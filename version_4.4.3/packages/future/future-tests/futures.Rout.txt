
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:19.036] plan(): Setting new future strategy stack:
[10:21:19.037] List of future strategies:
[10:21:19.037] 1. sequential:
[10:21:19.037]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.037]    - tweaked: FALSE
[10:21:19.037]    - call: future::plan("sequential")
[10:21:19.051] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[10:21:19.108] plan(): Setting new future strategy stack:
[10:21:19.108] List of future strategies:
[10:21:19.108] 1. sequential:
[10:21:19.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.108]    - tweaked: FALSE
[10:21:19.108]    - call: plan(strategy)
[10:21:19.121] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[10:21:19.122] getGlobalsAndPackages() ...
[10:21:19.122] Searching for globals...
[10:21:19.124] 
[10:21:19.124] Searching for globals ... DONE
[10:21:19.124] - globals: [0] <none>
[10:21:19.124] getGlobalsAndPackages() ... DONE
[10:21:19.125] run() for ‘Future’ ...
[10:21:19.125] - state: ‘created’
[10:21:19.125] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.125] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.125] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.125]   - Field: ‘label’
[10:21:19.126]   - Field: ‘local’
[10:21:19.126]   - Field: ‘owner’
[10:21:19.126]   - Field: ‘envir’
[10:21:19.126]   - Field: ‘packages’
[10:21:19.126]   - Field: ‘gc’
[10:21:19.126]   - Field: ‘conditions’
[10:21:19.126]   - Field: ‘expr’
[10:21:19.126]   - Field: ‘uuid’
[10:21:19.126]   - Field: ‘seed’
[10:21:19.126]   - Field: ‘version’
[10:21:19.126]   - Field: ‘result’
[10:21:19.126]   - Field: ‘asynchronous’
[10:21:19.127]   - Field: ‘calls’
[10:21:19.127]   - Field: ‘globals’
[10:21:19.127]   - Field: ‘stdout’
[10:21:19.127]   - Field: ‘earlySignal’
[10:21:19.127]   - Field: ‘lazy’
[10:21:19.127]   - Field: ‘state’
[10:21:19.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.127] - Launch lazy future ...
[10:21:19.128] Packages needed by the future expression (n = 0): <none>
[10:21:19.128] Packages needed by future strategies (n = 0): <none>
[10:21:19.129] {
[10:21:19.129]     {
[10:21:19.129]         {
[10:21:19.129]             ...future.startTime <- base::Sys.time()
[10:21:19.129]             {
[10:21:19.129]                 {
[10:21:19.129]                   {
[10:21:19.129]                     base::local({
[10:21:19.129]                       has_future <- base::requireNamespace("future", 
[10:21:19.129]                         quietly = TRUE)
[10:21:19.129]                       if (has_future) {
[10:21:19.129]                         ns <- base::getNamespace("future")
[10:21:19.129]                         version <- ns[[".package"]][["version"]]
[10:21:19.129]                         if (is.null(version)) 
[10:21:19.129]                           version <- utils::packageVersion("future")
[10:21:19.129]                       }
[10:21:19.129]                       else {
[10:21:19.129]                         version <- NULL
[10:21:19.129]                       }
[10:21:19.129]                       if (!has_future || version < "1.8.0") {
[10:21:19.129]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.129]                           "", base::R.version$version.string), 
[10:21:19.129]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.129]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.129]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.129]                             "release", "version")], collapse = " "), 
[10:21:19.129]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.129]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.129]                           info)
[10:21:19.129]                         info <- base::paste(info, collapse = "; ")
[10:21:19.129]                         if (!has_future) {
[10:21:19.129]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.129]                             info)
[10:21:19.129]                         }
[10:21:19.129]                         else {
[10:21:19.129]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.129]                             info, version)
[10:21:19.129]                         }
[10:21:19.129]                         base::stop(msg)
[10:21:19.129]                       }
[10:21:19.129]                     })
[10:21:19.129]                   }
[10:21:19.129]                   ...future.strategy.old <- future::plan("list")
[10:21:19.129]                   options(future.plan = NULL)
[10:21:19.129]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.129]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.129]                 }
[10:21:19.129]                 ...future.workdir <- getwd()
[10:21:19.129]             }
[10:21:19.129]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.129]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.129]         }
[10:21:19.129]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.129]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.129]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.129]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.129]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.129]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.129]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.129]             base::names(...future.oldOptions))
[10:21:19.129]     }
[10:21:19.129]     if (FALSE) {
[10:21:19.129]     }
[10:21:19.129]     else {
[10:21:19.129]         if (TRUE) {
[10:21:19.129]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.129]                 open = "w")
[10:21:19.129]         }
[10:21:19.129]         else {
[10:21:19.129]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.129]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.129]         }
[10:21:19.129]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.129]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.129]             base::sink(type = "output", split = FALSE)
[10:21:19.129]             base::close(...future.stdout)
[10:21:19.129]         }, add = TRUE)
[10:21:19.129]     }
[10:21:19.129]     ...future.frame <- base::sys.nframe()
[10:21:19.129]     ...future.conditions <- base::list()
[10:21:19.129]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.129]     if (FALSE) {
[10:21:19.129]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.129]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.129]     }
[10:21:19.129]     ...future.result <- base::tryCatch({
[10:21:19.129]         base::withCallingHandlers({
[10:21:19.129]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.129]             future::FutureResult(value = ...future.value$value, 
[10:21:19.129]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.129]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.129]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.129]                     ...future.globalenv.names))
[10:21:19.129]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.129]         }, condition = base::local({
[10:21:19.129]             c <- base::c
[10:21:19.129]             inherits <- base::inherits
[10:21:19.129]             invokeRestart <- base::invokeRestart
[10:21:19.129]             length <- base::length
[10:21:19.129]             list <- base::list
[10:21:19.129]             seq.int <- base::seq.int
[10:21:19.129]             signalCondition <- base::signalCondition
[10:21:19.129]             sys.calls <- base::sys.calls
[10:21:19.129]             `[[` <- base::`[[`
[10:21:19.129]             `+` <- base::`+`
[10:21:19.129]             `<<-` <- base::`<<-`
[10:21:19.129]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.129]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.129]                   3L)]
[10:21:19.129]             }
[10:21:19.129]             function(cond) {
[10:21:19.129]                 is_error <- inherits(cond, "error")
[10:21:19.129]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.129]                   NULL)
[10:21:19.129]                 if (is_error) {
[10:21:19.129]                   sessionInformation <- function() {
[10:21:19.129]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.129]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.129]                       search = base::search(), system = base::Sys.info())
[10:21:19.129]                   }
[10:21:19.129]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.129]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.129]                     cond$call), session = sessionInformation(), 
[10:21:19.129]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.129]                   signalCondition(cond)
[10:21:19.129]                 }
[10:21:19.129]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.129]                 "immediateCondition"))) {
[10:21:19.129]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.129]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.129]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.129]                   if (TRUE && !signal) {
[10:21:19.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.129]                     {
[10:21:19.129]                       inherits <- base::inherits
[10:21:19.129]                       invokeRestart <- base::invokeRestart
[10:21:19.129]                       is.null <- base::is.null
[10:21:19.129]                       muffled <- FALSE
[10:21:19.129]                       if (inherits(cond, "message")) {
[10:21:19.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.129]                         if (muffled) 
[10:21:19.129]                           invokeRestart("muffleMessage")
[10:21:19.129]                       }
[10:21:19.129]                       else if (inherits(cond, "warning")) {
[10:21:19.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.129]                         if (muffled) 
[10:21:19.129]                           invokeRestart("muffleWarning")
[10:21:19.129]                       }
[10:21:19.129]                       else if (inherits(cond, "condition")) {
[10:21:19.129]                         if (!is.null(pattern)) {
[10:21:19.129]                           computeRestarts <- base::computeRestarts
[10:21:19.129]                           grepl <- base::grepl
[10:21:19.129]                           restarts <- computeRestarts(cond)
[10:21:19.129]                           for (restart in restarts) {
[10:21:19.129]                             name <- restart$name
[10:21:19.129]                             if (is.null(name)) 
[10:21:19.129]                               next
[10:21:19.129]                             if (!grepl(pattern, name)) 
[10:21:19.129]                               next
[10:21:19.129]                             invokeRestart(restart)
[10:21:19.129]                             muffled <- TRUE
[10:21:19.129]                             break
[10:21:19.129]                           }
[10:21:19.129]                         }
[10:21:19.129]                       }
[10:21:19.129]                       invisible(muffled)
[10:21:19.129]                     }
[10:21:19.129]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.129]                   }
[10:21:19.129]                 }
[10:21:19.129]                 else {
[10:21:19.129]                   if (TRUE) {
[10:21:19.129]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.129]                     {
[10:21:19.129]                       inherits <- base::inherits
[10:21:19.129]                       invokeRestart <- base::invokeRestart
[10:21:19.129]                       is.null <- base::is.null
[10:21:19.129]                       muffled <- FALSE
[10:21:19.129]                       if (inherits(cond, "message")) {
[10:21:19.129]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.129]                         if (muffled) 
[10:21:19.129]                           invokeRestart("muffleMessage")
[10:21:19.129]                       }
[10:21:19.129]                       else if (inherits(cond, "warning")) {
[10:21:19.129]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.129]                         if (muffled) 
[10:21:19.129]                           invokeRestart("muffleWarning")
[10:21:19.129]                       }
[10:21:19.129]                       else if (inherits(cond, "condition")) {
[10:21:19.129]                         if (!is.null(pattern)) {
[10:21:19.129]                           computeRestarts <- base::computeRestarts
[10:21:19.129]                           grepl <- base::grepl
[10:21:19.129]                           restarts <- computeRestarts(cond)
[10:21:19.129]                           for (restart in restarts) {
[10:21:19.129]                             name <- restart$name
[10:21:19.129]                             if (is.null(name)) 
[10:21:19.129]                               next
[10:21:19.129]                             if (!grepl(pattern, name)) 
[10:21:19.129]                               next
[10:21:19.129]                             invokeRestart(restart)
[10:21:19.129]                             muffled <- TRUE
[10:21:19.129]                             break
[10:21:19.129]                           }
[10:21:19.129]                         }
[10:21:19.129]                       }
[10:21:19.129]                       invisible(muffled)
[10:21:19.129]                     }
[10:21:19.129]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.129]                   }
[10:21:19.129]                 }
[10:21:19.129]             }
[10:21:19.129]         }))
[10:21:19.129]     }, error = function(ex) {
[10:21:19.129]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.129]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.129]                 ...future.rng), started = ...future.startTime, 
[10:21:19.129]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.129]             version = "1.8"), class = "FutureResult")
[10:21:19.129]     }, finally = {
[10:21:19.129]         if (!identical(...future.workdir, getwd())) 
[10:21:19.129]             setwd(...future.workdir)
[10:21:19.129]         {
[10:21:19.129]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.129]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.129]             }
[10:21:19.129]             base::options(...future.oldOptions)
[10:21:19.129]             if (.Platform$OS.type == "windows") {
[10:21:19.129]                 old_names <- names(...future.oldEnvVars)
[10:21:19.129]                 envs <- base::Sys.getenv()
[10:21:19.129]                 names <- names(envs)
[10:21:19.129]                 common <- intersect(names, old_names)
[10:21:19.129]                 added <- setdiff(names, old_names)
[10:21:19.129]                 removed <- setdiff(old_names, names)
[10:21:19.129]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.129]                   envs[common]]
[10:21:19.129]                 NAMES <- toupper(changed)
[10:21:19.129]                 args <- list()
[10:21:19.129]                 for (kk in seq_along(NAMES)) {
[10:21:19.129]                   name <- changed[[kk]]
[10:21:19.129]                   NAME <- NAMES[[kk]]
[10:21:19.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.129]                     next
[10:21:19.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.129]                 }
[10:21:19.129]                 NAMES <- toupper(added)
[10:21:19.129]                 for (kk in seq_along(NAMES)) {
[10:21:19.129]                   name <- added[[kk]]
[10:21:19.129]                   NAME <- NAMES[[kk]]
[10:21:19.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.129]                     next
[10:21:19.129]                   args[[name]] <- ""
[10:21:19.129]                 }
[10:21:19.129]                 NAMES <- toupper(removed)
[10:21:19.129]                 for (kk in seq_along(NAMES)) {
[10:21:19.129]                   name <- removed[[kk]]
[10:21:19.129]                   NAME <- NAMES[[kk]]
[10:21:19.129]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.129]                     next
[10:21:19.129]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.129]                 }
[10:21:19.129]                 if (length(args) > 0) 
[10:21:19.129]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.129]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.129]             }
[10:21:19.129]             else {
[10:21:19.129]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.129]             }
[10:21:19.129]             {
[10:21:19.129]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.129]                   0L) {
[10:21:19.129]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.129]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.129]                   base::options(opts)
[10:21:19.129]                 }
[10:21:19.129]                 {
[10:21:19.129]                   {
[10:21:19.129]                     NULL
[10:21:19.129]                     RNGkind("Mersenne-Twister")
[10:21:19.129]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.129]                       inherits = FALSE)
[10:21:19.129]                   }
[10:21:19.129]                   options(future.plan = NULL)
[10:21:19.129]                   if (is.na(NA_character_)) 
[10:21:19.129]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.129]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.129]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.129]                     .init = FALSE)
[10:21:19.129]                 }
[10:21:19.129]             }
[10:21:19.129]         }
[10:21:19.129]     })
[10:21:19.129]     if (TRUE) {
[10:21:19.129]         base::sink(type = "output", split = FALSE)
[10:21:19.129]         if (TRUE) {
[10:21:19.129]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.129]         }
[10:21:19.129]         else {
[10:21:19.129]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.129]         }
[10:21:19.129]         base::close(...future.stdout)
[10:21:19.129]         ...future.stdout <- NULL
[10:21:19.129]     }
[10:21:19.129]     ...future.result$conditions <- ...future.conditions
[10:21:19.129]     ...future.result$finished <- base::Sys.time()
[10:21:19.129]     ...future.result
[10:21:19.129] }
[10:21:19.131] plan(): Setting new future strategy stack:
[10:21:19.131] List of future strategies:
[10:21:19.131] 1. sequential:
[10:21:19.131]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.131]    - tweaked: FALSE
[10:21:19.131]    - call: NULL
[10:21:19.131] plan(): nbrOfWorkers() = 1
[10:21:19.132] plan(): Setting new future strategy stack:
[10:21:19.132] List of future strategies:
[10:21:19.132] 1. sequential:
[10:21:19.132]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.132]    - tweaked: FALSE
[10:21:19.132]    - call: plan(strategy)
[10:21:19.133] plan(): nbrOfWorkers() = 1
[10:21:19.133] SequentialFuture started (and completed)
[10:21:19.134] - Launch lazy future ... done
[10:21:19.134] run() for ‘SequentialFuture’ ... done
[10:21:19.134] getGlobalsAndPackages() ...
[10:21:19.134] Searching for globals...
[10:21:19.134] 
[10:21:19.134] Searching for globals ... DONE
[10:21:19.134] - globals: [0] <none>
[10:21:19.134] getGlobalsAndPackages() ... DONE
[10:21:19.135] run() for ‘Future’ ...
[10:21:19.135] - state: ‘created’
[10:21:19.135] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.135] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.135]   - Field: ‘label’
[10:21:19.135]   - Field: ‘local’
[10:21:19.135]   - Field: ‘owner’
[10:21:19.136]   - Field: ‘envir’
[10:21:19.136]   - Field: ‘packages’
[10:21:19.136]   - Field: ‘gc’
[10:21:19.136]   - Field: ‘conditions’
[10:21:19.136]   - Field: ‘expr’
[10:21:19.136]   - Field: ‘uuid’
[10:21:19.136]   - Field: ‘seed’
[10:21:19.136]   - Field: ‘version’
[10:21:19.136]   - Field: ‘result’
[10:21:19.136]   - Field: ‘asynchronous’
[10:21:19.136]   - Field: ‘calls’
[10:21:19.136]   - Field: ‘globals’
[10:21:19.137]   - Field: ‘stdout’
[10:21:19.137]   - Field: ‘earlySignal’
[10:21:19.137]   - Field: ‘lazy’
[10:21:19.137]   - Field: ‘state’
[10:21:19.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.137] - Launch lazy future ...
[10:21:19.137] Packages needed by the future expression (n = 0): <none>
[10:21:19.137] Packages needed by future strategies (n = 0): <none>
[10:21:19.138] {
[10:21:19.138]     {
[10:21:19.138]         {
[10:21:19.138]             ...future.startTime <- base::Sys.time()
[10:21:19.138]             {
[10:21:19.138]                 {
[10:21:19.138]                   {
[10:21:19.138]                     base::local({
[10:21:19.138]                       has_future <- base::requireNamespace("future", 
[10:21:19.138]                         quietly = TRUE)
[10:21:19.138]                       if (has_future) {
[10:21:19.138]                         ns <- base::getNamespace("future")
[10:21:19.138]                         version <- ns[[".package"]][["version"]]
[10:21:19.138]                         if (is.null(version)) 
[10:21:19.138]                           version <- utils::packageVersion("future")
[10:21:19.138]                       }
[10:21:19.138]                       else {
[10:21:19.138]                         version <- NULL
[10:21:19.138]                       }
[10:21:19.138]                       if (!has_future || version < "1.8.0") {
[10:21:19.138]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.138]                           "", base::R.version$version.string), 
[10:21:19.138]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.138]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.138]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.138]                             "release", "version")], collapse = " "), 
[10:21:19.138]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.138]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.138]                           info)
[10:21:19.138]                         info <- base::paste(info, collapse = "; ")
[10:21:19.138]                         if (!has_future) {
[10:21:19.138]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.138]                             info)
[10:21:19.138]                         }
[10:21:19.138]                         else {
[10:21:19.138]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.138]                             info, version)
[10:21:19.138]                         }
[10:21:19.138]                         base::stop(msg)
[10:21:19.138]                       }
[10:21:19.138]                     })
[10:21:19.138]                   }
[10:21:19.138]                   ...future.strategy.old <- future::plan("list")
[10:21:19.138]                   options(future.plan = NULL)
[10:21:19.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.138]                 }
[10:21:19.138]                 ...future.workdir <- getwd()
[10:21:19.138]             }
[10:21:19.138]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.138]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.138]         }
[10:21:19.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.138]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.138]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.138]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.138]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.138]             base::names(...future.oldOptions))
[10:21:19.138]     }
[10:21:19.138]     if (FALSE) {
[10:21:19.138]     }
[10:21:19.138]     else {
[10:21:19.138]         if (TRUE) {
[10:21:19.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.138]                 open = "w")
[10:21:19.138]         }
[10:21:19.138]         else {
[10:21:19.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.138]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.138]         }
[10:21:19.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.138]             base::sink(type = "output", split = FALSE)
[10:21:19.138]             base::close(...future.stdout)
[10:21:19.138]         }, add = TRUE)
[10:21:19.138]     }
[10:21:19.138]     ...future.frame <- base::sys.nframe()
[10:21:19.138]     ...future.conditions <- base::list()
[10:21:19.138]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.138]     if (FALSE) {
[10:21:19.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.138]     }
[10:21:19.138]     ...future.result <- base::tryCatch({
[10:21:19.138]         base::withCallingHandlers({
[10:21:19.138]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.138]             future::FutureResult(value = ...future.value$value, 
[10:21:19.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.138]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.138]                     ...future.globalenv.names))
[10:21:19.138]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.138]         }, condition = base::local({
[10:21:19.138]             c <- base::c
[10:21:19.138]             inherits <- base::inherits
[10:21:19.138]             invokeRestart <- base::invokeRestart
[10:21:19.138]             length <- base::length
[10:21:19.138]             list <- base::list
[10:21:19.138]             seq.int <- base::seq.int
[10:21:19.138]             signalCondition <- base::signalCondition
[10:21:19.138]             sys.calls <- base::sys.calls
[10:21:19.138]             `[[` <- base::`[[`
[10:21:19.138]             `+` <- base::`+`
[10:21:19.138]             `<<-` <- base::`<<-`
[10:21:19.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.138]                   3L)]
[10:21:19.138]             }
[10:21:19.138]             function(cond) {
[10:21:19.138]                 is_error <- inherits(cond, "error")
[10:21:19.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.138]                   NULL)
[10:21:19.138]                 if (is_error) {
[10:21:19.138]                   sessionInformation <- function() {
[10:21:19.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.138]                       search = base::search(), system = base::Sys.info())
[10:21:19.138]                   }
[10:21:19.138]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.138]                     cond$call), session = sessionInformation(), 
[10:21:19.138]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.138]                   signalCondition(cond)
[10:21:19.138]                 }
[10:21:19.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.138]                 "immediateCondition"))) {
[10:21:19.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.138]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.138]                   if (TRUE && !signal) {
[10:21:19.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.138]                     {
[10:21:19.138]                       inherits <- base::inherits
[10:21:19.138]                       invokeRestart <- base::invokeRestart
[10:21:19.138]                       is.null <- base::is.null
[10:21:19.138]                       muffled <- FALSE
[10:21:19.138]                       if (inherits(cond, "message")) {
[10:21:19.138]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.138]                         if (muffled) 
[10:21:19.138]                           invokeRestart("muffleMessage")
[10:21:19.138]                       }
[10:21:19.138]                       else if (inherits(cond, "warning")) {
[10:21:19.138]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.138]                         if (muffled) 
[10:21:19.138]                           invokeRestart("muffleWarning")
[10:21:19.138]                       }
[10:21:19.138]                       else if (inherits(cond, "condition")) {
[10:21:19.138]                         if (!is.null(pattern)) {
[10:21:19.138]                           computeRestarts <- base::computeRestarts
[10:21:19.138]                           grepl <- base::grepl
[10:21:19.138]                           restarts <- computeRestarts(cond)
[10:21:19.138]                           for (restart in restarts) {
[10:21:19.138]                             name <- restart$name
[10:21:19.138]                             if (is.null(name)) 
[10:21:19.138]                               next
[10:21:19.138]                             if (!grepl(pattern, name)) 
[10:21:19.138]                               next
[10:21:19.138]                             invokeRestart(restart)
[10:21:19.138]                             muffled <- TRUE
[10:21:19.138]                             break
[10:21:19.138]                           }
[10:21:19.138]                         }
[10:21:19.138]                       }
[10:21:19.138]                       invisible(muffled)
[10:21:19.138]                     }
[10:21:19.138]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.138]                   }
[10:21:19.138]                 }
[10:21:19.138]                 else {
[10:21:19.138]                   if (TRUE) {
[10:21:19.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.138]                     {
[10:21:19.138]                       inherits <- base::inherits
[10:21:19.138]                       invokeRestart <- base::invokeRestart
[10:21:19.138]                       is.null <- base::is.null
[10:21:19.138]                       muffled <- FALSE
[10:21:19.138]                       if (inherits(cond, "message")) {
[10:21:19.138]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.138]                         if (muffled) 
[10:21:19.138]                           invokeRestart("muffleMessage")
[10:21:19.138]                       }
[10:21:19.138]                       else if (inherits(cond, "warning")) {
[10:21:19.138]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.138]                         if (muffled) 
[10:21:19.138]                           invokeRestart("muffleWarning")
[10:21:19.138]                       }
[10:21:19.138]                       else if (inherits(cond, "condition")) {
[10:21:19.138]                         if (!is.null(pattern)) {
[10:21:19.138]                           computeRestarts <- base::computeRestarts
[10:21:19.138]                           grepl <- base::grepl
[10:21:19.138]                           restarts <- computeRestarts(cond)
[10:21:19.138]                           for (restart in restarts) {
[10:21:19.138]                             name <- restart$name
[10:21:19.138]                             if (is.null(name)) 
[10:21:19.138]                               next
[10:21:19.138]                             if (!grepl(pattern, name)) 
[10:21:19.138]                               next
[10:21:19.138]                             invokeRestart(restart)
[10:21:19.138]                             muffled <- TRUE
[10:21:19.138]                             break
[10:21:19.138]                           }
[10:21:19.138]                         }
[10:21:19.138]                       }
[10:21:19.138]                       invisible(muffled)
[10:21:19.138]                     }
[10:21:19.138]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.138]                   }
[10:21:19.138]                 }
[10:21:19.138]             }
[10:21:19.138]         }))
[10:21:19.138]     }, error = function(ex) {
[10:21:19.138]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.138]                 ...future.rng), started = ...future.startTime, 
[10:21:19.138]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.138]             version = "1.8"), class = "FutureResult")
[10:21:19.138]     }, finally = {
[10:21:19.138]         if (!identical(...future.workdir, getwd())) 
[10:21:19.138]             setwd(...future.workdir)
[10:21:19.138]         {
[10:21:19.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.138]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.138]             }
[10:21:19.138]             base::options(...future.oldOptions)
[10:21:19.138]             if (.Platform$OS.type == "windows") {
[10:21:19.138]                 old_names <- names(...future.oldEnvVars)
[10:21:19.138]                 envs <- base::Sys.getenv()
[10:21:19.138]                 names <- names(envs)
[10:21:19.138]                 common <- intersect(names, old_names)
[10:21:19.138]                 added <- setdiff(names, old_names)
[10:21:19.138]                 removed <- setdiff(old_names, names)
[10:21:19.138]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.138]                   envs[common]]
[10:21:19.138]                 NAMES <- toupper(changed)
[10:21:19.138]                 args <- list()
[10:21:19.138]                 for (kk in seq_along(NAMES)) {
[10:21:19.138]                   name <- changed[[kk]]
[10:21:19.138]                   NAME <- NAMES[[kk]]
[10:21:19.138]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.138]                     next
[10:21:19.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.138]                 }
[10:21:19.138]                 NAMES <- toupper(added)
[10:21:19.138]                 for (kk in seq_along(NAMES)) {
[10:21:19.138]                   name <- added[[kk]]
[10:21:19.138]                   NAME <- NAMES[[kk]]
[10:21:19.138]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.138]                     next
[10:21:19.138]                   args[[name]] <- ""
[10:21:19.138]                 }
[10:21:19.138]                 NAMES <- toupper(removed)
[10:21:19.138]                 for (kk in seq_along(NAMES)) {
[10:21:19.138]                   name <- removed[[kk]]
[10:21:19.138]                   NAME <- NAMES[[kk]]
[10:21:19.138]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.138]                     next
[10:21:19.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.138]                 }
[10:21:19.138]                 if (length(args) > 0) 
[10:21:19.138]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.138]             }
[10:21:19.138]             else {
[10:21:19.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.138]             }
[10:21:19.138]             {
[10:21:19.138]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.138]                   0L) {
[10:21:19.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.138]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.138]                   base::options(opts)
[10:21:19.138]                 }
[10:21:19.138]                 {
[10:21:19.138]                   {
[10:21:19.138]                     NULL
[10:21:19.138]                     RNGkind("Mersenne-Twister")
[10:21:19.138]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.138]                       inherits = FALSE)
[10:21:19.138]                   }
[10:21:19.138]                   options(future.plan = NULL)
[10:21:19.138]                   if (is.na(NA_character_)) 
[10:21:19.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.138]                     .init = FALSE)
[10:21:19.138]                 }
[10:21:19.138]             }
[10:21:19.138]         }
[10:21:19.138]     })
[10:21:19.138]     if (TRUE) {
[10:21:19.138]         base::sink(type = "output", split = FALSE)
[10:21:19.138]         if (TRUE) {
[10:21:19.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.138]         }
[10:21:19.138]         else {
[10:21:19.138]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.138]         }
[10:21:19.138]         base::close(...future.stdout)
[10:21:19.138]         ...future.stdout <- NULL
[10:21:19.138]     }
[10:21:19.138]     ...future.result$conditions <- ...future.conditions
[10:21:19.138]     ...future.result$finished <- base::Sys.time()
[10:21:19.138]     ...future.result
[10:21:19.138] }
[10:21:19.139] plan(): Setting new future strategy stack:
[10:21:19.140] List of future strategies:
[10:21:19.140] 1. sequential:
[10:21:19.140]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.140]    - tweaked: FALSE
[10:21:19.140]    - call: NULL
[10:21:19.140] plan(): nbrOfWorkers() = 1
[10:21:19.141] plan(): Setting new future strategy stack:
[10:21:19.141] List of future strategies:
[10:21:19.141] 1. sequential:
[10:21:19.141]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.141]    - tweaked: FALSE
[10:21:19.141]    - call: plan(strategy)
[10:21:19.141] plan(): nbrOfWorkers() = 1
[10:21:19.141] SequentialFuture started (and completed)
[10:21:19.141] - Launch lazy future ... done
[10:21:19.142] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e3951538> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e4db3fc8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e3951538> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e4db3fc8> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:21:19.147] resolved() for ‘SequentialFuture’ ...
[10:21:19.147] - state: ‘finished’
[10:21:19.147] - run: TRUE
[10:21:19.147] - result: ‘FutureResult’
[10:21:19.147] resolved() for ‘SequentialFuture’ ... done
[10:21:19.148] resolved() for ‘SequentialFuture’ ...
[10:21:19.148] - state: ‘finished’
[10:21:19.148] - run: TRUE
[10:21:19.148] - result: ‘FutureResult’
[10:21:19.148] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:19.149] resolve() on list ...
[10:21:19.149]  recursive: 0
[10:21:19.149]  length: 6
[10:21:19.149]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:19.149] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.149] - nx: 6
[10:21:19.150] - relay: TRUE
[10:21:19.150] - stdout: TRUE
[10:21:19.150] - signal: TRUE
[10:21:19.150] - resignal: FALSE
[10:21:19.150] - force: TRUE
[10:21:19.150] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.150] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.150]  - until=2
[10:21:19.150]  - relaying element #2
[10:21:19.150] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.150] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.150] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.151]  length: 5 (resolved future 1)
[10:21:19.151] resolved() for ‘SequentialFuture’ ...
[10:21:19.151] - state: ‘finished’
[10:21:19.151] - run: TRUE
[10:21:19.151] - result: ‘FutureResult’
[10:21:19.151] resolved() for ‘SequentialFuture’ ... done
[10:21:19.151] Future #2
[10:21:19.151] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.152] - nx: 6
[10:21:19.152] - relay: TRUE
[10:21:19.152] - stdout: TRUE
[10:21:19.152] - signal: TRUE
[10:21:19.152] - resignal: FALSE
[10:21:19.152] - force: TRUE
[10:21:19.155] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.155] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.155]  - until=2
[10:21:19.155]  - relaying element #2
[10:21:19.155] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.155] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.155] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.155]  length: 4 (resolved future 2)
[10:21:19.156] resolved() for ‘SequentialFuture’ ...
[10:21:19.156] - state: ‘finished’
[10:21:19.156] - run: TRUE
[10:21:19.156] - result: ‘FutureResult’
[10:21:19.156] resolved() for ‘SequentialFuture’ ... done
[10:21:19.156] Future #3
[10:21:19.156] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.156] - nx: 6
[10:21:19.156] - relay: TRUE
[10:21:19.156] - stdout: TRUE
[10:21:19.156] - signal: TRUE
[10:21:19.157] - resignal: FALSE
[10:21:19.157] - force: TRUE
[10:21:19.157] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.157] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.157]  - until=3
[10:21:19.157]  - relaying element #3
[10:21:19.157] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.157] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.157] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.157]  length: 3 (resolved future 3)
[10:21:19.158] signalConditionsASAP(NULL, pos=4) ...
[10:21:19.158] - nx: 6
[10:21:19.158] - relay: TRUE
[10:21:19.158] - stdout: TRUE
[10:21:19.158] - signal: TRUE
[10:21:19.158] - resignal: FALSE
[10:21:19.158] - force: TRUE
[10:21:19.158] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.158] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.158]  - until=5
[10:21:19.158]  - relaying element #5
[10:21:19.158] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.158] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.159] signalConditionsASAP(NULL, pos=4) ... done
[10:21:19.159]  length: 2 (resolved future 4)
[10:21:19.159] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.159] - nx: 6
[10:21:19.159] - relay: TRUE
[10:21:19.159] - stdout: TRUE
[10:21:19.159] - signal: TRUE
[10:21:19.159] - resignal: FALSE
[10:21:19.159] - force: TRUE
[10:21:19.159] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.159] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.159]  - until=6
[10:21:19.160]  - relaying element #6
[10:21:19.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.160] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.160] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.160]  length: 1 (resolved future 5)
[10:21:19.160] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.160] - nx: 6
[10:21:19.160] - relay: TRUE
[10:21:19.160] - stdout: TRUE
[10:21:19.160] - signal: TRUE
[10:21:19.160] - resignal: FALSE
[10:21:19.160] - force: TRUE
[10:21:19.161] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.161] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.161]  - until=6
[10:21:19.161] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.161] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.161] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.161]  length: 0 (resolved future 6)
[10:21:19.161] Relaying remaining futures
[10:21:19.161] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.161] - nx: 6
[10:21:19.161] - relay: TRUE
[10:21:19.161] - stdout: TRUE
[10:21:19.161] - signal: TRUE
[10:21:19.162] - resignal: FALSE
[10:21:19.162] - force: TRUE
[10:21:19.162] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.162] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:19.162] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.162] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.162] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.162] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[10:21:19.164] getGlobalsAndPackages() ...
[10:21:19.164] Searching for globals...
[10:21:19.165] 
[10:21:19.165] Searching for globals ... DONE
[10:21:19.165] - globals: [0] <none>
[10:21:19.165] getGlobalsAndPackages() ... DONE
[10:21:19.165] run() for ‘Future’ ...
[10:21:19.165] - state: ‘created’
[10:21:19.165] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.166] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.166] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.166]   - Field: ‘label’
[10:21:19.166]   - Field: ‘local’
[10:21:19.166]   - Field: ‘owner’
[10:21:19.166]   - Field: ‘envir’
[10:21:19.166]   - Field: ‘packages’
[10:21:19.166]   - Field: ‘gc’
[10:21:19.166]   - Field: ‘conditions’
[10:21:19.166]   - Field: ‘expr’
[10:21:19.167]   - Field: ‘uuid’
[10:21:19.167]   - Field: ‘seed’
[10:21:19.167]   - Field: ‘version’
[10:21:19.167]   - Field: ‘result’
[10:21:19.167]   - Field: ‘asynchronous’
[10:21:19.167]   - Field: ‘calls’
[10:21:19.167]   - Field: ‘globals’
[10:21:19.167]   - Field: ‘stdout’
[10:21:19.167]   - Field: ‘earlySignal’
[10:21:19.167]   - Field: ‘lazy’
[10:21:19.167]   - Field: ‘state’
[10:21:19.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.168] - Launch lazy future ...
[10:21:19.168] Packages needed by the future expression (n = 0): <none>
[10:21:19.168] Packages needed by future strategies (n = 0): <none>
[10:21:19.168] {
[10:21:19.168]     {
[10:21:19.168]         {
[10:21:19.168]             ...future.startTime <- base::Sys.time()
[10:21:19.168]             {
[10:21:19.168]                 {
[10:21:19.168]                   {
[10:21:19.168]                     base::local({
[10:21:19.168]                       has_future <- base::requireNamespace("future", 
[10:21:19.168]                         quietly = TRUE)
[10:21:19.168]                       if (has_future) {
[10:21:19.168]                         ns <- base::getNamespace("future")
[10:21:19.168]                         version <- ns[[".package"]][["version"]]
[10:21:19.168]                         if (is.null(version)) 
[10:21:19.168]                           version <- utils::packageVersion("future")
[10:21:19.168]                       }
[10:21:19.168]                       else {
[10:21:19.168]                         version <- NULL
[10:21:19.168]                       }
[10:21:19.168]                       if (!has_future || version < "1.8.0") {
[10:21:19.168]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.168]                           "", base::R.version$version.string), 
[10:21:19.168]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.168]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.168]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.168]                             "release", "version")], collapse = " "), 
[10:21:19.168]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.168]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.168]                           info)
[10:21:19.168]                         info <- base::paste(info, collapse = "; ")
[10:21:19.168]                         if (!has_future) {
[10:21:19.168]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.168]                             info)
[10:21:19.168]                         }
[10:21:19.168]                         else {
[10:21:19.168]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.168]                             info, version)
[10:21:19.168]                         }
[10:21:19.168]                         base::stop(msg)
[10:21:19.168]                       }
[10:21:19.168]                     })
[10:21:19.168]                   }
[10:21:19.168]                   ...future.strategy.old <- future::plan("list")
[10:21:19.168]                   options(future.plan = NULL)
[10:21:19.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.168]                 }
[10:21:19.168]                 ...future.workdir <- getwd()
[10:21:19.168]             }
[10:21:19.168]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.168]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.168]         }
[10:21:19.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.168]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.168]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.168]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.168]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.168]             base::names(...future.oldOptions))
[10:21:19.168]     }
[10:21:19.168]     if (FALSE) {
[10:21:19.168]     }
[10:21:19.168]     else {
[10:21:19.168]         if (TRUE) {
[10:21:19.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.168]                 open = "w")
[10:21:19.168]         }
[10:21:19.168]         else {
[10:21:19.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.168]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.168]         }
[10:21:19.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.168]             base::sink(type = "output", split = FALSE)
[10:21:19.168]             base::close(...future.stdout)
[10:21:19.168]         }, add = TRUE)
[10:21:19.168]     }
[10:21:19.168]     ...future.frame <- base::sys.nframe()
[10:21:19.168]     ...future.conditions <- base::list()
[10:21:19.168]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.168]     if (FALSE) {
[10:21:19.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.168]     }
[10:21:19.168]     ...future.result <- base::tryCatch({
[10:21:19.168]         base::withCallingHandlers({
[10:21:19.168]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.168]             future::FutureResult(value = ...future.value$value, 
[10:21:19.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.168]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.168]                     ...future.globalenv.names))
[10:21:19.168]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.168]         }, condition = base::local({
[10:21:19.168]             c <- base::c
[10:21:19.168]             inherits <- base::inherits
[10:21:19.168]             invokeRestart <- base::invokeRestart
[10:21:19.168]             length <- base::length
[10:21:19.168]             list <- base::list
[10:21:19.168]             seq.int <- base::seq.int
[10:21:19.168]             signalCondition <- base::signalCondition
[10:21:19.168]             sys.calls <- base::sys.calls
[10:21:19.168]             `[[` <- base::`[[`
[10:21:19.168]             `+` <- base::`+`
[10:21:19.168]             `<<-` <- base::`<<-`
[10:21:19.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.168]                   3L)]
[10:21:19.168]             }
[10:21:19.168]             function(cond) {
[10:21:19.168]                 is_error <- inherits(cond, "error")
[10:21:19.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.168]                   NULL)
[10:21:19.168]                 if (is_error) {
[10:21:19.168]                   sessionInformation <- function() {
[10:21:19.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.168]                       search = base::search(), system = base::Sys.info())
[10:21:19.168]                   }
[10:21:19.168]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.168]                     cond$call), session = sessionInformation(), 
[10:21:19.168]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.168]                   signalCondition(cond)
[10:21:19.168]                 }
[10:21:19.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.168]                 "immediateCondition"))) {
[10:21:19.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.168]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.168]                   if (TRUE && !signal) {
[10:21:19.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.168]                     {
[10:21:19.168]                       inherits <- base::inherits
[10:21:19.168]                       invokeRestart <- base::invokeRestart
[10:21:19.168]                       is.null <- base::is.null
[10:21:19.168]                       muffled <- FALSE
[10:21:19.168]                       if (inherits(cond, "message")) {
[10:21:19.168]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.168]                         if (muffled) 
[10:21:19.168]                           invokeRestart("muffleMessage")
[10:21:19.168]                       }
[10:21:19.168]                       else if (inherits(cond, "warning")) {
[10:21:19.168]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.168]                         if (muffled) 
[10:21:19.168]                           invokeRestart("muffleWarning")
[10:21:19.168]                       }
[10:21:19.168]                       else if (inherits(cond, "condition")) {
[10:21:19.168]                         if (!is.null(pattern)) {
[10:21:19.168]                           computeRestarts <- base::computeRestarts
[10:21:19.168]                           grepl <- base::grepl
[10:21:19.168]                           restarts <- computeRestarts(cond)
[10:21:19.168]                           for (restart in restarts) {
[10:21:19.168]                             name <- restart$name
[10:21:19.168]                             if (is.null(name)) 
[10:21:19.168]                               next
[10:21:19.168]                             if (!grepl(pattern, name)) 
[10:21:19.168]                               next
[10:21:19.168]                             invokeRestart(restart)
[10:21:19.168]                             muffled <- TRUE
[10:21:19.168]                             break
[10:21:19.168]                           }
[10:21:19.168]                         }
[10:21:19.168]                       }
[10:21:19.168]                       invisible(muffled)
[10:21:19.168]                     }
[10:21:19.168]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.168]                   }
[10:21:19.168]                 }
[10:21:19.168]                 else {
[10:21:19.168]                   if (TRUE) {
[10:21:19.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.168]                     {
[10:21:19.168]                       inherits <- base::inherits
[10:21:19.168]                       invokeRestart <- base::invokeRestart
[10:21:19.168]                       is.null <- base::is.null
[10:21:19.168]                       muffled <- FALSE
[10:21:19.168]                       if (inherits(cond, "message")) {
[10:21:19.168]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.168]                         if (muffled) 
[10:21:19.168]                           invokeRestart("muffleMessage")
[10:21:19.168]                       }
[10:21:19.168]                       else if (inherits(cond, "warning")) {
[10:21:19.168]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.168]                         if (muffled) 
[10:21:19.168]                           invokeRestart("muffleWarning")
[10:21:19.168]                       }
[10:21:19.168]                       else if (inherits(cond, "condition")) {
[10:21:19.168]                         if (!is.null(pattern)) {
[10:21:19.168]                           computeRestarts <- base::computeRestarts
[10:21:19.168]                           grepl <- base::grepl
[10:21:19.168]                           restarts <- computeRestarts(cond)
[10:21:19.168]                           for (restart in restarts) {
[10:21:19.168]                             name <- restart$name
[10:21:19.168]                             if (is.null(name)) 
[10:21:19.168]                               next
[10:21:19.168]                             if (!grepl(pattern, name)) 
[10:21:19.168]                               next
[10:21:19.168]                             invokeRestart(restart)
[10:21:19.168]                             muffled <- TRUE
[10:21:19.168]                             break
[10:21:19.168]                           }
[10:21:19.168]                         }
[10:21:19.168]                       }
[10:21:19.168]                       invisible(muffled)
[10:21:19.168]                     }
[10:21:19.168]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.168]                   }
[10:21:19.168]                 }
[10:21:19.168]             }
[10:21:19.168]         }))
[10:21:19.168]     }, error = function(ex) {
[10:21:19.168]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.168]                 ...future.rng), started = ...future.startTime, 
[10:21:19.168]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.168]             version = "1.8"), class = "FutureResult")
[10:21:19.168]     }, finally = {
[10:21:19.168]         if (!identical(...future.workdir, getwd())) 
[10:21:19.168]             setwd(...future.workdir)
[10:21:19.168]         {
[10:21:19.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.168]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.168]             }
[10:21:19.168]             base::options(...future.oldOptions)
[10:21:19.168]             if (.Platform$OS.type == "windows") {
[10:21:19.168]                 old_names <- names(...future.oldEnvVars)
[10:21:19.168]                 envs <- base::Sys.getenv()
[10:21:19.168]                 names <- names(envs)
[10:21:19.168]                 common <- intersect(names, old_names)
[10:21:19.168]                 added <- setdiff(names, old_names)
[10:21:19.168]                 removed <- setdiff(old_names, names)
[10:21:19.168]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.168]                   envs[common]]
[10:21:19.168]                 NAMES <- toupper(changed)
[10:21:19.168]                 args <- list()
[10:21:19.168]                 for (kk in seq_along(NAMES)) {
[10:21:19.168]                   name <- changed[[kk]]
[10:21:19.168]                   NAME <- NAMES[[kk]]
[10:21:19.168]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.168]                     next
[10:21:19.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.168]                 }
[10:21:19.168]                 NAMES <- toupper(added)
[10:21:19.168]                 for (kk in seq_along(NAMES)) {
[10:21:19.168]                   name <- added[[kk]]
[10:21:19.168]                   NAME <- NAMES[[kk]]
[10:21:19.168]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.168]                     next
[10:21:19.168]                   args[[name]] <- ""
[10:21:19.168]                 }
[10:21:19.168]                 NAMES <- toupper(removed)
[10:21:19.168]                 for (kk in seq_along(NAMES)) {
[10:21:19.168]                   name <- removed[[kk]]
[10:21:19.168]                   NAME <- NAMES[[kk]]
[10:21:19.168]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.168]                     next
[10:21:19.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.168]                 }
[10:21:19.168]                 if (length(args) > 0) 
[10:21:19.168]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.168]             }
[10:21:19.168]             else {
[10:21:19.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.168]             }
[10:21:19.168]             {
[10:21:19.168]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.168]                   0L) {
[10:21:19.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.168]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.168]                   base::options(opts)
[10:21:19.168]                 }
[10:21:19.168]                 {
[10:21:19.168]                   {
[10:21:19.168]                     NULL
[10:21:19.168]                     RNGkind("Mersenne-Twister")
[10:21:19.168]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.168]                       inherits = FALSE)
[10:21:19.168]                   }
[10:21:19.168]                   options(future.plan = NULL)
[10:21:19.168]                   if (is.na(NA_character_)) 
[10:21:19.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.168]                     .init = FALSE)
[10:21:19.168]                 }
[10:21:19.168]             }
[10:21:19.168]         }
[10:21:19.168]     })
[10:21:19.168]     if (TRUE) {
[10:21:19.168]         base::sink(type = "output", split = FALSE)
[10:21:19.168]         if (TRUE) {
[10:21:19.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.168]         }
[10:21:19.168]         else {
[10:21:19.168]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.168]         }
[10:21:19.168]         base::close(...future.stdout)
[10:21:19.168]         ...future.stdout <- NULL
[10:21:19.168]     }
[10:21:19.168]     ...future.result$conditions <- ...future.conditions
[10:21:19.168]     ...future.result$finished <- base::Sys.time()
[10:21:19.168]     ...future.result
[10:21:19.168] }
[10:21:19.170] plan(): Setting new future strategy stack:
[10:21:19.170] List of future strategies:
[10:21:19.170] 1. sequential:
[10:21:19.170]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.170]    - tweaked: FALSE
[10:21:19.170]    - call: NULL
[10:21:19.171] plan(): nbrOfWorkers() = 1
[10:21:19.171] plan(): Setting new future strategy stack:
[10:21:19.171] List of future strategies:
[10:21:19.171] 1. sequential:
[10:21:19.171]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.171]    - tweaked: FALSE
[10:21:19.171]    - call: plan(strategy)
[10:21:19.172] plan(): nbrOfWorkers() = 1
[10:21:19.172] SequentialFuture started (and completed)
[10:21:19.172] - Launch lazy future ... done
[10:21:19.172] run() for ‘SequentialFuture’ ... done
[10:21:19.172] getGlobalsAndPackages() ...
[10:21:19.172] Searching for globals...
[10:21:19.173] 
[10:21:19.173] Searching for globals ... DONE
[10:21:19.173] - globals: [0] <none>
[10:21:19.173] getGlobalsAndPackages() ... DONE
[10:21:19.173] run() for ‘Future’ ...
[10:21:19.173] - state: ‘created’
[10:21:19.173] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.174] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.174] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.174]   - Field: ‘label’
[10:21:19.174]   - Field: ‘local’
[10:21:19.174]   - Field: ‘owner’
[10:21:19.174]   - Field: ‘envir’
[10:21:19.174]   - Field: ‘packages’
[10:21:19.174]   - Field: ‘gc’
[10:21:19.174]   - Field: ‘conditions’
[10:21:19.174]   - Field: ‘expr’
[10:21:19.175]   - Field: ‘uuid’
[10:21:19.175]   - Field: ‘seed’
[10:21:19.175]   - Field: ‘version’
[10:21:19.175]   - Field: ‘result’
[10:21:19.175]   - Field: ‘asynchronous’
[10:21:19.175]   - Field: ‘calls’
[10:21:19.175]   - Field: ‘globals’
[10:21:19.175]   - Field: ‘stdout’
[10:21:19.175]   - Field: ‘earlySignal’
[10:21:19.175]   - Field: ‘lazy’
[10:21:19.175]   - Field: ‘state’
[10:21:19.175] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.176] - Launch lazy future ...
[10:21:19.176] Packages needed by the future expression (n = 0): <none>
[10:21:19.176] Packages needed by future strategies (n = 0): <none>
[10:21:19.176] {
[10:21:19.176]     {
[10:21:19.176]         {
[10:21:19.176]             ...future.startTime <- base::Sys.time()
[10:21:19.176]             {
[10:21:19.176]                 {
[10:21:19.176]                   {
[10:21:19.176]                     base::local({
[10:21:19.176]                       has_future <- base::requireNamespace("future", 
[10:21:19.176]                         quietly = TRUE)
[10:21:19.176]                       if (has_future) {
[10:21:19.176]                         ns <- base::getNamespace("future")
[10:21:19.176]                         version <- ns[[".package"]][["version"]]
[10:21:19.176]                         if (is.null(version)) 
[10:21:19.176]                           version <- utils::packageVersion("future")
[10:21:19.176]                       }
[10:21:19.176]                       else {
[10:21:19.176]                         version <- NULL
[10:21:19.176]                       }
[10:21:19.176]                       if (!has_future || version < "1.8.0") {
[10:21:19.176]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.176]                           "", base::R.version$version.string), 
[10:21:19.176]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.176]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.176]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.176]                             "release", "version")], collapse = " "), 
[10:21:19.176]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.176]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.176]                           info)
[10:21:19.176]                         info <- base::paste(info, collapse = "; ")
[10:21:19.176]                         if (!has_future) {
[10:21:19.176]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.176]                             info)
[10:21:19.176]                         }
[10:21:19.176]                         else {
[10:21:19.176]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.176]                             info, version)
[10:21:19.176]                         }
[10:21:19.176]                         base::stop(msg)
[10:21:19.176]                       }
[10:21:19.176]                     })
[10:21:19.176]                   }
[10:21:19.176]                   ...future.strategy.old <- future::plan("list")
[10:21:19.176]                   options(future.plan = NULL)
[10:21:19.176]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.176]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.176]                 }
[10:21:19.176]                 ...future.workdir <- getwd()
[10:21:19.176]             }
[10:21:19.176]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.176]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.176]         }
[10:21:19.176]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.176]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.176]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.176]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.176]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.176]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.176]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.176]             base::names(...future.oldOptions))
[10:21:19.176]     }
[10:21:19.176]     if (FALSE) {
[10:21:19.176]     }
[10:21:19.176]     else {
[10:21:19.176]         if (TRUE) {
[10:21:19.176]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.176]                 open = "w")
[10:21:19.176]         }
[10:21:19.176]         else {
[10:21:19.176]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.176]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.176]         }
[10:21:19.176]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.176]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.176]             base::sink(type = "output", split = FALSE)
[10:21:19.176]             base::close(...future.stdout)
[10:21:19.176]         }, add = TRUE)
[10:21:19.176]     }
[10:21:19.176]     ...future.frame <- base::sys.nframe()
[10:21:19.176]     ...future.conditions <- base::list()
[10:21:19.176]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.176]     if (FALSE) {
[10:21:19.176]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.176]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.176]     }
[10:21:19.176]     ...future.result <- base::tryCatch({
[10:21:19.176]         base::withCallingHandlers({
[10:21:19.176]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.176]             future::FutureResult(value = ...future.value$value, 
[10:21:19.176]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.176]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.176]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.176]                     ...future.globalenv.names))
[10:21:19.176]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.176]         }, condition = base::local({
[10:21:19.176]             c <- base::c
[10:21:19.176]             inherits <- base::inherits
[10:21:19.176]             invokeRestart <- base::invokeRestart
[10:21:19.176]             length <- base::length
[10:21:19.176]             list <- base::list
[10:21:19.176]             seq.int <- base::seq.int
[10:21:19.176]             signalCondition <- base::signalCondition
[10:21:19.176]             sys.calls <- base::sys.calls
[10:21:19.176]             `[[` <- base::`[[`
[10:21:19.176]             `+` <- base::`+`
[10:21:19.176]             `<<-` <- base::`<<-`
[10:21:19.176]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.176]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.176]                   3L)]
[10:21:19.176]             }
[10:21:19.176]             function(cond) {
[10:21:19.176]                 is_error <- inherits(cond, "error")
[10:21:19.176]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.176]                   NULL)
[10:21:19.176]                 if (is_error) {
[10:21:19.176]                   sessionInformation <- function() {
[10:21:19.176]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.176]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.176]                       search = base::search(), system = base::Sys.info())
[10:21:19.176]                   }
[10:21:19.176]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.176]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.176]                     cond$call), session = sessionInformation(), 
[10:21:19.176]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.176]                   signalCondition(cond)
[10:21:19.176]                 }
[10:21:19.176]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.176]                 "immediateCondition"))) {
[10:21:19.176]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.176]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.176]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.176]                   if (TRUE && !signal) {
[10:21:19.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.176]                     {
[10:21:19.176]                       inherits <- base::inherits
[10:21:19.176]                       invokeRestart <- base::invokeRestart
[10:21:19.176]                       is.null <- base::is.null
[10:21:19.176]                       muffled <- FALSE
[10:21:19.176]                       if (inherits(cond, "message")) {
[10:21:19.176]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.176]                         if (muffled) 
[10:21:19.176]                           invokeRestart("muffleMessage")
[10:21:19.176]                       }
[10:21:19.176]                       else if (inherits(cond, "warning")) {
[10:21:19.176]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.176]                         if (muffled) 
[10:21:19.176]                           invokeRestart("muffleWarning")
[10:21:19.176]                       }
[10:21:19.176]                       else if (inherits(cond, "condition")) {
[10:21:19.176]                         if (!is.null(pattern)) {
[10:21:19.176]                           computeRestarts <- base::computeRestarts
[10:21:19.176]                           grepl <- base::grepl
[10:21:19.176]                           restarts <- computeRestarts(cond)
[10:21:19.176]                           for (restart in restarts) {
[10:21:19.176]                             name <- restart$name
[10:21:19.176]                             if (is.null(name)) 
[10:21:19.176]                               next
[10:21:19.176]                             if (!grepl(pattern, name)) 
[10:21:19.176]                               next
[10:21:19.176]                             invokeRestart(restart)
[10:21:19.176]                             muffled <- TRUE
[10:21:19.176]                             break
[10:21:19.176]                           }
[10:21:19.176]                         }
[10:21:19.176]                       }
[10:21:19.176]                       invisible(muffled)
[10:21:19.176]                     }
[10:21:19.176]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.176]                   }
[10:21:19.176]                 }
[10:21:19.176]                 else {
[10:21:19.176]                   if (TRUE) {
[10:21:19.176]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.176]                     {
[10:21:19.176]                       inherits <- base::inherits
[10:21:19.176]                       invokeRestart <- base::invokeRestart
[10:21:19.176]                       is.null <- base::is.null
[10:21:19.176]                       muffled <- FALSE
[10:21:19.176]                       if (inherits(cond, "message")) {
[10:21:19.176]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.176]                         if (muffled) 
[10:21:19.176]                           invokeRestart("muffleMessage")
[10:21:19.176]                       }
[10:21:19.176]                       else if (inherits(cond, "warning")) {
[10:21:19.176]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.176]                         if (muffled) 
[10:21:19.176]                           invokeRestart("muffleWarning")
[10:21:19.176]                       }
[10:21:19.176]                       else if (inherits(cond, "condition")) {
[10:21:19.176]                         if (!is.null(pattern)) {
[10:21:19.176]                           computeRestarts <- base::computeRestarts
[10:21:19.176]                           grepl <- base::grepl
[10:21:19.176]                           restarts <- computeRestarts(cond)
[10:21:19.176]                           for (restart in restarts) {
[10:21:19.176]                             name <- restart$name
[10:21:19.176]                             if (is.null(name)) 
[10:21:19.176]                               next
[10:21:19.176]                             if (!grepl(pattern, name)) 
[10:21:19.176]                               next
[10:21:19.176]                             invokeRestart(restart)
[10:21:19.176]                             muffled <- TRUE
[10:21:19.176]                             break
[10:21:19.176]                           }
[10:21:19.176]                         }
[10:21:19.176]                       }
[10:21:19.176]                       invisible(muffled)
[10:21:19.176]                     }
[10:21:19.176]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.176]                   }
[10:21:19.176]                 }
[10:21:19.176]             }
[10:21:19.176]         }))
[10:21:19.176]     }, error = function(ex) {
[10:21:19.176]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.176]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.176]                 ...future.rng), started = ...future.startTime, 
[10:21:19.176]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.176]             version = "1.8"), class = "FutureResult")
[10:21:19.176]     }, finally = {
[10:21:19.176]         if (!identical(...future.workdir, getwd())) 
[10:21:19.176]             setwd(...future.workdir)
[10:21:19.176]         {
[10:21:19.176]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.176]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.176]             }
[10:21:19.176]             base::options(...future.oldOptions)
[10:21:19.176]             if (.Platform$OS.type == "windows") {
[10:21:19.176]                 old_names <- names(...future.oldEnvVars)
[10:21:19.176]                 envs <- base::Sys.getenv()
[10:21:19.176]                 names <- names(envs)
[10:21:19.176]                 common <- intersect(names, old_names)
[10:21:19.176]                 added <- setdiff(names, old_names)
[10:21:19.176]                 removed <- setdiff(old_names, names)
[10:21:19.176]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.176]                   envs[common]]
[10:21:19.176]                 NAMES <- toupper(changed)
[10:21:19.176]                 args <- list()
[10:21:19.176]                 for (kk in seq_along(NAMES)) {
[10:21:19.176]                   name <- changed[[kk]]
[10:21:19.176]                   NAME <- NAMES[[kk]]
[10:21:19.176]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.176]                     next
[10:21:19.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.176]                 }
[10:21:19.176]                 NAMES <- toupper(added)
[10:21:19.176]                 for (kk in seq_along(NAMES)) {
[10:21:19.176]                   name <- added[[kk]]
[10:21:19.176]                   NAME <- NAMES[[kk]]
[10:21:19.176]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.176]                     next
[10:21:19.176]                   args[[name]] <- ""
[10:21:19.176]                 }
[10:21:19.176]                 NAMES <- toupper(removed)
[10:21:19.176]                 for (kk in seq_along(NAMES)) {
[10:21:19.176]                   name <- removed[[kk]]
[10:21:19.176]                   NAME <- NAMES[[kk]]
[10:21:19.176]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.176]                     next
[10:21:19.176]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.176]                 }
[10:21:19.176]                 if (length(args) > 0) 
[10:21:19.176]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.176]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.176]             }
[10:21:19.176]             else {
[10:21:19.176]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.176]             }
[10:21:19.176]             {
[10:21:19.176]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.176]                   0L) {
[10:21:19.176]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.176]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.176]                   base::options(opts)
[10:21:19.176]                 }
[10:21:19.176]                 {
[10:21:19.176]                   {
[10:21:19.176]                     NULL
[10:21:19.176]                     RNGkind("Mersenne-Twister")
[10:21:19.176]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.176]                       inherits = FALSE)
[10:21:19.176]                   }
[10:21:19.176]                   options(future.plan = NULL)
[10:21:19.176]                   if (is.na(NA_character_)) 
[10:21:19.176]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.176]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.176]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.176]                     .init = FALSE)
[10:21:19.176]                 }
[10:21:19.176]             }
[10:21:19.176]         }
[10:21:19.176]     })
[10:21:19.176]     if (TRUE) {
[10:21:19.176]         base::sink(type = "output", split = FALSE)
[10:21:19.176]         if (TRUE) {
[10:21:19.176]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.176]         }
[10:21:19.176]         else {
[10:21:19.176]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.176]         }
[10:21:19.176]         base::close(...future.stdout)
[10:21:19.176]         ...future.stdout <- NULL
[10:21:19.176]     }
[10:21:19.176]     ...future.result$conditions <- ...future.conditions
[10:21:19.176]     ...future.result$finished <- base::Sys.time()
[10:21:19.176]     ...future.result
[10:21:19.176] }
[10:21:19.178] plan(): Setting new future strategy stack:
[10:21:19.178] List of future strategies:
[10:21:19.178] 1. sequential:
[10:21:19.178]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.178]    - tweaked: FALSE
[10:21:19.178]    - call: NULL
[10:21:19.178] plan(): nbrOfWorkers() = 1
[10:21:19.179] plan(): Setting new future strategy stack:
[10:21:19.179] List of future strategies:
[10:21:19.179] 1. sequential:
[10:21:19.179]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.179]    - tweaked: FALSE
[10:21:19.179]    - call: plan(strategy)
[10:21:19.180] plan(): nbrOfWorkers() = 1
[10:21:19.180] SequentialFuture started (and completed)
[10:21:19.180] - Launch lazy future ... done
[10:21:19.180] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e4d06ab8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e510a790> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e4d06ab8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e510a790> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:21:19.186] resolved() for ‘SequentialFuture’ ...
[10:21:19.186] - state: ‘finished’
[10:21:19.187] - run: TRUE
[10:21:19.187] - result: ‘FutureResult’
[10:21:19.187] resolved() for ‘SequentialFuture’ ... done
[10:21:19.187] resolved() for ‘SequentialFuture’ ...
[10:21:19.187] - state: ‘finished’
[10:21:19.187] - run: TRUE
[10:21:19.187] - result: ‘FutureResult’
[10:21:19.187] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:19.189] resolve() on list ...
[10:21:19.189]  recursive: 0
[10:21:19.189]  length: 6
[10:21:19.189]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:19.189] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.189] - nx: 6
[10:21:19.189] - relay: TRUE
[10:21:19.190] - stdout: TRUE
[10:21:19.190] - signal: TRUE
[10:21:19.190] - resignal: FALSE
[10:21:19.190] - force: TRUE
[10:21:19.190] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.190] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.190]  - until=2
[10:21:19.190]  - relaying element #2
[10:21:19.190] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.190] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.190] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.190]  length: 5 (resolved future 1)
[10:21:19.191] resolved() for ‘SequentialFuture’ ...
[10:21:19.191] - state: ‘finished’
[10:21:19.191] - run: TRUE
[10:21:19.191] - result: ‘FutureResult’
[10:21:19.191] resolved() for ‘SequentialFuture’ ... done
[10:21:19.191] Future #2
[10:21:19.191] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.191] - nx: 6
[10:21:19.191] - relay: TRUE
[10:21:19.191] - stdout: TRUE
[10:21:19.191] - signal: TRUE
[10:21:19.191] - resignal: FALSE
[10:21:19.192] - force: TRUE
[10:21:19.192] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.192] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.192]  - until=2
[10:21:19.192]  - relaying element #2
[10:21:19.192] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.192] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.192] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.192]  length: 4 (resolved future 2)
[10:21:19.192] resolved() for ‘SequentialFuture’ ...
[10:21:19.193] - state: ‘finished’
[10:21:19.193] - run: TRUE
[10:21:19.193] - result: ‘FutureResult’
[10:21:19.193] resolved() for ‘SequentialFuture’ ... done
[10:21:19.193] Future #3
[10:21:19.193] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.193] - nx: 6
[10:21:19.193] - relay: TRUE
[10:21:19.193] - stdout: TRUE
[10:21:19.193] - signal: TRUE
[10:21:19.193] - resignal: FALSE
[10:21:19.193] - force: TRUE
[10:21:19.194] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.194] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.194]  - until=3
[10:21:19.194]  - relaying element #3
[10:21:19.194] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.194] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.194] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.194]  length: 3 (resolved future 3)
[10:21:19.194] signalConditionsASAP(NULL, pos=4) ...
[10:21:19.194] - nx: 6
[10:21:19.194] - relay: TRUE
[10:21:19.195] - stdout: TRUE
[10:21:19.195] - signal: TRUE
[10:21:19.195] - resignal: FALSE
[10:21:19.195] - force: TRUE
[10:21:19.195] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.195] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.195]  - until=5
[10:21:19.195]  - relaying element #5
[10:21:19.195] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.195] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.195] signalConditionsASAP(NULL, pos=4) ... done
[10:21:19.195]  length: 2 (resolved future 4)
[10:21:19.195] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.196] - nx: 6
[10:21:19.196] - relay: TRUE
[10:21:19.196] - stdout: TRUE
[10:21:19.196] - signal: TRUE
[10:21:19.196] - resignal: FALSE
[10:21:19.196] - force: TRUE
[10:21:19.196] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.196] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.196]  - until=6
[10:21:19.196]  - relaying element #6
[10:21:19.196] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.196] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.197] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.197]  length: 1 (resolved future 5)
[10:21:19.197] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.197] - nx: 6
[10:21:19.197] - relay: TRUE
[10:21:19.197] - stdout: TRUE
[10:21:19.197] - signal: TRUE
[10:21:19.197] - resignal: FALSE
[10:21:19.197] - force: TRUE
[10:21:19.197] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.197] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.197]  - until=6
[10:21:19.197] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.198] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.198] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.198]  length: 0 (resolved future 6)
[10:21:19.198] Relaying remaining futures
[10:21:19.198] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.198] - nx: 6
[10:21:19.198] - relay: TRUE
[10:21:19.198] - stdout: TRUE
[10:21:19.198] - signal: TRUE
[10:21:19.198] - resignal: FALSE
[10:21:19.198] - force: TRUE
[10:21:19.198] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.198] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:19.199] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.199] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.199] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.199] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:21:19.202] getGlobalsAndPackages() ...
[10:21:19.202] Searching for globals...
[10:21:19.202] 
[10:21:19.202] Searching for globals ... DONE
[10:21:19.202] - globals: [0] <none>
[10:21:19.202] getGlobalsAndPackages() ... DONE
[10:21:19.203] run() for ‘Future’ ...
[10:21:19.203] - state: ‘created’
[10:21:19.203] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.203] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.203] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.203]   - Field: ‘label’
[10:21:19.203]   - Field: ‘local’
[10:21:19.203]   - Field: ‘owner’
[10:21:19.204]   - Field: ‘envir’
[10:21:19.204]   - Field: ‘packages’
[10:21:19.204]   - Field: ‘gc’
[10:21:19.204]   - Field: ‘conditions’
[10:21:19.204]   - Field: ‘expr’
[10:21:19.204]   - Field: ‘uuid’
[10:21:19.204]   - Field: ‘seed’
[10:21:19.204]   - Field: ‘version’
[10:21:19.204]   - Field: ‘result’
[10:21:19.204]   - Field: ‘asynchronous’
[10:21:19.204]   - Field: ‘calls’
[10:21:19.204]   - Field: ‘globals’
[10:21:19.205]   - Field: ‘stdout’
[10:21:19.205]   - Field: ‘earlySignal’
[10:21:19.205]   - Field: ‘lazy’
[10:21:19.205]   - Field: ‘state’
[10:21:19.205] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.205] - Launch lazy future ...
[10:21:19.205] Packages needed by the future expression (n = 0): <none>
[10:21:19.205] Packages needed by future strategies (n = 0): <none>
[10:21:19.206] {
[10:21:19.206]     {
[10:21:19.206]         {
[10:21:19.206]             ...future.startTime <- base::Sys.time()
[10:21:19.206]             {
[10:21:19.206]                 {
[10:21:19.206]                   {
[10:21:19.206]                     base::local({
[10:21:19.206]                       has_future <- base::requireNamespace("future", 
[10:21:19.206]                         quietly = TRUE)
[10:21:19.206]                       if (has_future) {
[10:21:19.206]                         ns <- base::getNamespace("future")
[10:21:19.206]                         version <- ns[[".package"]][["version"]]
[10:21:19.206]                         if (is.null(version)) 
[10:21:19.206]                           version <- utils::packageVersion("future")
[10:21:19.206]                       }
[10:21:19.206]                       else {
[10:21:19.206]                         version <- NULL
[10:21:19.206]                       }
[10:21:19.206]                       if (!has_future || version < "1.8.0") {
[10:21:19.206]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.206]                           "", base::R.version$version.string), 
[10:21:19.206]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.206]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.206]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.206]                             "release", "version")], collapse = " "), 
[10:21:19.206]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.206]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.206]                           info)
[10:21:19.206]                         info <- base::paste(info, collapse = "; ")
[10:21:19.206]                         if (!has_future) {
[10:21:19.206]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.206]                             info)
[10:21:19.206]                         }
[10:21:19.206]                         else {
[10:21:19.206]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.206]                             info, version)
[10:21:19.206]                         }
[10:21:19.206]                         base::stop(msg)
[10:21:19.206]                       }
[10:21:19.206]                     })
[10:21:19.206]                   }
[10:21:19.206]                   ...future.strategy.old <- future::plan("list")
[10:21:19.206]                   options(future.plan = NULL)
[10:21:19.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.206]                 }
[10:21:19.206]                 ...future.workdir <- getwd()
[10:21:19.206]             }
[10:21:19.206]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.206]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.206]         }
[10:21:19.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.206]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.206]             base::names(...future.oldOptions))
[10:21:19.206]     }
[10:21:19.206]     if (FALSE) {
[10:21:19.206]     }
[10:21:19.206]     else {
[10:21:19.206]         if (TRUE) {
[10:21:19.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.206]                 open = "w")
[10:21:19.206]         }
[10:21:19.206]         else {
[10:21:19.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.206]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.206]         }
[10:21:19.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.206]             base::sink(type = "output", split = FALSE)
[10:21:19.206]             base::close(...future.stdout)
[10:21:19.206]         }, add = TRUE)
[10:21:19.206]     }
[10:21:19.206]     ...future.frame <- base::sys.nframe()
[10:21:19.206]     ...future.conditions <- base::list()
[10:21:19.206]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.206]     if (FALSE) {
[10:21:19.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.206]     }
[10:21:19.206]     ...future.result <- base::tryCatch({
[10:21:19.206]         base::withCallingHandlers({
[10:21:19.206]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.206]             future::FutureResult(value = ...future.value$value, 
[10:21:19.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.206]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.206]                     ...future.globalenv.names))
[10:21:19.206]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.206]         }, condition = base::local({
[10:21:19.206]             c <- base::c
[10:21:19.206]             inherits <- base::inherits
[10:21:19.206]             invokeRestart <- base::invokeRestart
[10:21:19.206]             length <- base::length
[10:21:19.206]             list <- base::list
[10:21:19.206]             seq.int <- base::seq.int
[10:21:19.206]             signalCondition <- base::signalCondition
[10:21:19.206]             sys.calls <- base::sys.calls
[10:21:19.206]             `[[` <- base::`[[`
[10:21:19.206]             `+` <- base::`+`
[10:21:19.206]             `<<-` <- base::`<<-`
[10:21:19.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.206]                   3L)]
[10:21:19.206]             }
[10:21:19.206]             function(cond) {
[10:21:19.206]                 is_error <- inherits(cond, "error")
[10:21:19.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.206]                   NULL)
[10:21:19.206]                 if (is_error) {
[10:21:19.206]                   sessionInformation <- function() {
[10:21:19.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.206]                       search = base::search(), system = base::Sys.info())
[10:21:19.206]                   }
[10:21:19.206]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.206]                     cond$call), session = sessionInformation(), 
[10:21:19.206]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.206]                   signalCondition(cond)
[10:21:19.206]                 }
[10:21:19.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.206]                 "immediateCondition"))) {
[10:21:19.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.206]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.206]                   if (TRUE && !signal) {
[10:21:19.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.206]                     {
[10:21:19.206]                       inherits <- base::inherits
[10:21:19.206]                       invokeRestart <- base::invokeRestart
[10:21:19.206]                       is.null <- base::is.null
[10:21:19.206]                       muffled <- FALSE
[10:21:19.206]                       if (inherits(cond, "message")) {
[10:21:19.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.206]                         if (muffled) 
[10:21:19.206]                           invokeRestart("muffleMessage")
[10:21:19.206]                       }
[10:21:19.206]                       else if (inherits(cond, "warning")) {
[10:21:19.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.206]                         if (muffled) 
[10:21:19.206]                           invokeRestart("muffleWarning")
[10:21:19.206]                       }
[10:21:19.206]                       else if (inherits(cond, "condition")) {
[10:21:19.206]                         if (!is.null(pattern)) {
[10:21:19.206]                           computeRestarts <- base::computeRestarts
[10:21:19.206]                           grepl <- base::grepl
[10:21:19.206]                           restarts <- computeRestarts(cond)
[10:21:19.206]                           for (restart in restarts) {
[10:21:19.206]                             name <- restart$name
[10:21:19.206]                             if (is.null(name)) 
[10:21:19.206]                               next
[10:21:19.206]                             if (!grepl(pattern, name)) 
[10:21:19.206]                               next
[10:21:19.206]                             invokeRestart(restart)
[10:21:19.206]                             muffled <- TRUE
[10:21:19.206]                             break
[10:21:19.206]                           }
[10:21:19.206]                         }
[10:21:19.206]                       }
[10:21:19.206]                       invisible(muffled)
[10:21:19.206]                     }
[10:21:19.206]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.206]                   }
[10:21:19.206]                 }
[10:21:19.206]                 else {
[10:21:19.206]                   if (TRUE) {
[10:21:19.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.206]                     {
[10:21:19.206]                       inherits <- base::inherits
[10:21:19.206]                       invokeRestart <- base::invokeRestart
[10:21:19.206]                       is.null <- base::is.null
[10:21:19.206]                       muffled <- FALSE
[10:21:19.206]                       if (inherits(cond, "message")) {
[10:21:19.206]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.206]                         if (muffled) 
[10:21:19.206]                           invokeRestart("muffleMessage")
[10:21:19.206]                       }
[10:21:19.206]                       else if (inherits(cond, "warning")) {
[10:21:19.206]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.206]                         if (muffled) 
[10:21:19.206]                           invokeRestart("muffleWarning")
[10:21:19.206]                       }
[10:21:19.206]                       else if (inherits(cond, "condition")) {
[10:21:19.206]                         if (!is.null(pattern)) {
[10:21:19.206]                           computeRestarts <- base::computeRestarts
[10:21:19.206]                           grepl <- base::grepl
[10:21:19.206]                           restarts <- computeRestarts(cond)
[10:21:19.206]                           for (restart in restarts) {
[10:21:19.206]                             name <- restart$name
[10:21:19.206]                             if (is.null(name)) 
[10:21:19.206]                               next
[10:21:19.206]                             if (!grepl(pattern, name)) 
[10:21:19.206]                               next
[10:21:19.206]                             invokeRestart(restart)
[10:21:19.206]                             muffled <- TRUE
[10:21:19.206]                             break
[10:21:19.206]                           }
[10:21:19.206]                         }
[10:21:19.206]                       }
[10:21:19.206]                       invisible(muffled)
[10:21:19.206]                     }
[10:21:19.206]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.206]                   }
[10:21:19.206]                 }
[10:21:19.206]             }
[10:21:19.206]         }))
[10:21:19.206]     }, error = function(ex) {
[10:21:19.206]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.206]                 ...future.rng), started = ...future.startTime, 
[10:21:19.206]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.206]             version = "1.8"), class = "FutureResult")
[10:21:19.206]     }, finally = {
[10:21:19.206]         if (!identical(...future.workdir, getwd())) 
[10:21:19.206]             setwd(...future.workdir)
[10:21:19.206]         {
[10:21:19.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.206]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.206]             }
[10:21:19.206]             base::options(...future.oldOptions)
[10:21:19.206]             if (.Platform$OS.type == "windows") {
[10:21:19.206]                 old_names <- names(...future.oldEnvVars)
[10:21:19.206]                 envs <- base::Sys.getenv()
[10:21:19.206]                 names <- names(envs)
[10:21:19.206]                 common <- intersect(names, old_names)
[10:21:19.206]                 added <- setdiff(names, old_names)
[10:21:19.206]                 removed <- setdiff(old_names, names)
[10:21:19.206]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.206]                   envs[common]]
[10:21:19.206]                 NAMES <- toupper(changed)
[10:21:19.206]                 args <- list()
[10:21:19.206]                 for (kk in seq_along(NAMES)) {
[10:21:19.206]                   name <- changed[[kk]]
[10:21:19.206]                   NAME <- NAMES[[kk]]
[10:21:19.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.206]                     next
[10:21:19.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.206]                 }
[10:21:19.206]                 NAMES <- toupper(added)
[10:21:19.206]                 for (kk in seq_along(NAMES)) {
[10:21:19.206]                   name <- added[[kk]]
[10:21:19.206]                   NAME <- NAMES[[kk]]
[10:21:19.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.206]                     next
[10:21:19.206]                   args[[name]] <- ""
[10:21:19.206]                 }
[10:21:19.206]                 NAMES <- toupper(removed)
[10:21:19.206]                 for (kk in seq_along(NAMES)) {
[10:21:19.206]                   name <- removed[[kk]]
[10:21:19.206]                   NAME <- NAMES[[kk]]
[10:21:19.206]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.206]                     next
[10:21:19.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.206]                 }
[10:21:19.206]                 if (length(args) > 0) 
[10:21:19.206]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.206]             }
[10:21:19.206]             else {
[10:21:19.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.206]             }
[10:21:19.206]             {
[10:21:19.206]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.206]                   0L) {
[10:21:19.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.206]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.206]                   base::options(opts)
[10:21:19.206]                 }
[10:21:19.206]                 {
[10:21:19.206]                   {
[10:21:19.206]                     NULL
[10:21:19.206]                     RNGkind("Mersenne-Twister")
[10:21:19.206]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.206]                       inherits = FALSE)
[10:21:19.206]                   }
[10:21:19.206]                   options(future.plan = NULL)
[10:21:19.206]                   if (is.na(NA_character_)) 
[10:21:19.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.206]                     .init = FALSE)
[10:21:19.206]                 }
[10:21:19.206]             }
[10:21:19.206]         }
[10:21:19.206]     })
[10:21:19.206]     if (TRUE) {
[10:21:19.206]         base::sink(type = "output", split = FALSE)
[10:21:19.206]         if (TRUE) {
[10:21:19.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.206]         }
[10:21:19.206]         else {
[10:21:19.206]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.206]         }
[10:21:19.206]         base::close(...future.stdout)
[10:21:19.206]         ...future.stdout <- NULL
[10:21:19.206]     }
[10:21:19.206]     ...future.result$conditions <- ...future.conditions
[10:21:19.206]     ...future.result$finished <- base::Sys.time()
[10:21:19.206]     ...future.result
[10:21:19.206] }
[10:21:19.207] plan(): Setting new future strategy stack:
[10:21:19.207] List of future strategies:
[10:21:19.207] 1. sequential:
[10:21:19.207]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.207]    - tweaked: FALSE
[10:21:19.207]    - call: NULL
[10:21:19.208] plan(): nbrOfWorkers() = 1
[10:21:19.209] plan(): Setting new future strategy stack:
[10:21:19.209] List of future strategies:
[10:21:19.209] 1. sequential:
[10:21:19.209]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.209]    - tweaked: FALSE
[10:21:19.209]    - call: plan(strategy)
[10:21:19.209] plan(): nbrOfWorkers() = 1
[10:21:19.209] SequentialFuture started (and completed)
[10:21:19.209] - Launch lazy future ... done
[10:21:19.209] run() for ‘SequentialFuture’ ... done
[10:21:19.210] getGlobalsAndPackages() ...
[10:21:19.210] Searching for globals...
[10:21:19.211] 
[10:21:19.211] Searching for globals ... DONE
[10:21:19.211] - globals: [0] <none>
[10:21:19.211] getGlobalsAndPackages() ... DONE
[10:21:19.212] run() for ‘Future’ ...
[10:21:19.212] - state: ‘created’
[10:21:19.212] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.212] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.212] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.212]   - Field: ‘label’
[10:21:19.212]   - Field: ‘local’
[10:21:19.213]   - Field: ‘owner’
[10:21:19.213]   - Field: ‘envir’
[10:21:19.213]   - Field: ‘packages’
[10:21:19.213]   - Field: ‘gc’
[10:21:19.213]   - Field: ‘conditions’
[10:21:19.213]   - Field: ‘expr’
[10:21:19.213]   - Field: ‘uuid’
[10:21:19.213]   - Field: ‘seed’
[10:21:19.213]   - Field: ‘version’
[10:21:19.213]   - Field: ‘result’
[10:21:19.213]   - Field: ‘asynchronous’
[10:21:19.213]   - Field: ‘calls’
[10:21:19.214]   - Field: ‘globals’
[10:21:19.214]   - Field: ‘stdout’
[10:21:19.214]   - Field: ‘earlySignal’
[10:21:19.214]   - Field: ‘lazy’
[10:21:19.214]   - Field: ‘state’
[10:21:19.214] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.214] - Launch lazy future ...
[10:21:19.214] Packages needed by the future expression (n = 0): <none>
[10:21:19.214] Packages needed by future strategies (n = 0): <none>
[10:21:19.215] {
[10:21:19.215]     {
[10:21:19.215]         {
[10:21:19.215]             ...future.startTime <- base::Sys.time()
[10:21:19.215]             {
[10:21:19.215]                 {
[10:21:19.215]                   {
[10:21:19.215]                     base::local({
[10:21:19.215]                       has_future <- base::requireNamespace("future", 
[10:21:19.215]                         quietly = TRUE)
[10:21:19.215]                       if (has_future) {
[10:21:19.215]                         ns <- base::getNamespace("future")
[10:21:19.215]                         version <- ns[[".package"]][["version"]]
[10:21:19.215]                         if (is.null(version)) 
[10:21:19.215]                           version <- utils::packageVersion("future")
[10:21:19.215]                       }
[10:21:19.215]                       else {
[10:21:19.215]                         version <- NULL
[10:21:19.215]                       }
[10:21:19.215]                       if (!has_future || version < "1.8.0") {
[10:21:19.215]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.215]                           "", base::R.version$version.string), 
[10:21:19.215]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.215]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.215]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.215]                             "release", "version")], collapse = " "), 
[10:21:19.215]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.215]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.215]                           info)
[10:21:19.215]                         info <- base::paste(info, collapse = "; ")
[10:21:19.215]                         if (!has_future) {
[10:21:19.215]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.215]                             info)
[10:21:19.215]                         }
[10:21:19.215]                         else {
[10:21:19.215]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.215]                             info, version)
[10:21:19.215]                         }
[10:21:19.215]                         base::stop(msg)
[10:21:19.215]                       }
[10:21:19.215]                     })
[10:21:19.215]                   }
[10:21:19.215]                   ...future.strategy.old <- future::plan("list")
[10:21:19.215]                   options(future.plan = NULL)
[10:21:19.215]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.215]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.215]                 }
[10:21:19.215]                 ...future.workdir <- getwd()
[10:21:19.215]             }
[10:21:19.215]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.215]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.215]         }
[10:21:19.215]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.215]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.215]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.215]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.215]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.215]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.215]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.215]             base::names(...future.oldOptions))
[10:21:19.215]     }
[10:21:19.215]     if (FALSE) {
[10:21:19.215]     }
[10:21:19.215]     else {
[10:21:19.215]         if (TRUE) {
[10:21:19.215]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.215]                 open = "w")
[10:21:19.215]         }
[10:21:19.215]         else {
[10:21:19.215]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.215]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.215]         }
[10:21:19.215]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.215]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.215]             base::sink(type = "output", split = FALSE)
[10:21:19.215]             base::close(...future.stdout)
[10:21:19.215]         }, add = TRUE)
[10:21:19.215]     }
[10:21:19.215]     ...future.frame <- base::sys.nframe()
[10:21:19.215]     ...future.conditions <- base::list()
[10:21:19.215]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.215]     if (FALSE) {
[10:21:19.215]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.215]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.215]     }
[10:21:19.215]     ...future.result <- base::tryCatch({
[10:21:19.215]         base::withCallingHandlers({
[10:21:19.215]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.215]             future::FutureResult(value = ...future.value$value, 
[10:21:19.215]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.215]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.215]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.215]                     ...future.globalenv.names))
[10:21:19.215]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.215]         }, condition = base::local({
[10:21:19.215]             c <- base::c
[10:21:19.215]             inherits <- base::inherits
[10:21:19.215]             invokeRestart <- base::invokeRestart
[10:21:19.215]             length <- base::length
[10:21:19.215]             list <- base::list
[10:21:19.215]             seq.int <- base::seq.int
[10:21:19.215]             signalCondition <- base::signalCondition
[10:21:19.215]             sys.calls <- base::sys.calls
[10:21:19.215]             `[[` <- base::`[[`
[10:21:19.215]             `+` <- base::`+`
[10:21:19.215]             `<<-` <- base::`<<-`
[10:21:19.215]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.215]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.215]                   3L)]
[10:21:19.215]             }
[10:21:19.215]             function(cond) {
[10:21:19.215]                 is_error <- inherits(cond, "error")
[10:21:19.215]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.215]                   NULL)
[10:21:19.215]                 if (is_error) {
[10:21:19.215]                   sessionInformation <- function() {
[10:21:19.215]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.215]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.215]                       search = base::search(), system = base::Sys.info())
[10:21:19.215]                   }
[10:21:19.215]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.215]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.215]                     cond$call), session = sessionInformation(), 
[10:21:19.215]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.215]                   signalCondition(cond)
[10:21:19.215]                 }
[10:21:19.215]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.215]                 "immediateCondition"))) {
[10:21:19.215]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.215]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.215]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.215]                   if (TRUE && !signal) {
[10:21:19.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.215]                     {
[10:21:19.215]                       inherits <- base::inherits
[10:21:19.215]                       invokeRestart <- base::invokeRestart
[10:21:19.215]                       is.null <- base::is.null
[10:21:19.215]                       muffled <- FALSE
[10:21:19.215]                       if (inherits(cond, "message")) {
[10:21:19.215]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.215]                         if (muffled) 
[10:21:19.215]                           invokeRestart("muffleMessage")
[10:21:19.215]                       }
[10:21:19.215]                       else if (inherits(cond, "warning")) {
[10:21:19.215]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.215]                         if (muffled) 
[10:21:19.215]                           invokeRestart("muffleWarning")
[10:21:19.215]                       }
[10:21:19.215]                       else if (inherits(cond, "condition")) {
[10:21:19.215]                         if (!is.null(pattern)) {
[10:21:19.215]                           computeRestarts <- base::computeRestarts
[10:21:19.215]                           grepl <- base::grepl
[10:21:19.215]                           restarts <- computeRestarts(cond)
[10:21:19.215]                           for (restart in restarts) {
[10:21:19.215]                             name <- restart$name
[10:21:19.215]                             if (is.null(name)) 
[10:21:19.215]                               next
[10:21:19.215]                             if (!grepl(pattern, name)) 
[10:21:19.215]                               next
[10:21:19.215]                             invokeRestart(restart)
[10:21:19.215]                             muffled <- TRUE
[10:21:19.215]                             break
[10:21:19.215]                           }
[10:21:19.215]                         }
[10:21:19.215]                       }
[10:21:19.215]                       invisible(muffled)
[10:21:19.215]                     }
[10:21:19.215]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.215]                   }
[10:21:19.215]                 }
[10:21:19.215]                 else {
[10:21:19.215]                   if (TRUE) {
[10:21:19.215]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.215]                     {
[10:21:19.215]                       inherits <- base::inherits
[10:21:19.215]                       invokeRestart <- base::invokeRestart
[10:21:19.215]                       is.null <- base::is.null
[10:21:19.215]                       muffled <- FALSE
[10:21:19.215]                       if (inherits(cond, "message")) {
[10:21:19.215]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.215]                         if (muffled) 
[10:21:19.215]                           invokeRestart("muffleMessage")
[10:21:19.215]                       }
[10:21:19.215]                       else if (inherits(cond, "warning")) {
[10:21:19.215]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.215]                         if (muffled) 
[10:21:19.215]                           invokeRestart("muffleWarning")
[10:21:19.215]                       }
[10:21:19.215]                       else if (inherits(cond, "condition")) {
[10:21:19.215]                         if (!is.null(pattern)) {
[10:21:19.215]                           computeRestarts <- base::computeRestarts
[10:21:19.215]                           grepl <- base::grepl
[10:21:19.215]                           restarts <- computeRestarts(cond)
[10:21:19.215]                           for (restart in restarts) {
[10:21:19.215]                             name <- restart$name
[10:21:19.215]                             if (is.null(name)) 
[10:21:19.215]                               next
[10:21:19.215]                             if (!grepl(pattern, name)) 
[10:21:19.215]                               next
[10:21:19.215]                             invokeRestart(restart)
[10:21:19.215]                             muffled <- TRUE
[10:21:19.215]                             break
[10:21:19.215]                           }
[10:21:19.215]                         }
[10:21:19.215]                       }
[10:21:19.215]                       invisible(muffled)
[10:21:19.215]                     }
[10:21:19.215]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.215]                   }
[10:21:19.215]                 }
[10:21:19.215]             }
[10:21:19.215]         }))
[10:21:19.215]     }, error = function(ex) {
[10:21:19.215]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.215]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.215]                 ...future.rng), started = ...future.startTime, 
[10:21:19.215]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.215]             version = "1.8"), class = "FutureResult")
[10:21:19.215]     }, finally = {
[10:21:19.215]         if (!identical(...future.workdir, getwd())) 
[10:21:19.215]             setwd(...future.workdir)
[10:21:19.215]         {
[10:21:19.215]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.215]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.215]             }
[10:21:19.215]             base::options(...future.oldOptions)
[10:21:19.215]             if (.Platform$OS.type == "windows") {
[10:21:19.215]                 old_names <- names(...future.oldEnvVars)
[10:21:19.215]                 envs <- base::Sys.getenv()
[10:21:19.215]                 names <- names(envs)
[10:21:19.215]                 common <- intersect(names, old_names)
[10:21:19.215]                 added <- setdiff(names, old_names)
[10:21:19.215]                 removed <- setdiff(old_names, names)
[10:21:19.215]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.215]                   envs[common]]
[10:21:19.215]                 NAMES <- toupper(changed)
[10:21:19.215]                 args <- list()
[10:21:19.215]                 for (kk in seq_along(NAMES)) {
[10:21:19.215]                   name <- changed[[kk]]
[10:21:19.215]                   NAME <- NAMES[[kk]]
[10:21:19.215]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.215]                     next
[10:21:19.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.215]                 }
[10:21:19.215]                 NAMES <- toupper(added)
[10:21:19.215]                 for (kk in seq_along(NAMES)) {
[10:21:19.215]                   name <- added[[kk]]
[10:21:19.215]                   NAME <- NAMES[[kk]]
[10:21:19.215]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.215]                     next
[10:21:19.215]                   args[[name]] <- ""
[10:21:19.215]                 }
[10:21:19.215]                 NAMES <- toupper(removed)
[10:21:19.215]                 for (kk in seq_along(NAMES)) {
[10:21:19.215]                   name <- removed[[kk]]
[10:21:19.215]                   NAME <- NAMES[[kk]]
[10:21:19.215]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.215]                     next
[10:21:19.215]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.215]                 }
[10:21:19.215]                 if (length(args) > 0) 
[10:21:19.215]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.215]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.215]             }
[10:21:19.215]             else {
[10:21:19.215]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.215]             }
[10:21:19.215]             {
[10:21:19.215]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.215]                   0L) {
[10:21:19.215]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.215]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.215]                   base::options(opts)
[10:21:19.215]                 }
[10:21:19.215]                 {
[10:21:19.215]                   {
[10:21:19.215]                     NULL
[10:21:19.215]                     RNGkind("Mersenne-Twister")
[10:21:19.215]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.215]                       inherits = FALSE)
[10:21:19.215]                   }
[10:21:19.215]                   options(future.plan = NULL)
[10:21:19.215]                   if (is.na(NA_character_)) 
[10:21:19.215]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.215]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.215]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.215]                     .init = FALSE)
[10:21:19.215]                 }
[10:21:19.215]             }
[10:21:19.215]         }
[10:21:19.215]     })
[10:21:19.215]     if (TRUE) {
[10:21:19.215]         base::sink(type = "output", split = FALSE)
[10:21:19.215]         if (TRUE) {
[10:21:19.215]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.215]         }
[10:21:19.215]         else {
[10:21:19.215]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.215]         }
[10:21:19.215]         base::close(...future.stdout)
[10:21:19.215]         ...future.stdout <- NULL
[10:21:19.215]     }
[10:21:19.215]     ...future.result$conditions <- ...future.conditions
[10:21:19.215]     ...future.result$finished <- base::Sys.time()
[10:21:19.215]     ...future.result
[10:21:19.215] }
[10:21:19.217] plan(): Setting new future strategy stack:
[10:21:19.217] List of future strategies:
[10:21:19.217] 1. sequential:
[10:21:19.217]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.217]    - tweaked: FALSE
[10:21:19.217]    - call: NULL
[10:21:19.217] plan(): nbrOfWorkers() = 1
[10:21:19.218] plan(): Setting new future strategy stack:
[10:21:19.218] List of future strategies:
[10:21:19.218] 1. sequential:
[10:21:19.218]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.218]    - tweaked: FALSE
[10:21:19.218]    - call: plan(strategy)
[10:21:19.218] plan(): nbrOfWorkers() = 1
[10:21:19.218] SequentialFuture started (and completed)
[10:21:19.219] - Launch lazy future ... done
[10:21:19.219] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e52c9be8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e44a0b08> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e52c9be8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e44a0b08> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:21:19.223] resolved() for ‘SequentialFuture’ ...
[10:21:19.223] - state: ‘finished’
[10:21:19.223] - run: TRUE
[10:21:19.223] - result: ‘FutureResult’
[10:21:19.223] resolved() for ‘SequentialFuture’ ... done
[10:21:19.224] resolved() for ‘SequentialFuture’ ...
[10:21:19.224] - state: ‘finished’
[10:21:19.224] - run: TRUE
[10:21:19.224] - result: ‘FutureResult’
[10:21:19.224] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:19.225] resolve() on list ...
[10:21:19.225]  recursive: 0
[10:21:19.225]  length: 6
[10:21:19.226]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:19.226] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.226] - nx: 6
[10:21:19.226] - relay: TRUE
[10:21:19.226] - stdout: TRUE
[10:21:19.226] - signal: TRUE
[10:21:19.226] - resignal: FALSE
[10:21:19.226] - force: TRUE
[10:21:19.226] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.226] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.226]  - until=2
[10:21:19.226]  - relaying element #2
[10:21:19.226] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.227] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.227] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.227]  length: 5 (resolved future 1)
[10:21:19.227] resolved() for ‘SequentialFuture’ ...
[10:21:19.227] - state: ‘finished’
[10:21:19.227] - run: TRUE
[10:21:19.227] - result: ‘FutureResult’
[10:21:19.227] resolved() for ‘SequentialFuture’ ... done
[10:21:19.227] Future #2
[10:21:19.227] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.227] - nx: 6
[10:21:19.228] - relay: TRUE
[10:21:19.228] - stdout: TRUE
[10:21:19.228] - signal: TRUE
[10:21:19.228] - resignal: FALSE
[10:21:19.228] - force: TRUE
[10:21:19.228] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.228] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.228]  - until=2
[10:21:19.228]  - relaying element #2
[10:21:19.228] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.228] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.229] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.229]  length: 4 (resolved future 2)
[10:21:19.229] resolved() for ‘SequentialFuture’ ...
[10:21:19.229] - state: ‘finished’
[10:21:19.229] - run: TRUE
[10:21:19.229] - result: ‘FutureResult’
[10:21:19.229] resolved() for ‘SequentialFuture’ ... done
[10:21:19.229] Future #3
[10:21:19.229] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.229] - nx: 6
[10:21:19.229] - relay: TRUE
[10:21:19.229] - stdout: TRUE
[10:21:19.230] - signal: TRUE
[10:21:19.230] - resignal: FALSE
[10:21:19.230] - force: TRUE
[10:21:19.230] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.230] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.230]  - until=3
[10:21:19.230]  - relaying element #3
[10:21:19.230] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.230] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.230] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.230]  length: 3 (resolved future 3)
[10:21:19.231] signalConditionsASAP(NULL, pos=4) ...
[10:21:19.231] - nx: 6
[10:21:19.231] - relay: TRUE
[10:21:19.231] - stdout: TRUE
[10:21:19.231] - signal: TRUE
[10:21:19.231] - resignal: FALSE
[10:21:19.231] - force: TRUE
[10:21:19.231] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.231] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.231]  - until=5
[10:21:19.231]  - relaying element #5
[10:21:19.231] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.231] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.232] signalConditionsASAP(NULL, pos=4) ... done
[10:21:19.232]  length: 2 (resolved future 4)
[10:21:19.232] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.232] - nx: 6
[10:21:19.232] - relay: TRUE
[10:21:19.232] - stdout: TRUE
[10:21:19.232] - signal: TRUE
[10:21:19.232] - resignal: FALSE
[10:21:19.232] - force: TRUE
[10:21:19.232] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.232] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.232]  - until=6
[10:21:19.232]  - relaying element #6
[10:21:19.232] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.233] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.233] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.233]  length: 1 (resolved future 5)
[10:21:19.233] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.233] - nx: 6
[10:21:19.233] - relay: TRUE
[10:21:19.233] - stdout: TRUE
[10:21:19.233] - signal: TRUE
[10:21:19.233] - resignal: FALSE
[10:21:19.233] - force: TRUE
[10:21:19.233] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.233] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.233]  - until=6
[10:21:19.234] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.234] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.234] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.234]  length: 0 (resolved future 6)
[10:21:19.234] Relaying remaining futures
[10:21:19.234] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.234] - nx: 6
[10:21:19.234] - relay: TRUE
[10:21:19.234] - stdout: TRUE
[10:21:19.234] - signal: TRUE
[10:21:19.234] - resignal: FALSE
[10:21:19.234] - force: TRUE
[10:21:19.234] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.235] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:19.235] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.235] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.235] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.235] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:21:19.239] getGlobalsAndPackages() ...
[10:21:19.239] Searching for globals...
[10:21:19.240] 
[10:21:19.240] Searching for globals ... DONE
[10:21:19.240] - globals: [0] <none>
[10:21:19.240] getGlobalsAndPackages() ... DONE
[10:21:19.240] run() for ‘Future’ ...
[10:21:19.240] - state: ‘created’
[10:21:19.240] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.241] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.241] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.241]   - Field: ‘label’
[10:21:19.241]   - Field: ‘local’
[10:21:19.241]   - Field: ‘owner’
[10:21:19.241]   - Field: ‘envir’
[10:21:19.241]   - Field: ‘packages’
[10:21:19.241]   - Field: ‘gc’
[10:21:19.241]   - Field: ‘conditions’
[10:21:19.241]   - Field: ‘expr’
[10:21:19.242]   - Field: ‘uuid’
[10:21:19.242]   - Field: ‘seed’
[10:21:19.242]   - Field: ‘version’
[10:21:19.242]   - Field: ‘result’
[10:21:19.242]   - Field: ‘asynchronous’
[10:21:19.242]   - Field: ‘calls’
[10:21:19.242]   - Field: ‘globals’
[10:21:19.242]   - Field: ‘stdout’
[10:21:19.242]   - Field: ‘earlySignal’
[10:21:19.242]   - Field: ‘lazy’
[10:21:19.242]   - Field: ‘state’
[10:21:19.242] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.243] - Launch lazy future ...
[10:21:19.243] Packages needed by the future expression (n = 0): <none>
[10:21:19.243] Packages needed by future strategies (n = 0): <none>
[10:21:19.243] {
[10:21:19.243]     {
[10:21:19.243]         {
[10:21:19.243]             ...future.startTime <- base::Sys.time()
[10:21:19.243]             {
[10:21:19.243]                 {
[10:21:19.243]                   {
[10:21:19.243]                     base::local({
[10:21:19.243]                       has_future <- base::requireNamespace("future", 
[10:21:19.243]                         quietly = TRUE)
[10:21:19.243]                       if (has_future) {
[10:21:19.243]                         ns <- base::getNamespace("future")
[10:21:19.243]                         version <- ns[[".package"]][["version"]]
[10:21:19.243]                         if (is.null(version)) 
[10:21:19.243]                           version <- utils::packageVersion("future")
[10:21:19.243]                       }
[10:21:19.243]                       else {
[10:21:19.243]                         version <- NULL
[10:21:19.243]                       }
[10:21:19.243]                       if (!has_future || version < "1.8.0") {
[10:21:19.243]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.243]                           "", base::R.version$version.string), 
[10:21:19.243]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.243]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.243]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.243]                             "release", "version")], collapse = " "), 
[10:21:19.243]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.243]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.243]                           info)
[10:21:19.243]                         info <- base::paste(info, collapse = "; ")
[10:21:19.243]                         if (!has_future) {
[10:21:19.243]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.243]                             info)
[10:21:19.243]                         }
[10:21:19.243]                         else {
[10:21:19.243]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.243]                             info, version)
[10:21:19.243]                         }
[10:21:19.243]                         base::stop(msg)
[10:21:19.243]                       }
[10:21:19.243]                     })
[10:21:19.243]                   }
[10:21:19.243]                   ...future.strategy.old <- future::plan("list")
[10:21:19.243]                   options(future.plan = NULL)
[10:21:19.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.243]                 }
[10:21:19.243]                 ...future.workdir <- getwd()
[10:21:19.243]             }
[10:21:19.243]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.243]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.243]         }
[10:21:19.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.243]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.243]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.243]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.243]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.243]             base::names(...future.oldOptions))
[10:21:19.243]     }
[10:21:19.243]     if (FALSE) {
[10:21:19.243]     }
[10:21:19.243]     else {
[10:21:19.243]         if (TRUE) {
[10:21:19.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.243]                 open = "w")
[10:21:19.243]         }
[10:21:19.243]         else {
[10:21:19.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.243]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.243]         }
[10:21:19.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.243]             base::sink(type = "output", split = FALSE)
[10:21:19.243]             base::close(...future.stdout)
[10:21:19.243]         }, add = TRUE)
[10:21:19.243]     }
[10:21:19.243]     ...future.frame <- base::sys.nframe()
[10:21:19.243]     ...future.conditions <- base::list()
[10:21:19.243]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.243]     if (FALSE) {
[10:21:19.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.243]     }
[10:21:19.243]     ...future.result <- base::tryCatch({
[10:21:19.243]         base::withCallingHandlers({
[10:21:19.243]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.243]             future::FutureResult(value = ...future.value$value, 
[10:21:19.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.243]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.243]                     ...future.globalenv.names))
[10:21:19.243]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.243]         }, condition = base::local({
[10:21:19.243]             c <- base::c
[10:21:19.243]             inherits <- base::inherits
[10:21:19.243]             invokeRestart <- base::invokeRestart
[10:21:19.243]             length <- base::length
[10:21:19.243]             list <- base::list
[10:21:19.243]             seq.int <- base::seq.int
[10:21:19.243]             signalCondition <- base::signalCondition
[10:21:19.243]             sys.calls <- base::sys.calls
[10:21:19.243]             `[[` <- base::`[[`
[10:21:19.243]             `+` <- base::`+`
[10:21:19.243]             `<<-` <- base::`<<-`
[10:21:19.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.243]                   3L)]
[10:21:19.243]             }
[10:21:19.243]             function(cond) {
[10:21:19.243]                 is_error <- inherits(cond, "error")
[10:21:19.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.243]                   NULL)
[10:21:19.243]                 if (is_error) {
[10:21:19.243]                   sessionInformation <- function() {
[10:21:19.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.243]                       search = base::search(), system = base::Sys.info())
[10:21:19.243]                   }
[10:21:19.243]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.243]                     cond$call), session = sessionInformation(), 
[10:21:19.243]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.243]                   signalCondition(cond)
[10:21:19.243]                 }
[10:21:19.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.243]                 "immediateCondition"))) {
[10:21:19.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.243]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.243]                   if (TRUE && !signal) {
[10:21:19.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.243]                     {
[10:21:19.243]                       inherits <- base::inherits
[10:21:19.243]                       invokeRestart <- base::invokeRestart
[10:21:19.243]                       is.null <- base::is.null
[10:21:19.243]                       muffled <- FALSE
[10:21:19.243]                       if (inherits(cond, "message")) {
[10:21:19.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.243]                         if (muffled) 
[10:21:19.243]                           invokeRestart("muffleMessage")
[10:21:19.243]                       }
[10:21:19.243]                       else if (inherits(cond, "warning")) {
[10:21:19.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.243]                         if (muffled) 
[10:21:19.243]                           invokeRestart("muffleWarning")
[10:21:19.243]                       }
[10:21:19.243]                       else if (inherits(cond, "condition")) {
[10:21:19.243]                         if (!is.null(pattern)) {
[10:21:19.243]                           computeRestarts <- base::computeRestarts
[10:21:19.243]                           grepl <- base::grepl
[10:21:19.243]                           restarts <- computeRestarts(cond)
[10:21:19.243]                           for (restart in restarts) {
[10:21:19.243]                             name <- restart$name
[10:21:19.243]                             if (is.null(name)) 
[10:21:19.243]                               next
[10:21:19.243]                             if (!grepl(pattern, name)) 
[10:21:19.243]                               next
[10:21:19.243]                             invokeRestart(restart)
[10:21:19.243]                             muffled <- TRUE
[10:21:19.243]                             break
[10:21:19.243]                           }
[10:21:19.243]                         }
[10:21:19.243]                       }
[10:21:19.243]                       invisible(muffled)
[10:21:19.243]                     }
[10:21:19.243]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.243]                   }
[10:21:19.243]                 }
[10:21:19.243]                 else {
[10:21:19.243]                   if (TRUE) {
[10:21:19.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.243]                     {
[10:21:19.243]                       inherits <- base::inherits
[10:21:19.243]                       invokeRestart <- base::invokeRestart
[10:21:19.243]                       is.null <- base::is.null
[10:21:19.243]                       muffled <- FALSE
[10:21:19.243]                       if (inherits(cond, "message")) {
[10:21:19.243]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.243]                         if (muffled) 
[10:21:19.243]                           invokeRestart("muffleMessage")
[10:21:19.243]                       }
[10:21:19.243]                       else if (inherits(cond, "warning")) {
[10:21:19.243]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.243]                         if (muffled) 
[10:21:19.243]                           invokeRestart("muffleWarning")
[10:21:19.243]                       }
[10:21:19.243]                       else if (inherits(cond, "condition")) {
[10:21:19.243]                         if (!is.null(pattern)) {
[10:21:19.243]                           computeRestarts <- base::computeRestarts
[10:21:19.243]                           grepl <- base::grepl
[10:21:19.243]                           restarts <- computeRestarts(cond)
[10:21:19.243]                           for (restart in restarts) {
[10:21:19.243]                             name <- restart$name
[10:21:19.243]                             if (is.null(name)) 
[10:21:19.243]                               next
[10:21:19.243]                             if (!grepl(pattern, name)) 
[10:21:19.243]                               next
[10:21:19.243]                             invokeRestart(restart)
[10:21:19.243]                             muffled <- TRUE
[10:21:19.243]                             break
[10:21:19.243]                           }
[10:21:19.243]                         }
[10:21:19.243]                       }
[10:21:19.243]                       invisible(muffled)
[10:21:19.243]                     }
[10:21:19.243]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.243]                   }
[10:21:19.243]                 }
[10:21:19.243]             }
[10:21:19.243]         }))
[10:21:19.243]     }, error = function(ex) {
[10:21:19.243]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.243]                 ...future.rng), started = ...future.startTime, 
[10:21:19.243]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.243]             version = "1.8"), class = "FutureResult")
[10:21:19.243]     }, finally = {
[10:21:19.243]         if (!identical(...future.workdir, getwd())) 
[10:21:19.243]             setwd(...future.workdir)
[10:21:19.243]         {
[10:21:19.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.243]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.243]             }
[10:21:19.243]             base::options(...future.oldOptions)
[10:21:19.243]             if (.Platform$OS.type == "windows") {
[10:21:19.243]                 old_names <- names(...future.oldEnvVars)
[10:21:19.243]                 envs <- base::Sys.getenv()
[10:21:19.243]                 names <- names(envs)
[10:21:19.243]                 common <- intersect(names, old_names)
[10:21:19.243]                 added <- setdiff(names, old_names)
[10:21:19.243]                 removed <- setdiff(old_names, names)
[10:21:19.243]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.243]                   envs[common]]
[10:21:19.243]                 NAMES <- toupper(changed)
[10:21:19.243]                 args <- list()
[10:21:19.243]                 for (kk in seq_along(NAMES)) {
[10:21:19.243]                   name <- changed[[kk]]
[10:21:19.243]                   NAME <- NAMES[[kk]]
[10:21:19.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.243]                     next
[10:21:19.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.243]                 }
[10:21:19.243]                 NAMES <- toupper(added)
[10:21:19.243]                 for (kk in seq_along(NAMES)) {
[10:21:19.243]                   name <- added[[kk]]
[10:21:19.243]                   NAME <- NAMES[[kk]]
[10:21:19.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.243]                     next
[10:21:19.243]                   args[[name]] <- ""
[10:21:19.243]                 }
[10:21:19.243]                 NAMES <- toupper(removed)
[10:21:19.243]                 for (kk in seq_along(NAMES)) {
[10:21:19.243]                   name <- removed[[kk]]
[10:21:19.243]                   NAME <- NAMES[[kk]]
[10:21:19.243]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.243]                     next
[10:21:19.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.243]                 }
[10:21:19.243]                 if (length(args) > 0) 
[10:21:19.243]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.243]             }
[10:21:19.243]             else {
[10:21:19.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.243]             }
[10:21:19.243]             {
[10:21:19.243]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.243]                   0L) {
[10:21:19.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.243]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.243]                   base::options(opts)
[10:21:19.243]                 }
[10:21:19.243]                 {
[10:21:19.243]                   {
[10:21:19.243]                     NULL
[10:21:19.243]                     RNGkind("Mersenne-Twister")
[10:21:19.243]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.243]                       inherits = FALSE)
[10:21:19.243]                   }
[10:21:19.243]                   options(future.plan = NULL)
[10:21:19.243]                   if (is.na(NA_character_)) 
[10:21:19.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.243]                     .init = FALSE)
[10:21:19.243]                 }
[10:21:19.243]             }
[10:21:19.243]         }
[10:21:19.243]     })
[10:21:19.243]     if (TRUE) {
[10:21:19.243]         base::sink(type = "output", split = FALSE)
[10:21:19.243]         if (TRUE) {
[10:21:19.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.243]         }
[10:21:19.243]         else {
[10:21:19.243]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.243]         }
[10:21:19.243]         base::close(...future.stdout)
[10:21:19.243]         ...future.stdout <- NULL
[10:21:19.243]     }
[10:21:19.243]     ...future.result$conditions <- ...future.conditions
[10:21:19.243]     ...future.result$finished <- base::Sys.time()
[10:21:19.243]     ...future.result
[10:21:19.243] }
[10:21:19.245] plan(): Setting new future strategy stack:
[10:21:19.245] List of future strategies:
[10:21:19.245] 1. sequential:
[10:21:19.245]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.245]    - tweaked: FALSE
[10:21:19.245]    - call: NULL
[10:21:19.245] plan(): nbrOfWorkers() = 1
[10:21:19.246] plan(): Setting new future strategy stack:
[10:21:19.246] List of future strategies:
[10:21:19.246] 1. sequential:
[10:21:19.246]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.246]    - tweaked: FALSE
[10:21:19.246]    - call: plan(strategy)
[10:21:19.247] plan(): nbrOfWorkers() = 1
[10:21:19.247] SequentialFuture started (and completed)
[10:21:19.247] - Launch lazy future ... done
[10:21:19.247] run() for ‘SequentialFuture’ ... done
[10:21:19.247] getGlobalsAndPackages() ...
[10:21:19.247] Searching for globals...
[10:21:19.247] 
[10:21:19.247] Searching for globals ... DONE
[10:21:19.248] - globals: [0] <none>
[10:21:19.248] getGlobalsAndPackages() ... DONE
[10:21:19.248] run() for ‘Future’ ...
[10:21:19.248] - state: ‘created’
[10:21:19.248] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.248] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.248] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.248]   - Field: ‘label’
[10:21:19.249]   - Field: ‘local’
[10:21:19.249]   - Field: ‘owner’
[10:21:19.249]   - Field: ‘envir’
[10:21:19.249]   - Field: ‘packages’
[10:21:19.249]   - Field: ‘gc’
[10:21:19.249]   - Field: ‘conditions’
[10:21:19.249]   - Field: ‘expr’
[10:21:19.249]   - Field: ‘uuid’
[10:21:19.249]   - Field: ‘seed’
[10:21:19.249]   - Field: ‘version’
[10:21:19.249]   - Field: ‘result’
[10:21:19.249]   - Field: ‘asynchronous’
[10:21:19.250]   - Field: ‘calls’
[10:21:19.250]   - Field: ‘globals’
[10:21:19.250]   - Field: ‘stdout’
[10:21:19.250]   - Field: ‘earlySignal’
[10:21:19.250]   - Field: ‘lazy’
[10:21:19.250]   - Field: ‘state’
[10:21:19.250] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.250] - Launch lazy future ...
[10:21:19.250] Packages needed by the future expression (n = 0): <none>
[10:21:19.250] Packages needed by future strategies (n = 0): <none>
[10:21:19.251] {
[10:21:19.251]     {
[10:21:19.251]         {
[10:21:19.251]             ...future.startTime <- base::Sys.time()
[10:21:19.251]             {
[10:21:19.251]                 {
[10:21:19.251]                   {
[10:21:19.251]                     base::local({
[10:21:19.251]                       has_future <- base::requireNamespace("future", 
[10:21:19.251]                         quietly = TRUE)
[10:21:19.251]                       if (has_future) {
[10:21:19.251]                         ns <- base::getNamespace("future")
[10:21:19.251]                         version <- ns[[".package"]][["version"]]
[10:21:19.251]                         if (is.null(version)) 
[10:21:19.251]                           version <- utils::packageVersion("future")
[10:21:19.251]                       }
[10:21:19.251]                       else {
[10:21:19.251]                         version <- NULL
[10:21:19.251]                       }
[10:21:19.251]                       if (!has_future || version < "1.8.0") {
[10:21:19.251]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.251]                           "", base::R.version$version.string), 
[10:21:19.251]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.251]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.251]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.251]                             "release", "version")], collapse = " "), 
[10:21:19.251]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.251]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.251]                           info)
[10:21:19.251]                         info <- base::paste(info, collapse = "; ")
[10:21:19.251]                         if (!has_future) {
[10:21:19.251]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.251]                             info)
[10:21:19.251]                         }
[10:21:19.251]                         else {
[10:21:19.251]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.251]                             info, version)
[10:21:19.251]                         }
[10:21:19.251]                         base::stop(msg)
[10:21:19.251]                       }
[10:21:19.251]                     })
[10:21:19.251]                   }
[10:21:19.251]                   ...future.strategy.old <- future::plan("list")
[10:21:19.251]                   options(future.plan = NULL)
[10:21:19.251]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.251]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.251]                 }
[10:21:19.251]                 ...future.workdir <- getwd()
[10:21:19.251]             }
[10:21:19.251]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.251]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.251]         }
[10:21:19.251]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.251]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.251]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.251]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.251]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.251]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.251]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.251]             base::names(...future.oldOptions))
[10:21:19.251]     }
[10:21:19.251]     if (FALSE) {
[10:21:19.251]     }
[10:21:19.251]     else {
[10:21:19.251]         if (TRUE) {
[10:21:19.251]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.251]                 open = "w")
[10:21:19.251]         }
[10:21:19.251]         else {
[10:21:19.251]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.251]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.251]         }
[10:21:19.251]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.251]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.251]             base::sink(type = "output", split = FALSE)
[10:21:19.251]             base::close(...future.stdout)
[10:21:19.251]         }, add = TRUE)
[10:21:19.251]     }
[10:21:19.251]     ...future.frame <- base::sys.nframe()
[10:21:19.251]     ...future.conditions <- base::list()
[10:21:19.251]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.251]     if (FALSE) {
[10:21:19.251]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.251]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.251]     }
[10:21:19.251]     ...future.result <- base::tryCatch({
[10:21:19.251]         base::withCallingHandlers({
[10:21:19.251]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.251]             future::FutureResult(value = ...future.value$value, 
[10:21:19.251]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.251]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.251]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.251]                     ...future.globalenv.names))
[10:21:19.251]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.251]         }, condition = base::local({
[10:21:19.251]             c <- base::c
[10:21:19.251]             inherits <- base::inherits
[10:21:19.251]             invokeRestart <- base::invokeRestart
[10:21:19.251]             length <- base::length
[10:21:19.251]             list <- base::list
[10:21:19.251]             seq.int <- base::seq.int
[10:21:19.251]             signalCondition <- base::signalCondition
[10:21:19.251]             sys.calls <- base::sys.calls
[10:21:19.251]             `[[` <- base::`[[`
[10:21:19.251]             `+` <- base::`+`
[10:21:19.251]             `<<-` <- base::`<<-`
[10:21:19.251]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.251]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.251]                   3L)]
[10:21:19.251]             }
[10:21:19.251]             function(cond) {
[10:21:19.251]                 is_error <- inherits(cond, "error")
[10:21:19.251]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.251]                   NULL)
[10:21:19.251]                 if (is_error) {
[10:21:19.251]                   sessionInformation <- function() {
[10:21:19.251]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.251]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.251]                       search = base::search(), system = base::Sys.info())
[10:21:19.251]                   }
[10:21:19.251]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.251]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.251]                     cond$call), session = sessionInformation(), 
[10:21:19.251]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.251]                   signalCondition(cond)
[10:21:19.251]                 }
[10:21:19.251]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.251]                 "immediateCondition"))) {
[10:21:19.251]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.251]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.251]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.251]                   if (TRUE && !signal) {
[10:21:19.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.251]                     {
[10:21:19.251]                       inherits <- base::inherits
[10:21:19.251]                       invokeRestart <- base::invokeRestart
[10:21:19.251]                       is.null <- base::is.null
[10:21:19.251]                       muffled <- FALSE
[10:21:19.251]                       if (inherits(cond, "message")) {
[10:21:19.251]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.251]                         if (muffled) 
[10:21:19.251]                           invokeRestart("muffleMessage")
[10:21:19.251]                       }
[10:21:19.251]                       else if (inherits(cond, "warning")) {
[10:21:19.251]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.251]                         if (muffled) 
[10:21:19.251]                           invokeRestart("muffleWarning")
[10:21:19.251]                       }
[10:21:19.251]                       else if (inherits(cond, "condition")) {
[10:21:19.251]                         if (!is.null(pattern)) {
[10:21:19.251]                           computeRestarts <- base::computeRestarts
[10:21:19.251]                           grepl <- base::grepl
[10:21:19.251]                           restarts <- computeRestarts(cond)
[10:21:19.251]                           for (restart in restarts) {
[10:21:19.251]                             name <- restart$name
[10:21:19.251]                             if (is.null(name)) 
[10:21:19.251]                               next
[10:21:19.251]                             if (!grepl(pattern, name)) 
[10:21:19.251]                               next
[10:21:19.251]                             invokeRestart(restart)
[10:21:19.251]                             muffled <- TRUE
[10:21:19.251]                             break
[10:21:19.251]                           }
[10:21:19.251]                         }
[10:21:19.251]                       }
[10:21:19.251]                       invisible(muffled)
[10:21:19.251]                     }
[10:21:19.251]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.251]                   }
[10:21:19.251]                 }
[10:21:19.251]                 else {
[10:21:19.251]                   if (TRUE) {
[10:21:19.251]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.251]                     {
[10:21:19.251]                       inherits <- base::inherits
[10:21:19.251]                       invokeRestart <- base::invokeRestart
[10:21:19.251]                       is.null <- base::is.null
[10:21:19.251]                       muffled <- FALSE
[10:21:19.251]                       if (inherits(cond, "message")) {
[10:21:19.251]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.251]                         if (muffled) 
[10:21:19.251]                           invokeRestart("muffleMessage")
[10:21:19.251]                       }
[10:21:19.251]                       else if (inherits(cond, "warning")) {
[10:21:19.251]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.251]                         if (muffled) 
[10:21:19.251]                           invokeRestart("muffleWarning")
[10:21:19.251]                       }
[10:21:19.251]                       else if (inherits(cond, "condition")) {
[10:21:19.251]                         if (!is.null(pattern)) {
[10:21:19.251]                           computeRestarts <- base::computeRestarts
[10:21:19.251]                           grepl <- base::grepl
[10:21:19.251]                           restarts <- computeRestarts(cond)
[10:21:19.251]                           for (restart in restarts) {
[10:21:19.251]                             name <- restart$name
[10:21:19.251]                             if (is.null(name)) 
[10:21:19.251]                               next
[10:21:19.251]                             if (!grepl(pattern, name)) 
[10:21:19.251]                               next
[10:21:19.251]                             invokeRestart(restart)
[10:21:19.251]                             muffled <- TRUE
[10:21:19.251]                             break
[10:21:19.251]                           }
[10:21:19.251]                         }
[10:21:19.251]                       }
[10:21:19.251]                       invisible(muffled)
[10:21:19.251]                     }
[10:21:19.251]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.251]                   }
[10:21:19.251]                 }
[10:21:19.251]             }
[10:21:19.251]         }))
[10:21:19.251]     }, error = function(ex) {
[10:21:19.251]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.251]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.251]                 ...future.rng), started = ...future.startTime, 
[10:21:19.251]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.251]             version = "1.8"), class = "FutureResult")
[10:21:19.251]     }, finally = {
[10:21:19.251]         if (!identical(...future.workdir, getwd())) 
[10:21:19.251]             setwd(...future.workdir)
[10:21:19.251]         {
[10:21:19.251]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.251]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.251]             }
[10:21:19.251]             base::options(...future.oldOptions)
[10:21:19.251]             if (.Platform$OS.type == "windows") {
[10:21:19.251]                 old_names <- names(...future.oldEnvVars)
[10:21:19.251]                 envs <- base::Sys.getenv()
[10:21:19.251]                 names <- names(envs)
[10:21:19.251]                 common <- intersect(names, old_names)
[10:21:19.251]                 added <- setdiff(names, old_names)
[10:21:19.251]                 removed <- setdiff(old_names, names)
[10:21:19.251]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.251]                   envs[common]]
[10:21:19.251]                 NAMES <- toupper(changed)
[10:21:19.251]                 args <- list()
[10:21:19.251]                 for (kk in seq_along(NAMES)) {
[10:21:19.251]                   name <- changed[[kk]]
[10:21:19.251]                   NAME <- NAMES[[kk]]
[10:21:19.251]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.251]                     next
[10:21:19.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.251]                 }
[10:21:19.251]                 NAMES <- toupper(added)
[10:21:19.251]                 for (kk in seq_along(NAMES)) {
[10:21:19.251]                   name <- added[[kk]]
[10:21:19.251]                   NAME <- NAMES[[kk]]
[10:21:19.251]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.251]                     next
[10:21:19.251]                   args[[name]] <- ""
[10:21:19.251]                 }
[10:21:19.251]                 NAMES <- toupper(removed)
[10:21:19.251]                 for (kk in seq_along(NAMES)) {
[10:21:19.251]                   name <- removed[[kk]]
[10:21:19.251]                   NAME <- NAMES[[kk]]
[10:21:19.251]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.251]                     next
[10:21:19.251]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.251]                 }
[10:21:19.251]                 if (length(args) > 0) 
[10:21:19.251]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.251]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.251]             }
[10:21:19.251]             else {
[10:21:19.251]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.251]             }
[10:21:19.251]             {
[10:21:19.251]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.251]                   0L) {
[10:21:19.251]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.251]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.251]                   base::options(opts)
[10:21:19.251]                 }
[10:21:19.251]                 {
[10:21:19.251]                   {
[10:21:19.251]                     NULL
[10:21:19.251]                     RNGkind("Mersenne-Twister")
[10:21:19.251]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.251]                       inherits = FALSE)
[10:21:19.251]                   }
[10:21:19.251]                   options(future.plan = NULL)
[10:21:19.251]                   if (is.na(NA_character_)) 
[10:21:19.251]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.251]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.251]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.251]                     .init = FALSE)
[10:21:19.251]                 }
[10:21:19.251]             }
[10:21:19.251]         }
[10:21:19.251]     })
[10:21:19.251]     if (TRUE) {
[10:21:19.251]         base::sink(type = "output", split = FALSE)
[10:21:19.251]         if (TRUE) {
[10:21:19.251]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.251]         }
[10:21:19.251]         else {
[10:21:19.251]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.251]         }
[10:21:19.251]         base::close(...future.stdout)
[10:21:19.251]         ...future.stdout <- NULL
[10:21:19.251]     }
[10:21:19.251]     ...future.result$conditions <- ...future.conditions
[10:21:19.251]     ...future.result$finished <- base::Sys.time()
[10:21:19.251]     ...future.result
[10:21:19.251] }
[10:21:19.252] plan(): Setting new future strategy stack:
[10:21:19.253] List of future strategies:
[10:21:19.253] 1. sequential:
[10:21:19.253]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.253]    - tweaked: FALSE
[10:21:19.253]    - call: NULL
[10:21:19.253] plan(): nbrOfWorkers() = 1
[10:21:19.254] plan(): Setting new future strategy stack:
[10:21:19.254] List of future strategies:
[10:21:19.254] 1. sequential:
[10:21:19.254]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.254]    - tweaked: FALSE
[10:21:19.254]    - call: plan(strategy)
[10:21:19.254] plan(): nbrOfWorkers() = 1
[10:21:19.254] SequentialFuture started (and completed)
[10:21:19.254] - Launch lazy future ... done
[10:21:19.254] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e35dcad0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e4aec948> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e35dcad0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e4aec948> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:21:19.259] resolved() for ‘SequentialFuture’ ...
[10:21:19.259] - state: ‘finished’
[10:21:19.259] - run: TRUE
[10:21:19.259] - result: ‘FutureResult’
[10:21:19.259] resolved() for ‘SequentialFuture’ ... done
[10:21:19.260] resolved() for ‘SequentialFuture’ ...
[10:21:19.260] - state: ‘finished’
[10:21:19.260] - run: TRUE
[10:21:19.260] - result: ‘FutureResult’
[10:21:19.260] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:19.261] resolve() on list ...
[10:21:19.262]  recursive: 0
[10:21:19.262]  length: 6
[10:21:19.262]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:19.262] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.262] - nx: 6
[10:21:19.262] - relay: TRUE
[10:21:19.262] - stdout: TRUE
[10:21:19.262] - signal: TRUE
[10:21:19.262] - resignal: FALSE
[10:21:19.262] - force: TRUE
[10:21:19.262] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.262] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.262]  - until=2
[10:21:19.263]  - relaying element #2
[10:21:19.263] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.263] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.263] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.263]  length: 5 (resolved future 1)
[10:21:19.263] resolved() for ‘SequentialFuture’ ...
[10:21:19.263] - state: ‘finished’
[10:21:19.263] - run: TRUE
[10:21:19.263] - result: ‘FutureResult’
[10:21:19.263] resolved() for ‘SequentialFuture’ ... done
[10:21:19.263] Future #2
[10:21:19.264] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.264] - nx: 6
[10:21:19.265] - relay: TRUE
[10:21:19.265] - stdout: TRUE
[10:21:19.265] - signal: TRUE
[10:21:19.265] - resignal: FALSE
[10:21:19.265] - force: TRUE
[10:21:19.265] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.265] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.265]  - until=2
[10:21:19.265]  - relaying element #2
[10:21:19.266] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.266] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.266] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.266]  length: 4 (resolved future 2)
[10:21:19.266] resolved() for ‘SequentialFuture’ ...
[10:21:19.266] - state: ‘finished’
[10:21:19.266] - run: TRUE
[10:21:19.266] - result: ‘FutureResult’
[10:21:19.266] resolved() for ‘SequentialFuture’ ... done
[10:21:19.266] Future #3
[10:21:19.267] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.267] - nx: 6
[10:21:19.267] - relay: TRUE
[10:21:19.267] - stdout: TRUE
[10:21:19.267] - signal: TRUE
[10:21:19.267] - resignal: FALSE
[10:21:19.267] - force: TRUE
[10:21:19.267] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.267] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.267]  - until=3
[10:21:19.267]  - relaying element #3
[10:21:19.268] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.268] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.268] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.268]  length: 3 (resolved future 3)
[10:21:19.268] signalConditionsASAP(NULL, pos=4) ...
[10:21:19.268] - nx: 6
[10:21:19.268] - relay: TRUE
[10:21:19.268] - stdout: TRUE
[10:21:19.268] - signal: TRUE
[10:21:19.268] - resignal: FALSE
[10:21:19.268] - force: TRUE
[10:21:19.268] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.268] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.269]  - until=5
[10:21:19.269]  - relaying element #5
[10:21:19.269] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.269] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.269] signalConditionsASAP(NULL, pos=4) ... done
[10:21:19.269]  length: 2 (resolved future 4)
[10:21:19.269] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.269] - nx: 6
[10:21:19.269] - relay: TRUE
[10:21:19.269] - stdout: TRUE
[10:21:19.269] - signal: TRUE
[10:21:19.269] - resignal: FALSE
[10:21:19.269] - force: TRUE
[10:21:19.270] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.270] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.270]  - until=6
[10:21:19.270]  - relaying element #6
[10:21:19.270] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.270] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.270] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.270]  length: 1 (resolved future 5)
[10:21:19.270] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.270] - nx: 6
[10:21:19.270] - relay: TRUE
[10:21:19.270] - stdout: TRUE
[10:21:19.270] - signal: TRUE
[10:21:19.271] - resignal: FALSE
[10:21:19.271] - force: TRUE
[10:21:19.271] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.271] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.271]  - until=6
[10:21:19.271] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.271] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.271] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.271]  length: 0 (resolved future 6)
[10:21:19.271] Relaying remaining futures
[10:21:19.271] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.271] - nx: 6
[10:21:19.271] - relay: TRUE
[10:21:19.272] - stdout: TRUE
[10:21:19.272] - signal: TRUE
[10:21:19.272] - resignal: FALSE
[10:21:19.272] - force: TRUE
[10:21:19.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.272] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:19.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.272] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.272] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.272] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:21:19.275] getGlobalsAndPackages() ...
[10:21:19.275] Searching for globals...
[10:21:19.276] 
[10:21:19.276] Searching for globals ... DONE
[10:21:19.276] - globals: [0] <none>
[10:21:19.276] getGlobalsAndPackages() ... DONE
[10:21:19.276] run() for ‘Future’ ...
[10:21:19.276] - state: ‘created’
[10:21:19.276] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.277] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.277] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.277]   - Field: ‘label’
[10:21:19.277]   - Field: ‘local’
[10:21:19.277]   - Field: ‘owner’
[10:21:19.277]   - Field: ‘envir’
[10:21:19.277]   - Field: ‘packages’
[10:21:19.277]   - Field: ‘gc’
[10:21:19.277]   - Field: ‘conditions’
[10:21:19.277]   - Field: ‘expr’
[10:21:19.277]   - Field: ‘uuid’
[10:21:19.277]   - Field: ‘seed’
[10:21:19.278]   - Field: ‘version’
[10:21:19.278]   - Field: ‘result’
[10:21:19.278]   - Field: ‘asynchronous’
[10:21:19.278]   - Field: ‘calls’
[10:21:19.278]   - Field: ‘globals’
[10:21:19.278]   - Field: ‘stdout’
[10:21:19.278]   - Field: ‘earlySignal’
[10:21:19.278]   - Field: ‘lazy’
[10:21:19.278]   - Field: ‘state’
[10:21:19.278] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.278] - Launch lazy future ...
[10:21:19.278] Packages needed by the future expression (n = 0): <none>
[10:21:19.279] Packages needed by future strategies (n = 0): <none>
[10:21:19.279] {
[10:21:19.279]     {
[10:21:19.279]         {
[10:21:19.279]             ...future.startTime <- base::Sys.time()
[10:21:19.279]             {
[10:21:19.279]                 {
[10:21:19.279]                   {
[10:21:19.279]                     base::local({
[10:21:19.279]                       has_future <- base::requireNamespace("future", 
[10:21:19.279]                         quietly = TRUE)
[10:21:19.279]                       if (has_future) {
[10:21:19.279]                         ns <- base::getNamespace("future")
[10:21:19.279]                         version <- ns[[".package"]][["version"]]
[10:21:19.279]                         if (is.null(version)) 
[10:21:19.279]                           version <- utils::packageVersion("future")
[10:21:19.279]                       }
[10:21:19.279]                       else {
[10:21:19.279]                         version <- NULL
[10:21:19.279]                       }
[10:21:19.279]                       if (!has_future || version < "1.8.0") {
[10:21:19.279]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.279]                           "", base::R.version$version.string), 
[10:21:19.279]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.279]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.279]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.279]                             "release", "version")], collapse = " "), 
[10:21:19.279]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.279]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.279]                           info)
[10:21:19.279]                         info <- base::paste(info, collapse = "; ")
[10:21:19.279]                         if (!has_future) {
[10:21:19.279]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.279]                             info)
[10:21:19.279]                         }
[10:21:19.279]                         else {
[10:21:19.279]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.279]                             info, version)
[10:21:19.279]                         }
[10:21:19.279]                         base::stop(msg)
[10:21:19.279]                       }
[10:21:19.279]                     })
[10:21:19.279]                   }
[10:21:19.279]                   ...future.strategy.old <- future::plan("list")
[10:21:19.279]                   options(future.plan = NULL)
[10:21:19.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.279]                 }
[10:21:19.279]                 ...future.workdir <- getwd()
[10:21:19.279]             }
[10:21:19.279]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.279]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.279]         }
[10:21:19.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.279]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.279]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.279]             base::names(...future.oldOptions))
[10:21:19.279]     }
[10:21:19.279]     if (FALSE) {
[10:21:19.279]     }
[10:21:19.279]     else {
[10:21:19.279]         if (TRUE) {
[10:21:19.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.279]                 open = "w")
[10:21:19.279]         }
[10:21:19.279]         else {
[10:21:19.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.279]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.279]         }
[10:21:19.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.279]             base::sink(type = "output", split = FALSE)
[10:21:19.279]             base::close(...future.stdout)
[10:21:19.279]         }, add = TRUE)
[10:21:19.279]     }
[10:21:19.279]     ...future.frame <- base::sys.nframe()
[10:21:19.279]     ...future.conditions <- base::list()
[10:21:19.279]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.279]     if (FALSE) {
[10:21:19.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.279]     }
[10:21:19.279]     ...future.result <- base::tryCatch({
[10:21:19.279]         base::withCallingHandlers({
[10:21:19.279]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.279]             future::FutureResult(value = ...future.value$value, 
[10:21:19.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.279]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.279]                     ...future.globalenv.names))
[10:21:19.279]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.279]         }, condition = base::local({
[10:21:19.279]             c <- base::c
[10:21:19.279]             inherits <- base::inherits
[10:21:19.279]             invokeRestart <- base::invokeRestart
[10:21:19.279]             length <- base::length
[10:21:19.279]             list <- base::list
[10:21:19.279]             seq.int <- base::seq.int
[10:21:19.279]             signalCondition <- base::signalCondition
[10:21:19.279]             sys.calls <- base::sys.calls
[10:21:19.279]             `[[` <- base::`[[`
[10:21:19.279]             `+` <- base::`+`
[10:21:19.279]             `<<-` <- base::`<<-`
[10:21:19.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.279]                   3L)]
[10:21:19.279]             }
[10:21:19.279]             function(cond) {
[10:21:19.279]                 is_error <- inherits(cond, "error")
[10:21:19.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.279]                   NULL)
[10:21:19.279]                 if (is_error) {
[10:21:19.279]                   sessionInformation <- function() {
[10:21:19.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.279]                       search = base::search(), system = base::Sys.info())
[10:21:19.279]                   }
[10:21:19.279]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.279]                     cond$call), session = sessionInformation(), 
[10:21:19.279]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.279]                   signalCondition(cond)
[10:21:19.279]                 }
[10:21:19.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.279]                 "immediateCondition"))) {
[10:21:19.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.279]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.279]                   if (TRUE && !signal) {
[10:21:19.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.279]                     {
[10:21:19.279]                       inherits <- base::inherits
[10:21:19.279]                       invokeRestart <- base::invokeRestart
[10:21:19.279]                       is.null <- base::is.null
[10:21:19.279]                       muffled <- FALSE
[10:21:19.279]                       if (inherits(cond, "message")) {
[10:21:19.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.279]                         if (muffled) 
[10:21:19.279]                           invokeRestart("muffleMessage")
[10:21:19.279]                       }
[10:21:19.279]                       else if (inherits(cond, "warning")) {
[10:21:19.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.279]                         if (muffled) 
[10:21:19.279]                           invokeRestart("muffleWarning")
[10:21:19.279]                       }
[10:21:19.279]                       else if (inherits(cond, "condition")) {
[10:21:19.279]                         if (!is.null(pattern)) {
[10:21:19.279]                           computeRestarts <- base::computeRestarts
[10:21:19.279]                           grepl <- base::grepl
[10:21:19.279]                           restarts <- computeRestarts(cond)
[10:21:19.279]                           for (restart in restarts) {
[10:21:19.279]                             name <- restart$name
[10:21:19.279]                             if (is.null(name)) 
[10:21:19.279]                               next
[10:21:19.279]                             if (!grepl(pattern, name)) 
[10:21:19.279]                               next
[10:21:19.279]                             invokeRestart(restart)
[10:21:19.279]                             muffled <- TRUE
[10:21:19.279]                             break
[10:21:19.279]                           }
[10:21:19.279]                         }
[10:21:19.279]                       }
[10:21:19.279]                       invisible(muffled)
[10:21:19.279]                     }
[10:21:19.279]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.279]                   }
[10:21:19.279]                 }
[10:21:19.279]                 else {
[10:21:19.279]                   if (TRUE) {
[10:21:19.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.279]                     {
[10:21:19.279]                       inherits <- base::inherits
[10:21:19.279]                       invokeRestart <- base::invokeRestart
[10:21:19.279]                       is.null <- base::is.null
[10:21:19.279]                       muffled <- FALSE
[10:21:19.279]                       if (inherits(cond, "message")) {
[10:21:19.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.279]                         if (muffled) 
[10:21:19.279]                           invokeRestart("muffleMessage")
[10:21:19.279]                       }
[10:21:19.279]                       else if (inherits(cond, "warning")) {
[10:21:19.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.279]                         if (muffled) 
[10:21:19.279]                           invokeRestart("muffleWarning")
[10:21:19.279]                       }
[10:21:19.279]                       else if (inherits(cond, "condition")) {
[10:21:19.279]                         if (!is.null(pattern)) {
[10:21:19.279]                           computeRestarts <- base::computeRestarts
[10:21:19.279]                           grepl <- base::grepl
[10:21:19.279]                           restarts <- computeRestarts(cond)
[10:21:19.279]                           for (restart in restarts) {
[10:21:19.279]                             name <- restart$name
[10:21:19.279]                             if (is.null(name)) 
[10:21:19.279]                               next
[10:21:19.279]                             if (!grepl(pattern, name)) 
[10:21:19.279]                               next
[10:21:19.279]                             invokeRestart(restart)
[10:21:19.279]                             muffled <- TRUE
[10:21:19.279]                             break
[10:21:19.279]                           }
[10:21:19.279]                         }
[10:21:19.279]                       }
[10:21:19.279]                       invisible(muffled)
[10:21:19.279]                     }
[10:21:19.279]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.279]                   }
[10:21:19.279]                 }
[10:21:19.279]             }
[10:21:19.279]         }))
[10:21:19.279]     }, error = function(ex) {
[10:21:19.279]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.279]                 ...future.rng), started = ...future.startTime, 
[10:21:19.279]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.279]             version = "1.8"), class = "FutureResult")
[10:21:19.279]     }, finally = {
[10:21:19.279]         if (!identical(...future.workdir, getwd())) 
[10:21:19.279]             setwd(...future.workdir)
[10:21:19.279]         {
[10:21:19.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.279]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.279]             }
[10:21:19.279]             base::options(...future.oldOptions)
[10:21:19.279]             if (.Platform$OS.type == "windows") {
[10:21:19.279]                 old_names <- names(...future.oldEnvVars)
[10:21:19.279]                 envs <- base::Sys.getenv()
[10:21:19.279]                 names <- names(envs)
[10:21:19.279]                 common <- intersect(names, old_names)
[10:21:19.279]                 added <- setdiff(names, old_names)
[10:21:19.279]                 removed <- setdiff(old_names, names)
[10:21:19.279]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.279]                   envs[common]]
[10:21:19.279]                 NAMES <- toupper(changed)
[10:21:19.279]                 args <- list()
[10:21:19.279]                 for (kk in seq_along(NAMES)) {
[10:21:19.279]                   name <- changed[[kk]]
[10:21:19.279]                   NAME <- NAMES[[kk]]
[10:21:19.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.279]                     next
[10:21:19.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.279]                 }
[10:21:19.279]                 NAMES <- toupper(added)
[10:21:19.279]                 for (kk in seq_along(NAMES)) {
[10:21:19.279]                   name <- added[[kk]]
[10:21:19.279]                   NAME <- NAMES[[kk]]
[10:21:19.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.279]                     next
[10:21:19.279]                   args[[name]] <- ""
[10:21:19.279]                 }
[10:21:19.279]                 NAMES <- toupper(removed)
[10:21:19.279]                 for (kk in seq_along(NAMES)) {
[10:21:19.279]                   name <- removed[[kk]]
[10:21:19.279]                   NAME <- NAMES[[kk]]
[10:21:19.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.279]                     next
[10:21:19.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.279]                 }
[10:21:19.279]                 if (length(args) > 0) 
[10:21:19.279]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.279]             }
[10:21:19.279]             else {
[10:21:19.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.279]             }
[10:21:19.279]             {
[10:21:19.279]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.279]                   0L) {
[10:21:19.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.279]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.279]                   base::options(opts)
[10:21:19.279]                 }
[10:21:19.279]                 {
[10:21:19.279]                   {
[10:21:19.279]                     NULL
[10:21:19.279]                     RNGkind("Mersenne-Twister")
[10:21:19.279]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.279]                       inherits = FALSE)
[10:21:19.279]                   }
[10:21:19.279]                   options(future.plan = NULL)
[10:21:19.279]                   if (is.na(NA_character_)) 
[10:21:19.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.279]                     .init = FALSE)
[10:21:19.279]                 }
[10:21:19.279]             }
[10:21:19.279]         }
[10:21:19.279]     })
[10:21:19.279]     if (TRUE) {
[10:21:19.279]         base::sink(type = "output", split = FALSE)
[10:21:19.279]         if (TRUE) {
[10:21:19.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.279]         }
[10:21:19.279]         else {
[10:21:19.279]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.279]         }
[10:21:19.279]         base::close(...future.stdout)
[10:21:19.279]         ...future.stdout <- NULL
[10:21:19.279]     }
[10:21:19.279]     ...future.result$conditions <- ...future.conditions
[10:21:19.279]     ...future.result$finished <- base::Sys.time()
[10:21:19.279]     ...future.result
[10:21:19.279] }
[10:21:19.281] plan(): Setting new future strategy stack:
[10:21:19.281] List of future strategies:
[10:21:19.281] 1. sequential:
[10:21:19.281]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.281]    - tweaked: FALSE
[10:21:19.281]    - call: NULL
[10:21:19.281] plan(): nbrOfWorkers() = 1
[10:21:19.282] plan(): Setting new future strategy stack:
[10:21:19.282] List of future strategies:
[10:21:19.282] 1. sequential:
[10:21:19.282]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.282]    - tweaked: FALSE
[10:21:19.282]    - call: plan(strategy)
[10:21:19.282] plan(): nbrOfWorkers() = 1
[10:21:19.282] SequentialFuture started (and completed)
[10:21:19.283] - Launch lazy future ... done
[10:21:19.283] run() for ‘SequentialFuture’ ... done
[10:21:19.283] getGlobalsAndPackages() ...
[10:21:19.283] Searching for globals...
[10:21:19.283] 
[10:21:19.283] Searching for globals ... DONE
[10:21:19.283] - globals: [0] <none>
[10:21:19.283] getGlobalsAndPackages() ... DONE
[10:21:19.284] run() for ‘Future’ ...
[10:21:19.284] - state: ‘created’
[10:21:19.284] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.284] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.284] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.284]   - Field: ‘label’
[10:21:19.284]   - Field: ‘local’
[10:21:19.284]   - Field: ‘owner’
[10:21:19.284]   - Field: ‘envir’
[10:21:19.285]   - Field: ‘packages’
[10:21:19.285]   - Field: ‘gc’
[10:21:19.285]   - Field: ‘conditions’
[10:21:19.285]   - Field: ‘expr’
[10:21:19.285]   - Field: ‘uuid’
[10:21:19.285]   - Field: ‘seed’
[10:21:19.285]   - Field: ‘version’
[10:21:19.285]   - Field: ‘result’
[10:21:19.285]   - Field: ‘asynchronous’
[10:21:19.285]   - Field: ‘calls’
[10:21:19.285]   - Field: ‘globals’
[10:21:19.285]   - Field: ‘stdout’
[10:21:19.285]   - Field: ‘earlySignal’
[10:21:19.286]   - Field: ‘lazy’
[10:21:19.286]   - Field: ‘state’
[10:21:19.286] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.286] - Launch lazy future ...
[10:21:19.286] Packages needed by the future expression (n = 0): <none>
[10:21:19.286] Packages needed by future strategies (n = 0): <none>
[10:21:19.286] {
[10:21:19.286]     {
[10:21:19.286]         {
[10:21:19.286]             ...future.startTime <- base::Sys.time()
[10:21:19.286]             {
[10:21:19.286]                 {
[10:21:19.286]                   {
[10:21:19.286]                     base::local({
[10:21:19.286]                       has_future <- base::requireNamespace("future", 
[10:21:19.286]                         quietly = TRUE)
[10:21:19.286]                       if (has_future) {
[10:21:19.286]                         ns <- base::getNamespace("future")
[10:21:19.286]                         version <- ns[[".package"]][["version"]]
[10:21:19.286]                         if (is.null(version)) 
[10:21:19.286]                           version <- utils::packageVersion("future")
[10:21:19.286]                       }
[10:21:19.286]                       else {
[10:21:19.286]                         version <- NULL
[10:21:19.286]                       }
[10:21:19.286]                       if (!has_future || version < "1.8.0") {
[10:21:19.286]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.286]                           "", base::R.version$version.string), 
[10:21:19.286]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.286]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.286]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.286]                             "release", "version")], collapse = " "), 
[10:21:19.286]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.286]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.286]                           info)
[10:21:19.286]                         info <- base::paste(info, collapse = "; ")
[10:21:19.286]                         if (!has_future) {
[10:21:19.286]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.286]                             info)
[10:21:19.286]                         }
[10:21:19.286]                         else {
[10:21:19.286]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.286]                             info, version)
[10:21:19.286]                         }
[10:21:19.286]                         base::stop(msg)
[10:21:19.286]                       }
[10:21:19.286]                     })
[10:21:19.286]                   }
[10:21:19.286]                   ...future.strategy.old <- future::plan("list")
[10:21:19.286]                   options(future.plan = NULL)
[10:21:19.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.286]                 }
[10:21:19.286]                 ...future.workdir <- getwd()
[10:21:19.286]             }
[10:21:19.286]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.286]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.286]         }
[10:21:19.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.286]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.286]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.286]             base::names(...future.oldOptions))
[10:21:19.286]     }
[10:21:19.286]     if (FALSE) {
[10:21:19.286]     }
[10:21:19.286]     else {
[10:21:19.286]         if (TRUE) {
[10:21:19.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.286]                 open = "w")
[10:21:19.286]         }
[10:21:19.286]         else {
[10:21:19.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.286]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.286]         }
[10:21:19.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.286]             base::sink(type = "output", split = FALSE)
[10:21:19.286]             base::close(...future.stdout)
[10:21:19.286]         }, add = TRUE)
[10:21:19.286]     }
[10:21:19.286]     ...future.frame <- base::sys.nframe()
[10:21:19.286]     ...future.conditions <- base::list()
[10:21:19.286]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.286]     if (FALSE) {
[10:21:19.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.286]     }
[10:21:19.286]     ...future.result <- base::tryCatch({
[10:21:19.286]         base::withCallingHandlers({
[10:21:19.286]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.286]             future::FutureResult(value = ...future.value$value, 
[10:21:19.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.286]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.286]                     ...future.globalenv.names))
[10:21:19.286]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.286]         }, condition = base::local({
[10:21:19.286]             c <- base::c
[10:21:19.286]             inherits <- base::inherits
[10:21:19.286]             invokeRestart <- base::invokeRestart
[10:21:19.286]             length <- base::length
[10:21:19.286]             list <- base::list
[10:21:19.286]             seq.int <- base::seq.int
[10:21:19.286]             signalCondition <- base::signalCondition
[10:21:19.286]             sys.calls <- base::sys.calls
[10:21:19.286]             `[[` <- base::`[[`
[10:21:19.286]             `+` <- base::`+`
[10:21:19.286]             `<<-` <- base::`<<-`
[10:21:19.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.286]                   3L)]
[10:21:19.286]             }
[10:21:19.286]             function(cond) {
[10:21:19.286]                 is_error <- inherits(cond, "error")
[10:21:19.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.286]                   NULL)
[10:21:19.286]                 if (is_error) {
[10:21:19.286]                   sessionInformation <- function() {
[10:21:19.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.286]                       search = base::search(), system = base::Sys.info())
[10:21:19.286]                   }
[10:21:19.286]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.286]                     cond$call), session = sessionInformation(), 
[10:21:19.286]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.286]                   signalCondition(cond)
[10:21:19.286]                 }
[10:21:19.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.286]                 "immediateCondition"))) {
[10:21:19.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.286]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.286]                   if (TRUE && !signal) {
[10:21:19.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.286]                     {
[10:21:19.286]                       inherits <- base::inherits
[10:21:19.286]                       invokeRestart <- base::invokeRestart
[10:21:19.286]                       is.null <- base::is.null
[10:21:19.286]                       muffled <- FALSE
[10:21:19.286]                       if (inherits(cond, "message")) {
[10:21:19.286]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.286]                         if (muffled) 
[10:21:19.286]                           invokeRestart("muffleMessage")
[10:21:19.286]                       }
[10:21:19.286]                       else if (inherits(cond, "warning")) {
[10:21:19.286]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.286]                         if (muffled) 
[10:21:19.286]                           invokeRestart("muffleWarning")
[10:21:19.286]                       }
[10:21:19.286]                       else if (inherits(cond, "condition")) {
[10:21:19.286]                         if (!is.null(pattern)) {
[10:21:19.286]                           computeRestarts <- base::computeRestarts
[10:21:19.286]                           grepl <- base::grepl
[10:21:19.286]                           restarts <- computeRestarts(cond)
[10:21:19.286]                           for (restart in restarts) {
[10:21:19.286]                             name <- restart$name
[10:21:19.286]                             if (is.null(name)) 
[10:21:19.286]                               next
[10:21:19.286]                             if (!grepl(pattern, name)) 
[10:21:19.286]                               next
[10:21:19.286]                             invokeRestart(restart)
[10:21:19.286]                             muffled <- TRUE
[10:21:19.286]                             break
[10:21:19.286]                           }
[10:21:19.286]                         }
[10:21:19.286]                       }
[10:21:19.286]                       invisible(muffled)
[10:21:19.286]                     }
[10:21:19.286]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.286]                   }
[10:21:19.286]                 }
[10:21:19.286]                 else {
[10:21:19.286]                   if (TRUE) {
[10:21:19.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.286]                     {
[10:21:19.286]                       inherits <- base::inherits
[10:21:19.286]                       invokeRestart <- base::invokeRestart
[10:21:19.286]                       is.null <- base::is.null
[10:21:19.286]                       muffled <- FALSE
[10:21:19.286]                       if (inherits(cond, "message")) {
[10:21:19.286]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.286]                         if (muffled) 
[10:21:19.286]                           invokeRestart("muffleMessage")
[10:21:19.286]                       }
[10:21:19.286]                       else if (inherits(cond, "warning")) {
[10:21:19.286]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.286]                         if (muffled) 
[10:21:19.286]                           invokeRestart("muffleWarning")
[10:21:19.286]                       }
[10:21:19.286]                       else if (inherits(cond, "condition")) {
[10:21:19.286]                         if (!is.null(pattern)) {
[10:21:19.286]                           computeRestarts <- base::computeRestarts
[10:21:19.286]                           grepl <- base::grepl
[10:21:19.286]                           restarts <- computeRestarts(cond)
[10:21:19.286]                           for (restart in restarts) {
[10:21:19.286]                             name <- restart$name
[10:21:19.286]                             if (is.null(name)) 
[10:21:19.286]                               next
[10:21:19.286]                             if (!grepl(pattern, name)) 
[10:21:19.286]                               next
[10:21:19.286]                             invokeRestart(restart)
[10:21:19.286]                             muffled <- TRUE
[10:21:19.286]                             break
[10:21:19.286]                           }
[10:21:19.286]                         }
[10:21:19.286]                       }
[10:21:19.286]                       invisible(muffled)
[10:21:19.286]                     }
[10:21:19.286]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.286]                   }
[10:21:19.286]                 }
[10:21:19.286]             }
[10:21:19.286]         }))
[10:21:19.286]     }, error = function(ex) {
[10:21:19.286]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.286]                 ...future.rng), started = ...future.startTime, 
[10:21:19.286]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.286]             version = "1.8"), class = "FutureResult")
[10:21:19.286]     }, finally = {
[10:21:19.286]         if (!identical(...future.workdir, getwd())) 
[10:21:19.286]             setwd(...future.workdir)
[10:21:19.286]         {
[10:21:19.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.286]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.286]             }
[10:21:19.286]             base::options(...future.oldOptions)
[10:21:19.286]             if (.Platform$OS.type == "windows") {
[10:21:19.286]                 old_names <- names(...future.oldEnvVars)
[10:21:19.286]                 envs <- base::Sys.getenv()
[10:21:19.286]                 names <- names(envs)
[10:21:19.286]                 common <- intersect(names, old_names)
[10:21:19.286]                 added <- setdiff(names, old_names)
[10:21:19.286]                 removed <- setdiff(old_names, names)
[10:21:19.286]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.286]                   envs[common]]
[10:21:19.286]                 NAMES <- toupper(changed)
[10:21:19.286]                 args <- list()
[10:21:19.286]                 for (kk in seq_along(NAMES)) {
[10:21:19.286]                   name <- changed[[kk]]
[10:21:19.286]                   NAME <- NAMES[[kk]]
[10:21:19.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.286]                     next
[10:21:19.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.286]                 }
[10:21:19.286]                 NAMES <- toupper(added)
[10:21:19.286]                 for (kk in seq_along(NAMES)) {
[10:21:19.286]                   name <- added[[kk]]
[10:21:19.286]                   NAME <- NAMES[[kk]]
[10:21:19.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.286]                     next
[10:21:19.286]                   args[[name]] <- ""
[10:21:19.286]                 }
[10:21:19.286]                 NAMES <- toupper(removed)
[10:21:19.286]                 for (kk in seq_along(NAMES)) {
[10:21:19.286]                   name <- removed[[kk]]
[10:21:19.286]                   NAME <- NAMES[[kk]]
[10:21:19.286]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.286]                     next
[10:21:19.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.286]                 }
[10:21:19.286]                 if (length(args) > 0) 
[10:21:19.286]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.286]             }
[10:21:19.286]             else {
[10:21:19.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.286]             }
[10:21:19.286]             {
[10:21:19.286]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.286]                   0L) {
[10:21:19.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.286]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.286]                   base::options(opts)
[10:21:19.286]                 }
[10:21:19.286]                 {
[10:21:19.286]                   {
[10:21:19.286]                     NULL
[10:21:19.286]                     RNGkind("Mersenne-Twister")
[10:21:19.286]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.286]                       inherits = FALSE)
[10:21:19.286]                   }
[10:21:19.286]                   options(future.plan = NULL)
[10:21:19.286]                   if (is.na(NA_character_)) 
[10:21:19.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.286]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.286]                     .init = FALSE)
[10:21:19.286]                 }
[10:21:19.286]             }
[10:21:19.286]         }
[10:21:19.286]     })
[10:21:19.286]     if (TRUE) {
[10:21:19.286]         base::sink(type = "output", split = FALSE)
[10:21:19.286]         if (TRUE) {
[10:21:19.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.286]         }
[10:21:19.286]         else {
[10:21:19.286]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.286]         }
[10:21:19.286]         base::close(...future.stdout)
[10:21:19.286]         ...future.stdout <- NULL
[10:21:19.286]     }
[10:21:19.286]     ...future.result$conditions <- ...future.conditions
[10:21:19.286]     ...future.result$finished <- base::Sys.time()
[10:21:19.286]     ...future.result
[10:21:19.286] }
[10:21:19.288] plan(): Setting new future strategy stack:
[10:21:19.288] List of future strategies:
[10:21:19.288] 1. sequential:
[10:21:19.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.288]    - tweaked: FALSE
[10:21:19.288]    - call: NULL
[10:21:19.289] plan(): nbrOfWorkers() = 1
[10:21:19.289] plan(): Setting new future strategy stack:
[10:21:19.289] List of future strategies:
[10:21:19.289] 1. sequential:
[10:21:19.289]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.289]    - tweaked: FALSE
[10:21:19.289]    - call: plan(strategy)
[10:21:19.290] plan(): nbrOfWorkers() = 1
[10:21:19.290] SequentialFuture started (and completed)
[10:21:19.290] - Launch lazy future ... done
[10:21:19.290] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e4e3aaa8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e5291d50> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e4e3aaa8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55e8e5291d50> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:21:19.296] resolved() for ‘SequentialFuture’ ...
[10:21:19.296] - state: ‘finished’
[10:21:19.296] - run: TRUE
[10:21:19.297] - result: ‘FutureResult’
[10:21:19.297] resolved() for ‘SequentialFuture’ ... done
[10:21:19.297] resolved() for ‘SequentialFuture’ ...
[10:21:19.297] - state: ‘finished’
[10:21:19.297] - run: TRUE
[10:21:19.297] - result: ‘FutureResult’
[10:21:19.297] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:19.299] resolve() on list ...
[10:21:19.299]  recursive: 0
[10:21:19.299]  length: 6
[10:21:19.299]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:19.299] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.299] - nx: 6
[10:21:19.299] - relay: TRUE
[10:21:19.299] - stdout: TRUE
[10:21:19.300] - signal: TRUE
[10:21:19.300] - resignal: FALSE
[10:21:19.300] - force: TRUE
[10:21:19.300] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.300] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.300]  - until=2
[10:21:19.300]  - relaying element #2
[10:21:19.300] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.300] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.300] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.300]  length: 5 (resolved future 1)
[10:21:19.300] resolved() for ‘SequentialFuture’ ...
[10:21:19.300] - state: ‘finished’
[10:21:19.301] - run: TRUE
[10:21:19.301] - result: ‘FutureResult’
[10:21:19.301] resolved() for ‘SequentialFuture’ ... done
[10:21:19.301] Future #2
[10:21:19.301] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.301] - nx: 6
[10:21:19.301] - relay: TRUE
[10:21:19.301] - stdout: TRUE
[10:21:19.301] - signal: TRUE
[10:21:19.301] - resignal: FALSE
[10:21:19.301] - force: TRUE
[10:21:19.301] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.302] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.302]  - until=2
[10:21:19.302]  - relaying element #2
[10:21:19.302] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.302] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.302] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.302]  length: 4 (resolved future 2)
[10:21:19.302] resolved() for ‘SequentialFuture’ ...
[10:21:19.302] - state: ‘finished’
[10:21:19.302] - run: TRUE
[10:21:19.302] - result: ‘FutureResult’
[10:21:19.303] resolved() for ‘SequentialFuture’ ... done
[10:21:19.303] Future #3
[10:21:19.303] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.303] - nx: 6
[10:21:19.303] - relay: TRUE
[10:21:19.303] - stdout: TRUE
[10:21:19.303] - signal: TRUE
[10:21:19.303] - resignal: FALSE
[10:21:19.303] - force: TRUE
[10:21:19.303] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.303] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.303]  - until=3
[10:21:19.303]  - relaying element #3
[10:21:19.304] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.304] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.304] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.304]  length: 3 (resolved future 3)
[10:21:19.304] signalConditionsASAP(NULL, pos=4) ...
[10:21:19.304] - nx: 6
[10:21:19.304] - relay: TRUE
[10:21:19.304] - stdout: TRUE
[10:21:19.304] - signal: TRUE
[10:21:19.304] - resignal: FALSE
[10:21:19.304] - force: TRUE
[10:21:19.304] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.305] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.305]  - until=5
[10:21:19.305]  - relaying element #5
[10:21:19.305] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.305] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.305] signalConditionsASAP(NULL, pos=4) ... done
[10:21:19.305]  length: 2 (resolved future 4)
[10:21:19.305] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.305] - nx: 6
[10:21:19.305] - relay: TRUE
[10:21:19.305] - stdout: TRUE
[10:21:19.305] - signal: TRUE
[10:21:19.305] - resignal: FALSE
[10:21:19.306] - force: TRUE
[10:21:19.306] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.306] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.306]  - until=6
[10:21:19.306]  - relaying element #6
[10:21:19.306] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.306] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.306] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.306]  length: 1 (resolved future 5)
[10:21:19.306] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.306] - nx: 6
[10:21:19.306] - relay: TRUE
[10:21:19.306] - stdout: TRUE
[10:21:19.307] - signal: TRUE
[10:21:19.307] - resignal: FALSE
[10:21:19.307] - force: TRUE
[10:21:19.307] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.307] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.307]  - until=6
[10:21:19.307] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.307] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.307] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.307]  length: 0 (resolved future 6)
[10:21:19.307] Relaying remaining futures
[10:21:19.307] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.307] - nx: 6
[10:21:19.308] - relay: TRUE
[10:21:19.308] - stdout: TRUE
[10:21:19.308] - signal: TRUE
[10:21:19.308] - resignal: FALSE
[10:21:19.308] - force: TRUE
[10:21:19.308] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.308] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:19.308] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.308] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.308] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.308] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[10:21:19.317] plan(): Setting new future strategy stack:
[10:21:19.317] List of future strategies:
[10:21:19.317] 1. sequential:
[10:21:19.317]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.317]    - tweaked: FALSE
[10:21:19.317]    - call: plan(strategy)
[10:21:19.318] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[10:21:19.318] getGlobalsAndPackages() ...
[10:21:19.318] Searching for globals...
[10:21:19.318] 
[10:21:19.319] Searching for globals ... DONE
[10:21:19.319] - globals: [0] <none>
[10:21:19.319] getGlobalsAndPackages() ... DONE
[10:21:19.319] run() for ‘Future’ ...
[10:21:19.319] - state: ‘created’
[10:21:19.319] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.319] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.319] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.320]   - Field: ‘label’
[10:21:19.320]   - Field: ‘local’
[10:21:19.320]   - Field: ‘owner’
[10:21:19.320]   - Field: ‘envir’
[10:21:19.320]   - Field: ‘packages’
[10:21:19.320]   - Field: ‘gc’
[10:21:19.320]   - Field: ‘conditions’
[10:21:19.320]   - Field: ‘expr’
[10:21:19.320]   - Field: ‘uuid’
[10:21:19.320]   - Field: ‘seed’
[10:21:19.320]   - Field: ‘version’
[10:21:19.320]   - Field: ‘result’
[10:21:19.321]   - Field: ‘asynchronous’
[10:21:19.321]   - Field: ‘calls’
[10:21:19.321]   - Field: ‘globals’
[10:21:19.321]   - Field: ‘stdout’
[10:21:19.321]   - Field: ‘earlySignal’
[10:21:19.321]   - Field: ‘lazy’
[10:21:19.321]   - Field: ‘state’
[10:21:19.321] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.321] - Launch lazy future ...
[10:21:19.321] Packages needed by the future expression (n = 0): <none>
[10:21:19.321] Packages needed by future strategies (n = 0): <none>
[10:21:19.322] {
[10:21:19.322]     {
[10:21:19.322]         {
[10:21:19.322]             ...future.startTime <- base::Sys.time()
[10:21:19.322]             {
[10:21:19.322]                 {
[10:21:19.322]                   {
[10:21:19.322]                     base::local({
[10:21:19.322]                       has_future <- base::requireNamespace("future", 
[10:21:19.322]                         quietly = TRUE)
[10:21:19.322]                       if (has_future) {
[10:21:19.322]                         ns <- base::getNamespace("future")
[10:21:19.322]                         version <- ns[[".package"]][["version"]]
[10:21:19.322]                         if (is.null(version)) 
[10:21:19.322]                           version <- utils::packageVersion("future")
[10:21:19.322]                       }
[10:21:19.322]                       else {
[10:21:19.322]                         version <- NULL
[10:21:19.322]                       }
[10:21:19.322]                       if (!has_future || version < "1.8.0") {
[10:21:19.322]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.322]                           "", base::R.version$version.string), 
[10:21:19.322]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.322]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.322]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.322]                             "release", "version")], collapse = " "), 
[10:21:19.322]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.322]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.322]                           info)
[10:21:19.322]                         info <- base::paste(info, collapse = "; ")
[10:21:19.322]                         if (!has_future) {
[10:21:19.322]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.322]                             info)
[10:21:19.322]                         }
[10:21:19.322]                         else {
[10:21:19.322]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.322]                             info, version)
[10:21:19.322]                         }
[10:21:19.322]                         base::stop(msg)
[10:21:19.322]                       }
[10:21:19.322]                     })
[10:21:19.322]                   }
[10:21:19.322]                   ...future.strategy.old <- future::plan("list")
[10:21:19.322]                   options(future.plan = NULL)
[10:21:19.322]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.322]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.322]                 }
[10:21:19.322]                 ...future.workdir <- getwd()
[10:21:19.322]             }
[10:21:19.322]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.322]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.322]         }
[10:21:19.322]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.322]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.322]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.322]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.322]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.322]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.322]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.322]             base::names(...future.oldOptions))
[10:21:19.322]     }
[10:21:19.322]     if (FALSE) {
[10:21:19.322]     }
[10:21:19.322]     else {
[10:21:19.322]         if (TRUE) {
[10:21:19.322]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.322]                 open = "w")
[10:21:19.322]         }
[10:21:19.322]         else {
[10:21:19.322]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.322]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.322]         }
[10:21:19.322]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.322]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.322]             base::sink(type = "output", split = FALSE)
[10:21:19.322]             base::close(...future.stdout)
[10:21:19.322]         }, add = TRUE)
[10:21:19.322]     }
[10:21:19.322]     ...future.frame <- base::sys.nframe()
[10:21:19.322]     ...future.conditions <- base::list()
[10:21:19.322]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.322]     if (FALSE) {
[10:21:19.322]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.322]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.322]     }
[10:21:19.322]     ...future.result <- base::tryCatch({
[10:21:19.322]         base::withCallingHandlers({
[10:21:19.322]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.322]             future::FutureResult(value = ...future.value$value, 
[10:21:19.322]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.322]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.322]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.322]                     ...future.globalenv.names))
[10:21:19.322]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.322]         }, condition = base::local({
[10:21:19.322]             c <- base::c
[10:21:19.322]             inherits <- base::inherits
[10:21:19.322]             invokeRestart <- base::invokeRestart
[10:21:19.322]             length <- base::length
[10:21:19.322]             list <- base::list
[10:21:19.322]             seq.int <- base::seq.int
[10:21:19.322]             signalCondition <- base::signalCondition
[10:21:19.322]             sys.calls <- base::sys.calls
[10:21:19.322]             `[[` <- base::`[[`
[10:21:19.322]             `+` <- base::`+`
[10:21:19.322]             `<<-` <- base::`<<-`
[10:21:19.322]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.322]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.322]                   3L)]
[10:21:19.322]             }
[10:21:19.322]             function(cond) {
[10:21:19.322]                 is_error <- inherits(cond, "error")
[10:21:19.322]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.322]                   NULL)
[10:21:19.322]                 if (is_error) {
[10:21:19.322]                   sessionInformation <- function() {
[10:21:19.322]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.322]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.322]                       search = base::search(), system = base::Sys.info())
[10:21:19.322]                   }
[10:21:19.322]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.322]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.322]                     cond$call), session = sessionInformation(), 
[10:21:19.322]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.322]                   signalCondition(cond)
[10:21:19.322]                 }
[10:21:19.322]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.322]                 "immediateCondition"))) {
[10:21:19.322]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.322]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.322]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.322]                   if (TRUE && !signal) {
[10:21:19.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.322]                     {
[10:21:19.322]                       inherits <- base::inherits
[10:21:19.322]                       invokeRestart <- base::invokeRestart
[10:21:19.322]                       is.null <- base::is.null
[10:21:19.322]                       muffled <- FALSE
[10:21:19.322]                       if (inherits(cond, "message")) {
[10:21:19.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.322]                         if (muffled) 
[10:21:19.322]                           invokeRestart("muffleMessage")
[10:21:19.322]                       }
[10:21:19.322]                       else if (inherits(cond, "warning")) {
[10:21:19.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.322]                         if (muffled) 
[10:21:19.322]                           invokeRestart("muffleWarning")
[10:21:19.322]                       }
[10:21:19.322]                       else if (inherits(cond, "condition")) {
[10:21:19.322]                         if (!is.null(pattern)) {
[10:21:19.322]                           computeRestarts <- base::computeRestarts
[10:21:19.322]                           grepl <- base::grepl
[10:21:19.322]                           restarts <- computeRestarts(cond)
[10:21:19.322]                           for (restart in restarts) {
[10:21:19.322]                             name <- restart$name
[10:21:19.322]                             if (is.null(name)) 
[10:21:19.322]                               next
[10:21:19.322]                             if (!grepl(pattern, name)) 
[10:21:19.322]                               next
[10:21:19.322]                             invokeRestart(restart)
[10:21:19.322]                             muffled <- TRUE
[10:21:19.322]                             break
[10:21:19.322]                           }
[10:21:19.322]                         }
[10:21:19.322]                       }
[10:21:19.322]                       invisible(muffled)
[10:21:19.322]                     }
[10:21:19.322]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.322]                   }
[10:21:19.322]                 }
[10:21:19.322]                 else {
[10:21:19.322]                   if (TRUE) {
[10:21:19.322]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.322]                     {
[10:21:19.322]                       inherits <- base::inherits
[10:21:19.322]                       invokeRestart <- base::invokeRestart
[10:21:19.322]                       is.null <- base::is.null
[10:21:19.322]                       muffled <- FALSE
[10:21:19.322]                       if (inherits(cond, "message")) {
[10:21:19.322]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.322]                         if (muffled) 
[10:21:19.322]                           invokeRestart("muffleMessage")
[10:21:19.322]                       }
[10:21:19.322]                       else if (inherits(cond, "warning")) {
[10:21:19.322]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.322]                         if (muffled) 
[10:21:19.322]                           invokeRestart("muffleWarning")
[10:21:19.322]                       }
[10:21:19.322]                       else if (inherits(cond, "condition")) {
[10:21:19.322]                         if (!is.null(pattern)) {
[10:21:19.322]                           computeRestarts <- base::computeRestarts
[10:21:19.322]                           grepl <- base::grepl
[10:21:19.322]                           restarts <- computeRestarts(cond)
[10:21:19.322]                           for (restart in restarts) {
[10:21:19.322]                             name <- restart$name
[10:21:19.322]                             if (is.null(name)) 
[10:21:19.322]                               next
[10:21:19.322]                             if (!grepl(pattern, name)) 
[10:21:19.322]                               next
[10:21:19.322]                             invokeRestart(restart)
[10:21:19.322]                             muffled <- TRUE
[10:21:19.322]                             break
[10:21:19.322]                           }
[10:21:19.322]                         }
[10:21:19.322]                       }
[10:21:19.322]                       invisible(muffled)
[10:21:19.322]                     }
[10:21:19.322]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.322]                   }
[10:21:19.322]                 }
[10:21:19.322]             }
[10:21:19.322]         }))
[10:21:19.322]     }, error = function(ex) {
[10:21:19.322]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.322]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.322]                 ...future.rng), started = ...future.startTime, 
[10:21:19.322]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.322]             version = "1.8"), class = "FutureResult")
[10:21:19.322]     }, finally = {
[10:21:19.322]         if (!identical(...future.workdir, getwd())) 
[10:21:19.322]             setwd(...future.workdir)
[10:21:19.322]         {
[10:21:19.322]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.322]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.322]             }
[10:21:19.322]             base::options(...future.oldOptions)
[10:21:19.322]             if (.Platform$OS.type == "windows") {
[10:21:19.322]                 old_names <- names(...future.oldEnvVars)
[10:21:19.322]                 envs <- base::Sys.getenv()
[10:21:19.322]                 names <- names(envs)
[10:21:19.322]                 common <- intersect(names, old_names)
[10:21:19.322]                 added <- setdiff(names, old_names)
[10:21:19.322]                 removed <- setdiff(old_names, names)
[10:21:19.322]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.322]                   envs[common]]
[10:21:19.322]                 NAMES <- toupper(changed)
[10:21:19.322]                 args <- list()
[10:21:19.322]                 for (kk in seq_along(NAMES)) {
[10:21:19.322]                   name <- changed[[kk]]
[10:21:19.322]                   NAME <- NAMES[[kk]]
[10:21:19.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.322]                     next
[10:21:19.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.322]                 }
[10:21:19.322]                 NAMES <- toupper(added)
[10:21:19.322]                 for (kk in seq_along(NAMES)) {
[10:21:19.322]                   name <- added[[kk]]
[10:21:19.322]                   NAME <- NAMES[[kk]]
[10:21:19.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.322]                     next
[10:21:19.322]                   args[[name]] <- ""
[10:21:19.322]                 }
[10:21:19.322]                 NAMES <- toupper(removed)
[10:21:19.322]                 for (kk in seq_along(NAMES)) {
[10:21:19.322]                   name <- removed[[kk]]
[10:21:19.322]                   NAME <- NAMES[[kk]]
[10:21:19.322]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.322]                     next
[10:21:19.322]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.322]                 }
[10:21:19.322]                 if (length(args) > 0) 
[10:21:19.322]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.322]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.322]             }
[10:21:19.322]             else {
[10:21:19.322]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.322]             }
[10:21:19.322]             {
[10:21:19.322]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.322]                   0L) {
[10:21:19.322]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.322]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.322]                   base::options(opts)
[10:21:19.322]                 }
[10:21:19.322]                 {
[10:21:19.322]                   {
[10:21:19.322]                     NULL
[10:21:19.322]                     RNGkind("Mersenne-Twister")
[10:21:19.322]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.322]                       inherits = FALSE)
[10:21:19.322]                   }
[10:21:19.322]                   options(future.plan = NULL)
[10:21:19.322]                   if (is.na(NA_character_)) 
[10:21:19.322]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.322]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.322]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.322]                     .init = FALSE)
[10:21:19.322]                 }
[10:21:19.322]             }
[10:21:19.322]         }
[10:21:19.322]     })
[10:21:19.322]     if (TRUE) {
[10:21:19.322]         base::sink(type = "output", split = FALSE)
[10:21:19.322]         if (TRUE) {
[10:21:19.322]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.322]         }
[10:21:19.322]         else {
[10:21:19.322]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.322]         }
[10:21:19.322]         base::close(...future.stdout)
[10:21:19.322]         ...future.stdout <- NULL
[10:21:19.322]     }
[10:21:19.322]     ...future.result$conditions <- ...future.conditions
[10:21:19.322]     ...future.result$finished <- base::Sys.time()
[10:21:19.322]     ...future.result
[10:21:19.322] }
[10:21:19.324] plan(): Setting new future strategy stack:
[10:21:19.324] List of future strategies:
[10:21:19.324] 1. sequential:
[10:21:19.324]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.324]    - tweaked: FALSE
[10:21:19.324]    - call: NULL
[10:21:19.324] plan(): nbrOfWorkers() = 1
[10:21:19.325] plan(): Setting new future strategy stack:
[10:21:19.325] List of future strategies:
[10:21:19.325] 1. sequential:
[10:21:19.325]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.325]    - tweaked: FALSE
[10:21:19.325]    - call: plan(strategy)
[10:21:19.325] plan(): nbrOfWorkers() = 1
[10:21:19.325] SequentialFuture started (and completed)
[10:21:19.325] - Launch lazy future ... done
[10:21:19.326] run() for ‘SequentialFuture’ ... done
[10:21:19.326] getGlobalsAndPackages() ...
[10:21:19.326] Searching for globals...
[10:21:19.326] 
[10:21:19.326] Searching for globals ... DONE
[10:21:19.326] - globals: [0] <none>
[10:21:19.326] getGlobalsAndPackages() ... DONE
[10:21:19.326] run() for ‘Future’ ...
[10:21:19.327] - state: ‘created’
[10:21:19.327] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.327] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.327] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.327]   - Field: ‘label’
[10:21:19.327]   - Field: ‘local’
[10:21:19.327]   - Field: ‘owner’
[10:21:19.327]   - Field: ‘envir’
[10:21:19.327]   - Field: ‘packages’
[10:21:19.327]   - Field: ‘gc’
[10:21:19.328]   - Field: ‘conditions’
[10:21:19.328]   - Field: ‘expr’
[10:21:19.328]   - Field: ‘uuid’
[10:21:19.328]   - Field: ‘seed’
[10:21:19.328]   - Field: ‘version’
[10:21:19.328]   - Field: ‘result’
[10:21:19.328]   - Field: ‘asynchronous’
[10:21:19.328]   - Field: ‘calls’
[10:21:19.328]   - Field: ‘globals’
[10:21:19.328]   - Field: ‘stdout’
[10:21:19.328]   - Field: ‘earlySignal’
[10:21:19.328]   - Field: ‘lazy’
[10:21:19.329]   - Field: ‘state’
[10:21:19.329] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.329] - Launch lazy future ...
[10:21:19.329] Packages needed by the future expression (n = 0): <none>
[10:21:19.329] Packages needed by future strategies (n = 0): <none>
[10:21:19.329] {
[10:21:19.329]     {
[10:21:19.329]         {
[10:21:19.329]             ...future.startTime <- base::Sys.time()
[10:21:19.329]             {
[10:21:19.329]                 {
[10:21:19.329]                   {
[10:21:19.329]                     base::local({
[10:21:19.329]                       has_future <- base::requireNamespace("future", 
[10:21:19.329]                         quietly = TRUE)
[10:21:19.329]                       if (has_future) {
[10:21:19.329]                         ns <- base::getNamespace("future")
[10:21:19.329]                         version <- ns[[".package"]][["version"]]
[10:21:19.329]                         if (is.null(version)) 
[10:21:19.329]                           version <- utils::packageVersion("future")
[10:21:19.329]                       }
[10:21:19.329]                       else {
[10:21:19.329]                         version <- NULL
[10:21:19.329]                       }
[10:21:19.329]                       if (!has_future || version < "1.8.0") {
[10:21:19.329]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.329]                           "", base::R.version$version.string), 
[10:21:19.329]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.329]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.329]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.329]                             "release", "version")], collapse = " "), 
[10:21:19.329]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.329]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.329]                           info)
[10:21:19.329]                         info <- base::paste(info, collapse = "; ")
[10:21:19.329]                         if (!has_future) {
[10:21:19.329]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.329]                             info)
[10:21:19.329]                         }
[10:21:19.329]                         else {
[10:21:19.329]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.329]                             info, version)
[10:21:19.329]                         }
[10:21:19.329]                         base::stop(msg)
[10:21:19.329]                       }
[10:21:19.329]                     })
[10:21:19.329]                   }
[10:21:19.329]                   ...future.strategy.old <- future::plan("list")
[10:21:19.329]                   options(future.plan = NULL)
[10:21:19.329]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.329]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.329]                 }
[10:21:19.329]                 ...future.workdir <- getwd()
[10:21:19.329]             }
[10:21:19.329]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.329]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.329]         }
[10:21:19.329]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.329]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.329]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.329]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.329]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.329]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.329]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.329]             base::names(...future.oldOptions))
[10:21:19.329]     }
[10:21:19.329]     if (FALSE) {
[10:21:19.329]     }
[10:21:19.329]     else {
[10:21:19.329]         if (TRUE) {
[10:21:19.329]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.329]                 open = "w")
[10:21:19.329]         }
[10:21:19.329]         else {
[10:21:19.329]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.329]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.329]         }
[10:21:19.329]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.329]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.329]             base::sink(type = "output", split = FALSE)
[10:21:19.329]             base::close(...future.stdout)
[10:21:19.329]         }, add = TRUE)
[10:21:19.329]     }
[10:21:19.329]     ...future.frame <- base::sys.nframe()
[10:21:19.329]     ...future.conditions <- base::list()
[10:21:19.329]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.329]     if (FALSE) {
[10:21:19.329]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.329]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.329]     }
[10:21:19.329]     ...future.result <- base::tryCatch({
[10:21:19.329]         base::withCallingHandlers({
[10:21:19.329]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.329]             future::FutureResult(value = ...future.value$value, 
[10:21:19.329]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.329]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.329]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.329]                     ...future.globalenv.names))
[10:21:19.329]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.329]         }, condition = base::local({
[10:21:19.329]             c <- base::c
[10:21:19.329]             inherits <- base::inherits
[10:21:19.329]             invokeRestart <- base::invokeRestart
[10:21:19.329]             length <- base::length
[10:21:19.329]             list <- base::list
[10:21:19.329]             seq.int <- base::seq.int
[10:21:19.329]             signalCondition <- base::signalCondition
[10:21:19.329]             sys.calls <- base::sys.calls
[10:21:19.329]             `[[` <- base::`[[`
[10:21:19.329]             `+` <- base::`+`
[10:21:19.329]             `<<-` <- base::`<<-`
[10:21:19.329]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.329]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.329]                   3L)]
[10:21:19.329]             }
[10:21:19.329]             function(cond) {
[10:21:19.329]                 is_error <- inherits(cond, "error")
[10:21:19.329]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.329]                   NULL)
[10:21:19.329]                 if (is_error) {
[10:21:19.329]                   sessionInformation <- function() {
[10:21:19.329]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.329]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.329]                       search = base::search(), system = base::Sys.info())
[10:21:19.329]                   }
[10:21:19.329]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.329]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.329]                     cond$call), session = sessionInformation(), 
[10:21:19.329]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.329]                   signalCondition(cond)
[10:21:19.329]                 }
[10:21:19.329]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.329]                 "immediateCondition"))) {
[10:21:19.329]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.329]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.329]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.329]                   if (TRUE && !signal) {
[10:21:19.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.329]                     {
[10:21:19.329]                       inherits <- base::inherits
[10:21:19.329]                       invokeRestart <- base::invokeRestart
[10:21:19.329]                       is.null <- base::is.null
[10:21:19.329]                       muffled <- FALSE
[10:21:19.329]                       if (inherits(cond, "message")) {
[10:21:19.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.329]                         if (muffled) 
[10:21:19.329]                           invokeRestart("muffleMessage")
[10:21:19.329]                       }
[10:21:19.329]                       else if (inherits(cond, "warning")) {
[10:21:19.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.329]                         if (muffled) 
[10:21:19.329]                           invokeRestart("muffleWarning")
[10:21:19.329]                       }
[10:21:19.329]                       else if (inherits(cond, "condition")) {
[10:21:19.329]                         if (!is.null(pattern)) {
[10:21:19.329]                           computeRestarts <- base::computeRestarts
[10:21:19.329]                           grepl <- base::grepl
[10:21:19.329]                           restarts <- computeRestarts(cond)
[10:21:19.329]                           for (restart in restarts) {
[10:21:19.329]                             name <- restart$name
[10:21:19.329]                             if (is.null(name)) 
[10:21:19.329]                               next
[10:21:19.329]                             if (!grepl(pattern, name)) 
[10:21:19.329]                               next
[10:21:19.329]                             invokeRestart(restart)
[10:21:19.329]                             muffled <- TRUE
[10:21:19.329]                             break
[10:21:19.329]                           }
[10:21:19.329]                         }
[10:21:19.329]                       }
[10:21:19.329]                       invisible(muffled)
[10:21:19.329]                     }
[10:21:19.329]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.329]                   }
[10:21:19.329]                 }
[10:21:19.329]                 else {
[10:21:19.329]                   if (TRUE) {
[10:21:19.329]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.329]                     {
[10:21:19.329]                       inherits <- base::inherits
[10:21:19.329]                       invokeRestart <- base::invokeRestart
[10:21:19.329]                       is.null <- base::is.null
[10:21:19.329]                       muffled <- FALSE
[10:21:19.329]                       if (inherits(cond, "message")) {
[10:21:19.329]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.329]                         if (muffled) 
[10:21:19.329]                           invokeRestart("muffleMessage")
[10:21:19.329]                       }
[10:21:19.329]                       else if (inherits(cond, "warning")) {
[10:21:19.329]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.329]                         if (muffled) 
[10:21:19.329]                           invokeRestart("muffleWarning")
[10:21:19.329]                       }
[10:21:19.329]                       else if (inherits(cond, "condition")) {
[10:21:19.329]                         if (!is.null(pattern)) {
[10:21:19.329]                           computeRestarts <- base::computeRestarts
[10:21:19.329]                           grepl <- base::grepl
[10:21:19.329]                           restarts <- computeRestarts(cond)
[10:21:19.329]                           for (restart in restarts) {
[10:21:19.329]                             name <- restart$name
[10:21:19.329]                             if (is.null(name)) 
[10:21:19.329]                               next
[10:21:19.329]                             if (!grepl(pattern, name)) 
[10:21:19.329]                               next
[10:21:19.329]                             invokeRestart(restart)
[10:21:19.329]                             muffled <- TRUE
[10:21:19.329]                             break
[10:21:19.329]                           }
[10:21:19.329]                         }
[10:21:19.329]                       }
[10:21:19.329]                       invisible(muffled)
[10:21:19.329]                     }
[10:21:19.329]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.329]                   }
[10:21:19.329]                 }
[10:21:19.329]             }
[10:21:19.329]         }))
[10:21:19.329]     }, error = function(ex) {
[10:21:19.329]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.329]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.329]                 ...future.rng), started = ...future.startTime, 
[10:21:19.329]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.329]             version = "1.8"), class = "FutureResult")
[10:21:19.329]     }, finally = {
[10:21:19.329]         if (!identical(...future.workdir, getwd())) 
[10:21:19.329]             setwd(...future.workdir)
[10:21:19.329]         {
[10:21:19.329]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.329]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.329]             }
[10:21:19.329]             base::options(...future.oldOptions)
[10:21:19.329]             if (.Platform$OS.type == "windows") {
[10:21:19.329]                 old_names <- names(...future.oldEnvVars)
[10:21:19.329]                 envs <- base::Sys.getenv()
[10:21:19.329]                 names <- names(envs)
[10:21:19.329]                 common <- intersect(names, old_names)
[10:21:19.329]                 added <- setdiff(names, old_names)
[10:21:19.329]                 removed <- setdiff(old_names, names)
[10:21:19.329]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.329]                   envs[common]]
[10:21:19.329]                 NAMES <- toupper(changed)
[10:21:19.329]                 args <- list()
[10:21:19.329]                 for (kk in seq_along(NAMES)) {
[10:21:19.329]                   name <- changed[[kk]]
[10:21:19.329]                   NAME <- NAMES[[kk]]
[10:21:19.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.329]                     next
[10:21:19.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.329]                 }
[10:21:19.329]                 NAMES <- toupper(added)
[10:21:19.329]                 for (kk in seq_along(NAMES)) {
[10:21:19.329]                   name <- added[[kk]]
[10:21:19.329]                   NAME <- NAMES[[kk]]
[10:21:19.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.329]                     next
[10:21:19.329]                   args[[name]] <- ""
[10:21:19.329]                 }
[10:21:19.329]                 NAMES <- toupper(removed)
[10:21:19.329]                 for (kk in seq_along(NAMES)) {
[10:21:19.329]                   name <- removed[[kk]]
[10:21:19.329]                   NAME <- NAMES[[kk]]
[10:21:19.329]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.329]                     next
[10:21:19.329]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.329]                 }
[10:21:19.329]                 if (length(args) > 0) 
[10:21:19.329]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.329]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.329]             }
[10:21:19.329]             else {
[10:21:19.329]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.329]             }
[10:21:19.329]             {
[10:21:19.329]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.329]                   0L) {
[10:21:19.329]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.329]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.329]                   base::options(opts)
[10:21:19.329]                 }
[10:21:19.329]                 {
[10:21:19.329]                   {
[10:21:19.329]                     NULL
[10:21:19.329]                     RNGkind("Mersenne-Twister")
[10:21:19.329]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.329]                       inherits = FALSE)
[10:21:19.329]                   }
[10:21:19.329]                   options(future.plan = NULL)
[10:21:19.329]                   if (is.na(NA_character_)) 
[10:21:19.329]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.329]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.329]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.329]                     .init = FALSE)
[10:21:19.329]                 }
[10:21:19.329]             }
[10:21:19.329]         }
[10:21:19.329]     })
[10:21:19.329]     if (TRUE) {
[10:21:19.329]         base::sink(type = "output", split = FALSE)
[10:21:19.329]         if (TRUE) {
[10:21:19.329]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.329]         }
[10:21:19.329]         else {
[10:21:19.329]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.329]         }
[10:21:19.329]         base::close(...future.stdout)
[10:21:19.329]         ...future.stdout <- NULL
[10:21:19.329]     }
[10:21:19.329]     ...future.result$conditions <- ...future.conditions
[10:21:19.329]     ...future.result$finished <- base::Sys.time()
[10:21:19.329]     ...future.result
[10:21:19.329] }
[10:21:19.331] plan(): Setting new future strategy stack:
[10:21:19.331] List of future strategies:
[10:21:19.331] 1. sequential:
[10:21:19.331]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.331]    - tweaked: FALSE
[10:21:19.331]    - call: NULL
[10:21:19.332] plan(): nbrOfWorkers() = 1
[10:21:19.332] plan(): Setting new future strategy stack:
[10:21:19.332] List of future strategies:
[10:21:19.332] 1. sequential:
[10:21:19.332]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.332]    - tweaked: FALSE
[10:21:19.332]    - call: plan(strategy)
[10:21:19.333] plan(): nbrOfWorkers() = 1
[10:21:19.333] SequentialFuture started (and completed)
[10:21:19.333] - Launch lazy future ... done
[10:21:19.333] run() for ‘SequentialFuture’ ... done
[10:21:19.334] getGlobalsAndPackages() ...
[10:21:19.335] Searching for globals...
[10:21:19.337] - globals found: [1] ‘{’
[10:21:19.337] Searching for globals ... DONE
[10:21:19.337] Resolving globals: FALSE
[10:21:19.337] 
[10:21:19.337] 
[10:21:19.337] getGlobalsAndPackages() ... DONE
[10:21:19.338] run() for ‘Future’ ...
[10:21:19.338] - state: ‘created’
[10:21:19.338] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.338] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.338] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.338]   - Field: ‘label’
[10:21:19.338]   - Field: ‘local’
[10:21:19.338]   - Field: ‘owner’
[10:21:19.338]   - Field: ‘envir’
[10:21:19.339]   - Field: ‘packages’
[10:21:19.339]   - Field: ‘gc’
[10:21:19.339]   - Field: ‘conditions’
[10:21:19.339]   - Field: ‘expr’
[10:21:19.339]   - Field: ‘uuid’
[10:21:19.339]   - Field: ‘seed’
[10:21:19.339]   - Field: ‘version’
[10:21:19.339]   - Field: ‘result’
[10:21:19.339]   - Field: ‘asynchronous’
[10:21:19.339]   - Field: ‘calls’
[10:21:19.339]   - Field: ‘globals’
[10:21:19.339]   - Field: ‘stdout’
[10:21:19.340]   - Field: ‘earlySignal’
[10:21:19.340]   - Field: ‘lazy’
[10:21:19.340]   - Field: ‘state’
[10:21:19.340] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.340] - Launch lazy future ...
[10:21:19.340] Packages needed by the future expression (n = 0): <none>
[10:21:19.340] Packages needed by future strategies (n = 0): <none>
[10:21:19.340] {
[10:21:19.340]     {
[10:21:19.340]         {
[10:21:19.340]             ...future.startTime <- base::Sys.time()
[10:21:19.340]             {
[10:21:19.340]                 {
[10:21:19.340]                   {
[10:21:19.340]                     base::local({
[10:21:19.340]                       has_future <- base::requireNamespace("future", 
[10:21:19.340]                         quietly = TRUE)
[10:21:19.340]                       if (has_future) {
[10:21:19.340]                         ns <- base::getNamespace("future")
[10:21:19.340]                         version <- ns[[".package"]][["version"]]
[10:21:19.340]                         if (is.null(version)) 
[10:21:19.340]                           version <- utils::packageVersion("future")
[10:21:19.340]                       }
[10:21:19.340]                       else {
[10:21:19.340]                         version <- NULL
[10:21:19.340]                       }
[10:21:19.340]                       if (!has_future || version < "1.8.0") {
[10:21:19.340]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.340]                           "", base::R.version$version.string), 
[10:21:19.340]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.340]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.340]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.340]                             "release", "version")], collapse = " "), 
[10:21:19.340]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.340]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.340]                           info)
[10:21:19.340]                         info <- base::paste(info, collapse = "; ")
[10:21:19.340]                         if (!has_future) {
[10:21:19.340]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.340]                             info)
[10:21:19.340]                         }
[10:21:19.340]                         else {
[10:21:19.340]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.340]                             info, version)
[10:21:19.340]                         }
[10:21:19.340]                         base::stop(msg)
[10:21:19.340]                       }
[10:21:19.340]                     })
[10:21:19.340]                   }
[10:21:19.340]                   ...future.strategy.old <- future::plan("list")
[10:21:19.340]                   options(future.plan = NULL)
[10:21:19.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.340]                 }
[10:21:19.340]                 ...future.workdir <- getwd()
[10:21:19.340]             }
[10:21:19.340]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.340]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.340]         }
[10:21:19.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.340]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.340]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.340]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.340]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.340]             base::names(...future.oldOptions))
[10:21:19.340]     }
[10:21:19.340]     if (FALSE) {
[10:21:19.340]     }
[10:21:19.340]     else {
[10:21:19.340]         if (TRUE) {
[10:21:19.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.340]                 open = "w")
[10:21:19.340]         }
[10:21:19.340]         else {
[10:21:19.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.340]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.340]         }
[10:21:19.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.340]             base::sink(type = "output", split = FALSE)
[10:21:19.340]             base::close(...future.stdout)
[10:21:19.340]         }, add = TRUE)
[10:21:19.340]     }
[10:21:19.340]     ...future.frame <- base::sys.nframe()
[10:21:19.340]     ...future.conditions <- base::list()
[10:21:19.340]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.340]     if (FALSE) {
[10:21:19.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.340]     }
[10:21:19.340]     ...future.result <- base::tryCatch({
[10:21:19.340]         base::withCallingHandlers({
[10:21:19.340]             ...future.value <- base::withVisible(base::local({
[10:21:19.340]                 4
[10:21:19.340]             }))
[10:21:19.340]             future::FutureResult(value = ...future.value$value, 
[10:21:19.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.340]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.340]                     ...future.globalenv.names))
[10:21:19.340]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.340]         }, condition = base::local({
[10:21:19.340]             c <- base::c
[10:21:19.340]             inherits <- base::inherits
[10:21:19.340]             invokeRestart <- base::invokeRestart
[10:21:19.340]             length <- base::length
[10:21:19.340]             list <- base::list
[10:21:19.340]             seq.int <- base::seq.int
[10:21:19.340]             signalCondition <- base::signalCondition
[10:21:19.340]             sys.calls <- base::sys.calls
[10:21:19.340]             `[[` <- base::`[[`
[10:21:19.340]             `+` <- base::`+`
[10:21:19.340]             `<<-` <- base::`<<-`
[10:21:19.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.340]                   3L)]
[10:21:19.340]             }
[10:21:19.340]             function(cond) {
[10:21:19.340]                 is_error <- inherits(cond, "error")
[10:21:19.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.340]                   NULL)
[10:21:19.340]                 if (is_error) {
[10:21:19.340]                   sessionInformation <- function() {
[10:21:19.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.340]                       search = base::search(), system = base::Sys.info())
[10:21:19.340]                   }
[10:21:19.340]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.340]                     cond$call), session = sessionInformation(), 
[10:21:19.340]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.340]                   signalCondition(cond)
[10:21:19.340]                 }
[10:21:19.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.340]                 "immediateCondition"))) {
[10:21:19.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.340]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.340]                   if (TRUE && !signal) {
[10:21:19.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.340]                     {
[10:21:19.340]                       inherits <- base::inherits
[10:21:19.340]                       invokeRestart <- base::invokeRestart
[10:21:19.340]                       is.null <- base::is.null
[10:21:19.340]                       muffled <- FALSE
[10:21:19.340]                       if (inherits(cond, "message")) {
[10:21:19.340]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.340]                         if (muffled) 
[10:21:19.340]                           invokeRestart("muffleMessage")
[10:21:19.340]                       }
[10:21:19.340]                       else if (inherits(cond, "warning")) {
[10:21:19.340]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.340]                         if (muffled) 
[10:21:19.340]                           invokeRestart("muffleWarning")
[10:21:19.340]                       }
[10:21:19.340]                       else if (inherits(cond, "condition")) {
[10:21:19.340]                         if (!is.null(pattern)) {
[10:21:19.340]                           computeRestarts <- base::computeRestarts
[10:21:19.340]                           grepl <- base::grepl
[10:21:19.340]                           restarts <- computeRestarts(cond)
[10:21:19.340]                           for (restart in restarts) {
[10:21:19.340]                             name <- restart$name
[10:21:19.340]                             if (is.null(name)) 
[10:21:19.340]                               next
[10:21:19.340]                             if (!grepl(pattern, name)) 
[10:21:19.340]                               next
[10:21:19.340]                             invokeRestart(restart)
[10:21:19.340]                             muffled <- TRUE
[10:21:19.340]                             break
[10:21:19.340]                           }
[10:21:19.340]                         }
[10:21:19.340]                       }
[10:21:19.340]                       invisible(muffled)
[10:21:19.340]                     }
[10:21:19.340]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.340]                   }
[10:21:19.340]                 }
[10:21:19.340]                 else {
[10:21:19.340]                   if (TRUE) {
[10:21:19.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.340]                     {
[10:21:19.340]                       inherits <- base::inherits
[10:21:19.340]                       invokeRestart <- base::invokeRestart
[10:21:19.340]                       is.null <- base::is.null
[10:21:19.340]                       muffled <- FALSE
[10:21:19.340]                       if (inherits(cond, "message")) {
[10:21:19.340]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.340]                         if (muffled) 
[10:21:19.340]                           invokeRestart("muffleMessage")
[10:21:19.340]                       }
[10:21:19.340]                       else if (inherits(cond, "warning")) {
[10:21:19.340]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.340]                         if (muffled) 
[10:21:19.340]                           invokeRestart("muffleWarning")
[10:21:19.340]                       }
[10:21:19.340]                       else if (inherits(cond, "condition")) {
[10:21:19.340]                         if (!is.null(pattern)) {
[10:21:19.340]                           computeRestarts <- base::computeRestarts
[10:21:19.340]                           grepl <- base::grepl
[10:21:19.340]                           restarts <- computeRestarts(cond)
[10:21:19.340]                           for (restart in restarts) {
[10:21:19.340]                             name <- restart$name
[10:21:19.340]                             if (is.null(name)) 
[10:21:19.340]                               next
[10:21:19.340]                             if (!grepl(pattern, name)) 
[10:21:19.340]                               next
[10:21:19.340]                             invokeRestart(restart)
[10:21:19.340]                             muffled <- TRUE
[10:21:19.340]                             break
[10:21:19.340]                           }
[10:21:19.340]                         }
[10:21:19.340]                       }
[10:21:19.340]                       invisible(muffled)
[10:21:19.340]                     }
[10:21:19.340]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.340]                   }
[10:21:19.340]                 }
[10:21:19.340]             }
[10:21:19.340]         }))
[10:21:19.340]     }, error = function(ex) {
[10:21:19.340]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.340]                 ...future.rng), started = ...future.startTime, 
[10:21:19.340]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.340]             version = "1.8"), class = "FutureResult")
[10:21:19.340]     }, finally = {
[10:21:19.340]         if (!identical(...future.workdir, getwd())) 
[10:21:19.340]             setwd(...future.workdir)
[10:21:19.340]         {
[10:21:19.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.340]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.340]             }
[10:21:19.340]             base::options(...future.oldOptions)
[10:21:19.340]             if (.Platform$OS.type == "windows") {
[10:21:19.340]                 old_names <- names(...future.oldEnvVars)
[10:21:19.340]                 envs <- base::Sys.getenv()
[10:21:19.340]                 names <- names(envs)
[10:21:19.340]                 common <- intersect(names, old_names)
[10:21:19.340]                 added <- setdiff(names, old_names)
[10:21:19.340]                 removed <- setdiff(old_names, names)
[10:21:19.340]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.340]                   envs[common]]
[10:21:19.340]                 NAMES <- toupper(changed)
[10:21:19.340]                 args <- list()
[10:21:19.340]                 for (kk in seq_along(NAMES)) {
[10:21:19.340]                   name <- changed[[kk]]
[10:21:19.340]                   NAME <- NAMES[[kk]]
[10:21:19.340]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.340]                     next
[10:21:19.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.340]                 }
[10:21:19.340]                 NAMES <- toupper(added)
[10:21:19.340]                 for (kk in seq_along(NAMES)) {
[10:21:19.340]                   name <- added[[kk]]
[10:21:19.340]                   NAME <- NAMES[[kk]]
[10:21:19.340]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.340]                     next
[10:21:19.340]                   args[[name]] <- ""
[10:21:19.340]                 }
[10:21:19.340]                 NAMES <- toupper(removed)
[10:21:19.340]                 for (kk in seq_along(NAMES)) {
[10:21:19.340]                   name <- removed[[kk]]
[10:21:19.340]                   NAME <- NAMES[[kk]]
[10:21:19.340]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.340]                     next
[10:21:19.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.340]                 }
[10:21:19.340]                 if (length(args) > 0) 
[10:21:19.340]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.340]             }
[10:21:19.340]             else {
[10:21:19.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.340]             }
[10:21:19.340]             {
[10:21:19.340]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.340]                   0L) {
[10:21:19.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.340]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.340]                   base::options(opts)
[10:21:19.340]                 }
[10:21:19.340]                 {
[10:21:19.340]                   {
[10:21:19.340]                     NULL
[10:21:19.340]                     RNGkind("Mersenne-Twister")
[10:21:19.340]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.340]                       inherits = FALSE)
[10:21:19.340]                   }
[10:21:19.340]                   options(future.plan = NULL)
[10:21:19.340]                   if (is.na(NA_character_)) 
[10:21:19.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.340]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.340]                     .init = FALSE)
[10:21:19.340]                 }
[10:21:19.340]             }
[10:21:19.340]         }
[10:21:19.340]     })
[10:21:19.340]     if (TRUE) {
[10:21:19.340]         base::sink(type = "output", split = FALSE)
[10:21:19.340]         if (TRUE) {
[10:21:19.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.340]         }
[10:21:19.340]         else {
[10:21:19.340]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.340]         }
[10:21:19.340]         base::close(...future.stdout)
[10:21:19.340]         ...future.stdout <- NULL
[10:21:19.340]     }
[10:21:19.340]     ...future.result$conditions <- ...future.conditions
[10:21:19.340]     ...future.result$finished <- base::Sys.time()
[10:21:19.340]     ...future.result
[10:21:19.340] }
[10:21:19.342] plan(): Setting new future strategy stack:
[10:21:19.342] List of future strategies:
[10:21:19.342] 1. sequential:
[10:21:19.342]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.342]    - tweaked: FALSE
[10:21:19.342]    - call: NULL
[10:21:19.343] plan(): nbrOfWorkers() = 1
[10:21:19.345] plan(): Setting new future strategy stack:
[10:21:19.345] List of future strategies:
[10:21:19.345] 1. sequential:
[10:21:19.345]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.345]    - tweaked: FALSE
[10:21:19.345]    - call: plan(strategy)
[10:21:19.345] plan(): nbrOfWorkers() = 1
[10:21:19.345] SequentialFuture started (and completed)
[10:21:19.346] - Launch lazy future ... done
[10:21:19.346] run() for ‘SequentialFuture’ ... done
<environment: 0x55e8e2f2bf98> 
<environment: 0x55e8e3800de0> 
[10:21:19.347] resolved() for ‘SequentialFuture’ ...
[10:21:19.347] - state: ‘finished’
[10:21:19.347] - run: TRUE
[10:21:19.347] - result: ‘FutureResult’
[10:21:19.347] resolved() for ‘SequentialFuture’ ... done
[10:21:19.347] resolved() for ‘SequentialFuture’ ...
[10:21:19.348] - state: ‘finished’
[10:21:19.348] - run: TRUE
[10:21:19.348] - result: ‘FutureResult’
[10:21:19.348] resolved() for ‘SequentialFuture’ ... done
[10:21:19.348] resolved() for ‘SequentialFuture’ ...
[10:21:19.348] - state: ‘finished’
[10:21:19.348] - run: TRUE
[10:21:19.348] - result: ‘FutureResult’
[10:21:19.348] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:19.349] resolve() on environment ...
[10:21:19.349]  recursive: 0
[10:21:19.350]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:19.350] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.350] - nx: 4
[10:21:19.350] - relay: TRUE
[10:21:19.350] - stdout: TRUE
[10:21:19.350] - signal: TRUE
[10:21:19.350] - resignal: FALSE
[10:21:19.350] - force: TRUE
[10:21:19.351] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.351] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.351]  - until=2
[10:21:19.351]  - relaying element #2
[10:21:19.351] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.351] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.351] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.351]  length: 3 (resolved future 1)
[10:21:19.351] resolved() for ‘SequentialFuture’ ...
[10:21:19.351] - state: ‘finished’
[10:21:19.351] - run: TRUE
[10:21:19.351] - result: ‘FutureResult’
[10:21:19.352] resolved() for ‘SequentialFuture’ ... done
[10:21:19.352] Future #2
[10:21:19.352] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.352] - nx: 4
[10:21:19.352] - relay: TRUE
[10:21:19.352] - stdout: TRUE
[10:21:19.352] - signal: TRUE
[10:21:19.352] - resignal: FALSE
[10:21:19.352] - force: TRUE
[10:21:19.352] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.352] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.352]  - until=2
[10:21:19.353]  - relaying element #2
[10:21:19.353] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.353] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.353] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.353]  length: 2 (resolved future 2)
[10:21:19.353] resolved() for ‘SequentialFuture’ ...
[10:21:19.353] - state: ‘finished’
[10:21:19.353] - run: TRUE
[10:21:19.353] - result: ‘FutureResult’
[10:21:19.353] resolved() for ‘SequentialFuture’ ... done
[10:21:19.353] Future #3
[10:21:19.354] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.354] - nx: 4
[10:21:19.354] - relay: TRUE
[10:21:19.354] - stdout: TRUE
[10:21:19.354] - signal: TRUE
[10:21:19.354] - resignal: FALSE
[10:21:19.354] - force: TRUE
[10:21:19.354] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.354] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.354]  - until=3
[10:21:19.354]  - relaying element #3
[10:21:19.354] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.355] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.355] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.355]  length: 1 (resolved future 3)
[10:21:19.355] resolved() for ‘SequentialFuture’ ...
[10:21:19.355] - state: ‘finished’
[10:21:19.355] - run: TRUE
[10:21:19.355] - result: ‘FutureResult’
[10:21:19.355] resolved() for ‘SequentialFuture’ ... done
[10:21:19.355] Future #4
[10:21:19.355] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.355] - nx: 4
[10:21:19.355] - relay: TRUE
[10:21:19.356] - stdout: TRUE
[10:21:19.356] - signal: TRUE
[10:21:19.356] - resignal: FALSE
[10:21:19.356] - force: TRUE
[10:21:19.356] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.356] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.356]  - until=4
[10:21:19.356]  - relaying element #4
[10:21:19.356] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.356] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.356] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.356]  length: 0 (resolved future 4)
[10:21:19.357] Relaying remaining futures
[10:21:19.357] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.357] - nx: 4
[10:21:19.357] - relay: TRUE
[10:21:19.357] - stdout: TRUE
[10:21:19.357] - signal: TRUE
[10:21:19.357] - resignal: FALSE
[10:21:19.357] - force: TRUE
[10:21:19.357] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.357] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:19.357] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.357] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.357] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.358] resolve() on environment ... DONE
<environment: 0x55e8e2c2dbe8> 
Dimensions: c(1, 6)
[10:21:19.358] getGlobalsAndPackages() ...
[10:21:19.358] Searching for globals...
[10:21:19.358] 
[10:21:19.358] Searching for globals ... DONE
[10:21:19.359] - globals: [0] <none>
[10:21:19.359] getGlobalsAndPackages() ... DONE
[10:21:19.359] run() for ‘Future’ ...
[10:21:19.359] - state: ‘created’
[10:21:19.359] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.359] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.359]   - Field: ‘label’
[10:21:19.359]   - Field: ‘local’
[10:21:19.360]   - Field: ‘owner’
[10:21:19.360]   - Field: ‘envir’
[10:21:19.360]   - Field: ‘packages’
[10:21:19.360]   - Field: ‘gc’
[10:21:19.360]   - Field: ‘conditions’
[10:21:19.360]   - Field: ‘expr’
[10:21:19.360]   - Field: ‘uuid’
[10:21:19.360]   - Field: ‘seed’
[10:21:19.360]   - Field: ‘version’
[10:21:19.360]   - Field: ‘result’
[10:21:19.360]   - Field: ‘asynchronous’
[10:21:19.360]   - Field: ‘calls’
[10:21:19.361]   - Field: ‘globals’
[10:21:19.361]   - Field: ‘stdout’
[10:21:19.361]   - Field: ‘earlySignal’
[10:21:19.361]   - Field: ‘lazy’
[10:21:19.361]   - Field: ‘state’
[10:21:19.361] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.361] - Launch lazy future ...
[10:21:19.361] Packages needed by the future expression (n = 0): <none>
[10:21:19.361] Packages needed by future strategies (n = 0): <none>
[10:21:19.362] {
[10:21:19.362]     {
[10:21:19.362]         {
[10:21:19.362]             ...future.startTime <- base::Sys.time()
[10:21:19.362]             {
[10:21:19.362]                 {
[10:21:19.362]                   {
[10:21:19.362]                     base::local({
[10:21:19.362]                       has_future <- base::requireNamespace("future", 
[10:21:19.362]                         quietly = TRUE)
[10:21:19.362]                       if (has_future) {
[10:21:19.362]                         ns <- base::getNamespace("future")
[10:21:19.362]                         version <- ns[[".package"]][["version"]]
[10:21:19.362]                         if (is.null(version)) 
[10:21:19.362]                           version <- utils::packageVersion("future")
[10:21:19.362]                       }
[10:21:19.362]                       else {
[10:21:19.362]                         version <- NULL
[10:21:19.362]                       }
[10:21:19.362]                       if (!has_future || version < "1.8.0") {
[10:21:19.362]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.362]                           "", base::R.version$version.string), 
[10:21:19.362]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.362]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.362]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.362]                             "release", "version")], collapse = " "), 
[10:21:19.362]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.362]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.362]                           info)
[10:21:19.362]                         info <- base::paste(info, collapse = "; ")
[10:21:19.362]                         if (!has_future) {
[10:21:19.362]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.362]                             info)
[10:21:19.362]                         }
[10:21:19.362]                         else {
[10:21:19.362]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.362]                             info, version)
[10:21:19.362]                         }
[10:21:19.362]                         base::stop(msg)
[10:21:19.362]                       }
[10:21:19.362]                     })
[10:21:19.362]                   }
[10:21:19.362]                   ...future.strategy.old <- future::plan("list")
[10:21:19.362]                   options(future.plan = NULL)
[10:21:19.362]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.362]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.362]                 }
[10:21:19.362]                 ...future.workdir <- getwd()
[10:21:19.362]             }
[10:21:19.362]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.362]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.362]         }
[10:21:19.362]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.362]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.362]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.362]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.362]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.362]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.362]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.362]             base::names(...future.oldOptions))
[10:21:19.362]     }
[10:21:19.362]     if (FALSE) {
[10:21:19.362]     }
[10:21:19.362]     else {
[10:21:19.362]         if (TRUE) {
[10:21:19.362]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.362]                 open = "w")
[10:21:19.362]         }
[10:21:19.362]         else {
[10:21:19.362]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.362]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.362]         }
[10:21:19.362]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.362]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.362]             base::sink(type = "output", split = FALSE)
[10:21:19.362]             base::close(...future.stdout)
[10:21:19.362]         }, add = TRUE)
[10:21:19.362]     }
[10:21:19.362]     ...future.frame <- base::sys.nframe()
[10:21:19.362]     ...future.conditions <- base::list()
[10:21:19.362]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.362]     if (FALSE) {
[10:21:19.362]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.362]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.362]     }
[10:21:19.362]     ...future.result <- base::tryCatch({
[10:21:19.362]         base::withCallingHandlers({
[10:21:19.362]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.362]             future::FutureResult(value = ...future.value$value, 
[10:21:19.362]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.362]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.362]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.362]                     ...future.globalenv.names))
[10:21:19.362]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.362]         }, condition = base::local({
[10:21:19.362]             c <- base::c
[10:21:19.362]             inherits <- base::inherits
[10:21:19.362]             invokeRestart <- base::invokeRestart
[10:21:19.362]             length <- base::length
[10:21:19.362]             list <- base::list
[10:21:19.362]             seq.int <- base::seq.int
[10:21:19.362]             signalCondition <- base::signalCondition
[10:21:19.362]             sys.calls <- base::sys.calls
[10:21:19.362]             `[[` <- base::`[[`
[10:21:19.362]             `+` <- base::`+`
[10:21:19.362]             `<<-` <- base::`<<-`
[10:21:19.362]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.362]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.362]                   3L)]
[10:21:19.362]             }
[10:21:19.362]             function(cond) {
[10:21:19.362]                 is_error <- inherits(cond, "error")
[10:21:19.362]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.362]                   NULL)
[10:21:19.362]                 if (is_error) {
[10:21:19.362]                   sessionInformation <- function() {
[10:21:19.362]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.362]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.362]                       search = base::search(), system = base::Sys.info())
[10:21:19.362]                   }
[10:21:19.362]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.362]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.362]                     cond$call), session = sessionInformation(), 
[10:21:19.362]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.362]                   signalCondition(cond)
[10:21:19.362]                 }
[10:21:19.362]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.362]                 "immediateCondition"))) {
[10:21:19.362]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.362]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.362]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.362]                   if (TRUE && !signal) {
[10:21:19.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.362]                     {
[10:21:19.362]                       inherits <- base::inherits
[10:21:19.362]                       invokeRestart <- base::invokeRestart
[10:21:19.362]                       is.null <- base::is.null
[10:21:19.362]                       muffled <- FALSE
[10:21:19.362]                       if (inherits(cond, "message")) {
[10:21:19.362]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.362]                         if (muffled) 
[10:21:19.362]                           invokeRestart("muffleMessage")
[10:21:19.362]                       }
[10:21:19.362]                       else if (inherits(cond, "warning")) {
[10:21:19.362]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.362]                         if (muffled) 
[10:21:19.362]                           invokeRestart("muffleWarning")
[10:21:19.362]                       }
[10:21:19.362]                       else if (inherits(cond, "condition")) {
[10:21:19.362]                         if (!is.null(pattern)) {
[10:21:19.362]                           computeRestarts <- base::computeRestarts
[10:21:19.362]                           grepl <- base::grepl
[10:21:19.362]                           restarts <- computeRestarts(cond)
[10:21:19.362]                           for (restart in restarts) {
[10:21:19.362]                             name <- restart$name
[10:21:19.362]                             if (is.null(name)) 
[10:21:19.362]                               next
[10:21:19.362]                             if (!grepl(pattern, name)) 
[10:21:19.362]                               next
[10:21:19.362]                             invokeRestart(restart)
[10:21:19.362]                             muffled <- TRUE
[10:21:19.362]                             break
[10:21:19.362]                           }
[10:21:19.362]                         }
[10:21:19.362]                       }
[10:21:19.362]                       invisible(muffled)
[10:21:19.362]                     }
[10:21:19.362]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.362]                   }
[10:21:19.362]                 }
[10:21:19.362]                 else {
[10:21:19.362]                   if (TRUE) {
[10:21:19.362]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.362]                     {
[10:21:19.362]                       inherits <- base::inherits
[10:21:19.362]                       invokeRestart <- base::invokeRestart
[10:21:19.362]                       is.null <- base::is.null
[10:21:19.362]                       muffled <- FALSE
[10:21:19.362]                       if (inherits(cond, "message")) {
[10:21:19.362]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.362]                         if (muffled) 
[10:21:19.362]                           invokeRestart("muffleMessage")
[10:21:19.362]                       }
[10:21:19.362]                       else if (inherits(cond, "warning")) {
[10:21:19.362]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.362]                         if (muffled) 
[10:21:19.362]                           invokeRestart("muffleWarning")
[10:21:19.362]                       }
[10:21:19.362]                       else if (inherits(cond, "condition")) {
[10:21:19.362]                         if (!is.null(pattern)) {
[10:21:19.362]                           computeRestarts <- base::computeRestarts
[10:21:19.362]                           grepl <- base::grepl
[10:21:19.362]                           restarts <- computeRestarts(cond)
[10:21:19.362]                           for (restart in restarts) {
[10:21:19.362]                             name <- restart$name
[10:21:19.362]                             if (is.null(name)) 
[10:21:19.362]                               next
[10:21:19.362]                             if (!grepl(pattern, name)) 
[10:21:19.362]                               next
[10:21:19.362]                             invokeRestart(restart)
[10:21:19.362]                             muffled <- TRUE
[10:21:19.362]                             break
[10:21:19.362]                           }
[10:21:19.362]                         }
[10:21:19.362]                       }
[10:21:19.362]                       invisible(muffled)
[10:21:19.362]                     }
[10:21:19.362]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.362]                   }
[10:21:19.362]                 }
[10:21:19.362]             }
[10:21:19.362]         }))
[10:21:19.362]     }, error = function(ex) {
[10:21:19.362]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.362]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.362]                 ...future.rng), started = ...future.startTime, 
[10:21:19.362]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.362]             version = "1.8"), class = "FutureResult")
[10:21:19.362]     }, finally = {
[10:21:19.362]         if (!identical(...future.workdir, getwd())) 
[10:21:19.362]             setwd(...future.workdir)
[10:21:19.362]         {
[10:21:19.362]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.362]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.362]             }
[10:21:19.362]             base::options(...future.oldOptions)
[10:21:19.362]             if (.Platform$OS.type == "windows") {
[10:21:19.362]                 old_names <- names(...future.oldEnvVars)
[10:21:19.362]                 envs <- base::Sys.getenv()
[10:21:19.362]                 names <- names(envs)
[10:21:19.362]                 common <- intersect(names, old_names)
[10:21:19.362]                 added <- setdiff(names, old_names)
[10:21:19.362]                 removed <- setdiff(old_names, names)
[10:21:19.362]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.362]                   envs[common]]
[10:21:19.362]                 NAMES <- toupper(changed)
[10:21:19.362]                 args <- list()
[10:21:19.362]                 for (kk in seq_along(NAMES)) {
[10:21:19.362]                   name <- changed[[kk]]
[10:21:19.362]                   NAME <- NAMES[[kk]]
[10:21:19.362]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.362]                     next
[10:21:19.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.362]                 }
[10:21:19.362]                 NAMES <- toupper(added)
[10:21:19.362]                 for (kk in seq_along(NAMES)) {
[10:21:19.362]                   name <- added[[kk]]
[10:21:19.362]                   NAME <- NAMES[[kk]]
[10:21:19.362]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.362]                     next
[10:21:19.362]                   args[[name]] <- ""
[10:21:19.362]                 }
[10:21:19.362]                 NAMES <- toupper(removed)
[10:21:19.362]                 for (kk in seq_along(NAMES)) {
[10:21:19.362]                   name <- removed[[kk]]
[10:21:19.362]                   NAME <- NAMES[[kk]]
[10:21:19.362]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.362]                     next
[10:21:19.362]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.362]                 }
[10:21:19.362]                 if (length(args) > 0) 
[10:21:19.362]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.362]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.362]             }
[10:21:19.362]             else {
[10:21:19.362]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.362]             }
[10:21:19.362]             {
[10:21:19.362]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.362]                   0L) {
[10:21:19.362]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.362]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.362]                   base::options(opts)
[10:21:19.362]                 }
[10:21:19.362]                 {
[10:21:19.362]                   {
[10:21:19.362]                     NULL
[10:21:19.362]                     RNGkind("Mersenne-Twister")
[10:21:19.362]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.362]                       inherits = FALSE)
[10:21:19.362]                   }
[10:21:19.362]                   options(future.plan = NULL)
[10:21:19.362]                   if (is.na(NA_character_)) 
[10:21:19.362]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.362]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.362]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.362]                     .init = FALSE)
[10:21:19.362]                 }
[10:21:19.362]             }
[10:21:19.362]         }
[10:21:19.362]     })
[10:21:19.362]     if (TRUE) {
[10:21:19.362]         base::sink(type = "output", split = FALSE)
[10:21:19.362]         if (TRUE) {
[10:21:19.362]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.362]         }
[10:21:19.362]         else {
[10:21:19.362]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.362]         }
[10:21:19.362]         base::close(...future.stdout)
[10:21:19.362]         ...future.stdout <- NULL
[10:21:19.362]     }
[10:21:19.362]     ...future.result$conditions <- ...future.conditions
[10:21:19.362]     ...future.result$finished <- base::Sys.time()
[10:21:19.362]     ...future.result
[10:21:19.362] }
[10:21:19.363] plan(): Setting new future strategy stack:
[10:21:19.363] List of future strategies:
[10:21:19.363] 1. sequential:
[10:21:19.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.363]    - tweaked: FALSE
[10:21:19.363]    - call: NULL
[10:21:19.364] plan(): nbrOfWorkers() = 1
[10:21:19.365] plan(): Setting new future strategy stack:
[10:21:19.365] List of future strategies:
[10:21:19.365] 1. sequential:
[10:21:19.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.365]    - tweaked: FALSE
[10:21:19.365]    - call: plan(strategy)
[10:21:19.365] plan(): nbrOfWorkers() = 1
[10:21:19.365] SequentialFuture started (and completed)
[10:21:19.365] - Launch lazy future ... done
[10:21:19.365] run() for ‘SequentialFuture’ ... done
[10:21:19.366] getGlobalsAndPackages() ...
[10:21:19.366] Searching for globals...
[10:21:19.366] 
[10:21:19.366] Searching for globals ... DONE
[10:21:19.366] - globals: [0] <none>
[10:21:19.366] getGlobalsAndPackages() ... DONE
[10:21:19.366] run() for ‘Future’ ...
[10:21:19.366] - state: ‘created’
[10:21:19.367] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.367] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.367] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.367]   - Field: ‘label’
[10:21:19.367]   - Field: ‘local’
[10:21:19.367]   - Field: ‘owner’
[10:21:19.367]   - Field: ‘envir’
[10:21:19.367]   - Field: ‘packages’
[10:21:19.367]   - Field: ‘gc’
[10:21:19.368]   - Field: ‘conditions’
[10:21:19.369]   - Field: ‘expr’
[10:21:19.369]   - Field: ‘uuid’
[10:21:19.369]   - Field: ‘seed’
[10:21:19.369]   - Field: ‘version’
[10:21:19.369]   - Field: ‘result’
[10:21:19.369]   - Field: ‘asynchronous’
[10:21:19.369]   - Field: ‘calls’
[10:21:19.369]   - Field: ‘globals’
[10:21:19.369]   - Field: ‘stdout’
[10:21:19.369]   - Field: ‘earlySignal’
[10:21:19.370]   - Field: ‘lazy’
[10:21:19.370]   - Field: ‘state’
[10:21:19.370] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.370] - Launch lazy future ...
[10:21:19.370] Packages needed by the future expression (n = 0): <none>
[10:21:19.370] Packages needed by future strategies (n = 0): <none>
[10:21:19.370] {
[10:21:19.370]     {
[10:21:19.370]         {
[10:21:19.370]             ...future.startTime <- base::Sys.time()
[10:21:19.370]             {
[10:21:19.370]                 {
[10:21:19.370]                   {
[10:21:19.370]                     base::local({
[10:21:19.370]                       has_future <- base::requireNamespace("future", 
[10:21:19.370]                         quietly = TRUE)
[10:21:19.370]                       if (has_future) {
[10:21:19.370]                         ns <- base::getNamespace("future")
[10:21:19.370]                         version <- ns[[".package"]][["version"]]
[10:21:19.370]                         if (is.null(version)) 
[10:21:19.370]                           version <- utils::packageVersion("future")
[10:21:19.370]                       }
[10:21:19.370]                       else {
[10:21:19.370]                         version <- NULL
[10:21:19.370]                       }
[10:21:19.370]                       if (!has_future || version < "1.8.0") {
[10:21:19.370]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.370]                           "", base::R.version$version.string), 
[10:21:19.370]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.370]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.370]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.370]                             "release", "version")], collapse = " "), 
[10:21:19.370]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.370]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.370]                           info)
[10:21:19.370]                         info <- base::paste(info, collapse = "; ")
[10:21:19.370]                         if (!has_future) {
[10:21:19.370]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.370]                             info)
[10:21:19.370]                         }
[10:21:19.370]                         else {
[10:21:19.370]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.370]                             info, version)
[10:21:19.370]                         }
[10:21:19.370]                         base::stop(msg)
[10:21:19.370]                       }
[10:21:19.370]                     })
[10:21:19.370]                   }
[10:21:19.370]                   ...future.strategy.old <- future::plan("list")
[10:21:19.370]                   options(future.plan = NULL)
[10:21:19.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.370]                 }
[10:21:19.370]                 ...future.workdir <- getwd()
[10:21:19.370]             }
[10:21:19.370]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.370]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.370]         }
[10:21:19.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.370]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.370]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.370]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.370]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.370]             base::names(...future.oldOptions))
[10:21:19.370]     }
[10:21:19.370]     if (FALSE) {
[10:21:19.370]     }
[10:21:19.370]     else {
[10:21:19.370]         if (TRUE) {
[10:21:19.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.370]                 open = "w")
[10:21:19.370]         }
[10:21:19.370]         else {
[10:21:19.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.370]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.370]         }
[10:21:19.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.370]             base::sink(type = "output", split = FALSE)
[10:21:19.370]             base::close(...future.stdout)
[10:21:19.370]         }, add = TRUE)
[10:21:19.370]     }
[10:21:19.370]     ...future.frame <- base::sys.nframe()
[10:21:19.370]     ...future.conditions <- base::list()
[10:21:19.370]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.370]     if (FALSE) {
[10:21:19.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.370]     }
[10:21:19.370]     ...future.result <- base::tryCatch({
[10:21:19.370]         base::withCallingHandlers({
[10:21:19.370]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.370]             future::FutureResult(value = ...future.value$value, 
[10:21:19.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.370]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.370]                     ...future.globalenv.names))
[10:21:19.370]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.370]         }, condition = base::local({
[10:21:19.370]             c <- base::c
[10:21:19.370]             inherits <- base::inherits
[10:21:19.370]             invokeRestart <- base::invokeRestart
[10:21:19.370]             length <- base::length
[10:21:19.370]             list <- base::list
[10:21:19.370]             seq.int <- base::seq.int
[10:21:19.370]             signalCondition <- base::signalCondition
[10:21:19.370]             sys.calls <- base::sys.calls
[10:21:19.370]             `[[` <- base::`[[`
[10:21:19.370]             `+` <- base::`+`
[10:21:19.370]             `<<-` <- base::`<<-`
[10:21:19.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.370]                   3L)]
[10:21:19.370]             }
[10:21:19.370]             function(cond) {
[10:21:19.370]                 is_error <- inherits(cond, "error")
[10:21:19.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.370]                   NULL)
[10:21:19.370]                 if (is_error) {
[10:21:19.370]                   sessionInformation <- function() {
[10:21:19.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.370]                       search = base::search(), system = base::Sys.info())
[10:21:19.370]                   }
[10:21:19.370]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.370]                     cond$call), session = sessionInformation(), 
[10:21:19.370]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.370]                   signalCondition(cond)
[10:21:19.370]                 }
[10:21:19.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.370]                 "immediateCondition"))) {
[10:21:19.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.370]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.370]                   if (TRUE && !signal) {
[10:21:19.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.370]                     {
[10:21:19.370]                       inherits <- base::inherits
[10:21:19.370]                       invokeRestart <- base::invokeRestart
[10:21:19.370]                       is.null <- base::is.null
[10:21:19.370]                       muffled <- FALSE
[10:21:19.370]                       if (inherits(cond, "message")) {
[10:21:19.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.370]                         if (muffled) 
[10:21:19.370]                           invokeRestart("muffleMessage")
[10:21:19.370]                       }
[10:21:19.370]                       else if (inherits(cond, "warning")) {
[10:21:19.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.370]                         if (muffled) 
[10:21:19.370]                           invokeRestart("muffleWarning")
[10:21:19.370]                       }
[10:21:19.370]                       else if (inherits(cond, "condition")) {
[10:21:19.370]                         if (!is.null(pattern)) {
[10:21:19.370]                           computeRestarts <- base::computeRestarts
[10:21:19.370]                           grepl <- base::grepl
[10:21:19.370]                           restarts <- computeRestarts(cond)
[10:21:19.370]                           for (restart in restarts) {
[10:21:19.370]                             name <- restart$name
[10:21:19.370]                             if (is.null(name)) 
[10:21:19.370]                               next
[10:21:19.370]                             if (!grepl(pattern, name)) 
[10:21:19.370]                               next
[10:21:19.370]                             invokeRestart(restart)
[10:21:19.370]                             muffled <- TRUE
[10:21:19.370]                             break
[10:21:19.370]                           }
[10:21:19.370]                         }
[10:21:19.370]                       }
[10:21:19.370]                       invisible(muffled)
[10:21:19.370]                     }
[10:21:19.370]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.370]                   }
[10:21:19.370]                 }
[10:21:19.370]                 else {
[10:21:19.370]                   if (TRUE) {
[10:21:19.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.370]                     {
[10:21:19.370]                       inherits <- base::inherits
[10:21:19.370]                       invokeRestart <- base::invokeRestart
[10:21:19.370]                       is.null <- base::is.null
[10:21:19.370]                       muffled <- FALSE
[10:21:19.370]                       if (inherits(cond, "message")) {
[10:21:19.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.370]                         if (muffled) 
[10:21:19.370]                           invokeRestart("muffleMessage")
[10:21:19.370]                       }
[10:21:19.370]                       else if (inherits(cond, "warning")) {
[10:21:19.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.370]                         if (muffled) 
[10:21:19.370]                           invokeRestart("muffleWarning")
[10:21:19.370]                       }
[10:21:19.370]                       else if (inherits(cond, "condition")) {
[10:21:19.370]                         if (!is.null(pattern)) {
[10:21:19.370]                           computeRestarts <- base::computeRestarts
[10:21:19.370]                           grepl <- base::grepl
[10:21:19.370]                           restarts <- computeRestarts(cond)
[10:21:19.370]                           for (restart in restarts) {
[10:21:19.370]                             name <- restart$name
[10:21:19.370]                             if (is.null(name)) 
[10:21:19.370]                               next
[10:21:19.370]                             if (!grepl(pattern, name)) 
[10:21:19.370]                               next
[10:21:19.370]                             invokeRestart(restart)
[10:21:19.370]                             muffled <- TRUE
[10:21:19.370]                             break
[10:21:19.370]                           }
[10:21:19.370]                         }
[10:21:19.370]                       }
[10:21:19.370]                       invisible(muffled)
[10:21:19.370]                     }
[10:21:19.370]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.370]                   }
[10:21:19.370]                 }
[10:21:19.370]             }
[10:21:19.370]         }))
[10:21:19.370]     }, error = function(ex) {
[10:21:19.370]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.370]                 ...future.rng), started = ...future.startTime, 
[10:21:19.370]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.370]             version = "1.8"), class = "FutureResult")
[10:21:19.370]     }, finally = {
[10:21:19.370]         if (!identical(...future.workdir, getwd())) 
[10:21:19.370]             setwd(...future.workdir)
[10:21:19.370]         {
[10:21:19.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.370]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.370]             }
[10:21:19.370]             base::options(...future.oldOptions)
[10:21:19.370]             if (.Platform$OS.type == "windows") {
[10:21:19.370]                 old_names <- names(...future.oldEnvVars)
[10:21:19.370]                 envs <- base::Sys.getenv()
[10:21:19.370]                 names <- names(envs)
[10:21:19.370]                 common <- intersect(names, old_names)
[10:21:19.370]                 added <- setdiff(names, old_names)
[10:21:19.370]                 removed <- setdiff(old_names, names)
[10:21:19.370]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.370]                   envs[common]]
[10:21:19.370]                 NAMES <- toupper(changed)
[10:21:19.370]                 args <- list()
[10:21:19.370]                 for (kk in seq_along(NAMES)) {
[10:21:19.370]                   name <- changed[[kk]]
[10:21:19.370]                   NAME <- NAMES[[kk]]
[10:21:19.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.370]                     next
[10:21:19.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.370]                 }
[10:21:19.370]                 NAMES <- toupper(added)
[10:21:19.370]                 for (kk in seq_along(NAMES)) {
[10:21:19.370]                   name <- added[[kk]]
[10:21:19.370]                   NAME <- NAMES[[kk]]
[10:21:19.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.370]                     next
[10:21:19.370]                   args[[name]] <- ""
[10:21:19.370]                 }
[10:21:19.370]                 NAMES <- toupper(removed)
[10:21:19.370]                 for (kk in seq_along(NAMES)) {
[10:21:19.370]                   name <- removed[[kk]]
[10:21:19.370]                   NAME <- NAMES[[kk]]
[10:21:19.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.370]                     next
[10:21:19.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.370]                 }
[10:21:19.370]                 if (length(args) > 0) 
[10:21:19.370]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.370]             }
[10:21:19.370]             else {
[10:21:19.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.370]             }
[10:21:19.370]             {
[10:21:19.370]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.370]                   0L) {
[10:21:19.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.370]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.370]                   base::options(opts)
[10:21:19.370]                 }
[10:21:19.370]                 {
[10:21:19.370]                   {
[10:21:19.370]                     NULL
[10:21:19.370]                     RNGkind("Mersenne-Twister")
[10:21:19.370]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.370]                       inherits = FALSE)
[10:21:19.370]                   }
[10:21:19.370]                   options(future.plan = NULL)
[10:21:19.370]                   if (is.na(NA_character_)) 
[10:21:19.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.370]                     .init = FALSE)
[10:21:19.370]                 }
[10:21:19.370]             }
[10:21:19.370]         }
[10:21:19.370]     })
[10:21:19.370]     if (TRUE) {
[10:21:19.370]         base::sink(type = "output", split = FALSE)
[10:21:19.370]         if (TRUE) {
[10:21:19.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.370]         }
[10:21:19.370]         else {
[10:21:19.370]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.370]         }
[10:21:19.370]         base::close(...future.stdout)
[10:21:19.370]         ...future.stdout <- NULL
[10:21:19.370]     }
[10:21:19.370]     ...future.result$conditions <- ...future.conditions
[10:21:19.370]     ...future.result$finished <- base::Sys.time()
[10:21:19.370]     ...future.result
[10:21:19.370] }
[10:21:19.372] plan(): Setting new future strategy stack:
[10:21:19.372] List of future strategies:
[10:21:19.372] 1. sequential:
[10:21:19.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.372]    - tweaked: FALSE
[10:21:19.372]    - call: NULL
[10:21:19.373] plan(): nbrOfWorkers() = 1
[10:21:19.373] plan(): Setting new future strategy stack:
[10:21:19.373] List of future strategies:
[10:21:19.373] 1. sequential:
[10:21:19.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.373]    - tweaked: FALSE
[10:21:19.373]    - call: plan(strategy)
[10:21:19.374] plan(): nbrOfWorkers() = 1
[10:21:19.374] SequentialFuture started (and completed)
[10:21:19.374] - Launch lazy future ... done
[10:21:19.374] run() for ‘SequentialFuture’ ... done
[10:21:19.374] getGlobalsAndPackages() ...
[10:21:19.374] Searching for globals...
[10:21:19.375] - globals found: [1] ‘{’
[10:21:19.375] Searching for globals ... DONE
[10:21:19.375] Resolving globals: FALSE
[10:21:19.375] 
[10:21:19.376] 
[10:21:19.376] getGlobalsAndPackages() ... DONE
[10:21:19.376] run() for ‘Future’ ...
[10:21:19.376] - state: ‘created’
[10:21:19.376] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.376] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.376]   - Field: ‘label’
[10:21:19.376]   - Field: ‘local’
[10:21:19.377]   - Field: ‘owner’
[10:21:19.377]   - Field: ‘envir’
[10:21:19.377]   - Field: ‘packages’
[10:21:19.377]   - Field: ‘gc’
[10:21:19.377]   - Field: ‘conditions’
[10:21:19.377]   - Field: ‘expr’
[10:21:19.377]   - Field: ‘uuid’
[10:21:19.377]   - Field: ‘seed’
[10:21:19.377]   - Field: ‘version’
[10:21:19.377]   - Field: ‘result’
[10:21:19.377]   - Field: ‘asynchronous’
[10:21:19.377]   - Field: ‘calls’
[10:21:19.378]   - Field: ‘globals’
[10:21:19.378]   - Field: ‘stdout’
[10:21:19.378]   - Field: ‘earlySignal’
[10:21:19.378]   - Field: ‘lazy’
[10:21:19.378]   - Field: ‘state’
[10:21:19.378] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.378] - Launch lazy future ...
[10:21:19.378] Packages needed by the future expression (n = 0): <none>
[10:21:19.378] Packages needed by future strategies (n = 0): <none>
[10:21:19.379] {
[10:21:19.379]     {
[10:21:19.379]         {
[10:21:19.379]             ...future.startTime <- base::Sys.time()
[10:21:19.379]             {
[10:21:19.379]                 {
[10:21:19.379]                   {
[10:21:19.379]                     base::local({
[10:21:19.379]                       has_future <- base::requireNamespace("future", 
[10:21:19.379]                         quietly = TRUE)
[10:21:19.379]                       if (has_future) {
[10:21:19.379]                         ns <- base::getNamespace("future")
[10:21:19.379]                         version <- ns[[".package"]][["version"]]
[10:21:19.379]                         if (is.null(version)) 
[10:21:19.379]                           version <- utils::packageVersion("future")
[10:21:19.379]                       }
[10:21:19.379]                       else {
[10:21:19.379]                         version <- NULL
[10:21:19.379]                       }
[10:21:19.379]                       if (!has_future || version < "1.8.0") {
[10:21:19.379]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.379]                           "", base::R.version$version.string), 
[10:21:19.379]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.379]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.379]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.379]                             "release", "version")], collapse = " "), 
[10:21:19.379]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.379]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.379]                           info)
[10:21:19.379]                         info <- base::paste(info, collapse = "; ")
[10:21:19.379]                         if (!has_future) {
[10:21:19.379]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.379]                             info)
[10:21:19.379]                         }
[10:21:19.379]                         else {
[10:21:19.379]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.379]                             info, version)
[10:21:19.379]                         }
[10:21:19.379]                         base::stop(msg)
[10:21:19.379]                       }
[10:21:19.379]                     })
[10:21:19.379]                   }
[10:21:19.379]                   ...future.strategy.old <- future::plan("list")
[10:21:19.379]                   options(future.plan = NULL)
[10:21:19.379]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.379]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.379]                 }
[10:21:19.379]                 ...future.workdir <- getwd()
[10:21:19.379]             }
[10:21:19.379]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.379]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.379]         }
[10:21:19.379]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.379]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.379]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.379]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.379]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.379]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.379]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.379]             base::names(...future.oldOptions))
[10:21:19.379]     }
[10:21:19.379]     if (FALSE) {
[10:21:19.379]     }
[10:21:19.379]     else {
[10:21:19.379]         if (TRUE) {
[10:21:19.379]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.379]                 open = "w")
[10:21:19.379]         }
[10:21:19.379]         else {
[10:21:19.379]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.379]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.379]         }
[10:21:19.379]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.379]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.379]             base::sink(type = "output", split = FALSE)
[10:21:19.379]             base::close(...future.stdout)
[10:21:19.379]         }, add = TRUE)
[10:21:19.379]     }
[10:21:19.379]     ...future.frame <- base::sys.nframe()
[10:21:19.379]     ...future.conditions <- base::list()
[10:21:19.379]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.379]     if (FALSE) {
[10:21:19.379]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.379]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.379]     }
[10:21:19.379]     ...future.result <- base::tryCatch({
[10:21:19.379]         base::withCallingHandlers({
[10:21:19.379]             ...future.value <- base::withVisible(base::local({
[10:21:19.379]                 4
[10:21:19.379]             }))
[10:21:19.379]             future::FutureResult(value = ...future.value$value, 
[10:21:19.379]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.379]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.379]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.379]                     ...future.globalenv.names))
[10:21:19.379]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.379]         }, condition = base::local({
[10:21:19.379]             c <- base::c
[10:21:19.379]             inherits <- base::inherits
[10:21:19.379]             invokeRestart <- base::invokeRestart
[10:21:19.379]             length <- base::length
[10:21:19.379]             list <- base::list
[10:21:19.379]             seq.int <- base::seq.int
[10:21:19.379]             signalCondition <- base::signalCondition
[10:21:19.379]             sys.calls <- base::sys.calls
[10:21:19.379]             `[[` <- base::`[[`
[10:21:19.379]             `+` <- base::`+`
[10:21:19.379]             `<<-` <- base::`<<-`
[10:21:19.379]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.379]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.379]                   3L)]
[10:21:19.379]             }
[10:21:19.379]             function(cond) {
[10:21:19.379]                 is_error <- inherits(cond, "error")
[10:21:19.379]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.379]                   NULL)
[10:21:19.379]                 if (is_error) {
[10:21:19.379]                   sessionInformation <- function() {
[10:21:19.379]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.379]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.379]                       search = base::search(), system = base::Sys.info())
[10:21:19.379]                   }
[10:21:19.379]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.379]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.379]                     cond$call), session = sessionInformation(), 
[10:21:19.379]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.379]                   signalCondition(cond)
[10:21:19.379]                 }
[10:21:19.379]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.379]                 "immediateCondition"))) {
[10:21:19.379]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.379]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.379]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.379]                   if (TRUE && !signal) {
[10:21:19.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.379]                     {
[10:21:19.379]                       inherits <- base::inherits
[10:21:19.379]                       invokeRestart <- base::invokeRestart
[10:21:19.379]                       is.null <- base::is.null
[10:21:19.379]                       muffled <- FALSE
[10:21:19.379]                       if (inherits(cond, "message")) {
[10:21:19.379]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.379]                         if (muffled) 
[10:21:19.379]                           invokeRestart("muffleMessage")
[10:21:19.379]                       }
[10:21:19.379]                       else if (inherits(cond, "warning")) {
[10:21:19.379]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.379]                         if (muffled) 
[10:21:19.379]                           invokeRestart("muffleWarning")
[10:21:19.379]                       }
[10:21:19.379]                       else if (inherits(cond, "condition")) {
[10:21:19.379]                         if (!is.null(pattern)) {
[10:21:19.379]                           computeRestarts <- base::computeRestarts
[10:21:19.379]                           grepl <- base::grepl
[10:21:19.379]                           restarts <- computeRestarts(cond)
[10:21:19.379]                           for (restart in restarts) {
[10:21:19.379]                             name <- restart$name
[10:21:19.379]                             if (is.null(name)) 
[10:21:19.379]                               next
[10:21:19.379]                             if (!grepl(pattern, name)) 
[10:21:19.379]                               next
[10:21:19.379]                             invokeRestart(restart)
[10:21:19.379]                             muffled <- TRUE
[10:21:19.379]                             break
[10:21:19.379]                           }
[10:21:19.379]                         }
[10:21:19.379]                       }
[10:21:19.379]                       invisible(muffled)
[10:21:19.379]                     }
[10:21:19.379]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.379]                   }
[10:21:19.379]                 }
[10:21:19.379]                 else {
[10:21:19.379]                   if (TRUE) {
[10:21:19.379]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.379]                     {
[10:21:19.379]                       inherits <- base::inherits
[10:21:19.379]                       invokeRestart <- base::invokeRestart
[10:21:19.379]                       is.null <- base::is.null
[10:21:19.379]                       muffled <- FALSE
[10:21:19.379]                       if (inherits(cond, "message")) {
[10:21:19.379]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.379]                         if (muffled) 
[10:21:19.379]                           invokeRestart("muffleMessage")
[10:21:19.379]                       }
[10:21:19.379]                       else if (inherits(cond, "warning")) {
[10:21:19.379]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.379]                         if (muffled) 
[10:21:19.379]                           invokeRestart("muffleWarning")
[10:21:19.379]                       }
[10:21:19.379]                       else if (inherits(cond, "condition")) {
[10:21:19.379]                         if (!is.null(pattern)) {
[10:21:19.379]                           computeRestarts <- base::computeRestarts
[10:21:19.379]                           grepl <- base::grepl
[10:21:19.379]                           restarts <- computeRestarts(cond)
[10:21:19.379]                           for (restart in restarts) {
[10:21:19.379]                             name <- restart$name
[10:21:19.379]                             if (is.null(name)) 
[10:21:19.379]                               next
[10:21:19.379]                             if (!grepl(pattern, name)) 
[10:21:19.379]                               next
[10:21:19.379]                             invokeRestart(restart)
[10:21:19.379]                             muffled <- TRUE
[10:21:19.379]                             break
[10:21:19.379]                           }
[10:21:19.379]                         }
[10:21:19.379]                       }
[10:21:19.379]                       invisible(muffled)
[10:21:19.379]                     }
[10:21:19.379]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.379]                   }
[10:21:19.379]                 }
[10:21:19.379]             }
[10:21:19.379]         }))
[10:21:19.379]     }, error = function(ex) {
[10:21:19.379]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.379]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.379]                 ...future.rng), started = ...future.startTime, 
[10:21:19.379]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.379]             version = "1.8"), class = "FutureResult")
[10:21:19.379]     }, finally = {
[10:21:19.379]         if (!identical(...future.workdir, getwd())) 
[10:21:19.379]             setwd(...future.workdir)
[10:21:19.379]         {
[10:21:19.379]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.379]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.379]             }
[10:21:19.379]             base::options(...future.oldOptions)
[10:21:19.379]             if (.Platform$OS.type == "windows") {
[10:21:19.379]                 old_names <- names(...future.oldEnvVars)
[10:21:19.379]                 envs <- base::Sys.getenv()
[10:21:19.379]                 names <- names(envs)
[10:21:19.379]                 common <- intersect(names, old_names)
[10:21:19.379]                 added <- setdiff(names, old_names)
[10:21:19.379]                 removed <- setdiff(old_names, names)
[10:21:19.379]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.379]                   envs[common]]
[10:21:19.379]                 NAMES <- toupper(changed)
[10:21:19.379]                 args <- list()
[10:21:19.379]                 for (kk in seq_along(NAMES)) {
[10:21:19.379]                   name <- changed[[kk]]
[10:21:19.379]                   NAME <- NAMES[[kk]]
[10:21:19.379]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.379]                     next
[10:21:19.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.379]                 }
[10:21:19.379]                 NAMES <- toupper(added)
[10:21:19.379]                 for (kk in seq_along(NAMES)) {
[10:21:19.379]                   name <- added[[kk]]
[10:21:19.379]                   NAME <- NAMES[[kk]]
[10:21:19.379]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.379]                     next
[10:21:19.379]                   args[[name]] <- ""
[10:21:19.379]                 }
[10:21:19.379]                 NAMES <- toupper(removed)
[10:21:19.379]                 for (kk in seq_along(NAMES)) {
[10:21:19.379]                   name <- removed[[kk]]
[10:21:19.379]                   NAME <- NAMES[[kk]]
[10:21:19.379]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.379]                     next
[10:21:19.379]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.379]                 }
[10:21:19.379]                 if (length(args) > 0) 
[10:21:19.379]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.379]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.379]             }
[10:21:19.379]             else {
[10:21:19.379]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.379]             }
[10:21:19.379]             {
[10:21:19.379]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.379]                   0L) {
[10:21:19.379]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.379]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.379]                   base::options(opts)
[10:21:19.379]                 }
[10:21:19.379]                 {
[10:21:19.379]                   {
[10:21:19.379]                     NULL
[10:21:19.379]                     RNGkind("Mersenne-Twister")
[10:21:19.379]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.379]                       inherits = FALSE)
[10:21:19.379]                   }
[10:21:19.379]                   options(future.plan = NULL)
[10:21:19.379]                   if (is.na(NA_character_)) 
[10:21:19.379]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.379]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.379]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.379]                     .init = FALSE)
[10:21:19.379]                 }
[10:21:19.379]             }
[10:21:19.379]         }
[10:21:19.379]     })
[10:21:19.379]     if (TRUE) {
[10:21:19.379]         base::sink(type = "output", split = FALSE)
[10:21:19.379]         if (TRUE) {
[10:21:19.379]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.379]         }
[10:21:19.379]         else {
[10:21:19.379]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.379]         }
[10:21:19.379]         base::close(...future.stdout)
[10:21:19.379]         ...future.stdout <- NULL
[10:21:19.379]     }
[10:21:19.379]     ...future.result$conditions <- ...future.conditions
[10:21:19.379]     ...future.result$finished <- base::Sys.time()
[10:21:19.379]     ...future.result
[10:21:19.379] }
[10:21:19.380] plan(): Setting new future strategy stack:
[10:21:19.380] List of future strategies:
[10:21:19.380] 1. sequential:
[10:21:19.380]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.380]    - tweaked: FALSE
[10:21:19.380]    - call: NULL
[10:21:19.381] plan(): nbrOfWorkers() = 1
[10:21:19.381] plan(): Setting new future strategy stack:
[10:21:19.382] List of future strategies:
[10:21:19.382] 1. sequential:
[10:21:19.382]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.382]    - tweaked: FALSE
[10:21:19.382]    - call: plan(strategy)
[10:21:19.382] plan(): nbrOfWorkers() = 1
[10:21:19.382] SequentialFuture started (and completed)
[10:21:19.382] - Launch lazy future ... done
[10:21:19.382] run() for ‘SequentialFuture’ ... done
<environment: 0x55e8e4f74f68> 
<environment: 0x55e8e4dd0070> 
[10:21:19.383] resolved() for ‘SequentialFuture’ ...
[10:21:19.384] - state: ‘finished’
[10:21:19.384] - run: TRUE
[10:21:19.384] - result: ‘FutureResult’
[10:21:19.384] resolved() for ‘SequentialFuture’ ... done
[10:21:19.384] resolved() for ‘SequentialFuture’ ...
[10:21:19.384] - state: ‘finished’
[10:21:19.384] - run: TRUE
[10:21:19.384] - result: ‘FutureResult’
[10:21:19.384] resolved() for ‘SequentialFuture’ ... done
[10:21:19.384] resolved() for ‘SequentialFuture’ ...
[10:21:19.384] - state: ‘finished’
[10:21:19.384] - run: TRUE
[10:21:19.384] - result: ‘FutureResult’
[10:21:19.385] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:19.386] resolve() on environment ...
[10:21:19.386]  recursive: 0
[10:21:19.386]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:19.386] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.386] - nx: 4
[10:21:19.386] - relay: TRUE
[10:21:19.386] - stdout: TRUE
[10:21:19.386] - signal: TRUE
[10:21:19.387] - resignal: FALSE
[10:21:19.387] - force: TRUE
[10:21:19.387] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.387] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.387]  - until=2
[10:21:19.387]  - relaying element #2
[10:21:19.387] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.387] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.387] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.387]  length: 3 (resolved future 1)
[10:21:19.387] resolved() for ‘SequentialFuture’ ...
[10:21:19.387] - state: ‘finished’
[10:21:19.388] - run: TRUE
[10:21:19.388] - result: ‘FutureResult’
[10:21:19.388] resolved() for ‘SequentialFuture’ ... done
[10:21:19.388] Future #2
[10:21:19.388] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.388] - nx: 4
[10:21:19.388] - relay: TRUE
[10:21:19.388] - stdout: TRUE
[10:21:19.388] - signal: TRUE
[10:21:19.388] - resignal: FALSE
[10:21:19.388] - force: TRUE
[10:21:19.388] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.388] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.389]  - until=2
[10:21:19.389]  - relaying element #2
[10:21:19.389] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.389] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.389] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.389]  length: 2 (resolved future 2)
[10:21:19.389] resolved() for ‘SequentialFuture’ ...
[10:21:19.389] - state: ‘finished’
[10:21:19.389] - run: TRUE
[10:21:19.389] - result: ‘FutureResult’
[10:21:19.389] resolved() for ‘SequentialFuture’ ... done
[10:21:19.390] Future #3
[10:21:19.390] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.390] - nx: 4
[10:21:19.390] - relay: TRUE
[10:21:19.390] - stdout: TRUE
[10:21:19.390] - signal: TRUE
[10:21:19.390] - resignal: FALSE
[10:21:19.390] - force: TRUE
[10:21:19.390] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.390] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.390]  - until=3
[10:21:19.390]  - relaying element #3
[10:21:19.391] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.391] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.391] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.391]  length: 1 (resolved future 3)
[10:21:19.391] resolved() for ‘SequentialFuture’ ...
[10:21:19.391] - state: ‘finished’
[10:21:19.391] - run: TRUE
[10:21:19.391] - result: ‘FutureResult’
[10:21:19.391] resolved() for ‘SequentialFuture’ ... done
[10:21:19.391] Future #4
[10:21:19.391] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.392] - nx: 4
[10:21:19.392] - relay: TRUE
[10:21:19.392] - stdout: TRUE
[10:21:19.392] - signal: TRUE
[10:21:19.392] - resignal: FALSE
[10:21:19.392] - force: TRUE
[10:21:19.392] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.392] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.392]  - until=4
[10:21:19.392]  - relaying element #4
[10:21:19.392] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.392] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.392] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.394]  length: 0 (resolved future 4)
[10:21:19.394] Relaying remaining futures
[10:21:19.394] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.394] - nx: 4
[10:21:19.394] - relay: TRUE
[10:21:19.394] - stdout: TRUE
[10:21:19.394] - signal: TRUE
[10:21:19.394] - resignal: FALSE
[10:21:19.394] - force: TRUE
[10:21:19.394] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.394] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:19.395] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.395] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.395] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.395] resolve() on environment ... DONE
<environment: 0x55e8e4f7a3d0> 
Dimensions: c(2, 3)
[10:21:19.395] getGlobalsAndPackages() ...
[10:21:19.395] Searching for globals...
[10:21:19.396] 
[10:21:19.396] Searching for globals ... DONE
[10:21:19.396] - globals: [0] <none>
[10:21:19.396] getGlobalsAndPackages() ... DONE
[10:21:19.396] run() for ‘Future’ ...
[10:21:19.396] - state: ‘created’
[10:21:19.396] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.397] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.397] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.397]   - Field: ‘label’
[10:21:19.397]   - Field: ‘local’
[10:21:19.397]   - Field: ‘owner’
[10:21:19.397]   - Field: ‘envir’
[10:21:19.397]   - Field: ‘packages’
[10:21:19.397]   - Field: ‘gc’
[10:21:19.397]   - Field: ‘conditions’
[10:21:19.397]   - Field: ‘expr’
[10:21:19.397]   - Field: ‘uuid’
[10:21:19.397]   - Field: ‘seed’
[10:21:19.397]   - Field: ‘version’
[10:21:19.398]   - Field: ‘result’
[10:21:19.398]   - Field: ‘asynchronous’
[10:21:19.398]   - Field: ‘calls’
[10:21:19.398]   - Field: ‘globals’
[10:21:19.398]   - Field: ‘stdout’
[10:21:19.398]   - Field: ‘earlySignal’
[10:21:19.398]   - Field: ‘lazy’
[10:21:19.398]   - Field: ‘state’
[10:21:19.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.398] - Launch lazy future ...
[10:21:19.398] Packages needed by the future expression (n = 0): <none>
[10:21:19.399] Packages needed by future strategies (n = 0): <none>
[10:21:19.399] {
[10:21:19.399]     {
[10:21:19.399]         {
[10:21:19.399]             ...future.startTime <- base::Sys.time()
[10:21:19.399]             {
[10:21:19.399]                 {
[10:21:19.399]                   {
[10:21:19.399]                     base::local({
[10:21:19.399]                       has_future <- base::requireNamespace("future", 
[10:21:19.399]                         quietly = TRUE)
[10:21:19.399]                       if (has_future) {
[10:21:19.399]                         ns <- base::getNamespace("future")
[10:21:19.399]                         version <- ns[[".package"]][["version"]]
[10:21:19.399]                         if (is.null(version)) 
[10:21:19.399]                           version <- utils::packageVersion("future")
[10:21:19.399]                       }
[10:21:19.399]                       else {
[10:21:19.399]                         version <- NULL
[10:21:19.399]                       }
[10:21:19.399]                       if (!has_future || version < "1.8.0") {
[10:21:19.399]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.399]                           "", base::R.version$version.string), 
[10:21:19.399]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.399]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.399]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.399]                             "release", "version")], collapse = " "), 
[10:21:19.399]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.399]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.399]                           info)
[10:21:19.399]                         info <- base::paste(info, collapse = "; ")
[10:21:19.399]                         if (!has_future) {
[10:21:19.399]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.399]                             info)
[10:21:19.399]                         }
[10:21:19.399]                         else {
[10:21:19.399]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.399]                             info, version)
[10:21:19.399]                         }
[10:21:19.399]                         base::stop(msg)
[10:21:19.399]                       }
[10:21:19.399]                     })
[10:21:19.399]                   }
[10:21:19.399]                   ...future.strategy.old <- future::plan("list")
[10:21:19.399]                   options(future.plan = NULL)
[10:21:19.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.399]                 }
[10:21:19.399]                 ...future.workdir <- getwd()
[10:21:19.399]             }
[10:21:19.399]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.399]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.399]         }
[10:21:19.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.399]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.399]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.399]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.399]             base::names(...future.oldOptions))
[10:21:19.399]     }
[10:21:19.399]     if (FALSE) {
[10:21:19.399]     }
[10:21:19.399]     else {
[10:21:19.399]         if (TRUE) {
[10:21:19.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.399]                 open = "w")
[10:21:19.399]         }
[10:21:19.399]         else {
[10:21:19.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.399]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.399]         }
[10:21:19.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.399]             base::sink(type = "output", split = FALSE)
[10:21:19.399]             base::close(...future.stdout)
[10:21:19.399]         }, add = TRUE)
[10:21:19.399]     }
[10:21:19.399]     ...future.frame <- base::sys.nframe()
[10:21:19.399]     ...future.conditions <- base::list()
[10:21:19.399]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.399]     if (FALSE) {
[10:21:19.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.399]     }
[10:21:19.399]     ...future.result <- base::tryCatch({
[10:21:19.399]         base::withCallingHandlers({
[10:21:19.399]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.399]             future::FutureResult(value = ...future.value$value, 
[10:21:19.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.399]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.399]                     ...future.globalenv.names))
[10:21:19.399]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.399]         }, condition = base::local({
[10:21:19.399]             c <- base::c
[10:21:19.399]             inherits <- base::inherits
[10:21:19.399]             invokeRestart <- base::invokeRestart
[10:21:19.399]             length <- base::length
[10:21:19.399]             list <- base::list
[10:21:19.399]             seq.int <- base::seq.int
[10:21:19.399]             signalCondition <- base::signalCondition
[10:21:19.399]             sys.calls <- base::sys.calls
[10:21:19.399]             `[[` <- base::`[[`
[10:21:19.399]             `+` <- base::`+`
[10:21:19.399]             `<<-` <- base::`<<-`
[10:21:19.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.399]                   3L)]
[10:21:19.399]             }
[10:21:19.399]             function(cond) {
[10:21:19.399]                 is_error <- inherits(cond, "error")
[10:21:19.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.399]                   NULL)
[10:21:19.399]                 if (is_error) {
[10:21:19.399]                   sessionInformation <- function() {
[10:21:19.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.399]                       search = base::search(), system = base::Sys.info())
[10:21:19.399]                   }
[10:21:19.399]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.399]                     cond$call), session = sessionInformation(), 
[10:21:19.399]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.399]                   signalCondition(cond)
[10:21:19.399]                 }
[10:21:19.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.399]                 "immediateCondition"))) {
[10:21:19.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.399]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.399]                   if (TRUE && !signal) {
[10:21:19.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.399]                     {
[10:21:19.399]                       inherits <- base::inherits
[10:21:19.399]                       invokeRestart <- base::invokeRestart
[10:21:19.399]                       is.null <- base::is.null
[10:21:19.399]                       muffled <- FALSE
[10:21:19.399]                       if (inherits(cond, "message")) {
[10:21:19.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.399]                         if (muffled) 
[10:21:19.399]                           invokeRestart("muffleMessage")
[10:21:19.399]                       }
[10:21:19.399]                       else if (inherits(cond, "warning")) {
[10:21:19.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.399]                         if (muffled) 
[10:21:19.399]                           invokeRestart("muffleWarning")
[10:21:19.399]                       }
[10:21:19.399]                       else if (inherits(cond, "condition")) {
[10:21:19.399]                         if (!is.null(pattern)) {
[10:21:19.399]                           computeRestarts <- base::computeRestarts
[10:21:19.399]                           grepl <- base::grepl
[10:21:19.399]                           restarts <- computeRestarts(cond)
[10:21:19.399]                           for (restart in restarts) {
[10:21:19.399]                             name <- restart$name
[10:21:19.399]                             if (is.null(name)) 
[10:21:19.399]                               next
[10:21:19.399]                             if (!grepl(pattern, name)) 
[10:21:19.399]                               next
[10:21:19.399]                             invokeRestart(restart)
[10:21:19.399]                             muffled <- TRUE
[10:21:19.399]                             break
[10:21:19.399]                           }
[10:21:19.399]                         }
[10:21:19.399]                       }
[10:21:19.399]                       invisible(muffled)
[10:21:19.399]                     }
[10:21:19.399]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.399]                   }
[10:21:19.399]                 }
[10:21:19.399]                 else {
[10:21:19.399]                   if (TRUE) {
[10:21:19.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.399]                     {
[10:21:19.399]                       inherits <- base::inherits
[10:21:19.399]                       invokeRestart <- base::invokeRestart
[10:21:19.399]                       is.null <- base::is.null
[10:21:19.399]                       muffled <- FALSE
[10:21:19.399]                       if (inherits(cond, "message")) {
[10:21:19.399]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.399]                         if (muffled) 
[10:21:19.399]                           invokeRestart("muffleMessage")
[10:21:19.399]                       }
[10:21:19.399]                       else if (inherits(cond, "warning")) {
[10:21:19.399]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.399]                         if (muffled) 
[10:21:19.399]                           invokeRestart("muffleWarning")
[10:21:19.399]                       }
[10:21:19.399]                       else if (inherits(cond, "condition")) {
[10:21:19.399]                         if (!is.null(pattern)) {
[10:21:19.399]                           computeRestarts <- base::computeRestarts
[10:21:19.399]                           grepl <- base::grepl
[10:21:19.399]                           restarts <- computeRestarts(cond)
[10:21:19.399]                           for (restart in restarts) {
[10:21:19.399]                             name <- restart$name
[10:21:19.399]                             if (is.null(name)) 
[10:21:19.399]                               next
[10:21:19.399]                             if (!grepl(pattern, name)) 
[10:21:19.399]                               next
[10:21:19.399]                             invokeRestart(restart)
[10:21:19.399]                             muffled <- TRUE
[10:21:19.399]                             break
[10:21:19.399]                           }
[10:21:19.399]                         }
[10:21:19.399]                       }
[10:21:19.399]                       invisible(muffled)
[10:21:19.399]                     }
[10:21:19.399]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.399]                   }
[10:21:19.399]                 }
[10:21:19.399]             }
[10:21:19.399]         }))
[10:21:19.399]     }, error = function(ex) {
[10:21:19.399]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.399]                 ...future.rng), started = ...future.startTime, 
[10:21:19.399]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.399]             version = "1.8"), class = "FutureResult")
[10:21:19.399]     }, finally = {
[10:21:19.399]         if (!identical(...future.workdir, getwd())) 
[10:21:19.399]             setwd(...future.workdir)
[10:21:19.399]         {
[10:21:19.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.399]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.399]             }
[10:21:19.399]             base::options(...future.oldOptions)
[10:21:19.399]             if (.Platform$OS.type == "windows") {
[10:21:19.399]                 old_names <- names(...future.oldEnvVars)
[10:21:19.399]                 envs <- base::Sys.getenv()
[10:21:19.399]                 names <- names(envs)
[10:21:19.399]                 common <- intersect(names, old_names)
[10:21:19.399]                 added <- setdiff(names, old_names)
[10:21:19.399]                 removed <- setdiff(old_names, names)
[10:21:19.399]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.399]                   envs[common]]
[10:21:19.399]                 NAMES <- toupper(changed)
[10:21:19.399]                 args <- list()
[10:21:19.399]                 for (kk in seq_along(NAMES)) {
[10:21:19.399]                   name <- changed[[kk]]
[10:21:19.399]                   NAME <- NAMES[[kk]]
[10:21:19.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.399]                     next
[10:21:19.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.399]                 }
[10:21:19.399]                 NAMES <- toupper(added)
[10:21:19.399]                 for (kk in seq_along(NAMES)) {
[10:21:19.399]                   name <- added[[kk]]
[10:21:19.399]                   NAME <- NAMES[[kk]]
[10:21:19.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.399]                     next
[10:21:19.399]                   args[[name]] <- ""
[10:21:19.399]                 }
[10:21:19.399]                 NAMES <- toupper(removed)
[10:21:19.399]                 for (kk in seq_along(NAMES)) {
[10:21:19.399]                   name <- removed[[kk]]
[10:21:19.399]                   NAME <- NAMES[[kk]]
[10:21:19.399]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.399]                     next
[10:21:19.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.399]                 }
[10:21:19.399]                 if (length(args) > 0) 
[10:21:19.399]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.399]             }
[10:21:19.399]             else {
[10:21:19.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.399]             }
[10:21:19.399]             {
[10:21:19.399]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.399]                   0L) {
[10:21:19.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.399]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.399]                   base::options(opts)
[10:21:19.399]                 }
[10:21:19.399]                 {
[10:21:19.399]                   {
[10:21:19.399]                     NULL
[10:21:19.399]                     RNGkind("Mersenne-Twister")
[10:21:19.399]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.399]                       inherits = FALSE)
[10:21:19.399]                   }
[10:21:19.399]                   options(future.plan = NULL)
[10:21:19.399]                   if (is.na(NA_character_)) 
[10:21:19.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.399]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.399]                     .init = FALSE)
[10:21:19.399]                 }
[10:21:19.399]             }
[10:21:19.399]         }
[10:21:19.399]     })
[10:21:19.399]     if (TRUE) {
[10:21:19.399]         base::sink(type = "output", split = FALSE)
[10:21:19.399]         if (TRUE) {
[10:21:19.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.399]         }
[10:21:19.399]         else {
[10:21:19.399]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.399]         }
[10:21:19.399]         base::close(...future.stdout)
[10:21:19.399]         ...future.stdout <- NULL
[10:21:19.399]     }
[10:21:19.399]     ...future.result$conditions <- ...future.conditions
[10:21:19.399]     ...future.result$finished <- base::Sys.time()
[10:21:19.399]     ...future.result
[10:21:19.399] }
[10:21:19.401] plan(): Setting new future strategy stack:
[10:21:19.401] List of future strategies:
[10:21:19.401] 1. sequential:
[10:21:19.401]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.401]    - tweaked: FALSE
[10:21:19.401]    - call: NULL
[10:21:19.401] plan(): nbrOfWorkers() = 1
[10:21:19.402] plan(): Setting new future strategy stack:
[10:21:19.402] List of future strategies:
[10:21:19.402] 1. sequential:
[10:21:19.402]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.402]    - tweaked: FALSE
[10:21:19.402]    - call: plan(strategy)
[10:21:19.402] plan(): nbrOfWorkers() = 1
[10:21:19.402] SequentialFuture started (and completed)
[10:21:19.403] - Launch lazy future ... done
[10:21:19.403] run() for ‘SequentialFuture’ ... done
[10:21:19.403] getGlobalsAndPackages() ...
[10:21:19.403] Searching for globals...
[10:21:19.403] 
[10:21:19.403] Searching for globals ... DONE
[10:21:19.403] - globals: [0] <none>
[10:21:19.403] getGlobalsAndPackages() ... DONE
[10:21:19.404] run() for ‘Future’ ...
[10:21:19.404] - state: ‘created’
[10:21:19.404] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.404] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.404] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.404]   - Field: ‘label’
[10:21:19.404]   - Field: ‘local’
[10:21:19.404]   - Field: ‘owner’
[10:21:19.404]   - Field: ‘envir’
[10:21:19.404]   - Field: ‘packages’
[10:21:19.405]   - Field: ‘gc’
[10:21:19.405]   - Field: ‘conditions’
[10:21:19.405]   - Field: ‘expr’
[10:21:19.405]   - Field: ‘uuid’
[10:21:19.405]   - Field: ‘seed’
[10:21:19.405]   - Field: ‘version’
[10:21:19.405]   - Field: ‘result’
[10:21:19.405]   - Field: ‘asynchronous’
[10:21:19.405]   - Field: ‘calls’
[10:21:19.405]   - Field: ‘globals’
[10:21:19.405]   - Field: ‘stdout’
[10:21:19.405]   - Field: ‘earlySignal’
[10:21:19.406]   - Field: ‘lazy’
[10:21:19.406]   - Field: ‘state’
[10:21:19.406] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.406] - Launch lazy future ...
[10:21:19.406] Packages needed by the future expression (n = 0): <none>
[10:21:19.406] Packages needed by future strategies (n = 0): <none>
[10:21:19.406] {
[10:21:19.406]     {
[10:21:19.406]         {
[10:21:19.406]             ...future.startTime <- base::Sys.time()
[10:21:19.406]             {
[10:21:19.406]                 {
[10:21:19.406]                   {
[10:21:19.406]                     base::local({
[10:21:19.406]                       has_future <- base::requireNamespace("future", 
[10:21:19.406]                         quietly = TRUE)
[10:21:19.406]                       if (has_future) {
[10:21:19.406]                         ns <- base::getNamespace("future")
[10:21:19.406]                         version <- ns[[".package"]][["version"]]
[10:21:19.406]                         if (is.null(version)) 
[10:21:19.406]                           version <- utils::packageVersion("future")
[10:21:19.406]                       }
[10:21:19.406]                       else {
[10:21:19.406]                         version <- NULL
[10:21:19.406]                       }
[10:21:19.406]                       if (!has_future || version < "1.8.0") {
[10:21:19.406]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.406]                           "", base::R.version$version.string), 
[10:21:19.406]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.406]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.406]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.406]                             "release", "version")], collapse = " "), 
[10:21:19.406]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.406]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.406]                           info)
[10:21:19.406]                         info <- base::paste(info, collapse = "; ")
[10:21:19.406]                         if (!has_future) {
[10:21:19.406]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.406]                             info)
[10:21:19.406]                         }
[10:21:19.406]                         else {
[10:21:19.406]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.406]                             info, version)
[10:21:19.406]                         }
[10:21:19.406]                         base::stop(msg)
[10:21:19.406]                       }
[10:21:19.406]                     })
[10:21:19.406]                   }
[10:21:19.406]                   ...future.strategy.old <- future::plan("list")
[10:21:19.406]                   options(future.plan = NULL)
[10:21:19.406]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.406]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.406]                 }
[10:21:19.406]                 ...future.workdir <- getwd()
[10:21:19.406]             }
[10:21:19.406]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.406]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.406]         }
[10:21:19.406]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.406]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.406]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.406]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.406]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.406]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.406]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.406]             base::names(...future.oldOptions))
[10:21:19.406]     }
[10:21:19.406]     if (FALSE) {
[10:21:19.406]     }
[10:21:19.406]     else {
[10:21:19.406]         if (TRUE) {
[10:21:19.406]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.406]                 open = "w")
[10:21:19.406]         }
[10:21:19.406]         else {
[10:21:19.406]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.406]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.406]         }
[10:21:19.406]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.406]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.406]             base::sink(type = "output", split = FALSE)
[10:21:19.406]             base::close(...future.stdout)
[10:21:19.406]         }, add = TRUE)
[10:21:19.406]     }
[10:21:19.406]     ...future.frame <- base::sys.nframe()
[10:21:19.406]     ...future.conditions <- base::list()
[10:21:19.406]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.406]     if (FALSE) {
[10:21:19.406]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.406]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.406]     }
[10:21:19.406]     ...future.result <- base::tryCatch({
[10:21:19.406]         base::withCallingHandlers({
[10:21:19.406]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.406]             future::FutureResult(value = ...future.value$value, 
[10:21:19.406]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.406]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.406]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.406]                     ...future.globalenv.names))
[10:21:19.406]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.406]         }, condition = base::local({
[10:21:19.406]             c <- base::c
[10:21:19.406]             inherits <- base::inherits
[10:21:19.406]             invokeRestart <- base::invokeRestart
[10:21:19.406]             length <- base::length
[10:21:19.406]             list <- base::list
[10:21:19.406]             seq.int <- base::seq.int
[10:21:19.406]             signalCondition <- base::signalCondition
[10:21:19.406]             sys.calls <- base::sys.calls
[10:21:19.406]             `[[` <- base::`[[`
[10:21:19.406]             `+` <- base::`+`
[10:21:19.406]             `<<-` <- base::`<<-`
[10:21:19.406]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.406]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.406]                   3L)]
[10:21:19.406]             }
[10:21:19.406]             function(cond) {
[10:21:19.406]                 is_error <- inherits(cond, "error")
[10:21:19.406]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.406]                   NULL)
[10:21:19.406]                 if (is_error) {
[10:21:19.406]                   sessionInformation <- function() {
[10:21:19.406]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.406]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.406]                       search = base::search(), system = base::Sys.info())
[10:21:19.406]                   }
[10:21:19.406]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.406]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.406]                     cond$call), session = sessionInformation(), 
[10:21:19.406]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.406]                   signalCondition(cond)
[10:21:19.406]                 }
[10:21:19.406]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.406]                 "immediateCondition"))) {
[10:21:19.406]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.406]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.406]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.406]                   if (TRUE && !signal) {
[10:21:19.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.406]                     {
[10:21:19.406]                       inherits <- base::inherits
[10:21:19.406]                       invokeRestart <- base::invokeRestart
[10:21:19.406]                       is.null <- base::is.null
[10:21:19.406]                       muffled <- FALSE
[10:21:19.406]                       if (inherits(cond, "message")) {
[10:21:19.406]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.406]                         if (muffled) 
[10:21:19.406]                           invokeRestart("muffleMessage")
[10:21:19.406]                       }
[10:21:19.406]                       else if (inherits(cond, "warning")) {
[10:21:19.406]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.406]                         if (muffled) 
[10:21:19.406]                           invokeRestart("muffleWarning")
[10:21:19.406]                       }
[10:21:19.406]                       else if (inherits(cond, "condition")) {
[10:21:19.406]                         if (!is.null(pattern)) {
[10:21:19.406]                           computeRestarts <- base::computeRestarts
[10:21:19.406]                           grepl <- base::grepl
[10:21:19.406]                           restarts <- computeRestarts(cond)
[10:21:19.406]                           for (restart in restarts) {
[10:21:19.406]                             name <- restart$name
[10:21:19.406]                             if (is.null(name)) 
[10:21:19.406]                               next
[10:21:19.406]                             if (!grepl(pattern, name)) 
[10:21:19.406]                               next
[10:21:19.406]                             invokeRestart(restart)
[10:21:19.406]                             muffled <- TRUE
[10:21:19.406]                             break
[10:21:19.406]                           }
[10:21:19.406]                         }
[10:21:19.406]                       }
[10:21:19.406]                       invisible(muffled)
[10:21:19.406]                     }
[10:21:19.406]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.406]                   }
[10:21:19.406]                 }
[10:21:19.406]                 else {
[10:21:19.406]                   if (TRUE) {
[10:21:19.406]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.406]                     {
[10:21:19.406]                       inherits <- base::inherits
[10:21:19.406]                       invokeRestart <- base::invokeRestart
[10:21:19.406]                       is.null <- base::is.null
[10:21:19.406]                       muffled <- FALSE
[10:21:19.406]                       if (inherits(cond, "message")) {
[10:21:19.406]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.406]                         if (muffled) 
[10:21:19.406]                           invokeRestart("muffleMessage")
[10:21:19.406]                       }
[10:21:19.406]                       else if (inherits(cond, "warning")) {
[10:21:19.406]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.406]                         if (muffled) 
[10:21:19.406]                           invokeRestart("muffleWarning")
[10:21:19.406]                       }
[10:21:19.406]                       else if (inherits(cond, "condition")) {
[10:21:19.406]                         if (!is.null(pattern)) {
[10:21:19.406]                           computeRestarts <- base::computeRestarts
[10:21:19.406]                           grepl <- base::grepl
[10:21:19.406]                           restarts <- computeRestarts(cond)
[10:21:19.406]                           for (restart in restarts) {
[10:21:19.406]                             name <- restart$name
[10:21:19.406]                             if (is.null(name)) 
[10:21:19.406]                               next
[10:21:19.406]                             if (!grepl(pattern, name)) 
[10:21:19.406]                               next
[10:21:19.406]                             invokeRestart(restart)
[10:21:19.406]                             muffled <- TRUE
[10:21:19.406]                             break
[10:21:19.406]                           }
[10:21:19.406]                         }
[10:21:19.406]                       }
[10:21:19.406]                       invisible(muffled)
[10:21:19.406]                     }
[10:21:19.406]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.406]                   }
[10:21:19.406]                 }
[10:21:19.406]             }
[10:21:19.406]         }))
[10:21:19.406]     }, error = function(ex) {
[10:21:19.406]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.406]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.406]                 ...future.rng), started = ...future.startTime, 
[10:21:19.406]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.406]             version = "1.8"), class = "FutureResult")
[10:21:19.406]     }, finally = {
[10:21:19.406]         if (!identical(...future.workdir, getwd())) 
[10:21:19.406]             setwd(...future.workdir)
[10:21:19.406]         {
[10:21:19.406]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.406]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.406]             }
[10:21:19.406]             base::options(...future.oldOptions)
[10:21:19.406]             if (.Platform$OS.type == "windows") {
[10:21:19.406]                 old_names <- names(...future.oldEnvVars)
[10:21:19.406]                 envs <- base::Sys.getenv()
[10:21:19.406]                 names <- names(envs)
[10:21:19.406]                 common <- intersect(names, old_names)
[10:21:19.406]                 added <- setdiff(names, old_names)
[10:21:19.406]                 removed <- setdiff(old_names, names)
[10:21:19.406]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.406]                   envs[common]]
[10:21:19.406]                 NAMES <- toupper(changed)
[10:21:19.406]                 args <- list()
[10:21:19.406]                 for (kk in seq_along(NAMES)) {
[10:21:19.406]                   name <- changed[[kk]]
[10:21:19.406]                   NAME <- NAMES[[kk]]
[10:21:19.406]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.406]                     next
[10:21:19.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.406]                 }
[10:21:19.406]                 NAMES <- toupper(added)
[10:21:19.406]                 for (kk in seq_along(NAMES)) {
[10:21:19.406]                   name <- added[[kk]]
[10:21:19.406]                   NAME <- NAMES[[kk]]
[10:21:19.406]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.406]                     next
[10:21:19.406]                   args[[name]] <- ""
[10:21:19.406]                 }
[10:21:19.406]                 NAMES <- toupper(removed)
[10:21:19.406]                 for (kk in seq_along(NAMES)) {
[10:21:19.406]                   name <- removed[[kk]]
[10:21:19.406]                   NAME <- NAMES[[kk]]
[10:21:19.406]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.406]                     next
[10:21:19.406]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.406]                 }
[10:21:19.406]                 if (length(args) > 0) 
[10:21:19.406]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.406]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.406]             }
[10:21:19.406]             else {
[10:21:19.406]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.406]             }
[10:21:19.406]             {
[10:21:19.406]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.406]                   0L) {
[10:21:19.406]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.406]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.406]                   base::options(opts)
[10:21:19.406]                 }
[10:21:19.406]                 {
[10:21:19.406]                   {
[10:21:19.406]                     NULL
[10:21:19.406]                     RNGkind("Mersenne-Twister")
[10:21:19.406]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.406]                       inherits = FALSE)
[10:21:19.406]                   }
[10:21:19.406]                   options(future.plan = NULL)
[10:21:19.406]                   if (is.na(NA_character_)) 
[10:21:19.406]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.406]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.406]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.406]                     .init = FALSE)
[10:21:19.406]                 }
[10:21:19.406]             }
[10:21:19.406]         }
[10:21:19.406]     })
[10:21:19.406]     if (TRUE) {
[10:21:19.406]         base::sink(type = "output", split = FALSE)
[10:21:19.406]         if (TRUE) {
[10:21:19.406]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.406]         }
[10:21:19.406]         else {
[10:21:19.406]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.406]         }
[10:21:19.406]         base::close(...future.stdout)
[10:21:19.406]         ...future.stdout <- NULL
[10:21:19.406]     }
[10:21:19.406]     ...future.result$conditions <- ...future.conditions
[10:21:19.406]     ...future.result$finished <- base::Sys.time()
[10:21:19.406]     ...future.result
[10:21:19.406] }
[10:21:19.408] plan(): Setting new future strategy stack:
[10:21:19.408] List of future strategies:
[10:21:19.408] 1. sequential:
[10:21:19.408]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.408]    - tweaked: FALSE
[10:21:19.408]    - call: NULL
[10:21:19.409] plan(): nbrOfWorkers() = 1
[10:21:19.409] plan(): Setting new future strategy stack:
[10:21:19.409] List of future strategies:
[10:21:19.409] 1. sequential:
[10:21:19.409]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.409]    - tweaked: FALSE
[10:21:19.409]    - call: plan(strategy)
[10:21:19.410] plan(): nbrOfWorkers() = 1
[10:21:19.410] SequentialFuture started (and completed)
[10:21:19.410] - Launch lazy future ... done
[10:21:19.410] run() for ‘SequentialFuture’ ... done
[10:21:19.410] getGlobalsAndPackages() ...
[10:21:19.410] Searching for globals...
[10:21:19.411] - globals found: [1] ‘{’
[10:21:19.411] Searching for globals ... DONE
[10:21:19.411] Resolving globals: FALSE
[10:21:19.411] 
[10:21:19.411] 
[10:21:19.412] getGlobalsAndPackages() ... DONE
[10:21:19.412] run() for ‘Future’ ...
[10:21:19.412] - state: ‘created’
[10:21:19.412] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.412] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.412]   - Field: ‘label’
[10:21:19.412]   - Field: ‘local’
[10:21:19.413]   - Field: ‘owner’
[10:21:19.413]   - Field: ‘envir’
[10:21:19.413]   - Field: ‘packages’
[10:21:19.413]   - Field: ‘gc’
[10:21:19.413]   - Field: ‘conditions’
[10:21:19.413]   - Field: ‘expr’
[10:21:19.413]   - Field: ‘uuid’
[10:21:19.413]   - Field: ‘seed’
[10:21:19.413]   - Field: ‘version’
[10:21:19.413]   - Field: ‘result’
[10:21:19.413]   - Field: ‘asynchronous’
[10:21:19.413]   - Field: ‘calls’
[10:21:19.413]   - Field: ‘globals’
[10:21:19.414]   - Field: ‘stdout’
[10:21:19.414]   - Field: ‘earlySignal’
[10:21:19.414]   - Field: ‘lazy’
[10:21:19.414]   - Field: ‘state’
[10:21:19.414] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.414] - Launch lazy future ...
[10:21:19.414] Packages needed by the future expression (n = 0): <none>
[10:21:19.414] Packages needed by future strategies (n = 0): <none>
[10:21:19.415] {
[10:21:19.415]     {
[10:21:19.415]         {
[10:21:19.415]             ...future.startTime <- base::Sys.time()
[10:21:19.415]             {
[10:21:19.415]                 {
[10:21:19.415]                   {
[10:21:19.415]                     base::local({
[10:21:19.415]                       has_future <- base::requireNamespace("future", 
[10:21:19.415]                         quietly = TRUE)
[10:21:19.415]                       if (has_future) {
[10:21:19.415]                         ns <- base::getNamespace("future")
[10:21:19.415]                         version <- ns[[".package"]][["version"]]
[10:21:19.415]                         if (is.null(version)) 
[10:21:19.415]                           version <- utils::packageVersion("future")
[10:21:19.415]                       }
[10:21:19.415]                       else {
[10:21:19.415]                         version <- NULL
[10:21:19.415]                       }
[10:21:19.415]                       if (!has_future || version < "1.8.0") {
[10:21:19.415]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.415]                           "", base::R.version$version.string), 
[10:21:19.415]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.415]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.415]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.415]                             "release", "version")], collapse = " "), 
[10:21:19.415]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.415]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.415]                           info)
[10:21:19.415]                         info <- base::paste(info, collapse = "; ")
[10:21:19.415]                         if (!has_future) {
[10:21:19.415]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.415]                             info)
[10:21:19.415]                         }
[10:21:19.415]                         else {
[10:21:19.415]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.415]                             info, version)
[10:21:19.415]                         }
[10:21:19.415]                         base::stop(msg)
[10:21:19.415]                       }
[10:21:19.415]                     })
[10:21:19.415]                   }
[10:21:19.415]                   ...future.strategy.old <- future::plan("list")
[10:21:19.415]                   options(future.plan = NULL)
[10:21:19.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.415]                 }
[10:21:19.415]                 ...future.workdir <- getwd()
[10:21:19.415]             }
[10:21:19.415]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.415]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.415]         }
[10:21:19.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.415]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.415]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.415]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.415]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.415]             base::names(...future.oldOptions))
[10:21:19.415]     }
[10:21:19.415]     if (FALSE) {
[10:21:19.415]     }
[10:21:19.415]     else {
[10:21:19.415]         if (TRUE) {
[10:21:19.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.415]                 open = "w")
[10:21:19.415]         }
[10:21:19.415]         else {
[10:21:19.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.415]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.415]         }
[10:21:19.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.415]             base::sink(type = "output", split = FALSE)
[10:21:19.415]             base::close(...future.stdout)
[10:21:19.415]         }, add = TRUE)
[10:21:19.415]     }
[10:21:19.415]     ...future.frame <- base::sys.nframe()
[10:21:19.415]     ...future.conditions <- base::list()
[10:21:19.415]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.415]     if (FALSE) {
[10:21:19.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.415]     }
[10:21:19.415]     ...future.result <- base::tryCatch({
[10:21:19.415]         base::withCallingHandlers({
[10:21:19.415]             ...future.value <- base::withVisible(base::local({
[10:21:19.415]                 4
[10:21:19.415]             }))
[10:21:19.415]             future::FutureResult(value = ...future.value$value, 
[10:21:19.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.415]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.415]                     ...future.globalenv.names))
[10:21:19.415]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.415]         }, condition = base::local({
[10:21:19.415]             c <- base::c
[10:21:19.415]             inherits <- base::inherits
[10:21:19.415]             invokeRestart <- base::invokeRestart
[10:21:19.415]             length <- base::length
[10:21:19.415]             list <- base::list
[10:21:19.415]             seq.int <- base::seq.int
[10:21:19.415]             signalCondition <- base::signalCondition
[10:21:19.415]             sys.calls <- base::sys.calls
[10:21:19.415]             `[[` <- base::`[[`
[10:21:19.415]             `+` <- base::`+`
[10:21:19.415]             `<<-` <- base::`<<-`
[10:21:19.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.415]                   3L)]
[10:21:19.415]             }
[10:21:19.415]             function(cond) {
[10:21:19.415]                 is_error <- inherits(cond, "error")
[10:21:19.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.415]                   NULL)
[10:21:19.415]                 if (is_error) {
[10:21:19.415]                   sessionInformation <- function() {
[10:21:19.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.415]                       search = base::search(), system = base::Sys.info())
[10:21:19.415]                   }
[10:21:19.415]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.415]                     cond$call), session = sessionInformation(), 
[10:21:19.415]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.415]                   signalCondition(cond)
[10:21:19.415]                 }
[10:21:19.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.415]                 "immediateCondition"))) {
[10:21:19.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.415]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.415]                   if (TRUE && !signal) {
[10:21:19.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.415]                     {
[10:21:19.415]                       inherits <- base::inherits
[10:21:19.415]                       invokeRestart <- base::invokeRestart
[10:21:19.415]                       is.null <- base::is.null
[10:21:19.415]                       muffled <- FALSE
[10:21:19.415]                       if (inherits(cond, "message")) {
[10:21:19.415]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.415]                         if (muffled) 
[10:21:19.415]                           invokeRestart("muffleMessage")
[10:21:19.415]                       }
[10:21:19.415]                       else if (inherits(cond, "warning")) {
[10:21:19.415]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.415]                         if (muffled) 
[10:21:19.415]                           invokeRestart("muffleWarning")
[10:21:19.415]                       }
[10:21:19.415]                       else if (inherits(cond, "condition")) {
[10:21:19.415]                         if (!is.null(pattern)) {
[10:21:19.415]                           computeRestarts <- base::computeRestarts
[10:21:19.415]                           grepl <- base::grepl
[10:21:19.415]                           restarts <- computeRestarts(cond)
[10:21:19.415]                           for (restart in restarts) {
[10:21:19.415]                             name <- restart$name
[10:21:19.415]                             if (is.null(name)) 
[10:21:19.415]                               next
[10:21:19.415]                             if (!grepl(pattern, name)) 
[10:21:19.415]                               next
[10:21:19.415]                             invokeRestart(restart)
[10:21:19.415]                             muffled <- TRUE
[10:21:19.415]                             break
[10:21:19.415]                           }
[10:21:19.415]                         }
[10:21:19.415]                       }
[10:21:19.415]                       invisible(muffled)
[10:21:19.415]                     }
[10:21:19.415]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.415]                   }
[10:21:19.415]                 }
[10:21:19.415]                 else {
[10:21:19.415]                   if (TRUE) {
[10:21:19.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.415]                     {
[10:21:19.415]                       inherits <- base::inherits
[10:21:19.415]                       invokeRestart <- base::invokeRestart
[10:21:19.415]                       is.null <- base::is.null
[10:21:19.415]                       muffled <- FALSE
[10:21:19.415]                       if (inherits(cond, "message")) {
[10:21:19.415]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.415]                         if (muffled) 
[10:21:19.415]                           invokeRestart("muffleMessage")
[10:21:19.415]                       }
[10:21:19.415]                       else if (inherits(cond, "warning")) {
[10:21:19.415]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.415]                         if (muffled) 
[10:21:19.415]                           invokeRestart("muffleWarning")
[10:21:19.415]                       }
[10:21:19.415]                       else if (inherits(cond, "condition")) {
[10:21:19.415]                         if (!is.null(pattern)) {
[10:21:19.415]                           computeRestarts <- base::computeRestarts
[10:21:19.415]                           grepl <- base::grepl
[10:21:19.415]                           restarts <- computeRestarts(cond)
[10:21:19.415]                           for (restart in restarts) {
[10:21:19.415]                             name <- restart$name
[10:21:19.415]                             if (is.null(name)) 
[10:21:19.415]                               next
[10:21:19.415]                             if (!grepl(pattern, name)) 
[10:21:19.415]                               next
[10:21:19.415]                             invokeRestart(restart)
[10:21:19.415]                             muffled <- TRUE
[10:21:19.415]                             break
[10:21:19.415]                           }
[10:21:19.415]                         }
[10:21:19.415]                       }
[10:21:19.415]                       invisible(muffled)
[10:21:19.415]                     }
[10:21:19.415]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.415]                   }
[10:21:19.415]                 }
[10:21:19.415]             }
[10:21:19.415]         }))
[10:21:19.415]     }, error = function(ex) {
[10:21:19.415]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.415]                 ...future.rng), started = ...future.startTime, 
[10:21:19.415]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.415]             version = "1.8"), class = "FutureResult")
[10:21:19.415]     }, finally = {
[10:21:19.415]         if (!identical(...future.workdir, getwd())) 
[10:21:19.415]             setwd(...future.workdir)
[10:21:19.415]         {
[10:21:19.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.415]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.415]             }
[10:21:19.415]             base::options(...future.oldOptions)
[10:21:19.415]             if (.Platform$OS.type == "windows") {
[10:21:19.415]                 old_names <- names(...future.oldEnvVars)
[10:21:19.415]                 envs <- base::Sys.getenv()
[10:21:19.415]                 names <- names(envs)
[10:21:19.415]                 common <- intersect(names, old_names)
[10:21:19.415]                 added <- setdiff(names, old_names)
[10:21:19.415]                 removed <- setdiff(old_names, names)
[10:21:19.415]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.415]                   envs[common]]
[10:21:19.415]                 NAMES <- toupper(changed)
[10:21:19.415]                 args <- list()
[10:21:19.415]                 for (kk in seq_along(NAMES)) {
[10:21:19.415]                   name <- changed[[kk]]
[10:21:19.415]                   NAME <- NAMES[[kk]]
[10:21:19.415]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.415]                     next
[10:21:19.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.415]                 }
[10:21:19.415]                 NAMES <- toupper(added)
[10:21:19.415]                 for (kk in seq_along(NAMES)) {
[10:21:19.415]                   name <- added[[kk]]
[10:21:19.415]                   NAME <- NAMES[[kk]]
[10:21:19.415]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.415]                     next
[10:21:19.415]                   args[[name]] <- ""
[10:21:19.415]                 }
[10:21:19.415]                 NAMES <- toupper(removed)
[10:21:19.415]                 for (kk in seq_along(NAMES)) {
[10:21:19.415]                   name <- removed[[kk]]
[10:21:19.415]                   NAME <- NAMES[[kk]]
[10:21:19.415]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.415]                     next
[10:21:19.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.415]                 }
[10:21:19.415]                 if (length(args) > 0) 
[10:21:19.415]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.415]             }
[10:21:19.415]             else {
[10:21:19.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.415]             }
[10:21:19.415]             {
[10:21:19.415]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.415]                   0L) {
[10:21:19.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.415]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.415]                   base::options(opts)
[10:21:19.415]                 }
[10:21:19.415]                 {
[10:21:19.415]                   {
[10:21:19.415]                     NULL
[10:21:19.415]                     RNGkind("Mersenne-Twister")
[10:21:19.415]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.415]                       inherits = FALSE)
[10:21:19.415]                   }
[10:21:19.415]                   options(future.plan = NULL)
[10:21:19.415]                   if (is.na(NA_character_)) 
[10:21:19.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.415]                     .init = FALSE)
[10:21:19.415]                 }
[10:21:19.415]             }
[10:21:19.415]         }
[10:21:19.415]     })
[10:21:19.415]     if (TRUE) {
[10:21:19.415]         base::sink(type = "output", split = FALSE)
[10:21:19.415]         if (TRUE) {
[10:21:19.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.415]         }
[10:21:19.415]         else {
[10:21:19.415]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.415]         }
[10:21:19.415]         base::close(...future.stdout)
[10:21:19.415]         ...future.stdout <- NULL
[10:21:19.415]     }
[10:21:19.415]     ...future.result$conditions <- ...future.conditions
[10:21:19.415]     ...future.result$finished <- base::Sys.time()
[10:21:19.415]     ...future.result
[10:21:19.415] }
[10:21:19.416] plan(): Setting new future strategy stack:
[10:21:19.416] List of future strategies:
[10:21:19.416] 1. sequential:
[10:21:19.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.416]    - tweaked: FALSE
[10:21:19.416]    - call: NULL
[10:21:19.417] plan(): nbrOfWorkers() = 1
[10:21:19.417] plan(): Setting new future strategy stack:
[10:21:19.418] List of future strategies:
[10:21:19.418] 1. sequential:
[10:21:19.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.418]    - tweaked: FALSE
[10:21:19.418]    - call: plan(strategy)
[10:21:19.418] plan(): nbrOfWorkers() = 1
[10:21:19.418] SequentialFuture started (and completed)
[10:21:19.418] - Launch lazy future ... done
[10:21:19.418] run() for ‘SequentialFuture’ ... done
<environment: 0x55e8e38027e8> 
<environment: 0x55e8e57d8578> 
[10:21:19.421] resolved() for ‘SequentialFuture’ ...
[10:21:19.421] - state: ‘finished’
[10:21:19.421] - run: TRUE
[10:21:19.421] - result: ‘FutureResult’
[10:21:19.421] resolved() for ‘SequentialFuture’ ... done
[10:21:19.421] resolved() for ‘SequentialFuture’ ...
[10:21:19.421] - state: ‘finished’
[10:21:19.422] - run: TRUE
[10:21:19.422] - result: ‘FutureResult’
[10:21:19.422] resolved() for ‘SequentialFuture’ ... done
[10:21:19.422] resolved() for ‘SequentialFuture’ ...
[10:21:19.422] - state: ‘finished’
[10:21:19.422] - run: TRUE
[10:21:19.422] - result: ‘FutureResult’
[10:21:19.422] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:19.423] resolve() on environment ...
[10:21:19.423]  recursive: 0
[10:21:19.424]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:19.424] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.424] - nx: 4
[10:21:19.424] - relay: TRUE
[10:21:19.424] - stdout: TRUE
[10:21:19.424] - signal: TRUE
[10:21:19.424] - resignal: FALSE
[10:21:19.424] - force: TRUE
[10:21:19.424] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.424] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.425]  - until=2
[10:21:19.425]  - relaying element #2
[10:21:19.425] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.425] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.425] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.425]  length: 3 (resolved future 1)
[10:21:19.425] resolved() for ‘SequentialFuture’ ...
[10:21:19.425] - state: ‘finished’
[10:21:19.425] - run: TRUE
[10:21:19.425] - result: ‘FutureResult’
[10:21:19.425] resolved() for ‘SequentialFuture’ ... done
[10:21:19.425] Future #2
[10:21:19.426] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.426] - nx: 4
[10:21:19.426] - relay: TRUE
[10:21:19.426] - stdout: TRUE
[10:21:19.426] - signal: TRUE
[10:21:19.426] - resignal: FALSE
[10:21:19.426] - force: TRUE
[10:21:19.426] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.426] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.426]  - until=2
[10:21:19.426]  - relaying element #2
[10:21:19.427] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.427] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.427] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.427]  length: 2 (resolved future 2)
[10:21:19.427] resolved() for ‘SequentialFuture’ ...
[10:21:19.427] - state: ‘finished’
[10:21:19.427] - run: TRUE
[10:21:19.427] - result: ‘FutureResult’
[10:21:19.427] resolved() for ‘SequentialFuture’ ... done
[10:21:19.427] Future #3
[10:21:19.427] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.427] - nx: 4
[10:21:19.428] - relay: TRUE
[10:21:19.428] - stdout: TRUE
[10:21:19.428] - signal: TRUE
[10:21:19.428] - resignal: FALSE
[10:21:19.428] - force: TRUE
[10:21:19.428] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.428] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.428]  - until=3
[10:21:19.428]  - relaying element #3
[10:21:19.428] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.428] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.428] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.429]  length: 1 (resolved future 3)
[10:21:19.429] resolved() for ‘SequentialFuture’ ...
[10:21:19.429] - state: ‘finished’
[10:21:19.429] - run: TRUE
[10:21:19.429] - result: ‘FutureResult’
[10:21:19.429] resolved() for ‘SequentialFuture’ ... done
[10:21:19.429] Future #4
[10:21:19.429] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.429] - nx: 4
[10:21:19.429] - relay: TRUE
[10:21:19.429] - stdout: TRUE
[10:21:19.429] - signal: TRUE
[10:21:19.430] - resignal: FALSE
[10:21:19.430] - force: TRUE
[10:21:19.430] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.430] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.430]  - until=4
[10:21:19.430]  - relaying element #4
[10:21:19.430] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.430] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.430] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.430]  length: 0 (resolved future 4)
[10:21:19.430] Relaying remaining futures
[10:21:19.430] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.431] - nx: 4
[10:21:19.431] - relay: TRUE
[10:21:19.431] - stdout: TRUE
[10:21:19.431] - signal: TRUE
[10:21:19.431] - resignal: FALSE
[10:21:19.431] - force: TRUE
[10:21:19.431] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.431] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:19.431] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.431] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.431] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.431] resolve() on environment ... DONE
<environment: 0x55e8e3694d78> 
Dimensions: c(2, 3, 1)
[10:21:19.432] getGlobalsAndPackages() ...
[10:21:19.432] Searching for globals...
[10:21:19.432] 
[10:21:19.432] Searching for globals ... DONE
[10:21:19.432] - globals: [0] <none>
[10:21:19.433] getGlobalsAndPackages() ... DONE
[10:21:19.433] run() for ‘Future’ ...
[10:21:19.433] - state: ‘created’
[10:21:19.433] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.433] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.433] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.433]   - Field: ‘label’
[10:21:19.433]   - Field: ‘local’
[10:21:19.434]   - Field: ‘owner’
[10:21:19.434]   - Field: ‘envir’
[10:21:19.434]   - Field: ‘packages’
[10:21:19.434]   - Field: ‘gc’
[10:21:19.434]   - Field: ‘conditions’
[10:21:19.434]   - Field: ‘expr’
[10:21:19.434]   - Field: ‘uuid’
[10:21:19.434]   - Field: ‘seed’
[10:21:19.434]   - Field: ‘version’
[10:21:19.434]   - Field: ‘result’
[10:21:19.434]   - Field: ‘asynchronous’
[10:21:19.434]   - Field: ‘calls’
[10:21:19.434]   - Field: ‘globals’
[10:21:19.435]   - Field: ‘stdout’
[10:21:19.435]   - Field: ‘earlySignal’
[10:21:19.435]   - Field: ‘lazy’
[10:21:19.435]   - Field: ‘state’
[10:21:19.435] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.435] - Launch lazy future ...
[10:21:19.435] Packages needed by the future expression (n = 0): <none>
[10:21:19.435] Packages needed by future strategies (n = 0): <none>
[10:21:19.436] {
[10:21:19.436]     {
[10:21:19.436]         {
[10:21:19.436]             ...future.startTime <- base::Sys.time()
[10:21:19.436]             {
[10:21:19.436]                 {
[10:21:19.436]                   {
[10:21:19.436]                     base::local({
[10:21:19.436]                       has_future <- base::requireNamespace("future", 
[10:21:19.436]                         quietly = TRUE)
[10:21:19.436]                       if (has_future) {
[10:21:19.436]                         ns <- base::getNamespace("future")
[10:21:19.436]                         version <- ns[[".package"]][["version"]]
[10:21:19.436]                         if (is.null(version)) 
[10:21:19.436]                           version <- utils::packageVersion("future")
[10:21:19.436]                       }
[10:21:19.436]                       else {
[10:21:19.436]                         version <- NULL
[10:21:19.436]                       }
[10:21:19.436]                       if (!has_future || version < "1.8.0") {
[10:21:19.436]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.436]                           "", base::R.version$version.string), 
[10:21:19.436]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.436]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.436]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.436]                             "release", "version")], collapse = " "), 
[10:21:19.436]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.436]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.436]                           info)
[10:21:19.436]                         info <- base::paste(info, collapse = "; ")
[10:21:19.436]                         if (!has_future) {
[10:21:19.436]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.436]                             info)
[10:21:19.436]                         }
[10:21:19.436]                         else {
[10:21:19.436]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.436]                             info, version)
[10:21:19.436]                         }
[10:21:19.436]                         base::stop(msg)
[10:21:19.436]                       }
[10:21:19.436]                     })
[10:21:19.436]                   }
[10:21:19.436]                   ...future.strategy.old <- future::plan("list")
[10:21:19.436]                   options(future.plan = NULL)
[10:21:19.436]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.436]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.436]                 }
[10:21:19.436]                 ...future.workdir <- getwd()
[10:21:19.436]             }
[10:21:19.436]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.436]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.436]         }
[10:21:19.436]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.436]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.436]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.436]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.436]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.436]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.436]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.436]             base::names(...future.oldOptions))
[10:21:19.436]     }
[10:21:19.436]     if (FALSE) {
[10:21:19.436]     }
[10:21:19.436]     else {
[10:21:19.436]         if (TRUE) {
[10:21:19.436]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.436]                 open = "w")
[10:21:19.436]         }
[10:21:19.436]         else {
[10:21:19.436]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.436]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.436]         }
[10:21:19.436]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.436]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.436]             base::sink(type = "output", split = FALSE)
[10:21:19.436]             base::close(...future.stdout)
[10:21:19.436]         }, add = TRUE)
[10:21:19.436]     }
[10:21:19.436]     ...future.frame <- base::sys.nframe()
[10:21:19.436]     ...future.conditions <- base::list()
[10:21:19.436]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.436]     if (FALSE) {
[10:21:19.436]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.436]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.436]     }
[10:21:19.436]     ...future.result <- base::tryCatch({
[10:21:19.436]         base::withCallingHandlers({
[10:21:19.436]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.436]             future::FutureResult(value = ...future.value$value, 
[10:21:19.436]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.436]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.436]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.436]                     ...future.globalenv.names))
[10:21:19.436]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.436]         }, condition = base::local({
[10:21:19.436]             c <- base::c
[10:21:19.436]             inherits <- base::inherits
[10:21:19.436]             invokeRestart <- base::invokeRestart
[10:21:19.436]             length <- base::length
[10:21:19.436]             list <- base::list
[10:21:19.436]             seq.int <- base::seq.int
[10:21:19.436]             signalCondition <- base::signalCondition
[10:21:19.436]             sys.calls <- base::sys.calls
[10:21:19.436]             `[[` <- base::`[[`
[10:21:19.436]             `+` <- base::`+`
[10:21:19.436]             `<<-` <- base::`<<-`
[10:21:19.436]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.436]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.436]                   3L)]
[10:21:19.436]             }
[10:21:19.436]             function(cond) {
[10:21:19.436]                 is_error <- inherits(cond, "error")
[10:21:19.436]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.436]                   NULL)
[10:21:19.436]                 if (is_error) {
[10:21:19.436]                   sessionInformation <- function() {
[10:21:19.436]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.436]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.436]                       search = base::search(), system = base::Sys.info())
[10:21:19.436]                   }
[10:21:19.436]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.436]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.436]                     cond$call), session = sessionInformation(), 
[10:21:19.436]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.436]                   signalCondition(cond)
[10:21:19.436]                 }
[10:21:19.436]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.436]                 "immediateCondition"))) {
[10:21:19.436]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.436]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.436]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.436]                   if (TRUE && !signal) {
[10:21:19.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.436]                     {
[10:21:19.436]                       inherits <- base::inherits
[10:21:19.436]                       invokeRestart <- base::invokeRestart
[10:21:19.436]                       is.null <- base::is.null
[10:21:19.436]                       muffled <- FALSE
[10:21:19.436]                       if (inherits(cond, "message")) {
[10:21:19.436]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.436]                         if (muffled) 
[10:21:19.436]                           invokeRestart("muffleMessage")
[10:21:19.436]                       }
[10:21:19.436]                       else if (inherits(cond, "warning")) {
[10:21:19.436]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.436]                         if (muffled) 
[10:21:19.436]                           invokeRestart("muffleWarning")
[10:21:19.436]                       }
[10:21:19.436]                       else if (inherits(cond, "condition")) {
[10:21:19.436]                         if (!is.null(pattern)) {
[10:21:19.436]                           computeRestarts <- base::computeRestarts
[10:21:19.436]                           grepl <- base::grepl
[10:21:19.436]                           restarts <- computeRestarts(cond)
[10:21:19.436]                           for (restart in restarts) {
[10:21:19.436]                             name <- restart$name
[10:21:19.436]                             if (is.null(name)) 
[10:21:19.436]                               next
[10:21:19.436]                             if (!grepl(pattern, name)) 
[10:21:19.436]                               next
[10:21:19.436]                             invokeRestart(restart)
[10:21:19.436]                             muffled <- TRUE
[10:21:19.436]                             break
[10:21:19.436]                           }
[10:21:19.436]                         }
[10:21:19.436]                       }
[10:21:19.436]                       invisible(muffled)
[10:21:19.436]                     }
[10:21:19.436]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.436]                   }
[10:21:19.436]                 }
[10:21:19.436]                 else {
[10:21:19.436]                   if (TRUE) {
[10:21:19.436]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.436]                     {
[10:21:19.436]                       inherits <- base::inherits
[10:21:19.436]                       invokeRestart <- base::invokeRestart
[10:21:19.436]                       is.null <- base::is.null
[10:21:19.436]                       muffled <- FALSE
[10:21:19.436]                       if (inherits(cond, "message")) {
[10:21:19.436]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.436]                         if (muffled) 
[10:21:19.436]                           invokeRestart("muffleMessage")
[10:21:19.436]                       }
[10:21:19.436]                       else if (inherits(cond, "warning")) {
[10:21:19.436]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.436]                         if (muffled) 
[10:21:19.436]                           invokeRestart("muffleWarning")
[10:21:19.436]                       }
[10:21:19.436]                       else if (inherits(cond, "condition")) {
[10:21:19.436]                         if (!is.null(pattern)) {
[10:21:19.436]                           computeRestarts <- base::computeRestarts
[10:21:19.436]                           grepl <- base::grepl
[10:21:19.436]                           restarts <- computeRestarts(cond)
[10:21:19.436]                           for (restart in restarts) {
[10:21:19.436]                             name <- restart$name
[10:21:19.436]                             if (is.null(name)) 
[10:21:19.436]                               next
[10:21:19.436]                             if (!grepl(pattern, name)) 
[10:21:19.436]                               next
[10:21:19.436]                             invokeRestart(restart)
[10:21:19.436]                             muffled <- TRUE
[10:21:19.436]                             break
[10:21:19.436]                           }
[10:21:19.436]                         }
[10:21:19.436]                       }
[10:21:19.436]                       invisible(muffled)
[10:21:19.436]                     }
[10:21:19.436]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.436]                   }
[10:21:19.436]                 }
[10:21:19.436]             }
[10:21:19.436]         }))
[10:21:19.436]     }, error = function(ex) {
[10:21:19.436]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.436]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.436]                 ...future.rng), started = ...future.startTime, 
[10:21:19.436]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.436]             version = "1.8"), class = "FutureResult")
[10:21:19.436]     }, finally = {
[10:21:19.436]         if (!identical(...future.workdir, getwd())) 
[10:21:19.436]             setwd(...future.workdir)
[10:21:19.436]         {
[10:21:19.436]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.436]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.436]             }
[10:21:19.436]             base::options(...future.oldOptions)
[10:21:19.436]             if (.Platform$OS.type == "windows") {
[10:21:19.436]                 old_names <- names(...future.oldEnvVars)
[10:21:19.436]                 envs <- base::Sys.getenv()
[10:21:19.436]                 names <- names(envs)
[10:21:19.436]                 common <- intersect(names, old_names)
[10:21:19.436]                 added <- setdiff(names, old_names)
[10:21:19.436]                 removed <- setdiff(old_names, names)
[10:21:19.436]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.436]                   envs[common]]
[10:21:19.436]                 NAMES <- toupper(changed)
[10:21:19.436]                 args <- list()
[10:21:19.436]                 for (kk in seq_along(NAMES)) {
[10:21:19.436]                   name <- changed[[kk]]
[10:21:19.436]                   NAME <- NAMES[[kk]]
[10:21:19.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.436]                     next
[10:21:19.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.436]                 }
[10:21:19.436]                 NAMES <- toupper(added)
[10:21:19.436]                 for (kk in seq_along(NAMES)) {
[10:21:19.436]                   name <- added[[kk]]
[10:21:19.436]                   NAME <- NAMES[[kk]]
[10:21:19.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.436]                     next
[10:21:19.436]                   args[[name]] <- ""
[10:21:19.436]                 }
[10:21:19.436]                 NAMES <- toupper(removed)
[10:21:19.436]                 for (kk in seq_along(NAMES)) {
[10:21:19.436]                   name <- removed[[kk]]
[10:21:19.436]                   NAME <- NAMES[[kk]]
[10:21:19.436]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.436]                     next
[10:21:19.436]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.436]                 }
[10:21:19.436]                 if (length(args) > 0) 
[10:21:19.436]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.436]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.436]             }
[10:21:19.436]             else {
[10:21:19.436]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.436]             }
[10:21:19.436]             {
[10:21:19.436]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.436]                   0L) {
[10:21:19.436]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.436]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.436]                   base::options(opts)
[10:21:19.436]                 }
[10:21:19.436]                 {
[10:21:19.436]                   {
[10:21:19.436]                     NULL
[10:21:19.436]                     RNGkind("Mersenne-Twister")
[10:21:19.436]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.436]                       inherits = FALSE)
[10:21:19.436]                   }
[10:21:19.436]                   options(future.plan = NULL)
[10:21:19.436]                   if (is.na(NA_character_)) 
[10:21:19.436]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.436]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.436]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.436]                     .init = FALSE)
[10:21:19.436]                 }
[10:21:19.436]             }
[10:21:19.436]         }
[10:21:19.436]     })
[10:21:19.436]     if (TRUE) {
[10:21:19.436]         base::sink(type = "output", split = FALSE)
[10:21:19.436]         if (TRUE) {
[10:21:19.436]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.436]         }
[10:21:19.436]         else {
[10:21:19.436]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.436]         }
[10:21:19.436]         base::close(...future.stdout)
[10:21:19.436]         ...future.stdout <- NULL
[10:21:19.436]     }
[10:21:19.436]     ...future.result$conditions <- ...future.conditions
[10:21:19.436]     ...future.result$finished <- base::Sys.time()
[10:21:19.436]     ...future.result
[10:21:19.436] }
[10:21:19.437] plan(): Setting new future strategy stack:
[10:21:19.437] List of future strategies:
[10:21:19.437] 1. sequential:
[10:21:19.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.437]    - tweaked: FALSE
[10:21:19.437]    - call: NULL
[10:21:19.438] plan(): nbrOfWorkers() = 1
[10:21:19.438] plan(): Setting new future strategy stack:
[10:21:19.439] List of future strategies:
[10:21:19.439] 1. sequential:
[10:21:19.439]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.439]    - tweaked: FALSE
[10:21:19.439]    - call: plan(strategy)
[10:21:19.439] plan(): nbrOfWorkers() = 1
[10:21:19.439] SequentialFuture started (and completed)
[10:21:19.439] - Launch lazy future ... done
[10:21:19.439] run() for ‘SequentialFuture’ ... done
[10:21:19.439] getGlobalsAndPackages() ...
[10:21:19.440] Searching for globals...
[10:21:19.440] 
[10:21:19.440] Searching for globals ... DONE
[10:21:19.440] - globals: [0] <none>
[10:21:19.440] getGlobalsAndPackages() ... DONE
[10:21:19.440] run() for ‘Future’ ...
[10:21:19.440] - state: ‘created’
[10:21:19.440] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.441] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.441] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.441]   - Field: ‘label’
[10:21:19.441]   - Field: ‘local’
[10:21:19.441]   - Field: ‘owner’
[10:21:19.441]   - Field: ‘envir’
[10:21:19.441]   - Field: ‘packages’
[10:21:19.441]   - Field: ‘gc’
[10:21:19.441]   - Field: ‘conditions’
[10:21:19.441]   - Field: ‘expr’
[10:21:19.442]   - Field: ‘uuid’
[10:21:19.442]   - Field: ‘seed’
[10:21:19.442]   - Field: ‘version’
[10:21:19.442]   - Field: ‘result’
[10:21:19.442]   - Field: ‘asynchronous’
[10:21:19.442]   - Field: ‘calls’
[10:21:19.442]   - Field: ‘globals’
[10:21:19.442]   - Field: ‘stdout’
[10:21:19.442]   - Field: ‘earlySignal’
[10:21:19.442]   - Field: ‘lazy’
[10:21:19.442]   - Field: ‘state’
[10:21:19.442] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.442] - Launch lazy future ...
[10:21:19.443] Packages needed by the future expression (n = 0): <none>
[10:21:19.443] Packages needed by future strategies (n = 0): <none>
[10:21:19.444] {
[10:21:19.444]     {
[10:21:19.444]         {
[10:21:19.444]             ...future.startTime <- base::Sys.time()
[10:21:19.444]             {
[10:21:19.444]                 {
[10:21:19.444]                   {
[10:21:19.444]                     base::local({
[10:21:19.444]                       has_future <- base::requireNamespace("future", 
[10:21:19.444]                         quietly = TRUE)
[10:21:19.444]                       if (has_future) {
[10:21:19.444]                         ns <- base::getNamespace("future")
[10:21:19.444]                         version <- ns[[".package"]][["version"]]
[10:21:19.444]                         if (is.null(version)) 
[10:21:19.444]                           version <- utils::packageVersion("future")
[10:21:19.444]                       }
[10:21:19.444]                       else {
[10:21:19.444]                         version <- NULL
[10:21:19.444]                       }
[10:21:19.444]                       if (!has_future || version < "1.8.0") {
[10:21:19.444]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.444]                           "", base::R.version$version.string), 
[10:21:19.444]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.444]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.444]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.444]                             "release", "version")], collapse = " "), 
[10:21:19.444]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.444]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.444]                           info)
[10:21:19.444]                         info <- base::paste(info, collapse = "; ")
[10:21:19.444]                         if (!has_future) {
[10:21:19.444]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.444]                             info)
[10:21:19.444]                         }
[10:21:19.444]                         else {
[10:21:19.444]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.444]                             info, version)
[10:21:19.444]                         }
[10:21:19.444]                         base::stop(msg)
[10:21:19.444]                       }
[10:21:19.444]                     })
[10:21:19.444]                   }
[10:21:19.444]                   ...future.strategy.old <- future::plan("list")
[10:21:19.444]                   options(future.plan = NULL)
[10:21:19.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.444]                 }
[10:21:19.444]                 ...future.workdir <- getwd()
[10:21:19.444]             }
[10:21:19.444]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.444]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.444]         }
[10:21:19.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.444]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.444]             base::names(...future.oldOptions))
[10:21:19.444]     }
[10:21:19.444]     if (FALSE) {
[10:21:19.444]     }
[10:21:19.444]     else {
[10:21:19.444]         if (TRUE) {
[10:21:19.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.444]                 open = "w")
[10:21:19.444]         }
[10:21:19.444]         else {
[10:21:19.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.444]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.444]         }
[10:21:19.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.444]             base::sink(type = "output", split = FALSE)
[10:21:19.444]             base::close(...future.stdout)
[10:21:19.444]         }, add = TRUE)
[10:21:19.444]     }
[10:21:19.444]     ...future.frame <- base::sys.nframe()
[10:21:19.444]     ...future.conditions <- base::list()
[10:21:19.444]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.444]     if (FALSE) {
[10:21:19.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.444]     }
[10:21:19.444]     ...future.result <- base::tryCatch({
[10:21:19.444]         base::withCallingHandlers({
[10:21:19.444]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.444]             future::FutureResult(value = ...future.value$value, 
[10:21:19.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.444]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.444]                     ...future.globalenv.names))
[10:21:19.444]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.444]         }, condition = base::local({
[10:21:19.444]             c <- base::c
[10:21:19.444]             inherits <- base::inherits
[10:21:19.444]             invokeRestart <- base::invokeRestart
[10:21:19.444]             length <- base::length
[10:21:19.444]             list <- base::list
[10:21:19.444]             seq.int <- base::seq.int
[10:21:19.444]             signalCondition <- base::signalCondition
[10:21:19.444]             sys.calls <- base::sys.calls
[10:21:19.444]             `[[` <- base::`[[`
[10:21:19.444]             `+` <- base::`+`
[10:21:19.444]             `<<-` <- base::`<<-`
[10:21:19.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.444]                   3L)]
[10:21:19.444]             }
[10:21:19.444]             function(cond) {
[10:21:19.444]                 is_error <- inherits(cond, "error")
[10:21:19.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.444]                   NULL)
[10:21:19.444]                 if (is_error) {
[10:21:19.444]                   sessionInformation <- function() {
[10:21:19.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.444]                       search = base::search(), system = base::Sys.info())
[10:21:19.444]                   }
[10:21:19.444]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.444]                     cond$call), session = sessionInformation(), 
[10:21:19.444]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.444]                   signalCondition(cond)
[10:21:19.444]                 }
[10:21:19.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.444]                 "immediateCondition"))) {
[10:21:19.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.444]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.444]                   if (TRUE && !signal) {
[10:21:19.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.444]                     {
[10:21:19.444]                       inherits <- base::inherits
[10:21:19.444]                       invokeRestart <- base::invokeRestart
[10:21:19.444]                       is.null <- base::is.null
[10:21:19.444]                       muffled <- FALSE
[10:21:19.444]                       if (inherits(cond, "message")) {
[10:21:19.444]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.444]                         if (muffled) 
[10:21:19.444]                           invokeRestart("muffleMessage")
[10:21:19.444]                       }
[10:21:19.444]                       else if (inherits(cond, "warning")) {
[10:21:19.444]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.444]                         if (muffled) 
[10:21:19.444]                           invokeRestart("muffleWarning")
[10:21:19.444]                       }
[10:21:19.444]                       else if (inherits(cond, "condition")) {
[10:21:19.444]                         if (!is.null(pattern)) {
[10:21:19.444]                           computeRestarts <- base::computeRestarts
[10:21:19.444]                           grepl <- base::grepl
[10:21:19.444]                           restarts <- computeRestarts(cond)
[10:21:19.444]                           for (restart in restarts) {
[10:21:19.444]                             name <- restart$name
[10:21:19.444]                             if (is.null(name)) 
[10:21:19.444]                               next
[10:21:19.444]                             if (!grepl(pattern, name)) 
[10:21:19.444]                               next
[10:21:19.444]                             invokeRestart(restart)
[10:21:19.444]                             muffled <- TRUE
[10:21:19.444]                             break
[10:21:19.444]                           }
[10:21:19.444]                         }
[10:21:19.444]                       }
[10:21:19.444]                       invisible(muffled)
[10:21:19.444]                     }
[10:21:19.444]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.444]                   }
[10:21:19.444]                 }
[10:21:19.444]                 else {
[10:21:19.444]                   if (TRUE) {
[10:21:19.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.444]                     {
[10:21:19.444]                       inherits <- base::inherits
[10:21:19.444]                       invokeRestart <- base::invokeRestart
[10:21:19.444]                       is.null <- base::is.null
[10:21:19.444]                       muffled <- FALSE
[10:21:19.444]                       if (inherits(cond, "message")) {
[10:21:19.444]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.444]                         if (muffled) 
[10:21:19.444]                           invokeRestart("muffleMessage")
[10:21:19.444]                       }
[10:21:19.444]                       else if (inherits(cond, "warning")) {
[10:21:19.444]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.444]                         if (muffled) 
[10:21:19.444]                           invokeRestart("muffleWarning")
[10:21:19.444]                       }
[10:21:19.444]                       else if (inherits(cond, "condition")) {
[10:21:19.444]                         if (!is.null(pattern)) {
[10:21:19.444]                           computeRestarts <- base::computeRestarts
[10:21:19.444]                           grepl <- base::grepl
[10:21:19.444]                           restarts <- computeRestarts(cond)
[10:21:19.444]                           for (restart in restarts) {
[10:21:19.444]                             name <- restart$name
[10:21:19.444]                             if (is.null(name)) 
[10:21:19.444]                               next
[10:21:19.444]                             if (!grepl(pattern, name)) 
[10:21:19.444]                               next
[10:21:19.444]                             invokeRestart(restart)
[10:21:19.444]                             muffled <- TRUE
[10:21:19.444]                             break
[10:21:19.444]                           }
[10:21:19.444]                         }
[10:21:19.444]                       }
[10:21:19.444]                       invisible(muffled)
[10:21:19.444]                     }
[10:21:19.444]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.444]                   }
[10:21:19.444]                 }
[10:21:19.444]             }
[10:21:19.444]         }))
[10:21:19.444]     }, error = function(ex) {
[10:21:19.444]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.444]                 ...future.rng), started = ...future.startTime, 
[10:21:19.444]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.444]             version = "1.8"), class = "FutureResult")
[10:21:19.444]     }, finally = {
[10:21:19.444]         if (!identical(...future.workdir, getwd())) 
[10:21:19.444]             setwd(...future.workdir)
[10:21:19.444]         {
[10:21:19.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.444]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.444]             }
[10:21:19.444]             base::options(...future.oldOptions)
[10:21:19.444]             if (.Platform$OS.type == "windows") {
[10:21:19.444]                 old_names <- names(...future.oldEnvVars)
[10:21:19.444]                 envs <- base::Sys.getenv()
[10:21:19.444]                 names <- names(envs)
[10:21:19.444]                 common <- intersect(names, old_names)
[10:21:19.444]                 added <- setdiff(names, old_names)
[10:21:19.444]                 removed <- setdiff(old_names, names)
[10:21:19.444]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.444]                   envs[common]]
[10:21:19.444]                 NAMES <- toupper(changed)
[10:21:19.444]                 args <- list()
[10:21:19.444]                 for (kk in seq_along(NAMES)) {
[10:21:19.444]                   name <- changed[[kk]]
[10:21:19.444]                   NAME <- NAMES[[kk]]
[10:21:19.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.444]                     next
[10:21:19.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.444]                 }
[10:21:19.444]                 NAMES <- toupper(added)
[10:21:19.444]                 for (kk in seq_along(NAMES)) {
[10:21:19.444]                   name <- added[[kk]]
[10:21:19.444]                   NAME <- NAMES[[kk]]
[10:21:19.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.444]                     next
[10:21:19.444]                   args[[name]] <- ""
[10:21:19.444]                 }
[10:21:19.444]                 NAMES <- toupper(removed)
[10:21:19.444]                 for (kk in seq_along(NAMES)) {
[10:21:19.444]                   name <- removed[[kk]]
[10:21:19.444]                   NAME <- NAMES[[kk]]
[10:21:19.444]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.444]                     next
[10:21:19.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.444]                 }
[10:21:19.444]                 if (length(args) > 0) 
[10:21:19.444]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.444]             }
[10:21:19.444]             else {
[10:21:19.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.444]             }
[10:21:19.444]             {
[10:21:19.444]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.444]                   0L) {
[10:21:19.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.444]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.444]                   base::options(opts)
[10:21:19.444]                 }
[10:21:19.444]                 {
[10:21:19.444]                   {
[10:21:19.444]                     NULL
[10:21:19.444]                     RNGkind("Mersenne-Twister")
[10:21:19.444]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.444]                       inherits = FALSE)
[10:21:19.444]                   }
[10:21:19.444]                   options(future.plan = NULL)
[10:21:19.444]                   if (is.na(NA_character_)) 
[10:21:19.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.444]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.444]                     .init = FALSE)
[10:21:19.444]                 }
[10:21:19.444]             }
[10:21:19.444]         }
[10:21:19.444]     })
[10:21:19.444]     if (TRUE) {
[10:21:19.444]         base::sink(type = "output", split = FALSE)
[10:21:19.444]         if (TRUE) {
[10:21:19.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.444]         }
[10:21:19.444]         else {
[10:21:19.444]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.444]         }
[10:21:19.444]         base::close(...future.stdout)
[10:21:19.444]         ...future.stdout <- NULL
[10:21:19.444]     }
[10:21:19.444]     ...future.result$conditions <- ...future.conditions
[10:21:19.444]     ...future.result$finished <- base::Sys.time()
[10:21:19.444]     ...future.result
[10:21:19.444] }
[10:21:19.446] plan(): Setting new future strategy stack:
[10:21:19.446] List of future strategies:
[10:21:19.446] 1. sequential:
[10:21:19.446]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.446]    - tweaked: FALSE
[10:21:19.446]    - call: NULL
[10:21:19.447] plan(): nbrOfWorkers() = 1
[10:21:19.447] plan(): Setting new future strategy stack:
[10:21:19.447] List of future strategies:
[10:21:19.447] 1. sequential:
[10:21:19.447]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.447]    - tweaked: FALSE
[10:21:19.447]    - call: plan(strategy)
[10:21:19.448] plan(): nbrOfWorkers() = 1
[10:21:19.448] SequentialFuture started (and completed)
[10:21:19.448] - Launch lazy future ... done
[10:21:19.448] run() for ‘SequentialFuture’ ... done
[10:21:19.448] getGlobalsAndPackages() ...
[10:21:19.448] Searching for globals...
[10:21:19.449] - globals found: [1] ‘{’
[10:21:19.449] Searching for globals ... DONE
[10:21:19.449] Resolving globals: FALSE
[10:21:19.449] 
[10:21:19.450] 
[10:21:19.450] getGlobalsAndPackages() ... DONE
[10:21:19.450] run() for ‘Future’ ...
[10:21:19.450] - state: ‘created’
[10:21:19.450] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.450] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.450] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.450]   - Field: ‘label’
[10:21:19.451]   - Field: ‘local’
[10:21:19.451]   - Field: ‘owner’
[10:21:19.451]   - Field: ‘envir’
[10:21:19.451]   - Field: ‘packages’
[10:21:19.451]   - Field: ‘gc’
[10:21:19.451]   - Field: ‘conditions’
[10:21:19.451]   - Field: ‘expr’
[10:21:19.451]   - Field: ‘uuid’
[10:21:19.451]   - Field: ‘seed’
[10:21:19.451]   - Field: ‘version’
[10:21:19.451]   - Field: ‘result’
[10:21:19.451]   - Field: ‘asynchronous’
[10:21:19.452]   - Field: ‘calls’
[10:21:19.452]   - Field: ‘globals’
[10:21:19.452]   - Field: ‘stdout’
[10:21:19.452]   - Field: ‘earlySignal’
[10:21:19.452]   - Field: ‘lazy’
[10:21:19.452]   - Field: ‘state’
[10:21:19.452] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.452] - Launch lazy future ...
[10:21:19.452] Packages needed by the future expression (n = 0): <none>
[10:21:19.452] Packages needed by future strategies (n = 0): <none>
[10:21:19.453] {
[10:21:19.453]     {
[10:21:19.453]         {
[10:21:19.453]             ...future.startTime <- base::Sys.time()
[10:21:19.453]             {
[10:21:19.453]                 {
[10:21:19.453]                   {
[10:21:19.453]                     base::local({
[10:21:19.453]                       has_future <- base::requireNamespace("future", 
[10:21:19.453]                         quietly = TRUE)
[10:21:19.453]                       if (has_future) {
[10:21:19.453]                         ns <- base::getNamespace("future")
[10:21:19.453]                         version <- ns[[".package"]][["version"]]
[10:21:19.453]                         if (is.null(version)) 
[10:21:19.453]                           version <- utils::packageVersion("future")
[10:21:19.453]                       }
[10:21:19.453]                       else {
[10:21:19.453]                         version <- NULL
[10:21:19.453]                       }
[10:21:19.453]                       if (!has_future || version < "1.8.0") {
[10:21:19.453]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.453]                           "", base::R.version$version.string), 
[10:21:19.453]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.453]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.453]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.453]                             "release", "version")], collapse = " "), 
[10:21:19.453]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.453]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.453]                           info)
[10:21:19.453]                         info <- base::paste(info, collapse = "; ")
[10:21:19.453]                         if (!has_future) {
[10:21:19.453]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.453]                             info)
[10:21:19.453]                         }
[10:21:19.453]                         else {
[10:21:19.453]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.453]                             info, version)
[10:21:19.453]                         }
[10:21:19.453]                         base::stop(msg)
[10:21:19.453]                       }
[10:21:19.453]                     })
[10:21:19.453]                   }
[10:21:19.453]                   ...future.strategy.old <- future::plan("list")
[10:21:19.453]                   options(future.plan = NULL)
[10:21:19.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.453]                 }
[10:21:19.453]                 ...future.workdir <- getwd()
[10:21:19.453]             }
[10:21:19.453]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.453]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.453]         }
[10:21:19.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.453]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.453]             base::names(...future.oldOptions))
[10:21:19.453]     }
[10:21:19.453]     if (FALSE) {
[10:21:19.453]     }
[10:21:19.453]     else {
[10:21:19.453]         if (TRUE) {
[10:21:19.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.453]                 open = "w")
[10:21:19.453]         }
[10:21:19.453]         else {
[10:21:19.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.453]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.453]         }
[10:21:19.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.453]             base::sink(type = "output", split = FALSE)
[10:21:19.453]             base::close(...future.stdout)
[10:21:19.453]         }, add = TRUE)
[10:21:19.453]     }
[10:21:19.453]     ...future.frame <- base::sys.nframe()
[10:21:19.453]     ...future.conditions <- base::list()
[10:21:19.453]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.453]     if (FALSE) {
[10:21:19.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.453]     }
[10:21:19.453]     ...future.result <- base::tryCatch({
[10:21:19.453]         base::withCallingHandlers({
[10:21:19.453]             ...future.value <- base::withVisible(base::local({
[10:21:19.453]                 4
[10:21:19.453]             }))
[10:21:19.453]             future::FutureResult(value = ...future.value$value, 
[10:21:19.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.453]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.453]                     ...future.globalenv.names))
[10:21:19.453]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.453]         }, condition = base::local({
[10:21:19.453]             c <- base::c
[10:21:19.453]             inherits <- base::inherits
[10:21:19.453]             invokeRestart <- base::invokeRestart
[10:21:19.453]             length <- base::length
[10:21:19.453]             list <- base::list
[10:21:19.453]             seq.int <- base::seq.int
[10:21:19.453]             signalCondition <- base::signalCondition
[10:21:19.453]             sys.calls <- base::sys.calls
[10:21:19.453]             `[[` <- base::`[[`
[10:21:19.453]             `+` <- base::`+`
[10:21:19.453]             `<<-` <- base::`<<-`
[10:21:19.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.453]                   3L)]
[10:21:19.453]             }
[10:21:19.453]             function(cond) {
[10:21:19.453]                 is_error <- inherits(cond, "error")
[10:21:19.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.453]                   NULL)
[10:21:19.453]                 if (is_error) {
[10:21:19.453]                   sessionInformation <- function() {
[10:21:19.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.453]                       search = base::search(), system = base::Sys.info())
[10:21:19.453]                   }
[10:21:19.453]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.453]                     cond$call), session = sessionInformation(), 
[10:21:19.453]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.453]                   signalCondition(cond)
[10:21:19.453]                 }
[10:21:19.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.453]                 "immediateCondition"))) {
[10:21:19.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.453]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.453]                   if (TRUE && !signal) {
[10:21:19.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.453]                     {
[10:21:19.453]                       inherits <- base::inherits
[10:21:19.453]                       invokeRestart <- base::invokeRestart
[10:21:19.453]                       is.null <- base::is.null
[10:21:19.453]                       muffled <- FALSE
[10:21:19.453]                       if (inherits(cond, "message")) {
[10:21:19.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.453]                         if (muffled) 
[10:21:19.453]                           invokeRestart("muffleMessage")
[10:21:19.453]                       }
[10:21:19.453]                       else if (inherits(cond, "warning")) {
[10:21:19.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.453]                         if (muffled) 
[10:21:19.453]                           invokeRestart("muffleWarning")
[10:21:19.453]                       }
[10:21:19.453]                       else if (inherits(cond, "condition")) {
[10:21:19.453]                         if (!is.null(pattern)) {
[10:21:19.453]                           computeRestarts <- base::computeRestarts
[10:21:19.453]                           grepl <- base::grepl
[10:21:19.453]                           restarts <- computeRestarts(cond)
[10:21:19.453]                           for (restart in restarts) {
[10:21:19.453]                             name <- restart$name
[10:21:19.453]                             if (is.null(name)) 
[10:21:19.453]                               next
[10:21:19.453]                             if (!grepl(pattern, name)) 
[10:21:19.453]                               next
[10:21:19.453]                             invokeRestart(restart)
[10:21:19.453]                             muffled <- TRUE
[10:21:19.453]                             break
[10:21:19.453]                           }
[10:21:19.453]                         }
[10:21:19.453]                       }
[10:21:19.453]                       invisible(muffled)
[10:21:19.453]                     }
[10:21:19.453]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.453]                   }
[10:21:19.453]                 }
[10:21:19.453]                 else {
[10:21:19.453]                   if (TRUE) {
[10:21:19.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.453]                     {
[10:21:19.453]                       inherits <- base::inherits
[10:21:19.453]                       invokeRestart <- base::invokeRestart
[10:21:19.453]                       is.null <- base::is.null
[10:21:19.453]                       muffled <- FALSE
[10:21:19.453]                       if (inherits(cond, "message")) {
[10:21:19.453]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.453]                         if (muffled) 
[10:21:19.453]                           invokeRestart("muffleMessage")
[10:21:19.453]                       }
[10:21:19.453]                       else if (inherits(cond, "warning")) {
[10:21:19.453]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.453]                         if (muffled) 
[10:21:19.453]                           invokeRestart("muffleWarning")
[10:21:19.453]                       }
[10:21:19.453]                       else if (inherits(cond, "condition")) {
[10:21:19.453]                         if (!is.null(pattern)) {
[10:21:19.453]                           computeRestarts <- base::computeRestarts
[10:21:19.453]                           grepl <- base::grepl
[10:21:19.453]                           restarts <- computeRestarts(cond)
[10:21:19.453]                           for (restart in restarts) {
[10:21:19.453]                             name <- restart$name
[10:21:19.453]                             if (is.null(name)) 
[10:21:19.453]                               next
[10:21:19.453]                             if (!grepl(pattern, name)) 
[10:21:19.453]                               next
[10:21:19.453]                             invokeRestart(restart)
[10:21:19.453]                             muffled <- TRUE
[10:21:19.453]                             break
[10:21:19.453]                           }
[10:21:19.453]                         }
[10:21:19.453]                       }
[10:21:19.453]                       invisible(muffled)
[10:21:19.453]                     }
[10:21:19.453]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.453]                   }
[10:21:19.453]                 }
[10:21:19.453]             }
[10:21:19.453]         }))
[10:21:19.453]     }, error = function(ex) {
[10:21:19.453]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.453]                 ...future.rng), started = ...future.startTime, 
[10:21:19.453]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.453]             version = "1.8"), class = "FutureResult")
[10:21:19.453]     }, finally = {
[10:21:19.453]         if (!identical(...future.workdir, getwd())) 
[10:21:19.453]             setwd(...future.workdir)
[10:21:19.453]         {
[10:21:19.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.453]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.453]             }
[10:21:19.453]             base::options(...future.oldOptions)
[10:21:19.453]             if (.Platform$OS.type == "windows") {
[10:21:19.453]                 old_names <- names(...future.oldEnvVars)
[10:21:19.453]                 envs <- base::Sys.getenv()
[10:21:19.453]                 names <- names(envs)
[10:21:19.453]                 common <- intersect(names, old_names)
[10:21:19.453]                 added <- setdiff(names, old_names)
[10:21:19.453]                 removed <- setdiff(old_names, names)
[10:21:19.453]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.453]                   envs[common]]
[10:21:19.453]                 NAMES <- toupper(changed)
[10:21:19.453]                 args <- list()
[10:21:19.453]                 for (kk in seq_along(NAMES)) {
[10:21:19.453]                   name <- changed[[kk]]
[10:21:19.453]                   NAME <- NAMES[[kk]]
[10:21:19.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.453]                     next
[10:21:19.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.453]                 }
[10:21:19.453]                 NAMES <- toupper(added)
[10:21:19.453]                 for (kk in seq_along(NAMES)) {
[10:21:19.453]                   name <- added[[kk]]
[10:21:19.453]                   NAME <- NAMES[[kk]]
[10:21:19.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.453]                     next
[10:21:19.453]                   args[[name]] <- ""
[10:21:19.453]                 }
[10:21:19.453]                 NAMES <- toupper(removed)
[10:21:19.453]                 for (kk in seq_along(NAMES)) {
[10:21:19.453]                   name <- removed[[kk]]
[10:21:19.453]                   NAME <- NAMES[[kk]]
[10:21:19.453]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.453]                     next
[10:21:19.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.453]                 }
[10:21:19.453]                 if (length(args) > 0) 
[10:21:19.453]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.453]             }
[10:21:19.453]             else {
[10:21:19.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.453]             }
[10:21:19.453]             {
[10:21:19.453]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.453]                   0L) {
[10:21:19.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.453]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.453]                   base::options(opts)
[10:21:19.453]                 }
[10:21:19.453]                 {
[10:21:19.453]                   {
[10:21:19.453]                     NULL
[10:21:19.453]                     RNGkind("Mersenne-Twister")
[10:21:19.453]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.453]                       inherits = FALSE)
[10:21:19.453]                   }
[10:21:19.453]                   options(future.plan = NULL)
[10:21:19.453]                   if (is.na(NA_character_)) 
[10:21:19.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.453]                     .init = FALSE)
[10:21:19.453]                 }
[10:21:19.453]             }
[10:21:19.453]         }
[10:21:19.453]     })
[10:21:19.453]     if (TRUE) {
[10:21:19.453]         base::sink(type = "output", split = FALSE)
[10:21:19.453]         if (TRUE) {
[10:21:19.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.453]         }
[10:21:19.453]         else {
[10:21:19.453]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.453]         }
[10:21:19.453]         base::close(...future.stdout)
[10:21:19.453]         ...future.stdout <- NULL
[10:21:19.453]     }
[10:21:19.453]     ...future.result$conditions <- ...future.conditions
[10:21:19.453]     ...future.result$finished <- base::Sys.time()
[10:21:19.453]     ...future.result
[10:21:19.453] }
[10:21:19.454] plan(): Setting new future strategy stack:
[10:21:19.455] List of future strategies:
[10:21:19.455] 1. sequential:
[10:21:19.455]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.455]    - tweaked: FALSE
[10:21:19.455]    - call: NULL
[10:21:19.455] plan(): nbrOfWorkers() = 1
[10:21:19.456] plan(): Setting new future strategy stack:
[10:21:19.456] List of future strategies:
[10:21:19.456] 1. sequential:
[10:21:19.456]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.456]    - tweaked: FALSE
[10:21:19.456]    - call: plan(strategy)
[10:21:19.456] plan(): nbrOfWorkers() = 1
[10:21:19.456] SequentialFuture started (and completed)
[10:21:19.456] - Launch lazy future ... done
[10:21:19.456] run() for ‘SequentialFuture’ ... done
<environment: 0x55e8e4e1dd28> 
<environment: 0x55e8e4b6eb10> 
[10:21:19.458] resolved() for ‘SequentialFuture’ ...
[10:21:19.458] - state: ‘finished’
[10:21:19.458] - run: TRUE
[10:21:19.458] - result: ‘FutureResult’
[10:21:19.458] resolved() for ‘SequentialFuture’ ... done
[10:21:19.458] resolved() for ‘SequentialFuture’ ...
[10:21:19.458] - state: ‘finished’
[10:21:19.458] - run: TRUE
[10:21:19.458] - result: ‘FutureResult’
[10:21:19.458] resolved() for ‘SequentialFuture’ ... done
[10:21:19.458] resolved() for ‘SequentialFuture’ ...
[10:21:19.458] - state: ‘finished’
[10:21:19.459] - run: TRUE
[10:21:19.459] - result: ‘FutureResult’
[10:21:19.459] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:19.460] resolve() on environment ...
[10:21:19.460]  recursive: 0
[10:21:19.460]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:19.460] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.460] - nx: 4
[10:21:19.461] - relay: TRUE
[10:21:19.461] - stdout: TRUE
[10:21:19.461] - signal: TRUE
[10:21:19.461] - resignal: FALSE
[10:21:19.461] - force: TRUE
[10:21:19.461] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.461] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.461]  - until=2
[10:21:19.461]  - relaying element #2
[10:21:19.461] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.461] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.461] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.461]  length: 3 (resolved future 1)
[10:21:19.462] resolved() for ‘SequentialFuture’ ...
[10:21:19.462] - state: ‘finished’
[10:21:19.462] - run: TRUE
[10:21:19.462] - result: ‘FutureResult’
[10:21:19.462] resolved() for ‘SequentialFuture’ ... done
[10:21:19.462] Future #2
[10:21:19.462] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.462] - nx: 4
[10:21:19.462] - relay: TRUE
[10:21:19.462] - stdout: TRUE
[10:21:19.462] - signal: TRUE
[10:21:19.462] - resignal: FALSE
[10:21:19.463] - force: TRUE
[10:21:19.463] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.463] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.463]  - until=2
[10:21:19.463]  - relaying element #2
[10:21:19.463] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.463] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.463] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.463]  length: 2 (resolved future 2)
[10:21:19.463] resolved() for ‘SequentialFuture’ ...
[10:21:19.463] - state: ‘finished’
[10:21:19.464] - run: TRUE
[10:21:19.464] - result: ‘FutureResult’
[10:21:19.464] resolved() for ‘SequentialFuture’ ... done
[10:21:19.464] Future #3
[10:21:19.464] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.464] - nx: 4
[10:21:19.464] - relay: TRUE
[10:21:19.464] - stdout: TRUE
[10:21:19.464] - signal: TRUE
[10:21:19.464] - resignal: FALSE
[10:21:19.464] - force: TRUE
[10:21:19.464] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.464] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.465]  - until=3
[10:21:19.465]  - relaying element #3
[10:21:19.465] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.465] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.465] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.465]  length: 1 (resolved future 3)
[10:21:19.465] resolved() for ‘SequentialFuture’ ...
[10:21:19.465] - state: ‘finished’
[10:21:19.465] - run: TRUE
[10:21:19.465] - result: ‘FutureResult’
[10:21:19.465] resolved() for ‘SequentialFuture’ ... done
[10:21:19.466] Future #4
[10:21:19.466] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.466] - nx: 4
[10:21:19.466] - relay: TRUE
[10:21:19.466] - stdout: TRUE
[10:21:19.466] - signal: TRUE
[10:21:19.466] - resignal: FALSE
[10:21:19.466] - force: TRUE
[10:21:19.466] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.466] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.466]  - until=4
[10:21:19.466]  - relaying element #4
[10:21:19.467] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.467] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.467] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.467]  length: 0 (resolved future 4)
[10:21:19.467] Relaying remaining futures
[10:21:19.467] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.467] - nx: 4
[10:21:19.467] - relay: TRUE
[10:21:19.467] - stdout: TRUE
[10:21:19.467] - signal: TRUE
[10:21:19.467] - resignal: FALSE
[10:21:19.467] - force: TRUE
[10:21:19.467] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.468] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:19.468] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.468] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.468] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.468] resolve() on environment ... DONE
<environment: 0x55e8e4e5e4b8> 
Dimensions: c(2, 1, 3, 1)
[10:21:19.470] getGlobalsAndPackages() ...
[10:21:19.470] Searching for globals...
[10:21:19.470] 
[10:21:19.470] Searching for globals ... DONE
[10:21:19.470] - globals: [0] <none>
[10:21:19.470] getGlobalsAndPackages() ... DONE
[10:21:19.470] run() for ‘Future’ ...
[10:21:19.470] - state: ‘created’
[10:21:19.471] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.471] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.471] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.471]   - Field: ‘label’
[10:21:19.471]   - Field: ‘local’
[10:21:19.471]   - Field: ‘owner’
[10:21:19.471]   - Field: ‘envir’
[10:21:19.471]   - Field: ‘packages’
[10:21:19.471]   - Field: ‘gc’
[10:21:19.472]   - Field: ‘conditions’
[10:21:19.472]   - Field: ‘expr’
[10:21:19.472]   - Field: ‘uuid’
[10:21:19.472]   - Field: ‘seed’
[10:21:19.472]   - Field: ‘version’
[10:21:19.472]   - Field: ‘result’
[10:21:19.472]   - Field: ‘asynchronous’
[10:21:19.472]   - Field: ‘calls’
[10:21:19.472]   - Field: ‘globals’
[10:21:19.472]   - Field: ‘stdout’
[10:21:19.472]   - Field: ‘earlySignal’
[10:21:19.472]   - Field: ‘lazy’
[10:21:19.472]   - Field: ‘state’
[10:21:19.473] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.473] - Launch lazy future ...
[10:21:19.473] Packages needed by the future expression (n = 0): <none>
[10:21:19.473] Packages needed by future strategies (n = 0): <none>
[10:21:19.473] {
[10:21:19.473]     {
[10:21:19.473]         {
[10:21:19.473]             ...future.startTime <- base::Sys.time()
[10:21:19.473]             {
[10:21:19.473]                 {
[10:21:19.473]                   {
[10:21:19.473]                     base::local({
[10:21:19.473]                       has_future <- base::requireNamespace("future", 
[10:21:19.473]                         quietly = TRUE)
[10:21:19.473]                       if (has_future) {
[10:21:19.473]                         ns <- base::getNamespace("future")
[10:21:19.473]                         version <- ns[[".package"]][["version"]]
[10:21:19.473]                         if (is.null(version)) 
[10:21:19.473]                           version <- utils::packageVersion("future")
[10:21:19.473]                       }
[10:21:19.473]                       else {
[10:21:19.473]                         version <- NULL
[10:21:19.473]                       }
[10:21:19.473]                       if (!has_future || version < "1.8.0") {
[10:21:19.473]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.473]                           "", base::R.version$version.string), 
[10:21:19.473]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.473]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.473]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.473]                             "release", "version")], collapse = " "), 
[10:21:19.473]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.473]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.473]                           info)
[10:21:19.473]                         info <- base::paste(info, collapse = "; ")
[10:21:19.473]                         if (!has_future) {
[10:21:19.473]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.473]                             info)
[10:21:19.473]                         }
[10:21:19.473]                         else {
[10:21:19.473]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.473]                             info, version)
[10:21:19.473]                         }
[10:21:19.473]                         base::stop(msg)
[10:21:19.473]                       }
[10:21:19.473]                     })
[10:21:19.473]                   }
[10:21:19.473]                   ...future.strategy.old <- future::plan("list")
[10:21:19.473]                   options(future.plan = NULL)
[10:21:19.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.473]                 }
[10:21:19.473]                 ...future.workdir <- getwd()
[10:21:19.473]             }
[10:21:19.473]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.473]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.473]         }
[10:21:19.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.473]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.473]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.473]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.473]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.473]             base::names(...future.oldOptions))
[10:21:19.473]     }
[10:21:19.473]     if (FALSE) {
[10:21:19.473]     }
[10:21:19.473]     else {
[10:21:19.473]         if (TRUE) {
[10:21:19.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.473]                 open = "w")
[10:21:19.473]         }
[10:21:19.473]         else {
[10:21:19.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.473]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.473]         }
[10:21:19.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.473]             base::sink(type = "output", split = FALSE)
[10:21:19.473]             base::close(...future.stdout)
[10:21:19.473]         }, add = TRUE)
[10:21:19.473]     }
[10:21:19.473]     ...future.frame <- base::sys.nframe()
[10:21:19.473]     ...future.conditions <- base::list()
[10:21:19.473]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.473]     if (FALSE) {
[10:21:19.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.473]     }
[10:21:19.473]     ...future.result <- base::tryCatch({
[10:21:19.473]         base::withCallingHandlers({
[10:21:19.473]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.473]             future::FutureResult(value = ...future.value$value, 
[10:21:19.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.473]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.473]                     ...future.globalenv.names))
[10:21:19.473]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.473]         }, condition = base::local({
[10:21:19.473]             c <- base::c
[10:21:19.473]             inherits <- base::inherits
[10:21:19.473]             invokeRestart <- base::invokeRestart
[10:21:19.473]             length <- base::length
[10:21:19.473]             list <- base::list
[10:21:19.473]             seq.int <- base::seq.int
[10:21:19.473]             signalCondition <- base::signalCondition
[10:21:19.473]             sys.calls <- base::sys.calls
[10:21:19.473]             `[[` <- base::`[[`
[10:21:19.473]             `+` <- base::`+`
[10:21:19.473]             `<<-` <- base::`<<-`
[10:21:19.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.473]                   3L)]
[10:21:19.473]             }
[10:21:19.473]             function(cond) {
[10:21:19.473]                 is_error <- inherits(cond, "error")
[10:21:19.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.473]                   NULL)
[10:21:19.473]                 if (is_error) {
[10:21:19.473]                   sessionInformation <- function() {
[10:21:19.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.473]                       search = base::search(), system = base::Sys.info())
[10:21:19.473]                   }
[10:21:19.473]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.473]                     cond$call), session = sessionInformation(), 
[10:21:19.473]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.473]                   signalCondition(cond)
[10:21:19.473]                 }
[10:21:19.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.473]                 "immediateCondition"))) {
[10:21:19.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.473]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.473]                   if (TRUE && !signal) {
[10:21:19.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.473]                     {
[10:21:19.473]                       inherits <- base::inherits
[10:21:19.473]                       invokeRestart <- base::invokeRestart
[10:21:19.473]                       is.null <- base::is.null
[10:21:19.473]                       muffled <- FALSE
[10:21:19.473]                       if (inherits(cond, "message")) {
[10:21:19.473]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.473]                         if (muffled) 
[10:21:19.473]                           invokeRestart("muffleMessage")
[10:21:19.473]                       }
[10:21:19.473]                       else if (inherits(cond, "warning")) {
[10:21:19.473]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.473]                         if (muffled) 
[10:21:19.473]                           invokeRestart("muffleWarning")
[10:21:19.473]                       }
[10:21:19.473]                       else if (inherits(cond, "condition")) {
[10:21:19.473]                         if (!is.null(pattern)) {
[10:21:19.473]                           computeRestarts <- base::computeRestarts
[10:21:19.473]                           grepl <- base::grepl
[10:21:19.473]                           restarts <- computeRestarts(cond)
[10:21:19.473]                           for (restart in restarts) {
[10:21:19.473]                             name <- restart$name
[10:21:19.473]                             if (is.null(name)) 
[10:21:19.473]                               next
[10:21:19.473]                             if (!grepl(pattern, name)) 
[10:21:19.473]                               next
[10:21:19.473]                             invokeRestart(restart)
[10:21:19.473]                             muffled <- TRUE
[10:21:19.473]                             break
[10:21:19.473]                           }
[10:21:19.473]                         }
[10:21:19.473]                       }
[10:21:19.473]                       invisible(muffled)
[10:21:19.473]                     }
[10:21:19.473]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.473]                   }
[10:21:19.473]                 }
[10:21:19.473]                 else {
[10:21:19.473]                   if (TRUE) {
[10:21:19.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.473]                     {
[10:21:19.473]                       inherits <- base::inherits
[10:21:19.473]                       invokeRestart <- base::invokeRestart
[10:21:19.473]                       is.null <- base::is.null
[10:21:19.473]                       muffled <- FALSE
[10:21:19.473]                       if (inherits(cond, "message")) {
[10:21:19.473]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.473]                         if (muffled) 
[10:21:19.473]                           invokeRestart("muffleMessage")
[10:21:19.473]                       }
[10:21:19.473]                       else if (inherits(cond, "warning")) {
[10:21:19.473]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.473]                         if (muffled) 
[10:21:19.473]                           invokeRestart("muffleWarning")
[10:21:19.473]                       }
[10:21:19.473]                       else if (inherits(cond, "condition")) {
[10:21:19.473]                         if (!is.null(pattern)) {
[10:21:19.473]                           computeRestarts <- base::computeRestarts
[10:21:19.473]                           grepl <- base::grepl
[10:21:19.473]                           restarts <- computeRestarts(cond)
[10:21:19.473]                           for (restart in restarts) {
[10:21:19.473]                             name <- restart$name
[10:21:19.473]                             if (is.null(name)) 
[10:21:19.473]                               next
[10:21:19.473]                             if (!grepl(pattern, name)) 
[10:21:19.473]                               next
[10:21:19.473]                             invokeRestart(restart)
[10:21:19.473]                             muffled <- TRUE
[10:21:19.473]                             break
[10:21:19.473]                           }
[10:21:19.473]                         }
[10:21:19.473]                       }
[10:21:19.473]                       invisible(muffled)
[10:21:19.473]                     }
[10:21:19.473]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.473]                   }
[10:21:19.473]                 }
[10:21:19.473]             }
[10:21:19.473]         }))
[10:21:19.473]     }, error = function(ex) {
[10:21:19.473]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.473]                 ...future.rng), started = ...future.startTime, 
[10:21:19.473]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.473]             version = "1.8"), class = "FutureResult")
[10:21:19.473]     }, finally = {
[10:21:19.473]         if (!identical(...future.workdir, getwd())) 
[10:21:19.473]             setwd(...future.workdir)
[10:21:19.473]         {
[10:21:19.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.473]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.473]             }
[10:21:19.473]             base::options(...future.oldOptions)
[10:21:19.473]             if (.Platform$OS.type == "windows") {
[10:21:19.473]                 old_names <- names(...future.oldEnvVars)
[10:21:19.473]                 envs <- base::Sys.getenv()
[10:21:19.473]                 names <- names(envs)
[10:21:19.473]                 common <- intersect(names, old_names)
[10:21:19.473]                 added <- setdiff(names, old_names)
[10:21:19.473]                 removed <- setdiff(old_names, names)
[10:21:19.473]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.473]                   envs[common]]
[10:21:19.473]                 NAMES <- toupper(changed)
[10:21:19.473]                 args <- list()
[10:21:19.473]                 for (kk in seq_along(NAMES)) {
[10:21:19.473]                   name <- changed[[kk]]
[10:21:19.473]                   NAME <- NAMES[[kk]]
[10:21:19.473]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.473]                     next
[10:21:19.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.473]                 }
[10:21:19.473]                 NAMES <- toupper(added)
[10:21:19.473]                 for (kk in seq_along(NAMES)) {
[10:21:19.473]                   name <- added[[kk]]
[10:21:19.473]                   NAME <- NAMES[[kk]]
[10:21:19.473]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.473]                     next
[10:21:19.473]                   args[[name]] <- ""
[10:21:19.473]                 }
[10:21:19.473]                 NAMES <- toupper(removed)
[10:21:19.473]                 for (kk in seq_along(NAMES)) {
[10:21:19.473]                   name <- removed[[kk]]
[10:21:19.473]                   NAME <- NAMES[[kk]]
[10:21:19.473]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.473]                     next
[10:21:19.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.473]                 }
[10:21:19.473]                 if (length(args) > 0) 
[10:21:19.473]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.473]             }
[10:21:19.473]             else {
[10:21:19.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.473]             }
[10:21:19.473]             {
[10:21:19.473]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.473]                   0L) {
[10:21:19.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.473]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.473]                   base::options(opts)
[10:21:19.473]                 }
[10:21:19.473]                 {
[10:21:19.473]                   {
[10:21:19.473]                     NULL
[10:21:19.473]                     RNGkind("Mersenne-Twister")
[10:21:19.473]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.473]                       inherits = FALSE)
[10:21:19.473]                   }
[10:21:19.473]                   options(future.plan = NULL)
[10:21:19.473]                   if (is.na(NA_character_)) 
[10:21:19.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.473]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.473]                     .init = FALSE)
[10:21:19.473]                 }
[10:21:19.473]             }
[10:21:19.473]         }
[10:21:19.473]     })
[10:21:19.473]     if (TRUE) {
[10:21:19.473]         base::sink(type = "output", split = FALSE)
[10:21:19.473]         if (TRUE) {
[10:21:19.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.473]         }
[10:21:19.473]         else {
[10:21:19.473]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.473]         }
[10:21:19.473]         base::close(...future.stdout)
[10:21:19.473]         ...future.stdout <- NULL
[10:21:19.473]     }
[10:21:19.473]     ...future.result$conditions <- ...future.conditions
[10:21:19.473]     ...future.result$finished <- base::Sys.time()
[10:21:19.473]     ...future.result
[10:21:19.473] }
[10:21:19.475] plan(): Setting new future strategy stack:
[10:21:19.475] List of future strategies:
[10:21:19.475] 1. sequential:
[10:21:19.475]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.475]    - tweaked: FALSE
[10:21:19.475]    - call: NULL
[10:21:19.476] plan(): nbrOfWorkers() = 1
[10:21:19.476] plan(): Setting new future strategy stack:
[10:21:19.476] List of future strategies:
[10:21:19.476] 1. sequential:
[10:21:19.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.476]    - tweaked: FALSE
[10:21:19.476]    - call: plan(strategy)
[10:21:19.477] plan(): nbrOfWorkers() = 1
[10:21:19.477] SequentialFuture started (and completed)
[10:21:19.477] - Launch lazy future ... done
[10:21:19.477] run() for ‘SequentialFuture’ ... done
[10:21:19.477] getGlobalsAndPackages() ...
[10:21:19.477] Searching for globals...
[10:21:19.477] 
[10:21:19.478] Searching for globals ... DONE
[10:21:19.478] - globals: [0] <none>
[10:21:19.478] getGlobalsAndPackages() ... DONE
[10:21:19.478] run() for ‘Future’ ...
[10:21:19.478] - state: ‘created’
[10:21:19.478] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.478] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.479]   - Field: ‘label’
[10:21:19.479]   - Field: ‘local’
[10:21:19.479]   - Field: ‘owner’
[10:21:19.479]   - Field: ‘envir’
[10:21:19.479]   - Field: ‘packages’
[10:21:19.479]   - Field: ‘gc’
[10:21:19.479]   - Field: ‘conditions’
[10:21:19.479]   - Field: ‘expr’
[10:21:19.479]   - Field: ‘uuid’
[10:21:19.479]   - Field: ‘seed’
[10:21:19.479]   - Field: ‘version’
[10:21:19.479]   - Field: ‘result’
[10:21:19.479]   - Field: ‘asynchronous’
[10:21:19.480]   - Field: ‘calls’
[10:21:19.480]   - Field: ‘globals’
[10:21:19.480]   - Field: ‘stdout’
[10:21:19.480]   - Field: ‘earlySignal’
[10:21:19.480]   - Field: ‘lazy’
[10:21:19.480]   - Field: ‘state’
[10:21:19.480] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.480] - Launch lazy future ...
[10:21:19.480] Packages needed by the future expression (n = 0): <none>
[10:21:19.480] Packages needed by future strategies (n = 0): <none>
[10:21:19.481] {
[10:21:19.481]     {
[10:21:19.481]         {
[10:21:19.481]             ...future.startTime <- base::Sys.time()
[10:21:19.481]             {
[10:21:19.481]                 {
[10:21:19.481]                   {
[10:21:19.481]                     base::local({
[10:21:19.481]                       has_future <- base::requireNamespace("future", 
[10:21:19.481]                         quietly = TRUE)
[10:21:19.481]                       if (has_future) {
[10:21:19.481]                         ns <- base::getNamespace("future")
[10:21:19.481]                         version <- ns[[".package"]][["version"]]
[10:21:19.481]                         if (is.null(version)) 
[10:21:19.481]                           version <- utils::packageVersion("future")
[10:21:19.481]                       }
[10:21:19.481]                       else {
[10:21:19.481]                         version <- NULL
[10:21:19.481]                       }
[10:21:19.481]                       if (!has_future || version < "1.8.0") {
[10:21:19.481]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.481]                           "", base::R.version$version.string), 
[10:21:19.481]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.481]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.481]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.481]                             "release", "version")], collapse = " "), 
[10:21:19.481]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.481]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.481]                           info)
[10:21:19.481]                         info <- base::paste(info, collapse = "; ")
[10:21:19.481]                         if (!has_future) {
[10:21:19.481]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.481]                             info)
[10:21:19.481]                         }
[10:21:19.481]                         else {
[10:21:19.481]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.481]                             info, version)
[10:21:19.481]                         }
[10:21:19.481]                         base::stop(msg)
[10:21:19.481]                       }
[10:21:19.481]                     })
[10:21:19.481]                   }
[10:21:19.481]                   ...future.strategy.old <- future::plan("list")
[10:21:19.481]                   options(future.plan = NULL)
[10:21:19.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.481]                 }
[10:21:19.481]                 ...future.workdir <- getwd()
[10:21:19.481]             }
[10:21:19.481]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.481]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.481]         }
[10:21:19.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.481]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.481]             base::names(...future.oldOptions))
[10:21:19.481]     }
[10:21:19.481]     if (FALSE) {
[10:21:19.481]     }
[10:21:19.481]     else {
[10:21:19.481]         if (TRUE) {
[10:21:19.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.481]                 open = "w")
[10:21:19.481]         }
[10:21:19.481]         else {
[10:21:19.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.481]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.481]         }
[10:21:19.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.481]             base::sink(type = "output", split = FALSE)
[10:21:19.481]             base::close(...future.stdout)
[10:21:19.481]         }, add = TRUE)
[10:21:19.481]     }
[10:21:19.481]     ...future.frame <- base::sys.nframe()
[10:21:19.481]     ...future.conditions <- base::list()
[10:21:19.481]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.481]     if (FALSE) {
[10:21:19.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.481]     }
[10:21:19.481]     ...future.result <- base::tryCatch({
[10:21:19.481]         base::withCallingHandlers({
[10:21:19.481]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.481]             future::FutureResult(value = ...future.value$value, 
[10:21:19.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.481]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.481]                     ...future.globalenv.names))
[10:21:19.481]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.481]         }, condition = base::local({
[10:21:19.481]             c <- base::c
[10:21:19.481]             inherits <- base::inherits
[10:21:19.481]             invokeRestart <- base::invokeRestart
[10:21:19.481]             length <- base::length
[10:21:19.481]             list <- base::list
[10:21:19.481]             seq.int <- base::seq.int
[10:21:19.481]             signalCondition <- base::signalCondition
[10:21:19.481]             sys.calls <- base::sys.calls
[10:21:19.481]             `[[` <- base::`[[`
[10:21:19.481]             `+` <- base::`+`
[10:21:19.481]             `<<-` <- base::`<<-`
[10:21:19.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.481]                   3L)]
[10:21:19.481]             }
[10:21:19.481]             function(cond) {
[10:21:19.481]                 is_error <- inherits(cond, "error")
[10:21:19.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.481]                   NULL)
[10:21:19.481]                 if (is_error) {
[10:21:19.481]                   sessionInformation <- function() {
[10:21:19.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.481]                       search = base::search(), system = base::Sys.info())
[10:21:19.481]                   }
[10:21:19.481]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.481]                     cond$call), session = sessionInformation(), 
[10:21:19.481]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.481]                   signalCondition(cond)
[10:21:19.481]                 }
[10:21:19.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.481]                 "immediateCondition"))) {
[10:21:19.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.481]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.481]                   if (TRUE && !signal) {
[10:21:19.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.481]                     {
[10:21:19.481]                       inherits <- base::inherits
[10:21:19.481]                       invokeRestart <- base::invokeRestart
[10:21:19.481]                       is.null <- base::is.null
[10:21:19.481]                       muffled <- FALSE
[10:21:19.481]                       if (inherits(cond, "message")) {
[10:21:19.481]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.481]                         if (muffled) 
[10:21:19.481]                           invokeRestart("muffleMessage")
[10:21:19.481]                       }
[10:21:19.481]                       else if (inherits(cond, "warning")) {
[10:21:19.481]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.481]                         if (muffled) 
[10:21:19.481]                           invokeRestart("muffleWarning")
[10:21:19.481]                       }
[10:21:19.481]                       else if (inherits(cond, "condition")) {
[10:21:19.481]                         if (!is.null(pattern)) {
[10:21:19.481]                           computeRestarts <- base::computeRestarts
[10:21:19.481]                           grepl <- base::grepl
[10:21:19.481]                           restarts <- computeRestarts(cond)
[10:21:19.481]                           for (restart in restarts) {
[10:21:19.481]                             name <- restart$name
[10:21:19.481]                             if (is.null(name)) 
[10:21:19.481]                               next
[10:21:19.481]                             if (!grepl(pattern, name)) 
[10:21:19.481]                               next
[10:21:19.481]                             invokeRestart(restart)
[10:21:19.481]                             muffled <- TRUE
[10:21:19.481]                             break
[10:21:19.481]                           }
[10:21:19.481]                         }
[10:21:19.481]                       }
[10:21:19.481]                       invisible(muffled)
[10:21:19.481]                     }
[10:21:19.481]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.481]                   }
[10:21:19.481]                 }
[10:21:19.481]                 else {
[10:21:19.481]                   if (TRUE) {
[10:21:19.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.481]                     {
[10:21:19.481]                       inherits <- base::inherits
[10:21:19.481]                       invokeRestart <- base::invokeRestart
[10:21:19.481]                       is.null <- base::is.null
[10:21:19.481]                       muffled <- FALSE
[10:21:19.481]                       if (inherits(cond, "message")) {
[10:21:19.481]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.481]                         if (muffled) 
[10:21:19.481]                           invokeRestart("muffleMessage")
[10:21:19.481]                       }
[10:21:19.481]                       else if (inherits(cond, "warning")) {
[10:21:19.481]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.481]                         if (muffled) 
[10:21:19.481]                           invokeRestart("muffleWarning")
[10:21:19.481]                       }
[10:21:19.481]                       else if (inherits(cond, "condition")) {
[10:21:19.481]                         if (!is.null(pattern)) {
[10:21:19.481]                           computeRestarts <- base::computeRestarts
[10:21:19.481]                           grepl <- base::grepl
[10:21:19.481]                           restarts <- computeRestarts(cond)
[10:21:19.481]                           for (restart in restarts) {
[10:21:19.481]                             name <- restart$name
[10:21:19.481]                             if (is.null(name)) 
[10:21:19.481]                               next
[10:21:19.481]                             if (!grepl(pattern, name)) 
[10:21:19.481]                               next
[10:21:19.481]                             invokeRestart(restart)
[10:21:19.481]                             muffled <- TRUE
[10:21:19.481]                             break
[10:21:19.481]                           }
[10:21:19.481]                         }
[10:21:19.481]                       }
[10:21:19.481]                       invisible(muffled)
[10:21:19.481]                     }
[10:21:19.481]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.481]                   }
[10:21:19.481]                 }
[10:21:19.481]             }
[10:21:19.481]         }))
[10:21:19.481]     }, error = function(ex) {
[10:21:19.481]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.481]                 ...future.rng), started = ...future.startTime, 
[10:21:19.481]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.481]             version = "1.8"), class = "FutureResult")
[10:21:19.481]     }, finally = {
[10:21:19.481]         if (!identical(...future.workdir, getwd())) 
[10:21:19.481]             setwd(...future.workdir)
[10:21:19.481]         {
[10:21:19.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.481]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.481]             }
[10:21:19.481]             base::options(...future.oldOptions)
[10:21:19.481]             if (.Platform$OS.type == "windows") {
[10:21:19.481]                 old_names <- names(...future.oldEnvVars)
[10:21:19.481]                 envs <- base::Sys.getenv()
[10:21:19.481]                 names <- names(envs)
[10:21:19.481]                 common <- intersect(names, old_names)
[10:21:19.481]                 added <- setdiff(names, old_names)
[10:21:19.481]                 removed <- setdiff(old_names, names)
[10:21:19.481]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.481]                   envs[common]]
[10:21:19.481]                 NAMES <- toupper(changed)
[10:21:19.481]                 args <- list()
[10:21:19.481]                 for (kk in seq_along(NAMES)) {
[10:21:19.481]                   name <- changed[[kk]]
[10:21:19.481]                   NAME <- NAMES[[kk]]
[10:21:19.481]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.481]                     next
[10:21:19.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.481]                 }
[10:21:19.481]                 NAMES <- toupper(added)
[10:21:19.481]                 for (kk in seq_along(NAMES)) {
[10:21:19.481]                   name <- added[[kk]]
[10:21:19.481]                   NAME <- NAMES[[kk]]
[10:21:19.481]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.481]                     next
[10:21:19.481]                   args[[name]] <- ""
[10:21:19.481]                 }
[10:21:19.481]                 NAMES <- toupper(removed)
[10:21:19.481]                 for (kk in seq_along(NAMES)) {
[10:21:19.481]                   name <- removed[[kk]]
[10:21:19.481]                   NAME <- NAMES[[kk]]
[10:21:19.481]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.481]                     next
[10:21:19.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.481]                 }
[10:21:19.481]                 if (length(args) > 0) 
[10:21:19.481]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.481]             }
[10:21:19.481]             else {
[10:21:19.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.481]             }
[10:21:19.481]             {
[10:21:19.481]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.481]                   0L) {
[10:21:19.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.481]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.481]                   base::options(opts)
[10:21:19.481]                 }
[10:21:19.481]                 {
[10:21:19.481]                   {
[10:21:19.481]                     NULL
[10:21:19.481]                     RNGkind("Mersenne-Twister")
[10:21:19.481]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.481]                       inherits = FALSE)
[10:21:19.481]                   }
[10:21:19.481]                   options(future.plan = NULL)
[10:21:19.481]                   if (is.na(NA_character_)) 
[10:21:19.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.481]                     .init = FALSE)
[10:21:19.481]                 }
[10:21:19.481]             }
[10:21:19.481]         }
[10:21:19.481]     })
[10:21:19.481]     if (TRUE) {
[10:21:19.481]         base::sink(type = "output", split = FALSE)
[10:21:19.481]         if (TRUE) {
[10:21:19.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.481]         }
[10:21:19.481]         else {
[10:21:19.481]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.481]         }
[10:21:19.481]         base::close(...future.stdout)
[10:21:19.481]         ...future.stdout <- NULL
[10:21:19.481]     }
[10:21:19.481]     ...future.result$conditions <- ...future.conditions
[10:21:19.481]     ...future.result$finished <- base::Sys.time()
[10:21:19.481]     ...future.result
[10:21:19.481] }
[10:21:19.482] plan(): Setting new future strategy stack:
[10:21:19.483] List of future strategies:
[10:21:19.483] 1. sequential:
[10:21:19.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.483]    - tweaked: FALSE
[10:21:19.483]    - call: NULL
[10:21:19.483] plan(): nbrOfWorkers() = 1
[10:21:19.484] plan(): Setting new future strategy stack:
[10:21:19.484] List of future strategies:
[10:21:19.484] 1. sequential:
[10:21:19.484]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.484]    - tweaked: FALSE
[10:21:19.484]    - call: plan(strategy)
[10:21:19.484] plan(): nbrOfWorkers() = 1
[10:21:19.484] SequentialFuture started (and completed)
[10:21:19.484] - Launch lazy future ... done
[10:21:19.484] run() for ‘SequentialFuture’ ... done
[10:21:19.485] getGlobalsAndPackages() ...
[10:21:19.485] Searching for globals...
[10:21:19.485] - globals found: [1] ‘{’
[10:21:19.485] Searching for globals ... DONE
[10:21:19.485] Resolving globals: FALSE
[10:21:19.486] 
[10:21:19.486] 
[10:21:19.486] getGlobalsAndPackages() ... DONE
[10:21:19.486] run() for ‘Future’ ...
[10:21:19.486] - state: ‘created’
[10:21:19.486] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.487] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.487] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.487]   - Field: ‘label’
[10:21:19.487]   - Field: ‘local’
[10:21:19.487]   - Field: ‘owner’
[10:21:19.487]   - Field: ‘envir’
[10:21:19.487]   - Field: ‘packages’
[10:21:19.487]   - Field: ‘gc’
[10:21:19.487]   - Field: ‘conditions’
[10:21:19.487]   - Field: ‘expr’
[10:21:19.487]   - Field: ‘uuid’
[10:21:19.487]   - Field: ‘seed’
[10:21:19.488]   - Field: ‘version’
[10:21:19.488]   - Field: ‘result’
[10:21:19.488]   - Field: ‘asynchronous’
[10:21:19.488]   - Field: ‘calls’
[10:21:19.488]   - Field: ‘globals’
[10:21:19.488]   - Field: ‘stdout’
[10:21:19.488]   - Field: ‘earlySignal’
[10:21:19.488]   - Field: ‘lazy’
[10:21:19.488]   - Field: ‘state’
[10:21:19.488] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.488] - Launch lazy future ...
[10:21:19.488] Packages needed by the future expression (n = 0): <none>
[10:21:19.489] Packages needed by future strategies (n = 0): <none>
[10:21:19.489] {
[10:21:19.489]     {
[10:21:19.489]         {
[10:21:19.489]             ...future.startTime <- base::Sys.time()
[10:21:19.489]             {
[10:21:19.489]                 {
[10:21:19.489]                   {
[10:21:19.489]                     base::local({
[10:21:19.489]                       has_future <- base::requireNamespace("future", 
[10:21:19.489]                         quietly = TRUE)
[10:21:19.489]                       if (has_future) {
[10:21:19.489]                         ns <- base::getNamespace("future")
[10:21:19.489]                         version <- ns[[".package"]][["version"]]
[10:21:19.489]                         if (is.null(version)) 
[10:21:19.489]                           version <- utils::packageVersion("future")
[10:21:19.489]                       }
[10:21:19.489]                       else {
[10:21:19.489]                         version <- NULL
[10:21:19.489]                       }
[10:21:19.489]                       if (!has_future || version < "1.8.0") {
[10:21:19.489]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.489]                           "", base::R.version$version.string), 
[10:21:19.489]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.489]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.489]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.489]                             "release", "version")], collapse = " "), 
[10:21:19.489]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.489]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.489]                           info)
[10:21:19.489]                         info <- base::paste(info, collapse = "; ")
[10:21:19.489]                         if (!has_future) {
[10:21:19.489]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.489]                             info)
[10:21:19.489]                         }
[10:21:19.489]                         else {
[10:21:19.489]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.489]                             info, version)
[10:21:19.489]                         }
[10:21:19.489]                         base::stop(msg)
[10:21:19.489]                       }
[10:21:19.489]                     })
[10:21:19.489]                   }
[10:21:19.489]                   ...future.strategy.old <- future::plan("list")
[10:21:19.489]                   options(future.plan = NULL)
[10:21:19.489]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.489]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.489]                 }
[10:21:19.489]                 ...future.workdir <- getwd()
[10:21:19.489]             }
[10:21:19.489]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.489]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.489]         }
[10:21:19.489]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.489]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.489]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.489]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.489]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.489]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.489]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.489]             base::names(...future.oldOptions))
[10:21:19.489]     }
[10:21:19.489]     if (FALSE) {
[10:21:19.489]     }
[10:21:19.489]     else {
[10:21:19.489]         if (TRUE) {
[10:21:19.489]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.489]                 open = "w")
[10:21:19.489]         }
[10:21:19.489]         else {
[10:21:19.489]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.489]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.489]         }
[10:21:19.489]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.489]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.489]             base::sink(type = "output", split = FALSE)
[10:21:19.489]             base::close(...future.stdout)
[10:21:19.489]         }, add = TRUE)
[10:21:19.489]     }
[10:21:19.489]     ...future.frame <- base::sys.nframe()
[10:21:19.489]     ...future.conditions <- base::list()
[10:21:19.489]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.489]     if (FALSE) {
[10:21:19.489]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.489]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.489]     }
[10:21:19.489]     ...future.result <- base::tryCatch({
[10:21:19.489]         base::withCallingHandlers({
[10:21:19.489]             ...future.value <- base::withVisible(base::local({
[10:21:19.489]                 4
[10:21:19.489]             }))
[10:21:19.489]             future::FutureResult(value = ...future.value$value, 
[10:21:19.489]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.489]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.489]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.489]                     ...future.globalenv.names))
[10:21:19.489]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.489]         }, condition = base::local({
[10:21:19.489]             c <- base::c
[10:21:19.489]             inherits <- base::inherits
[10:21:19.489]             invokeRestart <- base::invokeRestart
[10:21:19.489]             length <- base::length
[10:21:19.489]             list <- base::list
[10:21:19.489]             seq.int <- base::seq.int
[10:21:19.489]             signalCondition <- base::signalCondition
[10:21:19.489]             sys.calls <- base::sys.calls
[10:21:19.489]             `[[` <- base::`[[`
[10:21:19.489]             `+` <- base::`+`
[10:21:19.489]             `<<-` <- base::`<<-`
[10:21:19.489]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.489]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.489]                   3L)]
[10:21:19.489]             }
[10:21:19.489]             function(cond) {
[10:21:19.489]                 is_error <- inherits(cond, "error")
[10:21:19.489]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.489]                   NULL)
[10:21:19.489]                 if (is_error) {
[10:21:19.489]                   sessionInformation <- function() {
[10:21:19.489]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.489]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.489]                       search = base::search(), system = base::Sys.info())
[10:21:19.489]                   }
[10:21:19.489]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.489]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.489]                     cond$call), session = sessionInformation(), 
[10:21:19.489]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.489]                   signalCondition(cond)
[10:21:19.489]                 }
[10:21:19.489]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.489]                 "immediateCondition"))) {
[10:21:19.489]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.489]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.489]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.489]                   if (TRUE && !signal) {
[10:21:19.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.489]                     {
[10:21:19.489]                       inherits <- base::inherits
[10:21:19.489]                       invokeRestart <- base::invokeRestart
[10:21:19.489]                       is.null <- base::is.null
[10:21:19.489]                       muffled <- FALSE
[10:21:19.489]                       if (inherits(cond, "message")) {
[10:21:19.489]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.489]                         if (muffled) 
[10:21:19.489]                           invokeRestart("muffleMessage")
[10:21:19.489]                       }
[10:21:19.489]                       else if (inherits(cond, "warning")) {
[10:21:19.489]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.489]                         if (muffled) 
[10:21:19.489]                           invokeRestart("muffleWarning")
[10:21:19.489]                       }
[10:21:19.489]                       else if (inherits(cond, "condition")) {
[10:21:19.489]                         if (!is.null(pattern)) {
[10:21:19.489]                           computeRestarts <- base::computeRestarts
[10:21:19.489]                           grepl <- base::grepl
[10:21:19.489]                           restarts <- computeRestarts(cond)
[10:21:19.489]                           for (restart in restarts) {
[10:21:19.489]                             name <- restart$name
[10:21:19.489]                             if (is.null(name)) 
[10:21:19.489]                               next
[10:21:19.489]                             if (!grepl(pattern, name)) 
[10:21:19.489]                               next
[10:21:19.489]                             invokeRestart(restart)
[10:21:19.489]                             muffled <- TRUE
[10:21:19.489]                             break
[10:21:19.489]                           }
[10:21:19.489]                         }
[10:21:19.489]                       }
[10:21:19.489]                       invisible(muffled)
[10:21:19.489]                     }
[10:21:19.489]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.489]                   }
[10:21:19.489]                 }
[10:21:19.489]                 else {
[10:21:19.489]                   if (TRUE) {
[10:21:19.489]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.489]                     {
[10:21:19.489]                       inherits <- base::inherits
[10:21:19.489]                       invokeRestart <- base::invokeRestart
[10:21:19.489]                       is.null <- base::is.null
[10:21:19.489]                       muffled <- FALSE
[10:21:19.489]                       if (inherits(cond, "message")) {
[10:21:19.489]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.489]                         if (muffled) 
[10:21:19.489]                           invokeRestart("muffleMessage")
[10:21:19.489]                       }
[10:21:19.489]                       else if (inherits(cond, "warning")) {
[10:21:19.489]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.489]                         if (muffled) 
[10:21:19.489]                           invokeRestart("muffleWarning")
[10:21:19.489]                       }
[10:21:19.489]                       else if (inherits(cond, "condition")) {
[10:21:19.489]                         if (!is.null(pattern)) {
[10:21:19.489]                           computeRestarts <- base::computeRestarts
[10:21:19.489]                           grepl <- base::grepl
[10:21:19.489]                           restarts <- computeRestarts(cond)
[10:21:19.489]                           for (restart in restarts) {
[10:21:19.489]                             name <- restart$name
[10:21:19.489]                             if (is.null(name)) 
[10:21:19.489]                               next
[10:21:19.489]                             if (!grepl(pattern, name)) 
[10:21:19.489]                               next
[10:21:19.489]                             invokeRestart(restart)
[10:21:19.489]                             muffled <- TRUE
[10:21:19.489]                             break
[10:21:19.489]                           }
[10:21:19.489]                         }
[10:21:19.489]                       }
[10:21:19.489]                       invisible(muffled)
[10:21:19.489]                     }
[10:21:19.489]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.489]                   }
[10:21:19.489]                 }
[10:21:19.489]             }
[10:21:19.489]         }))
[10:21:19.489]     }, error = function(ex) {
[10:21:19.489]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.489]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.489]                 ...future.rng), started = ...future.startTime, 
[10:21:19.489]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.489]             version = "1.8"), class = "FutureResult")
[10:21:19.489]     }, finally = {
[10:21:19.489]         if (!identical(...future.workdir, getwd())) 
[10:21:19.489]             setwd(...future.workdir)
[10:21:19.489]         {
[10:21:19.489]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.489]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.489]             }
[10:21:19.489]             base::options(...future.oldOptions)
[10:21:19.489]             if (.Platform$OS.type == "windows") {
[10:21:19.489]                 old_names <- names(...future.oldEnvVars)
[10:21:19.489]                 envs <- base::Sys.getenv()
[10:21:19.489]                 names <- names(envs)
[10:21:19.489]                 common <- intersect(names, old_names)
[10:21:19.489]                 added <- setdiff(names, old_names)
[10:21:19.489]                 removed <- setdiff(old_names, names)
[10:21:19.489]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.489]                   envs[common]]
[10:21:19.489]                 NAMES <- toupper(changed)
[10:21:19.489]                 args <- list()
[10:21:19.489]                 for (kk in seq_along(NAMES)) {
[10:21:19.489]                   name <- changed[[kk]]
[10:21:19.489]                   NAME <- NAMES[[kk]]
[10:21:19.489]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.489]                     next
[10:21:19.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.489]                 }
[10:21:19.489]                 NAMES <- toupper(added)
[10:21:19.489]                 for (kk in seq_along(NAMES)) {
[10:21:19.489]                   name <- added[[kk]]
[10:21:19.489]                   NAME <- NAMES[[kk]]
[10:21:19.489]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.489]                     next
[10:21:19.489]                   args[[name]] <- ""
[10:21:19.489]                 }
[10:21:19.489]                 NAMES <- toupper(removed)
[10:21:19.489]                 for (kk in seq_along(NAMES)) {
[10:21:19.489]                   name <- removed[[kk]]
[10:21:19.489]                   NAME <- NAMES[[kk]]
[10:21:19.489]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.489]                     next
[10:21:19.489]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.489]                 }
[10:21:19.489]                 if (length(args) > 0) 
[10:21:19.489]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.489]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.489]             }
[10:21:19.489]             else {
[10:21:19.489]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.489]             }
[10:21:19.489]             {
[10:21:19.489]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.489]                   0L) {
[10:21:19.489]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.489]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.489]                   base::options(opts)
[10:21:19.489]                 }
[10:21:19.489]                 {
[10:21:19.489]                   {
[10:21:19.489]                     NULL
[10:21:19.489]                     RNGkind("Mersenne-Twister")
[10:21:19.489]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.489]                       inherits = FALSE)
[10:21:19.489]                   }
[10:21:19.489]                   options(future.plan = NULL)
[10:21:19.489]                   if (is.na(NA_character_)) 
[10:21:19.489]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.489]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.489]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.489]                     .init = FALSE)
[10:21:19.489]                 }
[10:21:19.489]             }
[10:21:19.489]         }
[10:21:19.489]     })
[10:21:19.489]     if (TRUE) {
[10:21:19.489]         base::sink(type = "output", split = FALSE)
[10:21:19.489]         if (TRUE) {
[10:21:19.489]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.489]         }
[10:21:19.489]         else {
[10:21:19.489]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.489]         }
[10:21:19.489]         base::close(...future.stdout)
[10:21:19.489]         ...future.stdout <- NULL
[10:21:19.489]     }
[10:21:19.489]     ...future.result$conditions <- ...future.conditions
[10:21:19.489]     ...future.result$finished <- base::Sys.time()
[10:21:19.489]     ...future.result
[10:21:19.489] }
[10:21:19.491] plan(): Setting new future strategy stack:
[10:21:19.491] List of future strategies:
[10:21:19.491] 1. sequential:
[10:21:19.491]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.491]    - tweaked: FALSE
[10:21:19.491]    - call: NULL
[10:21:19.491] plan(): nbrOfWorkers() = 1
[10:21:19.492] plan(): Setting new future strategy stack:
[10:21:19.492] List of future strategies:
[10:21:19.492] 1. sequential:
[10:21:19.492]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.492]    - tweaked: FALSE
[10:21:19.492]    - call: plan(strategy)
[10:21:19.492] plan(): nbrOfWorkers() = 1
[10:21:19.493] SequentialFuture started (and completed)
[10:21:19.493] - Launch lazy future ... done
[10:21:19.493] run() for ‘SequentialFuture’ ... done
<environment: 0x55e8e44cf228> 
<environment: 0x55e8e5465ac8> 
[10:21:19.494] resolved() for ‘SequentialFuture’ ...
[10:21:19.494] - state: ‘finished’
[10:21:19.494] - run: TRUE
[10:21:19.494] - result: ‘FutureResult’
[10:21:19.494] resolved() for ‘SequentialFuture’ ... done
[10:21:19.494] resolved() for ‘SequentialFuture’ ...
[10:21:19.494] - state: ‘finished’
[10:21:19.495] - run: TRUE
[10:21:19.495] - result: ‘FutureResult’
[10:21:19.495] resolved() for ‘SequentialFuture’ ... done
[10:21:19.496] resolved() for ‘SequentialFuture’ ...
[10:21:19.496] - state: ‘finished’
[10:21:19.496] - run: TRUE
[10:21:19.496] - result: ‘FutureResult’
[10:21:19.496] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:19.497] resolve() on environment ...
[10:21:19.498]  recursive: 0
[10:21:19.498]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:19.498] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.498] - nx: 4
[10:21:19.498] - relay: TRUE
[10:21:19.498] - stdout: TRUE
[10:21:19.498] - signal: TRUE
[10:21:19.498] - resignal: FALSE
[10:21:19.499] - force: TRUE
[10:21:19.499] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.499] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.499]  - until=2
[10:21:19.499]  - relaying element #2
[10:21:19.499] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.499] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.499] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.499]  length: 3 (resolved future 1)
[10:21:19.499] resolved() for ‘SequentialFuture’ ...
[10:21:19.499] - state: ‘finished’
[10:21:19.499] - run: TRUE
[10:21:19.500] - result: ‘FutureResult’
[10:21:19.500] resolved() for ‘SequentialFuture’ ... done
[10:21:19.500] Future #2
[10:21:19.500] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.500] - nx: 4
[10:21:19.500] - relay: TRUE
[10:21:19.500] - stdout: TRUE
[10:21:19.500] - signal: TRUE
[10:21:19.500] - resignal: FALSE
[10:21:19.500] - force: TRUE
[10:21:19.500] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:19.500] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:19.500]  - until=2
[10:21:19.501]  - relaying element #2
[10:21:19.501] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.501] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.501] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.501]  length: 2 (resolved future 2)
[10:21:19.501] resolved() for ‘SequentialFuture’ ...
[10:21:19.501] - state: ‘finished’
[10:21:19.501] - run: TRUE
[10:21:19.501] - result: ‘FutureResult’
[10:21:19.501] resolved() for ‘SequentialFuture’ ... done
[10:21:19.502] Future #3
[10:21:19.502] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.502] - nx: 4
[10:21:19.502] - relay: TRUE
[10:21:19.502] - stdout: TRUE
[10:21:19.502] - signal: TRUE
[10:21:19.502] - resignal: FALSE
[10:21:19.502] - force: TRUE
[10:21:19.502] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:19.502] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:19.502]  - until=3
[10:21:19.502]  - relaying element #3
[10:21:19.503] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.503] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.503] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.503]  length: 1 (resolved future 3)
[10:21:19.503] resolved() for ‘SequentialFuture’ ...
[10:21:19.503] - state: ‘finished’
[10:21:19.503] - run: TRUE
[10:21:19.503] - result: ‘FutureResult’
[10:21:19.503] resolved() for ‘SequentialFuture’ ... done
[10:21:19.503] Future #4
[10:21:19.503] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.503] - nx: 4
[10:21:19.504] - relay: TRUE
[10:21:19.504] - stdout: TRUE
[10:21:19.504] - signal: TRUE
[10:21:19.504] - resignal: FALSE
[10:21:19.504] - force: TRUE
[10:21:19.504] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:19.504] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:19.504]  - until=4
[10:21:19.504]  - relaying element #4
[10:21:19.504] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.504] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.504] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.505]  length: 0 (resolved future 4)
[10:21:19.505] Relaying remaining futures
[10:21:19.505] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.505] - nx: 4
[10:21:19.505] - relay: TRUE
[10:21:19.505] - stdout: TRUE
[10:21:19.505] - signal: TRUE
[10:21:19.505] - resignal: FALSE
[10:21:19.505] - force: TRUE
[10:21:19.505] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.505] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:19.505] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:19.505] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:19.506] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.506] resolve() on environment ... DONE
<environment: 0x55e8e399e858> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[10:21:19.506] plan(): Setting new future strategy stack:
[10:21:19.506] List of future strategies:
[10:21:19.506] 1. sequential:
[10:21:19.506]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.506]    - tweaked: FALSE
[10:21:19.506]    - call: plan(strategy)
[10:21:19.507] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[10:21:19.507] getGlobalsAndPackages() ...
[10:21:19.507] Searching for globals...
[10:21:19.508] 
[10:21:19.508] Searching for globals ... DONE
[10:21:19.508] - globals: [0] <none>
[10:21:19.508] getGlobalsAndPackages() ... DONE
[10:21:19.508] run() for ‘Future’ ...
[10:21:19.508] - state: ‘created’
[10:21:19.508] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.508] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.509] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.509]   - Field: ‘label’
[10:21:19.509]   - Field: ‘local’
[10:21:19.509]   - Field: ‘owner’
[10:21:19.509]   - Field: ‘envir’
[10:21:19.509]   - Field: ‘packages’
[10:21:19.509]   - Field: ‘gc’
[10:21:19.509]   - Field: ‘conditions’
[10:21:19.509]   - Field: ‘expr’
[10:21:19.509]   - Field: ‘uuid’
[10:21:19.509]   - Field: ‘seed’
[10:21:19.509]   - Field: ‘version’
[10:21:19.510]   - Field: ‘result’
[10:21:19.510]   - Field: ‘asynchronous’
[10:21:19.510]   - Field: ‘calls’
[10:21:19.510]   - Field: ‘globals’
[10:21:19.510]   - Field: ‘stdout’
[10:21:19.510]   - Field: ‘earlySignal’
[10:21:19.510]   - Field: ‘lazy’
[10:21:19.510]   - Field: ‘state’
[10:21:19.510] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.510] - Launch lazy future ...
[10:21:19.510] Packages needed by the future expression (n = 0): <none>
[10:21:19.510] Packages needed by future strategies (n = 0): <none>
[10:21:19.511] {
[10:21:19.511]     {
[10:21:19.511]         {
[10:21:19.511]             ...future.startTime <- base::Sys.time()
[10:21:19.511]             {
[10:21:19.511]                 {
[10:21:19.511]                   {
[10:21:19.511]                     base::local({
[10:21:19.511]                       has_future <- base::requireNamespace("future", 
[10:21:19.511]                         quietly = TRUE)
[10:21:19.511]                       if (has_future) {
[10:21:19.511]                         ns <- base::getNamespace("future")
[10:21:19.511]                         version <- ns[[".package"]][["version"]]
[10:21:19.511]                         if (is.null(version)) 
[10:21:19.511]                           version <- utils::packageVersion("future")
[10:21:19.511]                       }
[10:21:19.511]                       else {
[10:21:19.511]                         version <- NULL
[10:21:19.511]                       }
[10:21:19.511]                       if (!has_future || version < "1.8.0") {
[10:21:19.511]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.511]                           "", base::R.version$version.string), 
[10:21:19.511]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.511]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.511]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.511]                             "release", "version")], collapse = " "), 
[10:21:19.511]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.511]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.511]                           info)
[10:21:19.511]                         info <- base::paste(info, collapse = "; ")
[10:21:19.511]                         if (!has_future) {
[10:21:19.511]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.511]                             info)
[10:21:19.511]                         }
[10:21:19.511]                         else {
[10:21:19.511]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.511]                             info, version)
[10:21:19.511]                         }
[10:21:19.511]                         base::stop(msg)
[10:21:19.511]                       }
[10:21:19.511]                     })
[10:21:19.511]                   }
[10:21:19.511]                   ...future.strategy.old <- future::plan("list")
[10:21:19.511]                   options(future.plan = NULL)
[10:21:19.511]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.511]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.511]                 }
[10:21:19.511]                 ...future.workdir <- getwd()
[10:21:19.511]             }
[10:21:19.511]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.511]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.511]         }
[10:21:19.511]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.511]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.511]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.511]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.511]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.511]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.511]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.511]             base::names(...future.oldOptions))
[10:21:19.511]     }
[10:21:19.511]     if (FALSE) {
[10:21:19.511]     }
[10:21:19.511]     else {
[10:21:19.511]         if (TRUE) {
[10:21:19.511]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.511]                 open = "w")
[10:21:19.511]         }
[10:21:19.511]         else {
[10:21:19.511]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.511]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.511]         }
[10:21:19.511]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.511]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.511]             base::sink(type = "output", split = FALSE)
[10:21:19.511]             base::close(...future.stdout)
[10:21:19.511]         }, add = TRUE)
[10:21:19.511]     }
[10:21:19.511]     ...future.frame <- base::sys.nframe()
[10:21:19.511]     ...future.conditions <- base::list()
[10:21:19.511]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.511]     if (FALSE) {
[10:21:19.511]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.511]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.511]     }
[10:21:19.511]     ...future.result <- base::tryCatch({
[10:21:19.511]         base::withCallingHandlers({
[10:21:19.511]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.511]             future::FutureResult(value = ...future.value$value, 
[10:21:19.511]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.511]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.511]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.511]                     ...future.globalenv.names))
[10:21:19.511]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.511]         }, condition = base::local({
[10:21:19.511]             c <- base::c
[10:21:19.511]             inherits <- base::inherits
[10:21:19.511]             invokeRestart <- base::invokeRestart
[10:21:19.511]             length <- base::length
[10:21:19.511]             list <- base::list
[10:21:19.511]             seq.int <- base::seq.int
[10:21:19.511]             signalCondition <- base::signalCondition
[10:21:19.511]             sys.calls <- base::sys.calls
[10:21:19.511]             `[[` <- base::`[[`
[10:21:19.511]             `+` <- base::`+`
[10:21:19.511]             `<<-` <- base::`<<-`
[10:21:19.511]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.511]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.511]                   3L)]
[10:21:19.511]             }
[10:21:19.511]             function(cond) {
[10:21:19.511]                 is_error <- inherits(cond, "error")
[10:21:19.511]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.511]                   NULL)
[10:21:19.511]                 if (is_error) {
[10:21:19.511]                   sessionInformation <- function() {
[10:21:19.511]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.511]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.511]                       search = base::search(), system = base::Sys.info())
[10:21:19.511]                   }
[10:21:19.511]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.511]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.511]                     cond$call), session = sessionInformation(), 
[10:21:19.511]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.511]                   signalCondition(cond)
[10:21:19.511]                 }
[10:21:19.511]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.511]                 "immediateCondition"))) {
[10:21:19.511]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.511]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.511]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.511]                   if (TRUE && !signal) {
[10:21:19.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.511]                     {
[10:21:19.511]                       inherits <- base::inherits
[10:21:19.511]                       invokeRestart <- base::invokeRestart
[10:21:19.511]                       is.null <- base::is.null
[10:21:19.511]                       muffled <- FALSE
[10:21:19.511]                       if (inherits(cond, "message")) {
[10:21:19.511]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.511]                         if (muffled) 
[10:21:19.511]                           invokeRestart("muffleMessage")
[10:21:19.511]                       }
[10:21:19.511]                       else if (inherits(cond, "warning")) {
[10:21:19.511]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.511]                         if (muffled) 
[10:21:19.511]                           invokeRestart("muffleWarning")
[10:21:19.511]                       }
[10:21:19.511]                       else if (inherits(cond, "condition")) {
[10:21:19.511]                         if (!is.null(pattern)) {
[10:21:19.511]                           computeRestarts <- base::computeRestarts
[10:21:19.511]                           grepl <- base::grepl
[10:21:19.511]                           restarts <- computeRestarts(cond)
[10:21:19.511]                           for (restart in restarts) {
[10:21:19.511]                             name <- restart$name
[10:21:19.511]                             if (is.null(name)) 
[10:21:19.511]                               next
[10:21:19.511]                             if (!grepl(pattern, name)) 
[10:21:19.511]                               next
[10:21:19.511]                             invokeRestart(restart)
[10:21:19.511]                             muffled <- TRUE
[10:21:19.511]                             break
[10:21:19.511]                           }
[10:21:19.511]                         }
[10:21:19.511]                       }
[10:21:19.511]                       invisible(muffled)
[10:21:19.511]                     }
[10:21:19.511]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.511]                   }
[10:21:19.511]                 }
[10:21:19.511]                 else {
[10:21:19.511]                   if (TRUE) {
[10:21:19.511]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.511]                     {
[10:21:19.511]                       inherits <- base::inherits
[10:21:19.511]                       invokeRestart <- base::invokeRestart
[10:21:19.511]                       is.null <- base::is.null
[10:21:19.511]                       muffled <- FALSE
[10:21:19.511]                       if (inherits(cond, "message")) {
[10:21:19.511]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.511]                         if (muffled) 
[10:21:19.511]                           invokeRestart("muffleMessage")
[10:21:19.511]                       }
[10:21:19.511]                       else if (inherits(cond, "warning")) {
[10:21:19.511]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.511]                         if (muffled) 
[10:21:19.511]                           invokeRestart("muffleWarning")
[10:21:19.511]                       }
[10:21:19.511]                       else if (inherits(cond, "condition")) {
[10:21:19.511]                         if (!is.null(pattern)) {
[10:21:19.511]                           computeRestarts <- base::computeRestarts
[10:21:19.511]                           grepl <- base::grepl
[10:21:19.511]                           restarts <- computeRestarts(cond)
[10:21:19.511]                           for (restart in restarts) {
[10:21:19.511]                             name <- restart$name
[10:21:19.511]                             if (is.null(name)) 
[10:21:19.511]                               next
[10:21:19.511]                             if (!grepl(pattern, name)) 
[10:21:19.511]                               next
[10:21:19.511]                             invokeRestart(restart)
[10:21:19.511]                             muffled <- TRUE
[10:21:19.511]                             break
[10:21:19.511]                           }
[10:21:19.511]                         }
[10:21:19.511]                       }
[10:21:19.511]                       invisible(muffled)
[10:21:19.511]                     }
[10:21:19.511]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.511]                   }
[10:21:19.511]                 }
[10:21:19.511]             }
[10:21:19.511]         }))
[10:21:19.511]     }, error = function(ex) {
[10:21:19.511]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.511]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.511]                 ...future.rng), started = ...future.startTime, 
[10:21:19.511]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.511]             version = "1.8"), class = "FutureResult")
[10:21:19.511]     }, finally = {
[10:21:19.511]         if (!identical(...future.workdir, getwd())) 
[10:21:19.511]             setwd(...future.workdir)
[10:21:19.511]         {
[10:21:19.511]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.511]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.511]             }
[10:21:19.511]             base::options(...future.oldOptions)
[10:21:19.511]             if (.Platform$OS.type == "windows") {
[10:21:19.511]                 old_names <- names(...future.oldEnvVars)
[10:21:19.511]                 envs <- base::Sys.getenv()
[10:21:19.511]                 names <- names(envs)
[10:21:19.511]                 common <- intersect(names, old_names)
[10:21:19.511]                 added <- setdiff(names, old_names)
[10:21:19.511]                 removed <- setdiff(old_names, names)
[10:21:19.511]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.511]                   envs[common]]
[10:21:19.511]                 NAMES <- toupper(changed)
[10:21:19.511]                 args <- list()
[10:21:19.511]                 for (kk in seq_along(NAMES)) {
[10:21:19.511]                   name <- changed[[kk]]
[10:21:19.511]                   NAME <- NAMES[[kk]]
[10:21:19.511]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.511]                     next
[10:21:19.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.511]                 }
[10:21:19.511]                 NAMES <- toupper(added)
[10:21:19.511]                 for (kk in seq_along(NAMES)) {
[10:21:19.511]                   name <- added[[kk]]
[10:21:19.511]                   NAME <- NAMES[[kk]]
[10:21:19.511]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.511]                     next
[10:21:19.511]                   args[[name]] <- ""
[10:21:19.511]                 }
[10:21:19.511]                 NAMES <- toupper(removed)
[10:21:19.511]                 for (kk in seq_along(NAMES)) {
[10:21:19.511]                   name <- removed[[kk]]
[10:21:19.511]                   NAME <- NAMES[[kk]]
[10:21:19.511]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.511]                     next
[10:21:19.511]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.511]                 }
[10:21:19.511]                 if (length(args) > 0) 
[10:21:19.511]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.511]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.511]             }
[10:21:19.511]             else {
[10:21:19.511]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.511]             }
[10:21:19.511]             {
[10:21:19.511]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.511]                   0L) {
[10:21:19.511]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.511]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.511]                   base::options(opts)
[10:21:19.511]                 }
[10:21:19.511]                 {
[10:21:19.511]                   {
[10:21:19.511]                     NULL
[10:21:19.511]                     RNGkind("Mersenne-Twister")
[10:21:19.511]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.511]                       inherits = FALSE)
[10:21:19.511]                   }
[10:21:19.511]                   options(future.plan = NULL)
[10:21:19.511]                   if (is.na(NA_character_)) 
[10:21:19.511]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.511]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.511]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.511]                     .init = FALSE)
[10:21:19.511]                 }
[10:21:19.511]             }
[10:21:19.511]         }
[10:21:19.511]     })
[10:21:19.511]     if (TRUE) {
[10:21:19.511]         base::sink(type = "output", split = FALSE)
[10:21:19.511]         if (TRUE) {
[10:21:19.511]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.511]         }
[10:21:19.511]         else {
[10:21:19.511]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.511]         }
[10:21:19.511]         base::close(...future.stdout)
[10:21:19.511]         ...future.stdout <- NULL
[10:21:19.511]     }
[10:21:19.511]     ...future.result$conditions <- ...future.conditions
[10:21:19.511]     ...future.result$finished <- base::Sys.time()
[10:21:19.511]     ...future.result
[10:21:19.511] }
[10:21:19.513] plan(): Setting new future strategy stack:
[10:21:19.513] List of future strategies:
[10:21:19.513] 1. sequential:
[10:21:19.513]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.513]    - tweaked: FALSE
[10:21:19.513]    - call: NULL
[10:21:19.513] plan(): nbrOfWorkers() = 1
[10:21:19.514] plan(): Setting new future strategy stack:
[10:21:19.514] List of future strategies:
[10:21:19.514] 1. sequential:
[10:21:19.514]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.514]    - tweaked: FALSE
[10:21:19.514]    - call: plan(strategy)
[10:21:19.514] plan(): nbrOfWorkers() = 1
[10:21:19.514] SequentialFuture started (and completed)
[10:21:19.515] - Launch lazy future ... done
[10:21:19.515] run() for ‘SequentialFuture’ ... done
[10:21:19.515] getGlobalsAndPackages() ...
[10:21:19.515] Searching for globals...
[10:21:19.515] 
[10:21:19.515] Searching for globals ... DONE
[10:21:19.515] - globals: [0] <none>
[10:21:19.515] getGlobalsAndPackages() ... DONE
[10:21:19.516] run() for ‘Future’ ...
[10:21:19.516] - state: ‘created’
[10:21:19.516] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.516] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.516] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.516]   - Field: ‘label’
[10:21:19.516]   - Field: ‘local’
[10:21:19.516]   - Field: ‘owner’
[10:21:19.516]   - Field: ‘envir’
[10:21:19.516]   - Field: ‘packages’
[10:21:19.517]   - Field: ‘gc’
[10:21:19.517]   - Field: ‘conditions’
[10:21:19.517]   - Field: ‘expr’
[10:21:19.517]   - Field: ‘uuid’
[10:21:19.517]   - Field: ‘seed’
[10:21:19.517]   - Field: ‘version’
[10:21:19.517]   - Field: ‘result’
[10:21:19.517]   - Field: ‘asynchronous’
[10:21:19.517]   - Field: ‘calls’
[10:21:19.517]   - Field: ‘globals’
[10:21:19.517]   - Field: ‘stdout’
[10:21:19.517]   - Field: ‘earlySignal’
[10:21:19.518]   - Field: ‘lazy’
[10:21:19.518]   - Field: ‘state’
[10:21:19.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.519] - Launch lazy future ...
[10:21:19.519] Packages needed by the future expression (n = 0): <none>
[10:21:19.519] Packages needed by future strategies (n = 0): <none>
[10:21:19.520] {
[10:21:19.520]     {
[10:21:19.520]         {
[10:21:19.520]             ...future.startTime <- base::Sys.time()
[10:21:19.520]             {
[10:21:19.520]                 {
[10:21:19.520]                   {
[10:21:19.520]                     base::local({
[10:21:19.520]                       has_future <- base::requireNamespace("future", 
[10:21:19.520]                         quietly = TRUE)
[10:21:19.520]                       if (has_future) {
[10:21:19.520]                         ns <- base::getNamespace("future")
[10:21:19.520]                         version <- ns[[".package"]][["version"]]
[10:21:19.520]                         if (is.null(version)) 
[10:21:19.520]                           version <- utils::packageVersion("future")
[10:21:19.520]                       }
[10:21:19.520]                       else {
[10:21:19.520]                         version <- NULL
[10:21:19.520]                       }
[10:21:19.520]                       if (!has_future || version < "1.8.0") {
[10:21:19.520]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.520]                           "", base::R.version$version.string), 
[10:21:19.520]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.520]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.520]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.520]                             "release", "version")], collapse = " "), 
[10:21:19.520]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.520]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.520]                           info)
[10:21:19.520]                         info <- base::paste(info, collapse = "; ")
[10:21:19.520]                         if (!has_future) {
[10:21:19.520]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.520]                             info)
[10:21:19.520]                         }
[10:21:19.520]                         else {
[10:21:19.520]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.520]                             info, version)
[10:21:19.520]                         }
[10:21:19.520]                         base::stop(msg)
[10:21:19.520]                       }
[10:21:19.520]                     })
[10:21:19.520]                   }
[10:21:19.520]                   ...future.strategy.old <- future::plan("list")
[10:21:19.520]                   options(future.plan = NULL)
[10:21:19.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.520]                 }
[10:21:19.520]                 ...future.workdir <- getwd()
[10:21:19.520]             }
[10:21:19.520]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.520]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.520]         }
[10:21:19.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.520]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.520]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.520]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.520]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.520]             base::names(...future.oldOptions))
[10:21:19.520]     }
[10:21:19.520]     if (FALSE) {
[10:21:19.520]     }
[10:21:19.520]     else {
[10:21:19.520]         if (TRUE) {
[10:21:19.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.520]                 open = "w")
[10:21:19.520]         }
[10:21:19.520]         else {
[10:21:19.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.520]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.520]         }
[10:21:19.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.520]             base::sink(type = "output", split = FALSE)
[10:21:19.520]             base::close(...future.stdout)
[10:21:19.520]         }, add = TRUE)
[10:21:19.520]     }
[10:21:19.520]     ...future.frame <- base::sys.nframe()
[10:21:19.520]     ...future.conditions <- base::list()
[10:21:19.520]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.520]     if (FALSE) {
[10:21:19.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.520]     }
[10:21:19.520]     ...future.result <- base::tryCatch({
[10:21:19.520]         base::withCallingHandlers({
[10:21:19.520]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.520]             future::FutureResult(value = ...future.value$value, 
[10:21:19.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.520]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.520]                     ...future.globalenv.names))
[10:21:19.520]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.520]         }, condition = base::local({
[10:21:19.520]             c <- base::c
[10:21:19.520]             inherits <- base::inherits
[10:21:19.520]             invokeRestart <- base::invokeRestart
[10:21:19.520]             length <- base::length
[10:21:19.520]             list <- base::list
[10:21:19.520]             seq.int <- base::seq.int
[10:21:19.520]             signalCondition <- base::signalCondition
[10:21:19.520]             sys.calls <- base::sys.calls
[10:21:19.520]             `[[` <- base::`[[`
[10:21:19.520]             `+` <- base::`+`
[10:21:19.520]             `<<-` <- base::`<<-`
[10:21:19.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.520]                   3L)]
[10:21:19.520]             }
[10:21:19.520]             function(cond) {
[10:21:19.520]                 is_error <- inherits(cond, "error")
[10:21:19.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.520]                   NULL)
[10:21:19.520]                 if (is_error) {
[10:21:19.520]                   sessionInformation <- function() {
[10:21:19.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.520]                       search = base::search(), system = base::Sys.info())
[10:21:19.520]                   }
[10:21:19.520]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.520]                     cond$call), session = sessionInformation(), 
[10:21:19.520]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.520]                   signalCondition(cond)
[10:21:19.520]                 }
[10:21:19.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.520]                 "immediateCondition"))) {
[10:21:19.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.520]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.520]                   if (TRUE && !signal) {
[10:21:19.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.520]                     {
[10:21:19.520]                       inherits <- base::inherits
[10:21:19.520]                       invokeRestart <- base::invokeRestart
[10:21:19.520]                       is.null <- base::is.null
[10:21:19.520]                       muffled <- FALSE
[10:21:19.520]                       if (inherits(cond, "message")) {
[10:21:19.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.520]                         if (muffled) 
[10:21:19.520]                           invokeRestart("muffleMessage")
[10:21:19.520]                       }
[10:21:19.520]                       else if (inherits(cond, "warning")) {
[10:21:19.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.520]                         if (muffled) 
[10:21:19.520]                           invokeRestart("muffleWarning")
[10:21:19.520]                       }
[10:21:19.520]                       else if (inherits(cond, "condition")) {
[10:21:19.520]                         if (!is.null(pattern)) {
[10:21:19.520]                           computeRestarts <- base::computeRestarts
[10:21:19.520]                           grepl <- base::grepl
[10:21:19.520]                           restarts <- computeRestarts(cond)
[10:21:19.520]                           for (restart in restarts) {
[10:21:19.520]                             name <- restart$name
[10:21:19.520]                             if (is.null(name)) 
[10:21:19.520]                               next
[10:21:19.520]                             if (!grepl(pattern, name)) 
[10:21:19.520]                               next
[10:21:19.520]                             invokeRestart(restart)
[10:21:19.520]                             muffled <- TRUE
[10:21:19.520]                             break
[10:21:19.520]                           }
[10:21:19.520]                         }
[10:21:19.520]                       }
[10:21:19.520]                       invisible(muffled)
[10:21:19.520]                     }
[10:21:19.520]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.520]                   }
[10:21:19.520]                 }
[10:21:19.520]                 else {
[10:21:19.520]                   if (TRUE) {
[10:21:19.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.520]                     {
[10:21:19.520]                       inherits <- base::inherits
[10:21:19.520]                       invokeRestart <- base::invokeRestart
[10:21:19.520]                       is.null <- base::is.null
[10:21:19.520]                       muffled <- FALSE
[10:21:19.520]                       if (inherits(cond, "message")) {
[10:21:19.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.520]                         if (muffled) 
[10:21:19.520]                           invokeRestart("muffleMessage")
[10:21:19.520]                       }
[10:21:19.520]                       else if (inherits(cond, "warning")) {
[10:21:19.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.520]                         if (muffled) 
[10:21:19.520]                           invokeRestart("muffleWarning")
[10:21:19.520]                       }
[10:21:19.520]                       else if (inherits(cond, "condition")) {
[10:21:19.520]                         if (!is.null(pattern)) {
[10:21:19.520]                           computeRestarts <- base::computeRestarts
[10:21:19.520]                           grepl <- base::grepl
[10:21:19.520]                           restarts <- computeRestarts(cond)
[10:21:19.520]                           for (restart in restarts) {
[10:21:19.520]                             name <- restart$name
[10:21:19.520]                             if (is.null(name)) 
[10:21:19.520]                               next
[10:21:19.520]                             if (!grepl(pattern, name)) 
[10:21:19.520]                               next
[10:21:19.520]                             invokeRestart(restart)
[10:21:19.520]                             muffled <- TRUE
[10:21:19.520]                             break
[10:21:19.520]                           }
[10:21:19.520]                         }
[10:21:19.520]                       }
[10:21:19.520]                       invisible(muffled)
[10:21:19.520]                     }
[10:21:19.520]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.520]                   }
[10:21:19.520]                 }
[10:21:19.520]             }
[10:21:19.520]         }))
[10:21:19.520]     }, error = function(ex) {
[10:21:19.520]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.520]                 ...future.rng), started = ...future.startTime, 
[10:21:19.520]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.520]             version = "1.8"), class = "FutureResult")
[10:21:19.520]     }, finally = {
[10:21:19.520]         if (!identical(...future.workdir, getwd())) 
[10:21:19.520]             setwd(...future.workdir)
[10:21:19.520]         {
[10:21:19.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.520]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.520]             }
[10:21:19.520]             base::options(...future.oldOptions)
[10:21:19.520]             if (.Platform$OS.type == "windows") {
[10:21:19.520]                 old_names <- names(...future.oldEnvVars)
[10:21:19.520]                 envs <- base::Sys.getenv()
[10:21:19.520]                 names <- names(envs)
[10:21:19.520]                 common <- intersect(names, old_names)
[10:21:19.520]                 added <- setdiff(names, old_names)
[10:21:19.520]                 removed <- setdiff(old_names, names)
[10:21:19.520]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.520]                   envs[common]]
[10:21:19.520]                 NAMES <- toupper(changed)
[10:21:19.520]                 args <- list()
[10:21:19.520]                 for (kk in seq_along(NAMES)) {
[10:21:19.520]                   name <- changed[[kk]]
[10:21:19.520]                   NAME <- NAMES[[kk]]
[10:21:19.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.520]                     next
[10:21:19.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.520]                 }
[10:21:19.520]                 NAMES <- toupper(added)
[10:21:19.520]                 for (kk in seq_along(NAMES)) {
[10:21:19.520]                   name <- added[[kk]]
[10:21:19.520]                   NAME <- NAMES[[kk]]
[10:21:19.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.520]                     next
[10:21:19.520]                   args[[name]] <- ""
[10:21:19.520]                 }
[10:21:19.520]                 NAMES <- toupper(removed)
[10:21:19.520]                 for (kk in seq_along(NAMES)) {
[10:21:19.520]                   name <- removed[[kk]]
[10:21:19.520]                   NAME <- NAMES[[kk]]
[10:21:19.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.520]                     next
[10:21:19.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.520]                 }
[10:21:19.520]                 if (length(args) > 0) 
[10:21:19.520]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.520]             }
[10:21:19.520]             else {
[10:21:19.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.520]             }
[10:21:19.520]             {
[10:21:19.520]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.520]                   0L) {
[10:21:19.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.520]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.520]                   base::options(opts)
[10:21:19.520]                 }
[10:21:19.520]                 {
[10:21:19.520]                   {
[10:21:19.520]                     NULL
[10:21:19.520]                     RNGkind("Mersenne-Twister")
[10:21:19.520]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.520]                       inherits = FALSE)
[10:21:19.520]                   }
[10:21:19.520]                   options(future.plan = NULL)
[10:21:19.520]                   if (is.na(NA_character_)) 
[10:21:19.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.520]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.520]                     .init = FALSE)
[10:21:19.520]                 }
[10:21:19.520]             }
[10:21:19.520]         }
[10:21:19.520]     })
[10:21:19.520]     if (TRUE) {
[10:21:19.520]         base::sink(type = "output", split = FALSE)
[10:21:19.520]         if (TRUE) {
[10:21:19.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.520]         }
[10:21:19.520]         else {
[10:21:19.520]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.520]         }
[10:21:19.520]         base::close(...future.stdout)
[10:21:19.520]         ...future.stdout <- NULL
[10:21:19.520]     }
[10:21:19.520]     ...future.result$conditions <- ...future.conditions
[10:21:19.520]     ...future.result$finished <- base::Sys.time()
[10:21:19.520]     ...future.result
[10:21:19.520] }
[10:21:19.521] plan(): Setting new future strategy stack:
[10:21:19.521] List of future strategies:
[10:21:19.521] 1. sequential:
[10:21:19.521]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.521]    - tweaked: FALSE
[10:21:19.521]    - call: NULL
[10:21:19.522] plan(): nbrOfWorkers() = 1
[10:21:19.522] plan(): Setting new future strategy stack:
[10:21:19.523] List of future strategies:
[10:21:19.523] 1. sequential:
[10:21:19.523]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.523]    - tweaked: FALSE
[10:21:19.523]    - call: plan(strategy)
[10:21:19.523] plan(): nbrOfWorkers() = 1
[10:21:19.523] SequentialFuture started (and completed)
[10:21:19.523] - Launch lazy future ... done
[10:21:19.523] run() for ‘SequentialFuture’ ... done
[10:21:19.524] getGlobalsAndPackages() ...
[10:21:19.524] Searching for globals...
[10:21:19.524] - globals found: [1] ‘{’
[10:21:19.525] Searching for globals ... DONE
[10:21:19.525] Resolving globals: FALSE
[10:21:19.525] 
[10:21:19.525] 
[10:21:19.525] getGlobalsAndPackages() ... DONE
[10:21:19.525] run() for ‘Future’ ...
[10:21:19.525] - state: ‘created’
[10:21:19.525] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.526] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.526] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.526]   - Field: ‘label’
[10:21:19.526]   - Field: ‘local’
[10:21:19.526]   - Field: ‘owner’
[10:21:19.526]   - Field: ‘envir’
[10:21:19.526]   - Field: ‘packages’
[10:21:19.526]   - Field: ‘gc’
[10:21:19.526]   - Field: ‘conditions’
[10:21:19.526]   - Field: ‘expr’
[10:21:19.527]   - Field: ‘uuid’
[10:21:19.527]   - Field: ‘seed’
[10:21:19.527]   - Field: ‘version’
[10:21:19.527]   - Field: ‘result’
[10:21:19.527]   - Field: ‘asynchronous’
[10:21:19.527]   - Field: ‘calls’
[10:21:19.527]   - Field: ‘globals’
[10:21:19.527]   - Field: ‘stdout’
[10:21:19.527]   - Field: ‘earlySignal’
[10:21:19.527]   - Field: ‘lazy’
[10:21:19.527]   - Field: ‘state’
[10:21:19.527] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.527] - Launch lazy future ...
[10:21:19.528] Packages needed by the future expression (n = 0): <none>
[10:21:19.528] Packages needed by future strategies (n = 0): <none>
[10:21:19.528] {
[10:21:19.528]     {
[10:21:19.528]         {
[10:21:19.528]             ...future.startTime <- base::Sys.time()
[10:21:19.528]             {
[10:21:19.528]                 {
[10:21:19.528]                   {
[10:21:19.528]                     base::local({
[10:21:19.528]                       has_future <- base::requireNamespace("future", 
[10:21:19.528]                         quietly = TRUE)
[10:21:19.528]                       if (has_future) {
[10:21:19.528]                         ns <- base::getNamespace("future")
[10:21:19.528]                         version <- ns[[".package"]][["version"]]
[10:21:19.528]                         if (is.null(version)) 
[10:21:19.528]                           version <- utils::packageVersion("future")
[10:21:19.528]                       }
[10:21:19.528]                       else {
[10:21:19.528]                         version <- NULL
[10:21:19.528]                       }
[10:21:19.528]                       if (!has_future || version < "1.8.0") {
[10:21:19.528]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.528]                           "", base::R.version$version.string), 
[10:21:19.528]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.528]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.528]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.528]                             "release", "version")], collapse = " "), 
[10:21:19.528]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.528]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.528]                           info)
[10:21:19.528]                         info <- base::paste(info, collapse = "; ")
[10:21:19.528]                         if (!has_future) {
[10:21:19.528]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.528]                             info)
[10:21:19.528]                         }
[10:21:19.528]                         else {
[10:21:19.528]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.528]                             info, version)
[10:21:19.528]                         }
[10:21:19.528]                         base::stop(msg)
[10:21:19.528]                       }
[10:21:19.528]                     })
[10:21:19.528]                   }
[10:21:19.528]                   ...future.strategy.old <- future::plan("list")
[10:21:19.528]                   options(future.plan = NULL)
[10:21:19.528]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.528]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.528]                 }
[10:21:19.528]                 ...future.workdir <- getwd()
[10:21:19.528]             }
[10:21:19.528]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.528]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.528]         }
[10:21:19.528]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.528]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.528]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.528]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.528]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.528]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.528]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.528]             base::names(...future.oldOptions))
[10:21:19.528]     }
[10:21:19.528]     if (FALSE) {
[10:21:19.528]     }
[10:21:19.528]     else {
[10:21:19.528]         if (TRUE) {
[10:21:19.528]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.528]                 open = "w")
[10:21:19.528]         }
[10:21:19.528]         else {
[10:21:19.528]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.528]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.528]         }
[10:21:19.528]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.528]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.528]             base::sink(type = "output", split = FALSE)
[10:21:19.528]             base::close(...future.stdout)
[10:21:19.528]         }, add = TRUE)
[10:21:19.528]     }
[10:21:19.528]     ...future.frame <- base::sys.nframe()
[10:21:19.528]     ...future.conditions <- base::list()
[10:21:19.528]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.528]     if (FALSE) {
[10:21:19.528]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.528]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.528]     }
[10:21:19.528]     ...future.result <- base::tryCatch({
[10:21:19.528]         base::withCallingHandlers({
[10:21:19.528]             ...future.value <- base::withVisible(base::local({
[10:21:19.528]                 4
[10:21:19.528]             }))
[10:21:19.528]             future::FutureResult(value = ...future.value$value, 
[10:21:19.528]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.528]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.528]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.528]                     ...future.globalenv.names))
[10:21:19.528]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.528]         }, condition = base::local({
[10:21:19.528]             c <- base::c
[10:21:19.528]             inherits <- base::inherits
[10:21:19.528]             invokeRestart <- base::invokeRestart
[10:21:19.528]             length <- base::length
[10:21:19.528]             list <- base::list
[10:21:19.528]             seq.int <- base::seq.int
[10:21:19.528]             signalCondition <- base::signalCondition
[10:21:19.528]             sys.calls <- base::sys.calls
[10:21:19.528]             `[[` <- base::`[[`
[10:21:19.528]             `+` <- base::`+`
[10:21:19.528]             `<<-` <- base::`<<-`
[10:21:19.528]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.528]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.528]                   3L)]
[10:21:19.528]             }
[10:21:19.528]             function(cond) {
[10:21:19.528]                 is_error <- inherits(cond, "error")
[10:21:19.528]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.528]                   NULL)
[10:21:19.528]                 if (is_error) {
[10:21:19.528]                   sessionInformation <- function() {
[10:21:19.528]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.528]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.528]                       search = base::search(), system = base::Sys.info())
[10:21:19.528]                   }
[10:21:19.528]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.528]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.528]                     cond$call), session = sessionInformation(), 
[10:21:19.528]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.528]                   signalCondition(cond)
[10:21:19.528]                 }
[10:21:19.528]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.528]                 "immediateCondition"))) {
[10:21:19.528]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.528]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.528]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.528]                   if (TRUE && !signal) {
[10:21:19.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.528]                     {
[10:21:19.528]                       inherits <- base::inherits
[10:21:19.528]                       invokeRestart <- base::invokeRestart
[10:21:19.528]                       is.null <- base::is.null
[10:21:19.528]                       muffled <- FALSE
[10:21:19.528]                       if (inherits(cond, "message")) {
[10:21:19.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.528]                         if (muffled) 
[10:21:19.528]                           invokeRestart("muffleMessage")
[10:21:19.528]                       }
[10:21:19.528]                       else if (inherits(cond, "warning")) {
[10:21:19.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.528]                         if (muffled) 
[10:21:19.528]                           invokeRestart("muffleWarning")
[10:21:19.528]                       }
[10:21:19.528]                       else if (inherits(cond, "condition")) {
[10:21:19.528]                         if (!is.null(pattern)) {
[10:21:19.528]                           computeRestarts <- base::computeRestarts
[10:21:19.528]                           grepl <- base::grepl
[10:21:19.528]                           restarts <- computeRestarts(cond)
[10:21:19.528]                           for (restart in restarts) {
[10:21:19.528]                             name <- restart$name
[10:21:19.528]                             if (is.null(name)) 
[10:21:19.528]                               next
[10:21:19.528]                             if (!grepl(pattern, name)) 
[10:21:19.528]                               next
[10:21:19.528]                             invokeRestart(restart)
[10:21:19.528]                             muffled <- TRUE
[10:21:19.528]                             break
[10:21:19.528]                           }
[10:21:19.528]                         }
[10:21:19.528]                       }
[10:21:19.528]                       invisible(muffled)
[10:21:19.528]                     }
[10:21:19.528]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.528]                   }
[10:21:19.528]                 }
[10:21:19.528]                 else {
[10:21:19.528]                   if (TRUE) {
[10:21:19.528]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.528]                     {
[10:21:19.528]                       inherits <- base::inherits
[10:21:19.528]                       invokeRestart <- base::invokeRestart
[10:21:19.528]                       is.null <- base::is.null
[10:21:19.528]                       muffled <- FALSE
[10:21:19.528]                       if (inherits(cond, "message")) {
[10:21:19.528]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.528]                         if (muffled) 
[10:21:19.528]                           invokeRestart("muffleMessage")
[10:21:19.528]                       }
[10:21:19.528]                       else if (inherits(cond, "warning")) {
[10:21:19.528]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.528]                         if (muffled) 
[10:21:19.528]                           invokeRestart("muffleWarning")
[10:21:19.528]                       }
[10:21:19.528]                       else if (inherits(cond, "condition")) {
[10:21:19.528]                         if (!is.null(pattern)) {
[10:21:19.528]                           computeRestarts <- base::computeRestarts
[10:21:19.528]                           grepl <- base::grepl
[10:21:19.528]                           restarts <- computeRestarts(cond)
[10:21:19.528]                           for (restart in restarts) {
[10:21:19.528]                             name <- restart$name
[10:21:19.528]                             if (is.null(name)) 
[10:21:19.528]                               next
[10:21:19.528]                             if (!grepl(pattern, name)) 
[10:21:19.528]                               next
[10:21:19.528]                             invokeRestart(restart)
[10:21:19.528]                             muffled <- TRUE
[10:21:19.528]                             break
[10:21:19.528]                           }
[10:21:19.528]                         }
[10:21:19.528]                       }
[10:21:19.528]                       invisible(muffled)
[10:21:19.528]                     }
[10:21:19.528]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.528]                   }
[10:21:19.528]                 }
[10:21:19.528]             }
[10:21:19.528]         }))
[10:21:19.528]     }, error = function(ex) {
[10:21:19.528]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.528]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.528]                 ...future.rng), started = ...future.startTime, 
[10:21:19.528]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.528]             version = "1.8"), class = "FutureResult")
[10:21:19.528]     }, finally = {
[10:21:19.528]         if (!identical(...future.workdir, getwd())) 
[10:21:19.528]             setwd(...future.workdir)
[10:21:19.528]         {
[10:21:19.528]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.528]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.528]             }
[10:21:19.528]             base::options(...future.oldOptions)
[10:21:19.528]             if (.Platform$OS.type == "windows") {
[10:21:19.528]                 old_names <- names(...future.oldEnvVars)
[10:21:19.528]                 envs <- base::Sys.getenv()
[10:21:19.528]                 names <- names(envs)
[10:21:19.528]                 common <- intersect(names, old_names)
[10:21:19.528]                 added <- setdiff(names, old_names)
[10:21:19.528]                 removed <- setdiff(old_names, names)
[10:21:19.528]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.528]                   envs[common]]
[10:21:19.528]                 NAMES <- toupper(changed)
[10:21:19.528]                 args <- list()
[10:21:19.528]                 for (kk in seq_along(NAMES)) {
[10:21:19.528]                   name <- changed[[kk]]
[10:21:19.528]                   NAME <- NAMES[[kk]]
[10:21:19.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.528]                     next
[10:21:19.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.528]                 }
[10:21:19.528]                 NAMES <- toupper(added)
[10:21:19.528]                 for (kk in seq_along(NAMES)) {
[10:21:19.528]                   name <- added[[kk]]
[10:21:19.528]                   NAME <- NAMES[[kk]]
[10:21:19.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.528]                     next
[10:21:19.528]                   args[[name]] <- ""
[10:21:19.528]                 }
[10:21:19.528]                 NAMES <- toupper(removed)
[10:21:19.528]                 for (kk in seq_along(NAMES)) {
[10:21:19.528]                   name <- removed[[kk]]
[10:21:19.528]                   NAME <- NAMES[[kk]]
[10:21:19.528]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.528]                     next
[10:21:19.528]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.528]                 }
[10:21:19.528]                 if (length(args) > 0) 
[10:21:19.528]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.528]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.528]             }
[10:21:19.528]             else {
[10:21:19.528]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.528]             }
[10:21:19.528]             {
[10:21:19.528]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.528]                   0L) {
[10:21:19.528]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.528]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.528]                   base::options(opts)
[10:21:19.528]                 }
[10:21:19.528]                 {
[10:21:19.528]                   {
[10:21:19.528]                     NULL
[10:21:19.528]                     RNGkind("Mersenne-Twister")
[10:21:19.528]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.528]                       inherits = FALSE)
[10:21:19.528]                   }
[10:21:19.528]                   options(future.plan = NULL)
[10:21:19.528]                   if (is.na(NA_character_)) 
[10:21:19.528]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.528]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.528]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.528]                     .init = FALSE)
[10:21:19.528]                 }
[10:21:19.528]             }
[10:21:19.528]         }
[10:21:19.528]     })
[10:21:19.528]     if (TRUE) {
[10:21:19.528]         base::sink(type = "output", split = FALSE)
[10:21:19.528]         if (TRUE) {
[10:21:19.528]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.528]         }
[10:21:19.528]         else {
[10:21:19.528]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.528]         }
[10:21:19.528]         base::close(...future.stdout)
[10:21:19.528]         ...future.stdout <- NULL
[10:21:19.528]     }
[10:21:19.528]     ...future.result$conditions <- ...future.conditions
[10:21:19.528]     ...future.result$finished <- base::Sys.time()
[10:21:19.528]     ...future.result
[10:21:19.528] }
[10:21:19.530] plan(): Setting new future strategy stack:
[10:21:19.530] List of future strategies:
[10:21:19.530] 1. sequential:
[10:21:19.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.530]    - tweaked: FALSE
[10:21:19.530]    - call: NULL
[10:21:19.530] plan(): nbrOfWorkers() = 1
[10:21:19.531] plan(): Setting new future strategy stack:
[10:21:19.531] List of future strategies:
[10:21:19.531] 1. sequential:
[10:21:19.531]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.531]    - tweaked: FALSE
[10:21:19.531]    - call: plan(strategy)
[10:21:19.532] plan(): nbrOfWorkers() = 1
[10:21:19.532] SequentialFuture started (and completed)
[10:21:19.532] - Launch lazy future ... done
[10:21:19.532] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e4e23ba0> 
Classes 'listenv', 'environment' <environment: 0x55e8e4d76000> 
[10:21:19.534] resolved() for ‘SequentialFuture’ ...
[10:21:19.535] - state: ‘finished’
[10:21:19.535] - run: TRUE
[10:21:19.535] - result: ‘FutureResult’
[10:21:19.535] resolved() for ‘SequentialFuture’ ... done
[10:21:19.535] resolved() for ‘SequentialFuture’ ...
[10:21:19.535] - state: ‘finished’
[10:21:19.535] - run: TRUE
[10:21:19.535] - result: ‘FutureResult’
[10:21:19.535] resolved() for ‘SequentialFuture’ ... done
[10:21:19.535] resolved() for ‘SequentialFuture’ ...
[10:21:19.535] - state: ‘finished’
[10:21:19.536] - run: TRUE
[10:21:19.536] - result: ‘FutureResult’
[10:21:19.536] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:19.537] resolve() on list environment ...
[10:21:19.537]  recursive: 0
[10:21:19.538]  length: 6
[10:21:19.538]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:19.538] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.538] - nx: 6
[10:21:19.539] - relay: TRUE
[10:21:19.539] - stdout: TRUE
[10:21:19.539] - signal: TRUE
[10:21:19.539] - resignal: FALSE
[10:21:19.539] - force: TRUE
[10:21:19.539] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.539] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.539]  - until=2
[10:21:19.539]  - relaying element #2
[10:21:19.539] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.539] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.539] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.539]  length: 5 (resolved future 1)
[10:21:19.540] resolved() for ‘SequentialFuture’ ...
[10:21:19.540] - state: ‘finished’
[10:21:19.540] - run: TRUE
[10:21:19.540] - result: ‘FutureResult’
[10:21:19.540] resolved() for ‘SequentialFuture’ ... done
[10:21:19.540] Future #2
[10:21:19.540] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.540] - nx: 6
[10:21:19.540] - relay: TRUE
[10:21:19.540] - stdout: TRUE
[10:21:19.540] - signal: TRUE
[10:21:19.541] - resignal: FALSE
[10:21:19.541] - force: TRUE
[10:21:19.541] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.541] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.541]  - until=2
[10:21:19.541]  - relaying element #2
[10:21:19.541] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.541] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.541] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.541]  length: 4 (resolved future 2)
[10:21:19.541] resolved() for ‘SequentialFuture’ ...
[10:21:19.542] - state: ‘finished’
[10:21:19.542] - run: TRUE
[10:21:19.542] - result: ‘FutureResult’
[10:21:19.542] resolved() for ‘SequentialFuture’ ... done
[10:21:19.542] Future #3
[10:21:19.542] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.542] - nx: 6
[10:21:19.542] - relay: TRUE
[10:21:19.542] - stdout: TRUE
[10:21:19.542] - signal: TRUE
[10:21:19.544] - resignal: FALSE
[10:21:19.544] - force: TRUE
[10:21:19.544] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.544] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.544]  - until=3
[10:21:19.544]  - relaying element #3
[10:21:19.544] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.544] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.544] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.545]  length: 3 (resolved future 3)
[10:21:19.545] resolved() for ‘SequentialFuture’ ...
[10:21:19.545] - state: ‘finished’
[10:21:19.545] - run: TRUE
[10:21:19.545] - result: ‘FutureResult’
[10:21:19.545] resolved() for ‘SequentialFuture’ ... done
[10:21:19.545] Future #4
[10:21:19.545] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.545] - nx: 6
[10:21:19.545] - relay: TRUE
[10:21:19.545] - stdout: TRUE
[10:21:19.545] - signal: TRUE
[10:21:19.546] - resignal: FALSE
[10:21:19.546] - force: TRUE
[10:21:19.546] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.546] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.546]  - until=4
[10:21:19.546]  - relaying element #4
[10:21:19.546] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.546] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.546] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.546]  length: 2 (resolved future 4)
[10:21:19.546] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.547] - nx: 6
[10:21:19.547] - relay: TRUE
[10:21:19.547] - stdout: TRUE
[10:21:19.547] - signal: TRUE
[10:21:19.547] - resignal: FALSE
[10:21:19.547] - force: TRUE
[10:21:19.547] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.547] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.547]  - until=6
[10:21:19.547]  - relaying element #6
[10:21:19.547] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.547] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.547] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.547]  length: 1 (resolved future 5)
[10:21:19.548] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.548] - nx: 6
[10:21:19.548] - relay: TRUE
[10:21:19.548] - stdout: TRUE
[10:21:19.548] - signal: TRUE
[10:21:19.548] - resignal: FALSE
[10:21:19.548] - force: TRUE
[10:21:19.548] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.548] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.548]  - until=6
[10:21:19.548] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.548] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.548] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.549]  length: 0 (resolved future 6)
[10:21:19.549] Relaying remaining futures
[10:21:19.549] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.549] - nx: 6
[10:21:19.549] - relay: TRUE
[10:21:19.549] - stdout: TRUE
[10:21:19.549] - signal: TRUE
[10:21:19.549] - resignal: FALSE
[10:21:19.549] - force: TRUE
[10:21:19.549] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.549] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:19.549] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.549] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.550] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.550] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55e8e5035808> 
Dimensions: c(1, 6)
[10:21:19.550] getGlobalsAndPackages() ...
[10:21:19.550] Searching for globals...
[10:21:19.551] 
[10:21:19.551] Searching for globals ... DONE
[10:21:19.551] - globals: [0] <none>
[10:21:19.551] getGlobalsAndPackages() ... DONE
[10:21:19.551] run() for ‘Future’ ...
[10:21:19.551] - state: ‘created’
[10:21:19.551] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.552] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.552] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.552]   - Field: ‘label’
[10:21:19.552]   - Field: ‘local’
[10:21:19.552]   - Field: ‘owner’
[10:21:19.552]   - Field: ‘envir’
[10:21:19.552]   - Field: ‘packages’
[10:21:19.552]   - Field: ‘gc’
[10:21:19.552]   - Field: ‘conditions’
[10:21:19.552]   - Field: ‘expr’
[10:21:19.552]   - Field: ‘uuid’
[10:21:19.553]   - Field: ‘seed’
[10:21:19.553]   - Field: ‘version’
[10:21:19.553]   - Field: ‘result’
[10:21:19.553]   - Field: ‘asynchronous’
[10:21:19.553]   - Field: ‘calls’
[10:21:19.553]   - Field: ‘globals’
[10:21:19.553]   - Field: ‘stdout’
[10:21:19.553]   - Field: ‘earlySignal’
[10:21:19.553]   - Field: ‘lazy’
[10:21:19.553]   - Field: ‘state’
[10:21:19.553] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.553] - Launch lazy future ...
[10:21:19.554] Packages needed by the future expression (n = 0): <none>
[10:21:19.554] Packages needed by future strategies (n = 0): <none>
[10:21:19.554] {
[10:21:19.554]     {
[10:21:19.554]         {
[10:21:19.554]             ...future.startTime <- base::Sys.time()
[10:21:19.554]             {
[10:21:19.554]                 {
[10:21:19.554]                   {
[10:21:19.554]                     base::local({
[10:21:19.554]                       has_future <- base::requireNamespace("future", 
[10:21:19.554]                         quietly = TRUE)
[10:21:19.554]                       if (has_future) {
[10:21:19.554]                         ns <- base::getNamespace("future")
[10:21:19.554]                         version <- ns[[".package"]][["version"]]
[10:21:19.554]                         if (is.null(version)) 
[10:21:19.554]                           version <- utils::packageVersion("future")
[10:21:19.554]                       }
[10:21:19.554]                       else {
[10:21:19.554]                         version <- NULL
[10:21:19.554]                       }
[10:21:19.554]                       if (!has_future || version < "1.8.0") {
[10:21:19.554]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.554]                           "", base::R.version$version.string), 
[10:21:19.554]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.554]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.554]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.554]                             "release", "version")], collapse = " "), 
[10:21:19.554]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.554]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.554]                           info)
[10:21:19.554]                         info <- base::paste(info, collapse = "; ")
[10:21:19.554]                         if (!has_future) {
[10:21:19.554]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.554]                             info)
[10:21:19.554]                         }
[10:21:19.554]                         else {
[10:21:19.554]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.554]                             info, version)
[10:21:19.554]                         }
[10:21:19.554]                         base::stop(msg)
[10:21:19.554]                       }
[10:21:19.554]                     })
[10:21:19.554]                   }
[10:21:19.554]                   ...future.strategy.old <- future::plan("list")
[10:21:19.554]                   options(future.plan = NULL)
[10:21:19.554]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.554]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.554]                 }
[10:21:19.554]                 ...future.workdir <- getwd()
[10:21:19.554]             }
[10:21:19.554]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.554]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.554]         }
[10:21:19.554]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.554]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.554]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.554]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.554]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.554]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.554]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.554]             base::names(...future.oldOptions))
[10:21:19.554]     }
[10:21:19.554]     if (FALSE) {
[10:21:19.554]     }
[10:21:19.554]     else {
[10:21:19.554]         if (TRUE) {
[10:21:19.554]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.554]                 open = "w")
[10:21:19.554]         }
[10:21:19.554]         else {
[10:21:19.554]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.554]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.554]         }
[10:21:19.554]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.554]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.554]             base::sink(type = "output", split = FALSE)
[10:21:19.554]             base::close(...future.stdout)
[10:21:19.554]         }, add = TRUE)
[10:21:19.554]     }
[10:21:19.554]     ...future.frame <- base::sys.nframe()
[10:21:19.554]     ...future.conditions <- base::list()
[10:21:19.554]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.554]     if (FALSE) {
[10:21:19.554]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.554]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.554]     }
[10:21:19.554]     ...future.result <- base::tryCatch({
[10:21:19.554]         base::withCallingHandlers({
[10:21:19.554]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.554]             future::FutureResult(value = ...future.value$value, 
[10:21:19.554]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.554]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.554]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.554]                     ...future.globalenv.names))
[10:21:19.554]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.554]         }, condition = base::local({
[10:21:19.554]             c <- base::c
[10:21:19.554]             inherits <- base::inherits
[10:21:19.554]             invokeRestart <- base::invokeRestart
[10:21:19.554]             length <- base::length
[10:21:19.554]             list <- base::list
[10:21:19.554]             seq.int <- base::seq.int
[10:21:19.554]             signalCondition <- base::signalCondition
[10:21:19.554]             sys.calls <- base::sys.calls
[10:21:19.554]             `[[` <- base::`[[`
[10:21:19.554]             `+` <- base::`+`
[10:21:19.554]             `<<-` <- base::`<<-`
[10:21:19.554]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.554]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.554]                   3L)]
[10:21:19.554]             }
[10:21:19.554]             function(cond) {
[10:21:19.554]                 is_error <- inherits(cond, "error")
[10:21:19.554]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.554]                   NULL)
[10:21:19.554]                 if (is_error) {
[10:21:19.554]                   sessionInformation <- function() {
[10:21:19.554]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.554]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.554]                       search = base::search(), system = base::Sys.info())
[10:21:19.554]                   }
[10:21:19.554]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.554]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.554]                     cond$call), session = sessionInformation(), 
[10:21:19.554]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.554]                   signalCondition(cond)
[10:21:19.554]                 }
[10:21:19.554]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.554]                 "immediateCondition"))) {
[10:21:19.554]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.554]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.554]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.554]                   if (TRUE && !signal) {
[10:21:19.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.554]                     {
[10:21:19.554]                       inherits <- base::inherits
[10:21:19.554]                       invokeRestart <- base::invokeRestart
[10:21:19.554]                       is.null <- base::is.null
[10:21:19.554]                       muffled <- FALSE
[10:21:19.554]                       if (inherits(cond, "message")) {
[10:21:19.554]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.554]                         if (muffled) 
[10:21:19.554]                           invokeRestart("muffleMessage")
[10:21:19.554]                       }
[10:21:19.554]                       else if (inherits(cond, "warning")) {
[10:21:19.554]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.554]                         if (muffled) 
[10:21:19.554]                           invokeRestart("muffleWarning")
[10:21:19.554]                       }
[10:21:19.554]                       else if (inherits(cond, "condition")) {
[10:21:19.554]                         if (!is.null(pattern)) {
[10:21:19.554]                           computeRestarts <- base::computeRestarts
[10:21:19.554]                           grepl <- base::grepl
[10:21:19.554]                           restarts <- computeRestarts(cond)
[10:21:19.554]                           for (restart in restarts) {
[10:21:19.554]                             name <- restart$name
[10:21:19.554]                             if (is.null(name)) 
[10:21:19.554]                               next
[10:21:19.554]                             if (!grepl(pattern, name)) 
[10:21:19.554]                               next
[10:21:19.554]                             invokeRestart(restart)
[10:21:19.554]                             muffled <- TRUE
[10:21:19.554]                             break
[10:21:19.554]                           }
[10:21:19.554]                         }
[10:21:19.554]                       }
[10:21:19.554]                       invisible(muffled)
[10:21:19.554]                     }
[10:21:19.554]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.554]                   }
[10:21:19.554]                 }
[10:21:19.554]                 else {
[10:21:19.554]                   if (TRUE) {
[10:21:19.554]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.554]                     {
[10:21:19.554]                       inherits <- base::inherits
[10:21:19.554]                       invokeRestart <- base::invokeRestart
[10:21:19.554]                       is.null <- base::is.null
[10:21:19.554]                       muffled <- FALSE
[10:21:19.554]                       if (inherits(cond, "message")) {
[10:21:19.554]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.554]                         if (muffled) 
[10:21:19.554]                           invokeRestart("muffleMessage")
[10:21:19.554]                       }
[10:21:19.554]                       else if (inherits(cond, "warning")) {
[10:21:19.554]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.554]                         if (muffled) 
[10:21:19.554]                           invokeRestart("muffleWarning")
[10:21:19.554]                       }
[10:21:19.554]                       else if (inherits(cond, "condition")) {
[10:21:19.554]                         if (!is.null(pattern)) {
[10:21:19.554]                           computeRestarts <- base::computeRestarts
[10:21:19.554]                           grepl <- base::grepl
[10:21:19.554]                           restarts <- computeRestarts(cond)
[10:21:19.554]                           for (restart in restarts) {
[10:21:19.554]                             name <- restart$name
[10:21:19.554]                             if (is.null(name)) 
[10:21:19.554]                               next
[10:21:19.554]                             if (!grepl(pattern, name)) 
[10:21:19.554]                               next
[10:21:19.554]                             invokeRestart(restart)
[10:21:19.554]                             muffled <- TRUE
[10:21:19.554]                             break
[10:21:19.554]                           }
[10:21:19.554]                         }
[10:21:19.554]                       }
[10:21:19.554]                       invisible(muffled)
[10:21:19.554]                     }
[10:21:19.554]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.554]                   }
[10:21:19.554]                 }
[10:21:19.554]             }
[10:21:19.554]         }))
[10:21:19.554]     }, error = function(ex) {
[10:21:19.554]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.554]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.554]                 ...future.rng), started = ...future.startTime, 
[10:21:19.554]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.554]             version = "1.8"), class = "FutureResult")
[10:21:19.554]     }, finally = {
[10:21:19.554]         if (!identical(...future.workdir, getwd())) 
[10:21:19.554]             setwd(...future.workdir)
[10:21:19.554]         {
[10:21:19.554]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.554]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.554]             }
[10:21:19.554]             base::options(...future.oldOptions)
[10:21:19.554]             if (.Platform$OS.type == "windows") {
[10:21:19.554]                 old_names <- names(...future.oldEnvVars)
[10:21:19.554]                 envs <- base::Sys.getenv()
[10:21:19.554]                 names <- names(envs)
[10:21:19.554]                 common <- intersect(names, old_names)
[10:21:19.554]                 added <- setdiff(names, old_names)
[10:21:19.554]                 removed <- setdiff(old_names, names)
[10:21:19.554]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.554]                   envs[common]]
[10:21:19.554]                 NAMES <- toupper(changed)
[10:21:19.554]                 args <- list()
[10:21:19.554]                 for (kk in seq_along(NAMES)) {
[10:21:19.554]                   name <- changed[[kk]]
[10:21:19.554]                   NAME <- NAMES[[kk]]
[10:21:19.554]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.554]                     next
[10:21:19.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.554]                 }
[10:21:19.554]                 NAMES <- toupper(added)
[10:21:19.554]                 for (kk in seq_along(NAMES)) {
[10:21:19.554]                   name <- added[[kk]]
[10:21:19.554]                   NAME <- NAMES[[kk]]
[10:21:19.554]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.554]                     next
[10:21:19.554]                   args[[name]] <- ""
[10:21:19.554]                 }
[10:21:19.554]                 NAMES <- toupper(removed)
[10:21:19.554]                 for (kk in seq_along(NAMES)) {
[10:21:19.554]                   name <- removed[[kk]]
[10:21:19.554]                   NAME <- NAMES[[kk]]
[10:21:19.554]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.554]                     next
[10:21:19.554]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.554]                 }
[10:21:19.554]                 if (length(args) > 0) 
[10:21:19.554]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.554]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.554]             }
[10:21:19.554]             else {
[10:21:19.554]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.554]             }
[10:21:19.554]             {
[10:21:19.554]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.554]                   0L) {
[10:21:19.554]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.554]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.554]                   base::options(opts)
[10:21:19.554]                 }
[10:21:19.554]                 {
[10:21:19.554]                   {
[10:21:19.554]                     NULL
[10:21:19.554]                     RNGkind("Mersenne-Twister")
[10:21:19.554]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.554]                       inherits = FALSE)
[10:21:19.554]                   }
[10:21:19.554]                   options(future.plan = NULL)
[10:21:19.554]                   if (is.na(NA_character_)) 
[10:21:19.554]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.554]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.554]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.554]                     .init = FALSE)
[10:21:19.554]                 }
[10:21:19.554]             }
[10:21:19.554]         }
[10:21:19.554]     })
[10:21:19.554]     if (TRUE) {
[10:21:19.554]         base::sink(type = "output", split = FALSE)
[10:21:19.554]         if (TRUE) {
[10:21:19.554]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.554]         }
[10:21:19.554]         else {
[10:21:19.554]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.554]         }
[10:21:19.554]         base::close(...future.stdout)
[10:21:19.554]         ...future.stdout <- NULL
[10:21:19.554]     }
[10:21:19.554]     ...future.result$conditions <- ...future.conditions
[10:21:19.554]     ...future.result$finished <- base::Sys.time()
[10:21:19.554]     ...future.result
[10:21:19.554] }
[10:21:19.556] plan(): Setting new future strategy stack:
[10:21:19.556] List of future strategies:
[10:21:19.556] 1. sequential:
[10:21:19.556]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.556]    - tweaked: FALSE
[10:21:19.556]    - call: NULL
[10:21:19.556] plan(): nbrOfWorkers() = 1
[10:21:19.557] plan(): Setting new future strategy stack:
[10:21:19.557] List of future strategies:
[10:21:19.557] 1. sequential:
[10:21:19.557]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.557]    - tweaked: FALSE
[10:21:19.557]    - call: plan(strategy)
[10:21:19.557] plan(): nbrOfWorkers() = 1
[10:21:19.558] SequentialFuture started (and completed)
[10:21:19.558] - Launch lazy future ... done
[10:21:19.558] run() for ‘SequentialFuture’ ... done
[10:21:19.558] getGlobalsAndPackages() ...
[10:21:19.558] Searching for globals...
[10:21:19.558] 
[10:21:19.558] Searching for globals ... DONE
[10:21:19.558] - globals: [0] <none>
[10:21:19.558] getGlobalsAndPackages() ... DONE
[10:21:19.559] run() for ‘Future’ ...
[10:21:19.559] - state: ‘created’
[10:21:19.559] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.559] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.559]   - Field: ‘label’
[10:21:19.559]   - Field: ‘local’
[10:21:19.559]   - Field: ‘owner’
[10:21:19.559]   - Field: ‘envir’
[10:21:19.560]   - Field: ‘packages’
[10:21:19.560]   - Field: ‘gc’
[10:21:19.560]   - Field: ‘conditions’
[10:21:19.560]   - Field: ‘expr’
[10:21:19.560]   - Field: ‘uuid’
[10:21:19.560]   - Field: ‘seed’
[10:21:19.560]   - Field: ‘version’
[10:21:19.560]   - Field: ‘result’
[10:21:19.560]   - Field: ‘asynchronous’
[10:21:19.560]   - Field: ‘calls’
[10:21:19.560]   - Field: ‘globals’
[10:21:19.560]   - Field: ‘stdout’
[10:21:19.560]   - Field: ‘earlySignal’
[10:21:19.561]   - Field: ‘lazy’
[10:21:19.561]   - Field: ‘state’
[10:21:19.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.561] - Launch lazy future ...
[10:21:19.561] Packages needed by the future expression (n = 0): <none>
[10:21:19.561] Packages needed by future strategies (n = 0): <none>
[10:21:19.561] {
[10:21:19.561]     {
[10:21:19.561]         {
[10:21:19.561]             ...future.startTime <- base::Sys.time()
[10:21:19.561]             {
[10:21:19.561]                 {
[10:21:19.561]                   {
[10:21:19.561]                     base::local({
[10:21:19.561]                       has_future <- base::requireNamespace("future", 
[10:21:19.561]                         quietly = TRUE)
[10:21:19.561]                       if (has_future) {
[10:21:19.561]                         ns <- base::getNamespace("future")
[10:21:19.561]                         version <- ns[[".package"]][["version"]]
[10:21:19.561]                         if (is.null(version)) 
[10:21:19.561]                           version <- utils::packageVersion("future")
[10:21:19.561]                       }
[10:21:19.561]                       else {
[10:21:19.561]                         version <- NULL
[10:21:19.561]                       }
[10:21:19.561]                       if (!has_future || version < "1.8.0") {
[10:21:19.561]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.561]                           "", base::R.version$version.string), 
[10:21:19.561]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.561]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.561]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.561]                             "release", "version")], collapse = " "), 
[10:21:19.561]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.561]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.561]                           info)
[10:21:19.561]                         info <- base::paste(info, collapse = "; ")
[10:21:19.561]                         if (!has_future) {
[10:21:19.561]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.561]                             info)
[10:21:19.561]                         }
[10:21:19.561]                         else {
[10:21:19.561]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.561]                             info, version)
[10:21:19.561]                         }
[10:21:19.561]                         base::stop(msg)
[10:21:19.561]                       }
[10:21:19.561]                     })
[10:21:19.561]                   }
[10:21:19.561]                   ...future.strategy.old <- future::plan("list")
[10:21:19.561]                   options(future.plan = NULL)
[10:21:19.561]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.561]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.561]                 }
[10:21:19.561]                 ...future.workdir <- getwd()
[10:21:19.561]             }
[10:21:19.561]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.561]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.561]         }
[10:21:19.561]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.561]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.561]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.561]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.561]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.561]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.561]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.561]             base::names(...future.oldOptions))
[10:21:19.561]     }
[10:21:19.561]     if (FALSE) {
[10:21:19.561]     }
[10:21:19.561]     else {
[10:21:19.561]         if (TRUE) {
[10:21:19.561]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.561]                 open = "w")
[10:21:19.561]         }
[10:21:19.561]         else {
[10:21:19.561]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.561]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.561]         }
[10:21:19.561]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.561]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.561]             base::sink(type = "output", split = FALSE)
[10:21:19.561]             base::close(...future.stdout)
[10:21:19.561]         }, add = TRUE)
[10:21:19.561]     }
[10:21:19.561]     ...future.frame <- base::sys.nframe()
[10:21:19.561]     ...future.conditions <- base::list()
[10:21:19.561]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.561]     if (FALSE) {
[10:21:19.561]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.561]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.561]     }
[10:21:19.561]     ...future.result <- base::tryCatch({
[10:21:19.561]         base::withCallingHandlers({
[10:21:19.561]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.561]             future::FutureResult(value = ...future.value$value, 
[10:21:19.561]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.561]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.561]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.561]                     ...future.globalenv.names))
[10:21:19.561]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.561]         }, condition = base::local({
[10:21:19.561]             c <- base::c
[10:21:19.561]             inherits <- base::inherits
[10:21:19.561]             invokeRestart <- base::invokeRestart
[10:21:19.561]             length <- base::length
[10:21:19.561]             list <- base::list
[10:21:19.561]             seq.int <- base::seq.int
[10:21:19.561]             signalCondition <- base::signalCondition
[10:21:19.561]             sys.calls <- base::sys.calls
[10:21:19.561]             `[[` <- base::`[[`
[10:21:19.561]             `+` <- base::`+`
[10:21:19.561]             `<<-` <- base::`<<-`
[10:21:19.561]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.561]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.561]                   3L)]
[10:21:19.561]             }
[10:21:19.561]             function(cond) {
[10:21:19.561]                 is_error <- inherits(cond, "error")
[10:21:19.561]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.561]                   NULL)
[10:21:19.561]                 if (is_error) {
[10:21:19.561]                   sessionInformation <- function() {
[10:21:19.561]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.561]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.561]                       search = base::search(), system = base::Sys.info())
[10:21:19.561]                   }
[10:21:19.561]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.561]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.561]                     cond$call), session = sessionInformation(), 
[10:21:19.561]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.561]                   signalCondition(cond)
[10:21:19.561]                 }
[10:21:19.561]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.561]                 "immediateCondition"))) {
[10:21:19.561]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.561]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.561]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.561]                   if (TRUE && !signal) {
[10:21:19.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.561]                     {
[10:21:19.561]                       inherits <- base::inherits
[10:21:19.561]                       invokeRestart <- base::invokeRestart
[10:21:19.561]                       is.null <- base::is.null
[10:21:19.561]                       muffled <- FALSE
[10:21:19.561]                       if (inherits(cond, "message")) {
[10:21:19.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.561]                         if (muffled) 
[10:21:19.561]                           invokeRestart("muffleMessage")
[10:21:19.561]                       }
[10:21:19.561]                       else if (inherits(cond, "warning")) {
[10:21:19.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.561]                         if (muffled) 
[10:21:19.561]                           invokeRestart("muffleWarning")
[10:21:19.561]                       }
[10:21:19.561]                       else if (inherits(cond, "condition")) {
[10:21:19.561]                         if (!is.null(pattern)) {
[10:21:19.561]                           computeRestarts <- base::computeRestarts
[10:21:19.561]                           grepl <- base::grepl
[10:21:19.561]                           restarts <- computeRestarts(cond)
[10:21:19.561]                           for (restart in restarts) {
[10:21:19.561]                             name <- restart$name
[10:21:19.561]                             if (is.null(name)) 
[10:21:19.561]                               next
[10:21:19.561]                             if (!grepl(pattern, name)) 
[10:21:19.561]                               next
[10:21:19.561]                             invokeRestart(restart)
[10:21:19.561]                             muffled <- TRUE
[10:21:19.561]                             break
[10:21:19.561]                           }
[10:21:19.561]                         }
[10:21:19.561]                       }
[10:21:19.561]                       invisible(muffled)
[10:21:19.561]                     }
[10:21:19.561]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.561]                   }
[10:21:19.561]                 }
[10:21:19.561]                 else {
[10:21:19.561]                   if (TRUE) {
[10:21:19.561]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.561]                     {
[10:21:19.561]                       inherits <- base::inherits
[10:21:19.561]                       invokeRestart <- base::invokeRestart
[10:21:19.561]                       is.null <- base::is.null
[10:21:19.561]                       muffled <- FALSE
[10:21:19.561]                       if (inherits(cond, "message")) {
[10:21:19.561]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.561]                         if (muffled) 
[10:21:19.561]                           invokeRestart("muffleMessage")
[10:21:19.561]                       }
[10:21:19.561]                       else if (inherits(cond, "warning")) {
[10:21:19.561]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.561]                         if (muffled) 
[10:21:19.561]                           invokeRestart("muffleWarning")
[10:21:19.561]                       }
[10:21:19.561]                       else if (inherits(cond, "condition")) {
[10:21:19.561]                         if (!is.null(pattern)) {
[10:21:19.561]                           computeRestarts <- base::computeRestarts
[10:21:19.561]                           grepl <- base::grepl
[10:21:19.561]                           restarts <- computeRestarts(cond)
[10:21:19.561]                           for (restart in restarts) {
[10:21:19.561]                             name <- restart$name
[10:21:19.561]                             if (is.null(name)) 
[10:21:19.561]                               next
[10:21:19.561]                             if (!grepl(pattern, name)) 
[10:21:19.561]                               next
[10:21:19.561]                             invokeRestart(restart)
[10:21:19.561]                             muffled <- TRUE
[10:21:19.561]                             break
[10:21:19.561]                           }
[10:21:19.561]                         }
[10:21:19.561]                       }
[10:21:19.561]                       invisible(muffled)
[10:21:19.561]                     }
[10:21:19.561]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.561]                   }
[10:21:19.561]                 }
[10:21:19.561]             }
[10:21:19.561]         }))
[10:21:19.561]     }, error = function(ex) {
[10:21:19.561]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.561]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.561]                 ...future.rng), started = ...future.startTime, 
[10:21:19.561]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.561]             version = "1.8"), class = "FutureResult")
[10:21:19.561]     }, finally = {
[10:21:19.561]         if (!identical(...future.workdir, getwd())) 
[10:21:19.561]             setwd(...future.workdir)
[10:21:19.561]         {
[10:21:19.561]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.561]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.561]             }
[10:21:19.561]             base::options(...future.oldOptions)
[10:21:19.561]             if (.Platform$OS.type == "windows") {
[10:21:19.561]                 old_names <- names(...future.oldEnvVars)
[10:21:19.561]                 envs <- base::Sys.getenv()
[10:21:19.561]                 names <- names(envs)
[10:21:19.561]                 common <- intersect(names, old_names)
[10:21:19.561]                 added <- setdiff(names, old_names)
[10:21:19.561]                 removed <- setdiff(old_names, names)
[10:21:19.561]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.561]                   envs[common]]
[10:21:19.561]                 NAMES <- toupper(changed)
[10:21:19.561]                 args <- list()
[10:21:19.561]                 for (kk in seq_along(NAMES)) {
[10:21:19.561]                   name <- changed[[kk]]
[10:21:19.561]                   NAME <- NAMES[[kk]]
[10:21:19.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.561]                     next
[10:21:19.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.561]                 }
[10:21:19.561]                 NAMES <- toupper(added)
[10:21:19.561]                 for (kk in seq_along(NAMES)) {
[10:21:19.561]                   name <- added[[kk]]
[10:21:19.561]                   NAME <- NAMES[[kk]]
[10:21:19.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.561]                     next
[10:21:19.561]                   args[[name]] <- ""
[10:21:19.561]                 }
[10:21:19.561]                 NAMES <- toupper(removed)
[10:21:19.561]                 for (kk in seq_along(NAMES)) {
[10:21:19.561]                   name <- removed[[kk]]
[10:21:19.561]                   NAME <- NAMES[[kk]]
[10:21:19.561]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.561]                     next
[10:21:19.561]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.561]                 }
[10:21:19.561]                 if (length(args) > 0) 
[10:21:19.561]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.561]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.561]             }
[10:21:19.561]             else {
[10:21:19.561]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.561]             }
[10:21:19.561]             {
[10:21:19.561]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.561]                   0L) {
[10:21:19.561]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.561]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.561]                   base::options(opts)
[10:21:19.561]                 }
[10:21:19.561]                 {
[10:21:19.561]                   {
[10:21:19.561]                     NULL
[10:21:19.561]                     RNGkind("Mersenne-Twister")
[10:21:19.561]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.561]                       inherits = FALSE)
[10:21:19.561]                   }
[10:21:19.561]                   options(future.plan = NULL)
[10:21:19.561]                   if (is.na(NA_character_)) 
[10:21:19.561]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.561]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.561]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.561]                     .init = FALSE)
[10:21:19.561]                 }
[10:21:19.561]             }
[10:21:19.561]         }
[10:21:19.561]     })
[10:21:19.561]     if (TRUE) {
[10:21:19.561]         base::sink(type = "output", split = FALSE)
[10:21:19.561]         if (TRUE) {
[10:21:19.561]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.561]         }
[10:21:19.561]         else {
[10:21:19.561]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.561]         }
[10:21:19.561]         base::close(...future.stdout)
[10:21:19.561]         ...future.stdout <- NULL
[10:21:19.561]     }
[10:21:19.561]     ...future.result$conditions <- ...future.conditions
[10:21:19.561]     ...future.result$finished <- base::Sys.time()
[10:21:19.561]     ...future.result
[10:21:19.561] }
[10:21:19.563] plan(): Setting new future strategy stack:
[10:21:19.563] List of future strategies:
[10:21:19.563] 1. sequential:
[10:21:19.563]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.563]    - tweaked: FALSE
[10:21:19.563]    - call: NULL
[10:21:19.564] plan(): nbrOfWorkers() = 1
[10:21:19.564] plan(): Setting new future strategy stack:
[10:21:19.564] List of future strategies:
[10:21:19.564] 1. sequential:
[10:21:19.564]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.564]    - tweaked: FALSE
[10:21:19.564]    - call: plan(strategy)
[10:21:19.565] plan(): nbrOfWorkers() = 1
[10:21:19.565] SequentialFuture started (and completed)
[10:21:19.565] - Launch lazy future ... done
[10:21:19.565] run() for ‘SequentialFuture’ ... done
[10:21:19.566] getGlobalsAndPackages() ...
[10:21:19.566] Searching for globals...
[10:21:19.590] - globals found: [1] ‘{’
[10:21:19.590] Searching for globals ... DONE
[10:21:19.591] Resolving globals: FALSE
[10:21:19.591] 
[10:21:19.591] 
[10:21:19.591] getGlobalsAndPackages() ... DONE
[10:21:19.591] run() for ‘Future’ ...
[10:21:19.591] - state: ‘created’
[10:21:19.592] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.592] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.592] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.592]   - Field: ‘label’
[10:21:19.592]   - Field: ‘local’
[10:21:19.592]   - Field: ‘owner’
[10:21:19.592]   - Field: ‘envir’
[10:21:19.592]   - Field: ‘packages’
[10:21:19.593]   - Field: ‘gc’
[10:21:19.593]   - Field: ‘conditions’
[10:21:19.593]   - Field: ‘expr’
[10:21:19.593]   - Field: ‘uuid’
[10:21:19.593]   - Field: ‘seed’
[10:21:19.593]   - Field: ‘version’
[10:21:19.593]   - Field: ‘result’
[10:21:19.593]   - Field: ‘asynchronous’
[10:21:19.593]   - Field: ‘calls’
[10:21:19.593]   - Field: ‘globals’
[10:21:19.593]   - Field: ‘stdout’
[10:21:19.593]   - Field: ‘earlySignal’
[10:21:19.593]   - Field: ‘lazy’
[10:21:19.594]   - Field: ‘state’
[10:21:19.594] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.594] - Launch lazy future ...
[10:21:19.594] Packages needed by the future expression (n = 0): <none>
[10:21:19.594] Packages needed by future strategies (n = 0): <none>
[10:21:19.594] {
[10:21:19.594]     {
[10:21:19.594]         {
[10:21:19.594]             ...future.startTime <- base::Sys.time()
[10:21:19.594]             {
[10:21:19.594]                 {
[10:21:19.594]                   {
[10:21:19.594]                     base::local({
[10:21:19.594]                       has_future <- base::requireNamespace("future", 
[10:21:19.594]                         quietly = TRUE)
[10:21:19.594]                       if (has_future) {
[10:21:19.594]                         ns <- base::getNamespace("future")
[10:21:19.594]                         version <- ns[[".package"]][["version"]]
[10:21:19.594]                         if (is.null(version)) 
[10:21:19.594]                           version <- utils::packageVersion("future")
[10:21:19.594]                       }
[10:21:19.594]                       else {
[10:21:19.594]                         version <- NULL
[10:21:19.594]                       }
[10:21:19.594]                       if (!has_future || version < "1.8.0") {
[10:21:19.594]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.594]                           "", base::R.version$version.string), 
[10:21:19.594]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.594]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.594]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.594]                             "release", "version")], collapse = " "), 
[10:21:19.594]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.594]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.594]                           info)
[10:21:19.594]                         info <- base::paste(info, collapse = "; ")
[10:21:19.594]                         if (!has_future) {
[10:21:19.594]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.594]                             info)
[10:21:19.594]                         }
[10:21:19.594]                         else {
[10:21:19.594]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.594]                             info, version)
[10:21:19.594]                         }
[10:21:19.594]                         base::stop(msg)
[10:21:19.594]                       }
[10:21:19.594]                     })
[10:21:19.594]                   }
[10:21:19.594]                   ...future.strategy.old <- future::plan("list")
[10:21:19.594]                   options(future.plan = NULL)
[10:21:19.594]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.594]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.594]                 }
[10:21:19.594]                 ...future.workdir <- getwd()
[10:21:19.594]             }
[10:21:19.594]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.594]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.594]         }
[10:21:19.594]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.594]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.594]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.594]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.594]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.594]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.594]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.594]             base::names(...future.oldOptions))
[10:21:19.594]     }
[10:21:19.594]     if (FALSE) {
[10:21:19.594]     }
[10:21:19.594]     else {
[10:21:19.594]         if (TRUE) {
[10:21:19.594]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.594]                 open = "w")
[10:21:19.594]         }
[10:21:19.594]         else {
[10:21:19.594]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.594]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.594]         }
[10:21:19.594]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.594]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.594]             base::sink(type = "output", split = FALSE)
[10:21:19.594]             base::close(...future.stdout)
[10:21:19.594]         }, add = TRUE)
[10:21:19.594]     }
[10:21:19.594]     ...future.frame <- base::sys.nframe()
[10:21:19.594]     ...future.conditions <- base::list()
[10:21:19.594]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.594]     if (FALSE) {
[10:21:19.594]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.594]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.594]     }
[10:21:19.594]     ...future.result <- base::tryCatch({
[10:21:19.594]         base::withCallingHandlers({
[10:21:19.594]             ...future.value <- base::withVisible(base::local({
[10:21:19.594]                 4
[10:21:19.594]             }))
[10:21:19.594]             future::FutureResult(value = ...future.value$value, 
[10:21:19.594]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.594]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.594]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.594]                     ...future.globalenv.names))
[10:21:19.594]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.594]         }, condition = base::local({
[10:21:19.594]             c <- base::c
[10:21:19.594]             inherits <- base::inherits
[10:21:19.594]             invokeRestart <- base::invokeRestart
[10:21:19.594]             length <- base::length
[10:21:19.594]             list <- base::list
[10:21:19.594]             seq.int <- base::seq.int
[10:21:19.594]             signalCondition <- base::signalCondition
[10:21:19.594]             sys.calls <- base::sys.calls
[10:21:19.594]             `[[` <- base::`[[`
[10:21:19.594]             `+` <- base::`+`
[10:21:19.594]             `<<-` <- base::`<<-`
[10:21:19.594]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.594]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.594]                   3L)]
[10:21:19.594]             }
[10:21:19.594]             function(cond) {
[10:21:19.594]                 is_error <- inherits(cond, "error")
[10:21:19.594]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.594]                   NULL)
[10:21:19.594]                 if (is_error) {
[10:21:19.594]                   sessionInformation <- function() {
[10:21:19.594]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.594]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.594]                       search = base::search(), system = base::Sys.info())
[10:21:19.594]                   }
[10:21:19.594]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.594]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.594]                     cond$call), session = sessionInformation(), 
[10:21:19.594]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.594]                   signalCondition(cond)
[10:21:19.594]                 }
[10:21:19.594]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.594]                 "immediateCondition"))) {
[10:21:19.594]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.594]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.594]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.594]                   if (TRUE && !signal) {
[10:21:19.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.594]                     {
[10:21:19.594]                       inherits <- base::inherits
[10:21:19.594]                       invokeRestart <- base::invokeRestart
[10:21:19.594]                       is.null <- base::is.null
[10:21:19.594]                       muffled <- FALSE
[10:21:19.594]                       if (inherits(cond, "message")) {
[10:21:19.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.594]                         if (muffled) 
[10:21:19.594]                           invokeRestart("muffleMessage")
[10:21:19.594]                       }
[10:21:19.594]                       else if (inherits(cond, "warning")) {
[10:21:19.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.594]                         if (muffled) 
[10:21:19.594]                           invokeRestart("muffleWarning")
[10:21:19.594]                       }
[10:21:19.594]                       else if (inherits(cond, "condition")) {
[10:21:19.594]                         if (!is.null(pattern)) {
[10:21:19.594]                           computeRestarts <- base::computeRestarts
[10:21:19.594]                           grepl <- base::grepl
[10:21:19.594]                           restarts <- computeRestarts(cond)
[10:21:19.594]                           for (restart in restarts) {
[10:21:19.594]                             name <- restart$name
[10:21:19.594]                             if (is.null(name)) 
[10:21:19.594]                               next
[10:21:19.594]                             if (!grepl(pattern, name)) 
[10:21:19.594]                               next
[10:21:19.594]                             invokeRestart(restart)
[10:21:19.594]                             muffled <- TRUE
[10:21:19.594]                             break
[10:21:19.594]                           }
[10:21:19.594]                         }
[10:21:19.594]                       }
[10:21:19.594]                       invisible(muffled)
[10:21:19.594]                     }
[10:21:19.594]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.594]                   }
[10:21:19.594]                 }
[10:21:19.594]                 else {
[10:21:19.594]                   if (TRUE) {
[10:21:19.594]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.594]                     {
[10:21:19.594]                       inherits <- base::inherits
[10:21:19.594]                       invokeRestart <- base::invokeRestart
[10:21:19.594]                       is.null <- base::is.null
[10:21:19.594]                       muffled <- FALSE
[10:21:19.594]                       if (inherits(cond, "message")) {
[10:21:19.594]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.594]                         if (muffled) 
[10:21:19.594]                           invokeRestart("muffleMessage")
[10:21:19.594]                       }
[10:21:19.594]                       else if (inherits(cond, "warning")) {
[10:21:19.594]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.594]                         if (muffled) 
[10:21:19.594]                           invokeRestart("muffleWarning")
[10:21:19.594]                       }
[10:21:19.594]                       else if (inherits(cond, "condition")) {
[10:21:19.594]                         if (!is.null(pattern)) {
[10:21:19.594]                           computeRestarts <- base::computeRestarts
[10:21:19.594]                           grepl <- base::grepl
[10:21:19.594]                           restarts <- computeRestarts(cond)
[10:21:19.594]                           for (restart in restarts) {
[10:21:19.594]                             name <- restart$name
[10:21:19.594]                             if (is.null(name)) 
[10:21:19.594]                               next
[10:21:19.594]                             if (!grepl(pattern, name)) 
[10:21:19.594]                               next
[10:21:19.594]                             invokeRestart(restart)
[10:21:19.594]                             muffled <- TRUE
[10:21:19.594]                             break
[10:21:19.594]                           }
[10:21:19.594]                         }
[10:21:19.594]                       }
[10:21:19.594]                       invisible(muffled)
[10:21:19.594]                     }
[10:21:19.594]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.594]                   }
[10:21:19.594]                 }
[10:21:19.594]             }
[10:21:19.594]         }))
[10:21:19.594]     }, error = function(ex) {
[10:21:19.594]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.594]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.594]                 ...future.rng), started = ...future.startTime, 
[10:21:19.594]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.594]             version = "1.8"), class = "FutureResult")
[10:21:19.594]     }, finally = {
[10:21:19.594]         if (!identical(...future.workdir, getwd())) 
[10:21:19.594]             setwd(...future.workdir)
[10:21:19.594]         {
[10:21:19.594]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.594]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.594]             }
[10:21:19.594]             base::options(...future.oldOptions)
[10:21:19.594]             if (.Platform$OS.type == "windows") {
[10:21:19.594]                 old_names <- names(...future.oldEnvVars)
[10:21:19.594]                 envs <- base::Sys.getenv()
[10:21:19.594]                 names <- names(envs)
[10:21:19.594]                 common <- intersect(names, old_names)
[10:21:19.594]                 added <- setdiff(names, old_names)
[10:21:19.594]                 removed <- setdiff(old_names, names)
[10:21:19.594]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.594]                   envs[common]]
[10:21:19.594]                 NAMES <- toupper(changed)
[10:21:19.594]                 args <- list()
[10:21:19.594]                 for (kk in seq_along(NAMES)) {
[10:21:19.594]                   name <- changed[[kk]]
[10:21:19.594]                   NAME <- NAMES[[kk]]
[10:21:19.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.594]                     next
[10:21:19.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.594]                 }
[10:21:19.594]                 NAMES <- toupper(added)
[10:21:19.594]                 for (kk in seq_along(NAMES)) {
[10:21:19.594]                   name <- added[[kk]]
[10:21:19.594]                   NAME <- NAMES[[kk]]
[10:21:19.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.594]                     next
[10:21:19.594]                   args[[name]] <- ""
[10:21:19.594]                 }
[10:21:19.594]                 NAMES <- toupper(removed)
[10:21:19.594]                 for (kk in seq_along(NAMES)) {
[10:21:19.594]                   name <- removed[[kk]]
[10:21:19.594]                   NAME <- NAMES[[kk]]
[10:21:19.594]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.594]                     next
[10:21:19.594]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.594]                 }
[10:21:19.594]                 if (length(args) > 0) 
[10:21:19.594]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.594]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.594]             }
[10:21:19.594]             else {
[10:21:19.594]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.594]             }
[10:21:19.594]             {
[10:21:19.594]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.594]                   0L) {
[10:21:19.594]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.594]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.594]                   base::options(opts)
[10:21:19.594]                 }
[10:21:19.594]                 {
[10:21:19.594]                   {
[10:21:19.594]                     NULL
[10:21:19.594]                     RNGkind("Mersenne-Twister")
[10:21:19.594]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.594]                       inherits = FALSE)
[10:21:19.594]                   }
[10:21:19.594]                   options(future.plan = NULL)
[10:21:19.594]                   if (is.na(NA_character_)) 
[10:21:19.594]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.594]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.594]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.594]                     .init = FALSE)
[10:21:19.594]                 }
[10:21:19.594]             }
[10:21:19.594]         }
[10:21:19.594]     })
[10:21:19.594]     if (TRUE) {
[10:21:19.594]         base::sink(type = "output", split = FALSE)
[10:21:19.594]         if (TRUE) {
[10:21:19.594]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.594]         }
[10:21:19.594]         else {
[10:21:19.594]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.594]         }
[10:21:19.594]         base::close(...future.stdout)
[10:21:19.594]         ...future.stdout <- NULL
[10:21:19.594]     }
[10:21:19.594]     ...future.result$conditions <- ...future.conditions
[10:21:19.594]     ...future.result$finished <- base::Sys.time()
[10:21:19.594]     ...future.result
[10:21:19.594] }
[10:21:19.596] plan(): Setting new future strategy stack:
[10:21:19.596] List of future strategies:
[10:21:19.596] 1. sequential:
[10:21:19.596]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.596]    - tweaked: FALSE
[10:21:19.596]    - call: NULL
[10:21:19.597] plan(): nbrOfWorkers() = 1
[10:21:19.597] plan(): Setting new future strategy stack:
[10:21:19.598] List of future strategies:
[10:21:19.598] 1. sequential:
[10:21:19.598]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.598]    - tweaked: FALSE
[10:21:19.598]    - call: plan(strategy)
[10:21:19.598] plan(): nbrOfWorkers() = 1
[10:21:19.598] SequentialFuture started (and completed)
[10:21:19.598] - Launch lazy future ... done
[10:21:19.598] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e476d5b0> 
Classes 'listenv', 'environment' <environment: 0x55e8e3157840> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:21:19.602] resolved() for ‘SequentialFuture’ ...
[10:21:19.602] - state: ‘finished’
[10:21:19.602] - run: TRUE
[10:21:19.602] - result: ‘FutureResult’
[10:21:19.602] resolved() for ‘SequentialFuture’ ... done
[10:21:19.602] resolved() for ‘SequentialFuture’ ...
[10:21:19.602] - state: ‘finished’
[10:21:19.602] - run: TRUE
[10:21:19.602] - result: ‘FutureResult’
[10:21:19.602] resolved() for ‘SequentialFuture’ ... done
[10:21:19.603] resolved() for ‘SequentialFuture’ ...
[10:21:19.603] - state: ‘finished’
[10:21:19.603] - run: TRUE
[10:21:19.603] - result: ‘FutureResult’
[10:21:19.603] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:19.605] resolve() on list environment ...
[10:21:19.605]  recursive: 0
[10:21:19.606]  length: 6
[10:21:19.606]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:19.606] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.606] - nx: 6
[10:21:19.606] - relay: TRUE
[10:21:19.606] - stdout: TRUE
[10:21:19.606] - signal: TRUE
[10:21:19.607] - resignal: FALSE
[10:21:19.607] - force: TRUE
[10:21:19.607] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.607] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.607]  - until=2
[10:21:19.607]  - relaying element #2
[10:21:19.607] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.607] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.607] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.607]  length: 5 (resolved future 1)
[10:21:19.607] resolved() for ‘SequentialFuture’ ...
[10:21:19.607] - state: ‘finished’
[10:21:19.608] - run: TRUE
[10:21:19.608] - result: ‘FutureResult’
[10:21:19.608] resolved() for ‘SequentialFuture’ ... done
[10:21:19.608] Future #2
[10:21:19.608] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.608] - nx: 6
[10:21:19.608] - relay: TRUE
[10:21:19.608] - stdout: TRUE
[10:21:19.608] - signal: TRUE
[10:21:19.608] - resignal: FALSE
[10:21:19.608] - force: TRUE
[10:21:19.608] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.609] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.609]  - until=2
[10:21:19.609]  - relaying element #2
[10:21:19.609] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.609] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.609] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.609]  length: 4 (resolved future 2)
[10:21:19.609] resolved() for ‘SequentialFuture’ ...
[10:21:19.609] - state: ‘finished’
[10:21:19.609] - run: TRUE
[10:21:19.609] - result: ‘FutureResult’
[10:21:19.610] resolved() for ‘SequentialFuture’ ... done
[10:21:19.610] Future #3
[10:21:19.610] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.610] - nx: 6
[10:21:19.610] - relay: TRUE
[10:21:19.610] - stdout: TRUE
[10:21:19.610] - signal: TRUE
[10:21:19.610] - resignal: FALSE
[10:21:19.610] - force: TRUE
[10:21:19.610] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.610] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.610]  - until=3
[10:21:19.611]  - relaying element #3
[10:21:19.611] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.611] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.611] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.611]  length: 3 (resolved future 3)
[10:21:19.611] resolved() for ‘SequentialFuture’ ...
[10:21:19.611] - state: ‘finished’
[10:21:19.611] - run: TRUE
[10:21:19.611] - result: ‘FutureResult’
[10:21:19.611] resolved() for ‘SequentialFuture’ ... done
[10:21:19.611] Future #4
[10:21:19.612] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.612] - nx: 6
[10:21:19.612] - relay: TRUE
[10:21:19.612] - stdout: TRUE
[10:21:19.612] - signal: TRUE
[10:21:19.612] - resignal: FALSE
[10:21:19.612] - force: TRUE
[10:21:19.612] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.612] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.612]  - until=4
[10:21:19.612]  - relaying element #4
[10:21:19.613] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.613] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.613] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.613]  length: 2 (resolved future 4)
[10:21:19.613] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.613] - nx: 6
[10:21:19.613] - relay: TRUE
[10:21:19.613] - stdout: TRUE
[10:21:19.613] - signal: TRUE
[10:21:19.613] - resignal: FALSE
[10:21:19.613] - force: TRUE
[10:21:19.613] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.614] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.614]  - until=6
[10:21:19.614]  - relaying element #6
[10:21:19.614] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.614] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.614] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.614]  length: 1 (resolved future 5)
[10:21:19.614] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.614] - nx: 6
[10:21:19.614] - relay: TRUE
[10:21:19.615] - stdout: TRUE
[10:21:19.615] - signal: TRUE
[10:21:19.615] - resignal: FALSE
[10:21:19.616] - force: TRUE
[10:21:19.616] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.616] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.616]  - until=6
[10:21:19.616] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.616] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.616] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.616]  length: 0 (resolved future 6)
[10:21:19.616] Relaying remaining futures
[10:21:19.616] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.616] - nx: 6
[10:21:19.617] - relay: TRUE
[10:21:19.617] - stdout: TRUE
[10:21:19.617] - signal: TRUE
[10:21:19.617] - resignal: FALSE
[10:21:19.617] - force: TRUE
[10:21:19.617] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.617] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:19.617] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.617] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.617] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.617] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55e8e4e3d990> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:21:19.619] getGlobalsAndPackages() ...
[10:21:19.619] Searching for globals...
[10:21:19.620] 
[10:21:19.620] Searching for globals ... DONE
[10:21:19.620] - globals: [0] <none>
[10:21:19.620] getGlobalsAndPackages() ... DONE
[10:21:19.620] run() for ‘Future’ ...
[10:21:19.620] - state: ‘created’
[10:21:19.620] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.620] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.621] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.621]   - Field: ‘label’
[10:21:19.621]   - Field: ‘local’
[10:21:19.621]   - Field: ‘owner’
[10:21:19.621]   - Field: ‘envir’
[10:21:19.621]   - Field: ‘packages’
[10:21:19.621]   - Field: ‘gc’
[10:21:19.621]   - Field: ‘conditions’
[10:21:19.621]   - Field: ‘expr’
[10:21:19.621]   - Field: ‘uuid’
[10:21:19.621]   - Field: ‘seed’
[10:21:19.622]   - Field: ‘version’
[10:21:19.622]   - Field: ‘result’
[10:21:19.622]   - Field: ‘asynchronous’
[10:21:19.622]   - Field: ‘calls’
[10:21:19.622]   - Field: ‘globals’
[10:21:19.622]   - Field: ‘stdout’
[10:21:19.622]   - Field: ‘earlySignal’
[10:21:19.622]   - Field: ‘lazy’
[10:21:19.622]   - Field: ‘state’
[10:21:19.622] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.622] - Launch lazy future ...
[10:21:19.622] Packages needed by the future expression (n = 0): <none>
[10:21:19.623] Packages needed by future strategies (n = 0): <none>
[10:21:19.623] {
[10:21:19.623]     {
[10:21:19.623]         {
[10:21:19.623]             ...future.startTime <- base::Sys.time()
[10:21:19.623]             {
[10:21:19.623]                 {
[10:21:19.623]                   {
[10:21:19.623]                     base::local({
[10:21:19.623]                       has_future <- base::requireNamespace("future", 
[10:21:19.623]                         quietly = TRUE)
[10:21:19.623]                       if (has_future) {
[10:21:19.623]                         ns <- base::getNamespace("future")
[10:21:19.623]                         version <- ns[[".package"]][["version"]]
[10:21:19.623]                         if (is.null(version)) 
[10:21:19.623]                           version <- utils::packageVersion("future")
[10:21:19.623]                       }
[10:21:19.623]                       else {
[10:21:19.623]                         version <- NULL
[10:21:19.623]                       }
[10:21:19.623]                       if (!has_future || version < "1.8.0") {
[10:21:19.623]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.623]                           "", base::R.version$version.string), 
[10:21:19.623]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.623]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.623]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.623]                             "release", "version")], collapse = " "), 
[10:21:19.623]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.623]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.623]                           info)
[10:21:19.623]                         info <- base::paste(info, collapse = "; ")
[10:21:19.623]                         if (!has_future) {
[10:21:19.623]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.623]                             info)
[10:21:19.623]                         }
[10:21:19.623]                         else {
[10:21:19.623]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.623]                             info, version)
[10:21:19.623]                         }
[10:21:19.623]                         base::stop(msg)
[10:21:19.623]                       }
[10:21:19.623]                     })
[10:21:19.623]                   }
[10:21:19.623]                   ...future.strategy.old <- future::plan("list")
[10:21:19.623]                   options(future.plan = NULL)
[10:21:19.623]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.623]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.623]                 }
[10:21:19.623]                 ...future.workdir <- getwd()
[10:21:19.623]             }
[10:21:19.623]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.623]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.623]         }
[10:21:19.623]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.623]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.623]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.623]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.623]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.623]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.623]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.623]             base::names(...future.oldOptions))
[10:21:19.623]     }
[10:21:19.623]     if (FALSE) {
[10:21:19.623]     }
[10:21:19.623]     else {
[10:21:19.623]         if (TRUE) {
[10:21:19.623]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.623]                 open = "w")
[10:21:19.623]         }
[10:21:19.623]         else {
[10:21:19.623]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.623]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.623]         }
[10:21:19.623]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.623]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.623]             base::sink(type = "output", split = FALSE)
[10:21:19.623]             base::close(...future.stdout)
[10:21:19.623]         }, add = TRUE)
[10:21:19.623]     }
[10:21:19.623]     ...future.frame <- base::sys.nframe()
[10:21:19.623]     ...future.conditions <- base::list()
[10:21:19.623]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.623]     if (FALSE) {
[10:21:19.623]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.623]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.623]     }
[10:21:19.623]     ...future.result <- base::tryCatch({
[10:21:19.623]         base::withCallingHandlers({
[10:21:19.623]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.623]             future::FutureResult(value = ...future.value$value, 
[10:21:19.623]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.623]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.623]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.623]                     ...future.globalenv.names))
[10:21:19.623]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.623]         }, condition = base::local({
[10:21:19.623]             c <- base::c
[10:21:19.623]             inherits <- base::inherits
[10:21:19.623]             invokeRestart <- base::invokeRestart
[10:21:19.623]             length <- base::length
[10:21:19.623]             list <- base::list
[10:21:19.623]             seq.int <- base::seq.int
[10:21:19.623]             signalCondition <- base::signalCondition
[10:21:19.623]             sys.calls <- base::sys.calls
[10:21:19.623]             `[[` <- base::`[[`
[10:21:19.623]             `+` <- base::`+`
[10:21:19.623]             `<<-` <- base::`<<-`
[10:21:19.623]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.623]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.623]                   3L)]
[10:21:19.623]             }
[10:21:19.623]             function(cond) {
[10:21:19.623]                 is_error <- inherits(cond, "error")
[10:21:19.623]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.623]                   NULL)
[10:21:19.623]                 if (is_error) {
[10:21:19.623]                   sessionInformation <- function() {
[10:21:19.623]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.623]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.623]                       search = base::search(), system = base::Sys.info())
[10:21:19.623]                   }
[10:21:19.623]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.623]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.623]                     cond$call), session = sessionInformation(), 
[10:21:19.623]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.623]                   signalCondition(cond)
[10:21:19.623]                 }
[10:21:19.623]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.623]                 "immediateCondition"))) {
[10:21:19.623]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.623]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.623]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.623]                   if (TRUE && !signal) {
[10:21:19.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.623]                     {
[10:21:19.623]                       inherits <- base::inherits
[10:21:19.623]                       invokeRestart <- base::invokeRestart
[10:21:19.623]                       is.null <- base::is.null
[10:21:19.623]                       muffled <- FALSE
[10:21:19.623]                       if (inherits(cond, "message")) {
[10:21:19.623]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.623]                         if (muffled) 
[10:21:19.623]                           invokeRestart("muffleMessage")
[10:21:19.623]                       }
[10:21:19.623]                       else if (inherits(cond, "warning")) {
[10:21:19.623]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.623]                         if (muffled) 
[10:21:19.623]                           invokeRestart("muffleWarning")
[10:21:19.623]                       }
[10:21:19.623]                       else if (inherits(cond, "condition")) {
[10:21:19.623]                         if (!is.null(pattern)) {
[10:21:19.623]                           computeRestarts <- base::computeRestarts
[10:21:19.623]                           grepl <- base::grepl
[10:21:19.623]                           restarts <- computeRestarts(cond)
[10:21:19.623]                           for (restart in restarts) {
[10:21:19.623]                             name <- restart$name
[10:21:19.623]                             if (is.null(name)) 
[10:21:19.623]                               next
[10:21:19.623]                             if (!grepl(pattern, name)) 
[10:21:19.623]                               next
[10:21:19.623]                             invokeRestart(restart)
[10:21:19.623]                             muffled <- TRUE
[10:21:19.623]                             break
[10:21:19.623]                           }
[10:21:19.623]                         }
[10:21:19.623]                       }
[10:21:19.623]                       invisible(muffled)
[10:21:19.623]                     }
[10:21:19.623]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.623]                   }
[10:21:19.623]                 }
[10:21:19.623]                 else {
[10:21:19.623]                   if (TRUE) {
[10:21:19.623]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.623]                     {
[10:21:19.623]                       inherits <- base::inherits
[10:21:19.623]                       invokeRestart <- base::invokeRestart
[10:21:19.623]                       is.null <- base::is.null
[10:21:19.623]                       muffled <- FALSE
[10:21:19.623]                       if (inherits(cond, "message")) {
[10:21:19.623]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.623]                         if (muffled) 
[10:21:19.623]                           invokeRestart("muffleMessage")
[10:21:19.623]                       }
[10:21:19.623]                       else if (inherits(cond, "warning")) {
[10:21:19.623]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.623]                         if (muffled) 
[10:21:19.623]                           invokeRestart("muffleWarning")
[10:21:19.623]                       }
[10:21:19.623]                       else if (inherits(cond, "condition")) {
[10:21:19.623]                         if (!is.null(pattern)) {
[10:21:19.623]                           computeRestarts <- base::computeRestarts
[10:21:19.623]                           grepl <- base::grepl
[10:21:19.623]                           restarts <- computeRestarts(cond)
[10:21:19.623]                           for (restart in restarts) {
[10:21:19.623]                             name <- restart$name
[10:21:19.623]                             if (is.null(name)) 
[10:21:19.623]                               next
[10:21:19.623]                             if (!grepl(pattern, name)) 
[10:21:19.623]                               next
[10:21:19.623]                             invokeRestart(restart)
[10:21:19.623]                             muffled <- TRUE
[10:21:19.623]                             break
[10:21:19.623]                           }
[10:21:19.623]                         }
[10:21:19.623]                       }
[10:21:19.623]                       invisible(muffled)
[10:21:19.623]                     }
[10:21:19.623]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.623]                   }
[10:21:19.623]                 }
[10:21:19.623]             }
[10:21:19.623]         }))
[10:21:19.623]     }, error = function(ex) {
[10:21:19.623]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.623]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.623]                 ...future.rng), started = ...future.startTime, 
[10:21:19.623]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.623]             version = "1.8"), class = "FutureResult")
[10:21:19.623]     }, finally = {
[10:21:19.623]         if (!identical(...future.workdir, getwd())) 
[10:21:19.623]             setwd(...future.workdir)
[10:21:19.623]         {
[10:21:19.623]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.623]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.623]             }
[10:21:19.623]             base::options(...future.oldOptions)
[10:21:19.623]             if (.Platform$OS.type == "windows") {
[10:21:19.623]                 old_names <- names(...future.oldEnvVars)
[10:21:19.623]                 envs <- base::Sys.getenv()
[10:21:19.623]                 names <- names(envs)
[10:21:19.623]                 common <- intersect(names, old_names)
[10:21:19.623]                 added <- setdiff(names, old_names)
[10:21:19.623]                 removed <- setdiff(old_names, names)
[10:21:19.623]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.623]                   envs[common]]
[10:21:19.623]                 NAMES <- toupper(changed)
[10:21:19.623]                 args <- list()
[10:21:19.623]                 for (kk in seq_along(NAMES)) {
[10:21:19.623]                   name <- changed[[kk]]
[10:21:19.623]                   NAME <- NAMES[[kk]]
[10:21:19.623]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.623]                     next
[10:21:19.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.623]                 }
[10:21:19.623]                 NAMES <- toupper(added)
[10:21:19.623]                 for (kk in seq_along(NAMES)) {
[10:21:19.623]                   name <- added[[kk]]
[10:21:19.623]                   NAME <- NAMES[[kk]]
[10:21:19.623]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.623]                     next
[10:21:19.623]                   args[[name]] <- ""
[10:21:19.623]                 }
[10:21:19.623]                 NAMES <- toupper(removed)
[10:21:19.623]                 for (kk in seq_along(NAMES)) {
[10:21:19.623]                   name <- removed[[kk]]
[10:21:19.623]                   NAME <- NAMES[[kk]]
[10:21:19.623]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.623]                     next
[10:21:19.623]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.623]                 }
[10:21:19.623]                 if (length(args) > 0) 
[10:21:19.623]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.623]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.623]             }
[10:21:19.623]             else {
[10:21:19.623]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.623]             }
[10:21:19.623]             {
[10:21:19.623]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.623]                   0L) {
[10:21:19.623]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.623]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.623]                   base::options(opts)
[10:21:19.623]                 }
[10:21:19.623]                 {
[10:21:19.623]                   {
[10:21:19.623]                     NULL
[10:21:19.623]                     RNGkind("Mersenne-Twister")
[10:21:19.623]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.623]                       inherits = FALSE)
[10:21:19.623]                   }
[10:21:19.623]                   options(future.plan = NULL)
[10:21:19.623]                   if (is.na(NA_character_)) 
[10:21:19.623]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.623]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.623]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.623]                     .init = FALSE)
[10:21:19.623]                 }
[10:21:19.623]             }
[10:21:19.623]         }
[10:21:19.623]     })
[10:21:19.623]     if (TRUE) {
[10:21:19.623]         base::sink(type = "output", split = FALSE)
[10:21:19.623]         if (TRUE) {
[10:21:19.623]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.623]         }
[10:21:19.623]         else {
[10:21:19.623]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.623]         }
[10:21:19.623]         base::close(...future.stdout)
[10:21:19.623]         ...future.stdout <- NULL
[10:21:19.623]     }
[10:21:19.623]     ...future.result$conditions <- ...future.conditions
[10:21:19.623]     ...future.result$finished <- base::Sys.time()
[10:21:19.623]     ...future.result
[10:21:19.623] }
[10:21:19.625] plan(): Setting new future strategy stack:
[10:21:19.625] List of future strategies:
[10:21:19.625] 1. sequential:
[10:21:19.625]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.625]    - tweaked: FALSE
[10:21:19.625]    - call: NULL
[10:21:19.625] plan(): nbrOfWorkers() = 1
[10:21:19.626] plan(): Setting new future strategy stack:
[10:21:19.626] List of future strategies:
[10:21:19.626] 1. sequential:
[10:21:19.626]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.626]    - tweaked: FALSE
[10:21:19.626]    - call: plan(strategy)
[10:21:19.626] plan(): nbrOfWorkers() = 1
[10:21:19.627] SequentialFuture started (and completed)
[10:21:19.627] - Launch lazy future ... done
[10:21:19.627] run() for ‘SequentialFuture’ ... done
[10:21:19.627] getGlobalsAndPackages() ...
[10:21:19.627] Searching for globals...
[10:21:19.627] 
[10:21:19.627] Searching for globals ... DONE
[10:21:19.627] - globals: [0] <none>
[10:21:19.627] getGlobalsAndPackages() ... DONE
[10:21:19.628] run() for ‘Future’ ...
[10:21:19.628] - state: ‘created’
[10:21:19.628] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.628] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.628] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.628]   - Field: ‘label’
[10:21:19.628]   - Field: ‘local’
[10:21:19.628]   - Field: ‘owner’
[10:21:19.629]   - Field: ‘envir’
[10:21:19.629]   - Field: ‘packages’
[10:21:19.629]   - Field: ‘gc’
[10:21:19.629]   - Field: ‘conditions’
[10:21:19.629]   - Field: ‘expr’
[10:21:19.629]   - Field: ‘uuid’
[10:21:19.629]   - Field: ‘seed’
[10:21:19.629]   - Field: ‘version’
[10:21:19.629]   - Field: ‘result’
[10:21:19.629]   - Field: ‘asynchronous’
[10:21:19.629]   - Field: ‘calls’
[10:21:19.630]   - Field: ‘globals’
[10:21:19.630]   - Field: ‘stdout’
[10:21:19.630]   - Field: ‘earlySignal’
[10:21:19.630]   - Field: ‘lazy’
[10:21:19.630]   - Field: ‘state’
[10:21:19.630] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.630] - Launch lazy future ...
[10:21:19.630] Packages needed by the future expression (n = 0): <none>
[10:21:19.630] Packages needed by future strategies (n = 0): <none>
[10:21:19.631] {
[10:21:19.631]     {
[10:21:19.631]         {
[10:21:19.631]             ...future.startTime <- base::Sys.time()
[10:21:19.631]             {
[10:21:19.631]                 {
[10:21:19.631]                   {
[10:21:19.631]                     base::local({
[10:21:19.631]                       has_future <- base::requireNamespace("future", 
[10:21:19.631]                         quietly = TRUE)
[10:21:19.631]                       if (has_future) {
[10:21:19.631]                         ns <- base::getNamespace("future")
[10:21:19.631]                         version <- ns[[".package"]][["version"]]
[10:21:19.631]                         if (is.null(version)) 
[10:21:19.631]                           version <- utils::packageVersion("future")
[10:21:19.631]                       }
[10:21:19.631]                       else {
[10:21:19.631]                         version <- NULL
[10:21:19.631]                       }
[10:21:19.631]                       if (!has_future || version < "1.8.0") {
[10:21:19.631]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.631]                           "", base::R.version$version.string), 
[10:21:19.631]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.631]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.631]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.631]                             "release", "version")], collapse = " "), 
[10:21:19.631]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.631]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.631]                           info)
[10:21:19.631]                         info <- base::paste(info, collapse = "; ")
[10:21:19.631]                         if (!has_future) {
[10:21:19.631]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.631]                             info)
[10:21:19.631]                         }
[10:21:19.631]                         else {
[10:21:19.631]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.631]                             info, version)
[10:21:19.631]                         }
[10:21:19.631]                         base::stop(msg)
[10:21:19.631]                       }
[10:21:19.631]                     })
[10:21:19.631]                   }
[10:21:19.631]                   ...future.strategy.old <- future::plan("list")
[10:21:19.631]                   options(future.plan = NULL)
[10:21:19.631]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.631]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.631]                 }
[10:21:19.631]                 ...future.workdir <- getwd()
[10:21:19.631]             }
[10:21:19.631]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.631]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.631]         }
[10:21:19.631]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.631]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.631]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.631]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.631]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.631]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.631]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.631]             base::names(...future.oldOptions))
[10:21:19.631]     }
[10:21:19.631]     if (FALSE) {
[10:21:19.631]     }
[10:21:19.631]     else {
[10:21:19.631]         if (TRUE) {
[10:21:19.631]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.631]                 open = "w")
[10:21:19.631]         }
[10:21:19.631]         else {
[10:21:19.631]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.631]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.631]         }
[10:21:19.631]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.631]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.631]             base::sink(type = "output", split = FALSE)
[10:21:19.631]             base::close(...future.stdout)
[10:21:19.631]         }, add = TRUE)
[10:21:19.631]     }
[10:21:19.631]     ...future.frame <- base::sys.nframe()
[10:21:19.631]     ...future.conditions <- base::list()
[10:21:19.631]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.631]     if (FALSE) {
[10:21:19.631]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.631]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.631]     }
[10:21:19.631]     ...future.result <- base::tryCatch({
[10:21:19.631]         base::withCallingHandlers({
[10:21:19.631]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.631]             future::FutureResult(value = ...future.value$value, 
[10:21:19.631]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.631]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.631]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.631]                     ...future.globalenv.names))
[10:21:19.631]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.631]         }, condition = base::local({
[10:21:19.631]             c <- base::c
[10:21:19.631]             inherits <- base::inherits
[10:21:19.631]             invokeRestart <- base::invokeRestart
[10:21:19.631]             length <- base::length
[10:21:19.631]             list <- base::list
[10:21:19.631]             seq.int <- base::seq.int
[10:21:19.631]             signalCondition <- base::signalCondition
[10:21:19.631]             sys.calls <- base::sys.calls
[10:21:19.631]             `[[` <- base::`[[`
[10:21:19.631]             `+` <- base::`+`
[10:21:19.631]             `<<-` <- base::`<<-`
[10:21:19.631]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.631]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.631]                   3L)]
[10:21:19.631]             }
[10:21:19.631]             function(cond) {
[10:21:19.631]                 is_error <- inherits(cond, "error")
[10:21:19.631]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.631]                   NULL)
[10:21:19.631]                 if (is_error) {
[10:21:19.631]                   sessionInformation <- function() {
[10:21:19.631]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.631]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.631]                       search = base::search(), system = base::Sys.info())
[10:21:19.631]                   }
[10:21:19.631]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.631]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.631]                     cond$call), session = sessionInformation(), 
[10:21:19.631]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.631]                   signalCondition(cond)
[10:21:19.631]                 }
[10:21:19.631]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.631]                 "immediateCondition"))) {
[10:21:19.631]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.631]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.631]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.631]                   if (TRUE && !signal) {
[10:21:19.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.631]                     {
[10:21:19.631]                       inherits <- base::inherits
[10:21:19.631]                       invokeRestart <- base::invokeRestart
[10:21:19.631]                       is.null <- base::is.null
[10:21:19.631]                       muffled <- FALSE
[10:21:19.631]                       if (inherits(cond, "message")) {
[10:21:19.631]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.631]                         if (muffled) 
[10:21:19.631]                           invokeRestart("muffleMessage")
[10:21:19.631]                       }
[10:21:19.631]                       else if (inherits(cond, "warning")) {
[10:21:19.631]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.631]                         if (muffled) 
[10:21:19.631]                           invokeRestart("muffleWarning")
[10:21:19.631]                       }
[10:21:19.631]                       else if (inherits(cond, "condition")) {
[10:21:19.631]                         if (!is.null(pattern)) {
[10:21:19.631]                           computeRestarts <- base::computeRestarts
[10:21:19.631]                           grepl <- base::grepl
[10:21:19.631]                           restarts <- computeRestarts(cond)
[10:21:19.631]                           for (restart in restarts) {
[10:21:19.631]                             name <- restart$name
[10:21:19.631]                             if (is.null(name)) 
[10:21:19.631]                               next
[10:21:19.631]                             if (!grepl(pattern, name)) 
[10:21:19.631]                               next
[10:21:19.631]                             invokeRestart(restart)
[10:21:19.631]                             muffled <- TRUE
[10:21:19.631]                             break
[10:21:19.631]                           }
[10:21:19.631]                         }
[10:21:19.631]                       }
[10:21:19.631]                       invisible(muffled)
[10:21:19.631]                     }
[10:21:19.631]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.631]                   }
[10:21:19.631]                 }
[10:21:19.631]                 else {
[10:21:19.631]                   if (TRUE) {
[10:21:19.631]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.631]                     {
[10:21:19.631]                       inherits <- base::inherits
[10:21:19.631]                       invokeRestart <- base::invokeRestart
[10:21:19.631]                       is.null <- base::is.null
[10:21:19.631]                       muffled <- FALSE
[10:21:19.631]                       if (inherits(cond, "message")) {
[10:21:19.631]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.631]                         if (muffled) 
[10:21:19.631]                           invokeRestart("muffleMessage")
[10:21:19.631]                       }
[10:21:19.631]                       else if (inherits(cond, "warning")) {
[10:21:19.631]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.631]                         if (muffled) 
[10:21:19.631]                           invokeRestart("muffleWarning")
[10:21:19.631]                       }
[10:21:19.631]                       else if (inherits(cond, "condition")) {
[10:21:19.631]                         if (!is.null(pattern)) {
[10:21:19.631]                           computeRestarts <- base::computeRestarts
[10:21:19.631]                           grepl <- base::grepl
[10:21:19.631]                           restarts <- computeRestarts(cond)
[10:21:19.631]                           for (restart in restarts) {
[10:21:19.631]                             name <- restart$name
[10:21:19.631]                             if (is.null(name)) 
[10:21:19.631]                               next
[10:21:19.631]                             if (!grepl(pattern, name)) 
[10:21:19.631]                               next
[10:21:19.631]                             invokeRestart(restart)
[10:21:19.631]                             muffled <- TRUE
[10:21:19.631]                             break
[10:21:19.631]                           }
[10:21:19.631]                         }
[10:21:19.631]                       }
[10:21:19.631]                       invisible(muffled)
[10:21:19.631]                     }
[10:21:19.631]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.631]                   }
[10:21:19.631]                 }
[10:21:19.631]             }
[10:21:19.631]         }))
[10:21:19.631]     }, error = function(ex) {
[10:21:19.631]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.631]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.631]                 ...future.rng), started = ...future.startTime, 
[10:21:19.631]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.631]             version = "1.8"), class = "FutureResult")
[10:21:19.631]     }, finally = {
[10:21:19.631]         if (!identical(...future.workdir, getwd())) 
[10:21:19.631]             setwd(...future.workdir)
[10:21:19.631]         {
[10:21:19.631]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.631]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.631]             }
[10:21:19.631]             base::options(...future.oldOptions)
[10:21:19.631]             if (.Platform$OS.type == "windows") {
[10:21:19.631]                 old_names <- names(...future.oldEnvVars)
[10:21:19.631]                 envs <- base::Sys.getenv()
[10:21:19.631]                 names <- names(envs)
[10:21:19.631]                 common <- intersect(names, old_names)
[10:21:19.631]                 added <- setdiff(names, old_names)
[10:21:19.631]                 removed <- setdiff(old_names, names)
[10:21:19.631]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.631]                   envs[common]]
[10:21:19.631]                 NAMES <- toupper(changed)
[10:21:19.631]                 args <- list()
[10:21:19.631]                 for (kk in seq_along(NAMES)) {
[10:21:19.631]                   name <- changed[[kk]]
[10:21:19.631]                   NAME <- NAMES[[kk]]
[10:21:19.631]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.631]                     next
[10:21:19.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.631]                 }
[10:21:19.631]                 NAMES <- toupper(added)
[10:21:19.631]                 for (kk in seq_along(NAMES)) {
[10:21:19.631]                   name <- added[[kk]]
[10:21:19.631]                   NAME <- NAMES[[kk]]
[10:21:19.631]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.631]                     next
[10:21:19.631]                   args[[name]] <- ""
[10:21:19.631]                 }
[10:21:19.631]                 NAMES <- toupper(removed)
[10:21:19.631]                 for (kk in seq_along(NAMES)) {
[10:21:19.631]                   name <- removed[[kk]]
[10:21:19.631]                   NAME <- NAMES[[kk]]
[10:21:19.631]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.631]                     next
[10:21:19.631]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.631]                 }
[10:21:19.631]                 if (length(args) > 0) 
[10:21:19.631]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.631]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.631]             }
[10:21:19.631]             else {
[10:21:19.631]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.631]             }
[10:21:19.631]             {
[10:21:19.631]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.631]                   0L) {
[10:21:19.631]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.631]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.631]                   base::options(opts)
[10:21:19.631]                 }
[10:21:19.631]                 {
[10:21:19.631]                   {
[10:21:19.631]                     NULL
[10:21:19.631]                     RNGkind("Mersenne-Twister")
[10:21:19.631]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.631]                       inherits = FALSE)
[10:21:19.631]                   }
[10:21:19.631]                   options(future.plan = NULL)
[10:21:19.631]                   if (is.na(NA_character_)) 
[10:21:19.631]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.631]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.631]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.631]                     .init = FALSE)
[10:21:19.631]                 }
[10:21:19.631]             }
[10:21:19.631]         }
[10:21:19.631]     })
[10:21:19.631]     if (TRUE) {
[10:21:19.631]         base::sink(type = "output", split = FALSE)
[10:21:19.631]         if (TRUE) {
[10:21:19.631]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.631]         }
[10:21:19.631]         else {
[10:21:19.631]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.631]         }
[10:21:19.631]         base::close(...future.stdout)
[10:21:19.631]         ...future.stdout <- NULL
[10:21:19.631]     }
[10:21:19.631]     ...future.result$conditions <- ...future.conditions
[10:21:19.631]     ...future.result$finished <- base::Sys.time()
[10:21:19.631]     ...future.result
[10:21:19.631] }
[10:21:19.632] plan(): Setting new future strategy stack:
[10:21:19.633] List of future strategies:
[10:21:19.633] 1. sequential:
[10:21:19.633]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.633]    - tweaked: FALSE
[10:21:19.633]    - call: NULL
[10:21:19.633] plan(): nbrOfWorkers() = 1
[10:21:19.634] plan(): Setting new future strategy stack:
[10:21:19.634] List of future strategies:
[10:21:19.634] 1. sequential:
[10:21:19.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.634]    - tweaked: FALSE
[10:21:19.634]    - call: plan(strategy)
[10:21:19.634] plan(): nbrOfWorkers() = 1
[10:21:19.634] SequentialFuture started (and completed)
[10:21:19.634] - Launch lazy future ... done
[10:21:19.635] run() for ‘SequentialFuture’ ... done
[10:21:19.635] getGlobalsAndPackages() ...
[10:21:19.635] Searching for globals...
[10:21:19.635] - globals found: [1] ‘{’
[10:21:19.636] Searching for globals ... DONE
[10:21:19.636] Resolving globals: FALSE
[10:21:19.636] 
[10:21:19.636] 
[10:21:19.636] getGlobalsAndPackages() ... DONE
[10:21:19.636] run() for ‘Future’ ...
[10:21:19.636] - state: ‘created’
[10:21:19.636] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.637] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.637] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.637]   - Field: ‘label’
[10:21:19.637]   - Field: ‘local’
[10:21:19.637]   - Field: ‘owner’
[10:21:19.637]   - Field: ‘envir’
[10:21:19.637]   - Field: ‘packages’
[10:21:19.637]   - Field: ‘gc’
[10:21:19.637]   - Field: ‘conditions’
[10:21:19.638]   - Field: ‘expr’
[10:21:19.638]   - Field: ‘uuid’
[10:21:19.638]   - Field: ‘seed’
[10:21:19.638]   - Field: ‘version’
[10:21:19.638]   - Field: ‘result’
[10:21:19.638]   - Field: ‘asynchronous’
[10:21:19.638]   - Field: ‘calls’
[10:21:19.638]   - Field: ‘globals’
[10:21:19.638]   - Field: ‘stdout’
[10:21:19.638]   - Field: ‘earlySignal’
[10:21:19.638]   - Field: ‘lazy’
[10:21:19.638]   - Field: ‘state’
[10:21:19.638] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.639] - Launch lazy future ...
[10:21:19.639] Packages needed by the future expression (n = 0): <none>
[10:21:19.639] Packages needed by future strategies (n = 0): <none>
[10:21:19.639] {
[10:21:19.639]     {
[10:21:19.639]         {
[10:21:19.639]             ...future.startTime <- base::Sys.time()
[10:21:19.639]             {
[10:21:19.639]                 {
[10:21:19.639]                   {
[10:21:19.639]                     base::local({
[10:21:19.639]                       has_future <- base::requireNamespace("future", 
[10:21:19.639]                         quietly = TRUE)
[10:21:19.639]                       if (has_future) {
[10:21:19.639]                         ns <- base::getNamespace("future")
[10:21:19.639]                         version <- ns[[".package"]][["version"]]
[10:21:19.639]                         if (is.null(version)) 
[10:21:19.639]                           version <- utils::packageVersion("future")
[10:21:19.639]                       }
[10:21:19.639]                       else {
[10:21:19.639]                         version <- NULL
[10:21:19.639]                       }
[10:21:19.639]                       if (!has_future || version < "1.8.0") {
[10:21:19.639]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.639]                           "", base::R.version$version.string), 
[10:21:19.639]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.639]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.639]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.639]                             "release", "version")], collapse = " "), 
[10:21:19.639]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.639]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.639]                           info)
[10:21:19.639]                         info <- base::paste(info, collapse = "; ")
[10:21:19.639]                         if (!has_future) {
[10:21:19.639]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.639]                             info)
[10:21:19.639]                         }
[10:21:19.639]                         else {
[10:21:19.639]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.639]                             info, version)
[10:21:19.639]                         }
[10:21:19.639]                         base::stop(msg)
[10:21:19.639]                       }
[10:21:19.639]                     })
[10:21:19.639]                   }
[10:21:19.639]                   ...future.strategy.old <- future::plan("list")
[10:21:19.639]                   options(future.plan = NULL)
[10:21:19.639]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.639]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.639]                 }
[10:21:19.639]                 ...future.workdir <- getwd()
[10:21:19.639]             }
[10:21:19.639]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.639]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.639]         }
[10:21:19.639]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.639]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.639]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.639]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.639]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.639]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.639]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.639]             base::names(...future.oldOptions))
[10:21:19.639]     }
[10:21:19.639]     if (FALSE) {
[10:21:19.639]     }
[10:21:19.639]     else {
[10:21:19.639]         if (TRUE) {
[10:21:19.639]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.639]                 open = "w")
[10:21:19.639]         }
[10:21:19.639]         else {
[10:21:19.639]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.639]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.639]         }
[10:21:19.639]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.639]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.639]             base::sink(type = "output", split = FALSE)
[10:21:19.639]             base::close(...future.stdout)
[10:21:19.639]         }, add = TRUE)
[10:21:19.639]     }
[10:21:19.639]     ...future.frame <- base::sys.nframe()
[10:21:19.639]     ...future.conditions <- base::list()
[10:21:19.639]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.639]     if (FALSE) {
[10:21:19.639]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.639]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.639]     }
[10:21:19.639]     ...future.result <- base::tryCatch({
[10:21:19.639]         base::withCallingHandlers({
[10:21:19.639]             ...future.value <- base::withVisible(base::local({
[10:21:19.639]                 4
[10:21:19.639]             }))
[10:21:19.639]             future::FutureResult(value = ...future.value$value, 
[10:21:19.639]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.639]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.639]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.639]                     ...future.globalenv.names))
[10:21:19.639]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.639]         }, condition = base::local({
[10:21:19.639]             c <- base::c
[10:21:19.639]             inherits <- base::inherits
[10:21:19.639]             invokeRestart <- base::invokeRestart
[10:21:19.639]             length <- base::length
[10:21:19.639]             list <- base::list
[10:21:19.639]             seq.int <- base::seq.int
[10:21:19.639]             signalCondition <- base::signalCondition
[10:21:19.639]             sys.calls <- base::sys.calls
[10:21:19.639]             `[[` <- base::`[[`
[10:21:19.639]             `+` <- base::`+`
[10:21:19.639]             `<<-` <- base::`<<-`
[10:21:19.639]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.639]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.639]                   3L)]
[10:21:19.639]             }
[10:21:19.639]             function(cond) {
[10:21:19.639]                 is_error <- inherits(cond, "error")
[10:21:19.639]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.639]                   NULL)
[10:21:19.639]                 if (is_error) {
[10:21:19.639]                   sessionInformation <- function() {
[10:21:19.639]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.639]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.639]                       search = base::search(), system = base::Sys.info())
[10:21:19.639]                   }
[10:21:19.639]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.639]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.639]                     cond$call), session = sessionInformation(), 
[10:21:19.639]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.639]                   signalCondition(cond)
[10:21:19.639]                 }
[10:21:19.639]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.639]                 "immediateCondition"))) {
[10:21:19.639]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.639]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.639]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.639]                   if (TRUE && !signal) {
[10:21:19.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.639]                     {
[10:21:19.639]                       inherits <- base::inherits
[10:21:19.639]                       invokeRestart <- base::invokeRestart
[10:21:19.639]                       is.null <- base::is.null
[10:21:19.639]                       muffled <- FALSE
[10:21:19.639]                       if (inherits(cond, "message")) {
[10:21:19.639]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.639]                         if (muffled) 
[10:21:19.639]                           invokeRestart("muffleMessage")
[10:21:19.639]                       }
[10:21:19.639]                       else if (inherits(cond, "warning")) {
[10:21:19.639]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.639]                         if (muffled) 
[10:21:19.639]                           invokeRestart("muffleWarning")
[10:21:19.639]                       }
[10:21:19.639]                       else if (inherits(cond, "condition")) {
[10:21:19.639]                         if (!is.null(pattern)) {
[10:21:19.639]                           computeRestarts <- base::computeRestarts
[10:21:19.639]                           grepl <- base::grepl
[10:21:19.639]                           restarts <- computeRestarts(cond)
[10:21:19.639]                           for (restart in restarts) {
[10:21:19.639]                             name <- restart$name
[10:21:19.639]                             if (is.null(name)) 
[10:21:19.639]                               next
[10:21:19.639]                             if (!grepl(pattern, name)) 
[10:21:19.639]                               next
[10:21:19.639]                             invokeRestart(restart)
[10:21:19.639]                             muffled <- TRUE
[10:21:19.639]                             break
[10:21:19.639]                           }
[10:21:19.639]                         }
[10:21:19.639]                       }
[10:21:19.639]                       invisible(muffled)
[10:21:19.639]                     }
[10:21:19.639]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.639]                   }
[10:21:19.639]                 }
[10:21:19.639]                 else {
[10:21:19.639]                   if (TRUE) {
[10:21:19.639]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.639]                     {
[10:21:19.639]                       inherits <- base::inherits
[10:21:19.639]                       invokeRestart <- base::invokeRestart
[10:21:19.639]                       is.null <- base::is.null
[10:21:19.639]                       muffled <- FALSE
[10:21:19.639]                       if (inherits(cond, "message")) {
[10:21:19.639]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.639]                         if (muffled) 
[10:21:19.639]                           invokeRestart("muffleMessage")
[10:21:19.639]                       }
[10:21:19.639]                       else if (inherits(cond, "warning")) {
[10:21:19.639]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.639]                         if (muffled) 
[10:21:19.639]                           invokeRestart("muffleWarning")
[10:21:19.639]                       }
[10:21:19.639]                       else if (inherits(cond, "condition")) {
[10:21:19.639]                         if (!is.null(pattern)) {
[10:21:19.639]                           computeRestarts <- base::computeRestarts
[10:21:19.639]                           grepl <- base::grepl
[10:21:19.639]                           restarts <- computeRestarts(cond)
[10:21:19.639]                           for (restart in restarts) {
[10:21:19.639]                             name <- restart$name
[10:21:19.639]                             if (is.null(name)) 
[10:21:19.639]                               next
[10:21:19.639]                             if (!grepl(pattern, name)) 
[10:21:19.639]                               next
[10:21:19.639]                             invokeRestart(restart)
[10:21:19.639]                             muffled <- TRUE
[10:21:19.639]                             break
[10:21:19.639]                           }
[10:21:19.639]                         }
[10:21:19.639]                       }
[10:21:19.639]                       invisible(muffled)
[10:21:19.639]                     }
[10:21:19.639]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.639]                   }
[10:21:19.639]                 }
[10:21:19.639]             }
[10:21:19.639]         }))
[10:21:19.639]     }, error = function(ex) {
[10:21:19.639]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.639]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.639]                 ...future.rng), started = ...future.startTime, 
[10:21:19.639]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.639]             version = "1.8"), class = "FutureResult")
[10:21:19.639]     }, finally = {
[10:21:19.639]         if (!identical(...future.workdir, getwd())) 
[10:21:19.639]             setwd(...future.workdir)
[10:21:19.639]         {
[10:21:19.639]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.639]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.639]             }
[10:21:19.639]             base::options(...future.oldOptions)
[10:21:19.639]             if (.Platform$OS.type == "windows") {
[10:21:19.639]                 old_names <- names(...future.oldEnvVars)
[10:21:19.639]                 envs <- base::Sys.getenv()
[10:21:19.639]                 names <- names(envs)
[10:21:19.639]                 common <- intersect(names, old_names)
[10:21:19.639]                 added <- setdiff(names, old_names)
[10:21:19.639]                 removed <- setdiff(old_names, names)
[10:21:19.639]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.639]                   envs[common]]
[10:21:19.639]                 NAMES <- toupper(changed)
[10:21:19.639]                 args <- list()
[10:21:19.639]                 for (kk in seq_along(NAMES)) {
[10:21:19.639]                   name <- changed[[kk]]
[10:21:19.639]                   NAME <- NAMES[[kk]]
[10:21:19.639]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.639]                     next
[10:21:19.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.639]                 }
[10:21:19.639]                 NAMES <- toupper(added)
[10:21:19.639]                 for (kk in seq_along(NAMES)) {
[10:21:19.639]                   name <- added[[kk]]
[10:21:19.639]                   NAME <- NAMES[[kk]]
[10:21:19.639]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.639]                     next
[10:21:19.639]                   args[[name]] <- ""
[10:21:19.639]                 }
[10:21:19.639]                 NAMES <- toupper(removed)
[10:21:19.639]                 for (kk in seq_along(NAMES)) {
[10:21:19.639]                   name <- removed[[kk]]
[10:21:19.639]                   NAME <- NAMES[[kk]]
[10:21:19.639]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.639]                     next
[10:21:19.639]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.639]                 }
[10:21:19.639]                 if (length(args) > 0) 
[10:21:19.639]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.639]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.639]             }
[10:21:19.639]             else {
[10:21:19.639]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.639]             }
[10:21:19.639]             {
[10:21:19.639]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.639]                   0L) {
[10:21:19.639]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.639]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.639]                   base::options(opts)
[10:21:19.639]                 }
[10:21:19.639]                 {
[10:21:19.639]                   {
[10:21:19.639]                     NULL
[10:21:19.639]                     RNGkind("Mersenne-Twister")
[10:21:19.639]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.639]                       inherits = FALSE)
[10:21:19.639]                   }
[10:21:19.639]                   options(future.plan = NULL)
[10:21:19.639]                   if (is.na(NA_character_)) 
[10:21:19.639]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.639]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.639]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.639]                     .init = FALSE)
[10:21:19.639]                 }
[10:21:19.639]             }
[10:21:19.639]         }
[10:21:19.639]     })
[10:21:19.639]     if (TRUE) {
[10:21:19.639]         base::sink(type = "output", split = FALSE)
[10:21:19.639]         if (TRUE) {
[10:21:19.639]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.639]         }
[10:21:19.639]         else {
[10:21:19.639]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.639]         }
[10:21:19.639]         base::close(...future.stdout)
[10:21:19.639]         ...future.stdout <- NULL
[10:21:19.639]     }
[10:21:19.639]     ...future.result$conditions <- ...future.conditions
[10:21:19.639]     ...future.result$finished <- base::Sys.time()
[10:21:19.639]     ...future.result
[10:21:19.639] }
[10:21:19.641] plan(): Setting new future strategy stack:
[10:21:19.641] List of future strategies:
[10:21:19.641] 1. sequential:
[10:21:19.641]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.641]    - tweaked: FALSE
[10:21:19.641]    - call: NULL
[10:21:19.642] plan(): nbrOfWorkers() = 1
[10:21:19.642] plan(): Setting new future strategy stack:
[10:21:19.642] List of future strategies:
[10:21:19.642] 1. sequential:
[10:21:19.642]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.642]    - tweaked: FALSE
[10:21:19.642]    - call: plan(strategy)
[10:21:19.643] plan(): nbrOfWorkers() = 1
[10:21:19.643] SequentialFuture started (and completed)
[10:21:19.643] - Launch lazy future ... done
[10:21:19.643] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e363ed20> 
Classes 'listenv', 'environment' <environment: 0x55e8e58d8ac0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:21:19.647] resolved() for ‘SequentialFuture’ ...
[10:21:19.648] - state: ‘finished’
[10:21:19.648] - run: TRUE
[10:21:19.648] - result: ‘FutureResult’
[10:21:19.648] resolved() for ‘SequentialFuture’ ... done
[10:21:19.648] resolved() for ‘SequentialFuture’ ...
[10:21:19.648] - state: ‘finished’
[10:21:19.648] - run: TRUE
[10:21:19.648] - result: ‘FutureResult’
[10:21:19.648] resolved() for ‘SequentialFuture’ ... done
[10:21:19.648] resolved() for ‘SequentialFuture’ ...
[10:21:19.648] - state: ‘finished’
[10:21:19.649] - run: TRUE
[10:21:19.649] - result: ‘FutureResult’
[10:21:19.649] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:19.651] resolve() on list environment ...
[10:21:19.651]  recursive: 0
[10:21:19.652]  length: 6
[10:21:19.652]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:19.652] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.652] - nx: 6
[10:21:19.652] - relay: TRUE
[10:21:19.652] - stdout: TRUE
[10:21:19.652] - signal: TRUE
[10:21:19.652] - resignal: FALSE
[10:21:19.652] - force: TRUE
[10:21:19.652] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.652] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.653]  - until=2
[10:21:19.653]  - relaying element #2
[10:21:19.653] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.653] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.653] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.653]  length: 5 (resolved future 1)
[10:21:19.653] resolved() for ‘SequentialFuture’ ...
[10:21:19.653] - state: ‘finished’
[10:21:19.653] - run: TRUE
[10:21:19.653] - result: ‘FutureResult’
[10:21:19.653] resolved() for ‘SequentialFuture’ ... done
[10:21:19.654] Future #2
[10:21:19.654] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.654] - nx: 6
[10:21:19.654] - relay: TRUE
[10:21:19.654] - stdout: TRUE
[10:21:19.654] - signal: TRUE
[10:21:19.654] - resignal: FALSE
[10:21:19.654] - force: TRUE
[10:21:19.654] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.654] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.654]  - until=2
[10:21:19.654]  - relaying element #2
[10:21:19.655] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.655] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.655] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.655]  length: 4 (resolved future 2)
[10:21:19.655] resolved() for ‘SequentialFuture’ ...
[10:21:19.655] - state: ‘finished’
[10:21:19.655] - run: TRUE
[10:21:19.655] - result: ‘FutureResult’
[10:21:19.655] resolved() for ‘SequentialFuture’ ... done
[10:21:19.655] Future #3
[10:21:19.656] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.656] - nx: 6
[10:21:19.656] - relay: TRUE
[10:21:19.656] - stdout: TRUE
[10:21:19.656] - signal: TRUE
[10:21:19.656] - resignal: FALSE
[10:21:19.656] - force: TRUE
[10:21:19.656] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.656] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.656]  - until=3
[10:21:19.656]  - relaying element #3
[10:21:19.656] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.657] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.657] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.657]  length: 3 (resolved future 3)
[10:21:19.657] resolved() for ‘SequentialFuture’ ...
[10:21:19.657] - state: ‘finished’
[10:21:19.657] - run: TRUE
[10:21:19.657] - result: ‘FutureResult’
[10:21:19.657] resolved() for ‘SequentialFuture’ ... done
[10:21:19.657] Future #4
[10:21:19.657] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.657] - nx: 6
[10:21:19.657] - relay: TRUE
[10:21:19.658] - stdout: TRUE
[10:21:19.658] - signal: TRUE
[10:21:19.658] - resignal: FALSE
[10:21:19.658] - force: TRUE
[10:21:19.658] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.658] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.658]  - until=4
[10:21:19.658]  - relaying element #4
[10:21:19.658] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.658] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.658] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.658]  length: 2 (resolved future 4)
[10:21:19.659] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.659] - nx: 6
[10:21:19.659] - relay: TRUE
[10:21:19.659] - stdout: TRUE
[10:21:19.659] - signal: TRUE
[10:21:19.659] - resignal: FALSE
[10:21:19.659] - force: TRUE
[10:21:19.659] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.659] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.659]  - until=6
[10:21:19.659]  - relaying element #6
[10:21:19.659] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.659] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.660] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.660]  length: 1 (resolved future 5)
[10:21:19.660] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.660] - nx: 6
[10:21:19.660] - relay: TRUE
[10:21:19.660] - stdout: TRUE
[10:21:19.660] - signal: TRUE
[10:21:19.660] - resignal: FALSE
[10:21:19.660] - force: TRUE
[10:21:19.660] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.660] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.660]  - until=6
[10:21:19.660] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.661] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.661] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.661]  length: 0 (resolved future 6)
[10:21:19.661] Relaying remaining futures
[10:21:19.661] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.661] - nx: 6
[10:21:19.661] - relay: TRUE
[10:21:19.661] - stdout: TRUE
[10:21:19.661] - signal: TRUE
[10:21:19.661] - resignal: FALSE
[10:21:19.661] - force: TRUE
[10:21:19.661] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.661] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:19.662] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.662] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.662] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.662] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55e8e3541830> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:21:19.664] getGlobalsAndPackages() ...
[10:21:19.664] Searching for globals...
[10:21:19.664] 
[10:21:19.664] Searching for globals ... DONE
[10:21:19.664] - globals: [0] <none>
[10:21:19.664] getGlobalsAndPackages() ... DONE
[10:21:19.664] run() for ‘Future’ ...
[10:21:19.664] - state: ‘created’
[10:21:19.665] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.665] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.665]   - Field: ‘label’
[10:21:19.665]   - Field: ‘local’
[10:21:19.665]   - Field: ‘owner’
[10:21:19.665]   - Field: ‘envir’
[10:21:19.665]   - Field: ‘packages’
[10:21:19.665]   - Field: ‘gc’
[10:21:19.666]   - Field: ‘conditions’
[10:21:19.666]   - Field: ‘expr’
[10:21:19.666]   - Field: ‘uuid’
[10:21:19.667]   - Field: ‘seed’
[10:21:19.667]   - Field: ‘version’
[10:21:19.667]   - Field: ‘result’
[10:21:19.667]   - Field: ‘asynchronous’
[10:21:19.667]   - Field: ‘calls’
[10:21:19.667]   - Field: ‘globals’
[10:21:19.667]   - Field: ‘stdout’
[10:21:19.667]   - Field: ‘earlySignal’
[10:21:19.667]   - Field: ‘lazy’
[10:21:19.667]   - Field: ‘state’
[10:21:19.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.668] - Launch lazy future ...
[10:21:19.668] Packages needed by the future expression (n = 0): <none>
[10:21:19.668] Packages needed by future strategies (n = 0): <none>
[10:21:19.668] {
[10:21:19.668]     {
[10:21:19.668]         {
[10:21:19.668]             ...future.startTime <- base::Sys.time()
[10:21:19.668]             {
[10:21:19.668]                 {
[10:21:19.668]                   {
[10:21:19.668]                     base::local({
[10:21:19.668]                       has_future <- base::requireNamespace("future", 
[10:21:19.668]                         quietly = TRUE)
[10:21:19.668]                       if (has_future) {
[10:21:19.668]                         ns <- base::getNamespace("future")
[10:21:19.668]                         version <- ns[[".package"]][["version"]]
[10:21:19.668]                         if (is.null(version)) 
[10:21:19.668]                           version <- utils::packageVersion("future")
[10:21:19.668]                       }
[10:21:19.668]                       else {
[10:21:19.668]                         version <- NULL
[10:21:19.668]                       }
[10:21:19.668]                       if (!has_future || version < "1.8.0") {
[10:21:19.668]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.668]                           "", base::R.version$version.string), 
[10:21:19.668]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.668]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.668]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.668]                             "release", "version")], collapse = " "), 
[10:21:19.668]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.668]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.668]                           info)
[10:21:19.668]                         info <- base::paste(info, collapse = "; ")
[10:21:19.668]                         if (!has_future) {
[10:21:19.668]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.668]                             info)
[10:21:19.668]                         }
[10:21:19.668]                         else {
[10:21:19.668]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.668]                             info, version)
[10:21:19.668]                         }
[10:21:19.668]                         base::stop(msg)
[10:21:19.668]                       }
[10:21:19.668]                     })
[10:21:19.668]                   }
[10:21:19.668]                   ...future.strategy.old <- future::plan("list")
[10:21:19.668]                   options(future.plan = NULL)
[10:21:19.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.668]                 }
[10:21:19.668]                 ...future.workdir <- getwd()
[10:21:19.668]             }
[10:21:19.668]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.668]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.668]         }
[10:21:19.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.668]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.668]             base::names(...future.oldOptions))
[10:21:19.668]     }
[10:21:19.668]     if (FALSE) {
[10:21:19.668]     }
[10:21:19.668]     else {
[10:21:19.668]         if (TRUE) {
[10:21:19.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.668]                 open = "w")
[10:21:19.668]         }
[10:21:19.668]         else {
[10:21:19.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.668]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.668]         }
[10:21:19.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.668]             base::sink(type = "output", split = FALSE)
[10:21:19.668]             base::close(...future.stdout)
[10:21:19.668]         }, add = TRUE)
[10:21:19.668]     }
[10:21:19.668]     ...future.frame <- base::sys.nframe()
[10:21:19.668]     ...future.conditions <- base::list()
[10:21:19.668]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.668]     if (FALSE) {
[10:21:19.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.668]     }
[10:21:19.668]     ...future.result <- base::tryCatch({
[10:21:19.668]         base::withCallingHandlers({
[10:21:19.668]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.668]             future::FutureResult(value = ...future.value$value, 
[10:21:19.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.668]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.668]                     ...future.globalenv.names))
[10:21:19.668]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.668]         }, condition = base::local({
[10:21:19.668]             c <- base::c
[10:21:19.668]             inherits <- base::inherits
[10:21:19.668]             invokeRestart <- base::invokeRestart
[10:21:19.668]             length <- base::length
[10:21:19.668]             list <- base::list
[10:21:19.668]             seq.int <- base::seq.int
[10:21:19.668]             signalCondition <- base::signalCondition
[10:21:19.668]             sys.calls <- base::sys.calls
[10:21:19.668]             `[[` <- base::`[[`
[10:21:19.668]             `+` <- base::`+`
[10:21:19.668]             `<<-` <- base::`<<-`
[10:21:19.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.668]                   3L)]
[10:21:19.668]             }
[10:21:19.668]             function(cond) {
[10:21:19.668]                 is_error <- inherits(cond, "error")
[10:21:19.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.668]                   NULL)
[10:21:19.668]                 if (is_error) {
[10:21:19.668]                   sessionInformation <- function() {
[10:21:19.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.668]                       search = base::search(), system = base::Sys.info())
[10:21:19.668]                   }
[10:21:19.668]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.668]                     cond$call), session = sessionInformation(), 
[10:21:19.668]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.668]                   signalCondition(cond)
[10:21:19.668]                 }
[10:21:19.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.668]                 "immediateCondition"))) {
[10:21:19.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.668]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.668]                   if (TRUE && !signal) {
[10:21:19.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.668]                     {
[10:21:19.668]                       inherits <- base::inherits
[10:21:19.668]                       invokeRestart <- base::invokeRestart
[10:21:19.668]                       is.null <- base::is.null
[10:21:19.668]                       muffled <- FALSE
[10:21:19.668]                       if (inherits(cond, "message")) {
[10:21:19.668]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.668]                         if (muffled) 
[10:21:19.668]                           invokeRestart("muffleMessage")
[10:21:19.668]                       }
[10:21:19.668]                       else if (inherits(cond, "warning")) {
[10:21:19.668]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.668]                         if (muffled) 
[10:21:19.668]                           invokeRestart("muffleWarning")
[10:21:19.668]                       }
[10:21:19.668]                       else if (inherits(cond, "condition")) {
[10:21:19.668]                         if (!is.null(pattern)) {
[10:21:19.668]                           computeRestarts <- base::computeRestarts
[10:21:19.668]                           grepl <- base::grepl
[10:21:19.668]                           restarts <- computeRestarts(cond)
[10:21:19.668]                           for (restart in restarts) {
[10:21:19.668]                             name <- restart$name
[10:21:19.668]                             if (is.null(name)) 
[10:21:19.668]                               next
[10:21:19.668]                             if (!grepl(pattern, name)) 
[10:21:19.668]                               next
[10:21:19.668]                             invokeRestart(restart)
[10:21:19.668]                             muffled <- TRUE
[10:21:19.668]                             break
[10:21:19.668]                           }
[10:21:19.668]                         }
[10:21:19.668]                       }
[10:21:19.668]                       invisible(muffled)
[10:21:19.668]                     }
[10:21:19.668]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.668]                   }
[10:21:19.668]                 }
[10:21:19.668]                 else {
[10:21:19.668]                   if (TRUE) {
[10:21:19.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.668]                     {
[10:21:19.668]                       inherits <- base::inherits
[10:21:19.668]                       invokeRestart <- base::invokeRestart
[10:21:19.668]                       is.null <- base::is.null
[10:21:19.668]                       muffled <- FALSE
[10:21:19.668]                       if (inherits(cond, "message")) {
[10:21:19.668]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.668]                         if (muffled) 
[10:21:19.668]                           invokeRestart("muffleMessage")
[10:21:19.668]                       }
[10:21:19.668]                       else if (inherits(cond, "warning")) {
[10:21:19.668]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.668]                         if (muffled) 
[10:21:19.668]                           invokeRestart("muffleWarning")
[10:21:19.668]                       }
[10:21:19.668]                       else if (inherits(cond, "condition")) {
[10:21:19.668]                         if (!is.null(pattern)) {
[10:21:19.668]                           computeRestarts <- base::computeRestarts
[10:21:19.668]                           grepl <- base::grepl
[10:21:19.668]                           restarts <- computeRestarts(cond)
[10:21:19.668]                           for (restart in restarts) {
[10:21:19.668]                             name <- restart$name
[10:21:19.668]                             if (is.null(name)) 
[10:21:19.668]                               next
[10:21:19.668]                             if (!grepl(pattern, name)) 
[10:21:19.668]                               next
[10:21:19.668]                             invokeRestart(restart)
[10:21:19.668]                             muffled <- TRUE
[10:21:19.668]                             break
[10:21:19.668]                           }
[10:21:19.668]                         }
[10:21:19.668]                       }
[10:21:19.668]                       invisible(muffled)
[10:21:19.668]                     }
[10:21:19.668]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.668]                   }
[10:21:19.668]                 }
[10:21:19.668]             }
[10:21:19.668]         }))
[10:21:19.668]     }, error = function(ex) {
[10:21:19.668]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.668]                 ...future.rng), started = ...future.startTime, 
[10:21:19.668]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.668]             version = "1.8"), class = "FutureResult")
[10:21:19.668]     }, finally = {
[10:21:19.668]         if (!identical(...future.workdir, getwd())) 
[10:21:19.668]             setwd(...future.workdir)
[10:21:19.668]         {
[10:21:19.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.668]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.668]             }
[10:21:19.668]             base::options(...future.oldOptions)
[10:21:19.668]             if (.Platform$OS.type == "windows") {
[10:21:19.668]                 old_names <- names(...future.oldEnvVars)
[10:21:19.668]                 envs <- base::Sys.getenv()
[10:21:19.668]                 names <- names(envs)
[10:21:19.668]                 common <- intersect(names, old_names)
[10:21:19.668]                 added <- setdiff(names, old_names)
[10:21:19.668]                 removed <- setdiff(old_names, names)
[10:21:19.668]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.668]                   envs[common]]
[10:21:19.668]                 NAMES <- toupper(changed)
[10:21:19.668]                 args <- list()
[10:21:19.668]                 for (kk in seq_along(NAMES)) {
[10:21:19.668]                   name <- changed[[kk]]
[10:21:19.668]                   NAME <- NAMES[[kk]]
[10:21:19.668]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.668]                     next
[10:21:19.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.668]                 }
[10:21:19.668]                 NAMES <- toupper(added)
[10:21:19.668]                 for (kk in seq_along(NAMES)) {
[10:21:19.668]                   name <- added[[kk]]
[10:21:19.668]                   NAME <- NAMES[[kk]]
[10:21:19.668]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.668]                     next
[10:21:19.668]                   args[[name]] <- ""
[10:21:19.668]                 }
[10:21:19.668]                 NAMES <- toupper(removed)
[10:21:19.668]                 for (kk in seq_along(NAMES)) {
[10:21:19.668]                   name <- removed[[kk]]
[10:21:19.668]                   NAME <- NAMES[[kk]]
[10:21:19.668]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.668]                     next
[10:21:19.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.668]                 }
[10:21:19.668]                 if (length(args) > 0) 
[10:21:19.668]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.668]             }
[10:21:19.668]             else {
[10:21:19.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.668]             }
[10:21:19.668]             {
[10:21:19.668]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.668]                   0L) {
[10:21:19.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.668]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.668]                   base::options(opts)
[10:21:19.668]                 }
[10:21:19.668]                 {
[10:21:19.668]                   {
[10:21:19.668]                     NULL
[10:21:19.668]                     RNGkind("Mersenne-Twister")
[10:21:19.668]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.668]                       inherits = FALSE)
[10:21:19.668]                   }
[10:21:19.668]                   options(future.plan = NULL)
[10:21:19.668]                   if (is.na(NA_character_)) 
[10:21:19.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.668]                     .init = FALSE)
[10:21:19.668]                 }
[10:21:19.668]             }
[10:21:19.668]         }
[10:21:19.668]     })
[10:21:19.668]     if (TRUE) {
[10:21:19.668]         base::sink(type = "output", split = FALSE)
[10:21:19.668]         if (TRUE) {
[10:21:19.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.668]         }
[10:21:19.668]         else {
[10:21:19.668]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.668]         }
[10:21:19.668]         base::close(...future.stdout)
[10:21:19.668]         ...future.stdout <- NULL
[10:21:19.668]     }
[10:21:19.668]     ...future.result$conditions <- ...future.conditions
[10:21:19.668]     ...future.result$finished <- base::Sys.time()
[10:21:19.668]     ...future.result
[10:21:19.668] }
[10:21:19.670] plan(): Setting new future strategy stack:
[10:21:19.670] List of future strategies:
[10:21:19.670] 1. sequential:
[10:21:19.670]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.670]    - tweaked: FALSE
[10:21:19.670]    - call: NULL
[10:21:19.670] plan(): nbrOfWorkers() = 1
[10:21:19.671] plan(): Setting new future strategy stack:
[10:21:19.671] List of future strategies:
[10:21:19.671] 1. sequential:
[10:21:19.671]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.671]    - tweaked: FALSE
[10:21:19.671]    - call: plan(strategy)
[10:21:19.672] plan(): nbrOfWorkers() = 1
[10:21:19.672] SequentialFuture started (and completed)
[10:21:19.672] - Launch lazy future ... done
[10:21:19.672] run() for ‘SequentialFuture’ ... done
[10:21:19.672] getGlobalsAndPackages() ...
[10:21:19.672] Searching for globals...
[10:21:19.672] 
[10:21:19.673] Searching for globals ... DONE
[10:21:19.673] - globals: [0] <none>
[10:21:19.673] getGlobalsAndPackages() ... DONE
[10:21:19.673] run() for ‘Future’ ...
[10:21:19.673] - state: ‘created’
[10:21:19.673] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.673] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.673] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.673]   - Field: ‘label’
[10:21:19.674]   - Field: ‘local’
[10:21:19.674]   - Field: ‘owner’
[10:21:19.674]   - Field: ‘envir’
[10:21:19.674]   - Field: ‘packages’
[10:21:19.674]   - Field: ‘gc’
[10:21:19.674]   - Field: ‘conditions’
[10:21:19.674]   - Field: ‘expr’
[10:21:19.674]   - Field: ‘uuid’
[10:21:19.674]   - Field: ‘seed’
[10:21:19.674]   - Field: ‘version’
[10:21:19.674]   - Field: ‘result’
[10:21:19.674]   - Field: ‘asynchronous’
[10:21:19.675]   - Field: ‘calls’
[10:21:19.675]   - Field: ‘globals’
[10:21:19.675]   - Field: ‘stdout’
[10:21:19.675]   - Field: ‘earlySignal’
[10:21:19.675]   - Field: ‘lazy’
[10:21:19.675]   - Field: ‘state’
[10:21:19.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.675] - Launch lazy future ...
[10:21:19.675] Packages needed by the future expression (n = 0): <none>
[10:21:19.675] Packages needed by future strategies (n = 0): <none>
[10:21:19.676] {
[10:21:19.676]     {
[10:21:19.676]         {
[10:21:19.676]             ...future.startTime <- base::Sys.time()
[10:21:19.676]             {
[10:21:19.676]                 {
[10:21:19.676]                   {
[10:21:19.676]                     base::local({
[10:21:19.676]                       has_future <- base::requireNamespace("future", 
[10:21:19.676]                         quietly = TRUE)
[10:21:19.676]                       if (has_future) {
[10:21:19.676]                         ns <- base::getNamespace("future")
[10:21:19.676]                         version <- ns[[".package"]][["version"]]
[10:21:19.676]                         if (is.null(version)) 
[10:21:19.676]                           version <- utils::packageVersion("future")
[10:21:19.676]                       }
[10:21:19.676]                       else {
[10:21:19.676]                         version <- NULL
[10:21:19.676]                       }
[10:21:19.676]                       if (!has_future || version < "1.8.0") {
[10:21:19.676]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.676]                           "", base::R.version$version.string), 
[10:21:19.676]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.676]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.676]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.676]                             "release", "version")], collapse = " "), 
[10:21:19.676]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.676]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.676]                           info)
[10:21:19.676]                         info <- base::paste(info, collapse = "; ")
[10:21:19.676]                         if (!has_future) {
[10:21:19.676]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.676]                             info)
[10:21:19.676]                         }
[10:21:19.676]                         else {
[10:21:19.676]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.676]                             info, version)
[10:21:19.676]                         }
[10:21:19.676]                         base::stop(msg)
[10:21:19.676]                       }
[10:21:19.676]                     })
[10:21:19.676]                   }
[10:21:19.676]                   ...future.strategy.old <- future::plan("list")
[10:21:19.676]                   options(future.plan = NULL)
[10:21:19.676]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.676]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.676]                 }
[10:21:19.676]                 ...future.workdir <- getwd()
[10:21:19.676]             }
[10:21:19.676]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.676]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.676]         }
[10:21:19.676]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.676]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.676]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.676]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.676]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.676]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.676]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.676]             base::names(...future.oldOptions))
[10:21:19.676]     }
[10:21:19.676]     if (FALSE) {
[10:21:19.676]     }
[10:21:19.676]     else {
[10:21:19.676]         if (TRUE) {
[10:21:19.676]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.676]                 open = "w")
[10:21:19.676]         }
[10:21:19.676]         else {
[10:21:19.676]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.676]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.676]         }
[10:21:19.676]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.676]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.676]             base::sink(type = "output", split = FALSE)
[10:21:19.676]             base::close(...future.stdout)
[10:21:19.676]         }, add = TRUE)
[10:21:19.676]     }
[10:21:19.676]     ...future.frame <- base::sys.nframe()
[10:21:19.676]     ...future.conditions <- base::list()
[10:21:19.676]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.676]     if (FALSE) {
[10:21:19.676]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.676]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.676]     }
[10:21:19.676]     ...future.result <- base::tryCatch({
[10:21:19.676]         base::withCallingHandlers({
[10:21:19.676]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.676]             future::FutureResult(value = ...future.value$value, 
[10:21:19.676]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.676]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.676]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.676]                     ...future.globalenv.names))
[10:21:19.676]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.676]         }, condition = base::local({
[10:21:19.676]             c <- base::c
[10:21:19.676]             inherits <- base::inherits
[10:21:19.676]             invokeRestart <- base::invokeRestart
[10:21:19.676]             length <- base::length
[10:21:19.676]             list <- base::list
[10:21:19.676]             seq.int <- base::seq.int
[10:21:19.676]             signalCondition <- base::signalCondition
[10:21:19.676]             sys.calls <- base::sys.calls
[10:21:19.676]             `[[` <- base::`[[`
[10:21:19.676]             `+` <- base::`+`
[10:21:19.676]             `<<-` <- base::`<<-`
[10:21:19.676]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.676]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.676]                   3L)]
[10:21:19.676]             }
[10:21:19.676]             function(cond) {
[10:21:19.676]                 is_error <- inherits(cond, "error")
[10:21:19.676]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.676]                   NULL)
[10:21:19.676]                 if (is_error) {
[10:21:19.676]                   sessionInformation <- function() {
[10:21:19.676]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.676]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.676]                       search = base::search(), system = base::Sys.info())
[10:21:19.676]                   }
[10:21:19.676]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.676]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.676]                     cond$call), session = sessionInformation(), 
[10:21:19.676]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.676]                   signalCondition(cond)
[10:21:19.676]                 }
[10:21:19.676]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.676]                 "immediateCondition"))) {
[10:21:19.676]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.676]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.676]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.676]                   if (TRUE && !signal) {
[10:21:19.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.676]                     {
[10:21:19.676]                       inherits <- base::inherits
[10:21:19.676]                       invokeRestart <- base::invokeRestart
[10:21:19.676]                       is.null <- base::is.null
[10:21:19.676]                       muffled <- FALSE
[10:21:19.676]                       if (inherits(cond, "message")) {
[10:21:19.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.676]                         if (muffled) 
[10:21:19.676]                           invokeRestart("muffleMessage")
[10:21:19.676]                       }
[10:21:19.676]                       else if (inherits(cond, "warning")) {
[10:21:19.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.676]                         if (muffled) 
[10:21:19.676]                           invokeRestart("muffleWarning")
[10:21:19.676]                       }
[10:21:19.676]                       else if (inherits(cond, "condition")) {
[10:21:19.676]                         if (!is.null(pattern)) {
[10:21:19.676]                           computeRestarts <- base::computeRestarts
[10:21:19.676]                           grepl <- base::grepl
[10:21:19.676]                           restarts <- computeRestarts(cond)
[10:21:19.676]                           for (restart in restarts) {
[10:21:19.676]                             name <- restart$name
[10:21:19.676]                             if (is.null(name)) 
[10:21:19.676]                               next
[10:21:19.676]                             if (!grepl(pattern, name)) 
[10:21:19.676]                               next
[10:21:19.676]                             invokeRestart(restart)
[10:21:19.676]                             muffled <- TRUE
[10:21:19.676]                             break
[10:21:19.676]                           }
[10:21:19.676]                         }
[10:21:19.676]                       }
[10:21:19.676]                       invisible(muffled)
[10:21:19.676]                     }
[10:21:19.676]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.676]                   }
[10:21:19.676]                 }
[10:21:19.676]                 else {
[10:21:19.676]                   if (TRUE) {
[10:21:19.676]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.676]                     {
[10:21:19.676]                       inherits <- base::inherits
[10:21:19.676]                       invokeRestart <- base::invokeRestart
[10:21:19.676]                       is.null <- base::is.null
[10:21:19.676]                       muffled <- FALSE
[10:21:19.676]                       if (inherits(cond, "message")) {
[10:21:19.676]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.676]                         if (muffled) 
[10:21:19.676]                           invokeRestart("muffleMessage")
[10:21:19.676]                       }
[10:21:19.676]                       else if (inherits(cond, "warning")) {
[10:21:19.676]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.676]                         if (muffled) 
[10:21:19.676]                           invokeRestart("muffleWarning")
[10:21:19.676]                       }
[10:21:19.676]                       else if (inherits(cond, "condition")) {
[10:21:19.676]                         if (!is.null(pattern)) {
[10:21:19.676]                           computeRestarts <- base::computeRestarts
[10:21:19.676]                           grepl <- base::grepl
[10:21:19.676]                           restarts <- computeRestarts(cond)
[10:21:19.676]                           for (restart in restarts) {
[10:21:19.676]                             name <- restart$name
[10:21:19.676]                             if (is.null(name)) 
[10:21:19.676]                               next
[10:21:19.676]                             if (!grepl(pattern, name)) 
[10:21:19.676]                               next
[10:21:19.676]                             invokeRestart(restart)
[10:21:19.676]                             muffled <- TRUE
[10:21:19.676]                             break
[10:21:19.676]                           }
[10:21:19.676]                         }
[10:21:19.676]                       }
[10:21:19.676]                       invisible(muffled)
[10:21:19.676]                     }
[10:21:19.676]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.676]                   }
[10:21:19.676]                 }
[10:21:19.676]             }
[10:21:19.676]         }))
[10:21:19.676]     }, error = function(ex) {
[10:21:19.676]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.676]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.676]                 ...future.rng), started = ...future.startTime, 
[10:21:19.676]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.676]             version = "1.8"), class = "FutureResult")
[10:21:19.676]     }, finally = {
[10:21:19.676]         if (!identical(...future.workdir, getwd())) 
[10:21:19.676]             setwd(...future.workdir)
[10:21:19.676]         {
[10:21:19.676]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.676]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.676]             }
[10:21:19.676]             base::options(...future.oldOptions)
[10:21:19.676]             if (.Platform$OS.type == "windows") {
[10:21:19.676]                 old_names <- names(...future.oldEnvVars)
[10:21:19.676]                 envs <- base::Sys.getenv()
[10:21:19.676]                 names <- names(envs)
[10:21:19.676]                 common <- intersect(names, old_names)
[10:21:19.676]                 added <- setdiff(names, old_names)
[10:21:19.676]                 removed <- setdiff(old_names, names)
[10:21:19.676]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.676]                   envs[common]]
[10:21:19.676]                 NAMES <- toupper(changed)
[10:21:19.676]                 args <- list()
[10:21:19.676]                 for (kk in seq_along(NAMES)) {
[10:21:19.676]                   name <- changed[[kk]]
[10:21:19.676]                   NAME <- NAMES[[kk]]
[10:21:19.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.676]                     next
[10:21:19.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.676]                 }
[10:21:19.676]                 NAMES <- toupper(added)
[10:21:19.676]                 for (kk in seq_along(NAMES)) {
[10:21:19.676]                   name <- added[[kk]]
[10:21:19.676]                   NAME <- NAMES[[kk]]
[10:21:19.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.676]                     next
[10:21:19.676]                   args[[name]] <- ""
[10:21:19.676]                 }
[10:21:19.676]                 NAMES <- toupper(removed)
[10:21:19.676]                 for (kk in seq_along(NAMES)) {
[10:21:19.676]                   name <- removed[[kk]]
[10:21:19.676]                   NAME <- NAMES[[kk]]
[10:21:19.676]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.676]                     next
[10:21:19.676]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.676]                 }
[10:21:19.676]                 if (length(args) > 0) 
[10:21:19.676]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.676]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.676]             }
[10:21:19.676]             else {
[10:21:19.676]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.676]             }
[10:21:19.676]             {
[10:21:19.676]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.676]                   0L) {
[10:21:19.676]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.676]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.676]                   base::options(opts)
[10:21:19.676]                 }
[10:21:19.676]                 {
[10:21:19.676]                   {
[10:21:19.676]                     NULL
[10:21:19.676]                     RNGkind("Mersenne-Twister")
[10:21:19.676]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.676]                       inherits = FALSE)
[10:21:19.676]                   }
[10:21:19.676]                   options(future.plan = NULL)
[10:21:19.676]                   if (is.na(NA_character_)) 
[10:21:19.676]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.676]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.676]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.676]                     .init = FALSE)
[10:21:19.676]                 }
[10:21:19.676]             }
[10:21:19.676]         }
[10:21:19.676]     })
[10:21:19.676]     if (TRUE) {
[10:21:19.676]         base::sink(type = "output", split = FALSE)
[10:21:19.676]         if (TRUE) {
[10:21:19.676]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.676]         }
[10:21:19.676]         else {
[10:21:19.676]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.676]         }
[10:21:19.676]         base::close(...future.stdout)
[10:21:19.676]         ...future.stdout <- NULL
[10:21:19.676]     }
[10:21:19.676]     ...future.result$conditions <- ...future.conditions
[10:21:19.676]     ...future.result$finished <- base::Sys.time()
[10:21:19.676]     ...future.result
[10:21:19.676] }
[10:21:19.677] plan(): Setting new future strategy stack:
[10:21:19.678] List of future strategies:
[10:21:19.678] 1. sequential:
[10:21:19.678]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.678]    - tweaked: FALSE
[10:21:19.678]    - call: NULL
[10:21:19.678] plan(): nbrOfWorkers() = 1
[10:21:19.679] plan(): Setting new future strategy stack:
[10:21:19.679] List of future strategies:
[10:21:19.679] 1. sequential:
[10:21:19.679]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.679]    - tweaked: FALSE
[10:21:19.679]    - call: plan(strategy)
[10:21:19.679] plan(): nbrOfWorkers() = 1
[10:21:19.679] SequentialFuture started (and completed)
[10:21:19.679] - Launch lazy future ... done
[10:21:19.679] run() for ‘SequentialFuture’ ... done
[10:21:19.680] getGlobalsAndPackages() ...
[10:21:19.680] Searching for globals...
[10:21:19.680] - globals found: [1] ‘{’
[10:21:19.680] Searching for globals ... DONE
[10:21:19.681] Resolving globals: FALSE
[10:21:19.681] 
[10:21:19.681] 
[10:21:19.681] getGlobalsAndPackages() ... DONE
[10:21:19.681] run() for ‘Future’ ...
[10:21:19.681] - state: ‘created’
[10:21:19.681] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.682] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.682] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.682]   - Field: ‘label’
[10:21:19.682]   - Field: ‘local’
[10:21:19.682]   - Field: ‘owner’
[10:21:19.682]   - Field: ‘envir’
[10:21:19.682]   - Field: ‘packages’
[10:21:19.682]   - Field: ‘gc’
[10:21:19.682]   - Field: ‘conditions’
[10:21:19.682]   - Field: ‘expr’
[10:21:19.682]   - Field: ‘uuid’
[10:21:19.683]   - Field: ‘seed’
[10:21:19.683]   - Field: ‘version’
[10:21:19.683]   - Field: ‘result’
[10:21:19.683]   - Field: ‘asynchronous’
[10:21:19.683]   - Field: ‘calls’
[10:21:19.683]   - Field: ‘globals’
[10:21:19.683]   - Field: ‘stdout’
[10:21:19.683]   - Field: ‘earlySignal’
[10:21:19.683]   - Field: ‘lazy’
[10:21:19.683]   - Field: ‘state’
[10:21:19.683] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.683] - Launch lazy future ...
[10:21:19.684] Packages needed by the future expression (n = 0): <none>
[10:21:19.684] Packages needed by future strategies (n = 0): <none>
[10:21:19.684] {
[10:21:19.684]     {
[10:21:19.684]         {
[10:21:19.684]             ...future.startTime <- base::Sys.time()
[10:21:19.684]             {
[10:21:19.684]                 {
[10:21:19.684]                   {
[10:21:19.684]                     base::local({
[10:21:19.684]                       has_future <- base::requireNamespace("future", 
[10:21:19.684]                         quietly = TRUE)
[10:21:19.684]                       if (has_future) {
[10:21:19.684]                         ns <- base::getNamespace("future")
[10:21:19.684]                         version <- ns[[".package"]][["version"]]
[10:21:19.684]                         if (is.null(version)) 
[10:21:19.684]                           version <- utils::packageVersion("future")
[10:21:19.684]                       }
[10:21:19.684]                       else {
[10:21:19.684]                         version <- NULL
[10:21:19.684]                       }
[10:21:19.684]                       if (!has_future || version < "1.8.0") {
[10:21:19.684]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.684]                           "", base::R.version$version.string), 
[10:21:19.684]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.684]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.684]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.684]                             "release", "version")], collapse = " "), 
[10:21:19.684]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.684]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.684]                           info)
[10:21:19.684]                         info <- base::paste(info, collapse = "; ")
[10:21:19.684]                         if (!has_future) {
[10:21:19.684]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.684]                             info)
[10:21:19.684]                         }
[10:21:19.684]                         else {
[10:21:19.684]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.684]                             info, version)
[10:21:19.684]                         }
[10:21:19.684]                         base::stop(msg)
[10:21:19.684]                       }
[10:21:19.684]                     })
[10:21:19.684]                   }
[10:21:19.684]                   ...future.strategy.old <- future::plan("list")
[10:21:19.684]                   options(future.plan = NULL)
[10:21:19.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.684]                 }
[10:21:19.684]                 ...future.workdir <- getwd()
[10:21:19.684]             }
[10:21:19.684]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.684]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.684]         }
[10:21:19.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.684]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.684]             base::names(...future.oldOptions))
[10:21:19.684]     }
[10:21:19.684]     if (FALSE) {
[10:21:19.684]     }
[10:21:19.684]     else {
[10:21:19.684]         if (TRUE) {
[10:21:19.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.684]                 open = "w")
[10:21:19.684]         }
[10:21:19.684]         else {
[10:21:19.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.684]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.684]         }
[10:21:19.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.684]             base::sink(type = "output", split = FALSE)
[10:21:19.684]             base::close(...future.stdout)
[10:21:19.684]         }, add = TRUE)
[10:21:19.684]     }
[10:21:19.684]     ...future.frame <- base::sys.nframe()
[10:21:19.684]     ...future.conditions <- base::list()
[10:21:19.684]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.684]     if (FALSE) {
[10:21:19.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.684]     }
[10:21:19.684]     ...future.result <- base::tryCatch({
[10:21:19.684]         base::withCallingHandlers({
[10:21:19.684]             ...future.value <- base::withVisible(base::local({
[10:21:19.684]                 4
[10:21:19.684]             }))
[10:21:19.684]             future::FutureResult(value = ...future.value$value, 
[10:21:19.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.684]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.684]                     ...future.globalenv.names))
[10:21:19.684]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.684]         }, condition = base::local({
[10:21:19.684]             c <- base::c
[10:21:19.684]             inherits <- base::inherits
[10:21:19.684]             invokeRestart <- base::invokeRestart
[10:21:19.684]             length <- base::length
[10:21:19.684]             list <- base::list
[10:21:19.684]             seq.int <- base::seq.int
[10:21:19.684]             signalCondition <- base::signalCondition
[10:21:19.684]             sys.calls <- base::sys.calls
[10:21:19.684]             `[[` <- base::`[[`
[10:21:19.684]             `+` <- base::`+`
[10:21:19.684]             `<<-` <- base::`<<-`
[10:21:19.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.684]                   3L)]
[10:21:19.684]             }
[10:21:19.684]             function(cond) {
[10:21:19.684]                 is_error <- inherits(cond, "error")
[10:21:19.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.684]                   NULL)
[10:21:19.684]                 if (is_error) {
[10:21:19.684]                   sessionInformation <- function() {
[10:21:19.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.684]                       search = base::search(), system = base::Sys.info())
[10:21:19.684]                   }
[10:21:19.684]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.684]                     cond$call), session = sessionInformation(), 
[10:21:19.684]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.684]                   signalCondition(cond)
[10:21:19.684]                 }
[10:21:19.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.684]                 "immediateCondition"))) {
[10:21:19.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.684]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.684]                   if (TRUE && !signal) {
[10:21:19.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.684]                     {
[10:21:19.684]                       inherits <- base::inherits
[10:21:19.684]                       invokeRestart <- base::invokeRestart
[10:21:19.684]                       is.null <- base::is.null
[10:21:19.684]                       muffled <- FALSE
[10:21:19.684]                       if (inherits(cond, "message")) {
[10:21:19.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.684]                         if (muffled) 
[10:21:19.684]                           invokeRestart("muffleMessage")
[10:21:19.684]                       }
[10:21:19.684]                       else if (inherits(cond, "warning")) {
[10:21:19.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.684]                         if (muffled) 
[10:21:19.684]                           invokeRestart("muffleWarning")
[10:21:19.684]                       }
[10:21:19.684]                       else if (inherits(cond, "condition")) {
[10:21:19.684]                         if (!is.null(pattern)) {
[10:21:19.684]                           computeRestarts <- base::computeRestarts
[10:21:19.684]                           grepl <- base::grepl
[10:21:19.684]                           restarts <- computeRestarts(cond)
[10:21:19.684]                           for (restart in restarts) {
[10:21:19.684]                             name <- restart$name
[10:21:19.684]                             if (is.null(name)) 
[10:21:19.684]                               next
[10:21:19.684]                             if (!grepl(pattern, name)) 
[10:21:19.684]                               next
[10:21:19.684]                             invokeRestart(restart)
[10:21:19.684]                             muffled <- TRUE
[10:21:19.684]                             break
[10:21:19.684]                           }
[10:21:19.684]                         }
[10:21:19.684]                       }
[10:21:19.684]                       invisible(muffled)
[10:21:19.684]                     }
[10:21:19.684]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.684]                   }
[10:21:19.684]                 }
[10:21:19.684]                 else {
[10:21:19.684]                   if (TRUE) {
[10:21:19.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.684]                     {
[10:21:19.684]                       inherits <- base::inherits
[10:21:19.684]                       invokeRestart <- base::invokeRestart
[10:21:19.684]                       is.null <- base::is.null
[10:21:19.684]                       muffled <- FALSE
[10:21:19.684]                       if (inherits(cond, "message")) {
[10:21:19.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.684]                         if (muffled) 
[10:21:19.684]                           invokeRestart("muffleMessage")
[10:21:19.684]                       }
[10:21:19.684]                       else if (inherits(cond, "warning")) {
[10:21:19.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.684]                         if (muffled) 
[10:21:19.684]                           invokeRestart("muffleWarning")
[10:21:19.684]                       }
[10:21:19.684]                       else if (inherits(cond, "condition")) {
[10:21:19.684]                         if (!is.null(pattern)) {
[10:21:19.684]                           computeRestarts <- base::computeRestarts
[10:21:19.684]                           grepl <- base::grepl
[10:21:19.684]                           restarts <- computeRestarts(cond)
[10:21:19.684]                           for (restart in restarts) {
[10:21:19.684]                             name <- restart$name
[10:21:19.684]                             if (is.null(name)) 
[10:21:19.684]                               next
[10:21:19.684]                             if (!grepl(pattern, name)) 
[10:21:19.684]                               next
[10:21:19.684]                             invokeRestart(restart)
[10:21:19.684]                             muffled <- TRUE
[10:21:19.684]                             break
[10:21:19.684]                           }
[10:21:19.684]                         }
[10:21:19.684]                       }
[10:21:19.684]                       invisible(muffled)
[10:21:19.684]                     }
[10:21:19.684]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.684]                   }
[10:21:19.684]                 }
[10:21:19.684]             }
[10:21:19.684]         }))
[10:21:19.684]     }, error = function(ex) {
[10:21:19.684]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.684]                 ...future.rng), started = ...future.startTime, 
[10:21:19.684]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.684]             version = "1.8"), class = "FutureResult")
[10:21:19.684]     }, finally = {
[10:21:19.684]         if (!identical(...future.workdir, getwd())) 
[10:21:19.684]             setwd(...future.workdir)
[10:21:19.684]         {
[10:21:19.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.684]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.684]             }
[10:21:19.684]             base::options(...future.oldOptions)
[10:21:19.684]             if (.Platform$OS.type == "windows") {
[10:21:19.684]                 old_names <- names(...future.oldEnvVars)
[10:21:19.684]                 envs <- base::Sys.getenv()
[10:21:19.684]                 names <- names(envs)
[10:21:19.684]                 common <- intersect(names, old_names)
[10:21:19.684]                 added <- setdiff(names, old_names)
[10:21:19.684]                 removed <- setdiff(old_names, names)
[10:21:19.684]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.684]                   envs[common]]
[10:21:19.684]                 NAMES <- toupper(changed)
[10:21:19.684]                 args <- list()
[10:21:19.684]                 for (kk in seq_along(NAMES)) {
[10:21:19.684]                   name <- changed[[kk]]
[10:21:19.684]                   NAME <- NAMES[[kk]]
[10:21:19.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.684]                     next
[10:21:19.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.684]                 }
[10:21:19.684]                 NAMES <- toupper(added)
[10:21:19.684]                 for (kk in seq_along(NAMES)) {
[10:21:19.684]                   name <- added[[kk]]
[10:21:19.684]                   NAME <- NAMES[[kk]]
[10:21:19.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.684]                     next
[10:21:19.684]                   args[[name]] <- ""
[10:21:19.684]                 }
[10:21:19.684]                 NAMES <- toupper(removed)
[10:21:19.684]                 for (kk in seq_along(NAMES)) {
[10:21:19.684]                   name <- removed[[kk]]
[10:21:19.684]                   NAME <- NAMES[[kk]]
[10:21:19.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.684]                     next
[10:21:19.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.684]                 }
[10:21:19.684]                 if (length(args) > 0) 
[10:21:19.684]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.684]             }
[10:21:19.684]             else {
[10:21:19.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.684]             }
[10:21:19.684]             {
[10:21:19.684]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.684]                   0L) {
[10:21:19.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.684]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.684]                   base::options(opts)
[10:21:19.684]                 }
[10:21:19.684]                 {
[10:21:19.684]                   {
[10:21:19.684]                     NULL
[10:21:19.684]                     RNGkind("Mersenne-Twister")
[10:21:19.684]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.684]                       inherits = FALSE)
[10:21:19.684]                   }
[10:21:19.684]                   options(future.plan = NULL)
[10:21:19.684]                   if (is.na(NA_character_)) 
[10:21:19.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.684]                     .init = FALSE)
[10:21:19.684]                 }
[10:21:19.684]             }
[10:21:19.684]         }
[10:21:19.684]     })
[10:21:19.684]     if (TRUE) {
[10:21:19.684]         base::sink(type = "output", split = FALSE)
[10:21:19.684]         if (TRUE) {
[10:21:19.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.684]         }
[10:21:19.684]         else {
[10:21:19.684]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.684]         }
[10:21:19.684]         base::close(...future.stdout)
[10:21:19.684]         ...future.stdout <- NULL
[10:21:19.684]     }
[10:21:19.684]     ...future.result$conditions <- ...future.conditions
[10:21:19.684]     ...future.result$finished <- base::Sys.time()
[10:21:19.684]     ...future.result
[10:21:19.684] }
[10:21:19.686] plan(): Setting new future strategy stack:
[10:21:19.686] List of future strategies:
[10:21:19.686] 1. sequential:
[10:21:19.686]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.686]    - tweaked: FALSE
[10:21:19.686]    - call: NULL
[10:21:19.686] plan(): nbrOfWorkers() = 1
[10:21:19.687] plan(): Setting new future strategy stack:
[10:21:19.687] List of future strategies:
[10:21:19.687] 1. sequential:
[10:21:19.687]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.687]    - tweaked: FALSE
[10:21:19.687]    - call: plan(strategy)
[10:21:19.688] plan(): nbrOfWorkers() = 1
[10:21:19.688] SequentialFuture started (and completed)
[10:21:19.688] - Launch lazy future ... done
[10:21:19.688] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e54d4278> 
Classes 'listenv', 'environment' <environment: 0x55e8e525fba0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:21:19.691] resolved() for ‘SequentialFuture’ ...
[10:21:19.691] - state: ‘finished’
[10:21:19.691] - run: TRUE
[10:21:19.691] - result: ‘FutureResult’
[10:21:19.692] resolved() for ‘SequentialFuture’ ... done
[10:21:19.692] resolved() for ‘SequentialFuture’ ...
[10:21:19.692] - state: ‘finished’
[10:21:19.692] - run: TRUE
[10:21:19.692] - result: ‘FutureResult’
[10:21:19.692] resolved() for ‘SequentialFuture’ ... done
[10:21:19.692] resolved() for ‘SequentialFuture’ ...
[10:21:19.692] - state: ‘finished’
[10:21:19.692] - run: TRUE
[10:21:19.692] - result: ‘FutureResult’
[10:21:19.692] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:19.696] resolve() on list environment ...
[10:21:19.696]  recursive: 0
[10:21:19.697]  length: 6
[10:21:19.697]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:19.697] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.697] - nx: 6
[10:21:19.697] - relay: TRUE
[10:21:19.697] - stdout: TRUE
[10:21:19.697] - signal: TRUE
[10:21:19.697] - resignal: FALSE
[10:21:19.697] - force: TRUE
[10:21:19.697] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.697] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.698]  - until=2
[10:21:19.698]  - relaying element #2
[10:21:19.698] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.698] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.698] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.698]  length: 5 (resolved future 1)
[10:21:19.698] resolved() for ‘SequentialFuture’ ...
[10:21:19.698] - state: ‘finished’
[10:21:19.698] - run: TRUE
[10:21:19.698] - result: ‘FutureResult’
[10:21:19.698] resolved() for ‘SequentialFuture’ ... done
[10:21:19.699] Future #2
[10:21:19.699] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.699] - nx: 6
[10:21:19.699] - relay: TRUE
[10:21:19.699] - stdout: TRUE
[10:21:19.699] - signal: TRUE
[10:21:19.699] - resignal: FALSE
[10:21:19.699] - force: TRUE
[10:21:19.699] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.699] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.699]  - until=2
[10:21:19.699]  - relaying element #2
[10:21:19.700] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.700] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.700] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.700]  length: 4 (resolved future 2)
[10:21:19.700] resolved() for ‘SequentialFuture’ ...
[10:21:19.700] - state: ‘finished’
[10:21:19.700] - run: TRUE
[10:21:19.700] - result: ‘FutureResult’
[10:21:19.700] resolved() for ‘SequentialFuture’ ... done
[10:21:19.700] Future #3
[10:21:19.700] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.701] - nx: 6
[10:21:19.701] - relay: TRUE
[10:21:19.701] - stdout: TRUE
[10:21:19.701] - signal: TRUE
[10:21:19.701] - resignal: FALSE
[10:21:19.701] - force: TRUE
[10:21:19.701] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.701] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.701]  - until=3
[10:21:19.701]  - relaying element #3
[10:21:19.701] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.701] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.702] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.702]  length: 3 (resolved future 3)
[10:21:19.702] resolved() for ‘SequentialFuture’ ...
[10:21:19.702] - state: ‘finished’
[10:21:19.702] - run: TRUE
[10:21:19.702] - result: ‘FutureResult’
[10:21:19.702] resolved() for ‘SequentialFuture’ ... done
[10:21:19.702] Future #4
[10:21:19.702] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.702] - nx: 6
[10:21:19.702] - relay: TRUE
[10:21:19.702] - stdout: TRUE
[10:21:19.703] - signal: TRUE
[10:21:19.703] - resignal: FALSE
[10:21:19.703] - force: TRUE
[10:21:19.703] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.703] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.703]  - until=4
[10:21:19.703]  - relaying element #4
[10:21:19.703] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.703] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.703] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.703]  length: 2 (resolved future 4)
[10:21:19.704] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.704] - nx: 6
[10:21:19.704] - relay: TRUE
[10:21:19.704] - stdout: TRUE
[10:21:19.704] - signal: TRUE
[10:21:19.704] - resignal: FALSE
[10:21:19.704] - force: TRUE
[10:21:19.704] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.704] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.704]  - until=6
[10:21:19.704]  - relaying element #6
[10:21:19.704] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.704] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.704] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.705]  length: 1 (resolved future 5)
[10:21:19.705] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.705] - nx: 6
[10:21:19.705] - relay: TRUE
[10:21:19.705] - stdout: TRUE
[10:21:19.705] - signal: TRUE
[10:21:19.705] - resignal: FALSE
[10:21:19.705] - force: TRUE
[10:21:19.705] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.705] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.705]  - until=6
[10:21:19.705] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.705] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.706] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.706]  length: 0 (resolved future 6)
[10:21:19.706] Relaying remaining futures
[10:21:19.706] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.706] - nx: 6
[10:21:19.706] - relay: TRUE
[10:21:19.706] - stdout: TRUE
[10:21:19.706] - signal: TRUE
[10:21:19.706] - resignal: FALSE
[10:21:19.706] - force: TRUE
[10:21:19.706] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.706] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:19.706] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.707] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.707] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.707] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55e8e57eec88> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:21:19.709] getGlobalsAndPackages() ...
[10:21:19.709] Searching for globals...
[10:21:19.709] 
[10:21:19.709] Searching for globals ... DONE
[10:21:19.709] - globals: [0] <none>
[10:21:19.709] getGlobalsAndPackages() ... DONE
[10:21:19.710] run() for ‘Future’ ...
[10:21:19.710] - state: ‘created’
[10:21:19.710] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.710] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.710] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.710]   - Field: ‘label’
[10:21:19.710]   - Field: ‘local’
[10:21:19.710]   - Field: ‘owner’
[10:21:19.710]   - Field: ‘envir’
[10:21:19.711]   - Field: ‘packages’
[10:21:19.711]   - Field: ‘gc’
[10:21:19.711]   - Field: ‘conditions’
[10:21:19.711]   - Field: ‘expr’
[10:21:19.711]   - Field: ‘uuid’
[10:21:19.711]   - Field: ‘seed’
[10:21:19.711]   - Field: ‘version’
[10:21:19.711]   - Field: ‘result’
[10:21:19.711]   - Field: ‘asynchronous’
[10:21:19.711]   - Field: ‘calls’
[10:21:19.711]   - Field: ‘globals’
[10:21:19.711]   - Field: ‘stdout’
[10:21:19.712]   - Field: ‘earlySignal’
[10:21:19.712]   - Field: ‘lazy’
[10:21:19.712]   - Field: ‘state’
[10:21:19.712] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.712] - Launch lazy future ...
[10:21:19.712] Packages needed by the future expression (n = 0): <none>
[10:21:19.712] Packages needed by future strategies (n = 0): <none>
[10:21:19.712] {
[10:21:19.712]     {
[10:21:19.712]         {
[10:21:19.712]             ...future.startTime <- base::Sys.time()
[10:21:19.712]             {
[10:21:19.712]                 {
[10:21:19.712]                   {
[10:21:19.712]                     base::local({
[10:21:19.712]                       has_future <- base::requireNamespace("future", 
[10:21:19.712]                         quietly = TRUE)
[10:21:19.712]                       if (has_future) {
[10:21:19.712]                         ns <- base::getNamespace("future")
[10:21:19.712]                         version <- ns[[".package"]][["version"]]
[10:21:19.712]                         if (is.null(version)) 
[10:21:19.712]                           version <- utils::packageVersion("future")
[10:21:19.712]                       }
[10:21:19.712]                       else {
[10:21:19.712]                         version <- NULL
[10:21:19.712]                       }
[10:21:19.712]                       if (!has_future || version < "1.8.0") {
[10:21:19.712]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.712]                           "", base::R.version$version.string), 
[10:21:19.712]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.712]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.712]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.712]                             "release", "version")], collapse = " "), 
[10:21:19.712]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.712]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.712]                           info)
[10:21:19.712]                         info <- base::paste(info, collapse = "; ")
[10:21:19.712]                         if (!has_future) {
[10:21:19.712]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.712]                             info)
[10:21:19.712]                         }
[10:21:19.712]                         else {
[10:21:19.712]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.712]                             info, version)
[10:21:19.712]                         }
[10:21:19.712]                         base::stop(msg)
[10:21:19.712]                       }
[10:21:19.712]                     })
[10:21:19.712]                   }
[10:21:19.712]                   ...future.strategy.old <- future::plan("list")
[10:21:19.712]                   options(future.plan = NULL)
[10:21:19.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.712]                 }
[10:21:19.712]                 ...future.workdir <- getwd()
[10:21:19.712]             }
[10:21:19.712]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.712]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.712]         }
[10:21:19.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.712]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.712]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.712]             base::names(...future.oldOptions))
[10:21:19.712]     }
[10:21:19.712]     if (FALSE) {
[10:21:19.712]     }
[10:21:19.712]     else {
[10:21:19.712]         if (TRUE) {
[10:21:19.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.712]                 open = "w")
[10:21:19.712]         }
[10:21:19.712]         else {
[10:21:19.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.712]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.712]         }
[10:21:19.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.712]             base::sink(type = "output", split = FALSE)
[10:21:19.712]             base::close(...future.stdout)
[10:21:19.712]         }, add = TRUE)
[10:21:19.712]     }
[10:21:19.712]     ...future.frame <- base::sys.nframe()
[10:21:19.712]     ...future.conditions <- base::list()
[10:21:19.712]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.712]     if (FALSE) {
[10:21:19.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.712]     }
[10:21:19.712]     ...future.result <- base::tryCatch({
[10:21:19.712]         base::withCallingHandlers({
[10:21:19.712]             ...future.value <- base::withVisible(base::local(2))
[10:21:19.712]             future::FutureResult(value = ...future.value$value, 
[10:21:19.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.712]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.712]                     ...future.globalenv.names))
[10:21:19.712]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.712]         }, condition = base::local({
[10:21:19.712]             c <- base::c
[10:21:19.712]             inherits <- base::inherits
[10:21:19.712]             invokeRestart <- base::invokeRestart
[10:21:19.712]             length <- base::length
[10:21:19.712]             list <- base::list
[10:21:19.712]             seq.int <- base::seq.int
[10:21:19.712]             signalCondition <- base::signalCondition
[10:21:19.712]             sys.calls <- base::sys.calls
[10:21:19.712]             `[[` <- base::`[[`
[10:21:19.712]             `+` <- base::`+`
[10:21:19.712]             `<<-` <- base::`<<-`
[10:21:19.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.712]                   3L)]
[10:21:19.712]             }
[10:21:19.712]             function(cond) {
[10:21:19.712]                 is_error <- inherits(cond, "error")
[10:21:19.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.712]                   NULL)
[10:21:19.712]                 if (is_error) {
[10:21:19.712]                   sessionInformation <- function() {
[10:21:19.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.712]                       search = base::search(), system = base::Sys.info())
[10:21:19.712]                   }
[10:21:19.712]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.712]                     cond$call), session = sessionInformation(), 
[10:21:19.712]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.712]                   signalCondition(cond)
[10:21:19.712]                 }
[10:21:19.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.712]                 "immediateCondition"))) {
[10:21:19.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.712]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.712]                   if (TRUE && !signal) {
[10:21:19.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.712]                     {
[10:21:19.712]                       inherits <- base::inherits
[10:21:19.712]                       invokeRestart <- base::invokeRestart
[10:21:19.712]                       is.null <- base::is.null
[10:21:19.712]                       muffled <- FALSE
[10:21:19.712]                       if (inherits(cond, "message")) {
[10:21:19.712]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.712]                         if (muffled) 
[10:21:19.712]                           invokeRestart("muffleMessage")
[10:21:19.712]                       }
[10:21:19.712]                       else if (inherits(cond, "warning")) {
[10:21:19.712]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.712]                         if (muffled) 
[10:21:19.712]                           invokeRestart("muffleWarning")
[10:21:19.712]                       }
[10:21:19.712]                       else if (inherits(cond, "condition")) {
[10:21:19.712]                         if (!is.null(pattern)) {
[10:21:19.712]                           computeRestarts <- base::computeRestarts
[10:21:19.712]                           grepl <- base::grepl
[10:21:19.712]                           restarts <- computeRestarts(cond)
[10:21:19.712]                           for (restart in restarts) {
[10:21:19.712]                             name <- restart$name
[10:21:19.712]                             if (is.null(name)) 
[10:21:19.712]                               next
[10:21:19.712]                             if (!grepl(pattern, name)) 
[10:21:19.712]                               next
[10:21:19.712]                             invokeRestart(restart)
[10:21:19.712]                             muffled <- TRUE
[10:21:19.712]                             break
[10:21:19.712]                           }
[10:21:19.712]                         }
[10:21:19.712]                       }
[10:21:19.712]                       invisible(muffled)
[10:21:19.712]                     }
[10:21:19.712]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.712]                   }
[10:21:19.712]                 }
[10:21:19.712]                 else {
[10:21:19.712]                   if (TRUE) {
[10:21:19.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.712]                     {
[10:21:19.712]                       inherits <- base::inherits
[10:21:19.712]                       invokeRestart <- base::invokeRestart
[10:21:19.712]                       is.null <- base::is.null
[10:21:19.712]                       muffled <- FALSE
[10:21:19.712]                       if (inherits(cond, "message")) {
[10:21:19.712]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.712]                         if (muffled) 
[10:21:19.712]                           invokeRestart("muffleMessage")
[10:21:19.712]                       }
[10:21:19.712]                       else if (inherits(cond, "warning")) {
[10:21:19.712]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.712]                         if (muffled) 
[10:21:19.712]                           invokeRestart("muffleWarning")
[10:21:19.712]                       }
[10:21:19.712]                       else if (inherits(cond, "condition")) {
[10:21:19.712]                         if (!is.null(pattern)) {
[10:21:19.712]                           computeRestarts <- base::computeRestarts
[10:21:19.712]                           grepl <- base::grepl
[10:21:19.712]                           restarts <- computeRestarts(cond)
[10:21:19.712]                           for (restart in restarts) {
[10:21:19.712]                             name <- restart$name
[10:21:19.712]                             if (is.null(name)) 
[10:21:19.712]                               next
[10:21:19.712]                             if (!grepl(pattern, name)) 
[10:21:19.712]                               next
[10:21:19.712]                             invokeRestart(restart)
[10:21:19.712]                             muffled <- TRUE
[10:21:19.712]                             break
[10:21:19.712]                           }
[10:21:19.712]                         }
[10:21:19.712]                       }
[10:21:19.712]                       invisible(muffled)
[10:21:19.712]                     }
[10:21:19.712]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.712]                   }
[10:21:19.712]                 }
[10:21:19.712]             }
[10:21:19.712]         }))
[10:21:19.712]     }, error = function(ex) {
[10:21:19.712]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.712]                 ...future.rng), started = ...future.startTime, 
[10:21:19.712]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.712]             version = "1.8"), class = "FutureResult")
[10:21:19.712]     }, finally = {
[10:21:19.712]         if (!identical(...future.workdir, getwd())) 
[10:21:19.712]             setwd(...future.workdir)
[10:21:19.712]         {
[10:21:19.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.712]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.712]             }
[10:21:19.712]             base::options(...future.oldOptions)
[10:21:19.712]             if (.Platform$OS.type == "windows") {
[10:21:19.712]                 old_names <- names(...future.oldEnvVars)
[10:21:19.712]                 envs <- base::Sys.getenv()
[10:21:19.712]                 names <- names(envs)
[10:21:19.712]                 common <- intersect(names, old_names)
[10:21:19.712]                 added <- setdiff(names, old_names)
[10:21:19.712]                 removed <- setdiff(old_names, names)
[10:21:19.712]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.712]                   envs[common]]
[10:21:19.712]                 NAMES <- toupper(changed)
[10:21:19.712]                 args <- list()
[10:21:19.712]                 for (kk in seq_along(NAMES)) {
[10:21:19.712]                   name <- changed[[kk]]
[10:21:19.712]                   NAME <- NAMES[[kk]]
[10:21:19.712]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.712]                     next
[10:21:19.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.712]                 }
[10:21:19.712]                 NAMES <- toupper(added)
[10:21:19.712]                 for (kk in seq_along(NAMES)) {
[10:21:19.712]                   name <- added[[kk]]
[10:21:19.712]                   NAME <- NAMES[[kk]]
[10:21:19.712]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.712]                     next
[10:21:19.712]                   args[[name]] <- ""
[10:21:19.712]                 }
[10:21:19.712]                 NAMES <- toupper(removed)
[10:21:19.712]                 for (kk in seq_along(NAMES)) {
[10:21:19.712]                   name <- removed[[kk]]
[10:21:19.712]                   NAME <- NAMES[[kk]]
[10:21:19.712]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.712]                     next
[10:21:19.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.712]                 }
[10:21:19.712]                 if (length(args) > 0) 
[10:21:19.712]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.712]             }
[10:21:19.712]             else {
[10:21:19.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.712]             }
[10:21:19.712]             {
[10:21:19.712]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.712]                   0L) {
[10:21:19.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.712]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.712]                   base::options(opts)
[10:21:19.712]                 }
[10:21:19.712]                 {
[10:21:19.712]                   {
[10:21:19.712]                     NULL
[10:21:19.712]                     RNGkind("Mersenne-Twister")
[10:21:19.712]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.712]                       inherits = FALSE)
[10:21:19.712]                   }
[10:21:19.712]                   options(future.plan = NULL)
[10:21:19.712]                   if (is.na(NA_character_)) 
[10:21:19.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.712]                     .init = FALSE)
[10:21:19.712]                 }
[10:21:19.712]             }
[10:21:19.712]         }
[10:21:19.712]     })
[10:21:19.712]     if (TRUE) {
[10:21:19.712]         base::sink(type = "output", split = FALSE)
[10:21:19.712]         if (TRUE) {
[10:21:19.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.712]         }
[10:21:19.712]         else {
[10:21:19.712]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.712]         }
[10:21:19.712]         base::close(...future.stdout)
[10:21:19.712]         ...future.stdout <- NULL
[10:21:19.712]     }
[10:21:19.712]     ...future.result$conditions <- ...future.conditions
[10:21:19.712]     ...future.result$finished <- base::Sys.time()
[10:21:19.712]     ...future.result
[10:21:19.712] }
[10:21:19.714] plan(): Setting new future strategy stack:
[10:21:19.714] List of future strategies:
[10:21:19.714] 1. sequential:
[10:21:19.714]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.714]    - tweaked: FALSE
[10:21:19.714]    - call: NULL
[10:21:19.715] plan(): nbrOfWorkers() = 1
[10:21:19.715] plan(): Setting new future strategy stack:
[10:21:19.716] List of future strategies:
[10:21:19.716] 1. sequential:
[10:21:19.716]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.716]    - tweaked: FALSE
[10:21:19.716]    - call: plan(strategy)
[10:21:19.716] plan(): nbrOfWorkers() = 1
[10:21:19.716] SequentialFuture started (and completed)
[10:21:19.716] - Launch lazy future ... done
[10:21:19.716] run() for ‘SequentialFuture’ ... done
[10:21:19.716] getGlobalsAndPackages() ...
[10:21:19.717] Searching for globals...
[10:21:19.717] 
[10:21:19.717] Searching for globals ... DONE
[10:21:19.717] - globals: [0] <none>
[10:21:19.717] getGlobalsAndPackages() ... DONE
[10:21:19.718] run() for ‘Future’ ...
[10:21:19.718] - state: ‘created’
[10:21:19.718] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.719] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.719] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.719]   - Field: ‘label’
[10:21:19.719]   - Field: ‘local’
[10:21:19.719]   - Field: ‘owner’
[10:21:19.719]   - Field: ‘envir’
[10:21:19.719]   - Field: ‘packages’
[10:21:19.719]   - Field: ‘gc’
[10:21:19.719]   - Field: ‘conditions’
[10:21:19.719]   - Field: ‘expr’
[10:21:19.720]   - Field: ‘uuid’
[10:21:19.720]   - Field: ‘seed’
[10:21:19.720]   - Field: ‘version’
[10:21:19.720]   - Field: ‘result’
[10:21:19.720]   - Field: ‘asynchronous’
[10:21:19.720]   - Field: ‘calls’
[10:21:19.720]   - Field: ‘globals’
[10:21:19.720]   - Field: ‘stdout’
[10:21:19.720]   - Field: ‘earlySignal’
[10:21:19.720]   - Field: ‘lazy’
[10:21:19.720]   - Field: ‘state’
[10:21:19.720] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.720] - Launch lazy future ...
[10:21:19.721] Packages needed by the future expression (n = 0): <none>
[10:21:19.721] Packages needed by future strategies (n = 0): <none>
[10:21:19.721] {
[10:21:19.721]     {
[10:21:19.721]         {
[10:21:19.721]             ...future.startTime <- base::Sys.time()
[10:21:19.721]             {
[10:21:19.721]                 {
[10:21:19.721]                   {
[10:21:19.721]                     base::local({
[10:21:19.721]                       has_future <- base::requireNamespace("future", 
[10:21:19.721]                         quietly = TRUE)
[10:21:19.721]                       if (has_future) {
[10:21:19.721]                         ns <- base::getNamespace("future")
[10:21:19.721]                         version <- ns[[".package"]][["version"]]
[10:21:19.721]                         if (is.null(version)) 
[10:21:19.721]                           version <- utils::packageVersion("future")
[10:21:19.721]                       }
[10:21:19.721]                       else {
[10:21:19.721]                         version <- NULL
[10:21:19.721]                       }
[10:21:19.721]                       if (!has_future || version < "1.8.0") {
[10:21:19.721]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.721]                           "", base::R.version$version.string), 
[10:21:19.721]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.721]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.721]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.721]                             "release", "version")], collapse = " "), 
[10:21:19.721]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.721]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.721]                           info)
[10:21:19.721]                         info <- base::paste(info, collapse = "; ")
[10:21:19.721]                         if (!has_future) {
[10:21:19.721]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.721]                             info)
[10:21:19.721]                         }
[10:21:19.721]                         else {
[10:21:19.721]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.721]                             info, version)
[10:21:19.721]                         }
[10:21:19.721]                         base::stop(msg)
[10:21:19.721]                       }
[10:21:19.721]                     })
[10:21:19.721]                   }
[10:21:19.721]                   ...future.strategy.old <- future::plan("list")
[10:21:19.721]                   options(future.plan = NULL)
[10:21:19.721]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.721]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.721]                 }
[10:21:19.721]                 ...future.workdir <- getwd()
[10:21:19.721]             }
[10:21:19.721]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.721]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.721]         }
[10:21:19.721]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.721]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.721]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.721]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.721]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.721]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.721]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.721]             base::names(...future.oldOptions))
[10:21:19.721]     }
[10:21:19.721]     if (FALSE) {
[10:21:19.721]     }
[10:21:19.721]     else {
[10:21:19.721]         if (TRUE) {
[10:21:19.721]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.721]                 open = "w")
[10:21:19.721]         }
[10:21:19.721]         else {
[10:21:19.721]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.721]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.721]         }
[10:21:19.721]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.721]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.721]             base::sink(type = "output", split = FALSE)
[10:21:19.721]             base::close(...future.stdout)
[10:21:19.721]         }, add = TRUE)
[10:21:19.721]     }
[10:21:19.721]     ...future.frame <- base::sys.nframe()
[10:21:19.721]     ...future.conditions <- base::list()
[10:21:19.721]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.721]     if (FALSE) {
[10:21:19.721]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.721]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.721]     }
[10:21:19.721]     ...future.result <- base::tryCatch({
[10:21:19.721]         base::withCallingHandlers({
[10:21:19.721]             ...future.value <- base::withVisible(base::local(NULL))
[10:21:19.721]             future::FutureResult(value = ...future.value$value, 
[10:21:19.721]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.721]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.721]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.721]                     ...future.globalenv.names))
[10:21:19.721]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.721]         }, condition = base::local({
[10:21:19.721]             c <- base::c
[10:21:19.721]             inherits <- base::inherits
[10:21:19.721]             invokeRestart <- base::invokeRestart
[10:21:19.721]             length <- base::length
[10:21:19.721]             list <- base::list
[10:21:19.721]             seq.int <- base::seq.int
[10:21:19.721]             signalCondition <- base::signalCondition
[10:21:19.721]             sys.calls <- base::sys.calls
[10:21:19.721]             `[[` <- base::`[[`
[10:21:19.721]             `+` <- base::`+`
[10:21:19.721]             `<<-` <- base::`<<-`
[10:21:19.721]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.721]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.721]                   3L)]
[10:21:19.721]             }
[10:21:19.721]             function(cond) {
[10:21:19.721]                 is_error <- inherits(cond, "error")
[10:21:19.721]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.721]                   NULL)
[10:21:19.721]                 if (is_error) {
[10:21:19.721]                   sessionInformation <- function() {
[10:21:19.721]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.721]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.721]                       search = base::search(), system = base::Sys.info())
[10:21:19.721]                   }
[10:21:19.721]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.721]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.721]                     cond$call), session = sessionInformation(), 
[10:21:19.721]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.721]                   signalCondition(cond)
[10:21:19.721]                 }
[10:21:19.721]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.721]                 "immediateCondition"))) {
[10:21:19.721]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.721]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.721]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.721]                   if (TRUE && !signal) {
[10:21:19.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.721]                     {
[10:21:19.721]                       inherits <- base::inherits
[10:21:19.721]                       invokeRestart <- base::invokeRestart
[10:21:19.721]                       is.null <- base::is.null
[10:21:19.721]                       muffled <- FALSE
[10:21:19.721]                       if (inherits(cond, "message")) {
[10:21:19.721]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.721]                         if (muffled) 
[10:21:19.721]                           invokeRestart("muffleMessage")
[10:21:19.721]                       }
[10:21:19.721]                       else if (inherits(cond, "warning")) {
[10:21:19.721]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.721]                         if (muffled) 
[10:21:19.721]                           invokeRestart("muffleWarning")
[10:21:19.721]                       }
[10:21:19.721]                       else if (inherits(cond, "condition")) {
[10:21:19.721]                         if (!is.null(pattern)) {
[10:21:19.721]                           computeRestarts <- base::computeRestarts
[10:21:19.721]                           grepl <- base::grepl
[10:21:19.721]                           restarts <- computeRestarts(cond)
[10:21:19.721]                           for (restart in restarts) {
[10:21:19.721]                             name <- restart$name
[10:21:19.721]                             if (is.null(name)) 
[10:21:19.721]                               next
[10:21:19.721]                             if (!grepl(pattern, name)) 
[10:21:19.721]                               next
[10:21:19.721]                             invokeRestart(restart)
[10:21:19.721]                             muffled <- TRUE
[10:21:19.721]                             break
[10:21:19.721]                           }
[10:21:19.721]                         }
[10:21:19.721]                       }
[10:21:19.721]                       invisible(muffled)
[10:21:19.721]                     }
[10:21:19.721]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.721]                   }
[10:21:19.721]                 }
[10:21:19.721]                 else {
[10:21:19.721]                   if (TRUE) {
[10:21:19.721]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.721]                     {
[10:21:19.721]                       inherits <- base::inherits
[10:21:19.721]                       invokeRestart <- base::invokeRestart
[10:21:19.721]                       is.null <- base::is.null
[10:21:19.721]                       muffled <- FALSE
[10:21:19.721]                       if (inherits(cond, "message")) {
[10:21:19.721]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.721]                         if (muffled) 
[10:21:19.721]                           invokeRestart("muffleMessage")
[10:21:19.721]                       }
[10:21:19.721]                       else if (inherits(cond, "warning")) {
[10:21:19.721]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.721]                         if (muffled) 
[10:21:19.721]                           invokeRestart("muffleWarning")
[10:21:19.721]                       }
[10:21:19.721]                       else if (inherits(cond, "condition")) {
[10:21:19.721]                         if (!is.null(pattern)) {
[10:21:19.721]                           computeRestarts <- base::computeRestarts
[10:21:19.721]                           grepl <- base::grepl
[10:21:19.721]                           restarts <- computeRestarts(cond)
[10:21:19.721]                           for (restart in restarts) {
[10:21:19.721]                             name <- restart$name
[10:21:19.721]                             if (is.null(name)) 
[10:21:19.721]                               next
[10:21:19.721]                             if (!grepl(pattern, name)) 
[10:21:19.721]                               next
[10:21:19.721]                             invokeRestart(restart)
[10:21:19.721]                             muffled <- TRUE
[10:21:19.721]                             break
[10:21:19.721]                           }
[10:21:19.721]                         }
[10:21:19.721]                       }
[10:21:19.721]                       invisible(muffled)
[10:21:19.721]                     }
[10:21:19.721]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.721]                   }
[10:21:19.721]                 }
[10:21:19.721]             }
[10:21:19.721]         }))
[10:21:19.721]     }, error = function(ex) {
[10:21:19.721]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.721]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.721]                 ...future.rng), started = ...future.startTime, 
[10:21:19.721]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.721]             version = "1.8"), class = "FutureResult")
[10:21:19.721]     }, finally = {
[10:21:19.721]         if (!identical(...future.workdir, getwd())) 
[10:21:19.721]             setwd(...future.workdir)
[10:21:19.721]         {
[10:21:19.721]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.721]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.721]             }
[10:21:19.721]             base::options(...future.oldOptions)
[10:21:19.721]             if (.Platform$OS.type == "windows") {
[10:21:19.721]                 old_names <- names(...future.oldEnvVars)
[10:21:19.721]                 envs <- base::Sys.getenv()
[10:21:19.721]                 names <- names(envs)
[10:21:19.721]                 common <- intersect(names, old_names)
[10:21:19.721]                 added <- setdiff(names, old_names)
[10:21:19.721]                 removed <- setdiff(old_names, names)
[10:21:19.721]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.721]                   envs[common]]
[10:21:19.721]                 NAMES <- toupper(changed)
[10:21:19.721]                 args <- list()
[10:21:19.721]                 for (kk in seq_along(NAMES)) {
[10:21:19.721]                   name <- changed[[kk]]
[10:21:19.721]                   NAME <- NAMES[[kk]]
[10:21:19.721]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.721]                     next
[10:21:19.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.721]                 }
[10:21:19.721]                 NAMES <- toupper(added)
[10:21:19.721]                 for (kk in seq_along(NAMES)) {
[10:21:19.721]                   name <- added[[kk]]
[10:21:19.721]                   NAME <- NAMES[[kk]]
[10:21:19.721]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.721]                     next
[10:21:19.721]                   args[[name]] <- ""
[10:21:19.721]                 }
[10:21:19.721]                 NAMES <- toupper(removed)
[10:21:19.721]                 for (kk in seq_along(NAMES)) {
[10:21:19.721]                   name <- removed[[kk]]
[10:21:19.721]                   NAME <- NAMES[[kk]]
[10:21:19.721]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.721]                     next
[10:21:19.721]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.721]                 }
[10:21:19.721]                 if (length(args) > 0) 
[10:21:19.721]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.721]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.721]             }
[10:21:19.721]             else {
[10:21:19.721]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.721]             }
[10:21:19.721]             {
[10:21:19.721]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.721]                   0L) {
[10:21:19.721]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.721]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.721]                   base::options(opts)
[10:21:19.721]                 }
[10:21:19.721]                 {
[10:21:19.721]                   {
[10:21:19.721]                     NULL
[10:21:19.721]                     RNGkind("Mersenne-Twister")
[10:21:19.721]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.721]                       inherits = FALSE)
[10:21:19.721]                   }
[10:21:19.721]                   options(future.plan = NULL)
[10:21:19.721]                   if (is.na(NA_character_)) 
[10:21:19.721]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.721]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.721]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.721]                     .init = FALSE)
[10:21:19.721]                 }
[10:21:19.721]             }
[10:21:19.721]         }
[10:21:19.721]     })
[10:21:19.721]     if (TRUE) {
[10:21:19.721]         base::sink(type = "output", split = FALSE)
[10:21:19.721]         if (TRUE) {
[10:21:19.721]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.721]         }
[10:21:19.721]         else {
[10:21:19.721]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.721]         }
[10:21:19.721]         base::close(...future.stdout)
[10:21:19.721]         ...future.stdout <- NULL
[10:21:19.721]     }
[10:21:19.721]     ...future.result$conditions <- ...future.conditions
[10:21:19.721]     ...future.result$finished <- base::Sys.time()
[10:21:19.721]     ...future.result
[10:21:19.721] }
[10:21:19.723] plan(): Setting new future strategy stack:
[10:21:19.723] List of future strategies:
[10:21:19.723] 1. sequential:
[10:21:19.723]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.723]    - tweaked: FALSE
[10:21:19.723]    - call: NULL
[10:21:19.723] plan(): nbrOfWorkers() = 1
[10:21:19.724] plan(): Setting new future strategy stack:
[10:21:19.724] List of future strategies:
[10:21:19.724] 1. sequential:
[10:21:19.724]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.724]    - tweaked: FALSE
[10:21:19.724]    - call: plan(strategy)
[10:21:19.725] plan(): nbrOfWorkers() = 1
[10:21:19.725] SequentialFuture started (and completed)
[10:21:19.725] - Launch lazy future ... done
[10:21:19.725] run() for ‘SequentialFuture’ ... done
[10:21:19.725] getGlobalsAndPackages() ...
[10:21:19.725] Searching for globals...
[10:21:19.726] - globals found: [1] ‘{’
[10:21:19.726] Searching for globals ... DONE
[10:21:19.726] Resolving globals: FALSE
[10:21:19.726] 
[10:21:19.726] 
[10:21:19.726] getGlobalsAndPackages() ... DONE
[10:21:19.727] run() for ‘Future’ ...
[10:21:19.727] - state: ‘created’
[10:21:19.727] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:19.727] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:19.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:19.727]   - Field: ‘label’
[10:21:19.727]   - Field: ‘local’
[10:21:19.727]   - Field: ‘owner’
[10:21:19.728]   - Field: ‘envir’
[10:21:19.728]   - Field: ‘packages’
[10:21:19.728]   - Field: ‘gc’
[10:21:19.728]   - Field: ‘conditions’
[10:21:19.728]   - Field: ‘expr’
[10:21:19.728]   - Field: ‘uuid’
[10:21:19.728]   - Field: ‘seed’
[10:21:19.728]   - Field: ‘version’
[10:21:19.728]   - Field: ‘result’
[10:21:19.728]   - Field: ‘asynchronous’
[10:21:19.728]   - Field: ‘calls’
[10:21:19.728]   - Field: ‘globals’
[10:21:19.728]   - Field: ‘stdout’
[10:21:19.729]   - Field: ‘earlySignal’
[10:21:19.729]   - Field: ‘lazy’
[10:21:19.729]   - Field: ‘state’
[10:21:19.729] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:19.729] - Launch lazy future ...
[10:21:19.729] Packages needed by the future expression (n = 0): <none>
[10:21:19.729] Packages needed by future strategies (n = 0): <none>
[10:21:19.730] {
[10:21:19.730]     {
[10:21:19.730]         {
[10:21:19.730]             ...future.startTime <- base::Sys.time()
[10:21:19.730]             {
[10:21:19.730]                 {
[10:21:19.730]                   {
[10:21:19.730]                     base::local({
[10:21:19.730]                       has_future <- base::requireNamespace("future", 
[10:21:19.730]                         quietly = TRUE)
[10:21:19.730]                       if (has_future) {
[10:21:19.730]                         ns <- base::getNamespace("future")
[10:21:19.730]                         version <- ns[[".package"]][["version"]]
[10:21:19.730]                         if (is.null(version)) 
[10:21:19.730]                           version <- utils::packageVersion("future")
[10:21:19.730]                       }
[10:21:19.730]                       else {
[10:21:19.730]                         version <- NULL
[10:21:19.730]                       }
[10:21:19.730]                       if (!has_future || version < "1.8.0") {
[10:21:19.730]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.730]                           "", base::R.version$version.string), 
[10:21:19.730]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:19.730]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.730]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.730]                             "release", "version")], collapse = " "), 
[10:21:19.730]                           hostname = base::Sys.info()[["nodename"]])
[10:21:19.730]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.730]                           info)
[10:21:19.730]                         info <- base::paste(info, collapse = "; ")
[10:21:19.730]                         if (!has_future) {
[10:21:19.730]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.730]                             info)
[10:21:19.730]                         }
[10:21:19.730]                         else {
[10:21:19.730]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.730]                             info, version)
[10:21:19.730]                         }
[10:21:19.730]                         base::stop(msg)
[10:21:19.730]                       }
[10:21:19.730]                     })
[10:21:19.730]                   }
[10:21:19.730]                   ...future.strategy.old <- future::plan("list")
[10:21:19.730]                   options(future.plan = NULL)
[10:21:19.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.730]                 }
[10:21:19.730]                 ...future.workdir <- getwd()
[10:21:19.730]             }
[10:21:19.730]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.730]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.730]         }
[10:21:19.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.730]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.730]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.730]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.730]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.730]             base::names(...future.oldOptions))
[10:21:19.730]     }
[10:21:19.730]     if (FALSE) {
[10:21:19.730]     }
[10:21:19.730]     else {
[10:21:19.730]         if (TRUE) {
[10:21:19.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.730]                 open = "w")
[10:21:19.730]         }
[10:21:19.730]         else {
[10:21:19.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.730]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.730]         }
[10:21:19.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.730]             base::sink(type = "output", split = FALSE)
[10:21:19.730]             base::close(...future.stdout)
[10:21:19.730]         }, add = TRUE)
[10:21:19.730]     }
[10:21:19.730]     ...future.frame <- base::sys.nframe()
[10:21:19.730]     ...future.conditions <- base::list()
[10:21:19.730]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.730]     if (FALSE) {
[10:21:19.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.730]     }
[10:21:19.730]     ...future.result <- base::tryCatch({
[10:21:19.730]         base::withCallingHandlers({
[10:21:19.730]             ...future.value <- base::withVisible(base::local({
[10:21:19.730]                 4
[10:21:19.730]             }))
[10:21:19.730]             future::FutureResult(value = ...future.value$value, 
[10:21:19.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.730]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.730]                     ...future.globalenv.names))
[10:21:19.730]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.730]         }, condition = base::local({
[10:21:19.730]             c <- base::c
[10:21:19.730]             inherits <- base::inherits
[10:21:19.730]             invokeRestart <- base::invokeRestart
[10:21:19.730]             length <- base::length
[10:21:19.730]             list <- base::list
[10:21:19.730]             seq.int <- base::seq.int
[10:21:19.730]             signalCondition <- base::signalCondition
[10:21:19.730]             sys.calls <- base::sys.calls
[10:21:19.730]             `[[` <- base::`[[`
[10:21:19.730]             `+` <- base::`+`
[10:21:19.730]             `<<-` <- base::`<<-`
[10:21:19.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.730]                   3L)]
[10:21:19.730]             }
[10:21:19.730]             function(cond) {
[10:21:19.730]                 is_error <- inherits(cond, "error")
[10:21:19.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.730]                   NULL)
[10:21:19.730]                 if (is_error) {
[10:21:19.730]                   sessionInformation <- function() {
[10:21:19.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.730]                       search = base::search(), system = base::Sys.info())
[10:21:19.730]                   }
[10:21:19.730]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.730]                     cond$call), session = sessionInformation(), 
[10:21:19.730]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.730]                   signalCondition(cond)
[10:21:19.730]                 }
[10:21:19.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.730]                 "immediateCondition"))) {
[10:21:19.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.730]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.730]                   if (TRUE && !signal) {
[10:21:19.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.730]                     {
[10:21:19.730]                       inherits <- base::inherits
[10:21:19.730]                       invokeRestart <- base::invokeRestart
[10:21:19.730]                       is.null <- base::is.null
[10:21:19.730]                       muffled <- FALSE
[10:21:19.730]                       if (inherits(cond, "message")) {
[10:21:19.730]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.730]                         if (muffled) 
[10:21:19.730]                           invokeRestart("muffleMessage")
[10:21:19.730]                       }
[10:21:19.730]                       else if (inherits(cond, "warning")) {
[10:21:19.730]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.730]                         if (muffled) 
[10:21:19.730]                           invokeRestart("muffleWarning")
[10:21:19.730]                       }
[10:21:19.730]                       else if (inherits(cond, "condition")) {
[10:21:19.730]                         if (!is.null(pattern)) {
[10:21:19.730]                           computeRestarts <- base::computeRestarts
[10:21:19.730]                           grepl <- base::grepl
[10:21:19.730]                           restarts <- computeRestarts(cond)
[10:21:19.730]                           for (restart in restarts) {
[10:21:19.730]                             name <- restart$name
[10:21:19.730]                             if (is.null(name)) 
[10:21:19.730]                               next
[10:21:19.730]                             if (!grepl(pattern, name)) 
[10:21:19.730]                               next
[10:21:19.730]                             invokeRestart(restart)
[10:21:19.730]                             muffled <- TRUE
[10:21:19.730]                             break
[10:21:19.730]                           }
[10:21:19.730]                         }
[10:21:19.730]                       }
[10:21:19.730]                       invisible(muffled)
[10:21:19.730]                     }
[10:21:19.730]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.730]                   }
[10:21:19.730]                 }
[10:21:19.730]                 else {
[10:21:19.730]                   if (TRUE) {
[10:21:19.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.730]                     {
[10:21:19.730]                       inherits <- base::inherits
[10:21:19.730]                       invokeRestart <- base::invokeRestart
[10:21:19.730]                       is.null <- base::is.null
[10:21:19.730]                       muffled <- FALSE
[10:21:19.730]                       if (inherits(cond, "message")) {
[10:21:19.730]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.730]                         if (muffled) 
[10:21:19.730]                           invokeRestart("muffleMessage")
[10:21:19.730]                       }
[10:21:19.730]                       else if (inherits(cond, "warning")) {
[10:21:19.730]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.730]                         if (muffled) 
[10:21:19.730]                           invokeRestart("muffleWarning")
[10:21:19.730]                       }
[10:21:19.730]                       else if (inherits(cond, "condition")) {
[10:21:19.730]                         if (!is.null(pattern)) {
[10:21:19.730]                           computeRestarts <- base::computeRestarts
[10:21:19.730]                           grepl <- base::grepl
[10:21:19.730]                           restarts <- computeRestarts(cond)
[10:21:19.730]                           for (restart in restarts) {
[10:21:19.730]                             name <- restart$name
[10:21:19.730]                             if (is.null(name)) 
[10:21:19.730]                               next
[10:21:19.730]                             if (!grepl(pattern, name)) 
[10:21:19.730]                               next
[10:21:19.730]                             invokeRestart(restart)
[10:21:19.730]                             muffled <- TRUE
[10:21:19.730]                             break
[10:21:19.730]                           }
[10:21:19.730]                         }
[10:21:19.730]                       }
[10:21:19.730]                       invisible(muffled)
[10:21:19.730]                     }
[10:21:19.730]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.730]                   }
[10:21:19.730]                 }
[10:21:19.730]             }
[10:21:19.730]         }))
[10:21:19.730]     }, error = function(ex) {
[10:21:19.730]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.730]                 ...future.rng), started = ...future.startTime, 
[10:21:19.730]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.730]             version = "1.8"), class = "FutureResult")
[10:21:19.730]     }, finally = {
[10:21:19.730]         if (!identical(...future.workdir, getwd())) 
[10:21:19.730]             setwd(...future.workdir)
[10:21:19.730]         {
[10:21:19.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.730]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.730]             }
[10:21:19.730]             base::options(...future.oldOptions)
[10:21:19.730]             if (.Platform$OS.type == "windows") {
[10:21:19.730]                 old_names <- names(...future.oldEnvVars)
[10:21:19.730]                 envs <- base::Sys.getenv()
[10:21:19.730]                 names <- names(envs)
[10:21:19.730]                 common <- intersect(names, old_names)
[10:21:19.730]                 added <- setdiff(names, old_names)
[10:21:19.730]                 removed <- setdiff(old_names, names)
[10:21:19.730]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.730]                   envs[common]]
[10:21:19.730]                 NAMES <- toupper(changed)
[10:21:19.730]                 args <- list()
[10:21:19.730]                 for (kk in seq_along(NAMES)) {
[10:21:19.730]                   name <- changed[[kk]]
[10:21:19.730]                   NAME <- NAMES[[kk]]
[10:21:19.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.730]                     next
[10:21:19.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.730]                 }
[10:21:19.730]                 NAMES <- toupper(added)
[10:21:19.730]                 for (kk in seq_along(NAMES)) {
[10:21:19.730]                   name <- added[[kk]]
[10:21:19.730]                   NAME <- NAMES[[kk]]
[10:21:19.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.730]                     next
[10:21:19.730]                   args[[name]] <- ""
[10:21:19.730]                 }
[10:21:19.730]                 NAMES <- toupper(removed)
[10:21:19.730]                 for (kk in seq_along(NAMES)) {
[10:21:19.730]                   name <- removed[[kk]]
[10:21:19.730]                   NAME <- NAMES[[kk]]
[10:21:19.730]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.730]                     next
[10:21:19.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.730]                 }
[10:21:19.730]                 if (length(args) > 0) 
[10:21:19.730]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.730]             }
[10:21:19.730]             else {
[10:21:19.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.730]             }
[10:21:19.730]             {
[10:21:19.730]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.730]                   0L) {
[10:21:19.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.730]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.730]                   base::options(opts)
[10:21:19.730]                 }
[10:21:19.730]                 {
[10:21:19.730]                   {
[10:21:19.730]                     NULL
[10:21:19.730]                     RNGkind("Mersenne-Twister")
[10:21:19.730]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:19.730]                       inherits = FALSE)
[10:21:19.730]                   }
[10:21:19.730]                   options(future.plan = NULL)
[10:21:19.730]                   if (is.na(NA_character_)) 
[10:21:19.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.730]                     .init = FALSE)
[10:21:19.730]                 }
[10:21:19.730]             }
[10:21:19.730]         }
[10:21:19.730]     })
[10:21:19.730]     if (TRUE) {
[10:21:19.730]         base::sink(type = "output", split = FALSE)
[10:21:19.730]         if (TRUE) {
[10:21:19.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.730]         }
[10:21:19.730]         else {
[10:21:19.730]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.730]         }
[10:21:19.730]         base::close(...future.stdout)
[10:21:19.730]         ...future.stdout <- NULL
[10:21:19.730]     }
[10:21:19.730]     ...future.result$conditions <- ...future.conditions
[10:21:19.730]     ...future.result$finished <- base::Sys.time()
[10:21:19.730]     ...future.result
[10:21:19.730] }
[10:21:19.731] plan(): Setting new future strategy stack:
[10:21:19.731] List of future strategies:
[10:21:19.731] 1. sequential:
[10:21:19.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.731]    - tweaked: FALSE
[10:21:19.731]    - call: NULL
[10:21:19.732] plan(): nbrOfWorkers() = 1
[10:21:19.732] plan(): Setting new future strategy stack:
[10:21:19.733] List of future strategies:
[10:21:19.733] 1. sequential:
[10:21:19.733]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.733]    - tweaked: FALSE
[10:21:19.733]    - call: plan(strategy)
[10:21:19.733] plan(): nbrOfWorkers() = 1
[10:21:19.733] SequentialFuture started (and completed)
[10:21:19.733] - Launch lazy future ... done
[10:21:19.733] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e5067228> 
Classes 'listenv', 'environment' <environment: 0x55e8e4e5fe28> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:21:19.737] resolved() for ‘SequentialFuture’ ...
[10:21:19.737] - state: ‘finished’
[10:21:19.737] - run: TRUE
[10:21:19.737] - result: ‘FutureResult’
[10:21:19.737] resolved() for ‘SequentialFuture’ ... done
[10:21:19.737] resolved() for ‘SequentialFuture’ ...
[10:21:19.737] - state: ‘finished’
[10:21:19.737] - run: TRUE
[10:21:19.738] - result: ‘FutureResult’
[10:21:19.738] resolved() for ‘SequentialFuture’ ... done
[10:21:19.738] resolved() for ‘SequentialFuture’ ...
[10:21:19.738] - state: ‘finished’
[10:21:19.738] - run: TRUE
[10:21:19.738] - result: ‘FutureResult’
[10:21:19.738] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:19.741] resolve() on list environment ...
[10:21:19.741]  recursive: 0
[10:21:19.741]  length: 6
[10:21:19.742]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:19.742] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.742] - nx: 6
[10:21:19.742] - relay: TRUE
[10:21:19.742] - stdout: TRUE
[10:21:19.742] - signal: TRUE
[10:21:19.742] - resignal: FALSE
[10:21:19.742] - force: TRUE
[10:21:19.742] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.742] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.742]  - until=2
[10:21:19.743]  - relaying element #2
[10:21:19.744] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.744] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.744] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.744]  length: 5 (resolved future 1)
[10:21:19.744] resolved() for ‘SequentialFuture’ ...
[10:21:19.744] - state: ‘finished’
[10:21:19.744] - run: TRUE
[10:21:19.744] - result: ‘FutureResult’
[10:21:19.744] resolved() for ‘SequentialFuture’ ... done
[10:21:19.744] Future #2
[10:21:19.745] signalConditionsASAP(SequentialFuture, pos=2) ...
[10:21:19.745] - nx: 6
[10:21:19.745] - relay: TRUE
[10:21:19.745] - stdout: TRUE
[10:21:19.745] - signal: TRUE
[10:21:19.745] - resignal: FALSE
[10:21:19.745] - force: TRUE
[10:21:19.745] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.745] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.745]  - until=2
[10:21:19.745]  - relaying element #2
[10:21:19.745] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.746] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.746] signalConditionsASAP(SequentialFuture, pos=2) ... done
[10:21:19.746]  length: 4 (resolved future 2)
[10:21:19.746] resolved() for ‘SequentialFuture’ ...
[10:21:19.746] - state: ‘finished’
[10:21:19.746] - run: TRUE
[10:21:19.746] - result: ‘FutureResult’
[10:21:19.746] resolved() for ‘SequentialFuture’ ... done
[10:21:19.746] Future #3
[10:21:19.746] signalConditionsASAP(SequentialFuture, pos=3) ...
[10:21:19.746] - nx: 6
[10:21:19.747] - relay: TRUE
[10:21:19.747] - stdout: TRUE
[10:21:19.747] - signal: TRUE
[10:21:19.747] - resignal: FALSE
[10:21:19.747] - force: TRUE
[10:21:19.747] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.747] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.747]  - until=3
[10:21:19.747]  - relaying element #3
[10:21:19.747] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.747] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.747] signalConditionsASAP(SequentialFuture, pos=3) ... done
[10:21:19.748]  length: 3 (resolved future 3)
[10:21:19.748] resolved() for ‘SequentialFuture’ ...
[10:21:19.748] - state: ‘finished’
[10:21:19.748] - run: TRUE
[10:21:19.748] - result: ‘FutureResult’
[10:21:19.748] resolved() for ‘SequentialFuture’ ... done
[10:21:19.748] Future #4
[10:21:19.748] signalConditionsASAP(SequentialFuture, pos=4) ...
[10:21:19.748] - nx: 6
[10:21:19.748] - relay: TRUE
[10:21:19.748] - stdout: TRUE
[10:21:19.749] - signal: TRUE
[10:21:19.749] - resignal: FALSE
[10:21:19.749] - force: TRUE
[10:21:19.749] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.749] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.749]  - until=4
[10:21:19.749]  - relaying element #4
[10:21:19.749] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.749] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.749] signalConditionsASAP(SequentialFuture, pos=4) ... done
[10:21:19.749]  length: 2 (resolved future 4)
[10:21:19.749] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.750] - nx: 6
[10:21:19.750] - relay: TRUE
[10:21:19.750] - stdout: TRUE
[10:21:19.750] - signal: TRUE
[10:21:19.750] - resignal: FALSE
[10:21:19.750] - force: TRUE
[10:21:19.750] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.750] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.750]  - until=6
[10:21:19.750]  - relaying element #6
[10:21:19.750] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.750] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.750] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.751]  length: 1 (resolved future 5)
[10:21:19.751] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.751] - nx: 6
[10:21:19.751] - relay: TRUE
[10:21:19.751] - stdout: TRUE
[10:21:19.751] - signal: TRUE
[10:21:19.751] - resignal: FALSE
[10:21:19.751] - force: TRUE
[10:21:19.751] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.751] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.751]  - until=6
[10:21:19.751] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.751] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.752] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.752]  length: 0 (resolved future 6)
[10:21:19.752] Relaying remaining futures
[10:21:19.752] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.752] - nx: 6
[10:21:19.752] - relay: TRUE
[10:21:19.752] - stdout: TRUE
[10:21:19.752] - signal: TRUE
[10:21:19.752] - resignal: FALSE
[10:21:19.752] - force: TRUE
[10:21:19.752] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.752] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:19.752] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.752] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.753] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.753] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55e8e5435fd8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[10:21:19.755] plan(): Setting new future strategy stack:
[10:21:19.755] List of future strategies:
[10:21:19.755] 1. multicore:
[10:21:19.755]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:19.755]    - tweaked: FALSE
[10:21:19.755]    - call: plan(strategy)
[10:21:19.757] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:21:19.757] getGlobalsAndPackages() ...
[10:21:19.757] Searching for globals...
[10:21:19.758] 
[10:21:19.758] Searching for globals ... DONE
[10:21:19.758] - globals: [0] <none>
[10:21:19.758] getGlobalsAndPackages() ... DONE
[10:21:19.758] run() for ‘Future’ ...
[10:21:19.758] - state: ‘created’
[10:21:19.758] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:19.760] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:19.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:19.760]   - Field: ‘label’
[10:21:19.760]   - Field: ‘local’
[10:21:19.760]   - Field: ‘owner’
[10:21:19.760]   - Field: ‘envir’
[10:21:19.760]   - Field: ‘workers’
[10:21:19.760]   - Field: ‘packages’
[10:21:19.761]   - Field: ‘gc’
[10:21:19.761]   - Field: ‘job’
[10:21:19.761]   - Field: ‘conditions’
[10:21:19.761]   - Field: ‘expr’
[10:21:19.761]   - Field: ‘uuid’
[10:21:19.761]   - Field: ‘seed’
[10:21:19.761]   - Field: ‘version’
[10:21:19.761]   - Field: ‘result’
[10:21:19.761]   - Field: ‘asynchronous’
[10:21:19.761]   - Field: ‘calls’
[10:21:19.761]   - Field: ‘globals’
[10:21:19.761]   - Field: ‘stdout’
[10:21:19.762]   - Field: ‘earlySignal’
[10:21:19.762]   - Field: ‘lazy’
[10:21:19.762]   - Field: ‘state’
[10:21:19.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:19.762] - Launch lazy future ...
[10:21:19.763] Packages needed by the future expression (n = 0): <none>
[10:21:19.763] Packages needed by future strategies (n = 0): <none>
[10:21:19.763] {
[10:21:19.763]     {
[10:21:19.763]         {
[10:21:19.763]             ...future.startTime <- base::Sys.time()
[10:21:19.763]             {
[10:21:19.763]                 {
[10:21:19.763]                   {
[10:21:19.763]                     {
[10:21:19.763]                       base::local({
[10:21:19.763]                         has_future <- base::requireNamespace("future", 
[10:21:19.763]                           quietly = TRUE)
[10:21:19.763]                         if (has_future) {
[10:21:19.763]                           ns <- base::getNamespace("future")
[10:21:19.763]                           version <- ns[[".package"]][["version"]]
[10:21:19.763]                           if (is.null(version)) 
[10:21:19.763]                             version <- utils::packageVersion("future")
[10:21:19.763]                         }
[10:21:19.763]                         else {
[10:21:19.763]                           version <- NULL
[10:21:19.763]                         }
[10:21:19.763]                         if (!has_future || version < "1.8.0") {
[10:21:19.763]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.763]                             "", base::R.version$version.string), 
[10:21:19.763]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:19.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.763]                               "release", "version")], collapse = " "), 
[10:21:19.763]                             hostname = base::Sys.info()[["nodename"]])
[10:21:19.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.763]                             info)
[10:21:19.763]                           info <- base::paste(info, collapse = "; ")
[10:21:19.763]                           if (!has_future) {
[10:21:19.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.763]                               info)
[10:21:19.763]                           }
[10:21:19.763]                           else {
[10:21:19.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.763]                               info, version)
[10:21:19.763]                           }
[10:21:19.763]                           base::stop(msg)
[10:21:19.763]                         }
[10:21:19.763]                       })
[10:21:19.763]                     }
[10:21:19.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:19.763]                     base::options(mc.cores = 1L)
[10:21:19.763]                   }
[10:21:19.763]                   ...future.strategy.old <- future::plan("list")
[10:21:19.763]                   options(future.plan = NULL)
[10:21:19.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.763]                 }
[10:21:19.763]                 ...future.workdir <- getwd()
[10:21:19.763]             }
[10:21:19.763]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.763]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.763]         }
[10:21:19.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.763]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.763]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.763]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.763]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.763]             base::names(...future.oldOptions))
[10:21:19.763]     }
[10:21:19.763]     if (FALSE) {
[10:21:19.763]     }
[10:21:19.763]     else {
[10:21:19.763]         if (TRUE) {
[10:21:19.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.763]                 open = "w")
[10:21:19.763]         }
[10:21:19.763]         else {
[10:21:19.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.763]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.763]         }
[10:21:19.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.763]             base::sink(type = "output", split = FALSE)
[10:21:19.763]             base::close(...future.stdout)
[10:21:19.763]         }, add = TRUE)
[10:21:19.763]     }
[10:21:19.763]     ...future.frame <- base::sys.nframe()
[10:21:19.763]     ...future.conditions <- base::list()
[10:21:19.763]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.763]     if (FALSE) {
[10:21:19.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.763]     }
[10:21:19.763]     ...future.result <- base::tryCatch({
[10:21:19.763]         base::withCallingHandlers({
[10:21:19.763]             ...future.value <- base::withVisible(base::local({
[10:21:19.763]                 withCallingHandlers({
[10:21:19.763]                   2
[10:21:19.763]                 }, immediateCondition = function(cond) {
[10:21:19.763]                   save_rds <- function (object, pathname, ...) 
[10:21:19.763]                   {
[10:21:19.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:19.763]                     if (file_test("-f", pathname_tmp)) {
[10:21:19.763]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:19.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.763]                         fi_tmp[["mtime"]])
[10:21:19.763]                     }
[10:21:19.763]                     tryCatch({
[10:21:19.763]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:19.763]                     }, error = function(ex) {
[10:21:19.763]                       msg <- conditionMessage(ex)
[10:21:19.763]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:19.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.763]                         fi_tmp[["mtime"]], msg)
[10:21:19.763]                       ex$message <- msg
[10:21:19.763]                       stop(ex)
[10:21:19.763]                     })
[10:21:19.763]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:19.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:19.763]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:19.763]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.763]                       fi <- file.info(pathname)
[10:21:19.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:19.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:19.763]                         fi[["size"]], fi[["mtime"]])
[10:21:19.763]                       stop(msg)
[10:21:19.763]                     }
[10:21:19.763]                     invisible(pathname)
[10:21:19.763]                   }
[10:21:19.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:19.763]                     rootPath = tempdir()) 
[10:21:19.763]                   {
[10:21:19.763]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:19.763]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:19.763]                       tmpdir = path, fileext = ".rds")
[10:21:19.763]                     save_rds(obj, file)
[10:21:19.763]                   }
[10:21:19.763]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:19.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.763]                   {
[10:21:19.763]                     inherits <- base::inherits
[10:21:19.763]                     invokeRestart <- base::invokeRestart
[10:21:19.763]                     is.null <- base::is.null
[10:21:19.763]                     muffled <- FALSE
[10:21:19.763]                     if (inherits(cond, "message")) {
[10:21:19.763]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:19.763]                       if (muffled) 
[10:21:19.763]                         invokeRestart("muffleMessage")
[10:21:19.763]                     }
[10:21:19.763]                     else if (inherits(cond, "warning")) {
[10:21:19.763]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:19.763]                       if (muffled) 
[10:21:19.763]                         invokeRestart("muffleWarning")
[10:21:19.763]                     }
[10:21:19.763]                     else if (inherits(cond, "condition")) {
[10:21:19.763]                       if (!is.null(pattern)) {
[10:21:19.763]                         computeRestarts <- base::computeRestarts
[10:21:19.763]                         grepl <- base::grepl
[10:21:19.763]                         restarts <- computeRestarts(cond)
[10:21:19.763]                         for (restart in restarts) {
[10:21:19.763]                           name <- restart$name
[10:21:19.763]                           if (is.null(name)) 
[10:21:19.763]                             next
[10:21:19.763]                           if (!grepl(pattern, name)) 
[10:21:19.763]                             next
[10:21:19.763]                           invokeRestart(restart)
[10:21:19.763]                           muffled <- TRUE
[10:21:19.763]                           break
[10:21:19.763]                         }
[10:21:19.763]                       }
[10:21:19.763]                     }
[10:21:19.763]                     invisible(muffled)
[10:21:19.763]                   }
[10:21:19.763]                   muffleCondition(cond)
[10:21:19.763]                 })
[10:21:19.763]             }))
[10:21:19.763]             future::FutureResult(value = ...future.value$value, 
[10:21:19.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.763]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.763]                     ...future.globalenv.names))
[10:21:19.763]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.763]         }, condition = base::local({
[10:21:19.763]             c <- base::c
[10:21:19.763]             inherits <- base::inherits
[10:21:19.763]             invokeRestart <- base::invokeRestart
[10:21:19.763]             length <- base::length
[10:21:19.763]             list <- base::list
[10:21:19.763]             seq.int <- base::seq.int
[10:21:19.763]             signalCondition <- base::signalCondition
[10:21:19.763]             sys.calls <- base::sys.calls
[10:21:19.763]             `[[` <- base::`[[`
[10:21:19.763]             `+` <- base::`+`
[10:21:19.763]             `<<-` <- base::`<<-`
[10:21:19.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.763]                   3L)]
[10:21:19.763]             }
[10:21:19.763]             function(cond) {
[10:21:19.763]                 is_error <- inherits(cond, "error")
[10:21:19.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.763]                   NULL)
[10:21:19.763]                 if (is_error) {
[10:21:19.763]                   sessionInformation <- function() {
[10:21:19.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.763]                       search = base::search(), system = base::Sys.info())
[10:21:19.763]                   }
[10:21:19.763]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.763]                     cond$call), session = sessionInformation(), 
[10:21:19.763]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.763]                   signalCondition(cond)
[10:21:19.763]                 }
[10:21:19.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.763]                 "immediateCondition"))) {
[10:21:19.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.763]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.763]                   if (TRUE && !signal) {
[10:21:19.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.763]                     {
[10:21:19.763]                       inherits <- base::inherits
[10:21:19.763]                       invokeRestart <- base::invokeRestart
[10:21:19.763]                       is.null <- base::is.null
[10:21:19.763]                       muffled <- FALSE
[10:21:19.763]                       if (inherits(cond, "message")) {
[10:21:19.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.763]                         if (muffled) 
[10:21:19.763]                           invokeRestart("muffleMessage")
[10:21:19.763]                       }
[10:21:19.763]                       else if (inherits(cond, "warning")) {
[10:21:19.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.763]                         if (muffled) 
[10:21:19.763]                           invokeRestart("muffleWarning")
[10:21:19.763]                       }
[10:21:19.763]                       else if (inherits(cond, "condition")) {
[10:21:19.763]                         if (!is.null(pattern)) {
[10:21:19.763]                           computeRestarts <- base::computeRestarts
[10:21:19.763]                           grepl <- base::grepl
[10:21:19.763]                           restarts <- computeRestarts(cond)
[10:21:19.763]                           for (restart in restarts) {
[10:21:19.763]                             name <- restart$name
[10:21:19.763]                             if (is.null(name)) 
[10:21:19.763]                               next
[10:21:19.763]                             if (!grepl(pattern, name)) 
[10:21:19.763]                               next
[10:21:19.763]                             invokeRestart(restart)
[10:21:19.763]                             muffled <- TRUE
[10:21:19.763]                             break
[10:21:19.763]                           }
[10:21:19.763]                         }
[10:21:19.763]                       }
[10:21:19.763]                       invisible(muffled)
[10:21:19.763]                     }
[10:21:19.763]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.763]                   }
[10:21:19.763]                 }
[10:21:19.763]                 else {
[10:21:19.763]                   if (TRUE) {
[10:21:19.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.763]                     {
[10:21:19.763]                       inherits <- base::inherits
[10:21:19.763]                       invokeRestart <- base::invokeRestart
[10:21:19.763]                       is.null <- base::is.null
[10:21:19.763]                       muffled <- FALSE
[10:21:19.763]                       if (inherits(cond, "message")) {
[10:21:19.763]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.763]                         if (muffled) 
[10:21:19.763]                           invokeRestart("muffleMessage")
[10:21:19.763]                       }
[10:21:19.763]                       else if (inherits(cond, "warning")) {
[10:21:19.763]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.763]                         if (muffled) 
[10:21:19.763]                           invokeRestart("muffleWarning")
[10:21:19.763]                       }
[10:21:19.763]                       else if (inherits(cond, "condition")) {
[10:21:19.763]                         if (!is.null(pattern)) {
[10:21:19.763]                           computeRestarts <- base::computeRestarts
[10:21:19.763]                           grepl <- base::grepl
[10:21:19.763]                           restarts <- computeRestarts(cond)
[10:21:19.763]                           for (restart in restarts) {
[10:21:19.763]                             name <- restart$name
[10:21:19.763]                             if (is.null(name)) 
[10:21:19.763]                               next
[10:21:19.763]                             if (!grepl(pattern, name)) 
[10:21:19.763]                               next
[10:21:19.763]                             invokeRestart(restart)
[10:21:19.763]                             muffled <- TRUE
[10:21:19.763]                             break
[10:21:19.763]                           }
[10:21:19.763]                         }
[10:21:19.763]                       }
[10:21:19.763]                       invisible(muffled)
[10:21:19.763]                     }
[10:21:19.763]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.763]                   }
[10:21:19.763]                 }
[10:21:19.763]             }
[10:21:19.763]         }))
[10:21:19.763]     }, error = function(ex) {
[10:21:19.763]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.763]                 ...future.rng), started = ...future.startTime, 
[10:21:19.763]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.763]             version = "1.8"), class = "FutureResult")
[10:21:19.763]     }, finally = {
[10:21:19.763]         if (!identical(...future.workdir, getwd())) 
[10:21:19.763]             setwd(...future.workdir)
[10:21:19.763]         {
[10:21:19.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.763]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.763]             }
[10:21:19.763]             base::options(...future.oldOptions)
[10:21:19.763]             if (.Platform$OS.type == "windows") {
[10:21:19.763]                 old_names <- names(...future.oldEnvVars)
[10:21:19.763]                 envs <- base::Sys.getenv()
[10:21:19.763]                 names <- names(envs)
[10:21:19.763]                 common <- intersect(names, old_names)
[10:21:19.763]                 added <- setdiff(names, old_names)
[10:21:19.763]                 removed <- setdiff(old_names, names)
[10:21:19.763]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.763]                   envs[common]]
[10:21:19.763]                 NAMES <- toupper(changed)
[10:21:19.763]                 args <- list()
[10:21:19.763]                 for (kk in seq_along(NAMES)) {
[10:21:19.763]                   name <- changed[[kk]]
[10:21:19.763]                   NAME <- NAMES[[kk]]
[10:21:19.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.763]                     next
[10:21:19.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.763]                 }
[10:21:19.763]                 NAMES <- toupper(added)
[10:21:19.763]                 for (kk in seq_along(NAMES)) {
[10:21:19.763]                   name <- added[[kk]]
[10:21:19.763]                   NAME <- NAMES[[kk]]
[10:21:19.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.763]                     next
[10:21:19.763]                   args[[name]] <- ""
[10:21:19.763]                 }
[10:21:19.763]                 NAMES <- toupper(removed)
[10:21:19.763]                 for (kk in seq_along(NAMES)) {
[10:21:19.763]                   name <- removed[[kk]]
[10:21:19.763]                   NAME <- NAMES[[kk]]
[10:21:19.763]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.763]                     next
[10:21:19.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.763]                 }
[10:21:19.763]                 if (length(args) > 0) 
[10:21:19.763]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.763]             }
[10:21:19.763]             else {
[10:21:19.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.763]             }
[10:21:19.763]             {
[10:21:19.763]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.763]                   0L) {
[10:21:19.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.763]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.763]                   base::options(opts)
[10:21:19.763]                 }
[10:21:19.763]                 {
[10:21:19.763]                   {
[10:21:19.763]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:19.763]                     NULL
[10:21:19.763]                   }
[10:21:19.763]                   options(future.plan = NULL)
[10:21:19.763]                   if (is.na(NA_character_)) 
[10:21:19.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.763]                     .init = FALSE)
[10:21:19.763]                 }
[10:21:19.763]             }
[10:21:19.763]         }
[10:21:19.763]     })
[10:21:19.763]     if (TRUE) {
[10:21:19.763]         base::sink(type = "output", split = FALSE)
[10:21:19.763]         if (TRUE) {
[10:21:19.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.763]         }
[10:21:19.763]         else {
[10:21:19.763]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.763]         }
[10:21:19.763]         base::close(...future.stdout)
[10:21:19.763]         ...future.stdout <- NULL
[10:21:19.763]     }
[10:21:19.763]     ...future.result$conditions <- ...future.conditions
[10:21:19.763]     ...future.result$finished <- base::Sys.time()
[10:21:19.763]     ...future.result
[10:21:19.763] }
[10:21:19.765] requestCore(): workers = 2
[10:21:19.768] MulticoreFuture started
[10:21:19.769] - Launch lazy future ... done
[10:21:19.769] plan(): Setting new future strategy stack:
[10:21:19.769] run() for ‘MulticoreFuture’ ... done
[10:21:19.770] getGlobalsAndPackages() ...
[10:21:19.770] Searching for globals...
[10:21:19.769] List of future strategies:
[10:21:19.769] 1. sequential:
[10:21:19.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.769]    - tweaked: FALSE
[10:21:19.769]    - call: NULL
[10:21:19.770] plan(): nbrOfWorkers() = 1
[10:21:19.771] 
[10:21:19.771] Searching for globals ... DONE
[10:21:19.771] - globals: [0] <none>
[10:21:19.771] getGlobalsAndPackages() ... DONE
[10:21:19.772] run() for ‘Future’ ...
[10:21:19.772] plan(): Setting new future strategy stack:
[10:21:19.772] - state: ‘created’
[10:21:19.773] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:19.773] List of future strategies:
[10:21:19.773] 1. multicore:
[10:21:19.773]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:19.773]    - tweaked: FALSE
[10:21:19.773]    - call: plan(strategy)
[10:21:19.775] plan(): nbrOfWorkers() = 2
[10:21:19.776] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:19.776] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:19.776]   - Field: ‘label’
[10:21:19.782]   - Field: ‘local’
[10:21:19.783]   - Field: ‘owner’
[10:21:19.783]   - Field: ‘envir’
[10:21:19.784]   - Field: ‘workers’
[10:21:19.784]   - Field: ‘packages’
[10:21:19.784]   - Field: ‘gc’
[10:21:19.785]   - Field: ‘job’
[10:21:19.785]   - Field: ‘conditions’
[10:21:19.786]   - Field: ‘expr’
[10:21:19.786]   - Field: ‘uuid’
[10:21:19.787]   - Field: ‘seed’
[10:21:19.787]   - Field: ‘version’
[10:21:19.788]   - Field: ‘result’
[10:21:19.788]   - Field: ‘asynchronous’
[10:21:19.789]   - Field: ‘calls’
[10:21:19.789]   - Field: ‘globals’
[10:21:19.789]   - Field: ‘stdout’
[10:21:19.789]   - Field: ‘earlySignal’
[10:21:19.789]   - Field: ‘lazy’
[10:21:19.790]   - Field: ‘state’
[10:21:19.790] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:19.790] - Launch lazy future ...
[10:21:19.791] Packages needed by the future expression (n = 0): <none>
[10:21:19.791] Packages needed by future strategies (n = 0): <none>
[10:21:19.792] {
[10:21:19.792]     {
[10:21:19.792]         {
[10:21:19.792]             ...future.startTime <- base::Sys.time()
[10:21:19.792]             {
[10:21:19.792]                 {
[10:21:19.792]                   {
[10:21:19.792]                     {
[10:21:19.792]                       base::local({
[10:21:19.792]                         has_future <- base::requireNamespace("future", 
[10:21:19.792]                           quietly = TRUE)
[10:21:19.792]                         if (has_future) {
[10:21:19.792]                           ns <- base::getNamespace("future")
[10:21:19.792]                           version <- ns[[".package"]][["version"]]
[10:21:19.792]                           if (is.null(version)) 
[10:21:19.792]                             version <- utils::packageVersion("future")
[10:21:19.792]                         }
[10:21:19.792]                         else {
[10:21:19.792]                           version <- NULL
[10:21:19.792]                         }
[10:21:19.792]                         if (!has_future || version < "1.8.0") {
[10:21:19.792]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.792]                             "", base::R.version$version.string), 
[10:21:19.792]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:19.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.792]                               "release", "version")], collapse = " "), 
[10:21:19.792]                             hostname = base::Sys.info()[["nodename"]])
[10:21:19.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.792]                             info)
[10:21:19.792]                           info <- base::paste(info, collapse = "; ")
[10:21:19.792]                           if (!has_future) {
[10:21:19.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.792]                               info)
[10:21:19.792]                           }
[10:21:19.792]                           else {
[10:21:19.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.792]                               info, version)
[10:21:19.792]                           }
[10:21:19.792]                           base::stop(msg)
[10:21:19.792]                         }
[10:21:19.792]                       })
[10:21:19.792]                     }
[10:21:19.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:19.792]                     base::options(mc.cores = 1L)
[10:21:19.792]                   }
[10:21:19.792]                   ...future.strategy.old <- future::plan("list")
[10:21:19.792]                   options(future.plan = NULL)
[10:21:19.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.792]                 }
[10:21:19.792]                 ...future.workdir <- getwd()
[10:21:19.792]             }
[10:21:19.792]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.792]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.792]         }
[10:21:19.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.792]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.792]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.792]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.792]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.792]             base::names(...future.oldOptions))
[10:21:19.792]     }
[10:21:19.792]     if (FALSE) {
[10:21:19.792]     }
[10:21:19.792]     else {
[10:21:19.792]         if (TRUE) {
[10:21:19.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.792]                 open = "w")
[10:21:19.792]         }
[10:21:19.792]         else {
[10:21:19.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.792]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.792]         }
[10:21:19.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.792]             base::sink(type = "output", split = FALSE)
[10:21:19.792]             base::close(...future.stdout)
[10:21:19.792]         }, add = TRUE)
[10:21:19.792]     }
[10:21:19.792]     ...future.frame <- base::sys.nframe()
[10:21:19.792]     ...future.conditions <- base::list()
[10:21:19.792]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.792]     if (FALSE) {
[10:21:19.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.792]     }
[10:21:19.792]     ...future.result <- base::tryCatch({
[10:21:19.792]         base::withCallingHandlers({
[10:21:19.792]             ...future.value <- base::withVisible(base::local({
[10:21:19.792]                 withCallingHandlers({
[10:21:19.792]                   NULL
[10:21:19.792]                 }, immediateCondition = function(cond) {
[10:21:19.792]                   save_rds <- function (object, pathname, ...) 
[10:21:19.792]                   {
[10:21:19.792]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:19.792]                     if (file_test("-f", pathname_tmp)) {
[10:21:19.792]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.792]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:19.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.792]                         fi_tmp[["mtime"]])
[10:21:19.792]                     }
[10:21:19.792]                     tryCatch({
[10:21:19.792]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:19.792]                     }, error = function(ex) {
[10:21:19.792]                       msg <- conditionMessage(ex)
[10:21:19.792]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.792]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:19.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.792]                         fi_tmp[["mtime"]], msg)
[10:21:19.792]                       ex$message <- msg
[10:21:19.792]                       stop(ex)
[10:21:19.792]                     })
[10:21:19.792]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:19.792]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:19.792]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:19.792]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.792]                       fi <- file.info(pathname)
[10:21:19.792]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:19.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.792]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:19.792]                         fi[["size"]], fi[["mtime"]])
[10:21:19.792]                       stop(msg)
[10:21:19.792]                     }
[10:21:19.792]                     invisible(pathname)
[10:21:19.792]                   }
[10:21:19.792]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:19.792]                     rootPath = tempdir()) 
[10:21:19.792]                   {
[10:21:19.792]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:19.792]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:19.792]                       tmpdir = path, fileext = ".rds")
[10:21:19.792]                     save_rds(obj, file)
[10:21:19.792]                   }
[10:21:19.792]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:19.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.792]                   {
[10:21:19.792]                     inherits <- base::inherits
[10:21:19.792]                     invokeRestart <- base::invokeRestart
[10:21:19.792]                     is.null <- base::is.null
[10:21:19.792]                     muffled <- FALSE
[10:21:19.792]                     if (inherits(cond, "message")) {
[10:21:19.792]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:19.792]                       if (muffled) 
[10:21:19.792]                         invokeRestart("muffleMessage")
[10:21:19.792]                     }
[10:21:19.792]                     else if (inherits(cond, "warning")) {
[10:21:19.792]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:19.792]                       if (muffled) 
[10:21:19.792]                         invokeRestart("muffleWarning")
[10:21:19.792]                     }
[10:21:19.792]                     else if (inherits(cond, "condition")) {
[10:21:19.792]                       if (!is.null(pattern)) {
[10:21:19.792]                         computeRestarts <- base::computeRestarts
[10:21:19.792]                         grepl <- base::grepl
[10:21:19.792]                         restarts <- computeRestarts(cond)
[10:21:19.792]                         for (restart in restarts) {
[10:21:19.792]                           name <- restart$name
[10:21:19.792]                           if (is.null(name)) 
[10:21:19.792]                             next
[10:21:19.792]                           if (!grepl(pattern, name)) 
[10:21:19.792]                             next
[10:21:19.792]                           invokeRestart(restart)
[10:21:19.792]                           muffled <- TRUE
[10:21:19.792]                           break
[10:21:19.792]                         }
[10:21:19.792]                       }
[10:21:19.792]                     }
[10:21:19.792]                     invisible(muffled)
[10:21:19.792]                   }
[10:21:19.792]                   muffleCondition(cond)
[10:21:19.792]                 })
[10:21:19.792]             }))
[10:21:19.792]             future::FutureResult(value = ...future.value$value, 
[10:21:19.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.792]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.792]                     ...future.globalenv.names))
[10:21:19.792]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.792]         }, condition = base::local({
[10:21:19.792]             c <- base::c
[10:21:19.792]             inherits <- base::inherits
[10:21:19.792]             invokeRestart <- base::invokeRestart
[10:21:19.792]             length <- base::length
[10:21:19.792]             list <- base::list
[10:21:19.792]             seq.int <- base::seq.int
[10:21:19.792]             signalCondition <- base::signalCondition
[10:21:19.792]             sys.calls <- base::sys.calls
[10:21:19.792]             `[[` <- base::`[[`
[10:21:19.792]             `+` <- base::`+`
[10:21:19.792]             `<<-` <- base::`<<-`
[10:21:19.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.792]                   3L)]
[10:21:19.792]             }
[10:21:19.792]             function(cond) {
[10:21:19.792]                 is_error <- inherits(cond, "error")
[10:21:19.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.792]                   NULL)
[10:21:19.792]                 if (is_error) {
[10:21:19.792]                   sessionInformation <- function() {
[10:21:19.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.792]                       search = base::search(), system = base::Sys.info())
[10:21:19.792]                   }
[10:21:19.792]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.792]                     cond$call), session = sessionInformation(), 
[10:21:19.792]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.792]                   signalCondition(cond)
[10:21:19.792]                 }
[10:21:19.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.792]                 "immediateCondition"))) {
[10:21:19.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.792]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.792]                   if (TRUE && !signal) {
[10:21:19.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.792]                     {
[10:21:19.792]                       inherits <- base::inherits
[10:21:19.792]                       invokeRestart <- base::invokeRestart
[10:21:19.792]                       is.null <- base::is.null
[10:21:19.792]                       muffled <- FALSE
[10:21:19.792]                       if (inherits(cond, "message")) {
[10:21:19.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.792]                         if (muffled) 
[10:21:19.792]                           invokeRestart("muffleMessage")
[10:21:19.792]                       }
[10:21:19.792]                       else if (inherits(cond, "warning")) {
[10:21:19.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.792]                         if (muffled) 
[10:21:19.792]                           invokeRestart("muffleWarning")
[10:21:19.792]                       }
[10:21:19.792]                       else if (inherits(cond, "condition")) {
[10:21:19.792]                         if (!is.null(pattern)) {
[10:21:19.792]                           computeRestarts <- base::computeRestarts
[10:21:19.792]                           grepl <- base::grepl
[10:21:19.792]                           restarts <- computeRestarts(cond)
[10:21:19.792]                           for (restart in restarts) {
[10:21:19.792]                             name <- restart$name
[10:21:19.792]                             if (is.null(name)) 
[10:21:19.792]                               next
[10:21:19.792]                             if (!grepl(pattern, name)) 
[10:21:19.792]                               next
[10:21:19.792]                             invokeRestart(restart)
[10:21:19.792]                             muffled <- TRUE
[10:21:19.792]                             break
[10:21:19.792]                           }
[10:21:19.792]                         }
[10:21:19.792]                       }
[10:21:19.792]                       invisible(muffled)
[10:21:19.792]                     }
[10:21:19.792]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.792]                   }
[10:21:19.792]                 }
[10:21:19.792]                 else {
[10:21:19.792]                   if (TRUE) {
[10:21:19.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.792]                     {
[10:21:19.792]                       inherits <- base::inherits
[10:21:19.792]                       invokeRestart <- base::invokeRestart
[10:21:19.792]                       is.null <- base::is.null
[10:21:19.792]                       muffled <- FALSE
[10:21:19.792]                       if (inherits(cond, "message")) {
[10:21:19.792]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.792]                         if (muffled) 
[10:21:19.792]                           invokeRestart("muffleMessage")
[10:21:19.792]                       }
[10:21:19.792]                       else if (inherits(cond, "warning")) {
[10:21:19.792]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.792]                         if (muffled) 
[10:21:19.792]                           invokeRestart("muffleWarning")
[10:21:19.792]                       }
[10:21:19.792]                       else if (inherits(cond, "condition")) {
[10:21:19.792]                         if (!is.null(pattern)) {
[10:21:19.792]                           computeRestarts <- base::computeRestarts
[10:21:19.792]                           grepl <- base::grepl
[10:21:19.792]                           restarts <- computeRestarts(cond)
[10:21:19.792]                           for (restart in restarts) {
[10:21:19.792]                             name <- restart$name
[10:21:19.792]                             if (is.null(name)) 
[10:21:19.792]                               next
[10:21:19.792]                             if (!grepl(pattern, name)) 
[10:21:19.792]                               next
[10:21:19.792]                             invokeRestart(restart)
[10:21:19.792]                             muffled <- TRUE
[10:21:19.792]                             break
[10:21:19.792]                           }
[10:21:19.792]                         }
[10:21:19.792]                       }
[10:21:19.792]                       invisible(muffled)
[10:21:19.792]                     }
[10:21:19.792]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.792]                   }
[10:21:19.792]                 }
[10:21:19.792]             }
[10:21:19.792]         }))
[10:21:19.792]     }, error = function(ex) {
[10:21:19.792]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.792]                 ...future.rng), started = ...future.startTime, 
[10:21:19.792]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.792]             version = "1.8"), class = "FutureResult")
[10:21:19.792]     }, finally = {
[10:21:19.792]         if (!identical(...future.workdir, getwd())) 
[10:21:19.792]             setwd(...future.workdir)
[10:21:19.792]         {
[10:21:19.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.792]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.792]             }
[10:21:19.792]             base::options(...future.oldOptions)
[10:21:19.792]             if (.Platform$OS.type == "windows") {
[10:21:19.792]                 old_names <- names(...future.oldEnvVars)
[10:21:19.792]                 envs <- base::Sys.getenv()
[10:21:19.792]                 names <- names(envs)
[10:21:19.792]                 common <- intersect(names, old_names)
[10:21:19.792]                 added <- setdiff(names, old_names)
[10:21:19.792]                 removed <- setdiff(old_names, names)
[10:21:19.792]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.792]                   envs[common]]
[10:21:19.792]                 NAMES <- toupper(changed)
[10:21:19.792]                 args <- list()
[10:21:19.792]                 for (kk in seq_along(NAMES)) {
[10:21:19.792]                   name <- changed[[kk]]
[10:21:19.792]                   NAME <- NAMES[[kk]]
[10:21:19.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.792]                     next
[10:21:19.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.792]                 }
[10:21:19.792]                 NAMES <- toupper(added)
[10:21:19.792]                 for (kk in seq_along(NAMES)) {
[10:21:19.792]                   name <- added[[kk]]
[10:21:19.792]                   NAME <- NAMES[[kk]]
[10:21:19.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.792]                     next
[10:21:19.792]                   args[[name]] <- ""
[10:21:19.792]                 }
[10:21:19.792]                 NAMES <- toupper(removed)
[10:21:19.792]                 for (kk in seq_along(NAMES)) {
[10:21:19.792]                   name <- removed[[kk]]
[10:21:19.792]                   NAME <- NAMES[[kk]]
[10:21:19.792]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.792]                     next
[10:21:19.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.792]                 }
[10:21:19.792]                 if (length(args) > 0) 
[10:21:19.792]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.792]             }
[10:21:19.792]             else {
[10:21:19.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.792]             }
[10:21:19.792]             {
[10:21:19.792]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.792]                   0L) {
[10:21:19.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.792]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.792]                   base::options(opts)
[10:21:19.792]                 }
[10:21:19.792]                 {
[10:21:19.792]                   {
[10:21:19.792]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:19.792]                     NULL
[10:21:19.792]                   }
[10:21:19.792]                   options(future.plan = NULL)
[10:21:19.792]                   if (is.na(NA_character_)) 
[10:21:19.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.792]                     .init = FALSE)
[10:21:19.792]                 }
[10:21:19.792]             }
[10:21:19.792]         }
[10:21:19.792]     })
[10:21:19.792]     if (TRUE) {
[10:21:19.792]         base::sink(type = "output", split = FALSE)
[10:21:19.792]         if (TRUE) {
[10:21:19.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.792]         }
[10:21:19.792]         else {
[10:21:19.792]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.792]         }
[10:21:19.792]         base::close(...future.stdout)
[10:21:19.792]         ...future.stdout <- NULL
[10:21:19.792]     }
[10:21:19.792]     ...future.result$conditions <- ...future.conditions
[10:21:19.792]     ...future.result$finished <- base::Sys.time()
[10:21:19.792]     ...future.result
[10:21:19.792] }
[10:21:19.795] requestCore(): workers = 2
[10:21:19.803] MulticoreFuture started
[10:21:19.804] - Launch lazy future ... done
[10:21:19.804] run() for ‘MulticoreFuture’ ... done
[10:21:19.804] plan(): Setting new future strategy stack:
List of 6
 $ a:[10:21:19.804] List of future strategies:
[10:21:19.804] 1. sequential:
[10:21:19.804]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.804]    - tweaked: FALSE
[10:21:19.804]    - call: NULL
[10:21:19.805] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e4f8ecc0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e54aaec0> 
 $  :[10:21:19.808] plan(): Setting new future strategy stack:
 NULL
 $  :[10:21:19.808] List of future strategies:
[10:21:19.808] 1. multicore:
[10:21:19.808]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:19.808]    - tweaked: FALSE
[10:21:19.808]    - call: plan(strategy)
 NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e4f8ecc0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e54aaec0> 
 $  :[10:21:19.811] plan(): nbrOfWorkers() = 2
 NULL
 $  : NULL
 $  : num 6
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:19.816] resolve() on list ...
[10:21:19.816]  recursive: 0
[10:21:19.816]  length: 6
[10:21:19.817]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:19.817] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.817] - nx: 6
[10:21:19.817] - relay: TRUE
[10:21:19.817] - stdout: TRUE
[10:21:19.817] - signal: TRUE
[10:21:19.818] - resignal: FALSE
[10:21:19.818] - force: TRUE
[10:21:19.818] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.818] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.818]  - until=2
[10:21:19.819]  - relaying element #2
[10:21:19.819] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.819] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.819] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.819]  length: 5 (resolved future 1)
[10:21:19.820] Future #2
[10:21:19.820] result() for MulticoreFuture ...
[10:21:19.822] result() for MulticoreFuture ...
[10:21:19.823] result() for MulticoreFuture ... done
[10:21:19.823] result() for MulticoreFuture ... done
[10:21:19.823] result() for MulticoreFuture ...
[10:21:19.823] result() for MulticoreFuture ... done
[10:21:19.823] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:19.823] - nx: 6
[10:21:19.824] - relay: TRUE
[10:21:19.824] - stdout: TRUE
[10:21:19.824] - signal: TRUE
[10:21:19.824] - resignal: FALSE
[10:21:19.824] - force: TRUE
[10:21:19.824] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.824] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.825]  - until=2
[10:21:19.825]  - relaying element #2
[10:21:19.825] result() for MulticoreFuture ...
[10:21:19.825] result() for MulticoreFuture ... done
[10:21:19.825] result() for MulticoreFuture ...
[10:21:19.825] result() for MulticoreFuture ... done
[10:21:19.826] result() for MulticoreFuture ...
[10:21:19.826] result() for MulticoreFuture ... done
[10:21:19.826] result() for MulticoreFuture ...
[10:21:19.826] result() for MulticoreFuture ... done
[10:21:19.826] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.827] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.827] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:19.827]  length: 4 (resolved future 2)
[10:21:19.827] Future #3
[10:21:19.827] result() for MulticoreFuture ...
[10:21:19.828] result() for MulticoreFuture ...
[10:21:19.828] result() for MulticoreFuture ... done
[10:21:19.829] result() for MulticoreFuture ... done
[10:21:19.829] result() for MulticoreFuture ...
[10:21:19.829] result() for MulticoreFuture ... done
[10:21:19.829] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:19.829] - nx: 6
[10:21:19.829] - relay: TRUE
[10:21:19.829] - stdout: TRUE
[10:21:19.829] - signal: TRUE
[10:21:19.829] - resignal: FALSE
[10:21:19.830] - force: TRUE
[10:21:19.830] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.830] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.830]  - until=3
[10:21:19.830]  - relaying element #3
[10:21:19.830] result() for MulticoreFuture ...
[10:21:19.830] result() for MulticoreFuture ... done
[10:21:19.831] result() for MulticoreFuture ...
[10:21:19.831] result() for MulticoreFuture ... done
[10:21:19.831] result() for MulticoreFuture ...
[10:21:19.831] result() for MulticoreFuture ... done
[10:21:19.831] result() for MulticoreFuture ...
[10:21:19.831] result() for MulticoreFuture ... done
[10:21:19.831] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.831] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.831] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:19.832]  length: 3 (resolved future 3)
[10:21:19.832] signalConditionsASAP(NULL, pos=4) ...
[10:21:19.832] - nx: 6
[10:21:19.832] - relay: TRUE
[10:21:19.832] - stdout: TRUE
[10:21:19.832] - signal: TRUE
[10:21:19.832] - resignal: FALSE
[10:21:19.832] - force: TRUE
[10:21:19.832] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.832] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.833]  - until=5
[10:21:19.833]  - relaying element #5
[10:21:19.833] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.833] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.833] signalConditionsASAP(NULL, pos=4) ... done
[10:21:19.833]  length: 2 (resolved future 4)
[10:21:19.833] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.833] - nx: 6
[10:21:19.833] - relay: TRUE
[10:21:19.834] - stdout: TRUE
[10:21:19.834] - signal: TRUE
[10:21:19.834] - resignal: FALSE
[10:21:19.834] - force: TRUE
[10:21:19.834] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.834] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.834]  - until=6
[10:21:19.834]  - relaying element #6
[10:21:19.834] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.834] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.835] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.835]  length: 1 (resolved future 5)
[10:21:19.835] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.835] - nx: 6
[10:21:19.835] - relay: TRUE
[10:21:19.835] - stdout: TRUE
[10:21:19.835] - signal: TRUE
[10:21:19.835] - resignal: FALSE
[10:21:19.835] - force: TRUE
[10:21:19.835] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.835] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.836]  - until=6
[10:21:19.836] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.836] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.836] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.836]  length: 0 (resolved future 6)
[10:21:19.836] Relaying remaining futures
[10:21:19.836] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.838] - nx: 6
[10:21:19.839] - relay: TRUE
[10:21:19.839] - stdout: TRUE
[10:21:19.839] - signal: TRUE
[10:21:19.839] - resignal: FALSE
[10:21:19.839] - force: TRUE
[10:21:19.839] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.839] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:19.840] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.840] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.840] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.840] resolve() on list ... DONE
[10:21:19.840] result() for MulticoreFuture ...
[10:21:19.840] result() for MulticoreFuture ... done
[10:21:19.841] result() for MulticoreFuture ...
[10:21:19.841] result() for MulticoreFuture ... done
[10:21:19.841] result() for MulticoreFuture ...
[10:21:19.841] result() for MulticoreFuture ... done
[10:21:19.841] result() for MulticoreFuture ...
[10:21:19.841] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[10:21:19.844] getGlobalsAndPackages() ...
[10:21:19.844] Searching for globals...
[10:21:19.844] 
[10:21:19.844] Searching for globals ... DONE
[10:21:19.844] - globals: [0] <none>
[10:21:19.844] getGlobalsAndPackages() ... DONE
[10:21:19.845] run() for ‘Future’ ...
[10:21:19.845] - state: ‘created’
[10:21:19.845] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:19.847] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:19.847] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:19.847]   - Field: ‘label’
[10:21:19.847]   - Field: ‘local’
[10:21:19.847]   - Field: ‘owner’
[10:21:19.847]   - Field: ‘envir’
[10:21:19.848]   - Field: ‘workers’
[10:21:19.848]   - Field: ‘packages’
[10:21:19.848]   - Field: ‘gc’
[10:21:19.848]   - Field: ‘job’
[10:21:19.848]   - Field: ‘conditions’
[10:21:19.848]   - Field: ‘expr’
[10:21:19.848]   - Field: ‘uuid’
[10:21:19.848]   - Field: ‘seed’
[10:21:19.848]   - Field: ‘version’
[10:21:19.848]   - Field: ‘result’
[10:21:19.848]   - Field: ‘asynchronous’
[10:21:19.849]   - Field: ‘calls’
[10:21:19.849]   - Field: ‘globals’
[10:21:19.849]   - Field: ‘stdout’
[10:21:19.849]   - Field: ‘earlySignal’
[10:21:19.849]   - Field: ‘lazy’
[10:21:19.849]   - Field: ‘state’
[10:21:19.849] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:19.849] - Launch lazy future ...
[10:21:19.849] Packages needed by the future expression (n = 0): <none>
[10:21:19.850] Packages needed by future strategies (n = 0): <none>
[10:21:19.850] {
[10:21:19.850]     {
[10:21:19.850]         {
[10:21:19.850]             ...future.startTime <- base::Sys.time()
[10:21:19.850]             {
[10:21:19.850]                 {
[10:21:19.850]                   {
[10:21:19.850]                     {
[10:21:19.850]                       base::local({
[10:21:19.850]                         has_future <- base::requireNamespace("future", 
[10:21:19.850]                           quietly = TRUE)
[10:21:19.850]                         if (has_future) {
[10:21:19.850]                           ns <- base::getNamespace("future")
[10:21:19.850]                           version <- ns[[".package"]][["version"]]
[10:21:19.850]                           if (is.null(version)) 
[10:21:19.850]                             version <- utils::packageVersion("future")
[10:21:19.850]                         }
[10:21:19.850]                         else {
[10:21:19.850]                           version <- NULL
[10:21:19.850]                         }
[10:21:19.850]                         if (!has_future || version < "1.8.0") {
[10:21:19.850]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.850]                             "", base::R.version$version.string), 
[10:21:19.850]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:19.850]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.850]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.850]                               "release", "version")], collapse = " "), 
[10:21:19.850]                             hostname = base::Sys.info()[["nodename"]])
[10:21:19.850]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.850]                             info)
[10:21:19.850]                           info <- base::paste(info, collapse = "; ")
[10:21:19.850]                           if (!has_future) {
[10:21:19.850]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.850]                               info)
[10:21:19.850]                           }
[10:21:19.850]                           else {
[10:21:19.850]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.850]                               info, version)
[10:21:19.850]                           }
[10:21:19.850]                           base::stop(msg)
[10:21:19.850]                         }
[10:21:19.850]                       })
[10:21:19.850]                     }
[10:21:19.850]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:19.850]                     base::options(mc.cores = 1L)
[10:21:19.850]                   }
[10:21:19.850]                   ...future.strategy.old <- future::plan("list")
[10:21:19.850]                   options(future.plan = NULL)
[10:21:19.850]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.850]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.850]                 }
[10:21:19.850]                 ...future.workdir <- getwd()
[10:21:19.850]             }
[10:21:19.850]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.850]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.850]         }
[10:21:19.850]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.850]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.850]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.850]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.850]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.850]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.850]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.850]             base::names(...future.oldOptions))
[10:21:19.850]     }
[10:21:19.850]     if (FALSE) {
[10:21:19.850]     }
[10:21:19.850]     else {
[10:21:19.850]         if (TRUE) {
[10:21:19.850]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.850]                 open = "w")
[10:21:19.850]         }
[10:21:19.850]         else {
[10:21:19.850]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.850]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.850]         }
[10:21:19.850]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.850]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.850]             base::sink(type = "output", split = FALSE)
[10:21:19.850]             base::close(...future.stdout)
[10:21:19.850]         }, add = TRUE)
[10:21:19.850]     }
[10:21:19.850]     ...future.frame <- base::sys.nframe()
[10:21:19.850]     ...future.conditions <- base::list()
[10:21:19.850]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.850]     if (FALSE) {
[10:21:19.850]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.850]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.850]     }
[10:21:19.850]     ...future.result <- base::tryCatch({
[10:21:19.850]         base::withCallingHandlers({
[10:21:19.850]             ...future.value <- base::withVisible(base::local({
[10:21:19.850]                 withCallingHandlers({
[10:21:19.850]                   2
[10:21:19.850]                 }, immediateCondition = function(cond) {
[10:21:19.850]                   save_rds <- function (object, pathname, ...) 
[10:21:19.850]                   {
[10:21:19.850]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:19.850]                     if (file_test("-f", pathname_tmp)) {
[10:21:19.850]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.850]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:19.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.850]                         fi_tmp[["mtime"]])
[10:21:19.850]                     }
[10:21:19.850]                     tryCatch({
[10:21:19.850]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:19.850]                     }, error = function(ex) {
[10:21:19.850]                       msg <- conditionMessage(ex)
[10:21:19.850]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.850]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:19.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.850]                         fi_tmp[["mtime"]], msg)
[10:21:19.850]                       ex$message <- msg
[10:21:19.850]                       stop(ex)
[10:21:19.850]                     })
[10:21:19.850]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:19.850]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:19.850]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:19.850]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.850]                       fi <- file.info(pathname)
[10:21:19.850]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:19.850]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.850]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:19.850]                         fi[["size"]], fi[["mtime"]])
[10:21:19.850]                       stop(msg)
[10:21:19.850]                     }
[10:21:19.850]                     invisible(pathname)
[10:21:19.850]                   }
[10:21:19.850]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:19.850]                     rootPath = tempdir()) 
[10:21:19.850]                   {
[10:21:19.850]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:19.850]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:19.850]                       tmpdir = path, fileext = ".rds")
[10:21:19.850]                     save_rds(obj, file)
[10:21:19.850]                   }
[10:21:19.850]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:19.850]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.850]                   {
[10:21:19.850]                     inherits <- base::inherits
[10:21:19.850]                     invokeRestart <- base::invokeRestart
[10:21:19.850]                     is.null <- base::is.null
[10:21:19.850]                     muffled <- FALSE
[10:21:19.850]                     if (inherits(cond, "message")) {
[10:21:19.850]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:19.850]                       if (muffled) 
[10:21:19.850]                         invokeRestart("muffleMessage")
[10:21:19.850]                     }
[10:21:19.850]                     else if (inherits(cond, "warning")) {
[10:21:19.850]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:19.850]                       if (muffled) 
[10:21:19.850]                         invokeRestart("muffleWarning")
[10:21:19.850]                     }
[10:21:19.850]                     else if (inherits(cond, "condition")) {
[10:21:19.850]                       if (!is.null(pattern)) {
[10:21:19.850]                         computeRestarts <- base::computeRestarts
[10:21:19.850]                         grepl <- base::grepl
[10:21:19.850]                         restarts <- computeRestarts(cond)
[10:21:19.850]                         for (restart in restarts) {
[10:21:19.850]                           name <- restart$name
[10:21:19.850]                           if (is.null(name)) 
[10:21:19.850]                             next
[10:21:19.850]                           if (!grepl(pattern, name)) 
[10:21:19.850]                             next
[10:21:19.850]                           invokeRestart(restart)
[10:21:19.850]                           muffled <- TRUE
[10:21:19.850]                           break
[10:21:19.850]                         }
[10:21:19.850]                       }
[10:21:19.850]                     }
[10:21:19.850]                     invisible(muffled)
[10:21:19.850]                   }
[10:21:19.850]                   muffleCondition(cond)
[10:21:19.850]                 })
[10:21:19.850]             }))
[10:21:19.850]             future::FutureResult(value = ...future.value$value, 
[10:21:19.850]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.850]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.850]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.850]                     ...future.globalenv.names))
[10:21:19.850]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.850]         }, condition = base::local({
[10:21:19.850]             c <- base::c
[10:21:19.850]             inherits <- base::inherits
[10:21:19.850]             invokeRestart <- base::invokeRestart
[10:21:19.850]             length <- base::length
[10:21:19.850]             list <- base::list
[10:21:19.850]             seq.int <- base::seq.int
[10:21:19.850]             signalCondition <- base::signalCondition
[10:21:19.850]             sys.calls <- base::sys.calls
[10:21:19.850]             `[[` <- base::`[[`
[10:21:19.850]             `+` <- base::`+`
[10:21:19.850]             `<<-` <- base::`<<-`
[10:21:19.850]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.850]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.850]                   3L)]
[10:21:19.850]             }
[10:21:19.850]             function(cond) {
[10:21:19.850]                 is_error <- inherits(cond, "error")
[10:21:19.850]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.850]                   NULL)
[10:21:19.850]                 if (is_error) {
[10:21:19.850]                   sessionInformation <- function() {
[10:21:19.850]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.850]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.850]                       search = base::search(), system = base::Sys.info())
[10:21:19.850]                   }
[10:21:19.850]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.850]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.850]                     cond$call), session = sessionInformation(), 
[10:21:19.850]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.850]                   signalCondition(cond)
[10:21:19.850]                 }
[10:21:19.850]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.850]                 "immediateCondition"))) {
[10:21:19.850]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.850]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.850]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.850]                   if (TRUE && !signal) {
[10:21:19.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.850]                     {
[10:21:19.850]                       inherits <- base::inherits
[10:21:19.850]                       invokeRestart <- base::invokeRestart
[10:21:19.850]                       is.null <- base::is.null
[10:21:19.850]                       muffled <- FALSE
[10:21:19.850]                       if (inherits(cond, "message")) {
[10:21:19.850]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.850]                         if (muffled) 
[10:21:19.850]                           invokeRestart("muffleMessage")
[10:21:19.850]                       }
[10:21:19.850]                       else if (inherits(cond, "warning")) {
[10:21:19.850]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.850]                         if (muffled) 
[10:21:19.850]                           invokeRestart("muffleWarning")
[10:21:19.850]                       }
[10:21:19.850]                       else if (inherits(cond, "condition")) {
[10:21:19.850]                         if (!is.null(pattern)) {
[10:21:19.850]                           computeRestarts <- base::computeRestarts
[10:21:19.850]                           grepl <- base::grepl
[10:21:19.850]                           restarts <- computeRestarts(cond)
[10:21:19.850]                           for (restart in restarts) {
[10:21:19.850]                             name <- restart$name
[10:21:19.850]                             if (is.null(name)) 
[10:21:19.850]                               next
[10:21:19.850]                             if (!grepl(pattern, name)) 
[10:21:19.850]                               next
[10:21:19.850]                             invokeRestart(restart)
[10:21:19.850]                             muffled <- TRUE
[10:21:19.850]                             break
[10:21:19.850]                           }
[10:21:19.850]                         }
[10:21:19.850]                       }
[10:21:19.850]                       invisible(muffled)
[10:21:19.850]                     }
[10:21:19.850]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.850]                   }
[10:21:19.850]                 }
[10:21:19.850]                 else {
[10:21:19.850]                   if (TRUE) {
[10:21:19.850]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.850]                     {
[10:21:19.850]                       inherits <- base::inherits
[10:21:19.850]                       invokeRestart <- base::invokeRestart
[10:21:19.850]                       is.null <- base::is.null
[10:21:19.850]                       muffled <- FALSE
[10:21:19.850]                       if (inherits(cond, "message")) {
[10:21:19.850]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.850]                         if (muffled) 
[10:21:19.850]                           invokeRestart("muffleMessage")
[10:21:19.850]                       }
[10:21:19.850]                       else if (inherits(cond, "warning")) {
[10:21:19.850]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.850]                         if (muffled) 
[10:21:19.850]                           invokeRestart("muffleWarning")
[10:21:19.850]                       }
[10:21:19.850]                       else if (inherits(cond, "condition")) {
[10:21:19.850]                         if (!is.null(pattern)) {
[10:21:19.850]                           computeRestarts <- base::computeRestarts
[10:21:19.850]                           grepl <- base::grepl
[10:21:19.850]                           restarts <- computeRestarts(cond)
[10:21:19.850]                           for (restart in restarts) {
[10:21:19.850]                             name <- restart$name
[10:21:19.850]                             if (is.null(name)) 
[10:21:19.850]                               next
[10:21:19.850]                             if (!grepl(pattern, name)) 
[10:21:19.850]                               next
[10:21:19.850]                             invokeRestart(restart)
[10:21:19.850]                             muffled <- TRUE
[10:21:19.850]                             break
[10:21:19.850]                           }
[10:21:19.850]                         }
[10:21:19.850]                       }
[10:21:19.850]                       invisible(muffled)
[10:21:19.850]                     }
[10:21:19.850]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.850]                   }
[10:21:19.850]                 }
[10:21:19.850]             }
[10:21:19.850]         }))
[10:21:19.850]     }, error = function(ex) {
[10:21:19.850]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.850]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.850]                 ...future.rng), started = ...future.startTime, 
[10:21:19.850]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.850]             version = "1.8"), class = "FutureResult")
[10:21:19.850]     }, finally = {
[10:21:19.850]         if (!identical(...future.workdir, getwd())) 
[10:21:19.850]             setwd(...future.workdir)
[10:21:19.850]         {
[10:21:19.850]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.850]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.850]             }
[10:21:19.850]             base::options(...future.oldOptions)
[10:21:19.850]             if (.Platform$OS.type == "windows") {
[10:21:19.850]                 old_names <- names(...future.oldEnvVars)
[10:21:19.850]                 envs <- base::Sys.getenv()
[10:21:19.850]                 names <- names(envs)
[10:21:19.850]                 common <- intersect(names, old_names)
[10:21:19.850]                 added <- setdiff(names, old_names)
[10:21:19.850]                 removed <- setdiff(old_names, names)
[10:21:19.850]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.850]                   envs[common]]
[10:21:19.850]                 NAMES <- toupper(changed)
[10:21:19.850]                 args <- list()
[10:21:19.850]                 for (kk in seq_along(NAMES)) {
[10:21:19.850]                   name <- changed[[kk]]
[10:21:19.850]                   NAME <- NAMES[[kk]]
[10:21:19.850]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.850]                     next
[10:21:19.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.850]                 }
[10:21:19.850]                 NAMES <- toupper(added)
[10:21:19.850]                 for (kk in seq_along(NAMES)) {
[10:21:19.850]                   name <- added[[kk]]
[10:21:19.850]                   NAME <- NAMES[[kk]]
[10:21:19.850]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.850]                     next
[10:21:19.850]                   args[[name]] <- ""
[10:21:19.850]                 }
[10:21:19.850]                 NAMES <- toupper(removed)
[10:21:19.850]                 for (kk in seq_along(NAMES)) {
[10:21:19.850]                   name <- removed[[kk]]
[10:21:19.850]                   NAME <- NAMES[[kk]]
[10:21:19.850]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.850]                     next
[10:21:19.850]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.850]                 }
[10:21:19.850]                 if (length(args) > 0) 
[10:21:19.850]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.850]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.850]             }
[10:21:19.850]             else {
[10:21:19.850]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.850]             }
[10:21:19.850]             {
[10:21:19.850]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.850]                   0L) {
[10:21:19.850]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.850]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.850]                   base::options(opts)
[10:21:19.850]                 }
[10:21:19.850]                 {
[10:21:19.850]                   {
[10:21:19.850]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:19.850]                     NULL
[10:21:19.850]                   }
[10:21:19.850]                   options(future.plan = NULL)
[10:21:19.850]                   if (is.na(NA_character_)) 
[10:21:19.850]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.850]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.850]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.850]                     .init = FALSE)
[10:21:19.850]                 }
[10:21:19.850]             }
[10:21:19.850]         }
[10:21:19.850]     })
[10:21:19.850]     if (TRUE) {
[10:21:19.850]         base::sink(type = "output", split = FALSE)
[10:21:19.850]         if (TRUE) {
[10:21:19.850]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.850]         }
[10:21:19.850]         else {
[10:21:19.850]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.850]         }
[10:21:19.850]         base::close(...future.stdout)
[10:21:19.850]         ...future.stdout <- NULL
[10:21:19.850]     }
[10:21:19.850]     ...future.result$conditions <- ...future.conditions
[10:21:19.850]     ...future.result$finished <- base::Sys.time()
[10:21:19.850]     ...future.result
[10:21:19.850] }
[10:21:19.852] requestCore(): workers = 2
[10:21:19.854] MulticoreFuture started
[10:21:19.854] - Launch lazy future ... done
[10:21:19.855] run() for ‘MulticoreFuture’ ... done
[10:21:19.855] getGlobalsAndPackages() ...
[10:21:19.855] plan(): Setting new future strategy stack:
[10:21:19.855] Searching for globals...
[10:21:19.856] 
[10:21:19.855] List of future strategies:
[10:21:19.855] 1. sequential:
[10:21:19.855]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.855]    - tweaked: FALSE
[10:21:19.855]    - call: NULL
[10:21:19.856] Searching for globals ... DONE
[10:21:19.856] plan(): nbrOfWorkers() = 1
[10:21:19.856] - globals: [0] <none>
[10:21:19.856] getGlobalsAndPackages() ... DONE
[10:21:19.857] run() for ‘Future’ ...
[10:21:19.857] - state: ‘created’
[10:21:19.858] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:19.858] plan(): Setting new future strategy stack:
[10:21:19.858] List of future strategies:
[10:21:19.858] 1. multicore:
[10:21:19.858]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:19.858]    - tweaked: FALSE
[10:21:19.858]    - call: plan(strategy)
[10:21:19.861] plan(): nbrOfWorkers() = 2
[10:21:19.861] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:19.861] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:19.861]   - Field: ‘label’
[10:21:19.861]   - Field: ‘local’
[10:21:19.861]   - Field: ‘owner’
[10:21:19.862]   - Field: ‘envir’
[10:21:19.862]   - Field: ‘workers’
[10:21:19.862]   - Field: ‘packages’
[10:21:19.862]   - Field: ‘gc’
[10:21:19.862]   - Field: ‘job’
[10:21:19.862]   - Field: ‘conditions’
[10:21:19.862]   - Field: ‘expr’
[10:21:19.863]   - Field: ‘uuid’
[10:21:19.863]   - Field: ‘seed’
[10:21:19.863]   - Field: ‘version’
[10:21:19.863]   - Field: ‘result’
[10:21:19.863]   - Field: ‘asynchronous’
[10:21:19.863]   - Field: ‘calls’
[10:21:19.864]   - Field: ‘globals’
[10:21:19.864]   - Field: ‘stdout’
[10:21:19.864]   - Field: ‘earlySignal’
[10:21:19.864]   - Field: ‘lazy’
[10:21:19.864]   - Field: ‘state’
[10:21:19.864] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:19.864] - Launch lazy future ...
[10:21:19.865] Packages needed by the future expression (n = 0): <none>
[10:21:19.865] Packages needed by future strategies (n = 0): <none>
[10:21:19.866] {
[10:21:19.866]     {
[10:21:19.866]         {
[10:21:19.866]             ...future.startTime <- base::Sys.time()
[10:21:19.866]             {
[10:21:19.866]                 {
[10:21:19.866]                   {
[10:21:19.866]                     {
[10:21:19.866]                       base::local({
[10:21:19.866]                         has_future <- base::requireNamespace("future", 
[10:21:19.866]                           quietly = TRUE)
[10:21:19.866]                         if (has_future) {
[10:21:19.866]                           ns <- base::getNamespace("future")
[10:21:19.866]                           version <- ns[[".package"]][["version"]]
[10:21:19.866]                           if (is.null(version)) 
[10:21:19.866]                             version <- utils::packageVersion("future")
[10:21:19.866]                         }
[10:21:19.866]                         else {
[10:21:19.866]                           version <- NULL
[10:21:19.866]                         }
[10:21:19.866]                         if (!has_future || version < "1.8.0") {
[10:21:19.866]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.866]                             "", base::R.version$version.string), 
[10:21:19.866]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:19.866]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.866]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.866]                               "release", "version")], collapse = " "), 
[10:21:19.866]                             hostname = base::Sys.info()[["nodename"]])
[10:21:19.866]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.866]                             info)
[10:21:19.866]                           info <- base::paste(info, collapse = "; ")
[10:21:19.866]                           if (!has_future) {
[10:21:19.866]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.866]                               info)
[10:21:19.866]                           }
[10:21:19.866]                           else {
[10:21:19.866]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.866]                               info, version)
[10:21:19.866]                           }
[10:21:19.866]                           base::stop(msg)
[10:21:19.866]                         }
[10:21:19.866]                       })
[10:21:19.866]                     }
[10:21:19.866]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:19.866]                     base::options(mc.cores = 1L)
[10:21:19.866]                   }
[10:21:19.866]                   ...future.strategy.old <- future::plan("list")
[10:21:19.866]                   options(future.plan = NULL)
[10:21:19.866]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.866]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.866]                 }
[10:21:19.866]                 ...future.workdir <- getwd()
[10:21:19.866]             }
[10:21:19.866]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.866]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.866]         }
[10:21:19.866]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.866]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.866]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.866]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.866]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.866]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.866]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.866]             base::names(...future.oldOptions))
[10:21:19.866]     }
[10:21:19.866]     if (FALSE) {
[10:21:19.866]     }
[10:21:19.866]     else {
[10:21:19.866]         if (TRUE) {
[10:21:19.866]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.866]                 open = "w")
[10:21:19.866]         }
[10:21:19.866]         else {
[10:21:19.866]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.866]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.866]         }
[10:21:19.866]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.866]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.866]             base::sink(type = "output", split = FALSE)
[10:21:19.866]             base::close(...future.stdout)
[10:21:19.866]         }, add = TRUE)
[10:21:19.866]     }
[10:21:19.866]     ...future.frame <- base::sys.nframe()
[10:21:19.866]     ...future.conditions <- base::list()
[10:21:19.866]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.866]     if (FALSE) {
[10:21:19.866]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.866]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.866]     }
[10:21:19.866]     ...future.result <- base::tryCatch({
[10:21:19.866]         base::withCallingHandlers({
[10:21:19.866]             ...future.value <- base::withVisible(base::local({
[10:21:19.866]                 withCallingHandlers({
[10:21:19.866]                   NULL
[10:21:19.866]                 }, immediateCondition = function(cond) {
[10:21:19.866]                   save_rds <- function (object, pathname, ...) 
[10:21:19.866]                   {
[10:21:19.866]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:19.866]                     if (file_test("-f", pathname_tmp)) {
[10:21:19.866]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.866]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:19.866]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.866]                         fi_tmp[["mtime"]])
[10:21:19.866]                     }
[10:21:19.866]                     tryCatch({
[10:21:19.866]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:19.866]                     }, error = function(ex) {
[10:21:19.866]                       msg <- conditionMessage(ex)
[10:21:19.866]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.866]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:19.866]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.866]                         fi_tmp[["mtime"]], msg)
[10:21:19.866]                       ex$message <- msg
[10:21:19.866]                       stop(ex)
[10:21:19.866]                     })
[10:21:19.866]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:19.866]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:19.866]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:19.866]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.866]                       fi <- file.info(pathname)
[10:21:19.866]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:19.866]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.866]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:19.866]                         fi[["size"]], fi[["mtime"]])
[10:21:19.866]                       stop(msg)
[10:21:19.866]                     }
[10:21:19.866]                     invisible(pathname)
[10:21:19.866]                   }
[10:21:19.866]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:19.866]                     rootPath = tempdir()) 
[10:21:19.866]                   {
[10:21:19.866]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:19.866]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:19.866]                       tmpdir = path, fileext = ".rds")
[10:21:19.866]                     save_rds(obj, file)
[10:21:19.866]                   }
[10:21:19.866]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:19.866]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.866]                   {
[10:21:19.866]                     inherits <- base::inherits
[10:21:19.866]                     invokeRestart <- base::invokeRestart
[10:21:19.866]                     is.null <- base::is.null
[10:21:19.866]                     muffled <- FALSE
[10:21:19.866]                     if (inherits(cond, "message")) {
[10:21:19.866]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:19.866]                       if (muffled) 
[10:21:19.866]                         invokeRestart("muffleMessage")
[10:21:19.866]                     }
[10:21:19.866]                     else if (inherits(cond, "warning")) {
[10:21:19.866]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:19.866]                       if (muffled) 
[10:21:19.866]                         invokeRestart("muffleWarning")
[10:21:19.866]                     }
[10:21:19.866]                     else if (inherits(cond, "condition")) {
[10:21:19.866]                       if (!is.null(pattern)) {
[10:21:19.866]                         computeRestarts <- base::computeRestarts
[10:21:19.866]                         grepl <- base::grepl
[10:21:19.866]                         restarts <- computeRestarts(cond)
[10:21:19.866]                         for (restart in restarts) {
[10:21:19.866]                           name <- restart$name
[10:21:19.866]                           if (is.null(name)) 
[10:21:19.866]                             next
[10:21:19.866]                           if (!grepl(pattern, name)) 
[10:21:19.866]                             next
[10:21:19.866]                           invokeRestart(restart)
[10:21:19.866]                           muffled <- TRUE
[10:21:19.866]                           break
[10:21:19.866]                         }
[10:21:19.866]                       }
[10:21:19.866]                     }
[10:21:19.866]                     invisible(muffled)
[10:21:19.866]                   }
[10:21:19.866]                   muffleCondition(cond)
[10:21:19.866]                 })
[10:21:19.866]             }))
[10:21:19.866]             future::FutureResult(value = ...future.value$value, 
[10:21:19.866]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.866]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.866]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.866]                     ...future.globalenv.names))
[10:21:19.866]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.866]         }, condition = base::local({
[10:21:19.866]             c <- base::c
[10:21:19.866]             inherits <- base::inherits
[10:21:19.866]             invokeRestart <- base::invokeRestart
[10:21:19.866]             length <- base::length
[10:21:19.866]             list <- base::list
[10:21:19.866]             seq.int <- base::seq.int
[10:21:19.866]             signalCondition <- base::signalCondition
[10:21:19.866]             sys.calls <- base::sys.calls
[10:21:19.866]             `[[` <- base::`[[`
[10:21:19.866]             `+` <- base::`+`
[10:21:19.866]             `<<-` <- base::`<<-`
[10:21:19.866]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.866]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.866]                   3L)]
[10:21:19.866]             }
[10:21:19.866]             function(cond) {
[10:21:19.866]                 is_error <- inherits(cond, "error")
[10:21:19.866]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.866]                   NULL)
[10:21:19.866]                 if (is_error) {
[10:21:19.866]                   sessionInformation <- function() {
[10:21:19.866]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.866]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.866]                       search = base::search(), system = base::Sys.info())
[10:21:19.866]                   }
[10:21:19.866]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.866]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.866]                     cond$call), session = sessionInformation(), 
[10:21:19.866]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.866]                   signalCondition(cond)
[10:21:19.866]                 }
[10:21:19.866]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.866]                 "immediateCondition"))) {
[10:21:19.866]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.866]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.866]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.866]                   if (TRUE && !signal) {
[10:21:19.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.866]                     {
[10:21:19.866]                       inherits <- base::inherits
[10:21:19.866]                       invokeRestart <- base::invokeRestart
[10:21:19.866]                       is.null <- base::is.null
[10:21:19.866]                       muffled <- FALSE
[10:21:19.866]                       if (inherits(cond, "message")) {
[10:21:19.866]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.866]                         if (muffled) 
[10:21:19.866]                           invokeRestart("muffleMessage")
[10:21:19.866]                       }
[10:21:19.866]                       else if (inherits(cond, "warning")) {
[10:21:19.866]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.866]                         if (muffled) 
[10:21:19.866]                           invokeRestart("muffleWarning")
[10:21:19.866]                       }
[10:21:19.866]                       else if (inherits(cond, "condition")) {
[10:21:19.866]                         if (!is.null(pattern)) {
[10:21:19.866]                           computeRestarts <- base::computeRestarts
[10:21:19.866]                           grepl <- base::grepl
[10:21:19.866]                           restarts <- computeRestarts(cond)
[10:21:19.866]                           for (restart in restarts) {
[10:21:19.866]                             name <- restart$name
[10:21:19.866]                             if (is.null(name)) 
[10:21:19.866]                               next
[10:21:19.866]                             if (!grepl(pattern, name)) 
[10:21:19.866]                               next
[10:21:19.866]                             invokeRestart(restart)
[10:21:19.866]                             muffled <- TRUE
[10:21:19.866]                             break
[10:21:19.866]                           }
[10:21:19.866]                         }
[10:21:19.866]                       }
[10:21:19.866]                       invisible(muffled)
[10:21:19.866]                     }
[10:21:19.866]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.866]                   }
[10:21:19.866]                 }
[10:21:19.866]                 else {
[10:21:19.866]                   if (TRUE) {
[10:21:19.866]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.866]                     {
[10:21:19.866]                       inherits <- base::inherits
[10:21:19.866]                       invokeRestart <- base::invokeRestart
[10:21:19.866]                       is.null <- base::is.null
[10:21:19.866]                       muffled <- FALSE
[10:21:19.866]                       if (inherits(cond, "message")) {
[10:21:19.866]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.866]                         if (muffled) 
[10:21:19.866]                           invokeRestart("muffleMessage")
[10:21:19.866]                       }
[10:21:19.866]                       else if (inherits(cond, "warning")) {
[10:21:19.866]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.866]                         if (muffled) 
[10:21:19.866]                           invokeRestart("muffleWarning")
[10:21:19.866]                       }
[10:21:19.866]                       else if (inherits(cond, "condition")) {
[10:21:19.866]                         if (!is.null(pattern)) {
[10:21:19.866]                           computeRestarts <- base::computeRestarts
[10:21:19.866]                           grepl <- base::grepl
[10:21:19.866]                           restarts <- computeRestarts(cond)
[10:21:19.866]                           for (restart in restarts) {
[10:21:19.866]                             name <- restart$name
[10:21:19.866]                             if (is.null(name)) 
[10:21:19.866]                               next
[10:21:19.866]                             if (!grepl(pattern, name)) 
[10:21:19.866]                               next
[10:21:19.866]                             invokeRestart(restart)
[10:21:19.866]                             muffled <- TRUE
[10:21:19.866]                             break
[10:21:19.866]                           }
[10:21:19.866]                         }
[10:21:19.866]                       }
[10:21:19.866]                       invisible(muffled)
[10:21:19.866]                     }
[10:21:19.866]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.866]                   }
[10:21:19.866]                 }
[10:21:19.866]             }
[10:21:19.866]         }))
[10:21:19.866]     }, error = function(ex) {
[10:21:19.866]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.866]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.866]                 ...future.rng), started = ...future.startTime, 
[10:21:19.866]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.866]             version = "1.8"), class = "FutureResult")
[10:21:19.866]     }, finally = {
[10:21:19.866]         if (!identical(...future.workdir, getwd())) 
[10:21:19.866]             setwd(...future.workdir)
[10:21:19.866]         {
[10:21:19.866]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.866]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.866]             }
[10:21:19.866]             base::options(...future.oldOptions)
[10:21:19.866]             if (.Platform$OS.type == "windows") {
[10:21:19.866]                 old_names <- names(...future.oldEnvVars)
[10:21:19.866]                 envs <- base::Sys.getenv()
[10:21:19.866]                 names <- names(envs)
[10:21:19.866]                 common <- intersect(names, old_names)
[10:21:19.866]                 added <- setdiff(names, old_names)
[10:21:19.866]                 removed <- setdiff(old_names, names)
[10:21:19.866]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.866]                   envs[common]]
[10:21:19.866]                 NAMES <- toupper(changed)
[10:21:19.866]                 args <- list()
[10:21:19.866]                 for (kk in seq_along(NAMES)) {
[10:21:19.866]                   name <- changed[[kk]]
[10:21:19.866]                   NAME <- NAMES[[kk]]
[10:21:19.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.866]                     next
[10:21:19.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.866]                 }
[10:21:19.866]                 NAMES <- toupper(added)
[10:21:19.866]                 for (kk in seq_along(NAMES)) {
[10:21:19.866]                   name <- added[[kk]]
[10:21:19.866]                   NAME <- NAMES[[kk]]
[10:21:19.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.866]                     next
[10:21:19.866]                   args[[name]] <- ""
[10:21:19.866]                 }
[10:21:19.866]                 NAMES <- toupper(removed)
[10:21:19.866]                 for (kk in seq_along(NAMES)) {
[10:21:19.866]                   name <- removed[[kk]]
[10:21:19.866]                   NAME <- NAMES[[kk]]
[10:21:19.866]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.866]                     next
[10:21:19.866]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.866]                 }
[10:21:19.866]                 if (length(args) > 0) 
[10:21:19.866]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.866]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.866]             }
[10:21:19.866]             else {
[10:21:19.866]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.866]             }
[10:21:19.866]             {
[10:21:19.866]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.866]                   0L) {
[10:21:19.866]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.866]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.866]                   base::options(opts)
[10:21:19.866]                 }
[10:21:19.866]                 {
[10:21:19.866]                   {
[10:21:19.866]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:19.866]                     NULL
[10:21:19.866]                   }
[10:21:19.866]                   options(future.plan = NULL)
[10:21:19.866]                   if (is.na(NA_character_)) 
[10:21:19.866]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.866]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.866]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.866]                     .init = FALSE)
[10:21:19.866]                 }
[10:21:19.866]             }
[10:21:19.866]         }
[10:21:19.866]     })
[10:21:19.866]     if (TRUE) {
[10:21:19.866]         base::sink(type = "output", split = FALSE)
[10:21:19.866]         if (TRUE) {
[10:21:19.866]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.866]         }
[10:21:19.866]         else {
[10:21:19.866]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.866]         }
[10:21:19.866]         base::close(...future.stdout)
[10:21:19.866]         ...future.stdout <- NULL
[10:21:19.866]     }
[10:21:19.866]     ...future.result$conditions <- ...future.conditions
[10:21:19.866]     ...future.result$finished <- base::Sys.time()
[10:21:19.866]     ...future.result
[10:21:19.866] }
[10:21:19.869] requestCore(): workers = 2
[10:21:19.871] MulticoreFuture started
[10:21:19.871] - Launch lazy future ... done
[10:21:19.872] run() for ‘MulticoreFuture’ ... done
List of 6
[10:21:19.872] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[10:21:19.872] List of future strategies:
[10:21:19.872] 1. sequential:
[10:21:19.872]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.872]    - tweaked: FALSE
[10:21:19.872]    - call: NULL
[10:21:19.873] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e31efe10> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e4b17850> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:21:19.875] plan(): Setting new future strategy stack:
List of 6
 $ a:[10:21:19.875] List of future strategies:
[10:21:19.875] 1. multicore:
[10:21:19.875]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:19.875]    - tweaked: FALSE
[10:21:19.875]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e31efe10> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e4b17850> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=[10:21:19.879] plan(): nbrOfWorkers() = 2
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:19.883] resolve() on list ...
[10:21:19.883]  recursive: 0
[10:21:19.883]  length: 6
[10:21:19.883]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:19.883] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.884] - nx: 6
[10:21:19.884] - relay: TRUE
[10:21:19.887] - stdout: TRUE
[10:21:19.888] - signal: TRUE
[10:21:19.888] - resignal: FALSE
[10:21:19.888] - force: TRUE
[10:21:19.889] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.889] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.889]  - until=2
[10:21:19.890]  - relaying element #2
[10:21:19.890] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.890] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.890] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.890]  length: 5 (resolved future 1)
[10:21:19.891] Future #2
[10:21:19.891] result() for MulticoreFuture ...
[10:21:19.892] result() for MulticoreFuture ...
[10:21:19.893] result() for MulticoreFuture ... done
[10:21:19.893] result() for MulticoreFuture ... done
[10:21:19.893] result() for MulticoreFuture ...
[10:21:19.893] result() for MulticoreFuture ... done
[10:21:19.893] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:19.893] - nx: 6
[10:21:19.894] - relay: TRUE
[10:21:19.894] - stdout: TRUE
[10:21:19.894] - signal: TRUE
[10:21:19.894] - resignal: FALSE
[10:21:19.894] - force: TRUE
[10:21:19.894] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.894] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.895]  - until=2
[10:21:19.895]  - relaying element #2
[10:21:19.895] result() for MulticoreFuture ...
[10:21:19.895] result() for MulticoreFuture ... done
[10:21:19.895] result() for MulticoreFuture ...
[10:21:19.895] result() for MulticoreFuture ... done
[10:21:19.896] result() for MulticoreFuture ...
[10:21:19.896] result() for MulticoreFuture ... done
[10:21:19.896] result() for MulticoreFuture ...
[10:21:19.896] result() for MulticoreFuture ... done
[10:21:19.896] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.896] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.897] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:19.897]  length: 4 (resolved future 2)
[10:21:19.897] Future #3
[10:21:19.897] result() for MulticoreFuture ...
[10:21:19.898] result() for MulticoreFuture ...
[10:21:19.898] result() for MulticoreFuture ... done
[10:21:19.898] result() for MulticoreFuture ... done
[10:21:19.898] result() for MulticoreFuture ...
[10:21:19.898] result() for MulticoreFuture ... done
[10:21:19.899] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:19.899] - nx: 6
[10:21:19.899] - relay: TRUE
[10:21:19.899] - stdout: TRUE
[10:21:19.899] - signal: TRUE
[10:21:19.899] - resignal: FALSE
[10:21:19.899] - force: TRUE
[10:21:19.899] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.899] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.900]  - until=3
[10:21:19.900]  - relaying element #3
[10:21:19.900] result() for MulticoreFuture ...
[10:21:19.900] result() for MulticoreFuture ... done
[10:21:19.900] result() for MulticoreFuture ...
[10:21:19.900] result() for MulticoreFuture ... done
[10:21:19.900] result() for MulticoreFuture ...
[10:21:19.900] result() for MulticoreFuture ... done
[10:21:19.901] result() for MulticoreFuture ...
[10:21:19.901] result() for MulticoreFuture ... done
[10:21:19.901] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.901] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.901] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:19.901]  length: 3 (resolved future 3)
[10:21:19.901] signalConditionsASAP(NULL, pos=4) ...
[10:21:19.901] - nx: 6
[10:21:19.901] - relay: TRUE
[10:21:19.901] - stdout: TRUE
[10:21:19.902] - signal: TRUE
[10:21:19.902] - resignal: FALSE
[10:21:19.902] - force: TRUE
[10:21:19.902] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.902] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.902]  - until=5
[10:21:19.902]  - relaying element #5
[10:21:19.902] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.902] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.902] signalConditionsASAP(NULL, pos=4) ... done
[10:21:19.903]  length: 2 (resolved future 4)
[10:21:19.903] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.903] - nx: 6
[10:21:19.903] - relay: TRUE
[10:21:19.903] - stdout: TRUE
[10:21:19.903] - signal: TRUE
[10:21:19.903] - resignal: FALSE
[10:21:19.903] - force: TRUE
[10:21:19.903] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.903] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.903]  - until=6
[10:21:19.904]  - relaying element #6
[10:21:19.904] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.904] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.904] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.904]  length: 1 (resolved future 5)
[10:21:19.904] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.904] - nx: 6
[10:21:19.904] - relay: TRUE
[10:21:19.904] - stdout: TRUE
[10:21:19.904] - signal: TRUE
[10:21:19.904] - resignal: FALSE
[10:21:19.905] - force: TRUE
[10:21:19.905] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.905] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.905]  - until=6
[10:21:19.905] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.905] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.905] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.905]  length: 0 (resolved future 6)
[10:21:19.905] Relaying remaining futures
[10:21:19.905] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.906] - nx: 6
[10:21:19.906] - relay: TRUE
[10:21:19.906] - stdout: TRUE
[10:21:19.906] - signal: TRUE
[10:21:19.906] - resignal: FALSE
[10:21:19.906] - force: TRUE
[10:21:19.906] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.906] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:19.906] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.906] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.906] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.907] resolve() on list ... DONE
[10:21:19.907] result() for MulticoreFuture ...
[10:21:19.907] result() for MulticoreFuture ... done
[10:21:19.907] result() for MulticoreFuture ...
[10:21:19.907] result() for MulticoreFuture ... done
[10:21:19.907] result() for MulticoreFuture ...
[10:21:19.907] result() for MulticoreFuture ... done
[10:21:19.907] result() for MulticoreFuture ...
[10:21:19.907] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:21:19.911] getGlobalsAndPackages() ...
[10:21:19.911] Searching for globals...
[10:21:19.911] 
[10:21:19.911] Searching for globals ... DONE
[10:21:19.911] - globals: [0] <none>
[10:21:19.911] getGlobalsAndPackages() ... DONE
[10:21:19.912] run() for ‘Future’ ...
[10:21:19.912] - state: ‘created’
[10:21:19.912] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:19.914] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:19.914] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:19.914]   - Field: ‘label’
[10:21:19.914]   - Field: ‘local’
[10:21:19.914]   - Field: ‘owner’
[10:21:19.914]   - Field: ‘envir’
[10:21:19.914]   - Field: ‘workers’
[10:21:19.914]   - Field: ‘packages’
[10:21:19.914]   - Field: ‘gc’
[10:21:19.914]   - Field: ‘job’
[10:21:19.915]   - Field: ‘conditions’
[10:21:19.915]   - Field: ‘expr’
[10:21:19.915]   - Field: ‘uuid’
[10:21:19.915]   - Field: ‘seed’
[10:21:19.915]   - Field: ‘version’
[10:21:19.915]   - Field: ‘result’
[10:21:19.915]   - Field: ‘asynchronous’
[10:21:19.915]   - Field: ‘calls’
[10:21:19.915]   - Field: ‘globals’
[10:21:19.915]   - Field: ‘stdout’
[10:21:19.915]   - Field: ‘earlySignal’
[10:21:19.916]   - Field: ‘lazy’
[10:21:19.916]   - Field: ‘state’
[10:21:19.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:19.916] - Launch lazy future ...
[10:21:19.916] Packages needed by the future expression (n = 0): <none>
[10:21:19.916] Packages needed by future strategies (n = 0): <none>
[10:21:19.917] {
[10:21:19.917]     {
[10:21:19.917]         {
[10:21:19.917]             ...future.startTime <- base::Sys.time()
[10:21:19.917]             {
[10:21:19.917]                 {
[10:21:19.917]                   {
[10:21:19.917]                     {
[10:21:19.917]                       base::local({
[10:21:19.917]                         has_future <- base::requireNamespace("future", 
[10:21:19.917]                           quietly = TRUE)
[10:21:19.917]                         if (has_future) {
[10:21:19.917]                           ns <- base::getNamespace("future")
[10:21:19.917]                           version <- ns[[".package"]][["version"]]
[10:21:19.917]                           if (is.null(version)) 
[10:21:19.917]                             version <- utils::packageVersion("future")
[10:21:19.917]                         }
[10:21:19.917]                         else {
[10:21:19.917]                           version <- NULL
[10:21:19.917]                         }
[10:21:19.917]                         if (!has_future || version < "1.8.0") {
[10:21:19.917]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.917]                             "", base::R.version$version.string), 
[10:21:19.917]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:19.917]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.917]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.917]                               "release", "version")], collapse = " "), 
[10:21:19.917]                             hostname = base::Sys.info()[["nodename"]])
[10:21:19.917]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.917]                             info)
[10:21:19.917]                           info <- base::paste(info, collapse = "; ")
[10:21:19.917]                           if (!has_future) {
[10:21:19.917]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.917]                               info)
[10:21:19.917]                           }
[10:21:19.917]                           else {
[10:21:19.917]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.917]                               info, version)
[10:21:19.917]                           }
[10:21:19.917]                           base::stop(msg)
[10:21:19.917]                         }
[10:21:19.917]                       })
[10:21:19.917]                     }
[10:21:19.917]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:19.917]                     base::options(mc.cores = 1L)
[10:21:19.917]                   }
[10:21:19.917]                   ...future.strategy.old <- future::plan("list")
[10:21:19.917]                   options(future.plan = NULL)
[10:21:19.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.917]                 }
[10:21:19.917]                 ...future.workdir <- getwd()
[10:21:19.917]             }
[10:21:19.917]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.917]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.917]         }
[10:21:19.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.917]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.917]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.917]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.917]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.917]             base::names(...future.oldOptions))
[10:21:19.917]     }
[10:21:19.917]     if (FALSE) {
[10:21:19.917]     }
[10:21:19.917]     else {
[10:21:19.917]         if (TRUE) {
[10:21:19.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.917]                 open = "w")
[10:21:19.917]         }
[10:21:19.917]         else {
[10:21:19.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.917]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.917]         }
[10:21:19.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.917]             base::sink(type = "output", split = FALSE)
[10:21:19.917]             base::close(...future.stdout)
[10:21:19.917]         }, add = TRUE)
[10:21:19.917]     }
[10:21:19.917]     ...future.frame <- base::sys.nframe()
[10:21:19.917]     ...future.conditions <- base::list()
[10:21:19.917]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.917]     if (FALSE) {
[10:21:19.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.917]     }
[10:21:19.917]     ...future.result <- base::tryCatch({
[10:21:19.917]         base::withCallingHandlers({
[10:21:19.917]             ...future.value <- base::withVisible(base::local({
[10:21:19.917]                 withCallingHandlers({
[10:21:19.917]                   2
[10:21:19.917]                 }, immediateCondition = function(cond) {
[10:21:19.917]                   save_rds <- function (object, pathname, ...) 
[10:21:19.917]                   {
[10:21:19.917]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:19.917]                     if (file_test("-f", pathname_tmp)) {
[10:21:19.917]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.917]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:19.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.917]                         fi_tmp[["mtime"]])
[10:21:19.917]                     }
[10:21:19.917]                     tryCatch({
[10:21:19.917]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:19.917]                     }, error = function(ex) {
[10:21:19.917]                       msg <- conditionMessage(ex)
[10:21:19.917]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.917]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:19.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.917]                         fi_tmp[["mtime"]], msg)
[10:21:19.917]                       ex$message <- msg
[10:21:19.917]                       stop(ex)
[10:21:19.917]                     })
[10:21:19.917]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:19.917]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:19.917]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:19.917]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.917]                       fi <- file.info(pathname)
[10:21:19.917]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:19.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.917]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:19.917]                         fi[["size"]], fi[["mtime"]])
[10:21:19.917]                       stop(msg)
[10:21:19.917]                     }
[10:21:19.917]                     invisible(pathname)
[10:21:19.917]                   }
[10:21:19.917]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:19.917]                     rootPath = tempdir()) 
[10:21:19.917]                   {
[10:21:19.917]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:19.917]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:19.917]                       tmpdir = path, fileext = ".rds")
[10:21:19.917]                     save_rds(obj, file)
[10:21:19.917]                   }
[10:21:19.917]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:19.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.917]                   {
[10:21:19.917]                     inherits <- base::inherits
[10:21:19.917]                     invokeRestart <- base::invokeRestart
[10:21:19.917]                     is.null <- base::is.null
[10:21:19.917]                     muffled <- FALSE
[10:21:19.917]                     if (inherits(cond, "message")) {
[10:21:19.917]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:19.917]                       if (muffled) 
[10:21:19.917]                         invokeRestart("muffleMessage")
[10:21:19.917]                     }
[10:21:19.917]                     else if (inherits(cond, "warning")) {
[10:21:19.917]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:19.917]                       if (muffled) 
[10:21:19.917]                         invokeRestart("muffleWarning")
[10:21:19.917]                     }
[10:21:19.917]                     else if (inherits(cond, "condition")) {
[10:21:19.917]                       if (!is.null(pattern)) {
[10:21:19.917]                         computeRestarts <- base::computeRestarts
[10:21:19.917]                         grepl <- base::grepl
[10:21:19.917]                         restarts <- computeRestarts(cond)
[10:21:19.917]                         for (restart in restarts) {
[10:21:19.917]                           name <- restart$name
[10:21:19.917]                           if (is.null(name)) 
[10:21:19.917]                             next
[10:21:19.917]                           if (!grepl(pattern, name)) 
[10:21:19.917]                             next
[10:21:19.917]                           invokeRestart(restart)
[10:21:19.917]                           muffled <- TRUE
[10:21:19.917]                           break
[10:21:19.917]                         }
[10:21:19.917]                       }
[10:21:19.917]                     }
[10:21:19.917]                     invisible(muffled)
[10:21:19.917]                   }
[10:21:19.917]                   muffleCondition(cond)
[10:21:19.917]                 })
[10:21:19.917]             }))
[10:21:19.917]             future::FutureResult(value = ...future.value$value, 
[10:21:19.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.917]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.917]                     ...future.globalenv.names))
[10:21:19.917]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.917]         }, condition = base::local({
[10:21:19.917]             c <- base::c
[10:21:19.917]             inherits <- base::inherits
[10:21:19.917]             invokeRestart <- base::invokeRestart
[10:21:19.917]             length <- base::length
[10:21:19.917]             list <- base::list
[10:21:19.917]             seq.int <- base::seq.int
[10:21:19.917]             signalCondition <- base::signalCondition
[10:21:19.917]             sys.calls <- base::sys.calls
[10:21:19.917]             `[[` <- base::`[[`
[10:21:19.917]             `+` <- base::`+`
[10:21:19.917]             `<<-` <- base::`<<-`
[10:21:19.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.917]                   3L)]
[10:21:19.917]             }
[10:21:19.917]             function(cond) {
[10:21:19.917]                 is_error <- inherits(cond, "error")
[10:21:19.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.917]                   NULL)
[10:21:19.917]                 if (is_error) {
[10:21:19.917]                   sessionInformation <- function() {
[10:21:19.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.917]                       search = base::search(), system = base::Sys.info())
[10:21:19.917]                   }
[10:21:19.917]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.917]                     cond$call), session = sessionInformation(), 
[10:21:19.917]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.917]                   signalCondition(cond)
[10:21:19.917]                 }
[10:21:19.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.917]                 "immediateCondition"))) {
[10:21:19.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.917]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.917]                   if (TRUE && !signal) {
[10:21:19.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.917]                     {
[10:21:19.917]                       inherits <- base::inherits
[10:21:19.917]                       invokeRestart <- base::invokeRestart
[10:21:19.917]                       is.null <- base::is.null
[10:21:19.917]                       muffled <- FALSE
[10:21:19.917]                       if (inherits(cond, "message")) {
[10:21:19.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.917]                         if (muffled) 
[10:21:19.917]                           invokeRestart("muffleMessage")
[10:21:19.917]                       }
[10:21:19.917]                       else if (inherits(cond, "warning")) {
[10:21:19.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.917]                         if (muffled) 
[10:21:19.917]                           invokeRestart("muffleWarning")
[10:21:19.917]                       }
[10:21:19.917]                       else if (inherits(cond, "condition")) {
[10:21:19.917]                         if (!is.null(pattern)) {
[10:21:19.917]                           computeRestarts <- base::computeRestarts
[10:21:19.917]                           grepl <- base::grepl
[10:21:19.917]                           restarts <- computeRestarts(cond)
[10:21:19.917]                           for (restart in restarts) {
[10:21:19.917]                             name <- restart$name
[10:21:19.917]                             if (is.null(name)) 
[10:21:19.917]                               next
[10:21:19.917]                             if (!grepl(pattern, name)) 
[10:21:19.917]                               next
[10:21:19.917]                             invokeRestart(restart)
[10:21:19.917]                             muffled <- TRUE
[10:21:19.917]                             break
[10:21:19.917]                           }
[10:21:19.917]                         }
[10:21:19.917]                       }
[10:21:19.917]                       invisible(muffled)
[10:21:19.917]                     }
[10:21:19.917]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.917]                   }
[10:21:19.917]                 }
[10:21:19.917]                 else {
[10:21:19.917]                   if (TRUE) {
[10:21:19.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.917]                     {
[10:21:19.917]                       inherits <- base::inherits
[10:21:19.917]                       invokeRestart <- base::invokeRestart
[10:21:19.917]                       is.null <- base::is.null
[10:21:19.917]                       muffled <- FALSE
[10:21:19.917]                       if (inherits(cond, "message")) {
[10:21:19.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.917]                         if (muffled) 
[10:21:19.917]                           invokeRestart("muffleMessage")
[10:21:19.917]                       }
[10:21:19.917]                       else if (inherits(cond, "warning")) {
[10:21:19.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.917]                         if (muffled) 
[10:21:19.917]                           invokeRestart("muffleWarning")
[10:21:19.917]                       }
[10:21:19.917]                       else if (inherits(cond, "condition")) {
[10:21:19.917]                         if (!is.null(pattern)) {
[10:21:19.917]                           computeRestarts <- base::computeRestarts
[10:21:19.917]                           grepl <- base::grepl
[10:21:19.917]                           restarts <- computeRestarts(cond)
[10:21:19.917]                           for (restart in restarts) {
[10:21:19.917]                             name <- restart$name
[10:21:19.917]                             if (is.null(name)) 
[10:21:19.917]                               next
[10:21:19.917]                             if (!grepl(pattern, name)) 
[10:21:19.917]                               next
[10:21:19.917]                             invokeRestart(restart)
[10:21:19.917]                             muffled <- TRUE
[10:21:19.917]                             break
[10:21:19.917]                           }
[10:21:19.917]                         }
[10:21:19.917]                       }
[10:21:19.917]                       invisible(muffled)
[10:21:19.917]                     }
[10:21:19.917]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.917]                   }
[10:21:19.917]                 }
[10:21:19.917]             }
[10:21:19.917]         }))
[10:21:19.917]     }, error = function(ex) {
[10:21:19.917]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.917]                 ...future.rng), started = ...future.startTime, 
[10:21:19.917]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.917]             version = "1.8"), class = "FutureResult")
[10:21:19.917]     }, finally = {
[10:21:19.917]         if (!identical(...future.workdir, getwd())) 
[10:21:19.917]             setwd(...future.workdir)
[10:21:19.917]         {
[10:21:19.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.917]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.917]             }
[10:21:19.917]             base::options(...future.oldOptions)
[10:21:19.917]             if (.Platform$OS.type == "windows") {
[10:21:19.917]                 old_names <- names(...future.oldEnvVars)
[10:21:19.917]                 envs <- base::Sys.getenv()
[10:21:19.917]                 names <- names(envs)
[10:21:19.917]                 common <- intersect(names, old_names)
[10:21:19.917]                 added <- setdiff(names, old_names)
[10:21:19.917]                 removed <- setdiff(old_names, names)
[10:21:19.917]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.917]                   envs[common]]
[10:21:19.917]                 NAMES <- toupper(changed)
[10:21:19.917]                 args <- list()
[10:21:19.917]                 for (kk in seq_along(NAMES)) {
[10:21:19.917]                   name <- changed[[kk]]
[10:21:19.917]                   NAME <- NAMES[[kk]]
[10:21:19.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.917]                     next
[10:21:19.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.917]                 }
[10:21:19.917]                 NAMES <- toupper(added)
[10:21:19.917]                 for (kk in seq_along(NAMES)) {
[10:21:19.917]                   name <- added[[kk]]
[10:21:19.917]                   NAME <- NAMES[[kk]]
[10:21:19.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.917]                     next
[10:21:19.917]                   args[[name]] <- ""
[10:21:19.917]                 }
[10:21:19.917]                 NAMES <- toupper(removed)
[10:21:19.917]                 for (kk in seq_along(NAMES)) {
[10:21:19.917]                   name <- removed[[kk]]
[10:21:19.917]                   NAME <- NAMES[[kk]]
[10:21:19.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.917]                     next
[10:21:19.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.917]                 }
[10:21:19.917]                 if (length(args) > 0) 
[10:21:19.917]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.917]             }
[10:21:19.917]             else {
[10:21:19.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.917]             }
[10:21:19.917]             {
[10:21:19.917]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.917]                   0L) {
[10:21:19.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.917]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.917]                   base::options(opts)
[10:21:19.917]                 }
[10:21:19.917]                 {
[10:21:19.917]                   {
[10:21:19.917]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:19.917]                     NULL
[10:21:19.917]                   }
[10:21:19.917]                   options(future.plan = NULL)
[10:21:19.917]                   if (is.na(NA_character_)) 
[10:21:19.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.917]                     .init = FALSE)
[10:21:19.917]                 }
[10:21:19.917]             }
[10:21:19.917]         }
[10:21:19.917]     })
[10:21:19.917]     if (TRUE) {
[10:21:19.917]         base::sink(type = "output", split = FALSE)
[10:21:19.917]         if (TRUE) {
[10:21:19.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.917]         }
[10:21:19.917]         else {
[10:21:19.917]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.917]         }
[10:21:19.917]         base::close(...future.stdout)
[10:21:19.917]         ...future.stdout <- NULL
[10:21:19.917]     }
[10:21:19.917]     ...future.result$conditions <- ...future.conditions
[10:21:19.917]     ...future.result$finished <- base::Sys.time()
[10:21:19.917]     ...future.result
[10:21:19.917] }
[10:21:19.919] requestCore(): workers = 2
[10:21:19.921] MulticoreFuture started
[10:21:19.921] - Launch lazy future ... done
[10:21:19.921] run() for ‘MulticoreFuture’ ... done
[10:21:19.922] getGlobalsAndPackages() ...
[10:21:19.922] plan(): Setting new future strategy stack:
[10:21:19.922] Searching for globals...
[10:21:19.922] List of future strategies:
[10:21:19.922] 1. sequential:
[10:21:19.922]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.922]    - tweaked: FALSE
[10:21:19.922]    - call: NULL
[10:21:19.927] plan(): nbrOfWorkers() = 1
[10:21:19.927] 
[10:21:19.927] Searching for globals ... DONE
[10:21:19.927] - globals: [0] <none>
[10:21:19.928] getGlobalsAndPackages() ... DONE
[10:21:19.929] run() for ‘Future’ ...
[10:21:19.929] plan(): Setting new future strategy stack:
[10:21:19.929] - state: ‘created’
[10:21:19.930] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:19.929] List of future strategies:
[10:21:19.929] 1. multicore:
[10:21:19.929]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:19.929]    - tweaked: FALSE
[10:21:19.929]    - call: plan(strategy)
[10:21:19.933] plan(): nbrOfWorkers() = 2
[10:21:19.933] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:19.933] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:19.933]   - Field: ‘label’
[10:21:19.934]   - Field: ‘local’
[10:21:19.934]   - Field: ‘owner’
[10:21:19.934]   - Field: ‘envir’
[10:21:19.934]   - Field: ‘workers’
[10:21:19.934]   - Field: ‘packages’
[10:21:19.934]   - Field: ‘gc’
[10:21:19.935]   - Field: ‘job’
[10:21:19.935]   - Field: ‘conditions’
[10:21:19.935]   - Field: ‘expr’
[10:21:19.935]   - Field: ‘uuid’
[10:21:19.935]   - Field: ‘seed’
[10:21:19.935]   - Field: ‘version’
[10:21:19.935]   - Field: ‘result’
[10:21:19.936]   - Field: ‘asynchronous’
[10:21:19.936]   - Field: ‘calls’
[10:21:19.936]   - Field: ‘globals’
[10:21:19.936]   - Field: ‘stdout’
[10:21:19.936]   - Field: ‘earlySignal’
[10:21:19.936]   - Field: ‘lazy’
[10:21:19.937]   - Field: ‘state’
[10:21:19.937] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:19.937] - Launch lazy future ...
[10:21:19.937] Packages needed by the future expression (n = 0): <none>
[10:21:19.938] Packages needed by future strategies (n = 0): <none>
[10:21:19.938] {
[10:21:19.938]     {
[10:21:19.938]         {
[10:21:19.938]             ...future.startTime <- base::Sys.time()
[10:21:19.938]             {
[10:21:19.938]                 {
[10:21:19.938]                   {
[10:21:19.938]                     {
[10:21:19.938]                       base::local({
[10:21:19.938]                         has_future <- base::requireNamespace("future", 
[10:21:19.938]                           quietly = TRUE)
[10:21:19.938]                         if (has_future) {
[10:21:19.938]                           ns <- base::getNamespace("future")
[10:21:19.938]                           version <- ns[[".package"]][["version"]]
[10:21:19.938]                           if (is.null(version)) 
[10:21:19.938]                             version <- utils::packageVersion("future")
[10:21:19.938]                         }
[10:21:19.938]                         else {
[10:21:19.938]                           version <- NULL
[10:21:19.938]                         }
[10:21:19.938]                         if (!has_future || version < "1.8.0") {
[10:21:19.938]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.938]                             "", base::R.version$version.string), 
[10:21:19.938]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:19.938]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.938]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.938]                               "release", "version")], collapse = " "), 
[10:21:19.938]                             hostname = base::Sys.info()[["nodename"]])
[10:21:19.938]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.938]                             info)
[10:21:19.938]                           info <- base::paste(info, collapse = "; ")
[10:21:19.938]                           if (!has_future) {
[10:21:19.938]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.938]                               info)
[10:21:19.938]                           }
[10:21:19.938]                           else {
[10:21:19.938]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.938]                               info, version)
[10:21:19.938]                           }
[10:21:19.938]                           base::stop(msg)
[10:21:19.938]                         }
[10:21:19.938]                       })
[10:21:19.938]                     }
[10:21:19.938]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:19.938]                     base::options(mc.cores = 1L)
[10:21:19.938]                   }
[10:21:19.938]                   ...future.strategy.old <- future::plan("list")
[10:21:19.938]                   options(future.plan = NULL)
[10:21:19.938]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.938]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.938]                 }
[10:21:19.938]                 ...future.workdir <- getwd()
[10:21:19.938]             }
[10:21:19.938]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.938]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.938]         }
[10:21:19.938]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.938]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.938]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.938]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.938]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.938]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.938]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.938]             base::names(...future.oldOptions))
[10:21:19.938]     }
[10:21:19.938]     if (FALSE) {
[10:21:19.938]     }
[10:21:19.938]     else {
[10:21:19.938]         if (TRUE) {
[10:21:19.938]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.938]                 open = "w")
[10:21:19.938]         }
[10:21:19.938]         else {
[10:21:19.938]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.938]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.938]         }
[10:21:19.938]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.938]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.938]             base::sink(type = "output", split = FALSE)
[10:21:19.938]             base::close(...future.stdout)
[10:21:19.938]         }, add = TRUE)
[10:21:19.938]     }
[10:21:19.938]     ...future.frame <- base::sys.nframe()
[10:21:19.938]     ...future.conditions <- base::list()
[10:21:19.938]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.938]     if (FALSE) {
[10:21:19.938]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.938]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.938]     }
[10:21:19.938]     ...future.result <- base::tryCatch({
[10:21:19.938]         base::withCallingHandlers({
[10:21:19.938]             ...future.value <- base::withVisible(base::local({
[10:21:19.938]                 withCallingHandlers({
[10:21:19.938]                   NULL
[10:21:19.938]                 }, immediateCondition = function(cond) {
[10:21:19.938]                   save_rds <- function (object, pathname, ...) 
[10:21:19.938]                   {
[10:21:19.938]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:19.938]                     if (file_test("-f", pathname_tmp)) {
[10:21:19.938]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.938]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:19.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.938]                         fi_tmp[["mtime"]])
[10:21:19.938]                     }
[10:21:19.938]                     tryCatch({
[10:21:19.938]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:19.938]                     }, error = function(ex) {
[10:21:19.938]                       msg <- conditionMessage(ex)
[10:21:19.938]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.938]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:19.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.938]                         fi_tmp[["mtime"]], msg)
[10:21:19.938]                       ex$message <- msg
[10:21:19.938]                       stop(ex)
[10:21:19.938]                     })
[10:21:19.938]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:19.938]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:19.938]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:19.938]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.938]                       fi <- file.info(pathname)
[10:21:19.938]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:19.938]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.938]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:19.938]                         fi[["size"]], fi[["mtime"]])
[10:21:19.938]                       stop(msg)
[10:21:19.938]                     }
[10:21:19.938]                     invisible(pathname)
[10:21:19.938]                   }
[10:21:19.938]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:19.938]                     rootPath = tempdir()) 
[10:21:19.938]                   {
[10:21:19.938]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:19.938]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:19.938]                       tmpdir = path, fileext = ".rds")
[10:21:19.938]                     save_rds(obj, file)
[10:21:19.938]                   }
[10:21:19.938]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:19.938]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.938]                   {
[10:21:19.938]                     inherits <- base::inherits
[10:21:19.938]                     invokeRestart <- base::invokeRestart
[10:21:19.938]                     is.null <- base::is.null
[10:21:19.938]                     muffled <- FALSE
[10:21:19.938]                     if (inherits(cond, "message")) {
[10:21:19.938]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:19.938]                       if (muffled) 
[10:21:19.938]                         invokeRestart("muffleMessage")
[10:21:19.938]                     }
[10:21:19.938]                     else if (inherits(cond, "warning")) {
[10:21:19.938]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:19.938]                       if (muffled) 
[10:21:19.938]                         invokeRestart("muffleWarning")
[10:21:19.938]                     }
[10:21:19.938]                     else if (inherits(cond, "condition")) {
[10:21:19.938]                       if (!is.null(pattern)) {
[10:21:19.938]                         computeRestarts <- base::computeRestarts
[10:21:19.938]                         grepl <- base::grepl
[10:21:19.938]                         restarts <- computeRestarts(cond)
[10:21:19.938]                         for (restart in restarts) {
[10:21:19.938]                           name <- restart$name
[10:21:19.938]                           if (is.null(name)) 
[10:21:19.938]                             next
[10:21:19.938]                           if (!grepl(pattern, name)) 
[10:21:19.938]                             next
[10:21:19.938]                           invokeRestart(restart)
[10:21:19.938]                           muffled <- TRUE
[10:21:19.938]                           break
[10:21:19.938]                         }
[10:21:19.938]                       }
[10:21:19.938]                     }
[10:21:19.938]                     invisible(muffled)
[10:21:19.938]                   }
[10:21:19.938]                   muffleCondition(cond)
[10:21:19.938]                 })
[10:21:19.938]             }))
[10:21:19.938]             future::FutureResult(value = ...future.value$value, 
[10:21:19.938]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.938]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.938]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.938]                     ...future.globalenv.names))
[10:21:19.938]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.938]         }, condition = base::local({
[10:21:19.938]             c <- base::c
[10:21:19.938]             inherits <- base::inherits
[10:21:19.938]             invokeRestart <- base::invokeRestart
[10:21:19.938]             length <- base::length
[10:21:19.938]             list <- base::list
[10:21:19.938]             seq.int <- base::seq.int
[10:21:19.938]             signalCondition <- base::signalCondition
[10:21:19.938]             sys.calls <- base::sys.calls
[10:21:19.938]             `[[` <- base::`[[`
[10:21:19.938]             `+` <- base::`+`
[10:21:19.938]             `<<-` <- base::`<<-`
[10:21:19.938]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.938]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.938]                   3L)]
[10:21:19.938]             }
[10:21:19.938]             function(cond) {
[10:21:19.938]                 is_error <- inherits(cond, "error")
[10:21:19.938]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.938]                   NULL)
[10:21:19.938]                 if (is_error) {
[10:21:19.938]                   sessionInformation <- function() {
[10:21:19.938]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.938]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.938]                       search = base::search(), system = base::Sys.info())
[10:21:19.938]                   }
[10:21:19.938]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.938]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.938]                     cond$call), session = sessionInformation(), 
[10:21:19.938]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.938]                   signalCondition(cond)
[10:21:19.938]                 }
[10:21:19.938]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.938]                 "immediateCondition"))) {
[10:21:19.938]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.938]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.938]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.938]                   if (TRUE && !signal) {
[10:21:19.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.938]                     {
[10:21:19.938]                       inherits <- base::inherits
[10:21:19.938]                       invokeRestart <- base::invokeRestart
[10:21:19.938]                       is.null <- base::is.null
[10:21:19.938]                       muffled <- FALSE
[10:21:19.938]                       if (inherits(cond, "message")) {
[10:21:19.938]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.938]                         if (muffled) 
[10:21:19.938]                           invokeRestart("muffleMessage")
[10:21:19.938]                       }
[10:21:19.938]                       else if (inherits(cond, "warning")) {
[10:21:19.938]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.938]                         if (muffled) 
[10:21:19.938]                           invokeRestart("muffleWarning")
[10:21:19.938]                       }
[10:21:19.938]                       else if (inherits(cond, "condition")) {
[10:21:19.938]                         if (!is.null(pattern)) {
[10:21:19.938]                           computeRestarts <- base::computeRestarts
[10:21:19.938]                           grepl <- base::grepl
[10:21:19.938]                           restarts <- computeRestarts(cond)
[10:21:19.938]                           for (restart in restarts) {
[10:21:19.938]                             name <- restart$name
[10:21:19.938]                             if (is.null(name)) 
[10:21:19.938]                               next
[10:21:19.938]                             if (!grepl(pattern, name)) 
[10:21:19.938]                               next
[10:21:19.938]                             invokeRestart(restart)
[10:21:19.938]                             muffled <- TRUE
[10:21:19.938]                             break
[10:21:19.938]                           }
[10:21:19.938]                         }
[10:21:19.938]                       }
[10:21:19.938]                       invisible(muffled)
[10:21:19.938]                     }
[10:21:19.938]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.938]                   }
[10:21:19.938]                 }
[10:21:19.938]                 else {
[10:21:19.938]                   if (TRUE) {
[10:21:19.938]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.938]                     {
[10:21:19.938]                       inherits <- base::inherits
[10:21:19.938]                       invokeRestart <- base::invokeRestart
[10:21:19.938]                       is.null <- base::is.null
[10:21:19.938]                       muffled <- FALSE
[10:21:19.938]                       if (inherits(cond, "message")) {
[10:21:19.938]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.938]                         if (muffled) 
[10:21:19.938]                           invokeRestart("muffleMessage")
[10:21:19.938]                       }
[10:21:19.938]                       else if (inherits(cond, "warning")) {
[10:21:19.938]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.938]                         if (muffled) 
[10:21:19.938]                           invokeRestart("muffleWarning")
[10:21:19.938]                       }
[10:21:19.938]                       else if (inherits(cond, "condition")) {
[10:21:19.938]                         if (!is.null(pattern)) {
[10:21:19.938]                           computeRestarts <- base::computeRestarts
[10:21:19.938]                           grepl <- base::grepl
[10:21:19.938]                           restarts <- computeRestarts(cond)
[10:21:19.938]                           for (restart in restarts) {
[10:21:19.938]                             name <- restart$name
[10:21:19.938]                             if (is.null(name)) 
[10:21:19.938]                               next
[10:21:19.938]                             if (!grepl(pattern, name)) 
[10:21:19.938]                               next
[10:21:19.938]                             invokeRestart(restart)
[10:21:19.938]                             muffled <- TRUE
[10:21:19.938]                             break
[10:21:19.938]                           }
[10:21:19.938]                         }
[10:21:19.938]                       }
[10:21:19.938]                       invisible(muffled)
[10:21:19.938]                     }
[10:21:19.938]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.938]                   }
[10:21:19.938]                 }
[10:21:19.938]             }
[10:21:19.938]         }))
[10:21:19.938]     }, error = function(ex) {
[10:21:19.938]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.938]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.938]                 ...future.rng), started = ...future.startTime, 
[10:21:19.938]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.938]             version = "1.8"), class = "FutureResult")
[10:21:19.938]     }, finally = {
[10:21:19.938]         if (!identical(...future.workdir, getwd())) 
[10:21:19.938]             setwd(...future.workdir)
[10:21:19.938]         {
[10:21:19.938]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.938]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.938]             }
[10:21:19.938]             base::options(...future.oldOptions)
[10:21:19.938]             if (.Platform$OS.type == "windows") {
[10:21:19.938]                 old_names <- names(...future.oldEnvVars)
[10:21:19.938]                 envs <- base::Sys.getenv()
[10:21:19.938]                 names <- names(envs)
[10:21:19.938]                 common <- intersect(names, old_names)
[10:21:19.938]                 added <- setdiff(names, old_names)
[10:21:19.938]                 removed <- setdiff(old_names, names)
[10:21:19.938]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.938]                   envs[common]]
[10:21:19.938]                 NAMES <- toupper(changed)
[10:21:19.938]                 args <- list()
[10:21:19.938]                 for (kk in seq_along(NAMES)) {
[10:21:19.938]                   name <- changed[[kk]]
[10:21:19.938]                   NAME <- NAMES[[kk]]
[10:21:19.938]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.938]                     next
[10:21:19.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.938]                 }
[10:21:19.938]                 NAMES <- toupper(added)
[10:21:19.938]                 for (kk in seq_along(NAMES)) {
[10:21:19.938]                   name <- added[[kk]]
[10:21:19.938]                   NAME <- NAMES[[kk]]
[10:21:19.938]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.938]                     next
[10:21:19.938]                   args[[name]] <- ""
[10:21:19.938]                 }
[10:21:19.938]                 NAMES <- toupper(removed)
[10:21:19.938]                 for (kk in seq_along(NAMES)) {
[10:21:19.938]                   name <- removed[[kk]]
[10:21:19.938]                   NAME <- NAMES[[kk]]
[10:21:19.938]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.938]                     next
[10:21:19.938]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.938]                 }
[10:21:19.938]                 if (length(args) > 0) 
[10:21:19.938]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.938]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.938]             }
[10:21:19.938]             else {
[10:21:19.938]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.938]             }
[10:21:19.938]             {
[10:21:19.938]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.938]                   0L) {
[10:21:19.938]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.938]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.938]                   base::options(opts)
[10:21:19.938]                 }
[10:21:19.938]                 {
[10:21:19.938]                   {
[10:21:19.938]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:19.938]                     NULL
[10:21:19.938]                   }
[10:21:19.938]                   options(future.plan = NULL)
[10:21:19.938]                   if (is.na(NA_character_)) 
[10:21:19.938]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.938]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.938]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.938]                     .init = FALSE)
[10:21:19.938]                 }
[10:21:19.938]             }
[10:21:19.938]         }
[10:21:19.938]     })
[10:21:19.938]     if (TRUE) {
[10:21:19.938]         base::sink(type = "output", split = FALSE)
[10:21:19.938]         if (TRUE) {
[10:21:19.938]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.938]         }
[10:21:19.938]         else {
[10:21:19.938]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.938]         }
[10:21:19.938]         base::close(...future.stdout)
[10:21:19.938]         ...future.stdout <- NULL
[10:21:19.938]     }
[10:21:19.938]     ...future.result$conditions <- ...future.conditions
[10:21:19.938]     ...future.result$finished <- base::Sys.time()
[10:21:19.938]     ...future.result
[10:21:19.938] }
[10:21:19.941] requestCore(): workers = 2
[10:21:19.943] MulticoreFuture started
[10:21:19.944] - Launch lazy future ... done
[10:21:19.944] run() for ‘MulticoreFuture’ ... done
[10:21:19.945] plan(): Setting new future strategy stack:
List of 6
 $ a:[10:21:19.945] List of future strategies:
[10:21:19.945] 1. sequential:
[10:21:19.945]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.945]    - tweaked: FALSE
[10:21:19.945]    - call: NULL
 num 1
 $ b:[10:21:19.946] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e5112250> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e5874330> 
 $  : NULL
 $  : NULL
 $  :[10:21:19.948] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[10:21:19.948] List of future strategies:
[10:21:19.948] 1. multicore:
[10:21:19.948]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:19.948]    - tweaked: FALSE
[10:21:19.948]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e5112250> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e5874330> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")=[10:21:19.951] plan(): nbrOfWorkers() = 2
 int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:19.956] resolve() on list ...
[10:21:19.956]  recursive: 0
[10:21:19.956]  length: 6
[10:21:19.956]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:19.957] signalConditionsASAP(numeric, pos=1) ...
[10:21:19.957] - nx: 6
[10:21:19.957] - relay: TRUE
[10:21:19.957] - stdout: TRUE
[10:21:19.957] - signal: TRUE
[10:21:19.957] - resignal: FALSE
[10:21:19.957] - force: TRUE
[10:21:19.958] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.958] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.958]  - until=2
[10:21:19.958]  - relaying element #2
[10:21:19.958] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.958] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.958] signalConditionsASAP(NULL, pos=1) ... done
[10:21:19.959]  length: 5 (resolved future 1)
[10:21:19.959] Future #2
[10:21:19.959] result() for MulticoreFuture ...
[10:21:19.960] result() for MulticoreFuture ...
[10:21:19.960] result() for MulticoreFuture ... done
[10:21:19.960] result() for MulticoreFuture ... done
[10:21:19.960] result() for MulticoreFuture ...
[10:21:19.960] result() for MulticoreFuture ... done
[10:21:19.961] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:19.961] - nx: 6
[10:21:19.961] - relay: TRUE
[10:21:19.961] - stdout: TRUE
[10:21:19.961] - signal: TRUE
[10:21:19.961] - resignal: FALSE
[10:21:19.961] - force: TRUE
[10:21:19.961] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.962] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:19.962]  - until=2
[10:21:19.962]  - relaying element #2
[10:21:19.962] result() for MulticoreFuture ...
[10:21:19.962] result() for MulticoreFuture ... done
[10:21:19.962] result() for MulticoreFuture ...
[10:21:19.962] result() for MulticoreFuture ... done
[10:21:19.963] result() for MulticoreFuture ...
[10:21:19.963] result() for MulticoreFuture ... done
[10:21:19.963] result() for MulticoreFuture ...
[10:21:19.963] result() for MulticoreFuture ... done
[10:21:19.963] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.963] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.963] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:19.964]  length: 4 (resolved future 2)
[10:21:19.964] Future #3
[10:21:19.964] result() for MulticoreFuture ...
[10:21:19.965] result() for MulticoreFuture ...
[10:21:19.965] result() for MulticoreFuture ... done
[10:21:19.965] result() for MulticoreFuture ... done
[10:21:19.965] result() for MulticoreFuture ...
[10:21:19.965] result() for MulticoreFuture ... done
[10:21:19.965] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:19.966] - nx: 6
[10:21:19.966] - relay: TRUE
[10:21:19.966] - stdout: TRUE
[10:21:19.966] - signal: TRUE
[10:21:19.966] - resignal: FALSE
[10:21:19.966] - force: TRUE
[10:21:19.966] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.966] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:19.967]  - until=3
[10:21:19.967]  - relaying element #3
[10:21:19.967] result() for MulticoreFuture ...
[10:21:19.967] result() for MulticoreFuture ... done
[10:21:19.967] result() for MulticoreFuture ...
[10:21:19.967] result() for MulticoreFuture ... done
[10:21:19.967] result() for MulticoreFuture ...
[10:21:19.967] result() for MulticoreFuture ... done
[10:21:19.968] result() for MulticoreFuture ...
[10:21:19.968] result() for MulticoreFuture ... done
[10:21:19.968] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.968] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.968] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:19.968]  length: 3 (resolved future 3)
[10:21:19.968] signalConditionsASAP(NULL, pos=4) ...
[10:21:19.968] - nx: 6
[10:21:19.968] - relay: TRUE
[10:21:19.969] - stdout: TRUE
[10:21:19.969] - signal: TRUE
[10:21:19.969] - resignal: FALSE
[10:21:19.969] - force: TRUE
[10:21:19.969] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.969] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.969]  - until=5
[10:21:19.969]  - relaying element #5
[10:21:19.969] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.969] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.970] signalConditionsASAP(NULL, pos=4) ... done
[10:21:19.970]  length: 2 (resolved future 4)
[10:21:19.970] signalConditionsASAP(NULL, pos=5) ...
[10:21:19.970] - nx: 6
[10:21:19.970] - relay: TRUE
[10:21:19.970] - stdout: TRUE
[10:21:19.970] - signal: TRUE
[10:21:19.970] - resignal: FALSE
[10:21:19.970] - force: TRUE
[10:21:19.970] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:19.970] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.971]  - until=6
[10:21:19.971]  - relaying element #6
[10:21:19.971] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.973] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.973] signalConditionsASAP(NULL, pos=5) ... done
[10:21:19.973]  length: 1 (resolved future 5)
[10:21:19.974] signalConditionsASAP(numeric, pos=6) ...
[10:21:19.974] - nx: 6
[10:21:19.974] - relay: TRUE
[10:21:19.974] - stdout: TRUE
[10:21:19.974] - signal: TRUE
[10:21:19.974] - resignal: FALSE
[10:21:19.974] - force: TRUE
[10:21:19.975] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:19.975] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.975]  - until=6
[10:21:19.975] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.975] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.975] signalConditionsASAP(numeric, pos=6) ... done
[10:21:19.975]  length: 0 (resolved future 6)
[10:21:19.975] Relaying remaining futures
[10:21:19.976] signalConditionsASAP(NULL, pos=0) ...
[10:21:19.976] - nx: 6
[10:21:19.976] - relay: TRUE
[10:21:19.976] - stdout: TRUE
[10:21:19.976] - signal: TRUE
[10:21:19.976] - resignal: FALSE
[10:21:19.976] - force: TRUE
[10:21:19.976] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.976] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:19.977] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:19.977] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:19.977] signalConditionsASAP(NULL, pos=0) ... done
[10:21:19.977] resolve() on list ... DONE
[10:21:19.977] result() for MulticoreFuture ...
[10:21:19.977] result() for MulticoreFuture ... done
[10:21:19.977] result() for MulticoreFuture ...
[10:21:19.977] result() for MulticoreFuture ... done
[10:21:19.977] result() for MulticoreFuture ...
[10:21:19.978] result() for MulticoreFuture ... done
[10:21:19.978] result() for MulticoreFuture ...
[10:21:19.978] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:21:19.981] getGlobalsAndPackages() ...
[10:21:19.981] Searching for globals...
[10:21:19.982] 
[10:21:19.982] Searching for globals ... DONE
[10:21:19.982] - globals: [0] <none>
[10:21:19.982] getGlobalsAndPackages() ... DONE
[10:21:19.982] run() for ‘Future’ ...
[10:21:19.982] - state: ‘created’
[10:21:19.983] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:19.984] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:19.984] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:19.984]   - Field: ‘label’
[10:21:19.985]   - Field: ‘local’
[10:21:19.985]   - Field: ‘owner’
[10:21:19.985]   - Field: ‘envir’
[10:21:19.985]   - Field: ‘workers’
[10:21:19.985]   - Field: ‘packages’
[10:21:19.985]   - Field: ‘gc’
[10:21:19.985]   - Field: ‘job’
[10:21:19.985]   - Field: ‘conditions’
[10:21:19.985]   - Field: ‘expr’
[10:21:19.985]   - Field: ‘uuid’
[10:21:19.985]   - Field: ‘seed’
[10:21:19.986]   - Field: ‘version’
[10:21:19.986]   - Field: ‘result’
[10:21:19.986]   - Field: ‘asynchronous’
[10:21:19.986]   - Field: ‘calls’
[10:21:19.986]   - Field: ‘globals’
[10:21:19.986]   - Field: ‘stdout’
[10:21:19.986]   - Field: ‘earlySignal’
[10:21:19.986]   - Field: ‘lazy’
[10:21:19.986]   - Field: ‘state’
[10:21:19.986] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:19.986] - Launch lazy future ...
[10:21:19.987] Packages needed by the future expression (n = 0): <none>
[10:21:19.987] Packages needed by future strategies (n = 0): <none>
[10:21:19.987] {
[10:21:19.987]     {
[10:21:19.987]         {
[10:21:19.987]             ...future.startTime <- base::Sys.time()
[10:21:19.987]             {
[10:21:19.987]                 {
[10:21:19.987]                   {
[10:21:19.987]                     {
[10:21:19.987]                       base::local({
[10:21:19.987]                         has_future <- base::requireNamespace("future", 
[10:21:19.987]                           quietly = TRUE)
[10:21:19.987]                         if (has_future) {
[10:21:19.987]                           ns <- base::getNamespace("future")
[10:21:19.987]                           version <- ns[[".package"]][["version"]]
[10:21:19.987]                           if (is.null(version)) 
[10:21:19.987]                             version <- utils::packageVersion("future")
[10:21:19.987]                         }
[10:21:19.987]                         else {
[10:21:19.987]                           version <- NULL
[10:21:19.987]                         }
[10:21:19.987]                         if (!has_future || version < "1.8.0") {
[10:21:19.987]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:19.987]                             "", base::R.version$version.string), 
[10:21:19.987]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:19.987]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:19.987]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:19.987]                               "release", "version")], collapse = " "), 
[10:21:19.987]                             hostname = base::Sys.info()[["nodename"]])
[10:21:19.987]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:19.987]                             info)
[10:21:19.987]                           info <- base::paste(info, collapse = "; ")
[10:21:19.987]                           if (!has_future) {
[10:21:19.987]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:19.987]                               info)
[10:21:19.987]                           }
[10:21:19.987]                           else {
[10:21:19.987]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:19.987]                               info, version)
[10:21:19.987]                           }
[10:21:19.987]                           base::stop(msg)
[10:21:19.987]                         }
[10:21:19.987]                       })
[10:21:19.987]                     }
[10:21:19.987]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:19.987]                     base::options(mc.cores = 1L)
[10:21:19.987]                   }
[10:21:19.987]                   ...future.strategy.old <- future::plan("list")
[10:21:19.987]                   options(future.plan = NULL)
[10:21:19.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:19.987]                 }
[10:21:19.987]                 ...future.workdir <- getwd()
[10:21:19.987]             }
[10:21:19.987]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:19.987]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:19.987]         }
[10:21:19.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:19.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:19.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:19.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:19.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:19.987]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:19.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:19.987]             base::names(...future.oldOptions))
[10:21:19.987]     }
[10:21:19.987]     if (FALSE) {
[10:21:19.987]     }
[10:21:19.987]     else {
[10:21:19.987]         if (TRUE) {
[10:21:19.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:19.987]                 open = "w")
[10:21:19.987]         }
[10:21:19.987]         else {
[10:21:19.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:19.987]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:19.987]         }
[10:21:19.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:19.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:19.987]             base::sink(type = "output", split = FALSE)
[10:21:19.987]             base::close(...future.stdout)
[10:21:19.987]         }, add = TRUE)
[10:21:19.987]     }
[10:21:19.987]     ...future.frame <- base::sys.nframe()
[10:21:19.987]     ...future.conditions <- base::list()
[10:21:19.987]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:19.987]     if (FALSE) {
[10:21:19.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:19.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:19.987]     }
[10:21:19.987]     ...future.result <- base::tryCatch({
[10:21:19.987]         base::withCallingHandlers({
[10:21:19.987]             ...future.value <- base::withVisible(base::local({
[10:21:19.987]                 withCallingHandlers({
[10:21:19.987]                   2
[10:21:19.987]                 }, immediateCondition = function(cond) {
[10:21:19.987]                   save_rds <- function (object, pathname, ...) 
[10:21:19.987]                   {
[10:21:19.987]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:19.987]                     if (file_test("-f", pathname_tmp)) {
[10:21:19.987]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.987]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:19.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.987]                         fi_tmp[["mtime"]])
[10:21:19.987]                     }
[10:21:19.987]                     tryCatch({
[10:21:19.987]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:19.987]                     }, error = function(ex) {
[10:21:19.987]                       msg <- conditionMessage(ex)
[10:21:19.987]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.987]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:19.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.987]                         fi_tmp[["mtime"]], msg)
[10:21:19.987]                       ex$message <- msg
[10:21:19.987]                       stop(ex)
[10:21:19.987]                     })
[10:21:19.987]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:19.987]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:19.987]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:19.987]                       fi_tmp <- file.info(pathname_tmp)
[10:21:19.987]                       fi <- file.info(pathname)
[10:21:19.987]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:19.987]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:19.987]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:19.987]                         fi[["size"]], fi[["mtime"]])
[10:21:19.987]                       stop(msg)
[10:21:19.987]                     }
[10:21:19.987]                     invisible(pathname)
[10:21:19.987]                   }
[10:21:19.987]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:19.987]                     rootPath = tempdir()) 
[10:21:19.987]                   {
[10:21:19.987]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:19.987]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:19.987]                       tmpdir = path, fileext = ".rds")
[10:21:19.987]                     save_rds(obj, file)
[10:21:19.987]                   }
[10:21:19.987]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:19.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.987]                   {
[10:21:19.987]                     inherits <- base::inherits
[10:21:19.987]                     invokeRestart <- base::invokeRestart
[10:21:19.987]                     is.null <- base::is.null
[10:21:19.987]                     muffled <- FALSE
[10:21:19.987]                     if (inherits(cond, "message")) {
[10:21:19.987]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:19.987]                       if (muffled) 
[10:21:19.987]                         invokeRestart("muffleMessage")
[10:21:19.987]                     }
[10:21:19.987]                     else if (inherits(cond, "warning")) {
[10:21:19.987]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:19.987]                       if (muffled) 
[10:21:19.987]                         invokeRestart("muffleWarning")
[10:21:19.987]                     }
[10:21:19.987]                     else if (inherits(cond, "condition")) {
[10:21:19.987]                       if (!is.null(pattern)) {
[10:21:19.987]                         computeRestarts <- base::computeRestarts
[10:21:19.987]                         grepl <- base::grepl
[10:21:19.987]                         restarts <- computeRestarts(cond)
[10:21:19.987]                         for (restart in restarts) {
[10:21:19.987]                           name <- restart$name
[10:21:19.987]                           if (is.null(name)) 
[10:21:19.987]                             next
[10:21:19.987]                           if (!grepl(pattern, name)) 
[10:21:19.987]                             next
[10:21:19.987]                           invokeRestart(restart)
[10:21:19.987]                           muffled <- TRUE
[10:21:19.987]                           break
[10:21:19.987]                         }
[10:21:19.987]                       }
[10:21:19.987]                     }
[10:21:19.987]                     invisible(muffled)
[10:21:19.987]                   }
[10:21:19.987]                   muffleCondition(cond)
[10:21:19.987]                 })
[10:21:19.987]             }))
[10:21:19.987]             future::FutureResult(value = ...future.value$value, 
[10:21:19.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.987]                   ...future.rng), globalenv = if (FALSE) 
[10:21:19.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:19.987]                     ...future.globalenv.names))
[10:21:19.987]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:19.987]         }, condition = base::local({
[10:21:19.987]             c <- base::c
[10:21:19.987]             inherits <- base::inherits
[10:21:19.987]             invokeRestart <- base::invokeRestart
[10:21:19.987]             length <- base::length
[10:21:19.987]             list <- base::list
[10:21:19.987]             seq.int <- base::seq.int
[10:21:19.987]             signalCondition <- base::signalCondition
[10:21:19.987]             sys.calls <- base::sys.calls
[10:21:19.987]             `[[` <- base::`[[`
[10:21:19.987]             `+` <- base::`+`
[10:21:19.987]             `<<-` <- base::`<<-`
[10:21:19.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:19.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:19.987]                   3L)]
[10:21:19.987]             }
[10:21:19.987]             function(cond) {
[10:21:19.987]                 is_error <- inherits(cond, "error")
[10:21:19.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:19.987]                   NULL)
[10:21:19.987]                 if (is_error) {
[10:21:19.987]                   sessionInformation <- function() {
[10:21:19.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:19.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:19.987]                       search = base::search(), system = base::Sys.info())
[10:21:19.987]                   }
[10:21:19.987]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:19.987]                     cond$call), session = sessionInformation(), 
[10:21:19.987]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:19.987]                   signalCondition(cond)
[10:21:19.987]                 }
[10:21:19.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:19.987]                 "immediateCondition"))) {
[10:21:19.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:19.987]                   ...future.conditions[[length(...future.conditions) + 
[10:21:19.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:19.987]                   if (TRUE && !signal) {
[10:21:19.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.987]                     {
[10:21:19.987]                       inherits <- base::inherits
[10:21:19.987]                       invokeRestart <- base::invokeRestart
[10:21:19.987]                       is.null <- base::is.null
[10:21:19.987]                       muffled <- FALSE
[10:21:19.987]                       if (inherits(cond, "message")) {
[10:21:19.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.987]                         if (muffled) 
[10:21:19.987]                           invokeRestart("muffleMessage")
[10:21:19.987]                       }
[10:21:19.987]                       else if (inherits(cond, "warning")) {
[10:21:19.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.987]                         if (muffled) 
[10:21:19.987]                           invokeRestart("muffleWarning")
[10:21:19.987]                       }
[10:21:19.987]                       else if (inherits(cond, "condition")) {
[10:21:19.987]                         if (!is.null(pattern)) {
[10:21:19.987]                           computeRestarts <- base::computeRestarts
[10:21:19.987]                           grepl <- base::grepl
[10:21:19.987]                           restarts <- computeRestarts(cond)
[10:21:19.987]                           for (restart in restarts) {
[10:21:19.987]                             name <- restart$name
[10:21:19.987]                             if (is.null(name)) 
[10:21:19.987]                               next
[10:21:19.987]                             if (!grepl(pattern, name)) 
[10:21:19.987]                               next
[10:21:19.987]                             invokeRestart(restart)
[10:21:19.987]                             muffled <- TRUE
[10:21:19.987]                             break
[10:21:19.987]                           }
[10:21:19.987]                         }
[10:21:19.987]                       }
[10:21:19.987]                       invisible(muffled)
[10:21:19.987]                     }
[10:21:19.987]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.987]                   }
[10:21:19.987]                 }
[10:21:19.987]                 else {
[10:21:19.987]                   if (TRUE) {
[10:21:19.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:19.987]                     {
[10:21:19.987]                       inherits <- base::inherits
[10:21:19.987]                       invokeRestart <- base::invokeRestart
[10:21:19.987]                       is.null <- base::is.null
[10:21:19.987]                       muffled <- FALSE
[10:21:19.987]                       if (inherits(cond, "message")) {
[10:21:19.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:19.987]                         if (muffled) 
[10:21:19.987]                           invokeRestart("muffleMessage")
[10:21:19.987]                       }
[10:21:19.987]                       else if (inherits(cond, "warning")) {
[10:21:19.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:19.987]                         if (muffled) 
[10:21:19.987]                           invokeRestart("muffleWarning")
[10:21:19.987]                       }
[10:21:19.987]                       else if (inherits(cond, "condition")) {
[10:21:19.987]                         if (!is.null(pattern)) {
[10:21:19.987]                           computeRestarts <- base::computeRestarts
[10:21:19.987]                           grepl <- base::grepl
[10:21:19.987]                           restarts <- computeRestarts(cond)
[10:21:19.987]                           for (restart in restarts) {
[10:21:19.987]                             name <- restart$name
[10:21:19.987]                             if (is.null(name)) 
[10:21:19.987]                               next
[10:21:19.987]                             if (!grepl(pattern, name)) 
[10:21:19.987]                               next
[10:21:19.987]                             invokeRestart(restart)
[10:21:19.987]                             muffled <- TRUE
[10:21:19.987]                             break
[10:21:19.987]                           }
[10:21:19.987]                         }
[10:21:19.987]                       }
[10:21:19.987]                       invisible(muffled)
[10:21:19.987]                     }
[10:21:19.987]                     muffleCondition(cond, pattern = "^muffle")
[10:21:19.987]                   }
[10:21:19.987]                 }
[10:21:19.987]             }
[10:21:19.987]         }))
[10:21:19.987]     }, error = function(ex) {
[10:21:19.987]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:19.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:19.987]                 ...future.rng), started = ...future.startTime, 
[10:21:19.987]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:19.987]             version = "1.8"), class = "FutureResult")
[10:21:19.987]     }, finally = {
[10:21:19.987]         if (!identical(...future.workdir, getwd())) 
[10:21:19.987]             setwd(...future.workdir)
[10:21:19.987]         {
[10:21:19.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:19.987]                 ...future.oldOptions$nwarnings <- NULL
[10:21:19.987]             }
[10:21:19.987]             base::options(...future.oldOptions)
[10:21:19.987]             if (.Platform$OS.type == "windows") {
[10:21:19.987]                 old_names <- names(...future.oldEnvVars)
[10:21:19.987]                 envs <- base::Sys.getenv()
[10:21:19.987]                 names <- names(envs)
[10:21:19.987]                 common <- intersect(names, old_names)
[10:21:19.987]                 added <- setdiff(names, old_names)
[10:21:19.987]                 removed <- setdiff(old_names, names)
[10:21:19.987]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:19.987]                   envs[common]]
[10:21:19.987]                 NAMES <- toupper(changed)
[10:21:19.987]                 args <- list()
[10:21:19.987]                 for (kk in seq_along(NAMES)) {
[10:21:19.987]                   name <- changed[[kk]]
[10:21:19.987]                   NAME <- NAMES[[kk]]
[10:21:19.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.987]                     next
[10:21:19.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.987]                 }
[10:21:19.987]                 NAMES <- toupper(added)
[10:21:19.987]                 for (kk in seq_along(NAMES)) {
[10:21:19.987]                   name <- added[[kk]]
[10:21:19.987]                   NAME <- NAMES[[kk]]
[10:21:19.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.987]                     next
[10:21:19.987]                   args[[name]] <- ""
[10:21:19.987]                 }
[10:21:19.987]                 NAMES <- toupper(removed)
[10:21:19.987]                 for (kk in seq_along(NAMES)) {
[10:21:19.987]                   name <- removed[[kk]]
[10:21:19.987]                   NAME <- NAMES[[kk]]
[10:21:19.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:19.987]                     next
[10:21:19.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:19.987]                 }
[10:21:19.987]                 if (length(args) > 0) 
[10:21:19.987]                   base::do.call(base::Sys.setenv, args = args)
[10:21:19.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:19.987]             }
[10:21:19.987]             else {
[10:21:19.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:19.987]             }
[10:21:19.987]             {
[10:21:19.987]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:19.987]                   0L) {
[10:21:19.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:19.987]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:19.987]                   base::options(opts)
[10:21:19.987]                 }
[10:21:19.987]                 {
[10:21:19.987]                   {
[10:21:19.987]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:19.987]                     NULL
[10:21:19.987]                   }
[10:21:19.987]                   options(future.plan = NULL)
[10:21:19.987]                   if (is.na(NA_character_)) 
[10:21:19.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:19.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:19.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:19.987]                     .init = FALSE)
[10:21:19.987]                 }
[10:21:19.987]             }
[10:21:19.987]         }
[10:21:19.987]     })
[10:21:19.987]     if (TRUE) {
[10:21:19.987]         base::sink(type = "output", split = FALSE)
[10:21:19.987]         if (TRUE) {
[10:21:19.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:19.987]         }
[10:21:19.987]         else {
[10:21:19.987]             ...future.result["stdout"] <- base::list(NULL)
[10:21:19.987]         }
[10:21:19.987]         base::close(...future.stdout)
[10:21:19.987]         ...future.stdout <- NULL
[10:21:19.987]     }
[10:21:19.987]     ...future.result$conditions <- ...future.conditions
[10:21:19.987]     ...future.result$finished <- base::Sys.time()
[10:21:19.987]     ...future.result
[10:21:19.987] }
[10:21:19.990] requestCore(): workers = 2
[10:21:19.991] MulticoreFuture started
[10:21:19.992] - Launch lazy future ... done
[10:21:19.992] run() for ‘MulticoreFuture’ ... done
[10:21:19.992] getGlobalsAndPackages() ...
[10:21:19.992] Searching for globals...
[10:21:19.992] plan(): Setting new future strategy stack:
[10:21:19.993] 
[10:21:19.993] List of future strategies:
[10:21:19.993] 1. sequential:
[10:21:19.993]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:19.993]    - tweaked: FALSE
[10:21:19.993]    - call: NULL
[10:21:19.993] Searching for globals ... DONE
[10:21:19.994] - globals: [0] <none>
[10:21:19.994] plan(): nbrOfWorkers() = 1
[10:21:19.994] getGlobalsAndPackages() ... DONE
[10:21:19.994] run() for ‘Future’ ...
[10:21:19.994] - state: ‘created’
[10:21:19.995] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:19.995] plan(): Setting new future strategy stack:
[10:21:19.996] List of future strategies:
[10:21:19.996] 1. multicore:
[10:21:19.996]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:19.996]    - tweaked: FALSE
[10:21:19.996]    - call: plan(strategy)
[10:21:19.998] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:19.998] plan(): nbrOfWorkers() = 2
[10:21:19.998] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:19.998]   - Field: ‘label’
[10:21:19.998]   - Field: ‘local’
[10:21:19.998]   - Field: ‘owner’
[10:21:19.999]   - Field: ‘envir’
[10:21:19.999]   - Field: ‘workers’
[10:21:19.999]   - Field: ‘packages’
[10:21:19.999]   - Field: ‘gc’
[10:21:19.999]   - Field: ‘job’
[10:21:19.999]   - Field: ‘conditions’
[10:21:19.999]   - Field: ‘expr’
[10:21:20.000]   - Field: ‘uuid’
[10:21:20.000]   - Field: ‘seed’
[10:21:20.000]   - Field: ‘version’
[10:21:20.000]   - Field: ‘result’
[10:21:20.000]   - Field: ‘asynchronous’
[10:21:20.000]   - Field: ‘calls’
[10:21:20.000]   - Field: ‘globals’
[10:21:20.001]   - Field: ‘stdout’
[10:21:20.001]   - Field: ‘earlySignal’
[10:21:20.001]   - Field: ‘lazy’
[10:21:20.001]   - Field: ‘state’
[10:21:20.001] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:20.001] - Launch lazy future ...
[10:21:20.002] Packages needed by the future expression (n = 0): <none>
[10:21:20.002] Packages needed by future strategies (n = 0): <none>
[10:21:20.003] {
[10:21:20.003]     {
[10:21:20.003]         {
[10:21:20.003]             ...future.startTime <- base::Sys.time()
[10:21:20.003]             {
[10:21:20.003]                 {
[10:21:20.003]                   {
[10:21:20.003]                     {
[10:21:20.003]                       base::local({
[10:21:20.003]                         has_future <- base::requireNamespace("future", 
[10:21:20.003]                           quietly = TRUE)
[10:21:20.003]                         if (has_future) {
[10:21:20.003]                           ns <- base::getNamespace("future")
[10:21:20.003]                           version <- ns[[".package"]][["version"]]
[10:21:20.003]                           if (is.null(version)) 
[10:21:20.003]                             version <- utils::packageVersion("future")
[10:21:20.003]                         }
[10:21:20.003]                         else {
[10:21:20.003]                           version <- NULL
[10:21:20.003]                         }
[10:21:20.003]                         if (!has_future || version < "1.8.0") {
[10:21:20.003]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.003]                             "", base::R.version$version.string), 
[10:21:20.003]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.003]                               "release", "version")], collapse = " "), 
[10:21:20.003]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.003]                             info)
[10:21:20.003]                           info <- base::paste(info, collapse = "; ")
[10:21:20.003]                           if (!has_future) {
[10:21:20.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.003]                               info)
[10:21:20.003]                           }
[10:21:20.003]                           else {
[10:21:20.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.003]                               info, version)
[10:21:20.003]                           }
[10:21:20.003]                           base::stop(msg)
[10:21:20.003]                         }
[10:21:20.003]                       })
[10:21:20.003]                     }
[10:21:20.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.003]                     base::options(mc.cores = 1L)
[10:21:20.003]                   }
[10:21:20.003]                   ...future.strategy.old <- future::plan("list")
[10:21:20.003]                   options(future.plan = NULL)
[10:21:20.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.003]                 }
[10:21:20.003]                 ...future.workdir <- getwd()
[10:21:20.003]             }
[10:21:20.003]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.003]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.003]         }
[10:21:20.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.003]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.003]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.003]             base::names(...future.oldOptions))
[10:21:20.003]     }
[10:21:20.003]     if (FALSE) {
[10:21:20.003]     }
[10:21:20.003]     else {
[10:21:20.003]         if (TRUE) {
[10:21:20.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.003]                 open = "w")
[10:21:20.003]         }
[10:21:20.003]         else {
[10:21:20.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.003]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.003]         }
[10:21:20.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.003]             base::sink(type = "output", split = FALSE)
[10:21:20.003]             base::close(...future.stdout)
[10:21:20.003]         }, add = TRUE)
[10:21:20.003]     }
[10:21:20.003]     ...future.frame <- base::sys.nframe()
[10:21:20.003]     ...future.conditions <- base::list()
[10:21:20.003]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.003]     if (FALSE) {
[10:21:20.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.003]     }
[10:21:20.003]     ...future.result <- base::tryCatch({
[10:21:20.003]         base::withCallingHandlers({
[10:21:20.003]             ...future.value <- base::withVisible(base::local({
[10:21:20.003]                 withCallingHandlers({
[10:21:20.003]                   NULL
[10:21:20.003]                 }, immediateCondition = function(cond) {
[10:21:20.003]                   save_rds <- function (object, pathname, ...) 
[10:21:20.003]                   {
[10:21:20.003]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:20.003]                     if (file_test("-f", pathname_tmp)) {
[10:21:20.003]                       fi_tmp <- file.info(pathname_tmp)
[10:21:20.003]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:20.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:20.003]                         fi_tmp[["mtime"]])
[10:21:20.003]                     }
[10:21:20.003]                     tryCatch({
[10:21:20.003]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:20.003]                     }, error = function(ex) {
[10:21:20.003]                       msg <- conditionMessage(ex)
[10:21:20.003]                       fi_tmp <- file.info(pathname_tmp)
[10:21:20.003]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:20.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:20.003]                         fi_tmp[["mtime"]], msg)
[10:21:20.003]                       ex$message <- msg
[10:21:20.003]                       stop(ex)
[10:21:20.003]                     })
[10:21:20.003]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:20.003]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:20.003]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:20.003]                       fi_tmp <- file.info(pathname_tmp)
[10:21:20.003]                       fi <- file.info(pathname)
[10:21:20.003]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:20.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:20.003]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:20.003]                         fi[["size"]], fi[["mtime"]])
[10:21:20.003]                       stop(msg)
[10:21:20.003]                     }
[10:21:20.003]                     invisible(pathname)
[10:21:20.003]                   }
[10:21:20.003]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:20.003]                     rootPath = tempdir()) 
[10:21:20.003]                   {
[10:21:20.003]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:20.003]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:20.003]                       tmpdir = path, fileext = ".rds")
[10:21:20.003]                     save_rds(obj, file)
[10:21:20.003]                   }
[10:21:20.003]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:20.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.003]                   {
[10:21:20.003]                     inherits <- base::inherits
[10:21:20.003]                     invokeRestart <- base::invokeRestart
[10:21:20.003]                     is.null <- base::is.null
[10:21:20.003]                     muffled <- FALSE
[10:21:20.003]                     if (inherits(cond, "message")) {
[10:21:20.003]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.003]                       if (muffled) 
[10:21:20.003]                         invokeRestart("muffleMessage")
[10:21:20.003]                     }
[10:21:20.003]                     else if (inherits(cond, "warning")) {
[10:21:20.003]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.003]                       if (muffled) 
[10:21:20.003]                         invokeRestart("muffleWarning")
[10:21:20.003]                     }
[10:21:20.003]                     else if (inherits(cond, "condition")) {
[10:21:20.003]                       if (!is.null(pattern)) {
[10:21:20.003]                         computeRestarts <- base::computeRestarts
[10:21:20.003]                         grepl <- base::grepl
[10:21:20.003]                         restarts <- computeRestarts(cond)
[10:21:20.003]                         for (restart in restarts) {
[10:21:20.003]                           name <- restart$name
[10:21:20.003]                           if (is.null(name)) 
[10:21:20.003]                             next
[10:21:20.003]                           if (!grepl(pattern, name)) 
[10:21:20.003]                             next
[10:21:20.003]                           invokeRestart(restart)
[10:21:20.003]                           muffled <- TRUE
[10:21:20.003]                           break
[10:21:20.003]                         }
[10:21:20.003]                       }
[10:21:20.003]                     }
[10:21:20.003]                     invisible(muffled)
[10:21:20.003]                   }
[10:21:20.003]                   muffleCondition(cond)
[10:21:20.003]                 })
[10:21:20.003]             }))
[10:21:20.003]             future::FutureResult(value = ...future.value$value, 
[10:21:20.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.003]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.003]                     ...future.globalenv.names))
[10:21:20.003]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.003]         }, condition = base::local({
[10:21:20.003]             c <- base::c
[10:21:20.003]             inherits <- base::inherits
[10:21:20.003]             invokeRestart <- base::invokeRestart
[10:21:20.003]             length <- base::length
[10:21:20.003]             list <- base::list
[10:21:20.003]             seq.int <- base::seq.int
[10:21:20.003]             signalCondition <- base::signalCondition
[10:21:20.003]             sys.calls <- base::sys.calls
[10:21:20.003]             `[[` <- base::`[[`
[10:21:20.003]             `+` <- base::`+`
[10:21:20.003]             `<<-` <- base::`<<-`
[10:21:20.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.003]                   3L)]
[10:21:20.003]             }
[10:21:20.003]             function(cond) {
[10:21:20.003]                 is_error <- inherits(cond, "error")
[10:21:20.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.003]                   NULL)
[10:21:20.003]                 if (is_error) {
[10:21:20.003]                   sessionInformation <- function() {
[10:21:20.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.003]                       search = base::search(), system = base::Sys.info())
[10:21:20.003]                   }
[10:21:20.003]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.003]                     cond$call), session = sessionInformation(), 
[10:21:20.003]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.003]                   signalCondition(cond)
[10:21:20.003]                 }
[10:21:20.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.003]                 "immediateCondition"))) {
[10:21:20.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.003]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.003]                   if (TRUE && !signal) {
[10:21:20.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.003]                     {
[10:21:20.003]                       inherits <- base::inherits
[10:21:20.003]                       invokeRestart <- base::invokeRestart
[10:21:20.003]                       is.null <- base::is.null
[10:21:20.003]                       muffled <- FALSE
[10:21:20.003]                       if (inherits(cond, "message")) {
[10:21:20.003]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.003]                         if (muffled) 
[10:21:20.003]                           invokeRestart("muffleMessage")
[10:21:20.003]                       }
[10:21:20.003]                       else if (inherits(cond, "warning")) {
[10:21:20.003]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.003]                         if (muffled) 
[10:21:20.003]                           invokeRestart("muffleWarning")
[10:21:20.003]                       }
[10:21:20.003]                       else if (inherits(cond, "condition")) {
[10:21:20.003]                         if (!is.null(pattern)) {
[10:21:20.003]                           computeRestarts <- base::computeRestarts
[10:21:20.003]                           grepl <- base::grepl
[10:21:20.003]                           restarts <- computeRestarts(cond)
[10:21:20.003]                           for (restart in restarts) {
[10:21:20.003]                             name <- restart$name
[10:21:20.003]                             if (is.null(name)) 
[10:21:20.003]                               next
[10:21:20.003]                             if (!grepl(pattern, name)) 
[10:21:20.003]                               next
[10:21:20.003]                             invokeRestart(restart)
[10:21:20.003]                             muffled <- TRUE
[10:21:20.003]                             break
[10:21:20.003]                           }
[10:21:20.003]                         }
[10:21:20.003]                       }
[10:21:20.003]                       invisible(muffled)
[10:21:20.003]                     }
[10:21:20.003]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.003]                   }
[10:21:20.003]                 }
[10:21:20.003]                 else {
[10:21:20.003]                   if (TRUE) {
[10:21:20.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.003]                     {
[10:21:20.003]                       inherits <- base::inherits
[10:21:20.003]                       invokeRestart <- base::invokeRestart
[10:21:20.003]                       is.null <- base::is.null
[10:21:20.003]                       muffled <- FALSE
[10:21:20.003]                       if (inherits(cond, "message")) {
[10:21:20.003]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.003]                         if (muffled) 
[10:21:20.003]                           invokeRestart("muffleMessage")
[10:21:20.003]                       }
[10:21:20.003]                       else if (inherits(cond, "warning")) {
[10:21:20.003]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.003]                         if (muffled) 
[10:21:20.003]                           invokeRestart("muffleWarning")
[10:21:20.003]                       }
[10:21:20.003]                       else if (inherits(cond, "condition")) {
[10:21:20.003]                         if (!is.null(pattern)) {
[10:21:20.003]                           computeRestarts <- base::computeRestarts
[10:21:20.003]                           grepl <- base::grepl
[10:21:20.003]                           restarts <- computeRestarts(cond)
[10:21:20.003]                           for (restart in restarts) {
[10:21:20.003]                             name <- restart$name
[10:21:20.003]                             if (is.null(name)) 
[10:21:20.003]                               next
[10:21:20.003]                             if (!grepl(pattern, name)) 
[10:21:20.003]                               next
[10:21:20.003]                             invokeRestart(restart)
[10:21:20.003]                             muffled <- TRUE
[10:21:20.003]                             break
[10:21:20.003]                           }
[10:21:20.003]                         }
[10:21:20.003]                       }
[10:21:20.003]                       invisible(muffled)
[10:21:20.003]                     }
[10:21:20.003]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.003]                   }
[10:21:20.003]                 }
[10:21:20.003]             }
[10:21:20.003]         }))
[10:21:20.003]     }, error = function(ex) {
[10:21:20.003]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.003]                 ...future.rng), started = ...future.startTime, 
[10:21:20.003]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.003]             version = "1.8"), class = "FutureResult")
[10:21:20.003]     }, finally = {
[10:21:20.003]         if (!identical(...future.workdir, getwd())) 
[10:21:20.003]             setwd(...future.workdir)
[10:21:20.003]         {
[10:21:20.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.003]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.003]             }
[10:21:20.003]             base::options(...future.oldOptions)
[10:21:20.003]             if (.Platform$OS.type == "windows") {
[10:21:20.003]                 old_names <- names(...future.oldEnvVars)
[10:21:20.003]                 envs <- base::Sys.getenv()
[10:21:20.003]                 names <- names(envs)
[10:21:20.003]                 common <- intersect(names, old_names)
[10:21:20.003]                 added <- setdiff(names, old_names)
[10:21:20.003]                 removed <- setdiff(old_names, names)
[10:21:20.003]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.003]                   envs[common]]
[10:21:20.003]                 NAMES <- toupper(changed)
[10:21:20.003]                 args <- list()
[10:21:20.003]                 for (kk in seq_along(NAMES)) {
[10:21:20.003]                   name <- changed[[kk]]
[10:21:20.003]                   NAME <- NAMES[[kk]]
[10:21:20.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.003]                     next
[10:21:20.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.003]                 }
[10:21:20.003]                 NAMES <- toupper(added)
[10:21:20.003]                 for (kk in seq_along(NAMES)) {
[10:21:20.003]                   name <- added[[kk]]
[10:21:20.003]                   NAME <- NAMES[[kk]]
[10:21:20.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.003]                     next
[10:21:20.003]                   args[[name]] <- ""
[10:21:20.003]                 }
[10:21:20.003]                 NAMES <- toupper(removed)
[10:21:20.003]                 for (kk in seq_along(NAMES)) {
[10:21:20.003]                   name <- removed[[kk]]
[10:21:20.003]                   NAME <- NAMES[[kk]]
[10:21:20.003]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.003]                     next
[10:21:20.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.003]                 }
[10:21:20.003]                 if (length(args) > 0) 
[10:21:20.003]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.003]             }
[10:21:20.003]             else {
[10:21:20.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.003]             }
[10:21:20.003]             {
[10:21:20.003]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.003]                   0L) {
[10:21:20.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.003]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.003]                   base::options(opts)
[10:21:20.003]                 }
[10:21:20.003]                 {
[10:21:20.003]                   {
[10:21:20.003]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.003]                     NULL
[10:21:20.003]                   }
[10:21:20.003]                   options(future.plan = NULL)
[10:21:20.003]                   if (is.na(NA_character_)) 
[10:21:20.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.003]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.003]                     .init = FALSE)
[10:21:20.003]                 }
[10:21:20.003]             }
[10:21:20.003]         }
[10:21:20.003]     })
[10:21:20.003]     if (TRUE) {
[10:21:20.003]         base::sink(type = "output", split = FALSE)
[10:21:20.003]         if (TRUE) {
[10:21:20.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.003]         }
[10:21:20.003]         else {
[10:21:20.003]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.003]         }
[10:21:20.003]         base::close(...future.stdout)
[10:21:20.003]         ...future.stdout <- NULL
[10:21:20.003]     }
[10:21:20.003]     ...future.result$conditions <- ...future.conditions
[10:21:20.003]     ...future.result$finished <- base::Sys.time()
[10:21:20.003]     ...future.result
[10:21:20.003] }
[10:21:20.006] requestCore(): workers = 2
[10:21:20.008] MulticoreFuture started
[10:21:20.009] - Launch lazy future ... done
[10:21:20.009] run() for ‘MulticoreFuture’ ... done
List of 6
[10:21:20.009] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[10:21:20.010] List of future strategies:
[10:21:20.010] 1. sequential:
[10:21:20.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:20.010]    - tweaked: FALSE
[10:21:20.010]    - call: NULL
[10:21:20.011] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e323ba58> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e4e95508> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
[10:21:20.013] plan(): Setting new future strategy stack:
 $ a:[10:21:20.013] List of future strategies:
[10:21:20.013] 1. multicore:
[10:21:20.013]    - args: function (..., workers = availa num bleCores(constraints = "multicore"), envir = parent.frame())
[10:21:20.013]    - tweaked: FALSE
[10:21:20.013]    - call: plan(s1trategy)

 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e323ba58> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e4e95508> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")=[10:21:20.016] plan(): nbrOfWorkers() = 2
 int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:20.028] resolve() on list ...
[10:21:20.028]  recursive: 0
[10:21:20.028]  length: 6
[10:21:20.028]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:20.028] signalConditionsASAP(numeric, pos=1) ...
[10:21:20.028] - nx: 6
[10:21:20.029] - relay: TRUE
[10:21:20.029] - stdout: TRUE
[10:21:20.029] - signal: TRUE
[10:21:20.029] - resignal: FALSE
[10:21:20.029] - force: TRUE
[10:21:20.029] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.029] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.030]  - until=2
[10:21:20.030]  - relaying element #2
[10:21:20.030] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.030] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.030] signalConditionsASAP(NULL, pos=1) ... done
[10:21:20.030]  length: 5 (resolved future 1)
[10:21:20.031] Future #2
[10:21:20.031] result() for MulticoreFuture ...
[10:21:20.032] result() for MulticoreFuture ...
[10:21:20.032] result() for MulticoreFuture ... done
[10:21:20.032] result() for MulticoreFuture ... done
[10:21:20.032] result() for MulticoreFuture ...
[10:21:20.032] result() for MulticoreFuture ... done
[10:21:20.032] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:20.033] - nx: 6
[10:21:20.033] - relay: TRUE
[10:21:20.033] - stdout: TRUE
[10:21:20.033] - signal: TRUE
[10:21:20.033] - resignal: FALSE
[10:21:20.033] - force: TRUE
[10:21:20.033] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.033] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.034]  - until=2
[10:21:20.034]  - relaying element #2
[10:21:20.034] result() for MulticoreFuture ...
[10:21:20.034] result() for MulticoreFuture ... done
[10:21:20.034] result() for MulticoreFuture ...
[10:21:20.034] result() for MulticoreFuture ... done
[10:21:20.034] result() for MulticoreFuture ...
[10:21:20.035] result() for MulticoreFuture ... done
[10:21:20.035] result() for MulticoreFuture ...
[10:21:20.035] result() for MulticoreFuture ... done
[10:21:20.035] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.035] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.035] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:20.035]  length: 4 (resolved future 2)
[10:21:20.036] Future #3
[10:21:20.036] result() for MulticoreFuture ...
[10:21:20.036] result() for MulticoreFuture ...
[10:21:20.036] result() for MulticoreFuture ... done
[10:21:20.037] result() for MulticoreFuture ... done
[10:21:20.037] result() for MulticoreFuture ...
[10:21:20.037] result() for MulticoreFuture ... done
[10:21:20.037] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:20.037] - nx: 6
[10:21:20.037] - relay: TRUE
[10:21:20.037] - stdout: TRUE
[10:21:20.037] - signal: TRUE
[10:21:20.038] - resignal: FALSE
[10:21:20.038] - force: TRUE
[10:21:20.038] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.038] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.038]  - until=3
[10:21:20.038]  - relaying element #3
[10:21:20.038] result() for MulticoreFuture ...
[10:21:20.038] result() for MulticoreFuture ... done
[10:21:20.038] result() for MulticoreFuture ...
[10:21:20.039] result() for MulticoreFuture ... done
[10:21:20.039] result() for MulticoreFuture ...
[10:21:20.039] result() for MulticoreFuture ... done
[10:21:20.039] result() for MulticoreFuture ...
[10:21:20.039] result() for MulticoreFuture ... done
[10:21:20.039] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.039] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:20.039]  length: 3 (resolved future 3)
[10:21:20.040] signalConditionsASAP(NULL, pos=4) ...
[10:21:20.040] - nx: 6
[10:21:20.040] - relay: TRUE
[10:21:20.040] - stdout: TRUE
[10:21:20.040] - signal: TRUE
[10:21:20.040] - resignal: FALSE
[10:21:20.040] - force: TRUE
[10:21:20.040] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.040] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.040]  - until=5
[10:21:20.040]  - relaying element #5
[10:21:20.041] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:20.041] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.041] signalConditionsASAP(NULL, pos=4) ... done
[10:21:20.041]  length: 2 (resolved future 4)
[10:21:20.041] signalConditionsASAP(NULL, pos=5) ...
[10:21:20.041] - nx: 6
[10:21:20.041] - relay: TRUE
[10:21:20.041] - stdout: TRUE
[10:21:20.041] - signal: TRUE
[10:21:20.041] - resignal: FALSE
[10:21:20.041] - force: TRUE
[10:21:20.042] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:20.042] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.042]  - until=6
[10:21:20.042]  - relaying element #6
[10:21:20.042] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:20.042] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.042] signalConditionsASAP(NULL, pos=5) ... done
[10:21:20.042]  length: 1 (resolved future 5)
[10:21:20.042] signalConditionsASAP(numeric, pos=6) ...
[10:21:20.042] - nx: 6
[10:21:20.042] - relay: TRUE
[10:21:20.043] - stdout: TRUE
[10:21:20.043] - signal: TRUE
[10:21:20.043] - resignal: FALSE
[10:21:20.043] - force: TRUE
[10:21:20.043] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:20.043] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.043]  - until=6
[10:21:20.043] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.043] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.043] signalConditionsASAP(numeric, pos=6) ... done
[10:21:20.043]  length: 0 (resolved future 6)
[10:21:20.044] Relaying remaining futures
[10:21:20.044] signalConditionsASAP(NULL, pos=0) ...
[10:21:20.044] - nx: 6
[10:21:20.044] - relay: TRUE
[10:21:20.044] - stdout: TRUE
[10:21:20.044] - signal: TRUE
[10:21:20.044] - resignal: FALSE
[10:21:20.044] - force: TRUE
[10:21:20.044] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.044] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:20.045] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.045] signalConditionsASAP(NULL, pos=0) ... done
[10:21:20.045] resolve() on list ... DONE
[10:21:20.045] result() for MulticoreFuture ...
[10:21:20.045] result() for MulticoreFuture ... done
[10:21:20.045] result() for MulticoreFuture ...
[10:21:20.045] result() for MulticoreFuture ... done
[10:21:20.045] result() for MulticoreFuture ...
[10:21:20.045] result() for MulticoreFuture ... done
[10:21:20.045] result() for MulticoreFuture ...
[10:21:20.046] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:21:20.049] getGlobalsAndPackages() ...
[10:21:20.049] Searching for globals...
[10:21:20.049] 
[10:21:20.050] Searching for globals ... DONE
[10:21:20.050] - globals: [0] <none>
[10:21:20.050] getGlobalsAndPackages() ... DONE
[10:21:20.050] run() for ‘Future’ ...
[10:21:20.050] - state: ‘created’
[10:21:20.050] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:20.054] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:20.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:20.054]   - Field: ‘label’
[10:21:20.054]   - Field: ‘local’
[10:21:20.054]   - Field: ‘owner’
[10:21:20.054]   - Field: ‘envir’
[10:21:20.054]   - Field: ‘workers’
[10:21:20.055]   - Field: ‘packages’
[10:21:20.055]   - Field: ‘gc’
[10:21:20.055]   - Field: ‘job’
[10:21:20.055]   - Field: ‘conditions’
[10:21:20.055]   - Field: ‘expr’
[10:21:20.055]   - Field: ‘uuid’
[10:21:20.055]   - Field: ‘seed’
[10:21:20.055]   - Field: ‘version’
[10:21:20.055]   - Field: ‘result’
[10:21:20.055]   - Field: ‘asynchronous’
[10:21:20.056]   - Field: ‘calls’
[10:21:20.056]   - Field: ‘globals’
[10:21:20.056]   - Field: ‘stdout’
[10:21:20.056]   - Field: ‘earlySignal’
[10:21:20.056]   - Field: ‘lazy’
[10:21:20.056]   - Field: ‘state’
[10:21:20.056] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:20.056] - Launch lazy future ...
[10:21:20.056] Packages needed by the future expression (n = 0): <none>
[10:21:20.057] Packages needed by future strategies (n = 0): <none>
[10:21:20.057] {
[10:21:20.057]     {
[10:21:20.057]         {
[10:21:20.057]             ...future.startTime <- base::Sys.time()
[10:21:20.057]             {
[10:21:20.057]                 {
[10:21:20.057]                   {
[10:21:20.057]                     {
[10:21:20.057]                       base::local({
[10:21:20.057]                         has_future <- base::requireNamespace("future", 
[10:21:20.057]                           quietly = TRUE)
[10:21:20.057]                         if (has_future) {
[10:21:20.057]                           ns <- base::getNamespace("future")
[10:21:20.057]                           version <- ns[[".package"]][["version"]]
[10:21:20.057]                           if (is.null(version)) 
[10:21:20.057]                             version <- utils::packageVersion("future")
[10:21:20.057]                         }
[10:21:20.057]                         else {
[10:21:20.057]                           version <- NULL
[10:21:20.057]                         }
[10:21:20.057]                         if (!has_future || version < "1.8.0") {
[10:21:20.057]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.057]                             "", base::R.version$version.string), 
[10:21:20.057]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.057]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.057]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.057]                               "release", "version")], collapse = " "), 
[10:21:20.057]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.057]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.057]                             info)
[10:21:20.057]                           info <- base::paste(info, collapse = "; ")
[10:21:20.057]                           if (!has_future) {
[10:21:20.057]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.057]                               info)
[10:21:20.057]                           }
[10:21:20.057]                           else {
[10:21:20.057]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.057]                               info, version)
[10:21:20.057]                           }
[10:21:20.057]                           base::stop(msg)
[10:21:20.057]                         }
[10:21:20.057]                       })
[10:21:20.057]                     }
[10:21:20.057]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.057]                     base::options(mc.cores = 1L)
[10:21:20.057]                   }
[10:21:20.057]                   ...future.strategy.old <- future::plan("list")
[10:21:20.057]                   options(future.plan = NULL)
[10:21:20.057]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.057]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.057]                 }
[10:21:20.057]                 ...future.workdir <- getwd()
[10:21:20.057]             }
[10:21:20.057]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.057]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.057]         }
[10:21:20.057]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.057]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.057]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.057]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.057]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.057]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.057]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.057]             base::names(...future.oldOptions))
[10:21:20.057]     }
[10:21:20.057]     if (FALSE) {
[10:21:20.057]     }
[10:21:20.057]     else {
[10:21:20.057]         if (TRUE) {
[10:21:20.057]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.057]                 open = "w")
[10:21:20.057]         }
[10:21:20.057]         else {
[10:21:20.057]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.057]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.057]         }
[10:21:20.057]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.057]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.057]             base::sink(type = "output", split = FALSE)
[10:21:20.057]             base::close(...future.stdout)
[10:21:20.057]         }, add = TRUE)
[10:21:20.057]     }
[10:21:20.057]     ...future.frame <- base::sys.nframe()
[10:21:20.057]     ...future.conditions <- base::list()
[10:21:20.057]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.057]     if (FALSE) {
[10:21:20.057]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.057]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.057]     }
[10:21:20.057]     ...future.result <- base::tryCatch({
[10:21:20.057]         base::withCallingHandlers({
[10:21:20.057]             ...future.value <- base::withVisible(base::local({
[10:21:20.057]                 withCallingHandlers({
[10:21:20.057]                   2
[10:21:20.057]                 }, immediateCondition = function(cond) {
[10:21:20.057]                   save_rds <- function (object, pathname, ...) 
[10:21:20.057]                   {
[10:21:20.057]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:20.057]                     if (file_test("-f", pathname_tmp)) {
[10:21:20.057]                       fi_tmp <- file.info(pathname_tmp)
[10:21:20.057]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:20.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:20.057]                         fi_tmp[["mtime"]])
[10:21:20.057]                     }
[10:21:20.057]                     tryCatch({
[10:21:20.057]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:20.057]                     }, error = function(ex) {
[10:21:20.057]                       msg <- conditionMessage(ex)
[10:21:20.057]                       fi_tmp <- file.info(pathname_tmp)
[10:21:20.057]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:20.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:20.057]                         fi_tmp[["mtime"]], msg)
[10:21:20.057]                       ex$message <- msg
[10:21:20.057]                       stop(ex)
[10:21:20.057]                     })
[10:21:20.057]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:20.057]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:20.057]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:20.057]                       fi_tmp <- file.info(pathname_tmp)
[10:21:20.057]                       fi <- file.info(pathname)
[10:21:20.057]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:20.057]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:20.057]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:20.057]                         fi[["size"]], fi[["mtime"]])
[10:21:20.057]                       stop(msg)
[10:21:20.057]                     }
[10:21:20.057]                     invisible(pathname)
[10:21:20.057]                   }
[10:21:20.057]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:20.057]                     rootPath = tempdir()) 
[10:21:20.057]                   {
[10:21:20.057]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:20.057]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:20.057]                       tmpdir = path, fileext = ".rds")
[10:21:20.057]                     save_rds(obj, file)
[10:21:20.057]                   }
[10:21:20.057]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:20.057]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.057]                   {
[10:21:20.057]                     inherits <- base::inherits
[10:21:20.057]                     invokeRestart <- base::invokeRestart
[10:21:20.057]                     is.null <- base::is.null
[10:21:20.057]                     muffled <- FALSE
[10:21:20.057]                     if (inherits(cond, "message")) {
[10:21:20.057]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.057]                       if (muffled) 
[10:21:20.057]                         invokeRestart("muffleMessage")
[10:21:20.057]                     }
[10:21:20.057]                     else if (inherits(cond, "warning")) {
[10:21:20.057]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.057]                       if (muffled) 
[10:21:20.057]                         invokeRestart("muffleWarning")
[10:21:20.057]                     }
[10:21:20.057]                     else if (inherits(cond, "condition")) {
[10:21:20.057]                       if (!is.null(pattern)) {
[10:21:20.057]                         computeRestarts <- base::computeRestarts
[10:21:20.057]                         grepl <- base::grepl
[10:21:20.057]                         restarts <- computeRestarts(cond)
[10:21:20.057]                         for (restart in restarts) {
[10:21:20.057]                           name <- restart$name
[10:21:20.057]                           if (is.null(name)) 
[10:21:20.057]                             next
[10:21:20.057]                           if (!grepl(pattern, name)) 
[10:21:20.057]                             next
[10:21:20.057]                           invokeRestart(restart)
[10:21:20.057]                           muffled <- TRUE
[10:21:20.057]                           break
[10:21:20.057]                         }
[10:21:20.057]                       }
[10:21:20.057]                     }
[10:21:20.057]                     invisible(muffled)
[10:21:20.057]                   }
[10:21:20.057]                   muffleCondition(cond)
[10:21:20.057]                 })
[10:21:20.057]             }))
[10:21:20.057]             future::FutureResult(value = ...future.value$value, 
[10:21:20.057]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.057]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.057]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.057]                     ...future.globalenv.names))
[10:21:20.057]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.057]         }, condition = base::local({
[10:21:20.057]             c <- base::c
[10:21:20.057]             inherits <- base::inherits
[10:21:20.057]             invokeRestart <- base::invokeRestart
[10:21:20.057]             length <- base::length
[10:21:20.057]             list <- base::list
[10:21:20.057]             seq.int <- base::seq.int
[10:21:20.057]             signalCondition <- base::signalCondition
[10:21:20.057]             sys.calls <- base::sys.calls
[10:21:20.057]             `[[` <- base::`[[`
[10:21:20.057]             `+` <- base::`+`
[10:21:20.057]             `<<-` <- base::`<<-`
[10:21:20.057]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.057]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.057]                   3L)]
[10:21:20.057]             }
[10:21:20.057]             function(cond) {
[10:21:20.057]                 is_error <- inherits(cond, "error")
[10:21:20.057]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.057]                   NULL)
[10:21:20.057]                 if (is_error) {
[10:21:20.057]                   sessionInformation <- function() {
[10:21:20.057]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.057]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.057]                       search = base::search(), system = base::Sys.info())
[10:21:20.057]                   }
[10:21:20.057]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.057]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.057]                     cond$call), session = sessionInformation(), 
[10:21:20.057]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.057]                   signalCondition(cond)
[10:21:20.057]                 }
[10:21:20.057]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.057]                 "immediateCondition"))) {
[10:21:20.057]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.057]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.057]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.057]                   if (TRUE && !signal) {
[10:21:20.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.057]                     {
[10:21:20.057]                       inherits <- base::inherits
[10:21:20.057]                       invokeRestart <- base::invokeRestart
[10:21:20.057]                       is.null <- base::is.null
[10:21:20.057]                       muffled <- FALSE
[10:21:20.057]                       if (inherits(cond, "message")) {
[10:21:20.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.057]                         if (muffled) 
[10:21:20.057]                           invokeRestart("muffleMessage")
[10:21:20.057]                       }
[10:21:20.057]                       else if (inherits(cond, "warning")) {
[10:21:20.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.057]                         if (muffled) 
[10:21:20.057]                           invokeRestart("muffleWarning")
[10:21:20.057]                       }
[10:21:20.057]                       else if (inherits(cond, "condition")) {
[10:21:20.057]                         if (!is.null(pattern)) {
[10:21:20.057]                           computeRestarts <- base::computeRestarts
[10:21:20.057]                           grepl <- base::grepl
[10:21:20.057]                           restarts <- computeRestarts(cond)
[10:21:20.057]                           for (restart in restarts) {
[10:21:20.057]                             name <- restart$name
[10:21:20.057]                             if (is.null(name)) 
[10:21:20.057]                               next
[10:21:20.057]                             if (!grepl(pattern, name)) 
[10:21:20.057]                               next
[10:21:20.057]                             invokeRestart(restart)
[10:21:20.057]                             muffled <- TRUE
[10:21:20.057]                             break
[10:21:20.057]                           }
[10:21:20.057]                         }
[10:21:20.057]                       }
[10:21:20.057]                       invisible(muffled)
[10:21:20.057]                     }
[10:21:20.057]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.057]                   }
[10:21:20.057]                 }
[10:21:20.057]                 else {
[10:21:20.057]                   if (TRUE) {
[10:21:20.057]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.057]                     {
[10:21:20.057]                       inherits <- base::inherits
[10:21:20.057]                       invokeRestart <- base::invokeRestart
[10:21:20.057]                       is.null <- base::is.null
[10:21:20.057]                       muffled <- FALSE
[10:21:20.057]                       if (inherits(cond, "message")) {
[10:21:20.057]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.057]                         if (muffled) 
[10:21:20.057]                           invokeRestart("muffleMessage")
[10:21:20.057]                       }
[10:21:20.057]                       else if (inherits(cond, "warning")) {
[10:21:20.057]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.057]                         if (muffled) 
[10:21:20.057]                           invokeRestart("muffleWarning")
[10:21:20.057]                       }
[10:21:20.057]                       else if (inherits(cond, "condition")) {
[10:21:20.057]                         if (!is.null(pattern)) {
[10:21:20.057]                           computeRestarts <- base::computeRestarts
[10:21:20.057]                           grepl <- base::grepl
[10:21:20.057]                           restarts <- computeRestarts(cond)
[10:21:20.057]                           for (restart in restarts) {
[10:21:20.057]                             name <- restart$name
[10:21:20.057]                             if (is.null(name)) 
[10:21:20.057]                               next
[10:21:20.057]                             if (!grepl(pattern, name)) 
[10:21:20.057]                               next
[10:21:20.057]                             invokeRestart(restart)
[10:21:20.057]                             muffled <- TRUE
[10:21:20.057]                             break
[10:21:20.057]                           }
[10:21:20.057]                         }
[10:21:20.057]                       }
[10:21:20.057]                       invisible(muffled)
[10:21:20.057]                     }
[10:21:20.057]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.057]                   }
[10:21:20.057]                 }
[10:21:20.057]             }
[10:21:20.057]         }))
[10:21:20.057]     }, error = function(ex) {
[10:21:20.057]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.057]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.057]                 ...future.rng), started = ...future.startTime, 
[10:21:20.057]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.057]             version = "1.8"), class = "FutureResult")
[10:21:20.057]     }, finally = {
[10:21:20.057]         if (!identical(...future.workdir, getwd())) 
[10:21:20.057]             setwd(...future.workdir)
[10:21:20.057]         {
[10:21:20.057]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.057]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.057]             }
[10:21:20.057]             base::options(...future.oldOptions)
[10:21:20.057]             if (.Platform$OS.type == "windows") {
[10:21:20.057]                 old_names <- names(...future.oldEnvVars)
[10:21:20.057]                 envs <- base::Sys.getenv()
[10:21:20.057]                 names <- names(envs)
[10:21:20.057]                 common <- intersect(names, old_names)
[10:21:20.057]                 added <- setdiff(names, old_names)
[10:21:20.057]                 removed <- setdiff(old_names, names)
[10:21:20.057]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.057]                   envs[common]]
[10:21:20.057]                 NAMES <- toupper(changed)
[10:21:20.057]                 args <- list()
[10:21:20.057]                 for (kk in seq_along(NAMES)) {
[10:21:20.057]                   name <- changed[[kk]]
[10:21:20.057]                   NAME <- NAMES[[kk]]
[10:21:20.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.057]                     next
[10:21:20.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.057]                 }
[10:21:20.057]                 NAMES <- toupper(added)
[10:21:20.057]                 for (kk in seq_along(NAMES)) {
[10:21:20.057]                   name <- added[[kk]]
[10:21:20.057]                   NAME <- NAMES[[kk]]
[10:21:20.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.057]                     next
[10:21:20.057]                   args[[name]] <- ""
[10:21:20.057]                 }
[10:21:20.057]                 NAMES <- toupper(removed)
[10:21:20.057]                 for (kk in seq_along(NAMES)) {
[10:21:20.057]                   name <- removed[[kk]]
[10:21:20.057]                   NAME <- NAMES[[kk]]
[10:21:20.057]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.057]                     next
[10:21:20.057]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.057]                 }
[10:21:20.057]                 if (length(args) > 0) 
[10:21:20.057]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.057]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.057]             }
[10:21:20.057]             else {
[10:21:20.057]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.057]             }
[10:21:20.057]             {
[10:21:20.057]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.057]                   0L) {
[10:21:20.057]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.057]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.057]                   base::options(opts)
[10:21:20.057]                 }
[10:21:20.057]                 {
[10:21:20.057]                   {
[10:21:20.057]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.057]                     NULL
[10:21:20.057]                   }
[10:21:20.057]                   options(future.plan = NULL)
[10:21:20.057]                   if (is.na(NA_character_)) 
[10:21:20.057]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.057]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.057]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.057]                     .init = FALSE)
[10:21:20.057]                 }
[10:21:20.057]             }
[10:21:20.057]         }
[10:21:20.057]     })
[10:21:20.057]     if (TRUE) {
[10:21:20.057]         base::sink(type = "output", split = FALSE)
[10:21:20.057]         if (TRUE) {
[10:21:20.057]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.057]         }
[10:21:20.057]         else {
[10:21:20.057]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.057]         }
[10:21:20.057]         base::close(...future.stdout)
[10:21:20.057]         ...future.stdout <- NULL
[10:21:20.057]     }
[10:21:20.057]     ...future.result$conditions <- ...future.conditions
[10:21:20.057]     ...future.result$finished <- base::Sys.time()
[10:21:20.057]     ...future.result
[10:21:20.057] }
[10:21:20.059] requestCore(): workers = 2
[10:21:20.062] MulticoreFuture started
[10:21:20.062] - Launch lazy future ... done
[10:21:20.062] run() for ‘MulticoreFuture’ ... done
[10:21:20.063] plan(): Setting new future strategy stack:
[10:21:20.063] getGlobalsAndPackages() ...
[10:21:20.063] Searching for globals...
[10:21:20.063] List of future strategies:
[10:21:20.063] 1. sequential:
[10:21:20.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:20.063]    - tweaked: FALSE
[10:21:20.063]    - call: NULL
[10:21:20.064] 
[10:21:20.064] plan(): nbrOfWorkers() = 1
[10:21:20.064] Searching for globals ... DONE
[10:21:20.065] - globals: [0] <none>
[10:21:20.065] getGlobalsAndPackages() ... DONE
[10:21:20.065] run() for ‘Future’ ...
[10:21:20.066] - state: ‘created’
[10:21:20.066] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:20.066] plan(): Setting new future strategy stack:
[10:21:20.066] List of future strategies:
[10:21:20.066] 1. multicore:
[10:21:20.066]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:20.066]    - tweaked: FALSE
[10:21:20.066]    - call: plan(strategy)
[10:21:20.069] plan(): nbrOfWorkers() = 2
[10:21:20.069] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:20.069] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:20.070]   - Field: ‘label’
[10:21:20.070]   - Field: ‘local’
[10:21:20.070]   - Field: ‘owner’
[10:21:20.070]   - Field: ‘envir’
[10:21:20.070]   - Field: ‘workers’
[10:21:20.070]   - Field: ‘packages’
[10:21:20.071]   - Field: ‘gc’
[10:21:20.071]   - Field: ‘job’
[10:21:20.071]   - Field: ‘conditions’
[10:21:20.071]   - Field: ‘expr’
[10:21:20.071]   - Field: ‘uuid’
[10:21:20.071]   - Field: ‘seed’
[10:21:20.071]   - Field: ‘version’
[10:21:20.072]   - Field: ‘result’
[10:21:20.072]   - Field: ‘asynchronous’
[10:21:20.072]   - Field: ‘calls’
[10:21:20.072]   - Field: ‘globals’
[10:21:20.072]   - Field: ‘stdout’
[10:21:20.072]   - Field: ‘earlySignal’
[10:21:20.072]   - Field: ‘lazy’
[10:21:20.073]   - Field: ‘state’
[10:21:20.073] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:20.073] - Launch lazy future ...
[10:21:20.073] Packages needed by the future expression (n = 0): <none>
[10:21:20.074] Packages needed by future strategies (n = 0): <none>
[10:21:20.074] {
[10:21:20.074]     {
[10:21:20.074]         {
[10:21:20.074]             ...future.startTime <- base::Sys.time()
[10:21:20.074]             {
[10:21:20.074]                 {
[10:21:20.074]                   {
[10:21:20.074]                     {
[10:21:20.074]                       base::local({
[10:21:20.074]                         has_future <- base::requireNamespace("future", 
[10:21:20.074]                           quietly = TRUE)
[10:21:20.074]                         if (has_future) {
[10:21:20.074]                           ns <- base::getNamespace("future")
[10:21:20.074]                           version <- ns[[".package"]][["version"]]
[10:21:20.074]                           if (is.null(version)) 
[10:21:20.074]                             version <- utils::packageVersion("future")
[10:21:20.074]                         }
[10:21:20.074]                         else {
[10:21:20.074]                           version <- NULL
[10:21:20.074]                         }
[10:21:20.074]                         if (!has_future || version < "1.8.0") {
[10:21:20.074]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.074]                             "", base::R.version$version.string), 
[10:21:20.074]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.074]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.074]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.074]                               "release", "version")], collapse = " "), 
[10:21:20.074]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.074]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.074]                             info)
[10:21:20.074]                           info <- base::paste(info, collapse = "; ")
[10:21:20.074]                           if (!has_future) {
[10:21:20.074]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.074]                               info)
[10:21:20.074]                           }
[10:21:20.074]                           else {
[10:21:20.074]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.074]                               info, version)
[10:21:20.074]                           }
[10:21:20.074]                           base::stop(msg)
[10:21:20.074]                         }
[10:21:20.074]                       })
[10:21:20.074]                     }
[10:21:20.074]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.074]                     base::options(mc.cores = 1L)
[10:21:20.074]                   }
[10:21:20.074]                   ...future.strategy.old <- future::plan("list")
[10:21:20.074]                   options(future.plan = NULL)
[10:21:20.074]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.074]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.074]                 }
[10:21:20.074]                 ...future.workdir <- getwd()
[10:21:20.074]             }
[10:21:20.074]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.074]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.074]         }
[10:21:20.074]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.074]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.074]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.074]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.074]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.074]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.074]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.074]             base::names(...future.oldOptions))
[10:21:20.074]     }
[10:21:20.074]     if (FALSE) {
[10:21:20.074]     }
[10:21:20.074]     else {
[10:21:20.074]         if (TRUE) {
[10:21:20.074]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.074]                 open = "w")
[10:21:20.074]         }
[10:21:20.074]         else {
[10:21:20.074]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.074]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.074]         }
[10:21:20.074]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.074]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.074]             base::sink(type = "output", split = FALSE)
[10:21:20.074]             base::close(...future.stdout)
[10:21:20.074]         }, add = TRUE)
[10:21:20.074]     }
[10:21:20.074]     ...future.frame <- base::sys.nframe()
[10:21:20.074]     ...future.conditions <- base::list()
[10:21:20.074]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.074]     if (FALSE) {
[10:21:20.074]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.074]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.074]     }
[10:21:20.074]     ...future.result <- base::tryCatch({
[10:21:20.074]         base::withCallingHandlers({
[10:21:20.074]             ...future.value <- base::withVisible(base::local({
[10:21:20.074]                 withCallingHandlers({
[10:21:20.074]                   NULL
[10:21:20.074]                 }, immediateCondition = function(cond) {
[10:21:20.074]                   save_rds <- function (object, pathname, ...) 
[10:21:20.074]                   {
[10:21:20.074]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:20.074]                     if (file_test("-f", pathname_tmp)) {
[10:21:20.074]                       fi_tmp <- file.info(pathname_tmp)
[10:21:20.074]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:20.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:20.074]                         fi_tmp[["mtime"]])
[10:21:20.074]                     }
[10:21:20.074]                     tryCatch({
[10:21:20.074]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:20.074]                     }, error = function(ex) {
[10:21:20.074]                       msg <- conditionMessage(ex)
[10:21:20.074]                       fi_tmp <- file.info(pathname_tmp)
[10:21:20.074]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:20.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:20.074]                         fi_tmp[["mtime"]], msg)
[10:21:20.074]                       ex$message <- msg
[10:21:20.074]                       stop(ex)
[10:21:20.074]                     })
[10:21:20.074]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:20.074]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:20.074]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:20.074]                       fi_tmp <- file.info(pathname_tmp)
[10:21:20.074]                       fi <- file.info(pathname)
[10:21:20.074]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:20.074]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:20.074]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:20.074]                         fi[["size"]], fi[["mtime"]])
[10:21:20.074]                       stop(msg)
[10:21:20.074]                     }
[10:21:20.074]                     invisible(pathname)
[10:21:20.074]                   }
[10:21:20.074]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:20.074]                     rootPath = tempdir()) 
[10:21:20.074]                   {
[10:21:20.074]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:20.074]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:20.074]                       tmpdir = path, fileext = ".rds")
[10:21:20.074]                     save_rds(obj, file)
[10:21:20.074]                   }
[10:21:20.074]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:20.074]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.074]                   {
[10:21:20.074]                     inherits <- base::inherits
[10:21:20.074]                     invokeRestart <- base::invokeRestart
[10:21:20.074]                     is.null <- base::is.null
[10:21:20.074]                     muffled <- FALSE
[10:21:20.074]                     if (inherits(cond, "message")) {
[10:21:20.074]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.074]                       if (muffled) 
[10:21:20.074]                         invokeRestart("muffleMessage")
[10:21:20.074]                     }
[10:21:20.074]                     else if (inherits(cond, "warning")) {
[10:21:20.074]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.074]                       if (muffled) 
[10:21:20.074]                         invokeRestart("muffleWarning")
[10:21:20.074]                     }
[10:21:20.074]                     else if (inherits(cond, "condition")) {
[10:21:20.074]                       if (!is.null(pattern)) {
[10:21:20.074]                         computeRestarts <- base::computeRestarts
[10:21:20.074]                         grepl <- base::grepl
[10:21:20.074]                         restarts <- computeRestarts(cond)
[10:21:20.074]                         for (restart in restarts) {
[10:21:20.074]                           name <- restart$name
[10:21:20.074]                           if (is.null(name)) 
[10:21:20.074]                             next
[10:21:20.074]                           if (!grepl(pattern, name)) 
[10:21:20.074]                             next
[10:21:20.074]                           invokeRestart(restart)
[10:21:20.074]                           muffled <- TRUE
[10:21:20.074]                           break
[10:21:20.074]                         }
[10:21:20.074]                       }
[10:21:20.074]                     }
[10:21:20.074]                     invisible(muffled)
[10:21:20.074]                   }
[10:21:20.074]                   muffleCondition(cond)
[10:21:20.074]                 })
[10:21:20.074]             }))
[10:21:20.074]             future::FutureResult(value = ...future.value$value, 
[10:21:20.074]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.074]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.074]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.074]                     ...future.globalenv.names))
[10:21:20.074]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.074]         }, condition = base::local({
[10:21:20.074]             c <- base::c
[10:21:20.074]             inherits <- base::inherits
[10:21:20.074]             invokeRestart <- base::invokeRestart
[10:21:20.074]             length <- base::length
[10:21:20.074]             list <- base::list
[10:21:20.074]             seq.int <- base::seq.int
[10:21:20.074]             signalCondition <- base::signalCondition
[10:21:20.074]             sys.calls <- base::sys.calls
[10:21:20.074]             `[[` <- base::`[[`
[10:21:20.074]             `+` <- base::`+`
[10:21:20.074]             `<<-` <- base::`<<-`
[10:21:20.074]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.074]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.074]                   3L)]
[10:21:20.074]             }
[10:21:20.074]             function(cond) {
[10:21:20.074]                 is_error <- inherits(cond, "error")
[10:21:20.074]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.074]                   NULL)
[10:21:20.074]                 if (is_error) {
[10:21:20.074]                   sessionInformation <- function() {
[10:21:20.074]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.074]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.074]                       search = base::search(), system = base::Sys.info())
[10:21:20.074]                   }
[10:21:20.074]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.074]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.074]                     cond$call), session = sessionInformation(), 
[10:21:20.074]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.074]                   signalCondition(cond)
[10:21:20.074]                 }
[10:21:20.074]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.074]                 "immediateCondition"))) {
[10:21:20.074]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.074]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.074]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.074]                   if (TRUE && !signal) {
[10:21:20.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.074]                     {
[10:21:20.074]                       inherits <- base::inherits
[10:21:20.074]                       invokeRestart <- base::invokeRestart
[10:21:20.074]                       is.null <- base::is.null
[10:21:20.074]                       muffled <- FALSE
[10:21:20.074]                       if (inherits(cond, "message")) {
[10:21:20.074]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.074]                         if (muffled) 
[10:21:20.074]                           invokeRestart("muffleMessage")
[10:21:20.074]                       }
[10:21:20.074]                       else if (inherits(cond, "warning")) {
[10:21:20.074]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.074]                         if (muffled) 
[10:21:20.074]                           invokeRestart("muffleWarning")
[10:21:20.074]                       }
[10:21:20.074]                       else if (inherits(cond, "condition")) {
[10:21:20.074]                         if (!is.null(pattern)) {
[10:21:20.074]                           computeRestarts <- base::computeRestarts
[10:21:20.074]                           grepl <- base::grepl
[10:21:20.074]                           restarts <- computeRestarts(cond)
[10:21:20.074]                           for (restart in restarts) {
[10:21:20.074]                             name <- restart$name
[10:21:20.074]                             if (is.null(name)) 
[10:21:20.074]                               next
[10:21:20.074]                             if (!grepl(pattern, name)) 
[10:21:20.074]                               next
[10:21:20.074]                             invokeRestart(restart)
[10:21:20.074]                             muffled <- TRUE
[10:21:20.074]                             break
[10:21:20.074]                           }
[10:21:20.074]                         }
[10:21:20.074]                       }
[10:21:20.074]                       invisible(muffled)
[10:21:20.074]                     }
[10:21:20.074]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.074]                   }
[10:21:20.074]                 }
[10:21:20.074]                 else {
[10:21:20.074]                   if (TRUE) {
[10:21:20.074]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.074]                     {
[10:21:20.074]                       inherits <- base::inherits
[10:21:20.074]                       invokeRestart <- base::invokeRestart
[10:21:20.074]                       is.null <- base::is.null
[10:21:20.074]                       muffled <- FALSE
[10:21:20.074]                       if (inherits(cond, "message")) {
[10:21:20.074]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.074]                         if (muffled) 
[10:21:20.074]                           invokeRestart("muffleMessage")
[10:21:20.074]                       }
[10:21:20.074]                       else if (inherits(cond, "warning")) {
[10:21:20.074]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.074]                         if (muffled) 
[10:21:20.074]                           invokeRestart("muffleWarning")
[10:21:20.074]                       }
[10:21:20.074]                       else if (inherits(cond, "condition")) {
[10:21:20.074]                         if (!is.null(pattern)) {
[10:21:20.074]                           computeRestarts <- base::computeRestarts
[10:21:20.074]                           grepl <- base::grepl
[10:21:20.074]                           restarts <- computeRestarts(cond)
[10:21:20.074]                           for (restart in restarts) {
[10:21:20.074]                             name <- restart$name
[10:21:20.074]                             if (is.null(name)) 
[10:21:20.074]                               next
[10:21:20.074]                             if (!grepl(pattern, name)) 
[10:21:20.074]                               next
[10:21:20.074]                             invokeRestart(restart)
[10:21:20.074]                             muffled <- TRUE
[10:21:20.074]                             break
[10:21:20.074]                           }
[10:21:20.074]                         }
[10:21:20.074]                       }
[10:21:20.074]                       invisible(muffled)
[10:21:20.074]                     }
[10:21:20.074]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.074]                   }
[10:21:20.074]                 }
[10:21:20.074]             }
[10:21:20.074]         }))
[10:21:20.074]     }, error = function(ex) {
[10:21:20.074]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.074]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.074]                 ...future.rng), started = ...future.startTime, 
[10:21:20.074]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.074]             version = "1.8"), class = "FutureResult")
[10:21:20.074]     }, finally = {
[10:21:20.074]         if (!identical(...future.workdir, getwd())) 
[10:21:20.074]             setwd(...future.workdir)
[10:21:20.074]         {
[10:21:20.074]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.074]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.074]             }
[10:21:20.074]             base::options(...future.oldOptions)
[10:21:20.074]             if (.Platform$OS.type == "windows") {
[10:21:20.074]                 old_names <- names(...future.oldEnvVars)
[10:21:20.074]                 envs <- base::Sys.getenv()
[10:21:20.074]                 names <- names(envs)
[10:21:20.074]                 common <- intersect(names, old_names)
[10:21:20.074]                 added <- setdiff(names, old_names)
[10:21:20.074]                 removed <- setdiff(old_names, names)
[10:21:20.074]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.074]                   envs[common]]
[10:21:20.074]                 NAMES <- toupper(changed)
[10:21:20.074]                 args <- list()
[10:21:20.074]                 for (kk in seq_along(NAMES)) {
[10:21:20.074]                   name <- changed[[kk]]
[10:21:20.074]                   NAME <- NAMES[[kk]]
[10:21:20.074]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.074]                     next
[10:21:20.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.074]                 }
[10:21:20.074]                 NAMES <- toupper(added)
[10:21:20.074]                 for (kk in seq_along(NAMES)) {
[10:21:20.074]                   name <- added[[kk]]
[10:21:20.074]                   NAME <- NAMES[[kk]]
[10:21:20.074]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.074]                     next
[10:21:20.074]                   args[[name]] <- ""
[10:21:20.074]                 }
[10:21:20.074]                 NAMES <- toupper(removed)
[10:21:20.074]                 for (kk in seq_along(NAMES)) {
[10:21:20.074]                   name <- removed[[kk]]
[10:21:20.074]                   NAME <- NAMES[[kk]]
[10:21:20.074]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.074]                     next
[10:21:20.074]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.074]                 }
[10:21:20.074]                 if (length(args) > 0) 
[10:21:20.074]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.074]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.074]             }
[10:21:20.074]             else {
[10:21:20.074]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.074]             }
[10:21:20.074]             {
[10:21:20.074]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.074]                   0L) {
[10:21:20.074]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.074]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.074]                   base::options(opts)
[10:21:20.074]                 }
[10:21:20.074]                 {
[10:21:20.074]                   {
[10:21:20.074]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.074]                     NULL
[10:21:20.074]                   }
[10:21:20.074]                   options(future.plan = NULL)
[10:21:20.074]                   if (is.na(NA_character_)) 
[10:21:20.074]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.074]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.074]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.074]                     .init = FALSE)
[10:21:20.074]                 }
[10:21:20.074]             }
[10:21:20.074]         }
[10:21:20.074]     })
[10:21:20.074]     if (TRUE) {
[10:21:20.074]         base::sink(type = "output", split = FALSE)
[10:21:20.074]         if (TRUE) {
[10:21:20.074]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.074]         }
[10:21:20.074]         else {
[10:21:20.074]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.074]         }
[10:21:20.074]         base::close(...future.stdout)
[10:21:20.074]         ...future.stdout <- NULL
[10:21:20.074]     }
[10:21:20.074]     ...future.result$conditions <- ...future.conditions
[10:21:20.074]     ...future.result$finished <- base::Sys.time()
[10:21:20.074]     ...future.result
[10:21:20.074] }
[10:21:20.078] requestCore(): workers = 2
[10:21:20.080] MulticoreFuture started
[10:21:20.080] - Launch lazy future ... done
[10:21:20.080] run() for ‘MulticoreFuture’ ... done
List of 6
[10:21:20.081] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[10:21:20.081] List of future strategies:
[10:21:20.081] 1. sequential:
[10:21:20.081]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:20.081]    - tweaked: FALSE
[10:21:20.081]    - call: NULL
[10:21:20.082] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e54ce6a0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e31d9ab8> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:21:20.084] plan(): Setting new future strategy stack:
List of 6
 $ a:[10:21:20.085] List of future strategies:
[10:21:20.085] 1. multicore:
[10:21:20.085]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:20.085]    - tweaked: FALSE
[10:21:20.085]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e54ce6a0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e31d9ab8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ :[10:21:20.088] plan(): nbrOfWorkers() = 2
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:20.093] resolve() on list ...
[10:21:20.093]  recursive: 0
[10:21:20.093]  length: 6
[10:21:20.093]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:20.094] signalConditionsASAP(numeric, pos=1) ...
[10:21:20.094] - nx: 6
[10:21:20.094] - relay: TRUE
[10:21:20.094] - stdout: TRUE
[10:21:20.094] - signal: TRUE
[10:21:20.094] - resignal: FALSE
[10:21:20.094] - force: TRUE
[10:21:20.094] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.095] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.095]  - until=2
[10:21:20.095]  - relaying element #2
[10:21:20.095] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.095] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.095] signalConditionsASAP(NULL, pos=1) ... done
[10:21:20.095]  length: 5 (resolved future 1)
[10:21:20.096] Future #2
[10:21:20.096] result() for MulticoreFuture ...
[10:21:20.097] result() for MulticoreFuture ...
[10:21:20.097] result() for MulticoreFuture ... done
[10:21:20.097] result() for MulticoreFuture ... done
[10:21:20.097] result() for MulticoreFuture ...
[10:21:20.098] result() for MulticoreFuture ... done
[10:21:20.098] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:20.098] - nx: 6
[10:21:20.098] - relay: TRUE
[10:21:20.098] - stdout: TRUE
[10:21:20.098] - signal: TRUE
[10:21:20.098] - resignal: FALSE
[10:21:20.098] - force: TRUE
[10:21:20.099] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.099] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.099]  - until=2
[10:21:20.099]  - relaying element #2
[10:21:20.099] result() for MulticoreFuture ...
[10:21:20.099] result() for MulticoreFuture ... done
[10:21:20.099] result() for MulticoreFuture ...
[10:21:20.099] result() for MulticoreFuture ... done
[10:21:20.100] result() for MulticoreFuture ...
[10:21:20.100] result() for MulticoreFuture ... done
[10:21:20.100] result() for MulticoreFuture ...
[10:21:20.100] result() for MulticoreFuture ... done
[10:21:20.100] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.100] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.100] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:20.104]  length: 4 (resolved future 2)
[10:21:20.104] Future #3
[10:21:20.105] result() for MulticoreFuture ...
[10:21:20.106] result() for MulticoreFuture ...
[10:21:20.106] result() for MulticoreFuture ... done
[10:21:20.106] result() for MulticoreFuture ... done
[10:21:20.106] result() for MulticoreFuture ...
[10:21:20.107] result() for MulticoreFuture ... done
[10:21:20.107] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:20.107] - nx: 6
[10:21:20.107] - relay: TRUE
[10:21:20.107] - stdout: TRUE
[10:21:20.107] - signal: TRUE
[10:21:20.108] - resignal: FALSE
[10:21:20.108] - force: TRUE
[10:21:20.108] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.108] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.108]  - until=3
[10:21:20.108]  - relaying element #3
[10:21:20.108] result() for MulticoreFuture ...
[10:21:20.108] result() for MulticoreFuture ... done
[10:21:20.109] result() for MulticoreFuture ...
[10:21:20.109] result() for MulticoreFuture ... done
[10:21:20.109] result() for MulticoreFuture ...
[10:21:20.109] result() for MulticoreFuture ... done
[10:21:20.109] result() for MulticoreFuture ...
[10:21:20.109] result() for MulticoreFuture ... done
[10:21:20.109] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.109] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.110] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:20.110]  length: 3 (resolved future 3)
[10:21:20.110] signalConditionsASAP(NULL, pos=4) ...
[10:21:20.110] - nx: 6
[10:21:20.110] - relay: TRUE
[10:21:20.110] - stdout: TRUE
[10:21:20.110] - signal: TRUE
[10:21:20.110] - resignal: FALSE
[10:21:20.110] - force: TRUE
[10:21:20.111] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.111] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.111]  - until=5
[10:21:20.111]  - relaying element #5
[10:21:20.111] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:20.111] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.111] signalConditionsASAP(NULL, pos=4) ... done
[10:21:20.111]  length: 2 (resolved future 4)
[10:21:20.111] signalConditionsASAP(NULL, pos=5) ...
[10:21:20.112] - nx: 6
[10:21:20.112] - relay: TRUE
[10:21:20.112] - stdout: TRUE
[10:21:20.112] - signal: TRUE
[10:21:20.112] - resignal: FALSE
[10:21:20.112] - force: TRUE
[10:21:20.112] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:20.112] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.112]  - until=6
[10:21:20.112]  - relaying element #6
[10:21:20.113] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:20.113] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.113] signalConditionsASAP(NULL, pos=5) ... done
[10:21:20.113]  length: 1 (resolved future 5)
[10:21:20.113] signalConditionsASAP(numeric, pos=6) ...
[10:21:20.113] - nx: 6
[10:21:20.113] - relay: TRUE
[10:21:20.113] - stdout: TRUE
[10:21:20.113] - signal: TRUE
[10:21:20.113] - resignal: FALSE
[10:21:20.114] - force: TRUE
[10:21:20.114] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:20.114] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.114]  - until=6
[10:21:20.114] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.114] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.114] signalConditionsASAP(numeric, pos=6) ... done
[10:21:20.114]  length: 0 (resolved future 6)
[10:21:20.114] Relaying remaining futures
[10:21:20.114] signalConditionsASAP(NULL, pos=0) ...
[10:21:20.115] - nx: 6
[10:21:20.115] - relay: TRUE
[10:21:20.115] - stdout: TRUE
[10:21:20.115] - signal: TRUE
[10:21:20.115] - resignal: FALSE
[10:21:20.115] - force: TRUE
[10:21:20.115] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.115] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:20.115] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.115] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.116] signalConditionsASAP(NULL, pos=0) ... done
[10:21:20.116] resolve() on list ... DONE
[10:21:20.116] result() for MulticoreFuture ...
[10:21:20.116] result() for MulticoreFuture ... done
[10:21:20.116] result() for MulticoreFuture ...
[10:21:20.116] result() for MulticoreFuture ... done
[10:21:20.116] result() for MulticoreFuture ...
[10:21:20.116] result() for MulticoreFuture ... done
[10:21:20.116] result() for MulticoreFuture ...
[10:21:20.116] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[10:21:20.120] plan(): Setting new future strategy stack:
[10:21:20.120] List of future strategies:
[10:21:20.120] 1. multisession:
[10:21:20.120]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:20.120]    - tweaked: FALSE
[10:21:20.120]    - call: plan(strategy)
[10:21:20.121] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:20.121] multisession:
[10:21:20.121] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:20.121] - tweaked: FALSE
[10:21:20.121] - call: plan(strategy)
[10:21:20.125] getGlobalsAndPackages() ...
[10:21:20.125] Not searching for globals
[10:21:20.125] - globals: [0] <none>
[10:21:20.125] getGlobalsAndPackages() ... DONE
[10:21:20.604] Packages needed by the future expression (n = 0): <none>
[10:21:20.605] Packages needed by future strategies (n = 0): <none>
[10:21:20.605] {
[10:21:20.605]     {
[10:21:20.605]         {
[10:21:20.605]             ...future.startTime <- base::Sys.time()
[10:21:20.605]             {
[10:21:20.605]                 {
[10:21:20.605]                   {
[10:21:20.605]                     {
[10:21:20.605]                       base::local({
[10:21:20.605]                         has_future <- base::requireNamespace("future", 
[10:21:20.605]                           quietly = TRUE)
[10:21:20.605]                         if (has_future) {
[10:21:20.605]                           ns <- base::getNamespace("future")
[10:21:20.605]                           version <- ns[[".package"]][["version"]]
[10:21:20.605]                           if (is.null(version)) 
[10:21:20.605]                             version <- utils::packageVersion("future")
[10:21:20.605]                         }
[10:21:20.605]                         else {
[10:21:20.605]                           version <- NULL
[10:21:20.605]                         }
[10:21:20.605]                         if (!has_future || version < "1.8.0") {
[10:21:20.605]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.605]                             "", base::R.version$version.string), 
[10:21:20.605]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.605]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.605]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.605]                               "release", "version")], collapse = " "), 
[10:21:20.605]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.605]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.605]                             info)
[10:21:20.605]                           info <- base::paste(info, collapse = "; ")
[10:21:20.605]                           if (!has_future) {
[10:21:20.605]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.605]                               info)
[10:21:20.605]                           }
[10:21:20.605]                           else {
[10:21:20.605]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.605]                               info, version)
[10:21:20.605]                           }
[10:21:20.605]                           base::stop(msg)
[10:21:20.605]                         }
[10:21:20.605]                       })
[10:21:20.605]                     }
[10:21:20.605]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.605]                     base::options(mc.cores = 1L)
[10:21:20.605]                   }
[10:21:20.605]                   ...future.strategy.old <- future::plan("list")
[10:21:20.605]                   options(future.plan = NULL)
[10:21:20.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.605]                 }
[10:21:20.605]                 ...future.workdir <- getwd()
[10:21:20.605]             }
[10:21:20.605]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.605]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.605]         }
[10:21:20.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.605]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.605]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.605]             base::names(...future.oldOptions))
[10:21:20.605]     }
[10:21:20.605]     if (FALSE) {
[10:21:20.605]     }
[10:21:20.605]     else {
[10:21:20.605]         if (TRUE) {
[10:21:20.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.605]                 open = "w")
[10:21:20.605]         }
[10:21:20.605]         else {
[10:21:20.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.605]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.605]         }
[10:21:20.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.605]             base::sink(type = "output", split = FALSE)
[10:21:20.605]             base::close(...future.stdout)
[10:21:20.605]         }, add = TRUE)
[10:21:20.605]     }
[10:21:20.605]     ...future.frame <- base::sys.nframe()
[10:21:20.605]     ...future.conditions <- base::list()
[10:21:20.605]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.605]     if (FALSE) {
[10:21:20.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.605]     }
[10:21:20.605]     ...future.result <- base::tryCatch({
[10:21:20.605]         base::withCallingHandlers({
[10:21:20.605]             ...future.value <- base::withVisible(base::local({
[10:21:20.605]                 ...future.makeSendCondition <- base::local({
[10:21:20.605]                   sendCondition <- NULL
[10:21:20.605]                   function(frame = 1L) {
[10:21:20.605]                     if (is.function(sendCondition)) 
[10:21:20.605]                       return(sendCondition)
[10:21:20.605]                     ns <- getNamespace("parallel")
[10:21:20.605]                     if (exists("sendData", mode = "function", 
[10:21:20.605]                       envir = ns)) {
[10:21:20.605]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:20.605]                         envir = ns)
[10:21:20.605]                       envir <- sys.frame(frame)
[10:21:20.605]                       master <- NULL
[10:21:20.605]                       while (!identical(envir, .GlobalEnv) && 
[10:21:20.605]                         !identical(envir, emptyenv())) {
[10:21:20.605]                         if (exists("master", mode = "list", envir = envir, 
[10:21:20.605]                           inherits = FALSE)) {
[10:21:20.605]                           master <- get("master", mode = "list", 
[10:21:20.605]                             envir = envir, inherits = FALSE)
[10:21:20.605]                           if (inherits(master, c("SOCKnode", 
[10:21:20.605]                             "SOCK0node"))) {
[10:21:20.605]                             sendCondition <<- function(cond) {
[10:21:20.605]                               data <- list(type = "VALUE", value = cond, 
[10:21:20.605]                                 success = TRUE)
[10:21:20.605]                               parallel_sendData(master, data)
[10:21:20.605]                             }
[10:21:20.605]                             return(sendCondition)
[10:21:20.605]                           }
[10:21:20.605]                         }
[10:21:20.605]                         frame <- frame + 1L
[10:21:20.605]                         envir <- sys.frame(frame)
[10:21:20.605]                       }
[10:21:20.605]                     }
[10:21:20.605]                     sendCondition <<- function(cond) NULL
[10:21:20.605]                   }
[10:21:20.605]                 })
[10:21:20.605]                 withCallingHandlers({
[10:21:20.605]                   NA
[10:21:20.605]                 }, immediateCondition = function(cond) {
[10:21:20.605]                   sendCondition <- ...future.makeSendCondition()
[10:21:20.605]                   sendCondition(cond)
[10:21:20.605]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.605]                   {
[10:21:20.605]                     inherits <- base::inherits
[10:21:20.605]                     invokeRestart <- base::invokeRestart
[10:21:20.605]                     is.null <- base::is.null
[10:21:20.605]                     muffled <- FALSE
[10:21:20.605]                     if (inherits(cond, "message")) {
[10:21:20.605]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.605]                       if (muffled) 
[10:21:20.605]                         invokeRestart("muffleMessage")
[10:21:20.605]                     }
[10:21:20.605]                     else if (inherits(cond, "warning")) {
[10:21:20.605]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.605]                       if (muffled) 
[10:21:20.605]                         invokeRestart("muffleWarning")
[10:21:20.605]                     }
[10:21:20.605]                     else if (inherits(cond, "condition")) {
[10:21:20.605]                       if (!is.null(pattern)) {
[10:21:20.605]                         computeRestarts <- base::computeRestarts
[10:21:20.605]                         grepl <- base::grepl
[10:21:20.605]                         restarts <- computeRestarts(cond)
[10:21:20.605]                         for (restart in restarts) {
[10:21:20.605]                           name <- restart$name
[10:21:20.605]                           if (is.null(name)) 
[10:21:20.605]                             next
[10:21:20.605]                           if (!grepl(pattern, name)) 
[10:21:20.605]                             next
[10:21:20.605]                           invokeRestart(restart)
[10:21:20.605]                           muffled <- TRUE
[10:21:20.605]                           break
[10:21:20.605]                         }
[10:21:20.605]                       }
[10:21:20.605]                     }
[10:21:20.605]                     invisible(muffled)
[10:21:20.605]                   }
[10:21:20.605]                   muffleCondition(cond)
[10:21:20.605]                 })
[10:21:20.605]             }))
[10:21:20.605]             future::FutureResult(value = ...future.value$value, 
[10:21:20.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.605]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.605]                     ...future.globalenv.names))
[10:21:20.605]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.605]         }, condition = base::local({
[10:21:20.605]             c <- base::c
[10:21:20.605]             inherits <- base::inherits
[10:21:20.605]             invokeRestart <- base::invokeRestart
[10:21:20.605]             length <- base::length
[10:21:20.605]             list <- base::list
[10:21:20.605]             seq.int <- base::seq.int
[10:21:20.605]             signalCondition <- base::signalCondition
[10:21:20.605]             sys.calls <- base::sys.calls
[10:21:20.605]             `[[` <- base::`[[`
[10:21:20.605]             `+` <- base::`+`
[10:21:20.605]             `<<-` <- base::`<<-`
[10:21:20.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.605]                   3L)]
[10:21:20.605]             }
[10:21:20.605]             function(cond) {
[10:21:20.605]                 is_error <- inherits(cond, "error")
[10:21:20.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.605]                   NULL)
[10:21:20.605]                 if (is_error) {
[10:21:20.605]                   sessionInformation <- function() {
[10:21:20.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.605]                       search = base::search(), system = base::Sys.info())
[10:21:20.605]                   }
[10:21:20.605]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.605]                     cond$call), session = sessionInformation(), 
[10:21:20.605]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.605]                   signalCondition(cond)
[10:21:20.605]                 }
[10:21:20.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.605]                 "immediateCondition"))) {
[10:21:20.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.605]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.605]                   if (TRUE && !signal) {
[10:21:20.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.605]                     {
[10:21:20.605]                       inherits <- base::inherits
[10:21:20.605]                       invokeRestart <- base::invokeRestart
[10:21:20.605]                       is.null <- base::is.null
[10:21:20.605]                       muffled <- FALSE
[10:21:20.605]                       if (inherits(cond, "message")) {
[10:21:20.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.605]                         if (muffled) 
[10:21:20.605]                           invokeRestart("muffleMessage")
[10:21:20.605]                       }
[10:21:20.605]                       else if (inherits(cond, "warning")) {
[10:21:20.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.605]                         if (muffled) 
[10:21:20.605]                           invokeRestart("muffleWarning")
[10:21:20.605]                       }
[10:21:20.605]                       else if (inherits(cond, "condition")) {
[10:21:20.605]                         if (!is.null(pattern)) {
[10:21:20.605]                           computeRestarts <- base::computeRestarts
[10:21:20.605]                           grepl <- base::grepl
[10:21:20.605]                           restarts <- computeRestarts(cond)
[10:21:20.605]                           for (restart in restarts) {
[10:21:20.605]                             name <- restart$name
[10:21:20.605]                             if (is.null(name)) 
[10:21:20.605]                               next
[10:21:20.605]                             if (!grepl(pattern, name)) 
[10:21:20.605]                               next
[10:21:20.605]                             invokeRestart(restart)
[10:21:20.605]                             muffled <- TRUE
[10:21:20.605]                             break
[10:21:20.605]                           }
[10:21:20.605]                         }
[10:21:20.605]                       }
[10:21:20.605]                       invisible(muffled)
[10:21:20.605]                     }
[10:21:20.605]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.605]                   }
[10:21:20.605]                 }
[10:21:20.605]                 else {
[10:21:20.605]                   if (TRUE) {
[10:21:20.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.605]                     {
[10:21:20.605]                       inherits <- base::inherits
[10:21:20.605]                       invokeRestart <- base::invokeRestart
[10:21:20.605]                       is.null <- base::is.null
[10:21:20.605]                       muffled <- FALSE
[10:21:20.605]                       if (inherits(cond, "message")) {
[10:21:20.605]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.605]                         if (muffled) 
[10:21:20.605]                           invokeRestart("muffleMessage")
[10:21:20.605]                       }
[10:21:20.605]                       else if (inherits(cond, "warning")) {
[10:21:20.605]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.605]                         if (muffled) 
[10:21:20.605]                           invokeRestart("muffleWarning")
[10:21:20.605]                       }
[10:21:20.605]                       else if (inherits(cond, "condition")) {
[10:21:20.605]                         if (!is.null(pattern)) {
[10:21:20.605]                           computeRestarts <- base::computeRestarts
[10:21:20.605]                           grepl <- base::grepl
[10:21:20.605]                           restarts <- computeRestarts(cond)
[10:21:20.605]                           for (restart in restarts) {
[10:21:20.605]                             name <- restart$name
[10:21:20.605]                             if (is.null(name)) 
[10:21:20.605]                               next
[10:21:20.605]                             if (!grepl(pattern, name)) 
[10:21:20.605]                               next
[10:21:20.605]                             invokeRestart(restart)
[10:21:20.605]                             muffled <- TRUE
[10:21:20.605]                             break
[10:21:20.605]                           }
[10:21:20.605]                         }
[10:21:20.605]                       }
[10:21:20.605]                       invisible(muffled)
[10:21:20.605]                     }
[10:21:20.605]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.605]                   }
[10:21:20.605]                 }
[10:21:20.605]             }
[10:21:20.605]         }))
[10:21:20.605]     }, error = function(ex) {
[10:21:20.605]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.605]                 ...future.rng), started = ...future.startTime, 
[10:21:20.605]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.605]             version = "1.8"), class = "FutureResult")
[10:21:20.605]     }, finally = {
[10:21:20.605]         if (!identical(...future.workdir, getwd())) 
[10:21:20.605]             setwd(...future.workdir)
[10:21:20.605]         {
[10:21:20.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.605]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.605]             }
[10:21:20.605]             base::options(...future.oldOptions)
[10:21:20.605]             if (.Platform$OS.type == "windows") {
[10:21:20.605]                 old_names <- names(...future.oldEnvVars)
[10:21:20.605]                 envs <- base::Sys.getenv()
[10:21:20.605]                 names <- names(envs)
[10:21:20.605]                 common <- intersect(names, old_names)
[10:21:20.605]                 added <- setdiff(names, old_names)
[10:21:20.605]                 removed <- setdiff(old_names, names)
[10:21:20.605]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.605]                   envs[common]]
[10:21:20.605]                 NAMES <- toupper(changed)
[10:21:20.605]                 args <- list()
[10:21:20.605]                 for (kk in seq_along(NAMES)) {
[10:21:20.605]                   name <- changed[[kk]]
[10:21:20.605]                   NAME <- NAMES[[kk]]
[10:21:20.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.605]                     next
[10:21:20.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.605]                 }
[10:21:20.605]                 NAMES <- toupper(added)
[10:21:20.605]                 for (kk in seq_along(NAMES)) {
[10:21:20.605]                   name <- added[[kk]]
[10:21:20.605]                   NAME <- NAMES[[kk]]
[10:21:20.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.605]                     next
[10:21:20.605]                   args[[name]] <- ""
[10:21:20.605]                 }
[10:21:20.605]                 NAMES <- toupper(removed)
[10:21:20.605]                 for (kk in seq_along(NAMES)) {
[10:21:20.605]                   name <- removed[[kk]]
[10:21:20.605]                   NAME <- NAMES[[kk]]
[10:21:20.605]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.605]                     next
[10:21:20.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.605]                 }
[10:21:20.605]                 if (length(args) > 0) 
[10:21:20.605]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.605]             }
[10:21:20.605]             else {
[10:21:20.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.605]             }
[10:21:20.605]             {
[10:21:20.605]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.605]                   0L) {
[10:21:20.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.605]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.605]                   base::options(opts)
[10:21:20.605]                 }
[10:21:20.605]                 {
[10:21:20.605]                   {
[10:21:20.605]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.605]                     NULL
[10:21:20.605]                   }
[10:21:20.605]                   options(future.plan = NULL)
[10:21:20.605]                   if (is.na(NA_character_)) 
[10:21:20.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.605]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.605]                     .init = FALSE)
[10:21:20.605]                 }
[10:21:20.605]             }
[10:21:20.605]         }
[10:21:20.605]     })
[10:21:20.605]     if (TRUE) {
[10:21:20.605]         base::sink(type = "output", split = FALSE)
[10:21:20.605]         if (TRUE) {
[10:21:20.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.605]         }
[10:21:20.605]         else {
[10:21:20.605]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.605]         }
[10:21:20.605]         base::close(...future.stdout)
[10:21:20.605]         ...future.stdout <- NULL
[10:21:20.605]     }
[10:21:20.605]     ...future.result$conditions <- ...future.conditions
[10:21:20.605]     ...future.result$finished <- base::Sys.time()
[10:21:20.605]     ...future.result
[10:21:20.605] }
[10:21:20.658] MultisessionFuture started
[10:21:20.658] result() for ClusterFuture ...
[10:21:20.659] receiveMessageFromWorker() for ClusterFuture ...
[10:21:20.659] - Validating connection of MultisessionFuture
[10:21:20.689] - received message: FutureResult
[10:21:20.690] - Received FutureResult
[10:21:20.690] - Erased future from FutureRegistry
[10:21:20.690] result() for ClusterFuture ...
[10:21:20.690] - result already collected: FutureResult
[10:21:20.690] result() for ClusterFuture ... done
[10:21:20.690] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:20.690] result() for ClusterFuture ... done
[10:21:20.690] result() for ClusterFuture ...
[10:21:20.690] - result already collected: FutureResult
[10:21:20.690] result() for ClusterFuture ... done
[10:21:20.691] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:20.692] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:21:20.692] getGlobalsAndPackages() ...
[10:21:20.693] Searching for globals...
[10:21:20.693] 
[10:21:20.693] Searching for globals ... DONE
[10:21:20.693] - globals: [0] <none>
[10:21:20.693] getGlobalsAndPackages() ... DONE
[10:21:20.693] run() for ‘Future’ ...
[10:21:20.694] - state: ‘created’
[10:21:20.694] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:20.708] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:20.708] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:20.708]   - Field: ‘node’
[10:21:20.708]   - Field: ‘label’
[10:21:20.708]   - Field: ‘local’
[10:21:20.708]   - Field: ‘owner’
[10:21:20.709]   - Field: ‘envir’
[10:21:20.709]   - Field: ‘workers’
[10:21:20.709]   - Field: ‘packages’
[10:21:20.709]   - Field: ‘gc’
[10:21:20.709]   - Field: ‘conditions’
[10:21:20.709]   - Field: ‘persistent’
[10:21:20.709]   - Field: ‘expr’
[10:21:20.709]   - Field: ‘uuid’
[10:21:20.709]   - Field: ‘seed’
[10:21:20.709]   - Field: ‘version’
[10:21:20.709]   - Field: ‘result’
[10:21:20.710]   - Field: ‘asynchronous’
[10:21:20.710]   - Field: ‘calls’
[10:21:20.710]   - Field: ‘globals’
[10:21:20.710]   - Field: ‘stdout’
[10:21:20.710]   - Field: ‘earlySignal’
[10:21:20.710]   - Field: ‘lazy’
[10:21:20.710]   - Field: ‘state’
[10:21:20.710] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:20.710] - Launch lazy future ...
[10:21:20.710] Packages needed by the future expression (n = 0): <none>
[10:21:20.711] Packages needed by future strategies (n = 0): <none>
[10:21:20.711] {
[10:21:20.711]     {
[10:21:20.711]         {
[10:21:20.711]             ...future.startTime <- base::Sys.time()
[10:21:20.711]             {
[10:21:20.711]                 {
[10:21:20.711]                   {
[10:21:20.711]                     {
[10:21:20.711]                       base::local({
[10:21:20.711]                         has_future <- base::requireNamespace("future", 
[10:21:20.711]                           quietly = TRUE)
[10:21:20.711]                         if (has_future) {
[10:21:20.711]                           ns <- base::getNamespace("future")
[10:21:20.711]                           version <- ns[[".package"]][["version"]]
[10:21:20.711]                           if (is.null(version)) 
[10:21:20.711]                             version <- utils::packageVersion("future")
[10:21:20.711]                         }
[10:21:20.711]                         else {
[10:21:20.711]                           version <- NULL
[10:21:20.711]                         }
[10:21:20.711]                         if (!has_future || version < "1.8.0") {
[10:21:20.711]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.711]                             "", base::R.version$version.string), 
[10:21:20.711]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.711]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.711]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.711]                               "release", "version")], collapse = " "), 
[10:21:20.711]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.711]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.711]                             info)
[10:21:20.711]                           info <- base::paste(info, collapse = "; ")
[10:21:20.711]                           if (!has_future) {
[10:21:20.711]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.711]                               info)
[10:21:20.711]                           }
[10:21:20.711]                           else {
[10:21:20.711]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.711]                               info, version)
[10:21:20.711]                           }
[10:21:20.711]                           base::stop(msg)
[10:21:20.711]                         }
[10:21:20.711]                       })
[10:21:20.711]                     }
[10:21:20.711]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.711]                     base::options(mc.cores = 1L)
[10:21:20.711]                   }
[10:21:20.711]                   ...future.strategy.old <- future::plan("list")
[10:21:20.711]                   options(future.plan = NULL)
[10:21:20.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.711]                 }
[10:21:20.711]                 ...future.workdir <- getwd()
[10:21:20.711]             }
[10:21:20.711]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.711]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.711]         }
[10:21:20.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.711]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.711]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.711]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.711]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.711]             base::names(...future.oldOptions))
[10:21:20.711]     }
[10:21:20.711]     if (FALSE) {
[10:21:20.711]     }
[10:21:20.711]     else {
[10:21:20.711]         if (TRUE) {
[10:21:20.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.711]                 open = "w")
[10:21:20.711]         }
[10:21:20.711]         else {
[10:21:20.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.711]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.711]         }
[10:21:20.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.711]             base::sink(type = "output", split = FALSE)
[10:21:20.711]             base::close(...future.stdout)
[10:21:20.711]         }, add = TRUE)
[10:21:20.711]     }
[10:21:20.711]     ...future.frame <- base::sys.nframe()
[10:21:20.711]     ...future.conditions <- base::list()
[10:21:20.711]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.711]     if (FALSE) {
[10:21:20.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.711]     }
[10:21:20.711]     ...future.result <- base::tryCatch({
[10:21:20.711]         base::withCallingHandlers({
[10:21:20.711]             ...future.value <- base::withVisible(base::local({
[10:21:20.711]                 ...future.makeSendCondition <- base::local({
[10:21:20.711]                   sendCondition <- NULL
[10:21:20.711]                   function(frame = 1L) {
[10:21:20.711]                     if (is.function(sendCondition)) 
[10:21:20.711]                       return(sendCondition)
[10:21:20.711]                     ns <- getNamespace("parallel")
[10:21:20.711]                     if (exists("sendData", mode = "function", 
[10:21:20.711]                       envir = ns)) {
[10:21:20.711]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:20.711]                         envir = ns)
[10:21:20.711]                       envir <- sys.frame(frame)
[10:21:20.711]                       master <- NULL
[10:21:20.711]                       while (!identical(envir, .GlobalEnv) && 
[10:21:20.711]                         !identical(envir, emptyenv())) {
[10:21:20.711]                         if (exists("master", mode = "list", envir = envir, 
[10:21:20.711]                           inherits = FALSE)) {
[10:21:20.711]                           master <- get("master", mode = "list", 
[10:21:20.711]                             envir = envir, inherits = FALSE)
[10:21:20.711]                           if (inherits(master, c("SOCKnode", 
[10:21:20.711]                             "SOCK0node"))) {
[10:21:20.711]                             sendCondition <<- function(cond) {
[10:21:20.711]                               data <- list(type = "VALUE", value = cond, 
[10:21:20.711]                                 success = TRUE)
[10:21:20.711]                               parallel_sendData(master, data)
[10:21:20.711]                             }
[10:21:20.711]                             return(sendCondition)
[10:21:20.711]                           }
[10:21:20.711]                         }
[10:21:20.711]                         frame <- frame + 1L
[10:21:20.711]                         envir <- sys.frame(frame)
[10:21:20.711]                       }
[10:21:20.711]                     }
[10:21:20.711]                     sendCondition <<- function(cond) NULL
[10:21:20.711]                   }
[10:21:20.711]                 })
[10:21:20.711]                 withCallingHandlers({
[10:21:20.711]                   2
[10:21:20.711]                 }, immediateCondition = function(cond) {
[10:21:20.711]                   sendCondition <- ...future.makeSendCondition()
[10:21:20.711]                   sendCondition(cond)
[10:21:20.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.711]                   {
[10:21:20.711]                     inherits <- base::inherits
[10:21:20.711]                     invokeRestart <- base::invokeRestart
[10:21:20.711]                     is.null <- base::is.null
[10:21:20.711]                     muffled <- FALSE
[10:21:20.711]                     if (inherits(cond, "message")) {
[10:21:20.711]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.711]                       if (muffled) 
[10:21:20.711]                         invokeRestart("muffleMessage")
[10:21:20.711]                     }
[10:21:20.711]                     else if (inherits(cond, "warning")) {
[10:21:20.711]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.711]                       if (muffled) 
[10:21:20.711]                         invokeRestart("muffleWarning")
[10:21:20.711]                     }
[10:21:20.711]                     else if (inherits(cond, "condition")) {
[10:21:20.711]                       if (!is.null(pattern)) {
[10:21:20.711]                         computeRestarts <- base::computeRestarts
[10:21:20.711]                         grepl <- base::grepl
[10:21:20.711]                         restarts <- computeRestarts(cond)
[10:21:20.711]                         for (restart in restarts) {
[10:21:20.711]                           name <- restart$name
[10:21:20.711]                           if (is.null(name)) 
[10:21:20.711]                             next
[10:21:20.711]                           if (!grepl(pattern, name)) 
[10:21:20.711]                             next
[10:21:20.711]                           invokeRestart(restart)
[10:21:20.711]                           muffled <- TRUE
[10:21:20.711]                           break
[10:21:20.711]                         }
[10:21:20.711]                       }
[10:21:20.711]                     }
[10:21:20.711]                     invisible(muffled)
[10:21:20.711]                   }
[10:21:20.711]                   muffleCondition(cond)
[10:21:20.711]                 })
[10:21:20.711]             }))
[10:21:20.711]             future::FutureResult(value = ...future.value$value, 
[10:21:20.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.711]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.711]                     ...future.globalenv.names))
[10:21:20.711]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.711]         }, condition = base::local({
[10:21:20.711]             c <- base::c
[10:21:20.711]             inherits <- base::inherits
[10:21:20.711]             invokeRestart <- base::invokeRestart
[10:21:20.711]             length <- base::length
[10:21:20.711]             list <- base::list
[10:21:20.711]             seq.int <- base::seq.int
[10:21:20.711]             signalCondition <- base::signalCondition
[10:21:20.711]             sys.calls <- base::sys.calls
[10:21:20.711]             `[[` <- base::`[[`
[10:21:20.711]             `+` <- base::`+`
[10:21:20.711]             `<<-` <- base::`<<-`
[10:21:20.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.711]                   3L)]
[10:21:20.711]             }
[10:21:20.711]             function(cond) {
[10:21:20.711]                 is_error <- inherits(cond, "error")
[10:21:20.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.711]                   NULL)
[10:21:20.711]                 if (is_error) {
[10:21:20.711]                   sessionInformation <- function() {
[10:21:20.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.711]                       search = base::search(), system = base::Sys.info())
[10:21:20.711]                   }
[10:21:20.711]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.711]                     cond$call), session = sessionInformation(), 
[10:21:20.711]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.711]                   signalCondition(cond)
[10:21:20.711]                 }
[10:21:20.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.711]                 "immediateCondition"))) {
[10:21:20.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.711]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.711]                   if (TRUE && !signal) {
[10:21:20.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.711]                     {
[10:21:20.711]                       inherits <- base::inherits
[10:21:20.711]                       invokeRestart <- base::invokeRestart
[10:21:20.711]                       is.null <- base::is.null
[10:21:20.711]                       muffled <- FALSE
[10:21:20.711]                       if (inherits(cond, "message")) {
[10:21:20.711]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.711]                         if (muffled) 
[10:21:20.711]                           invokeRestart("muffleMessage")
[10:21:20.711]                       }
[10:21:20.711]                       else if (inherits(cond, "warning")) {
[10:21:20.711]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.711]                         if (muffled) 
[10:21:20.711]                           invokeRestart("muffleWarning")
[10:21:20.711]                       }
[10:21:20.711]                       else if (inherits(cond, "condition")) {
[10:21:20.711]                         if (!is.null(pattern)) {
[10:21:20.711]                           computeRestarts <- base::computeRestarts
[10:21:20.711]                           grepl <- base::grepl
[10:21:20.711]                           restarts <- computeRestarts(cond)
[10:21:20.711]                           for (restart in restarts) {
[10:21:20.711]                             name <- restart$name
[10:21:20.711]                             if (is.null(name)) 
[10:21:20.711]                               next
[10:21:20.711]                             if (!grepl(pattern, name)) 
[10:21:20.711]                               next
[10:21:20.711]                             invokeRestart(restart)
[10:21:20.711]                             muffled <- TRUE
[10:21:20.711]                             break
[10:21:20.711]                           }
[10:21:20.711]                         }
[10:21:20.711]                       }
[10:21:20.711]                       invisible(muffled)
[10:21:20.711]                     }
[10:21:20.711]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.711]                   }
[10:21:20.711]                 }
[10:21:20.711]                 else {
[10:21:20.711]                   if (TRUE) {
[10:21:20.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.711]                     {
[10:21:20.711]                       inherits <- base::inherits
[10:21:20.711]                       invokeRestart <- base::invokeRestart
[10:21:20.711]                       is.null <- base::is.null
[10:21:20.711]                       muffled <- FALSE
[10:21:20.711]                       if (inherits(cond, "message")) {
[10:21:20.711]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.711]                         if (muffled) 
[10:21:20.711]                           invokeRestart("muffleMessage")
[10:21:20.711]                       }
[10:21:20.711]                       else if (inherits(cond, "warning")) {
[10:21:20.711]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.711]                         if (muffled) 
[10:21:20.711]                           invokeRestart("muffleWarning")
[10:21:20.711]                       }
[10:21:20.711]                       else if (inherits(cond, "condition")) {
[10:21:20.711]                         if (!is.null(pattern)) {
[10:21:20.711]                           computeRestarts <- base::computeRestarts
[10:21:20.711]                           grepl <- base::grepl
[10:21:20.711]                           restarts <- computeRestarts(cond)
[10:21:20.711]                           for (restart in restarts) {
[10:21:20.711]                             name <- restart$name
[10:21:20.711]                             if (is.null(name)) 
[10:21:20.711]                               next
[10:21:20.711]                             if (!grepl(pattern, name)) 
[10:21:20.711]                               next
[10:21:20.711]                             invokeRestart(restart)
[10:21:20.711]                             muffled <- TRUE
[10:21:20.711]                             break
[10:21:20.711]                           }
[10:21:20.711]                         }
[10:21:20.711]                       }
[10:21:20.711]                       invisible(muffled)
[10:21:20.711]                     }
[10:21:20.711]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.711]                   }
[10:21:20.711]                 }
[10:21:20.711]             }
[10:21:20.711]         }))
[10:21:20.711]     }, error = function(ex) {
[10:21:20.711]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.711]                 ...future.rng), started = ...future.startTime, 
[10:21:20.711]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.711]             version = "1.8"), class = "FutureResult")
[10:21:20.711]     }, finally = {
[10:21:20.711]         if (!identical(...future.workdir, getwd())) 
[10:21:20.711]             setwd(...future.workdir)
[10:21:20.711]         {
[10:21:20.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.711]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.711]             }
[10:21:20.711]             base::options(...future.oldOptions)
[10:21:20.711]             if (.Platform$OS.type == "windows") {
[10:21:20.711]                 old_names <- names(...future.oldEnvVars)
[10:21:20.711]                 envs <- base::Sys.getenv()
[10:21:20.711]                 names <- names(envs)
[10:21:20.711]                 common <- intersect(names, old_names)
[10:21:20.711]                 added <- setdiff(names, old_names)
[10:21:20.711]                 removed <- setdiff(old_names, names)
[10:21:20.711]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.711]                   envs[common]]
[10:21:20.711]                 NAMES <- toupper(changed)
[10:21:20.711]                 args <- list()
[10:21:20.711]                 for (kk in seq_along(NAMES)) {
[10:21:20.711]                   name <- changed[[kk]]
[10:21:20.711]                   NAME <- NAMES[[kk]]
[10:21:20.711]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.711]                     next
[10:21:20.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.711]                 }
[10:21:20.711]                 NAMES <- toupper(added)
[10:21:20.711]                 for (kk in seq_along(NAMES)) {
[10:21:20.711]                   name <- added[[kk]]
[10:21:20.711]                   NAME <- NAMES[[kk]]
[10:21:20.711]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.711]                     next
[10:21:20.711]                   args[[name]] <- ""
[10:21:20.711]                 }
[10:21:20.711]                 NAMES <- toupper(removed)
[10:21:20.711]                 for (kk in seq_along(NAMES)) {
[10:21:20.711]                   name <- removed[[kk]]
[10:21:20.711]                   NAME <- NAMES[[kk]]
[10:21:20.711]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.711]                     next
[10:21:20.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.711]                 }
[10:21:20.711]                 if (length(args) > 0) 
[10:21:20.711]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.711]             }
[10:21:20.711]             else {
[10:21:20.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.711]             }
[10:21:20.711]             {
[10:21:20.711]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.711]                   0L) {
[10:21:20.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.711]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.711]                   base::options(opts)
[10:21:20.711]                 }
[10:21:20.711]                 {
[10:21:20.711]                   {
[10:21:20.711]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.711]                     NULL
[10:21:20.711]                   }
[10:21:20.711]                   options(future.plan = NULL)
[10:21:20.711]                   if (is.na(NA_character_)) 
[10:21:20.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.711]                     .init = FALSE)
[10:21:20.711]                 }
[10:21:20.711]             }
[10:21:20.711]         }
[10:21:20.711]     })
[10:21:20.711]     if (TRUE) {
[10:21:20.711]         base::sink(type = "output", split = FALSE)
[10:21:20.711]         if (TRUE) {
[10:21:20.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.711]         }
[10:21:20.711]         else {
[10:21:20.711]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.711]         }
[10:21:20.711]         base::close(...future.stdout)
[10:21:20.711]         ...future.stdout <- NULL
[10:21:20.711]     }
[10:21:20.711]     ...future.result$conditions <- ...future.conditions
[10:21:20.711]     ...future.result$finished <- base::Sys.time()
[10:21:20.711]     ...future.result
[10:21:20.711] }
[10:21:20.714] MultisessionFuture started
[10:21:20.714] - Launch lazy future ... done
[10:21:20.714] run() for ‘MultisessionFuture’ ... done
[10:21:20.714] getGlobalsAndPackages() ...
[10:21:20.714] Searching for globals...
[10:21:20.715] 
[10:21:20.715] Searching for globals ... DONE
[10:21:20.715] - globals: [0] <none>
[10:21:20.715] getGlobalsAndPackages() ... DONE
[10:21:20.715] run() for ‘Future’ ...
[10:21:20.715] - state: ‘created’
[10:21:20.715] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:20.731] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:20.731] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:20.731]   - Field: ‘node’
[10:21:20.731]   - Field: ‘label’
[10:21:20.731]   - Field: ‘local’
[10:21:20.731]   - Field: ‘owner’
[10:21:20.731]   - Field: ‘envir’
[10:21:20.731]   - Field: ‘workers’
[10:21:20.731]   - Field: ‘packages’
[10:21:20.731]   - Field: ‘gc’
[10:21:20.732]   - Field: ‘conditions’
[10:21:20.732]   - Field: ‘persistent’
[10:21:20.732]   - Field: ‘expr’
[10:21:20.732]   - Field: ‘uuid’
[10:21:20.732]   - Field: ‘seed’
[10:21:20.732]   - Field: ‘version’
[10:21:20.732]   - Field: ‘result’
[10:21:20.732]   - Field: ‘asynchronous’
[10:21:20.732]   - Field: ‘calls’
[10:21:20.732]   - Field: ‘globals’
[10:21:20.732]   - Field: ‘stdout’
[10:21:20.732]   - Field: ‘earlySignal’
[10:21:20.733]   - Field: ‘lazy’
[10:21:20.733]   - Field: ‘state’
[10:21:20.733] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:20.733] - Launch lazy future ...
[10:21:20.733] Packages needed by the future expression (n = 0): <none>
[10:21:20.733] Packages needed by future strategies (n = 0): <none>
[10:21:20.734] {
[10:21:20.734]     {
[10:21:20.734]         {
[10:21:20.734]             ...future.startTime <- base::Sys.time()
[10:21:20.734]             {
[10:21:20.734]                 {
[10:21:20.734]                   {
[10:21:20.734]                     {
[10:21:20.734]                       base::local({
[10:21:20.734]                         has_future <- base::requireNamespace("future", 
[10:21:20.734]                           quietly = TRUE)
[10:21:20.734]                         if (has_future) {
[10:21:20.734]                           ns <- base::getNamespace("future")
[10:21:20.734]                           version <- ns[[".package"]][["version"]]
[10:21:20.734]                           if (is.null(version)) 
[10:21:20.734]                             version <- utils::packageVersion("future")
[10:21:20.734]                         }
[10:21:20.734]                         else {
[10:21:20.734]                           version <- NULL
[10:21:20.734]                         }
[10:21:20.734]                         if (!has_future || version < "1.8.0") {
[10:21:20.734]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.734]                             "", base::R.version$version.string), 
[10:21:20.734]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.734]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.734]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.734]                               "release", "version")], collapse = " "), 
[10:21:20.734]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.734]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.734]                             info)
[10:21:20.734]                           info <- base::paste(info, collapse = "; ")
[10:21:20.734]                           if (!has_future) {
[10:21:20.734]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.734]                               info)
[10:21:20.734]                           }
[10:21:20.734]                           else {
[10:21:20.734]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.734]                               info, version)
[10:21:20.734]                           }
[10:21:20.734]                           base::stop(msg)
[10:21:20.734]                         }
[10:21:20.734]                       })
[10:21:20.734]                     }
[10:21:20.734]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.734]                     base::options(mc.cores = 1L)
[10:21:20.734]                   }
[10:21:20.734]                   ...future.strategy.old <- future::plan("list")
[10:21:20.734]                   options(future.plan = NULL)
[10:21:20.734]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.734]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.734]                 }
[10:21:20.734]                 ...future.workdir <- getwd()
[10:21:20.734]             }
[10:21:20.734]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.734]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.734]         }
[10:21:20.734]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.734]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.734]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.734]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.734]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.734]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.734]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.734]             base::names(...future.oldOptions))
[10:21:20.734]     }
[10:21:20.734]     if (FALSE) {
[10:21:20.734]     }
[10:21:20.734]     else {
[10:21:20.734]         if (TRUE) {
[10:21:20.734]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.734]                 open = "w")
[10:21:20.734]         }
[10:21:20.734]         else {
[10:21:20.734]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.734]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.734]         }
[10:21:20.734]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.734]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.734]             base::sink(type = "output", split = FALSE)
[10:21:20.734]             base::close(...future.stdout)
[10:21:20.734]         }, add = TRUE)
[10:21:20.734]     }
[10:21:20.734]     ...future.frame <- base::sys.nframe()
[10:21:20.734]     ...future.conditions <- base::list()
[10:21:20.734]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.734]     if (FALSE) {
[10:21:20.734]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.734]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.734]     }
[10:21:20.734]     ...future.result <- base::tryCatch({
[10:21:20.734]         base::withCallingHandlers({
[10:21:20.734]             ...future.value <- base::withVisible(base::local({
[10:21:20.734]                 ...future.makeSendCondition <- base::local({
[10:21:20.734]                   sendCondition <- NULL
[10:21:20.734]                   function(frame = 1L) {
[10:21:20.734]                     if (is.function(sendCondition)) 
[10:21:20.734]                       return(sendCondition)
[10:21:20.734]                     ns <- getNamespace("parallel")
[10:21:20.734]                     if (exists("sendData", mode = "function", 
[10:21:20.734]                       envir = ns)) {
[10:21:20.734]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:20.734]                         envir = ns)
[10:21:20.734]                       envir <- sys.frame(frame)
[10:21:20.734]                       master <- NULL
[10:21:20.734]                       while (!identical(envir, .GlobalEnv) && 
[10:21:20.734]                         !identical(envir, emptyenv())) {
[10:21:20.734]                         if (exists("master", mode = "list", envir = envir, 
[10:21:20.734]                           inherits = FALSE)) {
[10:21:20.734]                           master <- get("master", mode = "list", 
[10:21:20.734]                             envir = envir, inherits = FALSE)
[10:21:20.734]                           if (inherits(master, c("SOCKnode", 
[10:21:20.734]                             "SOCK0node"))) {
[10:21:20.734]                             sendCondition <<- function(cond) {
[10:21:20.734]                               data <- list(type = "VALUE", value = cond, 
[10:21:20.734]                                 success = TRUE)
[10:21:20.734]                               parallel_sendData(master, data)
[10:21:20.734]                             }
[10:21:20.734]                             return(sendCondition)
[10:21:20.734]                           }
[10:21:20.734]                         }
[10:21:20.734]                         frame <- frame + 1L
[10:21:20.734]                         envir <- sys.frame(frame)
[10:21:20.734]                       }
[10:21:20.734]                     }
[10:21:20.734]                     sendCondition <<- function(cond) NULL
[10:21:20.734]                   }
[10:21:20.734]                 })
[10:21:20.734]                 withCallingHandlers({
[10:21:20.734]                   NULL
[10:21:20.734]                 }, immediateCondition = function(cond) {
[10:21:20.734]                   sendCondition <- ...future.makeSendCondition()
[10:21:20.734]                   sendCondition(cond)
[10:21:20.734]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.734]                   {
[10:21:20.734]                     inherits <- base::inherits
[10:21:20.734]                     invokeRestart <- base::invokeRestart
[10:21:20.734]                     is.null <- base::is.null
[10:21:20.734]                     muffled <- FALSE
[10:21:20.734]                     if (inherits(cond, "message")) {
[10:21:20.734]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.734]                       if (muffled) 
[10:21:20.734]                         invokeRestart("muffleMessage")
[10:21:20.734]                     }
[10:21:20.734]                     else if (inherits(cond, "warning")) {
[10:21:20.734]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.734]                       if (muffled) 
[10:21:20.734]                         invokeRestart("muffleWarning")
[10:21:20.734]                     }
[10:21:20.734]                     else if (inherits(cond, "condition")) {
[10:21:20.734]                       if (!is.null(pattern)) {
[10:21:20.734]                         computeRestarts <- base::computeRestarts
[10:21:20.734]                         grepl <- base::grepl
[10:21:20.734]                         restarts <- computeRestarts(cond)
[10:21:20.734]                         for (restart in restarts) {
[10:21:20.734]                           name <- restart$name
[10:21:20.734]                           if (is.null(name)) 
[10:21:20.734]                             next
[10:21:20.734]                           if (!grepl(pattern, name)) 
[10:21:20.734]                             next
[10:21:20.734]                           invokeRestart(restart)
[10:21:20.734]                           muffled <- TRUE
[10:21:20.734]                           break
[10:21:20.734]                         }
[10:21:20.734]                       }
[10:21:20.734]                     }
[10:21:20.734]                     invisible(muffled)
[10:21:20.734]                   }
[10:21:20.734]                   muffleCondition(cond)
[10:21:20.734]                 })
[10:21:20.734]             }))
[10:21:20.734]             future::FutureResult(value = ...future.value$value, 
[10:21:20.734]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.734]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.734]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.734]                     ...future.globalenv.names))
[10:21:20.734]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.734]         }, condition = base::local({
[10:21:20.734]             c <- base::c
[10:21:20.734]             inherits <- base::inherits
[10:21:20.734]             invokeRestart <- base::invokeRestart
[10:21:20.734]             length <- base::length
[10:21:20.734]             list <- base::list
[10:21:20.734]             seq.int <- base::seq.int
[10:21:20.734]             signalCondition <- base::signalCondition
[10:21:20.734]             sys.calls <- base::sys.calls
[10:21:20.734]             `[[` <- base::`[[`
[10:21:20.734]             `+` <- base::`+`
[10:21:20.734]             `<<-` <- base::`<<-`
[10:21:20.734]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.734]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.734]                   3L)]
[10:21:20.734]             }
[10:21:20.734]             function(cond) {
[10:21:20.734]                 is_error <- inherits(cond, "error")
[10:21:20.734]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.734]                   NULL)
[10:21:20.734]                 if (is_error) {
[10:21:20.734]                   sessionInformation <- function() {
[10:21:20.734]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.734]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.734]                       search = base::search(), system = base::Sys.info())
[10:21:20.734]                   }
[10:21:20.734]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.734]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.734]                     cond$call), session = sessionInformation(), 
[10:21:20.734]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.734]                   signalCondition(cond)
[10:21:20.734]                 }
[10:21:20.734]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.734]                 "immediateCondition"))) {
[10:21:20.734]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.734]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.734]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.734]                   if (TRUE && !signal) {
[10:21:20.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.734]                     {
[10:21:20.734]                       inherits <- base::inherits
[10:21:20.734]                       invokeRestart <- base::invokeRestart
[10:21:20.734]                       is.null <- base::is.null
[10:21:20.734]                       muffled <- FALSE
[10:21:20.734]                       if (inherits(cond, "message")) {
[10:21:20.734]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.734]                         if (muffled) 
[10:21:20.734]                           invokeRestart("muffleMessage")
[10:21:20.734]                       }
[10:21:20.734]                       else if (inherits(cond, "warning")) {
[10:21:20.734]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.734]                         if (muffled) 
[10:21:20.734]                           invokeRestart("muffleWarning")
[10:21:20.734]                       }
[10:21:20.734]                       else if (inherits(cond, "condition")) {
[10:21:20.734]                         if (!is.null(pattern)) {
[10:21:20.734]                           computeRestarts <- base::computeRestarts
[10:21:20.734]                           grepl <- base::grepl
[10:21:20.734]                           restarts <- computeRestarts(cond)
[10:21:20.734]                           for (restart in restarts) {
[10:21:20.734]                             name <- restart$name
[10:21:20.734]                             if (is.null(name)) 
[10:21:20.734]                               next
[10:21:20.734]                             if (!grepl(pattern, name)) 
[10:21:20.734]                               next
[10:21:20.734]                             invokeRestart(restart)
[10:21:20.734]                             muffled <- TRUE
[10:21:20.734]                             break
[10:21:20.734]                           }
[10:21:20.734]                         }
[10:21:20.734]                       }
[10:21:20.734]                       invisible(muffled)
[10:21:20.734]                     }
[10:21:20.734]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.734]                   }
[10:21:20.734]                 }
[10:21:20.734]                 else {
[10:21:20.734]                   if (TRUE) {
[10:21:20.734]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.734]                     {
[10:21:20.734]                       inherits <- base::inherits
[10:21:20.734]                       invokeRestart <- base::invokeRestart
[10:21:20.734]                       is.null <- base::is.null
[10:21:20.734]                       muffled <- FALSE
[10:21:20.734]                       if (inherits(cond, "message")) {
[10:21:20.734]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.734]                         if (muffled) 
[10:21:20.734]                           invokeRestart("muffleMessage")
[10:21:20.734]                       }
[10:21:20.734]                       else if (inherits(cond, "warning")) {
[10:21:20.734]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.734]                         if (muffled) 
[10:21:20.734]                           invokeRestart("muffleWarning")
[10:21:20.734]                       }
[10:21:20.734]                       else if (inherits(cond, "condition")) {
[10:21:20.734]                         if (!is.null(pattern)) {
[10:21:20.734]                           computeRestarts <- base::computeRestarts
[10:21:20.734]                           grepl <- base::grepl
[10:21:20.734]                           restarts <- computeRestarts(cond)
[10:21:20.734]                           for (restart in restarts) {
[10:21:20.734]                             name <- restart$name
[10:21:20.734]                             if (is.null(name)) 
[10:21:20.734]                               next
[10:21:20.734]                             if (!grepl(pattern, name)) 
[10:21:20.734]                               next
[10:21:20.734]                             invokeRestart(restart)
[10:21:20.734]                             muffled <- TRUE
[10:21:20.734]                             break
[10:21:20.734]                           }
[10:21:20.734]                         }
[10:21:20.734]                       }
[10:21:20.734]                       invisible(muffled)
[10:21:20.734]                     }
[10:21:20.734]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.734]                   }
[10:21:20.734]                 }
[10:21:20.734]             }
[10:21:20.734]         }))
[10:21:20.734]     }, error = function(ex) {
[10:21:20.734]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.734]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.734]                 ...future.rng), started = ...future.startTime, 
[10:21:20.734]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.734]             version = "1.8"), class = "FutureResult")
[10:21:20.734]     }, finally = {
[10:21:20.734]         if (!identical(...future.workdir, getwd())) 
[10:21:20.734]             setwd(...future.workdir)
[10:21:20.734]         {
[10:21:20.734]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.734]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.734]             }
[10:21:20.734]             base::options(...future.oldOptions)
[10:21:20.734]             if (.Platform$OS.type == "windows") {
[10:21:20.734]                 old_names <- names(...future.oldEnvVars)
[10:21:20.734]                 envs <- base::Sys.getenv()
[10:21:20.734]                 names <- names(envs)
[10:21:20.734]                 common <- intersect(names, old_names)
[10:21:20.734]                 added <- setdiff(names, old_names)
[10:21:20.734]                 removed <- setdiff(old_names, names)
[10:21:20.734]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.734]                   envs[common]]
[10:21:20.734]                 NAMES <- toupper(changed)
[10:21:20.734]                 args <- list()
[10:21:20.734]                 for (kk in seq_along(NAMES)) {
[10:21:20.734]                   name <- changed[[kk]]
[10:21:20.734]                   NAME <- NAMES[[kk]]
[10:21:20.734]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.734]                     next
[10:21:20.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.734]                 }
[10:21:20.734]                 NAMES <- toupper(added)
[10:21:20.734]                 for (kk in seq_along(NAMES)) {
[10:21:20.734]                   name <- added[[kk]]
[10:21:20.734]                   NAME <- NAMES[[kk]]
[10:21:20.734]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.734]                     next
[10:21:20.734]                   args[[name]] <- ""
[10:21:20.734]                 }
[10:21:20.734]                 NAMES <- toupper(removed)
[10:21:20.734]                 for (kk in seq_along(NAMES)) {
[10:21:20.734]                   name <- removed[[kk]]
[10:21:20.734]                   NAME <- NAMES[[kk]]
[10:21:20.734]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.734]                     next
[10:21:20.734]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.734]                 }
[10:21:20.734]                 if (length(args) > 0) 
[10:21:20.734]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.734]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.734]             }
[10:21:20.734]             else {
[10:21:20.734]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.734]             }
[10:21:20.734]             {
[10:21:20.734]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.734]                   0L) {
[10:21:20.734]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.734]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.734]                   base::options(opts)
[10:21:20.734]                 }
[10:21:20.734]                 {
[10:21:20.734]                   {
[10:21:20.734]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.734]                     NULL
[10:21:20.734]                   }
[10:21:20.734]                   options(future.plan = NULL)
[10:21:20.734]                   if (is.na(NA_character_)) 
[10:21:20.734]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.734]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.734]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.734]                     .init = FALSE)
[10:21:20.734]                 }
[10:21:20.734]             }
[10:21:20.734]         }
[10:21:20.734]     })
[10:21:20.734]     if (TRUE) {
[10:21:20.734]         base::sink(type = "output", split = FALSE)
[10:21:20.734]         if (TRUE) {
[10:21:20.734]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.734]         }
[10:21:20.734]         else {
[10:21:20.734]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.734]         }
[10:21:20.734]         base::close(...future.stdout)
[10:21:20.734]         ...future.stdout <- NULL
[10:21:20.734]     }
[10:21:20.734]     ...future.result$conditions <- ...future.conditions
[10:21:20.734]     ...future.result$finished <- base::Sys.time()
[10:21:20.734]     ...future.result
[10:21:20.734] }
[10:21:20.788] MultisessionFuture started
[10:21:20.788] - Launch lazy future ... done
[10:21:20.788] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e4ee5c30> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e3302148> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e4ee5c30> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e3302148> 
 $  : NULL
 $  : NULL
 $  : num 6
[10:21:20.797] receiveMessageFromWorker() for ClusterFuture ...
[10:21:20.797] - Validating connection of MultisessionFuture
[10:21:20.797] - received message: FutureResult
[10:21:20.797] - Received FutureResult
[10:21:20.798] - Erased future from FutureRegistry
[10:21:20.798] result() for ClusterFuture ...
[10:21:20.798] - result already collected: FutureResult
[10:21:20.798] result() for ClusterFuture ... done
[10:21:20.798] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:20.810] resolve() on list ...
[10:21:20.810]  recursive: 0
[10:21:20.811]  length: 6
[10:21:20.811]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:20.811] signalConditionsASAP(numeric, pos=1) ...
[10:21:20.811] - nx: 6
[10:21:20.811] - relay: TRUE
[10:21:20.812] - stdout: TRUE
[10:21:20.812] - signal: TRUE
[10:21:20.812] - resignal: FALSE
[10:21:20.812] - force: TRUE
[10:21:20.812] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.812] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.813]  - until=2
[10:21:20.813]  - relaying element #2
[10:21:20.813] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.813] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.813] signalConditionsASAP(NULL, pos=1) ... done
[10:21:20.814]  length: 5 (resolved future 1)
[10:21:20.814] Future #2
[10:21:20.814] result() for ClusterFuture ...
[10:21:20.814] - result already collected: FutureResult
[10:21:20.814] result() for ClusterFuture ... done
[10:21:20.815] result() for ClusterFuture ...
[10:21:20.815] - result already collected: FutureResult
[10:21:20.815] result() for ClusterFuture ... done
[10:21:20.815] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:20.815] - nx: 6
[10:21:20.816] - relay: TRUE
[10:21:20.816] - stdout: TRUE
[10:21:20.816] - signal: TRUE
[10:21:20.816] - resignal: FALSE
[10:21:20.816] - force: TRUE
[10:21:20.816] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.817] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.817]  - until=2
[10:21:20.817]  - relaying element #2
[10:21:20.817] result() for ClusterFuture ...
[10:21:20.817] - result already collected: FutureResult
[10:21:20.818] result() for ClusterFuture ... done
[10:21:20.818] result() for ClusterFuture ...
[10:21:20.818] - result already collected: FutureResult
[10:21:20.818] result() for ClusterFuture ... done
[10:21:20.818] result() for ClusterFuture ...
[10:21:20.818] - result already collected: FutureResult
[10:21:20.818] result() for ClusterFuture ... done
[10:21:20.818] result() for ClusterFuture ...
[10:21:20.819] - result already collected: FutureResult
[10:21:20.819] result() for ClusterFuture ... done
[10:21:20.819] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.819] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.819] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:20.819]  length: 4 (resolved future 2)
[10:21:20.828] receiveMessageFromWorker() for ClusterFuture ...
[10:21:20.828] - Validating connection of MultisessionFuture
[10:21:20.829] - received message: FutureResult
[10:21:20.829] - Received FutureResult
[10:21:20.829] - Erased future from FutureRegistry
[10:21:20.829] result() for ClusterFuture ...
[10:21:20.829] - result already collected: FutureResult
[10:21:20.829] result() for ClusterFuture ... done
[10:21:20.829] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:20.830] Future #3
[10:21:20.830] result() for ClusterFuture ...
[10:21:20.830] - result already collected: FutureResult
[10:21:20.830] result() for ClusterFuture ... done
[10:21:20.830] result() for ClusterFuture ...
[10:21:20.830] - result already collected: FutureResult
[10:21:20.830] result() for ClusterFuture ... done
[10:21:20.830] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:20.830] - nx: 6
[10:21:20.831] - relay: TRUE
[10:21:20.831] - stdout: TRUE
[10:21:20.831] - signal: TRUE
[10:21:20.831] - resignal: FALSE
[10:21:20.831] - force: TRUE
[10:21:20.831] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.831] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.831]  - until=3
[10:21:20.831]  - relaying element #3
[10:21:20.831] result() for ClusterFuture ...
[10:21:20.832] - result already collected: FutureResult
[10:21:20.832] result() for ClusterFuture ... done
[10:21:20.832] result() for ClusterFuture ...
[10:21:20.832] - result already collected: FutureResult
[10:21:20.832] result() for ClusterFuture ... done
[10:21:20.832] result() for ClusterFuture ...
[10:21:20.832] - result already collected: FutureResult
[10:21:20.832] result() for ClusterFuture ... done
[10:21:20.832] result() for ClusterFuture ...
[10:21:20.833] - result already collected: FutureResult
[10:21:20.833] result() for ClusterFuture ... done
[10:21:20.833] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.833] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.833] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:20.833]  length: 3 (resolved future 3)
[10:21:20.833] signalConditionsASAP(NULL, pos=4) ...
[10:21:20.833] - nx: 6
[10:21:20.833] - relay: TRUE
[10:21:20.833] - stdout: TRUE
[10:21:20.834] - signal: TRUE
[10:21:20.834] - resignal: FALSE
[10:21:20.834] - force: TRUE
[10:21:20.834] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.834] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.834]  - until=5
[10:21:20.834]  - relaying element #5
[10:21:20.834] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:20.834] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.834] signalConditionsASAP(NULL, pos=4) ... done
[10:21:20.835]  length: 2 (resolved future 4)
[10:21:20.835] signalConditionsASAP(NULL, pos=5) ...
[10:21:20.835] - nx: 6
[10:21:20.835] - relay: TRUE
[10:21:20.835] - stdout: TRUE
[10:21:20.835] - signal: TRUE
[10:21:20.835] - resignal: FALSE
[10:21:20.835] - force: TRUE
[10:21:20.835] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:20.835] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.836]  - until=6
[10:21:20.836]  - relaying element #6
[10:21:20.836] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:20.836] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.836] signalConditionsASAP(NULL, pos=5) ... done
[10:21:20.836]  length: 1 (resolved future 5)
[10:21:20.836] signalConditionsASAP(numeric, pos=6) ...
[10:21:20.836] - nx: 6
[10:21:20.836] - relay: TRUE
[10:21:20.836] - stdout: TRUE
[10:21:20.837] - signal: TRUE
[10:21:20.837] - resignal: FALSE
[10:21:20.837] - force: TRUE
[10:21:20.837] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:20.837] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.837]  - until=6
[10:21:20.837] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.837] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.837] signalConditionsASAP(numeric, pos=6) ... done
[10:21:20.837]  length: 0 (resolved future 6)
[10:21:20.838] Relaying remaining futures
[10:21:20.838] signalConditionsASAP(NULL, pos=0) ...
[10:21:20.838] - nx: 6
[10:21:20.838] - relay: TRUE
[10:21:20.838] - stdout: TRUE
[10:21:20.838] - signal: TRUE
[10:21:20.838] - resignal: FALSE
[10:21:20.838] - force: TRUE
[10:21:20.838] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.838] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:20.839] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.839] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.839] signalConditionsASAP(NULL, pos=0) ... done
[10:21:20.839] resolve() on list ... DONE
[10:21:20.839] result() for ClusterFuture ...
[10:21:20.839] - result already collected: FutureResult
[10:21:20.839] result() for ClusterFuture ... done
[10:21:20.839] result() for ClusterFuture ...
[10:21:20.839] - result already collected: FutureResult
[10:21:20.840] result() for ClusterFuture ... done
[10:21:20.840] result() for ClusterFuture ...
[10:21:20.840] - result already collected: FutureResult
[10:21:20.840] result() for ClusterFuture ... done
[10:21:20.840] result() for ClusterFuture ...
[10:21:20.840] - result already collected: FutureResult
[10:21:20.840] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[10:21:20.843] getGlobalsAndPackages() ...
[10:21:20.843] Searching for globals...
[10:21:20.843] 
[10:21:20.843] Searching for globals ... DONE
[10:21:20.844] - globals: [0] <none>
[10:21:20.844] getGlobalsAndPackages() ... DONE
[10:21:20.844] run() for ‘Future’ ...
[10:21:20.844] - state: ‘created’
[10:21:20.844] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:20.859] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:20.859] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:20.860]   - Field: ‘node’
[10:21:20.860]   - Field: ‘label’
[10:21:20.860]   - Field: ‘local’
[10:21:20.860]   - Field: ‘owner’
[10:21:20.860]   - Field: ‘envir’
[10:21:20.860]   - Field: ‘workers’
[10:21:20.860]   - Field: ‘packages’
[10:21:20.860]   - Field: ‘gc’
[10:21:20.860]   - Field: ‘conditions’
[10:21:20.860]   - Field: ‘persistent’
[10:21:20.861]   - Field: ‘expr’
[10:21:20.861]   - Field: ‘uuid’
[10:21:20.861]   - Field: ‘seed’
[10:21:20.861]   - Field: ‘version’
[10:21:20.861]   - Field: ‘result’
[10:21:20.861]   - Field: ‘asynchronous’
[10:21:20.861]   - Field: ‘calls’
[10:21:20.861]   - Field: ‘globals’
[10:21:20.861]   - Field: ‘stdout’
[10:21:20.861]   - Field: ‘earlySignal’
[10:21:20.862]   - Field: ‘lazy’
[10:21:20.862]   - Field: ‘state’
[10:21:20.862] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:20.862] - Launch lazy future ...
[10:21:20.862] Packages needed by the future expression (n = 0): <none>
[10:21:20.862] Packages needed by future strategies (n = 0): <none>
[10:21:20.863] {
[10:21:20.863]     {
[10:21:20.863]         {
[10:21:20.863]             ...future.startTime <- base::Sys.time()
[10:21:20.863]             {
[10:21:20.863]                 {
[10:21:20.863]                   {
[10:21:20.863]                     {
[10:21:20.863]                       base::local({
[10:21:20.863]                         has_future <- base::requireNamespace("future", 
[10:21:20.863]                           quietly = TRUE)
[10:21:20.863]                         if (has_future) {
[10:21:20.863]                           ns <- base::getNamespace("future")
[10:21:20.863]                           version <- ns[[".package"]][["version"]]
[10:21:20.863]                           if (is.null(version)) 
[10:21:20.863]                             version <- utils::packageVersion("future")
[10:21:20.863]                         }
[10:21:20.863]                         else {
[10:21:20.863]                           version <- NULL
[10:21:20.863]                         }
[10:21:20.863]                         if (!has_future || version < "1.8.0") {
[10:21:20.863]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.863]                             "", base::R.version$version.string), 
[10:21:20.863]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.863]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.863]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.863]                               "release", "version")], collapse = " "), 
[10:21:20.863]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.863]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.863]                             info)
[10:21:20.863]                           info <- base::paste(info, collapse = "; ")
[10:21:20.863]                           if (!has_future) {
[10:21:20.863]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.863]                               info)
[10:21:20.863]                           }
[10:21:20.863]                           else {
[10:21:20.863]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.863]                               info, version)
[10:21:20.863]                           }
[10:21:20.863]                           base::stop(msg)
[10:21:20.863]                         }
[10:21:20.863]                       })
[10:21:20.863]                     }
[10:21:20.863]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.863]                     base::options(mc.cores = 1L)
[10:21:20.863]                   }
[10:21:20.863]                   ...future.strategy.old <- future::plan("list")
[10:21:20.863]                   options(future.plan = NULL)
[10:21:20.863]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.863]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.863]                 }
[10:21:20.863]                 ...future.workdir <- getwd()
[10:21:20.863]             }
[10:21:20.863]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.863]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.863]         }
[10:21:20.863]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.863]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.863]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.863]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.863]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.863]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.863]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.863]             base::names(...future.oldOptions))
[10:21:20.863]     }
[10:21:20.863]     if (FALSE) {
[10:21:20.863]     }
[10:21:20.863]     else {
[10:21:20.863]         if (TRUE) {
[10:21:20.863]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.863]                 open = "w")
[10:21:20.863]         }
[10:21:20.863]         else {
[10:21:20.863]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.863]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.863]         }
[10:21:20.863]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.863]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.863]             base::sink(type = "output", split = FALSE)
[10:21:20.863]             base::close(...future.stdout)
[10:21:20.863]         }, add = TRUE)
[10:21:20.863]     }
[10:21:20.863]     ...future.frame <- base::sys.nframe()
[10:21:20.863]     ...future.conditions <- base::list()
[10:21:20.863]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.863]     if (FALSE) {
[10:21:20.863]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.863]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.863]     }
[10:21:20.863]     ...future.result <- base::tryCatch({
[10:21:20.863]         base::withCallingHandlers({
[10:21:20.863]             ...future.value <- base::withVisible(base::local({
[10:21:20.863]                 ...future.makeSendCondition <- base::local({
[10:21:20.863]                   sendCondition <- NULL
[10:21:20.863]                   function(frame = 1L) {
[10:21:20.863]                     if (is.function(sendCondition)) 
[10:21:20.863]                       return(sendCondition)
[10:21:20.863]                     ns <- getNamespace("parallel")
[10:21:20.863]                     if (exists("sendData", mode = "function", 
[10:21:20.863]                       envir = ns)) {
[10:21:20.863]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:20.863]                         envir = ns)
[10:21:20.863]                       envir <- sys.frame(frame)
[10:21:20.863]                       master <- NULL
[10:21:20.863]                       while (!identical(envir, .GlobalEnv) && 
[10:21:20.863]                         !identical(envir, emptyenv())) {
[10:21:20.863]                         if (exists("master", mode = "list", envir = envir, 
[10:21:20.863]                           inherits = FALSE)) {
[10:21:20.863]                           master <- get("master", mode = "list", 
[10:21:20.863]                             envir = envir, inherits = FALSE)
[10:21:20.863]                           if (inherits(master, c("SOCKnode", 
[10:21:20.863]                             "SOCK0node"))) {
[10:21:20.863]                             sendCondition <<- function(cond) {
[10:21:20.863]                               data <- list(type = "VALUE", value = cond, 
[10:21:20.863]                                 success = TRUE)
[10:21:20.863]                               parallel_sendData(master, data)
[10:21:20.863]                             }
[10:21:20.863]                             return(sendCondition)
[10:21:20.863]                           }
[10:21:20.863]                         }
[10:21:20.863]                         frame <- frame + 1L
[10:21:20.863]                         envir <- sys.frame(frame)
[10:21:20.863]                       }
[10:21:20.863]                     }
[10:21:20.863]                     sendCondition <<- function(cond) NULL
[10:21:20.863]                   }
[10:21:20.863]                 })
[10:21:20.863]                 withCallingHandlers({
[10:21:20.863]                   2
[10:21:20.863]                 }, immediateCondition = function(cond) {
[10:21:20.863]                   sendCondition <- ...future.makeSendCondition()
[10:21:20.863]                   sendCondition(cond)
[10:21:20.863]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.863]                   {
[10:21:20.863]                     inherits <- base::inherits
[10:21:20.863]                     invokeRestart <- base::invokeRestart
[10:21:20.863]                     is.null <- base::is.null
[10:21:20.863]                     muffled <- FALSE
[10:21:20.863]                     if (inherits(cond, "message")) {
[10:21:20.863]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.863]                       if (muffled) 
[10:21:20.863]                         invokeRestart("muffleMessage")
[10:21:20.863]                     }
[10:21:20.863]                     else if (inherits(cond, "warning")) {
[10:21:20.863]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.863]                       if (muffled) 
[10:21:20.863]                         invokeRestart("muffleWarning")
[10:21:20.863]                     }
[10:21:20.863]                     else if (inherits(cond, "condition")) {
[10:21:20.863]                       if (!is.null(pattern)) {
[10:21:20.863]                         computeRestarts <- base::computeRestarts
[10:21:20.863]                         grepl <- base::grepl
[10:21:20.863]                         restarts <- computeRestarts(cond)
[10:21:20.863]                         for (restart in restarts) {
[10:21:20.863]                           name <- restart$name
[10:21:20.863]                           if (is.null(name)) 
[10:21:20.863]                             next
[10:21:20.863]                           if (!grepl(pattern, name)) 
[10:21:20.863]                             next
[10:21:20.863]                           invokeRestart(restart)
[10:21:20.863]                           muffled <- TRUE
[10:21:20.863]                           break
[10:21:20.863]                         }
[10:21:20.863]                       }
[10:21:20.863]                     }
[10:21:20.863]                     invisible(muffled)
[10:21:20.863]                   }
[10:21:20.863]                   muffleCondition(cond)
[10:21:20.863]                 })
[10:21:20.863]             }))
[10:21:20.863]             future::FutureResult(value = ...future.value$value, 
[10:21:20.863]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.863]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.863]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.863]                     ...future.globalenv.names))
[10:21:20.863]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.863]         }, condition = base::local({
[10:21:20.863]             c <- base::c
[10:21:20.863]             inherits <- base::inherits
[10:21:20.863]             invokeRestart <- base::invokeRestart
[10:21:20.863]             length <- base::length
[10:21:20.863]             list <- base::list
[10:21:20.863]             seq.int <- base::seq.int
[10:21:20.863]             signalCondition <- base::signalCondition
[10:21:20.863]             sys.calls <- base::sys.calls
[10:21:20.863]             `[[` <- base::`[[`
[10:21:20.863]             `+` <- base::`+`
[10:21:20.863]             `<<-` <- base::`<<-`
[10:21:20.863]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.863]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.863]                   3L)]
[10:21:20.863]             }
[10:21:20.863]             function(cond) {
[10:21:20.863]                 is_error <- inherits(cond, "error")
[10:21:20.863]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.863]                   NULL)
[10:21:20.863]                 if (is_error) {
[10:21:20.863]                   sessionInformation <- function() {
[10:21:20.863]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.863]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.863]                       search = base::search(), system = base::Sys.info())
[10:21:20.863]                   }
[10:21:20.863]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.863]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.863]                     cond$call), session = sessionInformation(), 
[10:21:20.863]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.863]                   signalCondition(cond)
[10:21:20.863]                 }
[10:21:20.863]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.863]                 "immediateCondition"))) {
[10:21:20.863]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.863]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.863]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.863]                   if (TRUE && !signal) {
[10:21:20.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.863]                     {
[10:21:20.863]                       inherits <- base::inherits
[10:21:20.863]                       invokeRestart <- base::invokeRestart
[10:21:20.863]                       is.null <- base::is.null
[10:21:20.863]                       muffled <- FALSE
[10:21:20.863]                       if (inherits(cond, "message")) {
[10:21:20.863]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.863]                         if (muffled) 
[10:21:20.863]                           invokeRestart("muffleMessage")
[10:21:20.863]                       }
[10:21:20.863]                       else if (inherits(cond, "warning")) {
[10:21:20.863]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.863]                         if (muffled) 
[10:21:20.863]                           invokeRestart("muffleWarning")
[10:21:20.863]                       }
[10:21:20.863]                       else if (inherits(cond, "condition")) {
[10:21:20.863]                         if (!is.null(pattern)) {
[10:21:20.863]                           computeRestarts <- base::computeRestarts
[10:21:20.863]                           grepl <- base::grepl
[10:21:20.863]                           restarts <- computeRestarts(cond)
[10:21:20.863]                           for (restart in restarts) {
[10:21:20.863]                             name <- restart$name
[10:21:20.863]                             if (is.null(name)) 
[10:21:20.863]                               next
[10:21:20.863]                             if (!grepl(pattern, name)) 
[10:21:20.863]                               next
[10:21:20.863]                             invokeRestart(restart)
[10:21:20.863]                             muffled <- TRUE
[10:21:20.863]                             break
[10:21:20.863]                           }
[10:21:20.863]                         }
[10:21:20.863]                       }
[10:21:20.863]                       invisible(muffled)
[10:21:20.863]                     }
[10:21:20.863]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.863]                   }
[10:21:20.863]                 }
[10:21:20.863]                 else {
[10:21:20.863]                   if (TRUE) {
[10:21:20.863]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.863]                     {
[10:21:20.863]                       inherits <- base::inherits
[10:21:20.863]                       invokeRestart <- base::invokeRestart
[10:21:20.863]                       is.null <- base::is.null
[10:21:20.863]                       muffled <- FALSE
[10:21:20.863]                       if (inherits(cond, "message")) {
[10:21:20.863]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.863]                         if (muffled) 
[10:21:20.863]                           invokeRestart("muffleMessage")
[10:21:20.863]                       }
[10:21:20.863]                       else if (inherits(cond, "warning")) {
[10:21:20.863]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.863]                         if (muffled) 
[10:21:20.863]                           invokeRestart("muffleWarning")
[10:21:20.863]                       }
[10:21:20.863]                       else if (inherits(cond, "condition")) {
[10:21:20.863]                         if (!is.null(pattern)) {
[10:21:20.863]                           computeRestarts <- base::computeRestarts
[10:21:20.863]                           grepl <- base::grepl
[10:21:20.863]                           restarts <- computeRestarts(cond)
[10:21:20.863]                           for (restart in restarts) {
[10:21:20.863]                             name <- restart$name
[10:21:20.863]                             if (is.null(name)) 
[10:21:20.863]                               next
[10:21:20.863]                             if (!grepl(pattern, name)) 
[10:21:20.863]                               next
[10:21:20.863]                             invokeRestart(restart)
[10:21:20.863]                             muffled <- TRUE
[10:21:20.863]                             break
[10:21:20.863]                           }
[10:21:20.863]                         }
[10:21:20.863]                       }
[10:21:20.863]                       invisible(muffled)
[10:21:20.863]                     }
[10:21:20.863]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.863]                   }
[10:21:20.863]                 }
[10:21:20.863]             }
[10:21:20.863]         }))
[10:21:20.863]     }, error = function(ex) {
[10:21:20.863]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.863]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.863]                 ...future.rng), started = ...future.startTime, 
[10:21:20.863]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.863]             version = "1.8"), class = "FutureResult")
[10:21:20.863]     }, finally = {
[10:21:20.863]         if (!identical(...future.workdir, getwd())) 
[10:21:20.863]             setwd(...future.workdir)
[10:21:20.863]         {
[10:21:20.863]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.863]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.863]             }
[10:21:20.863]             base::options(...future.oldOptions)
[10:21:20.863]             if (.Platform$OS.type == "windows") {
[10:21:20.863]                 old_names <- names(...future.oldEnvVars)
[10:21:20.863]                 envs <- base::Sys.getenv()
[10:21:20.863]                 names <- names(envs)
[10:21:20.863]                 common <- intersect(names, old_names)
[10:21:20.863]                 added <- setdiff(names, old_names)
[10:21:20.863]                 removed <- setdiff(old_names, names)
[10:21:20.863]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.863]                   envs[common]]
[10:21:20.863]                 NAMES <- toupper(changed)
[10:21:20.863]                 args <- list()
[10:21:20.863]                 for (kk in seq_along(NAMES)) {
[10:21:20.863]                   name <- changed[[kk]]
[10:21:20.863]                   NAME <- NAMES[[kk]]
[10:21:20.863]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.863]                     next
[10:21:20.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.863]                 }
[10:21:20.863]                 NAMES <- toupper(added)
[10:21:20.863]                 for (kk in seq_along(NAMES)) {
[10:21:20.863]                   name <- added[[kk]]
[10:21:20.863]                   NAME <- NAMES[[kk]]
[10:21:20.863]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.863]                     next
[10:21:20.863]                   args[[name]] <- ""
[10:21:20.863]                 }
[10:21:20.863]                 NAMES <- toupper(removed)
[10:21:20.863]                 for (kk in seq_along(NAMES)) {
[10:21:20.863]                   name <- removed[[kk]]
[10:21:20.863]                   NAME <- NAMES[[kk]]
[10:21:20.863]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.863]                     next
[10:21:20.863]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.863]                 }
[10:21:20.863]                 if (length(args) > 0) 
[10:21:20.863]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.863]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.863]             }
[10:21:20.863]             else {
[10:21:20.863]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.863]             }
[10:21:20.863]             {
[10:21:20.863]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.863]                   0L) {
[10:21:20.863]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.863]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.863]                   base::options(opts)
[10:21:20.863]                 }
[10:21:20.863]                 {
[10:21:20.863]                   {
[10:21:20.863]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.863]                     NULL
[10:21:20.863]                   }
[10:21:20.863]                   options(future.plan = NULL)
[10:21:20.863]                   if (is.na(NA_character_)) 
[10:21:20.863]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.863]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.863]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.863]                     .init = FALSE)
[10:21:20.863]                 }
[10:21:20.863]             }
[10:21:20.863]         }
[10:21:20.863]     })
[10:21:20.863]     if (TRUE) {
[10:21:20.863]         base::sink(type = "output", split = FALSE)
[10:21:20.863]         if (TRUE) {
[10:21:20.863]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.863]         }
[10:21:20.863]         else {
[10:21:20.863]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.863]         }
[10:21:20.863]         base::close(...future.stdout)
[10:21:20.863]         ...future.stdout <- NULL
[10:21:20.863]     }
[10:21:20.863]     ...future.result$conditions <- ...future.conditions
[10:21:20.863]     ...future.result$finished <- base::Sys.time()
[10:21:20.863]     ...future.result
[10:21:20.863] }
[10:21:20.867] MultisessionFuture started
[10:21:20.867] - Launch lazy future ... done
[10:21:20.867] run() for ‘MultisessionFuture’ ... done
[10:21:20.867] getGlobalsAndPackages() ...
[10:21:20.867] Searching for globals...
[10:21:20.868] 
[10:21:20.868] Searching for globals ... DONE
[10:21:20.868] - globals: [0] <none>
[10:21:20.868] getGlobalsAndPackages() ... DONE
[10:21:20.869] run() for ‘Future’ ...
[10:21:20.869] - state: ‘created’
[10:21:20.869] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:20.885] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:20.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:20.885]   - Field: ‘node’
[10:21:20.885]   - Field: ‘label’
[10:21:20.885]   - Field: ‘local’
[10:21:20.885]   - Field: ‘owner’
[10:21:20.885]   - Field: ‘envir’
[10:21:20.885]   - Field: ‘workers’
[10:21:20.885]   - Field: ‘packages’
[10:21:20.886]   - Field: ‘gc’
[10:21:20.886]   - Field: ‘conditions’
[10:21:20.886]   - Field: ‘persistent’
[10:21:20.886]   - Field: ‘expr’
[10:21:20.886]   - Field: ‘uuid’
[10:21:20.886]   - Field: ‘seed’
[10:21:20.886]   - Field: ‘version’
[10:21:20.886]   - Field: ‘result’
[10:21:20.886]   - Field: ‘asynchronous’
[10:21:20.887]   - Field: ‘calls’
[10:21:20.887]   - Field: ‘globals’
[10:21:20.887]   - Field: ‘stdout’
[10:21:20.887]   - Field: ‘earlySignal’
[10:21:20.887]   - Field: ‘lazy’
[10:21:20.887]   - Field: ‘state’
[10:21:20.887] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:20.887] - Launch lazy future ...
[10:21:20.888] Packages needed by the future expression (n = 0): <none>
[10:21:20.888] Packages needed by future strategies (n = 0): <none>
[10:21:20.888] {
[10:21:20.888]     {
[10:21:20.888]         {
[10:21:20.888]             ...future.startTime <- base::Sys.time()
[10:21:20.888]             {
[10:21:20.888]                 {
[10:21:20.888]                   {
[10:21:20.888]                     {
[10:21:20.888]                       base::local({
[10:21:20.888]                         has_future <- base::requireNamespace("future", 
[10:21:20.888]                           quietly = TRUE)
[10:21:20.888]                         if (has_future) {
[10:21:20.888]                           ns <- base::getNamespace("future")
[10:21:20.888]                           version <- ns[[".package"]][["version"]]
[10:21:20.888]                           if (is.null(version)) 
[10:21:20.888]                             version <- utils::packageVersion("future")
[10:21:20.888]                         }
[10:21:20.888]                         else {
[10:21:20.888]                           version <- NULL
[10:21:20.888]                         }
[10:21:20.888]                         if (!has_future || version < "1.8.0") {
[10:21:20.888]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.888]                             "", base::R.version$version.string), 
[10:21:20.888]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.888]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.888]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.888]                               "release", "version")], collapse = " "), 
[10:21:20.888]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.888]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.888]                             info)
[10:21:20.888]                           info <- base::paste(info, collapse = "; ")
[10:21:20.888]                           if (!has_future) {
[10:21:20.888]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.888]                               info)
[10:21:20.888]                           }
[10:21:20.888]                           else {
[10:21:20.888]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.888]                               info, version)
[10:21:20.888]                           }
[10:21:20.888]                           base::stop(msg)
[10:21:20.888]                         }
[10:21:20.888]                       })
[10:21:20.888]                     }
[10:21:20.888]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.888]                     base::options(mc.cores = 1L)
[10:21:20.888]                   }
[10:21:20.888]                   ...future.strategy.old <- future::plan("list")
[10:21:20.888]                   options(future.plan = NULL)
[10:21:20.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.888]                 }
[10:21:20.888]                 ...future.workdir <- getwd()
[10:21:20.888]             }
[10:21:20.888]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.888]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.888]         }
[10:21:20.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.888]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.888]             base::names(...future.oldOptions))
[10:21:20.888]     }
[10:21:20.888]     if (FALSE) {
[10:21:20.888]     }
[10:21:20.888]     else {
[10:21:20.888]         if (TRUE) {
[10:21:20.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.888]                 open = "w")
[10:21:20.888]         }
[10:21:20.888]         else {
[10:21:20.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.888]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.888]         }
[10:21:20.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.888]             base::sink(type = "output", split = FALSE)
[10:21:20.888]             base::close(...future.stdout)
[10:21:20.888]         }, add = TRUE)
[10:21:20.888]     }
[10:21:20.888]     ...future.frame <- base::sys.nframe()
[10:21:20.888]     ...future.conditions <- base::list()
[10:21:20.888]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.888]     if (FALSE) {
[10:21:20.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.888]     }
[10:21:20.888]     ...future.result <- base::tryCatch({
[10:21:20.888]         base::withCallingHandlers({
[10:21:20.888]             ...future.value <- base::withVisible(base::local({
[10:21:20.888]                 ...future.makeSendCondition <- base::local({
[10:21:20.888]                   sendCondition <- NULL
[10:21:20.888]                   function(frame = 1L) {
[10:21:20.888]                     if (is.function(sendCondition)) 
[10:21:20.888]                       return(sendCondition)
[10:21:20.888]                     ns <- getNamespace("parallel")
[10:21:20.888]                     if (exists("sendData", mode = "function", 
[10:21:20.888]                       envir = ns)) {
[10:21:20.888]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:20.888]                         envir = ns)
[10:21:20.888]                       envir <- sys.frame(frame)
[10:21:20.888]                       master <- NULL
[10:21:20.888]                       while (!identical(envir, .GlobalEnv) && 
[10:21:20.888]                         !identical(envir, emptyenv())) {
[10:21:20.888]                         if (exists("master", mode = "list", envir = envir, 
[10:21:20.888]                           inherits = FALSE)) {
[10:21:20.888]                           master <- get("master", mode = "list", 
[10:21:20.888]                             envir = envir, inherits = FALSE)
[10:21:20.888]                           if (inherits(master, c("SOCKnode", 
[10:21:20.888]                             "SOCK0node"))) {
[10:21:20.888]                             sendCondition <<- function(cond) {
[10:21:20.888]                               data <- list(type = "VALUE", value = cond, 
[10:21:20.888]                                 success = TRUE)
[10:21:20.888]                               parallel_sendData(master, data)
[10:21:20.888]                             }
[10:21:20.888]                             return(sendCondition)
[10:21:20.888]                           }
[10:21:20.888]                         }
[10:21:20.888]                         frame <- frame + 1L
[10:21:20.888]                         envir <- sys.frame(frame)
[10:21:20.888]                       }
[10:21:20.888]                     }
[10:21:20.888]                     sendCondition <<- function(cond) NULL
[10:21:20.888]                   }
[10:21:20.888]                 })
[10:21:20.888]                 withCallingHandlers({
[10:21:20.888]                   NULL
[10:21:20.888]                 }, immediateCondition = function(cond) {
[10:21:20.888]                   sendCondition <- ...future.makeSendCondition()
[10:21:20.888]                   sendCondition(cond)
[10:21:20.888]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.888]                   {
[10:21:20.888]                     inherits <- base::inherits
[10:21:20.888]                     invokeRestart <- base::invokeRestart
[10:21:20.888]                     is.null <- base::is.null
[10:21:20.888]                     muffled <- FALSE
[10:21:20.888]                     if (inherits(cond, "message")) {
[10:21:20.888]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.888]                       if (muffled) 
[10:21:20.888]                         invokeRestart("muffleMessage")
[10:21:20.888]                     }
[10:21:20.888]                     else if (inherits(cond, "warning")) {
[10:21:20.888]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.888]                       if (muffled) 
[10:21:20.888]                         invokeRestart("muffleWarning")
[10:21:20.888]                     }
[10:21:20.888]                     else if (inherits(cond, "condition")) {
[10:21:20.888]                       if (!is.null(pattern)) {
[10:21:20.888]                         computeRestarts <- base::computeRestarts
[10:21:20.888]                         grepl <- base::grepl
[10:21:20.888]                         restarts <- computeRestarts(cond)
[10:21:20.888]                         for (restart in restarts) {
[10:21:20.888]                           name <- restart$name
[10:21:20.888]                           if (is.null(name)) 
[10:21:20.888]                             next
[10:21:20.888]                           if (!grepl(pattern, name)) 
[10:21:20.888]                             next
[10:21:20.888]                           invokeRestart(restart)
[10:21:20.888]                           muffled <- TRUE
[10:21:20.888]                           break
[10:21:20.888]                         }
[10:21:20.888]                       }
[10:21:20.888]                     }
[10:21:20.888]                     invisible(muffled)
[10:21:20.888]                   }
[10:21:20.888]                   muffleCondition(cond)
[10:21:20.888]                 })
[10:21:20.888]             }))
[10:21:20.888]             future::FutureResult(value = ...future.value$value, 
[10:21:20.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.888]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.888]                     ...future.globalenv.names))
[10:21:20.888]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.888]         }, condition = base::local({
[10:21:20.888]             c <- base::c
[10:21:20.888]             inherits <- base::inherits
[10:21:20.888]             invokeRestart <- base::invokeRestart
[10:21:20.888]             length <- base::length
[10:21:20.888]             list <- base::list
[10:21:20.888]             seq.int <- base::seq.int
[10:21:20.888]             signalCondition <- base::signalCondition
[10:21:20.888]             sys.calls <- base::sys.calls
[10:21:20.888]             `[[` <- base::`[[`
[10:21:20.888]             `+` <- base::`+`
[10:21:20.888]             `<<-` <- base::`<<-`
[10:21:20.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.888]                   3L)]
[10:21:20.888]             }
[10:21:20.888]             function(cond) {
[10:21:20.888]                 is_error <- inherits(cond, "error")
[10:21:20.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.888]                   NULL)
[10:21:20.888]                 if (is_error) {
[10:21:20.888]                   sessionInformation <- function() {
[10:21:20.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.888]                       search = base::search(), system = base::Sys.info())
[10:21:20.888]                   }
[10:21:20.888]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.888]                     cond$call), session = sessionInformation(), 
[10:21:20.888]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.888]                   signalCondition(cond)
[10:21:20.888]                 }
[10:21:20.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.888]                 "immediateCondition"))) {
[10:21:20.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.888]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.888]                   if (TRUE && !signal) {
[10:21:20.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.888]                     {
[10:21:20.888]                       inherits <- base::inherits
[10:21:20.888]                       invokeRestart <- base::invokeRestart
[10:21:20.888]                       is.null <- base::is.null
[10:21:20.888]                       muffled <- FALSE
[10:21:20.888]                       if (inherits(cond, "message")) {
[10:21:20.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.888]                         if (muffled) 
[10:21:20.888]                           invokeRestart("muffleMessage")
[10:21:20.888]                       }
[10:21:20.888]                       else if (inherits(cond, "warning")) {
[10:21:20.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.888]                         if (muffled) 
[10:21:20.888]                           invokeRestart("muffleWarning")
[10:21:20.888]                       }
[10:21:20.888]                       else if (inherits(cond, "condition")) {
[10:21:20.888]                         if (!is.null(pattern)) {
[10:21:20.888]                           computeRestarts <- base::computeRestarts
[10:21:20.888]                           grepl <- base::grepl
[10:21:20.888]                           restarts <- computeRestarts(cond)
[10:21:20.888]                           for (restart in restarts) {
[10:21:20.888]                             name <- restart$name
[10:21:20.888]                             if (is.null(name)) 
[10:21:20.888]                               next
[10:21:20.888]                             if (!grepl(pattern, name)) 
[10:21:20.888]                               next
[10:21:20.888]                             invokeRestart(restart)
[10:21:20.888]                             muffled <- TRUE
[10:21:20.888]                             break
[10:21:20.888]                           }
[10:21:20.888]                         }
[10:21:20.888]                       }
[10:21:20.888]                       invisible(muffled)
[10:21:20.888]                     }
[10:21:20.888]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.888]                   }
[10:21:20.888]                 }
[10:21:20.888]                 else {
[10:21:20.888]                   if (TRUE) {
[10:21:20.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.888]                     {
[10:21:20.888]                       inherits <- base::inherits
[10:21:20.888]                       invokeRestart <- base::invokeRestart
[10:21:20.888]                       is.null <- base::is.null
[10:21:20.888]                       muffled <- FALSE
[10:21:20.888]                       if (inherits(cond, "message")) {
[10:21:20.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.888]                         if (muffled) 
[10:21:20.888]                           invokeRestart("muffleMessage")
[10:21:20.888]                       }
[10:21:20.888]                       else if (inherits(cond, "warning")) {
[10:21:20.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.888]                         if (muffled) 
[10:21:20.888]                           invokeRestart("muffleWarning")
[10:21:20.888]                       }
[10:21:20.888]                       else if (inherits(cond, "condition")) {
[10:21:20.888]                         if (!is.null(pattern)) {
[10:21:20.888]                           computeRestarts <- base::computeRestarts
[10:21:20.888]                           grepl <- base::grepl
[10:21:20.888]                           restarts <- computeRestarts(cond)
[10:21:20.888]                           for (restart in restarts) {
[10:21:20.888]                             name <- restart$name
[10:21:20.888]                             if (is.null(name)) 
[10:21:20.888]                               next
[10:21:20.888]                             if (!grepl(pattern, name)) 
[10:21:20.888]                               next
[10:21:20.888]                             invokeRestart(restart)
[10:21:20.888]                             muffled <- TRUE
[10:21:20.888]                             break
[10:21:20.888]                           }
[10:21:20.888]                         }
[10:21:20.888]                       }
[10:21:20.888]                       invisible(muffled)
[10:21:20.888]                     }
[10:21:20.888]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.888]                   }
[10:21:20.888]                 }
[10:21:20.888]             }
[10:21:20.888]         }))
[10:21:20.888]     }, error = function(ex) {
[10:21:20.888]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.888]                 ...future.rng), started = ...future.startTime, 
[10:21:20.888]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.888]             version = "1.8"), class = "FutureResult")
[10:21:20.888]     }, finally = {
[10:21:20.888]         if (!identical(...future.workdir, getwd())) 
[10:21:20.888]             setwd(...future.workdir)
[10:21:20.888]         {
[10:21:20.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.888]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.888]             }
[10:21:20.888]             base::options(...future.oldOptions)
[10:21:20.888]             if (.Platform$OS.type == "windows") {
[10:21:20.888]                 old_names <- names(...future.oldEnvVars)
[10:21:20.888]                 envs <- base::Sys.getenv()
[10:21:20.888]                 names <- names(envs)
[10:21:20.888]                 common <- intersect(names, old_names)
[10:21:20.888]                 added <- setdiff(names, old_names)
[10:21:20.888]                 removed <- setdiff(old_names, names)
[10:21:20.888]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.888]                   envs[common]]
[10:21:20.888]                 NAMES <- toupper(changed)
[10:21:20.888]                 args <- list()
[10:21:20.888]                 for (kk in seq_along(NAMES)) {
[10:21:20.888]                   name <- changed[[kk]]
[10:21:20.888]                   NAME <- NAMES[[kk]]
[10:21:20.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.888]                     next
[10:21:20.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.888]                 }
[10:21:20.888]                 NAMES <- toupper(added)
[10:21:20.888]                 for (kk in seq_along(NAMES)) {
[10:21:20.888]                   name <- added[[kk]]
[10:21:20.888]                   NAME <- NAMES[[kk]]
[10:21:20.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.888]                     next
[10:21:20.888]                   args[[name]] <- ""
[10:21:20.888]                 }
[10:21:20.888]                 NAMES <- toupper(removed)
[10:21:20.888]                 for (kk in seq_along(NAMES)) {
[10:21:20.888]                   name <- removed[[kk]]
[10:21:20.888]                   NAME <- NAMES[[kk]]
[10:21:20.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.888]                     next
[10:21:20.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.888]                 }
[10:21:20.888]                 if (length(args) > 0) 
[10:21:20.888]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.888]             }
[10:21:20.888]             else {
[10:21:20.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.888]             }
[10:21:20.888]             {
[10:21:20.888]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.888]                   0L) {
[10:21:20.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.888]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.888]                   base::options(opts)
[10:21:20.888]                 }
[10:21:20.888]                 {
[10:21:20.888]                   {
[10:21:20.888]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.888]                     NULL
[10:21:20.888]                   }
[10:21:20.888]                   options(future.plan = NULL)
[10:21:20.888]                   if (is.na(NA_character_)) 
[10:21:20.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.888]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.888]                     .init = FALSE)
[10:21:20.888]                 }
[10:21:20.888]             }
[10:21:20.888]         }
[10:21:20.888]     })
[10:21:20.888]     if (TRUE) {
[10:21:20.888]         base::sink(type = "output", split = FALSE)
[10:21:20.888]         if (TRUE) {
[10:21:20.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.888]         }
[10:21:20.888]         else {
[10:21:20.888]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.888]         }
[10:21:20.888]         base::close(...future.stdout)
[10:21:20.888]         ...future.stdout <- NULL
[10:21:20.888]     }
[10:21:20.888]     ...future.result$conditions <- ...future.conditions
[10:21:20.888]     ...future.result$finished <- base::Sys.time()
[10:21:20.888]     ...future.result
[10:21:20.888] }
[10:21:20.892] MultisessionFuture started
[10:21:20.892] - Launch lazy future ... done
[10:21:20.892] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e6cfe400> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e718ba50> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e6cfe400> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e718ba50> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:20.923] resolve() on list ...
[10:21:20.923]  recursive: 0
[10:21:20.923]  length: 6
[10:21:20.923]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:20.923] signalConditionsASAP(numeric, pos=1) ...
[10:21:20.924] - nx: 6
[10:21:20.924] - relay: TRUE
[10:21:20.924] - stdout: TRUE
[10:21:20.924] - signal: TRUE
[10:21:20.924] - resignal: FALSE
[10:21:20.924] - force: TRUE
[10:21:20.924] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.924] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.924]  - until=2
[10:21:20.924]  - relaying element #2
[10:21:20.924] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.924] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.924] signalConditionsASAP(NULL, pos=1) ... done
[10:21:20.925]  length: 5 (resolved future 1)
[10:21:20.925] receiveMessageFromWorker() for ClusterFuture ...
[10:21:20.925] - Validating connection of MultisessionFuture
[10:21:20.925] - received message: FutureResult
[10:21:20.925] - Received FutureResult
[10:21:20.925] - Erased future from FutureRegistry
[10:21:20.926] result() for ClusterFuture ...
[10:21:20.926] - result already collected: FutureResult
[10:21:20.926] result() for ClusterFuture ... done
[10:21:20.926] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:20.926] Future #2
[10:21:20.926] result() for ClusterFuture ...
[10:21:20.926] - result already collected: FutureResult
[10:21:20.926] result() for ClusterFuture ... done
[10:21:20.926] result() for ClusterFuture ...
[10:21:20.926] - result already collected: FutureResult
[10:21:20.926] result() for ClusterFuture ... done
[10:21:20.926] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:20.927] - nx: 6
[10:21:20.927] - relay: TRUE
[10:21:20.927] - stdout: TRUE
[10:21:20.927] - signal: TRUE
[10:21:20.927] - resignal: FALSE
[10:21:20.927] - force: TRUE
[10:21:20.927] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.927] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:20.927]  - until=2
[10:21:20.927]  - relaying element #2
[10:21:20.927] result() for ClusterFuture ...
[10:21:20.927] - result already collected: FutureResult
[10:21:20.927] result() for ClusterFuture ... done
[10:21:20.928] result() for ClusterFuture ...
[10:21:20.928] - result already collected: FutureResult
[10:21:20.928] result() for ClusterFuture ... done
[10:21:20.928] result() for ClusterFuture ...
[10:21:20.928] - result already collected: FutureResult
[10:21:20.928] result() for ClusterFuture ... done
[10:21:20.928] result() for ClusterFuture ...
[10:21:20.928] - result already collected: FutureResult
[10:21:20.928] result() for ClusterFuture ... done
[10:21:20.928] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.928] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.928] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:20.929]  length: 4 (resolved future 2)
[10:21:20.934] receiveMessageFromWorker() for ClusterFuture ...
[10:21:20.934] - Validating connection of MultisessionFuture
[10:21:20.935] - received message: FutureResult
[10:21:20.935] - Received FutureResult
[10:21:20.935] - Erased future from FutureRegistry
[10:21:20.935] result() for ClusterFuture ...
[10:21:20.935] - result already collected: FutureResult
[10:21:20.935] result() for ClusterFuture ... done
[10:21:20.935] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:20.935] Future #3
[10:21:20.935] result() for ClusterFuture ...
[10:21:20.935] - result already collected: FutureResult
[10:21:20.936] result() for ClusterFuture ... done
[10:21:20.936] result() for ClusterFuture ...
[10:21:20.936] - result already collected: FutureResult
[10:21:20.936] result() for ClusterFuture ... done
[10:21:20.936] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:20.936] - nx: 6
[10:21:20.936] - relay: TRUE
[10:21:20.936] - stdout: TRUE
[10:21:20.936] - signal: TRUE
[10:21:20.936] - resignal: FALSE
[10:21:20.936] - force: TRUE
[10:21:20.936] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.936] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:20.937]  - until=3
[10:21:20.937]  - relaying element #3
[10:21:20.937] result() for ClusterFuture ...
[10:21:20.937] - result already collected: FutureResult
[10:21:20.937] result() for ClusterFuture ... done
[10:21:20.937] result() for ClusterFuture ...
[10:21:20.937] - result already collected: FutureResult
[10:21:20.937] result() for ClusterFuture ... done
[10:21:20.937] result() for ClusterFuture ...
[10:21:20.937] - result already collected: FutureResult
[10:21:20.937] result() for ClusterFuture ... done
[10:21:20.937] result() for ClusterFuture ...
[10:21:20.938] - result already collected: FutureResult
[10:21:20.938] result() for ClusterFuture ... done
[10:21:20.938] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.938] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.938] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:20.938]  length: 3 (resolved future 3)
[10:21:20.938] signalConditionsASAP(NULL, pos=4) ...
[10:21:20.938] - nx: 6
[10:21:20.938] - relay: TRUE
[10:21:20.938] - stdout: TRUE
[10:21:20.938] - signal: TRUE
[10:21:20.938] - resignal: FALSE
[10:21:20.938] - force: TRUE
[10:21:20.939] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.939] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.939]  - until=5
[10:21:20.939]  - relaying element #5
[10:21:20.939] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:20.939] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.939] signalConditionsASAP(NULL, pos=4) ... done
[10:21:20.939]  length: 2 (resolved future 4)
[10:21:20.939] signalConditionsASAP(NULL, pos=5) ...
[10:21:20.939] - nx: 6
[10:21:20.939] - relay: TRUE
[10:21:20.939] - stdout: TRUE
[10:21:20.939] - signal: TRUE
[10:21:20.940] - resignal: FALSE
[10:21:20.940] - force: TRUE
[10:21:20.940] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:20.940] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.940]  - until=6
[10:21:20.940]  - relaying element #6
[10:21:20.940] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:20.940] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.940] signalConditionsASAP(NULL, pos=5) ... done
[10:21:20.940]  length: 1 (resolved future 5)
[10:21:20.940] signalConditionsASAP(numeric, pos=6) ...
[10:21:20.940] - nx: 6
[10:21:20.940] - relay: TRUE
[10:21:20.941] - stdout: TRUE
[10:21:20.941] - signal: TRUE
[10:21:20.941] - resignal: FALSE
[10:21:20.941] - force: TRUE
[10:21:20.941] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:20.941] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.941]  - until=6
[10:21:20.941] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.941] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.941] signalConditionsASAP(numeric, pos=6) ... done
[10:21:20.941]  length: 0 (resolved future 6)
[10:21:20.941] Relaying remaining futures
[10:21:20.941] signalConditionsASAP(NULL, pos=0) ...
[10:21:20.942] - nx: 6
[10:21:20.942] - relay: TRUE
[10:21:20.942] - stdout: TRUE
[10:21:20.942] - signal: TRUE
[10:21:20.942] - resignal: FALSE
[10:21:20.942] - force: TRUE
[10:21:20.942] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.942] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:20.942] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:20.942] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:20.942] signalConditionsASAP(NULL, pos=0) ... done
[10:21:20.942] resolve() on list ... DONE
[10:21:20.943] result() for ClusterFuture ...
[10:21:20.943] - result already collected: FutureResult
[10:21:20.943] result() for ClusterFuture ... done
[10:21:20.943] result() for ClusterFuture ...
[10:21:20.943] - result already collected: FutureResult
[10:21:20.943] result() for ClusterFuture ... done
[10:21:20.943] result() for ClusterFuture ...
[10:21:20.943] - result already collected: FutureResult
[10:21:20.943] result() for ClusterFuture ... done
[10:21:20.943] result() for ClusterFuture ...
[10:21:20.943] - result already collected: FutureResult
[10:21:20.943] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:21:20.946] getGlobalsAndPackages() ...
[10:21:20.947] Searching for globals...
[10:21:20.947] 
[10:21:20.947] Searching for globals ... DONE
[10:21:20.947] - globals: [0] <none>
[10:21:20.947] getGlobalsAndPackages() ... DONE
[10:21:20.947] run() for ‘Future’ ...
[10:21:20.947] - state: ‘created’
[10:21:20.948] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:20.963] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:20.963] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:20.963]   - Field: ‘node’
[10:21:20.963]   - Field: ‘label’
[10:21:20.963]   - Field: ‘local’
[10:21:20.963]   - Field: ‘owner’
[10:21:20.963]   - Field: ‘envir’
[10:21:20.963]   - Field: ‘workers’
[10:21:20.963]   - Field: ‘packages’
[10:21:20.964]   - Field: ‘gc’
[10:21:20.964]   - Field: ‘conditions’
[10:21:20.964]   - Field: ‘persistent’
[10:21:20.964]   - Field: ‘expr’
[10:21:20.964]   - Field: ‘uuid’
[10:21:20.964]   - Field: ‘seed’
[10:21:20.964]   - Field: ‘version’
[10:21:20.964]   - Field: ‘result’
[10:21:20.964]   - Field: ‘asynchronous’
[10:21:20.964]   - Field: ‘calls’
[10:21:20.964]   - Field: ‘globals’
[10:21:20.964]   - Field: ‘stdout’
[10:21:20.965]   - Field: ‘earlySignal’
[10:21:20.965]   - Field: ‘lazy’
[10:21:20.965]   - Field: ‘state’
[10:21:20.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:20.965] - Launch lazy future ...
[10:21:20.965] Packages needed by the future expression (n = 0): <none>
[10:21:20.965] Packages needed by future strategies (n = 0): <none>
[10:21:20.966] {
[10:21:20.966]     {
[10:21:20.966]         {
[10:21:20.966]             ...future.startTime <- base::Sys.time()
[10:21:20.966]             {
[10:21:20.966]                 {
[10:21:20.966]                   {
[10:21:20.966]                     {
[10:21:20.966]                       base::local({
[10:21:20.966]                         has_future <- base::requireNamespace("future", 
[10:21:20.966]                           quietly = TRUE)
[10:21:20.966]                         if (has_future) {
[10:21:20.966]                           ns <- base::getNamespace("future")
[10:21:20.966]                           version <- ns[[".package"]][["version"]]
[10:21:20.966]                           if (is.null(version)) 
[10:21:20.966]                             version <- utils::packageVersion("future")
[10:21:20.966]                         }
[10:21:20.966]                         else {
[10:21:20.966]                           version <- NULL
[10:21:20.966]                         }
[10:21:20.966]                         if (!has_future || version < "1.8.0") {
[10:21:20.966]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.966]                             "", base::R.version$version.string), 
[10:21:20.966]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.966]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.966]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.966]                               "release", "version")], collapse = " "), 
[10:21:20.966]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.966]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.966]                             info)
[10:21:20.966]                           info <- base::paste(info, collapse = "; ")
[10:21:20.966]                           if (!has_future) {
[10:21:20.966]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.966]                               info)
[10:21:20.966]                           }
[10:21:20.966]                           else {
[10:21:20.966]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.966]                               info, version)
[10:21:20.966]                           }
[10:21:20.966]                           base::stop(msg)
[10:21:20.966]                         }
[10:21:20.966]                       })
[10:21:20.966]                     }
[10:21:20.966]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.966]                     base::options(mc.cores = 1L)
[10:21:20.966]                   }
[10:21:20.966]                   ...future.strategy.old <- future::plan("list")
[10:21:20.966]                   options(future.plan = NULL)
[10:21:20.966]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.966]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.966]                 }
[10:21:20.966]                 ...future.workdir <- getwd()
[10:21:20.966]             }
[10:21:20.966]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.966]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.966]         }
[10:21:20.966]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.966]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.966]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.966]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.966]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.966]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.966]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.966]             base::names(...future.oldOptions))
[10:21:20.966]     }
[10:21:20.966]     if (FALSE) {
[10:21:20.966]     }
[10:21:20.966]     else {
[10:21:20.966]         if (TRUE) {
[10:21:20.966]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.966]                 open = "w")
[10:21:20.966]         }
[10:21:20.966]         else {
[10:21:20.966]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.966]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.966]         }
[10:21:20.966]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.966]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.966]             base::sink(type = "output", split = FALSE)
[10:21:20.966]             base::close(...future.stdout)
[10:21:20.966]         }, add = TRUE)
[10:21:20.966]     }
[10:21:20.966]     ...future.frame <- base::sys.nframe()
[10:21:20.966]     ...future.conditions <- base::list()
[10:21:20.966]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.966]     if (FALSE) {
[10:21:20.966]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.966]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.966]     }
[10:21:20.966]     ...future.result <- base::tryCatch({
[10:21:20.966]         base::withCallingHandlers({
[10:21:20.966]             ...future.value <- base::withVisible(base::local({
[10:21:20.966]                 ...future.makeSendCondition <- base::local({
[10:21:20.966]                   sendCondition <- NULL
[10:21:20.966]                   function(frame = 1L) {
[10:21:20.966]                     if (is.function(sendCondition)) 
[10:21:20.966]                       return(sendCondition)
[10:21:20.966]                     ns <- getNamespace("parallel")
[10:21:20.966]                     if (exists("sendData", mode = "function", 
[10:21:20.966]                       envir = ns)) {
[10:21:20.966]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:20.966]                         envir = ns)
[10:21:20.966]                       envir <- sys.frame(frame)
[10:21:20.966]                       master <- NULL
[10:21:20.966]                       while (!identical(envir, .GlobalEnv) && 
[10:21:20.966]                         !identical(envir, emptyenv())) {
[10:21:20.966]                         if (exists("master", mode = "list", envir = envir, 
[10:21:20.966]                           inherits = FALSE)) {
[10:21:20.966]                           master <- get("master", mode = "list", 
[10:21:20.966]                             envir = envir, inherits = FALSE)
[10:21:20.966]                           if (inherits(master, c("SOCKnode", 
[10:21:20.966]                             "SOCK0node"))) {
[10:21:20.966]                             sendCondition <<- function(cond) {
[10:21:20.966]                               data <- list(type = "VALUE", value = cond, 
[10:21:20.966]                                 success = TRUE)
[10:21:20.966]                               parallel_sendData(master, data)
[10:21:20.966]                             }
[10:21:20.966]                             return(sendCondition)
[10:21:20.966]                           }
[10:21:20.966]                         }
[10:21:20.966]                         frame <- frame + 1L
[10:21:20.966]                         envir <- sys.frame(frame)
[10:21:20.966]                       }
[10:21:20.966]                     }
[10:21:20.966]                     sendCondition <<- function(cond) NULL
[10:21:20.966]                   }
[10:21:20.966]                 })
[10:21:20.966]                 withCallingHandlers({
[10:21:20.966]                   2
[10:21:20.966]                 }, immediateCondition = function(cond) {
[10:21:20.966]                   sendCondition <- ...future.makeSendCondition()
[10:21:20.966]                   sendCondition(cond)
[10:21:20.966]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.966]                   {
[10:21:20.966]                     inherits <- base::inherits
[10:21:20.966]                     invokeRestart <- base::invokeRestart
[10:21:20.966]                     is.null <- base::is.null
[10:21:20.966]                     muffled <- FALSE
[10:21:20.966]                     if (inherits(cond, "message")) {
[10:21:20.966]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.966]                       if (muffled) 
[10:21:20.966]                         invokeRestart("muffleMessage")
[10:21:20.966]                     }
[10:21:20.966]                     else if (inherits(cond, "warning")) {
[10:21:20.966]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.966]                       if (muffled) 
[10:21:20.966]                         invokeRestart("muffleWarning")
[10:21:20.966]                     }
[10:21:20.966]                     else if (inherits(cond, "condition")) {
[10:21:20.966]                       if (!is.null(pattern)) {
[10:21:20.966]                         computeRestarts <- base::computeRestarts
[10:21:20.966]                         grepl <- base::grepl
[10:21:20.966]                         restarts <- computeRestarts(cond)
[10:21:20.966]                         for (restart in restarts) {
[10:21:20.966]                           name <- restart$name
[10:21:20.966]                           if (is.null(name)) 
[10:21:20.966]                             next
[10:21:20.966]                           if (!grepl(pattern, name)) 
[10:21:20.966]                             next
[10:21:20.966]                           invokeRestart(restart)
[10:21:20.966]                           muffled <- TRUE
[10:21:20.966]                           break
[10:21:20.966]                         }
[10:21:20.966]                       }
[10:21:20.966]                     }
[10:21:20.966]                     invisible(muffled)
[10:21:20.966]                   }
[10:21:20.966]                   muffleCondition(cond)
[10:21:20.966]                 })
[10:21:20.966]             }))
[10:21:20.966]             future::FutureResult(value = ...future.value$value, 
[10:21:20.966]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.966]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.966]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.966]                     ...future.globalenv.names))
[10:21:20.966]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.966]         }, condition = base::local({
[10:21:20.966]             c <- base::c
[10:21:20.966]             inherits <- base::inherits
[10:21:20.966]             invokeRestart <- base::invokeRestart
[10:21:20.966]             length <- base::length
[10:21:20.966]             list <- base::list
[10:21:20.966]             seq.int <- base::seq.int
[10:21:20.966]             signalCondition <- base::signalCondition
[10:21:20.966]             sys.calls <- base::sys.calls
[10:21:20.966]             `[[` <- base::`[[`
[10:21:20.966]             `+` <- base::`+`
[10:21:20.966]             `<<-` <- base::`<<-`
[10:21:20.966]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.966]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.966]                   3L)]
[10:21:20.966]             }
[10:21:20.966]             function(cond) {
[10:21:20.966]                 is_error <- inherits(cond, "error")
[10:21:20.966]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.966]                   NULL)
[10:21:20.966]                 if (is_error) {
[10:21:20.966]                   sessionInformation <- function() {
[10:21:20.966]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.966]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.966]                       search = base::search(), system = base::Sys.info())
[10:21:20.966]                   }
[10:21:20.966]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.966]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.966]                     cond$call), session = sessionInformation(), 
[10:21:20.966]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.966]                   signalCondition(cond)
[10:21:20.966]                 }
[10:21:20.966]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.966]                 "immediateCondition"))) {
[10:21:20.966]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.966]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.966]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.966]                   if (TRUE && !signal) {
[10:21:20.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.966]                     {
[10:21:20.966]                       inherits <- base::inherits
[10:21:20.966]                       invokeRestart <- base::invokeRestart
[10:21:20.966]                       is.null <- base::is.null
[10:21:20.966]                       muffled <- FALSE
[10:21:20.966]                       if (inherits(cond, "message")) {
[10:21:20.966]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.966]                         if (muffled) 
[10:21:20.966]                           invokeRestart("muffleMessage")
[10:21:20.966]                       }
[10:21:20.966]                       else if (inherits(cond, "warning")) {
[10:21:20.966]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.966]                         if (muffled) 
[10:21:20.966]                           invokeRestart("muffleWarning")
[10:21:20.966]                       }
[10:21:20.966]                       else if (inherits(cond, "condition")) {
[10:21:20.966]                         if (!is.null(pattern)) {
[10:21:20.966]                           computeRestarts <- base::computeRestarts
[10:21:20.966]                           grepl <- base::grepl
[10:21:20.966]                           restarts <- computeRestarts(cond)
[10:21:20.966]                           for (restart in restarts) {
[10:21:20.966]                             name <- restart$name
[10:21:20.966]                             if (is.null(name)) 
[10:21:20.966]                               next
[10:21:20.966]                             if (!grepl(pattern, name)) 
[10:21:20.966]                               next
[10:21:20.966]                             invokeRestart(restart)
[10:21:20.966]                             muffled <- TRUE
[10:21:20.966]                             break
[10:21:20.966]                           }
[10:21:20.966]                         }
[10:21:20.966]                       }
[10:21:20.966]                       invisible(muffled)
[10:21:20.966]                     }
[10:21:20.966]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.966]                   }
[10:21:20.966]                 }
[10:21:20.966]                 else {
[10:21:20.966]                   if (TRUE) {
[10:21:20.966]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.966]                     {
[10:21:20.966]                       inherits <- base::inherits
[10:21:20.966]                       invokeRestart <- base::invokeRestart
[10:21:20.966]                       is.null <- base::is.null
[10:21:20.966]                       muffled <- FALSE
[10:21:20.966]                       if (inherits(cond, "message")) {
[10:21:20.966]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.966]                         if (muffled) 
[10:21:20.966]                           invokeRestart("muffleMessage")
[10:21:20.966]                       }
[10:21:20.966]                       else if (inherits(cond, "warning")) {
[10:21:20.966]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.966]                         if (muffled) 
[10:21:20.966]                           invokeRestart("muffleWarning")
[10:21:20.966]                       }
[10:21:20.966]                       else if (inherits(cond, "condition")) {
[10:21:20.966]                         if (!is.null(pattern)) {
[10:21:20.966]                           computeRestarts <- base::computeRestarts
[10:21:20.966]                           grepl <- base::grepl
[10:21:20.966]                           restarts <- computeRestarts(cond)
[10:21:20.966]                           for (restart in restarts) {
[10:21:20.966]                             name <- restart$name
[10:21:20.966]                             if (is.null(name)) 
[10:21:20.966]                               next
[10:21:20.966]                             if (!grepl(pattern, name)) 
[10:21:20.966]                               next
[10:21:20.966]                             invokeRestart(restart)
[10:21:20.966]                             muffled <- TRUE
[10:21:20.966]                             break
[10:21:20.966]                           }
[10:21:20.966]                         }
[10:21:20.966]                       }
[10:21:20.966]                       invisible(muffled)
[10:21:20.966]                     }
[10:21:20.966]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.966]                   }
[10:21:20.966]                 }
[10:21:20.966]             }
[10:21:20.966]         }))
[10:21:20.966]     }, error = function(ex) {
[10:21:20.966]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.966]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.966]                 ...future.rng), started = ...future.startTime, 
[10:21:20.966]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.966]             version = "1.8"), class = "FutureResult")
[10:21:20.966]     }, finally = {
[10:21:20.966]         if (!identical(...future.workdir, getwd())) 
[10:21:20.966]             setwd(...future.workdir)
[10:21:20.966]         {
[10:21:20.966]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.966]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.966]             }
[10:21:20.966]             base::options(...future.oldOptions)
[10:21:20.966]             if (.Platform$OS.type == "windows") {
[10:21:20.966]                 old_names <- names(...future.oldEnvVars)
[10:21:20.966]                 envs <- base::Sys.getenv()
[10:21:20.966]                 names <- names(envs)
[10:21:20.966]                 common <- intersect(names, old_names)
[10:21:20.966]                 added <- setdiff(names, old_names)
[10:21:20.966]                 removed <- setdiff(old_names, names)
[10:21:20.966]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.966]                   envs[common]]
[10:21:20.966]                 NAMES <- toupper(changed)
[10:21:20.966]                 args <- list()
[10:21:20.966]                 for (kk in seq_along(NAMES)) {
[10:21:20.966]                   name <- changed[[kk]]
[10:21:20.966]                   NAME <- NAMES[[kk]]
[10:21:20.966]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.966]                     next
[10:21:20.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.966]                 }
[10:21:20.966]                 NAMES <- toupper(added)
[10:21:20.966]                 for (kk in seq_along(NAMES)) {
[10:21:20.966]                   name <- added[[kk]]
[10:21:20.966]                   NAME <- NAMES[[kk]]
[10:21:20.966]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.966]                     next
[10:21:20.966]                   args[[name]] <- ""
[10:21:20.966]                 }
[10:21:20.966]                 NAMES <- toupper(removed)
[10:21:20.966]                 for (kk in seq_along(NAMES)) {
[10:21:20.966]                   name <- removed[[kk]]
[10:21:20.966]                   NAME <- NAMES[[kk]]
[10:21:20.966]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.966]                     next
[10:21:20.966]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.966]                 }
[10:21:20.966]                 if (length(args) > 0) 
[10:21:20.966]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.966]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.966]             }
[10:21:20.966]             else {
[10:21:20.966]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.966]             }
[10:21:20.966]             {
[10:21:20.966]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.966]                   0L) {
[10:21:20.966]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.966]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.966]                   base::options(opts)
[10:21:20.966]                 }
[10:21:20.966]                 {
[10:21:20.966]                   {
[10:21:20.966]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.966]                     NULL
[10:21:20.966]                   }
[10:21:20.966]                   options(future.plan = NULL)
[10:21:20.966]                   if (is.na(NA_character_)) 
[10:21:20.966]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.966]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.966]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.966]                     .init = FALSE)
[10:21:20.966]                 }
[10:21:20.966]             }
[10:21:20.966]         }
[10:21:20.966]     })
[10:21:20.966]     if (TRUE) {
[10:21:20.966]         base::sink(type = "output", split = FALSE)
[10:21:20.966]         if (TRUE) {
[10:21:20.966]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.966]         }
[10:21:20.966]         else {
[10:21:20.966]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.966]         }
[10:21:20.966]         base::close(...future.stdout)
[10:21:20.966]         ...future.stdout <- NULL
[10:21:20.966]     }
[10:21:20.966]     ...future.result$conditions <- ...future.conditions
[10:21:20.966]     ...future.result$finished <- base::Sys.time()
[10:21:20.966]     ...future.result
[10:21:20.966] }
[10:21:20.969] MultisessionFuture started
[10:21:20.969] - Launch lazy future ... done
[10:21:20.969] run() for ‘MultisessionFuture’ ... done
[10:21:20.969] getGlobalsAndPackages() ...
[10:21:20.969] Searching for globals...
[10:21:20.970] 
[10:21:20.970] Searching for globals ... DONE
[10:21:20.970] - globals: [0] <none>
[10:21:20.970] getGlobalsAndPackages() ... DONE
[10:21:20.970] run() for ‘Future’ ...
[10:21:20.970] - state: ‘created’
[10:21:20.970] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:20.984] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:20.984] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:20.984]   - Field: ‘node’
[10:21:20.984]   - Field: ‘label’
[10:21:20.984]   - Field: ‘local’
[10:21:20.984]   - Field: ‘owner’
[10:21:20.985]   - Field: ‘envir’
[10:21:20.985]   - Field: ‘workers’
[10:21:20.985]   - Field: ‘packages’
[10:21:20.985]   - Field: ‘gc’
[10:21:20.985]   - Field: ‘conditions’
[10:21:20.985]   - Field: ‘persistent’
[10:21:20.985]   - Field: ‘expr’
[10:21:20.985]   - Field: ‘uuid’
[10:21:20.985]   - Field: ‘seed’
[10:21:20.985]   - Field: ‘version’
[10:21:20.985]   - Field: ‘result’
[10:21:20.985]   - Field: ‘asynchronous’
[10:21:20.986]   - Field: ‘calls’
[10:21:20.986]   - Field: ‘globals’
[10:21:20.986]   - Field: ‘stdout’
[10:21:20.986]   - Field: ‘earlySignal’
[10:21:20.986]   - Field: ‘lazy’
[10:21:20.986]   - Field: ‘state’
[10:21:20.986] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:20.986] - Launch lazy future ...
[10:21:20.986] Packages needed by the future expression (n = 0): <none>
[10:21:20.986] Packages needed by future strategies (n = 0): <none>
[10:21:20.987] {
[10:21:20.987]     {
[10:21:20.987]         {
[10:21:20.987]             ...future.startTime <- base::Sys.time()
[10:21:20.987]             {
[10:21:20.987]                 {
[10:21:20.987]                   {
[10:21:20.987]                     {
[10:21:20.987]                       base::local({
[10:21:20.987]                         has_future <- base::requireNamespace("future", 
[10:21:20.987]                           quietly = TRUE)
[10:21:20.987]                         if (has_future) {
[10:21:20.987]                           ns <- base::getNamespace("future")
[10:21:20.987]                           version <- ns[[".package"]][["version"]]
[10:21:20.987]                           if (is.null(version)) 
[10:21:20.987]                             version <- utils::packageVersion("future")
[10:21:20.987]                         }
[10:21:20.987]                         else {
[10:21:20.987]                           version <- NULL
[10:21:20.987]                         }
[10:21:20.987]                         if (!has_future || version < "1.8.0") {
[10:21:20.987]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:20.987]                             "", base::R.version$version.string), 
[10:21:20.987]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:20.987]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:20.987]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:20.987]                               "release", "version")], collapse = " "), 
[10:21:20.987]                             hostname = base::Sys.info()[["nodename"]])
[10:21:20.987]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:20.987]                             info)
[10:21:20.987]                           info <- base::paste(info, collapse = "; ")
[10:21:20.987]                           if (!has_future) {
[10:21:20.987]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:20.987]                               info)
[10:21:20.987]                           }
[10:21:20.987]                           else {
[10:21:20.987]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:20.987]                               info, version)
[10:21:20.987]                           }
[10:21:20.987]                           base::stop(msg)
[10:21:20.987]                         }
[10:21:20.987]                       })
[10:21:20.987]                     }
[10:21:20.987]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:20.987]                     base::options(mc.cores = 1L)
[10:21:20.987]                   }
[10:21:20.987]                   ...future.strategy.old <- future::plan("list")
[10:21:20.987]                   options(future.plan = NULL)
[10:21:20.987]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.987]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:20.987]                 }
[10:21:20.987]                 ...future.workdir <- getwd()
[10:21:20.987]             }
[10:21:20.987]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:20.987]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:20.987]         }
[10:21:20.987]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:20.987]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:20.987]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:20.987]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:20.987]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:20.987]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:20.987]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:20.987]             base::names(...future.oldOptions))
[10:21:20.987]     }
[10:21:20.987]     if (FALSE) {
[10:21:20.987]     }
[10:21:20.987]     else {
[10:21:20.987]         if (TRUE) {
[10:21:20.987]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:20.987]                 open = "w")
[10:21:20.987]         }
[10:21:20.987]         else {
[10:21:20.987]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:20.987]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:20.987]         }
[10:21:20.987]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:20.987]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:20.987]             base::sink(type = "output", split = FALSE)
[10:21:20.987]             base::close(...future.stdout)
[10:21:20.987]         }, add = TRUE)
[10:21:20.987]     }
[10:21:20.987]     ...future.frame <- base::sys.nframe()
[10:21:20.987]     ...future.conditions <- base::list()
[10:21:20.987]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:20.987]     if (FALSE) {
[10:21:20.987]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:20.987]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:20.987]     }
[10:21:20.987]     ...future.result <- base::tryCatch({
[10:21:20.987]         base::withCallingHandlers({
[10:21:20.987]             ...future.value <- base::withVisible(base::local({
[10:21:20.987]                 ...future.makeSendCondition <- base::local({
[10:21:20.987]                   sendCondition <- NULL
[10:21:20.987]                   function(frame = 1L) {
[10:21:20.987]                     if (is.function(sendCondition)) 
[10:21:20.987]                       return(sendCondition)
[10:21:20.987]                     ns <- getNamespace("parallel")
[10:21:20.987]                     if (exists("sendData", mode = "function", 
[10:21:20.987]                       envir = ns)) {
[10:21:20.987]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:20.987]                         envir = ns)
[10:21:20.987]                       envir <- sys.frame(frame)
[10:21:20.987]                       master <- NULL
[10:21:20.987]                       while (!identical(envir, .GlobalEnv) && 
[10:21:20.987]                         !identical(envir, emptyenv())) {
[10:21:20.987]                         if (exists("master", mode = "list", envir = envir, 
[10:21:20.987]                           inherits = FALSE)) {
[10:21:20.987]                           master <- get("master", mode = "list", 
[10:21:20.987]                             envir = envir, inherits = FALSE)
[10:21:20.987]                           if (inherits(master, c("SOCKnode", 
[10:21:20.987]                             "SOCK0node"))) {
[10:21:20.987]                             sendCondition <<- function(cond) {
[10:21:20.987]                               data <- list(type = "VALUE", value = cond, 
[10:21:20.987]                                 success = TRUE)
[10:21:20.987]                               parallel_sendData(master, data)
[10:21:20.987]                             }
[10:21:20.987]                             return(sendCondition)
[10:21:20.987]                           }
[10:21:20.987]                         }
[10:21:20.987]                         frame <- frame + 1L
[10:21:20.987]                         envir <- sys.frame(frame)
[10:21:20.987]                       }
[10:21:20.987]                     }
[10:21:20.987]                     sendCondition <<- function(cond) NULL
[10:21:20.987]                   }
[10:21:20.987]                 })
[10:21:20.987]                 withCallingHandlers({
[10:21:20.987]                   NULL
[10:21:20.987]                 }, immediateCondition = function(cond) {
[10:21:20.987]                   sendCondition <- ...future.makeSendCondition()
[10:21:20.987]                   sendCondition(cond)
[10:21:20.987]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.987]                   {
[10:21:20.987]                     inherits <- base::inherits
[10:21:20.987]                     invokeRestart <- base::invokeRestart
[10:21:20.987]                     is.null <- base::is.null
[10:21:20.987]                     muffled <- FALSE
[10:21:20.987]                     if (inherits(cond, "message")) {
[10:21:20.987]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:20.987]                       if (muffled) 
[10:21:20.987]                         invokeRestart("muffleMessage")
[10:21:20.987]                     }
[10:21:20.987]                     else if (inherits(cond, "warning")) {
[10:21:20.987]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:20.987]                       if (muffled) 
[10:21:20.987]                         invokeRestart("muffleWarning")
[10:21:20.987]                     }
[10:21:20.987]                     else if (inherits(cond, "condition")) {
[10:21:20.987]                       if (!is.null(pattern)) {
[10:21:20.987]                         computeRestarts <- base::computeRestarts
[10:21:20.987]                         grepl <- base::grepl
[10:21:20.987]                         restarts <- computeRestarts(cond)
[10:21:20.987]                         for (restart in restarts) {
[10:21:20.987]                           name <- restart$name
[10:21:20.987]                           if (is.null(name)) 
[10:21:20.987]                             next
[10:21:20.987]                           if (!grepl(pattern, name)) 
[10:21:20.987]                             next
[10:21:20.987]                           invokeRestart(restart)
[10:21:20.987]                           muffled <- TRUE
[10:21:20.987]                           break
[10:21:20.987]                         }
[10:21:20.987]                       }
[10:21:20.987]                     }
[10:21:20.987]                     invisible(muffled)
[10:21:20.987]                   }
[10:21:20.987]                   muffleCondition(cond)
[10:21:20.987]                 })
[10:21:20.987]             }))
[10:21:20.987]             future::FutureResult(value = ...future.value$value, 
[10:21:20.987]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.987]                   ...future.rng), globalenv = if (FALSE) 
[10:21:20.987]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:20.987]                     ...future.globalenv.names))
[10:21:20.987]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:20.987]         }, condition = base::local({
[10:21:20.987]             c <- base::c
[10:21:20.987]             inherits <- base::inherits
[10:21:20.987]             invokeRestart <- base::invokeRestart
[10:21:20.987]             length <- base::length
[10:21:20.987]             list <- base::list
[10:21:20.987]             seq.int <- base::seq.int
[10:21:20.987]             signalCondition <- base::signalCondition
[10:21:20.987]             sys.calls <- base::sys.calls
[10:21:20.987]             `[[` <- base::`[[`
[10:21:20.987]             `+` <- base::`+`
[10:21:20.987]             `<<-` <- base::`<<-`
[10:21:20.987]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:20.987]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:20.987]                   3L)]
[10:21:20.987]             }
[10:21:20.987]             function(cond) {
[10:21:20.987]                 is_error <- inherits(cond, "error")
[10:21:20.987]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:20.987]                   NULL)
[10:21:20.987]                 if (is_error) {
[10:21:20.987]                   sessionInformation <- function() {
[10:21:20.987]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:20.987]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:20.987]                       search = base::search(), system = base::Sys.info())
[10:21:20.987]                   }
[10:21:20.987]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.987]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:20.987]                     cond$call), session = sessionInformation(), 
[10:21:20.987]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:20.987]                   signalCondition(cond)
[10:21:20.987]                 }
[10:21:20.987]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:20.987]                 "immediateCondition"))) {
[10:21:20.987]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:20.987]                   ...future.conditions[[length(...future.conditions) + 
[10:21:20.987]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:20.987]                   if (TRUE && !signal) {
[10:21:20.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.987]                     {
[10:21:20.987]                       inherits <- base::inherits
[10:21:20.987]                       invokeRestart <- base::invokeRestart
[10:21:20.987]                       is.null <- base::is.null
[10:21:20.987]                       muffled <- FALSE
[10:21:20.987]                       if (inherits(cond, "message")) {
[10:21:20.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.987]                         if (muffled) 
[10:21:20.987]                           invokeRestart("muffleMessage")
[10:21:20.987]                       }
[10:21:20.987]                       else if (inherits(cond, "warning")) {
[10:21:20.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.987]                         if (muffled) 
[10:21:20.987]                           invokeRestart("muffleWarning")
[10:21:20.987]                       }
[10:21:20.987]                       else if (inherits(cond, "condition")) {
[10:21:20.987]                         if (!is.null(pattern)) {
[10:21:20.987]                           computeRestarts <- base::computeRestarts
[10:21:20.987]                           grepl <- base::grepl
[10:21:20.987]                           restarts <- computeRestarts(cond)
[10:21:20.987]                           for (restart in restarts) {
[10:21:20.987]                             name <- restart$name
[10:21:20.987]                             if (is.null(name)) 
[10:21:20.987]                               next
[10:21:20.987]                             if (!grepl(pattern, name)) 
[10:21:20.987]                               next
[10:21:20.987]                             invokeRestart(restart)
[10:21:20.987]                             muffled <- TRUE
[10:21:20.987]                             break
[10:21:20.987]                           }
[10:21:20.987]                         }
[10:21:20.987]                       }
[10:21:20.987]                       invisible(muffled)
[10:21:20.987]                     }
[10:21:20.987]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.987]                   }
[10:21:20.987]                 }
[10:21:20.987]                 else {
[10:21:20.987]                   if (TRUE) {
[10:21:20.987]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:20.987]                     {
[10:21:20.987]                       inherits <- base::inherits
[10:21:20.987]                       invokeRestart <- base::invokeRestart
[10:21:20.987]                       is.null <- base::is.null
[10:21:20.987]                       muffled <- FALSE
[10:21:20.987]                       if (inherits(cond, "message")) {
[10:21:20.987]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:20.987]                         if (muffled) 
[10:21:20.987]                           invokeRestart("muffleMessage")
[10:21:20.987]                       }
[10:21:20.987]                       else if (inherits(cond, "warning")) {
[10:21:20.987]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:20.987]                         if (muffled) 
[10:21:20.987]                           invokeRestart("muffleWarning")
[10:21:20.987]                       }
[10:21:20.987]                       else if (inherits(cond, "condition")) {
[10:21:20.987]                         if (!is.null(pattern)) {
[10:21:20.987]                           computeRestarts <- base::computeRestarts
[10:21:20.987]                           grepl <- base::grepl
[10:21:20.987]                           restarts <- computeRestarts(cond)
[10:21:20.987]                           for (restart in restarts) {
[10:21:20.987]                             name <- restart$name
[10:21:20.987]                             if (is.null(name)) 
[10:21:20.987]                               next
[10:21:20.987]                             if (!grepl(pattern, name)) 
[10:21:20.987]                               next
[10:21:20.987]                             invokeRestart(restart)
[10:21:20.987]                             muffled <- TRUE
[10:21:20.987]                             break
[10:21:20.987]                           }
[10:21:20.987]                         }
[10:21:20.987]                       }
[10:21:20.987]                       invisible(muffled)
[10:21:20.987]                     }
[10:21:20.987]                     muffleCondition(cond, pattern = "^muffle")
[10:21:20.987]                   }
[10:21:20.987]                 }
[10:21:20.987]             }
[10:21:20.987]         }))
[10:21:20.987]     }, error = function(ex) {
[10:21:20.987]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:20.987]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:20.987]                 ...future.rng), started = ...future.startTime, 
[10:21:20.987]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:20.987]             version = "1.8"), class = "FutureResult")
[10:21:20.987]     }, finally = {
[10:21:20.987]         if (!identical(...future.workdir, getwd())) 
[10:21:20.987]             setwd(...future.workdir)
[10:21:20.987]         {
[10:21:20.987]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:20.987]                 ...future.oldOptions$nwarnings <- NULL
[10:21:20.987]             }
[10:21:20.987]             base::options(...future.oldOptions)
[10:21:20.987]             if (.Platform$OS.type == "windows") {
[10:21:20.987]                 old_names <- names(...future.oldEnvVars)
[10:21:20.987]                 envs <- base::Sys.getenv()
[10:21:20.987]                 names <- names(envs)
[10:21:20.987]                 common <- intersect(names, old_names)
[10:21:20.987]                 added <- setdiff(names, old_names)
[10:21:20.987]                 removed <- setdiff(old_names, names)
[10:21:20.987]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:20.987]                   envs[common]]
[10:21:20.987]                 NAMES <- toupper(changed)
[10:21:20.987]                 args <- list()
[10:21:20.987]                 for (kk in seq_along(NAMES)) {
[10:21:20.987]                   name <- changed[[kk]]
[10:21:20.987]                   NAME <- NAMES[[kk]]
[10:21:20.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.987]                     next
[10:21:20.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.987]                 }
[10:21:20.987]                 NAMES <- toupper(added)
[10:21:20.987]                 for (kk in seq_along(NAMES)) {
[10:21:20.987]                   name <- added[[kk]]
[10:21:20.987]                   NAME <- NAMES[[kk]]
[10:21:20.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.987]                     next
[10:21:20.987]                   args[[name]] <- ""
[10:21:20.987]                 }
[10:21:20.987]                 NAMES <- toupper(removed)
[10:21:20.987]                 for (kk in seq_along(NAMES)) {
[10:21:20.987]                   name <- removed[[kk]]
[10:21:20.987]                   NAME <- NAMES[[kk]]
[10:21:20.987]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:20.987]                     next
[10:21:20.987]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:20.987]                 }
[10:21:20.987]                 if (length(args) > 0) 
[10:21:20.987]                   base::do.call(base::Sys.setenv, args = args)
[10:21:20.987]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:20.987]             }
[10:21:20.987]             else {
[10:21:20.987]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:20.987]             }
[10:21:20.987]             {
[10:21:20.987]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:20.987]                   0L) {
[10:21:20.987]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:20.987]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:20.987]                   base::options(opts)
[10:21:20.987]                 }
[10:21:20.987]                 {
[10:21:20.987]                   {
[10:21:20.987]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:20.987]                     NULL
[10:21:20.987]                   }
[10:21:20.987]                   options(future.plan = NULL)
[10:21:20.987]                   if (is.na(NA_character_)) 
[10:21:20.987]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:20.987]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:20.987]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:20.987]                     .init = FALSE)
[10:21:20.987]                 }
[10:21:20.987]             }
[10:21:20.987]         }
[10:21:20.987]     })
[10:21:20.987]     if (TRUE) {
[10:21:20.987]         base::sink(type = "output", split = FALSE)
[10:21:20.987]         if (TRUE) {
[10:21:20.987]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:20.987]         }
[10:21:20.987]         else {
[10:21:20.987]             ...future.result["stdout"] <- base::list(NULL)
[10:21:20.987]         }
[10:21:20.987]         base::close(...future.stdout)
[10:21:20.987]         ...future.stdout <- NULL
[10:21:20.987]     }
[10:21:20.987]     ...future.result$conditions <- ...future.conditions
[10:21:20.987]     ...future.result$finished <- base::Sys.time()
[10:21:20.987]     ...future.result
[10:21:20.987] }
[10:21:20.990] MultisessionFuture started
[10:21:20.990] - Launch lazy future ... done
[10:21:20.990] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e360ba50> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e647e9f8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e360ba50> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e647e9f8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:21.017] resolve() on list ...
[10:21:21.017]  recursive: 0
[10:21:21.017]  length: 6
[10:21:21.017]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:21.018] signalConditionsASAP(numeric, pos=1) ...
[10:21:21.018] - nx: 6
[10:21:21.018] - relay: TRUE
[10:21:21.018] - stdout: TRUE
[10:21:21.018] - signal: TRUE
[10:21:21.018] - resignal: FALSE
[10:21:21.018] - force: TRUE
[10:21:21.018] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.018] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.018]  - until=2
[10:21:21.018]  - relaying element #2
[10:21:21.018] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.019] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.019] signalConditionsASAP(NULL, pos=1) ... done
[10:21:21.019]  length: 5 (resolved future 1)
[10:21:21.019] receiveMessageFromWorker() for ClusterFuture ...
[10:21:21.019] - Validating connection of MultisessionFuture
[10:21:21.019] - received message: FutureResult
[10:21:21.020] - Received FutureResult
[10:21:21.020] - Erased future from FutureRegistry
[10:21:21.020] result() for ClusterFuture ...
[10:21:21.020] - result already collected: FutureResult
[10:21:21.020] result() for ClusterFuture ... done
[10:21:21.020] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:21.020] Future #2
[10:21:21.020] result() for ClusterFuture ...
[10:21:21.020] - result already collected: FutureResult
[10:21:21.020] result() for ClusterFuture ... done
[10:21:21.020] result() for ClusterFuture ...
[10:21:21.020] - result already collected: FutureResult
[10:21:21.021] result() for ClusterFuture ... done
[10:21:21.021] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:21.021] - nx: 6
[10:21:21.021] - relay: TRUE
[10:21:21.021] - stdout: TRUE
[10:21:21.021] - signal: TRUE
[10:21:21.021] - resignal: FALSE
[10:21:21.021] - force: TRUE
[10:21:21.021] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.021] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.021]  - until=2
[10:21:21.021]  - relaying element #2
[10:21:21.022] result() for ClusterFuture ...
[10:21:21.022] - result already collected: FutureResult
[10:21:21.022] result() for ClusterFuture ... done
[10:21:21.022] result() for ClusterFuture ...
[10:21:21.022] - result already collected: FutureResult
[10:21:21.022] result() for ClusterFuture ... done
[10:21:21.022] result() for ClusterFuture ...
[10:21:21.022] - result already collected: FutureResult
[10:21:21.022] result() for ClusterFuture ... done
[10:21:21.022] result() for ClusterFuture ...
[10:21:21.022] - result already collected: FutureResult
[10:21:21.022] result() for ClusterFuture ... done
[10:21:21.023] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.023] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.023] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:21.023]  length: 4 (resolved future 2)
[10:21:21.032] receiveMessageFromWorker() for ClusterFuture ...
[10:21:21.032] - Validating connection of MultisessionFuture
[10:21:21.032] - received message: FutureResult
[10:21:21.032] - Received FutureResult
[10:21:21.033] - Erased future from FutureRegistry
[10:21:21.033] result() for ClusterFuture ...
[10:21:21.033] - result already collected: FutureResult
[10:21:21.033] result() for ClusterFuture ... done
[10:21:21.033] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:21.033] Future #3
[10:21:21.033] result() for ClusterFuture ...
[10:21:21.033] - result already collected: FutureResult
[10:21:21.033] result() for ClusterFuture ... done
[10:21:21.033] result() for ClusterFuture ...
[10:21:21.033] - result already collected: FutureResult
[10:21:21.034] result() for ClusterFuture ... done
[10:21:21.034] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:21.034] - nx: 6
[10:21:21.034] - relay: TRUE
[10:21:21.034] - stdout: TRUE
[10:21:21.034] - signal: TRUE
[10:21:21.034] - resignal: FALSE
[10:21:21.034] - force: TRUE
[10:21:21.034] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.034] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.034]  - until=3
[10:21:21.034]  - relaying element #3
[10:21:21.035] result() for ClusterFuture ...
[10:21:21.035] - result already collected: FutureResult
[10:21:21.035] result() for ClusterFuture ... done
[10:21:21.035] result() for ClusterFuture ...
[10:21:21.035] - result already collected: FutureResult
[10:21:21.035] result() for ClusterFuture ... done
[10:21:21.035] result() for ClusterFuture ...
[10:21:21.035] - result already collected: FutureResult
[10:21:21.035] result() for ClusterFuture ... done
[10:21:21.035] result() for ClusterFuture ...
[10:21:21.035] - result already collected: FutureResult
[10:21:21.035] result() for ClusterFuture ... done
[10:21:21.036] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.036] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.036] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:21.036]  length: 3 (resolved future 3)
[10:21:21.036] signalConditionsASAP(NULL, pos=4) ...
[10:21:21.036] - nx: 6
[10:21:21.036] - relay: TRUE
[10:21:21.036] - stdout: TRUE
[10:21:21.036] - signal: TRUE
[10:21:21.036] - resignal: FALSE
[10:21:21.036] - force: TRUE
[10:21:21.036] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.037] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.037]  - until=5
[10:21:21.037]  - relaying element #5
[10:21:21.037] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:21.037] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.037] signalConditionsASAP(NULL, pos=4) ... done
[10:21:21.037]  length: 2 (resolved future 4)
[10:21:21.037] signalConditionsASAP(NULL, pos=5) ...
[10:21:21.037] - nx: 6
[10:21:21.037] - relay: TRUE
[10:21:21.037] - stdout: TRUE
[10:21:21.037] - signal: TRUE
[10:21:21.038] - resignal: FALSE
[10:21:21.038] - force: TRUE
[10:21:21.038] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:21.038] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.038]  - until=6
[10:21:21.038]  - relaying element #6
[10:21:21.038] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:21.038] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.038] signalConditionsASAP(NULL, pos=5) ... done
[10:21:21.038]  length: 1 (resolved future 5)
[10:21:21.038] signalConditionsASAP(numeric, pos=6) ...
[10:21:21.038] - nx: 6
[10:21:21.038] - relay: TRUE
[10:21:21.039] - stdout: TRUE
[10:21:21.039] - signal: TRUE
[10:21:21.039] - resignal: FALSE
[10:21:21.039] - force: TRUE
[10:21:21.039] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:21.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.039]  - until=6
[10:21:21.039] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:21.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.039] signalConditionsASAP(numeric, pos=6) ... done
[10:21:21.039]  length: 0 (resolved future 6)
[10:21:21.039] Relaying remaining futures
[10:21:21.040] signalConditionsASAP(NULL, pos=0) ...
[10:21:21.040] - nx: 6
[10:21:21.040] - relay: TRUE
[10:21:21.040] - stdout: TRUE
[10:21:21.040] - signal: TRUE
[10:21:21.040] - resignal: FALSE
[10:21:21.040] - force: TRUE
[10:21:21.040] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:21.040] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:21.040] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:21.040] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.040] signalConditionsASAP(NULL, pos=0) ... done
[10:21:21.040] resolve() on list ... DONE
[10:21:21.041] result() for ClusterFuture ...
[10:21:21.041] - result already collected: FutureResult
[10:21:21.041] result() for ClusterFuture ... done
[10:21:21.041] result() for ClusterFuture ...
[10:21:21.041] - result already collected: FutureResult
[10:21:21.041] result() for ClusterFuture ... done
[10:21:21.041] result() for ClusterFuture ...
[10:21:21.041] - result already collected: FutureResult
[10:21:21.041] result() for ClusterFuture ... done
[10:21:21.041] result() for ClusterFuture ...
[10:21:21.041] - result already collected: FutureResult
[10:21:21.041] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:21:21.044] getGlobalsAndPackages() ...
[10:21:21.044] Searching for globals...
[10:21:21.045] 
[10:21:21.045] Searching for globals ... DONE
[10:21:21.045] - globals: [0] <none>
[10:21:21.045] getGlobalsAndPackages() ... DONE
[10:21:21.045] run() for ‘Future’ ...
[10:21:21.045] - state: ‘created’
[10:21:21.045] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.059] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.059] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:21.059]   - Field: ‘node’
[10:21:21.060]   - Field: ‘label’
[10:21:21.060]   - Field: ‘local’
[10:21:21.060]   - Field: ‘owner’
[10:21:21.060]   - Field: ‘envir’
[10:21:21.060]   - Field: ‘workers’
[10:21:21.060]   - Field: ‘packages’
[10:21:21.060]   - Field: ‘gc’
[10:21:21.060]   - Field: ‘conditions’
[10:21:21.060]   - Field: ‘persistent’
[10:21:21.060]   - Field: ‘expr’
[10:21:21.060]   - Field: ‘uuid’
[10:21:21.060]   - Field: ‘seed’
[10:21:21.061]   - Field: ‘version’
[10:21:21.061]   - Field: ‘result’
[10:21:21.061]   - Field: ‘asynchronous’
[10:21:21.061]   - Field: ‘calls’
[10:21:21.061]   - Field: ‘globals’
[10:21:21.061]   - Field: ‘stdout’
[10:21:21.063]   - Field: ‘earlySignal’
[10:21:21.063]   - Field: ‘lazy’
[10:21:21.063]   - Field: ‘state’
[10:21:21.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:21.063] - Launch lazy future ...
[10:21:21.064] Packages needed by the future expression (n = 0): <none>
[10:21:21.064] Packages needed by future strategies (n = 0): <none>
[10:21:21.064] {
[10:21:21.064]     {
[10:21:21.064]         {
[10:21:21.064]             ...future.startTime <- base::Sys.time()
[10:21:21.064]             {
[10:21:21.064]                 {
[10:21:21.064]                   {
[10:21:21.064]                     {
[10:21:21.064]                       base::local({
[10:21:21.064]                         has_future <- base::requireNamespace("future", 
[10:21:21.064]                           quietly = TRUE)
[10:21:21.064]                         if (has_future) {
[10:21:21.064]                           ns <- base::getNamespace("future")
[10:21:21.064]                           version <- ns[[".package"]][["version"]]
[10:21:21.064]                           if (is.null(version)) 
[10:21:21.064]                             version <- utils::packageVersion("future")
[10:21:21.064]                         }
[10:21:21.064]                         else {
[10:21:21.064]                           version <- NULL
[10:21:21.064]                         }
[10:21:21.064]                         if (!has_future || version < "1.8.0") {
[10:21:21.064]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.064]                             "", base::R.version$version.string), 
[10:21:21.064]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.064]                               "release", "version")], collapse = " "), 
[10:21:21.064]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.064]                             info)
[10:21:21.064]                           info <- base::paste(info, collapse = "; ")
[10:21:21.064]                           if (!has_future) {
[10:21:21.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.064]                               info)
[10:21:21.064]                           }
[10:21:21.064]                           else {
[10:21:21.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.064]                               info, version)
[10:21:21.064]                           }
[10:21:21.064]                           base::stop(msg)
[10:21:21.064]                         }
[10:21:21.064]                       })
[10:21:21.064]                     }
[10:21:21.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.064]                     base::options(mc.cores = 1L)
[10:21:21.064]                   }
[10:21:21.064]                   ...future.strategy.old <- future::plan("list")
[10:21:21.064]                   options(future.plan = NULL)
[10:21:21.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.064]                 }
[10:21:21.064]                 ...future.workdir <- getwd()
[10:21:21.064]             }
[10:21:21.064]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.064]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.064]         }
[10:21:21.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.064]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.064]             base::names(...future.oldOptions))
[10:21:21.064]     }
[10:21:21.064]     if (FALSE) {
[10:21:21.064]     }
[10:21:21.064]     else {
[10:21:21.064]         if (TRUE) {
[10:21:21.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.064]                 open = "w")
[10:21:21.064]         }
[10:21:21.064]         else {
[10:21:21.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.064]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.064]         }
[10:21:21.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.064]             base::sink(type = "output", split = FALSE)
[10:21:21.064]             base::close(...future.stdout)
[10:21:21.064]         }, add = TRUE)
[10:21:21.064]     }
[10:21:21.064]     ...future.frame <- base::sys.nframe()
[10:21:21.064]     ...future.conditions <- base::list()
[10:21:21.064]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.064]     if (FALSE) {
[10:21:21.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.064]     }
[10:21:21.064]     ...future.result <- base::tryCatch({
[10:21:21.064]         base::withCallingHandlers({
[10:21:21.064]             ...future.value <- base::withVisible(base::local({
[10:21:21.064]                 ...future.makeSendCondition <- base::local({
[10:21:21.064]                   sendCondition <- NULL
[10:21:21.064]                   function(frame = 1L) {
[10:21:21.064]                     if (is.function(sendCondition)) 
[10:21:21.064]                       return(sendCondition)
[10:21:21.064]                     ns <- getNamespace("parallel")
[10:21:21.064]                     if (exists("sendData", mode = "function", 
[10:21:21.064]                       envir = ns)) {
[10:21:21.064]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:21.064]                         envir = ns)
[10:21:21.064]                       envir <- sys.frame(frame)
[10:21:21.064]                       master <- NULL
[10:21:21.064]                       while (!identical(envir, .GlobalEnv) && 
[10:21:21.064]                         !identical(envir, emptyenv())) {
[10:21:21.064]                         if (exists("master", mode = "list", envir = envir, 
[10:21:21.064]                           inherits = FALSE)) {
[10:21:21.064]                           master <- get("master", mode = "list", 
[10:21:21.064]                             envir = envir, inherits = FALSE)
[10:21:21.064]                           if (inherits(master, c("SOCKnode", 
[10:21:21.064]                             "SOCK0node"))) {
[10:21:21.064]                             sendCondition <<- function(cond) {
[10:21:21.064]                               data <- list(type = "VALUE", value = cond, 
[10:21:21.064]                                 success = TRUE)
[10:21:21.064]                               parallel_sendData(master, data)
[10:21:21.064]                             }
[10:21:21.064]                             return(sendCondition)
[10:21:21.064]                           }
[10:21:21.064]                         }
[10:21:21.064]                         frame <- frame + 1L
[10:21:21.064]                         envir <- sys.frame(frame)
[10:21:21.064]                       }
[10:21:21.064]                     }
[10:21:21.064]                     sendCondition <<- function(cond) NULL
[10:21:21.064]                   }
[10:21:21.064]                 })
[10:21:21.064]                 withCallingHandlers({
[10:21:21.064]                   2
[10:21:21.064]                 }, immediateCondition = function(cond) {
[10:21:21.064]                   sendCondition <- ...future.makeSendCondition()
[10:21:21.064]                   sendCondition(cond)
[10:21:21.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.064]                   {
[10:21:21.064]                     inherits <- base::inherits
[10:21:21.064]                     invokeRestart <- base::invokeRestart
[10:21:21.064]                     is.null <- base::is.null
[10:21:21.064]                     muffled <- FALSE
[10:21:21.064]                     if (inherits(cond, "message")) {
[10:21:21.064]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.064]                       if (muffled) 
[10:21:21.064]                         invokeRestart("muffleMessage")
[10:21:21.064]                     }
[10:21:21.064]                     else if (inherits(cond, "warning")) {
[10:21:21.064]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.064]                       if (muffled) 
[10:21:21.064]                         invokeRestart("muffleWarning")
[10:21:21.064]                     }
[10:21:21.064]                     else if (inherits(cond, "condition")) {
[10:21:21.064]                       if (!is.null(pattern)) {
[10:21:21.064]                         computeRestarts <- base::computeRestarts
[10:21:21.064]                         grepl <- base::grepl
[10:21:21.064]                         restarts <- computeRestarts(cond)
[10:21:21.064]                         for (restart in restarts) {
[10:21:21.064]                           name <- restart$name
[10:21:21.064]                           if (is.null(name)) 
[10:21:21.064]                             next
[10:21:21.064]                           if (!grepl(pattern, name)) 
[10:21:21.064]                             next
[10:21:21.064]                           invokeRestart(restart)
[10:21:21.064]                           muffled <- TRUE
[10:21:21.064]                           break
[10:21:21.064]                         }
[10:21:21.064]                       }
[10:21:21.064]                     }
[10:21:21.064]                     invisible(muffled)
[10:21:21.064]                   }
[10:21:21.064]                   muffleCondition(cond)
[10:21:21.064]                 })
[10:21:21.064]             }))
[10:21:21.064]             future::FutureResult(value = ...future.value$value, 
[10:21:21.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.064]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.064]                     ...future.globalenv.names))
[10:21:21.064]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.064]         }, condition = base::local({
[10:21:21.064]             c <- base::c
[10:21:21.064]             inherits <- base::inherits
[10:21:21.064]             invokeRestart <- base::invokeRestart
[10:21:21.064]             length <- base::length
[10:21:21.064]             list <- base::list
[10:21:21.064]             seq.int <- base::seq.int
[10:21:21.064]             signalCondition <- base::signalCondition
[10:21:21.064]             sys.calls <- base::sys.calls
[10:21:21.064]             `[[` <- base::`[[`
[10:21:21.064]             `+` <- base::`+`
[10:21:21.064]             `<<-` <- base::`<<-`
[10:21:21.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.064]                   3L)]
[10:21:21.064]             }
[10:21:21.064]             function(cond) {
[10:21:21.064]                 is_error <- inherits(cond, "error")
[10:21:21.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.064]                   NULL)
[10:21:21.064]                 if (is_error) {
[10:21:21.064]                   sessionInformation <- function() {
[10:21:21.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.064]                       search = base::search(), system = base::Sys.info())
[10:21:21.064]                   }
[10:21:21.064]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.064]                     cond$call), session = sessionInformation(), 
[10:21:21.064]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.064]                   signalCondition(cond)
[10:21:21.064]                 }
[10:21:21.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.064]                 "immediateCondition"))) {
[10:21:21.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.064]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.064]                   if (TRUE && !signal) {
[10:21:21.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.064]                     {
[10:21:21.064]                       inherits <- base::inherits
[10:21:21.064]                       invokeRestart <- base::invokeRestart
[10:21:21.064]                       is.null <- base::is.null
[10:21:21.064]                       muffled <- FALSE
[10:21:21.064]                       if (inherits(cond, "message")) {
[10:21:21.064]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.064]                         if (muffled) 
[10:21:21.064]                           invokeRestart("muffleMessage")
[10:21:21.064]                       }
[10:21:21.064]                       else if (inherits(cond, "warning")) {
[10:21:21.064]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.064]                         if (muffled) 
[10:21:21.064]                           invokeRestart("muffleWarning")
[10:21:21.064]                       }
[10:21:21.064]                       else if (inherits(cond, "condition")) {
[10:21:21.064]                         if (!is.null(pattern)) {
[10:21:21.064]                           computeRestarts <- base::computeRestarts
[10:21:21.064]                           grepl <- base::grepl
[10:21:21.064]                           restarts <- computeRestarts(cond)
[10:21:21.064]                           for (restart in restarts) {
[10:21:21.064]                             name <- restart$name
[10:21:21.064]                             if (is.null(name)) 
[10:21:21.064]                               next
[10:21:21.064]                             if (!grepl(pattern, name)) 
[10:21:21.064]                               next
[10:21:21.064]                             invokeRestart(restart)
[10:21:21.064]                             muffled <- TRUE
[10:21:21.064]                             break
[10:21:21.064]                           }
[10:21:21.064]                         }
[10:21:21.064]                       }
[10:21:21.064]                       invisible(muffled)
[10:21:21.064]                     }
[10:21:21.064]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.064]                   }
[10:21:21.064]                 }
[10:21:21.064]                 else {
[10:21:21.064]                   if (TRUE) {
[10:21:21.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.064]                     {
[10:21:21.064]                       inherits <- base::inherits
[10:21:21.064]                       invokeRestart <- base::invokeRestart
[10:21:21.064]                       is.null <- base::is.null
[10:21:21.064]                       muffled <- FALSE
[10:21:21.064]                       if (inherits(cond, "message")) {
[10:21:21.064]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.064]                         if (muffled) 
[10:21:21.064]                           invokeRestart("muffleMessage")
[10:21:21.064]                       }
[10:21:21.064]                       else if (inherits(cond, "warning")) {
[10:21:21.064]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.064]                         if (muffled) 
[10:21:21.064]                           invokeRestart("muffleWarning")
[10:21:21.064]                       }
[10:21:21.064]                       else if (inherits(cond, "condition")) {
[10:21:21.064]                         if (!is.null(pattern)) {
[10:21:21.064]                           computeRestarts <- base::computeRestarts
[10:21:21.064]                           grepl <- base::grepl
[10:21:21.064]                           restarts <- computeRestarts(cond)
[10:21:21.064]                           for (restart in restarts) {
[10:21:21.064]                             name <- restart$name
[10:21:21.064]                             if (is.null(name)) 
[10:21:21.064]                               next
[10:21:21.064]                             if (!grepl(pattern, name)) 
[10:21:21.064]                               next
[10:21:21.064]                             invokeRestart(restart)
[10:21:21.064]                             muffled <- TRUE
[10:21:21.064]                             break
[10:21:21.064]                           }
[10:21:21.064]                         }
[10:21:21.064]                       }
[10:21:21.064]                       invisible(muffled)
[10:21:21.064]                     }
[10:21:21.064]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.064]                   }
[10:21:21.064]                 }
[10:21:21.064]             }
[10:21:21.064]         }))
[10:21:21.064]     }, error = function(ex) {
[10:21:21.064]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.064]                 ...future.rng), started = ...future.startTime, 
[10:21:21.064]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.064]             version = "1.8"), class = "FutureResult")
[10:21:21.064]     }, finally = {
[10:21:21.064]         if (!identical(...future.workdir, getwd())) 
[10:21:21.064]             setwd(...future.workdir)
[10:21:21.064]         {
[10:21:21.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.064]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.064]             }
[10:21:21.064]             base::options(...future.oldOptions)
[10:21:21.064]             if (.Platform$OS.type == "windows") {
[10:21:21.064]                 old_names <- names(...future.oldEnvVars)
[10:21:21.064]                 envs <- base::Sys.getenv()
[10:21:21.064]                 names <- names(envs)
[10:21:21.064]                 common <- intersect(names, old_names)
[10:21:21.064]                 added <- setdiff(names, old_names)
[10:21:21.064]                 removed <- setdiff(old_names, names)
[10:21:21.064]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.064]                   envs[common]]
[10:21:21.064]                 NAMES <- toupper(changed)
[10:21:21.064]                 args <- list()
[10:21:21.064]                 for (kk in seq_along(NAMES)) {
[10:21:21.064]                   name <- changed[[kk]]
[10:21:21.064]                   NAME <- NAMES[[kk]]
[10:21:21.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.064]                     next
[10:21:21.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.064]                 }
[10:21:21.064]                 NAMES <- toupper(added)
[10:21:21.064]                 for (kk in seq_along(NAMES)) {
[10:21:21.064]                   name <- added[[kk]]
[10:21:21.064]                   NAME <- NAMES[[kk]]
[10:21:21.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.064]                     next
[10:21:21.064]                   args[[name]] <- ""
[10:21:21.064]                 }
[10:21:21.064]                 NAMES <- toupper(removed)
[10:21:21.064]                 for (kk in seq_along(NAMES)) {
[10:21:21.064]                   name <- removed[[kk]]
[10:21:21.064]                   NAME <- NAMES[[kk]]
[10:21:21.064]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.064]                     next
[10:21:21.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.064]                 }
[10:21:21.064]                 if (length(args) > 0) 
[10:21:21.064]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.064]             }
[10:21:21.064]             else {
[10:21:21.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.064]             }
[10:21:21.064]             {
[10:21:21.064]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.064]                   0L) {
[10:21:21.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.064]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.064]                   base::options(opts)
[10:21:21.064]                 }
[10:21:21.064]                 {
[10:21:21.064]                   {
[10:21:21.064]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.064]                     NULL
[10:21:21.064]                   }
[10:21:21.064]                   options(future.plan = NULL)
[10:21:21.064]                   if (is.na(NA_character_)) 
[10:21:21.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.064]                     .init = FALSE)
[10:21:21.064]                 }
[10:21:21.064]             }
[10:21:21.064]         }
[10:21:21.064]     })
[10:21:21.064]     if (TRUE) {
[10:21:21.064]         base::sink(type = "output", split = FALSE)
[10:21:21.064]         if (TRUE) {
[10:21:21.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.064]         }
[10:21:21.064]         else {
[10:21:21.064]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.064]         }
[10:21:21.064]         base::close(...future.stdout)
[10:21:21.064]         ...future.stdout <- NULL
[10:21:21.064]     }
[10:21:21.064]     ...future.result$conditions <- ...future.conditions
[10:21:21.064]     ...future.result$finished <- base::Sys.time()
[10:21:21.064]     ...future.result
[10:21:21.064] }
[10:21:21.067] MultisessionFuture started
[10:21:21.067] - Launch lazy future ... done
[10:21:21.067] run() for ‘MultisessionFuture’ ... done
[10:21:21.068] getGlobalsAndPackages() ...
[10:21:21.068] Searching for globals...
[10:21:21.068] 
[10:21:21.068] Searching for globals ... DONE
[10:21:21.068] - globals: [0] <none>
[10:21:21.068] getGlobalsAndPackages() ... DONE
[10:21:21.068] run() for ‘Future’ ...
[10:21:21.069] - state: ‘created’
[10:21:21.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.082] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:21.083]   - Field: ‘node’
[10:21:21.083]   - Field: ‘label’
[10:21:21.083]   - Field: ‘local’
[10:21:21.083]   - Field: ‘owner’
[10:21:21.083]   - Field: ‘envir’
[10:21:21.083]   - Field: ‘workers’
[10:21:21.083]   - Field: ‘packages’
[10:21:21.083]   - Field: ‘gc’
[10:21:21.083]   - Field: ‘conditions’
[10:21:21.084]   - Field: ‘persistent’
[10:21:21.084]   - Field: ‘expr’
[10:21:21.084]   - Field: ‘uuid’
[10:21:21.084]   - Field: ‘seed’
[10:21:21.084]   - Field: ‘version’
[10:21:21.084]   - Field: ‘result’
[10:21:21.084]   - Field: ‘asynchronous’
[10:21:21.084]   - Field: ‘calls’
[10:21:21.084]   - Field: ‘globals’
[10:21:21.084]   - Field: ‘stdout’
[10:21:21.084]   - Field: ‘earlySignal’
[10:21:21.084]   - Field: ‘lazy’
[10:21:21.085]   - Field: ‘state’
[10:21:21.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:21.085] - Launch lazy future ...
[10:21:21.085] Packages needed by the future expression (n = 0): <none>
[10:21:21.085] Packages needed by future strategies (n = 0): <none>
[10:21:21.085] {
[10:21:21.085]     {
[10:21:21.085]         {
[10:21:21.085]             ...future.startTime <- base::Sys.time()
[10:21:21.085]             {
[10:21:21.085]                 {
[10:21:21.085]                   {
[10:21:21.085]                     {
[10:21:21.085]                       base::local({
[10:21:21.085]                         has_future <- base::requireNamespace("future", 
[10:21:21.085]                           quietly = TRUE)
[10:21:21.085]                         if (has_future) {
[10:21:21.085]                           ns <- base::getNamespace("future")
[10:21:21.085]                           version <- ns[[".package"]][["version"]]
[10:21:21.085]                           if (is.null(version)) 
[10:21:21.085]                             version <- utils::packageVersion("future")
[10:21:21.085]                         }
[10:21:21.085]                         else {
[10:21:21.085]                           version <- NULL
[10:21:21.085]                         }
[10:21:21.085]                         if (!has_future || version < "1.8.0") {
[10:21:21.085]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.085]                             "", base::R.version$version.string), 
[10:21:21.085]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.085]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.085]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.085]                               "release", "version")], collapse = " "), 
[10:21:21.085]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.085]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.085]                             info)
[10:21:21.085]                           info <- base::paste(info, collapse = "; ")
[10:21:21.085]                           if (!has_future) {
[10:21:21.085]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.085]                               info)
[10:21:21.085]                           }
[10:21:21.085]                           else {
[10:21:21.085]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.085]                               info, version)
[10:21:21.085]                           }
[10:21:21.085]                           base::stop(msg)
[10:21:21.085]                         }
[10:21:21.085]                       })
[10:21:21.085]                     }
[10:21:21.085]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.085]                     base::options(mc.cores = 1L)
[10:21:21.085]                   }
[10:21:21.085]                   ...future.strategy.old <- future::plan("list")
[10:21:21.085]                   options(future.plan = NULL)
[10:21:21.085]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.085]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.085]                 }
[10:21:21.085]                 ...future.workdir <- getwd()
[10:21:21.085]             }
[10:21:21.085]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.085]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.085]         }
[10:21:21.085]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.085]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.085]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.085]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.085]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.085]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.085]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.085]             base::names(...future.oldOptions))
[10:21:21.085]     }
[10:21:21.085]     if (FALSE) {
[10:21:21.085]     }
[10:21:21.085]     else {
[10:21:21.085]         if (TRUE) {
[10:21:21.085]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.085]                 open = "w")
[10:21:21.085]         }
[10:21:21.085]         else {
[10:21:21.085]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.085]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.085]         }
[10:21:21.085]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.085]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.085]             base::sink(type = "output", split = FALSE)
[10:21:21.085]             base::close(...future.stdout)
[10:21:21.085]         }, add = TRUE)
[10:21:21.085]     }
[10:21:21.085]     ...future.frame <- base::sys.nframe()
[10:21:21.085]     ...future.conditions <- base::list()
[10:21:21.085]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.085]     if (FALSE) {
[10:21:21.085]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.085]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.085]     }
[10:21:21.085]     ...future.result <- base::tryCatch({
[10:21:21.085]         base::withCallingHandlers({
[10:21:21.085]             ...future.value <- base::withVisible(base::local({
[10:21:21.085]                 ...future.makeSendCondition <- base::local({
[10:21:21.085]                   sendCondition <- NULL
[10:21:21.085]                   function(frame = 1L) {
[10:21:21.085]                     if (is.function(sendCondition)) 
[10:21:21.085]                       return(sendCondition)
[10:21:21.085]                     ns <- getNamespace("parallel")
[10:21:21.085]                     if (exists("sendData", mode = "function", 
[10:21:21.085]                       envir = ns)) {
[10:21:21.085]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:21.085]                         envir = ns)
[10:21:21.085]                       envir <- sys.frame(frame)
[10:21:21.085]                       master <- NULL
[10:21:21.085]                       while (!identical(envir, .GlobalEnv) && 
[10:21:21.085]                         !identical(envir, emptyenv())) {
[10:21:21.085]                         if (exists("master", mode = "list", envir = envir, 
[10:21:21.085]                           inherits = FALSE)) {
[10:21:21.085]                           master <- get("master", mode = "list", 
[10:21:21.085]                             envir = envir, inherits = FALSE)
[10:21:21.085]                           if (inherits(master, c("SOCKnode", 
[10:21:21.085]                             "SOCK0node"))) {
[10:21:21.085]                             sendCondition <<- function(cond) {
[10:21:21.085]                               data <- list(type = "VALUE", value = cond, 
[10:21:21.085]                                 success = TRUE)
[10:21:21.085]                               parallel_sendData(master, data)
[10:21:21.085]                             }
[10:21:21.085]                             return(sendCondition)
[10:21:21.085]                           }
[10:21:21.085]                         }
[10:21:21.085]                         frame <- frame + 1L
[10:21:21.085]                         envir <- sys.frame(frame)
[10:21:21.085]                       }
[10:21:21.085]                     }
[10:21:21.085]                     sendCondition <<- function(cond) NULL
[10:21:21.085]                   }
[10:21:21.085]                 })
[10:21:21.085]                 withCallingHandlers({
[10:21:21.085]                   NULL
[10:21:21.085]                 }, immediateCondition = function(cond) {
[10:21:21.085]                   sendCondition <- ...future.makeSendCondition()
[10:21:21.085]                   sendCondition(cond)
[10:21:21.085]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.085]                   {
[10:21:21.085]                     inherits <- base::inherits
[10:21:21.085]                     invokeRestart <- base::invokeRestart
[10:21:21.085]                     is.null <- base::is.null
[10:21:21.085]                     muffled <- FALSE
[10:21:21.085]                     if (inherits(cond, "message")) {
[10:21:21.085]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.085]                       if (muffled) 
[10:21:21.085]                         invokeRestart("muffleMessage")
[10:21:21.085]                     }
[10:21:21.085]                     else if (inherits(cond, "warning")) {
[10:21:21.085]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.085]                       if (muffled) 
[10:21:21.085]                         invokeRestart("muffleWarning")
[10:21:21.085]                     }
[10:21:21.085]                     else if (inherits(cond, "condition")) {
[10:21:21.085]                       if (!is.null(pattern)) {
[10:21:21.085]                         computeRestarts <- base::computeRestarts
[10:21:21.085]                         grepl <- base::grepl
[10:21:21.085]                         restarts <- computeRestarts(cond)
[10:21:21.085]                         for (restart in restarts) {
[10:21:21.085]                           name <- restart$name
[10:21:21.085]                           if (is.null(name)) 
[10:21:21.085]                             next
[10:21:21.085]                           if (!grepl(pattern, name)) 
[10:21:21.085]                             next
[10:21:21.085]                           invokeRestart(restart)
[10:21:21.085]                           muffled <- TRUE
[10:21:21.085]                           break
[10:21:21.085]                         }
[10:21:21.085]                       }
[10:21:21.085]                     }
[10:21:21.085]                     invisible(muffled)
[10:21:21.085]                   }
[10:21:21.085]                   muffleCondition(cond)
[10:21:21.085]                 })
[10:21:21.085]             }))
[10:21:21.085]             future::FutureResult(value = ...future.value$value, 
[10:21:21.085]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.085]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.085]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.085]                     ...future.globalenv.names))
[10:21:21.085]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.085]         }, condition = base::local({
[10:21:21.085]             c <- base::c
[10:21:21.085]             inherits <- base::inherits
[10:21:21.085]             invokeRestart <- base::invokeRestart
[10:21:21.085]             length <- base::length
[10:21:21.085]             list <- base::list
[10:21:21.085]             seq.int <- base::seq.int
[10:21:21.085]             signalCondition <- base::signalCondition
[10:21:21.085]             sys.calls <- base::sys.calls
[10:21:21.085]             `[[` <- base::`[[`
[10:21:21.085]             `+` <- base::`+`
[10:21:21.085]             `<<-` <- base::`<<-`
[10:21:21.085]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.085]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.085]                   3L)]
[10:21:21.085]             }
[10:21:21.085]             function(cond) {
[10:21:21.085]                 is_error <- inherits(cond, "error")
[10:21:21.085]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.085]                   NULL)
[10:21:21.085]                 if (is_error) {
[10:21:21.085]                   sessionInformation <- function() {
[10:21:21.085]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.085]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.085]                       search = base::search(), system = base::Sys.info())
[10:21:21.085]                   }
[10:21:21.085]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.085]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.085]                     cond$call), session = sessionInformation(), 
[10:21:21.085]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.085]                   signalCondition(cond)
[10:21:21.085]                 }
[10:21:21.085]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.085]                 "immediateCondition"))) {
[10:21:21.085]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.085]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.085]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.085]                   if (TRUE && !signal) {
[10:21:21.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.085]                     {
[10:21:21.085]                       inherits <- base::inherits
[10:21:21.085]                       invokeRestart <- base::invokeRestart
[10:21:21.085]                       is.null <- base::is.null
[10:21:21.085]                       muffled <- FALSE
[10:21:21.085]                       if (inherits(cond, "message")) {
[10:21:21.085]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.085]                         if (muffled) 
[10:21:21.085]                           invokeRestart("muffleMessage")
[10:21:21.085]                       }
[10:21:21.085]                       else if (inherits(cond, "warning")) {
[10:21:21.085]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.085]                         if (muffled) 
[10:21:21.085]                           invokeRestart("muffleWarning")
[10:21:21.085]                       }
[10:21:21.085]                       else if (inherits(cond, "condition")) {
[10:21:21.085]                         if (!is.null(pattern)) {
[10:21:21.085]                           computeRestarts <- base::computeRestarts
[10:21:21.085]                           grepl <- base::grepl
[10:21:21.085]                           restarts <- computeRestarts(cond)
[10:21:21.085]                           for (restart in restarts) {
[10:21:21.085]                             name <- restart$name
[10:21:21.085]                             if (is.null(name)) 
[10:21:21.085]                               next
[10:21:21.085]                             if (!grepl(pattern, name)) 
[10:21:21.085]                               next
[10:21:21.085]                             invokeRestart(restart)
[10:21:21.085]                             muffled <- TRUE
[10:21:21.085]                             break
[10:21:21.085]                           }
[10:21:21.085]                         }
[10:21:21.085]                       }
[10:21:21.085]                       invisible(muffled)
[10:21:21.085]                     }
[10:21:21.085]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.085]                   }
[10:21:21.085]                 }
[10:21:21.085]                 else {
[10:21:21.085]                   if (TRUE) {
[10:21:21.085]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.085]                     {
[10:21:21.085]                       inherits <- base::inherits
[10:21:21.085]                       invokeRestart <- base::invokeRestart
[10:21:21.085]                       is.null <- base::is.null
[10:21:21.085]                       muffled <- FALSE
[10:21:21.085]                       if (inherits(cond, "message")) {
[10:21:21.085]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.085]                         if (muffled) 
[10:21:21.085]                           invokeRestart("muffleMessage")
[10:21:21.085]                       }
[10:21:21.085]                       else if (inherits(cond, "warning")) {
[10:21:21.085]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.085]                         if (muffled) 
[10:21:21.085]                           invokeRestart("muffleWarning")
[10:21:21.085]                       }
[10:21:21.085]                       else if (inherits(cond, "condition")) {
[10:21:21.085]                         if (!is.null(pattern)) {
[10:21:21.085]                           computeRestarts <- base::computeRestarts
[10:21:21.085]                           grepl <- base::grepl
[10:21:21.085]                           restarts <- computeRestarts(cond)
[10:21:21.085]                           for (restart in restarts) {
[10:21:21.085]                             name <- restart$name
[10:21:21.085]                             if (is.null(name)) 
[10:21:21.085]                               next
[10:21:21.085]                             if (!grepl(pattern, name)) 
[10:21:21.085]                               next
[10:21:21.085]                             invokeRestart(restart)
[10:21:21.085]                             muffled <- TRUE
[10:21:21.085]                             break
[10:21:21.085]                           }
[10:21:21.085]                         }
[10:21:21.085]                       }
[10:21:21.085]                       invisible(muffled)
[10:21:21.085]                     }
[10:21:21.085]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.085]                   }
[10:21:21.085]                 }
[10:21:21.085]             }
[10:21:21.085]         }))
[10:21:21.085]     }, error = function(ex) {
[10:21:21.085]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.085]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.085]                 ...future.rng), started = ...future.startTime, 
[10:21:21.085]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.085]             version = "1.8"), class = "FutureResult")
[10:21:21.085]     }, finally = {
[10:21:21.085]         if (!identical(...future.workdir, getwd())) 
[10:21:21.085]             setwd(...future.workdir)
[10:21:21.085]         {
[10:21:21.085]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.085]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.085]             }
[10:21:21.085]             base::options(...future.oldOptions)
[10:21:21.085]             if (.Platform$OS.type == "windows") {
[10:21:21.085]                 old_names <- names(...future.oldEnvVars)
[10:21:21.085]                 envs <- base::Sys.getenv()
[10:21:21.085]                 names <- names(envs)
[10:21:21.085]                 common <- intersect(names, old_names)
[10:21:21.085]                 added <- setdiff(names, old_names)
[10:21:21.085]                 removed <- setdiff(old_names, names)
[10:21:21.085]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.085]                   envs[common]]
[10:21:21.085]                 NAMES <- toupper(changed)
[10:21:21.085]                 args <- list()
[10:21:21.085]                 for (kk in seq_along(NAMES)) {
[10:21:21.085]                   name <- changed[[kk]]
[10:21:21.085]                   NAME <- NAMES[[kk]]
[10:21:21.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.085]                     next
[10:21:21.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.085]                 }
[10:21:21.085]                 NAMES <- toupper(added)
[10:21:21.085]                 for (kk in seq_along(NAMES)) {
[10:21:21.085]                   name <- added[[kk]]
[10:21:21.085]                   NAME <- NAMES[[kk]]
[10:21:21.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.085]                     next
[10:21:21.085]                   args[[name]] <- ""
[10:21:21.085]                 }
[10:21:21.085]                 NAMES <- toupper(removed)
[10:21:21.085]                 for (kk in seq_along(NAMES)) {
[10:21:21.085]                   name <- removed[[kk]]
[10:21:21.085]                   NAME <- NAMES[[kk]]
[10:21:21.085]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.085]                     next
[10:21:21.085]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.085]                 }
[10:21:21.085]                 if (length(args) > 0) 
[10:21:21.085]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.085]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.085]             }
[10:21:21.085]             else {
[10:21:21.085]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.085]             }
[10:21:21.085]             {
[10:21:21.085]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.085]                   0L) {
[10:21:21.085]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.085]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.085]                   base::options(opts)
[10:21:21.085]                 }
[10:21:21.085]                 {
[10:21:21.085]                   {
[10:21:21.085]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.085]                     NULL
[10:21:21.085]                   }
[10:21:21.085]                   options(future.plan = NULL)
[10:21:21.085]                   if (is.na(NA_character_)) 
[10:21:21.085]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.085]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.085]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.085]                     .init = FALSE)
[10:21:21.085]                 }
[10:21:21.085]             }
[10:21:21.085]         }
[10:21:21.085]     })
[10:21:21.085]     if (TRUE) {
[10:21:21.085]         base::sink(type = "output", split = FALSE)
[10:21:21.085]         if (TRUE) {
[10:21:21.085]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.085]         }
[10:21:21.085]         else {
[10:21:21.085]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.085]         }
[10:21:21.085]         base::close(...future.stdout)
[10:21:21.085]         ...future.stdout <- NULL
[10:21:21.085]     }
[10:21:21.085]     ...future.result$conditions <- ...future.conditions
[10:21:21.085]     ...future.result$finished <- base::Sys.time()
[10:21:21.085]     ...future.result
[10:21:21.085] }
[10:21:21.088] MultisessionFuture started
[10:21:21.088] - Launch lazy future ... done
[10:21:21.088] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e7632d98> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e58e9e80> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e7632d98> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e58e9e80> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:21.116] resolve() on list ...
[10:21:21.116]  recursive: 0
[10:21:21.116]  length: 6
[10:21:21.116]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:21.117] signalConditionsASAP(numeric, pos=1) ...
[10:21:21.117] - nx: 6
[10:21:21.117] - relay: TRUE
[10:21:21.117] - stdout: TRUE
[10:21:21.117] - signal: TRUE
[10:21:21.117] - resignal: FALSE
[10:21:21.117] - force: TRUE
[10:21:21.117] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.117] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.117]  - until=2
[10:21:21.117]  - relaying element #2
[10:21:21.117] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.118] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.118] signalConditionsASAP(NULL, pos=1) ... done
[10:21:21.118]  length: 5 (resolved future 1)
[10:21:21.118] receiveMessageFromWorker() for ClusterFuture ...
[10:21:21.118] - Validating connection of MultisessionFuture
[10:21:21.118] - received message: FutureResult
[10:21:21.119] - Received FutureResult
[10:21:21.119] - Erased future from FutureRegistry
[10:21:21.119] result() for ClusterFuture ...
[10:21:21.119] - result already collected: FutureResult
[10:21:21.119] result() for ClusterFuture ... done
[10:21:21.119] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:21.119] Future #2
[10:21:21.119] result() for ClusterFuture ...
[10:21:21.119] - result already collected: FutureResult
[10:21:21.119] result() for ClusterFuture ... done
[10:21:21.119] result() for ClusterFuture ...
[10:21:21.120] - result already collected: FutureResult
[10:21:21.120] result() for ClusterFuture ... done
[10:21:21.120] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:21.120] - nx: 6
[10:21:21.120] - relay: TRUE
[10:21:21.120] - stdout: TRUE
[10:21:21.120] - signal: TRUE
[10:21:21.120] - resignal: FALSE
[10:21:21.120] - force: TRUE
[10:21:21.120] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.120] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.120]  - until=2
[10:21:21.121]  - relaying element #2
[10:21:21.121] result() for ClusterFuture ...
[10:21:21.121] - result already collected: FutureResult
[10:21:21.121] result() for ClusterFuture ... done
[10:21:21.121] result() for ClusterFuture ...
[10:21:21.121] - result already collected: FutureResult
[10:21:21.121] result() for ClusterFuture ... done
[10:21:21.121] result() for ClusterFuture ...
[10:21:21.121] - result already collected: FutureResult
[10:21:21.121] result() for ClusterFuture ... done
[10:21:21.121] result() for ClusterFuture ...
[10:21:21.121] - result already collected: FutureResult
[10:21:21.122] result() for ClusterFuture ... done
[10:21:21.122] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.122] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.122] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:21.122]  length: 4 (resolved future 2)
[10:21:21.130] receiveMessageFromWorker() for ClusterFuture ...
[10:21:21.130] - Validating connection of MultisessionFuture
[10:21:21.130] - received message: FutureResult
[10:21:21.131] - Received FutureResult
[10:21:21.131] - Erased future from FutureRegistry
[10:21:21.131] result() for ClusterFuture ...
[10:21:21.131] - result already collected: FutureResult
[10:21:21.131] result() for ClusterFuture ... done
[10:21:21.131] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:21.131] Future #3
[10:21:21.131] result() for ClusterFuture ...
[10:21:21.131] - result already collected: FutureResult
[10:21:21.131] result() for ClusterFuture ... done
[10:21:21.131] result() for ClusterFuture ...
[10:21:21.131] - result already collected: FutureResult
[10:21:21.132] result() for ClusterFuture ... done
[10:21:21.132] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:21.132] - nx: 6
[10:21:21.132] - relay: TRUE
[10:21:21.132] - stdout: TRUE
[10:21:21.132] - signal: TRUE
[10:21:21.132] - resignal: FALSE
[10:21:21.132] - force: TRUE
[10:21:21.132] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.132] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.132]  - until=3
[10:21:21.132]  - relaying element #3
[10:21:21.133] result() for ClusterFuture ...
[10:21:21.133] - result already collected: FutureResult
[10:21:21.133] result() for ClusterFuture ... done
[10:21:21.133] result() for ClusterFuture ...
[10:21:21.133] - result already collected: FutureResult
[10:21:21.133] result() for ClusterFuture ... done
[10:21:21.133] result() for ClusterFuture ...
[10:21:21.133] - result already collected: FutureResult
[10:21:21.133] result() for ClusterFuture ... done
[10:21:21.133] result() for ClusterFuture ...
[10:21:21.133] - result already collected: FutureResult
[10:21:21.133] result() for ClusterFuture ... done
[10:21:21.134] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.134] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.134] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:21.134]  length: 3 (resolved future 3)
[10:21:21.134] signalConditionsASAP(NULL, pos=4) ...
[10:21:21.134] - nx: 6
[10:21:21.134] - relay: TRUE
[10:21:21.134] - stdout: TRUE
[10:21:21.134] - signal: TRUE
[10:21:21.134] - resignal: FALSE
[10:21:21.134] - force: TRUE
[10:21:21.134] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.134] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.135]  - until=5
[10:21:21.135]  - relaying element #5
[10:21:21.135] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:21.135] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.135] signalConditionsASAP(NULL, pos=4) ... done
[10:21:21.135]  length: 2 (resolved future 4)
[10:21:21.135] signalConditionsASAP(NULL, pos=5) ...
[10:21:21.135] - nx: 6
[10:21:21.135] - relay: TRUE
[10:21:21.135] - stdout: TRUE
[10:21:21.135] - signal: TRUE
[10:21:21.135] - resignal: FALSE
[10:21:21.135] - force: TRUE
[10:21:21.136] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:21.136] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.136]  - until=6
[10:21:21.136]  - relaying element #6
[10:21:21.136] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:21.136] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.136] signalConditionsASAP(NULL, pos=5) ... done
[10:21:21.136]  length: 1 (resolved future 5)
[10:21:21.137] signalConditionsASAP(numeric, pos=6) ...
[10:21:21.137] - nx: 6
[10:21:21.137] - relay: TRUE
[10:21:21.137] - stdout: TRUE
[10:21:21.137] - signal: TRUE
[10:21:21.137] - resignal: FALSE
[10:21:21.138] - force: TRUE
[10:21:21.138] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:21.138] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.138]  - until=6
[10:21:21.138] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:21.138] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.138] signalConditionsASAP(numeric, pos=6) ... done
[10:21:21.138]  length: 0 (resolved future 6)
[10:21:21.138] Relaying remaining futures
[10:21:21.138] signalConditionsASAP(NULL, pos=0) ...
[10:21:21.138] - nx: 6
[10:21:21.138] - relay: TRUE
[10:21:21.138] - stdout: TRUE
[10:21:21.139] - signal: TRUE
[10:21:21.139] - resignal: FALSE
[10:21:21.139] - force: TRUE
[10:21:21.139] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:21.139] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:21.139] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:21.139] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.139] signalConditionsASAP(NULL, pos=0) ... done
[10:21:21.139] resolve() on list ... DONE
[10:21:21.139] result() for ClusterFuture ...
[10:21:21.139] - result already collected: FutureResult
[10:21:21.140] result() for ClusterFuture ... done
[10:21:21.140] result() for ClusterFuture ...
[10:21:21.140] - result already collected: FutureResult
[10:21:21.140] result() for ClusterFuture ... done
[10:21:21.140] result() for ClusterFuture ...
[10:21:21.140] - result already collected: FutureResult
[10:21:21.140] result() for ClusterFuture ... done
[10:21:21.140] result() for ClusterFuture ...
[10:21:21.140] - result already collected: FutureResult
[10:21:21.140] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:21:21.143] getGlobalsAndPackages() ...
[10:21:21.143] Searching for globals...
[10:21:21.144] 
[10:21:21.144] Searching for globals ... DONE
[10:21:21.144] - globals: [0] <none>
[10:21:21.144] getGlobalsAndPackages() ... DONE
[10:21:21.144] run() for ‘Future’ ...
[10:21:21.144] - state: ‘created’
[10:21:21.145] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.158] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.158] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:21.159]   - Field: ‘node’
[10:21:21.159]   - Field: ‘label’
[10:21:21.159]   - Field: ‘local’
[10:21:21.159]   - Field: ‘owner’
[10:21:21.159]   - Field: ‘envir’
[10:21:21.159]   - Field: ‘workers’
[10:21:21.159]   - Field: ‘packages’
[10:21:21.159]   - Field: ‘gc’
[10:21:21.159]   - Field: ‘conditions’
[10:21:21.159]   - Field: ‘persistent’
[10:21:21.160]   - Field: ‘expr’
[10:21:21.160]   - Field: ‘uuid’
[10:21:21.160]   - Field: ‘seed’
[10:21:21.160]   - Field: ‘version’
[10:21:21.160]   - Field: ‘result’
[10:21:21.160]   - Field: ‘asynchronous’
[10:21:21.160]   - Field: ‘calls’
[10:21:21.160]   - Field: ‘globals’
[10:21:21.160]   - Field: ‘stdout’
[10:21:21.160]   - Field: ‘earlySignal’
[10:21:21.160]   - Field: ‘lazy’
[10:21:21.161]   - Field: ‘state’
[10:21:21.161] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:21.161] - Launch lazy future ...
[10:21:21.161] Packages needed by the future expression (n = 0): <none>
[10:21:21.161] Packages needed by future strategies (n = 0): <none>
[10:21:21.161] {
[10:21:21.161]     {
[10:21:21.161]         {
[10:21:21.161]             ...future.startTime <- base::Sys.time()
[10:21:21.161]             {
[10:21:21.161]                 {
[10:21:21.161]                   {
[10:21:21.161]                     {
[10:21:21.161]                       base::local({
[10:21:21.161]                         has_future <- base::requireNamespace("future", 
[10:21:21.161]                           quietly = TRUE)
[10:21:21.161]                         if (has_future) {
[10:21:21.161]                           ns <- base::getNamespace("future")
[10:21:21.161]                           version <- ns[[".package"]][["version"]]
[10:21:21.161]                           if (is.null(version)) 
[10:21:21.161]                             version <- utils::packageVersion("future")
[10:21:21.161]                         }
[10:21:21.161]                         else {
[10:21:21.161]                           version <- NULL
[10:21:21.161]                         }
[10:21:21.161]                         if (!has_future || version < "1.8.0") {
[10:21:21.161]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.161]                             "", base::R.version$version.string), 
[10:21:21.161]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.161]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.161]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.161]                               "release", "version")], collapse = " "), 
[10:21:21.161]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.161]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.161]                             info)
[10:21:21.161]                           info <- base::paste(info, collapse = "; ")
[10:21:21.161]                           if (!has_future) {
[10:21:21.161]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.161]                               info)
[10:21:21.161]                           }
[10:21:21.161]                           else {
[10:21:21.161]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.161]                               info, version)
[10:21:21.161]                           }
[10:21:21.161]                           base::stop(msg)
[10:21:21.161]                         }
[10:21:21.161]                       })
[10:21:21.161]                     }
[10:21:21.161]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.161]                     base::options(mc.cores = 1L)
[10:21:21.161]                   }
[10:21:21.161]                   ...future.strategy.old <- future::plan("list")
[10:21:21.161]                   options(future.plan = NULL)
[10:21:21.161]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.161]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.161]                 }
[10:21:21.161]                 ...future.workdir <- getwd()
[10:21:21.161]             }
[10:21:21.161]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.161]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.161]         }
[10:21:21.161]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.161]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.161]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.161]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.161]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.161]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.161]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.161]             base::names(...future.oldOptions))
[10:21:21.161]     }
[10:21:21.161]     if (FALSE) {
[10:21:21.161]     }
[10:21:21.161]     else {
[10:21:21.161]         if (TRUE) {
[10:21:21.161]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.161]                 open = "w")
[10:21:21.161]         }
[10:21:21.161]         else {
[10:21:21.161]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.161]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.161]         }
[10:21:21.161]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.161]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.161]             base::sink(type = "output", split = FALSE)
[10:21:21.161]             base::close(...future.stdout)
[10:21:21.161]         }, add = TRUE)
[10:21:21.161]     }
[10:21:21.161]     ...future.frame <- base::sys.nframe()
[10:21:21.161]     ...future.conditions <- base::list()
[10:21:21.161]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.161]     if (FALSE) {
[10:21:21.161]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.161]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.161]     }
[10:21:21.161]     ...future.result <- base::tryCatch({
[10:21:21.161]         base::withCallingHandlers({
[10:21:21.161]             ...future.value <- base::withVisible(base::local({
[10:21:21.161]                 ...future.makeSendCondition <- base::local({
[10:21:21.161]                   sendCondition <- NULL
[10:21:21.161]                   function(frame = 1L) {
[10:21:21.161]                     if (is.function(sendCondition)) 
[10:21:21.161]                       return(sendCondition)
[10:21:21.161]                     ns <- getNamespace("parallel")
[10:21:21.161]                     if (exists("sendData", mode = "function", 
[10:21:21.161]                       envir = ns)) {
[10:21:21.161]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:21.161]                         envir = ns)
[10:21:21.161]                       envir <- sys.frame(frame)
[10:21:21.161]                       master <- NULL
[10:21:21.161]                       while (!identical(envir, .GlobalEnv) && 
[10:21:21.161]                         !identical(envir, emptyenv())) {
[10:21:21.161]                         if (exists("master", mode = "list", envir = envir, 
[10:21:21.161]                           inherits = FALSE)) {
[10:21:21.161]                           master <- get("master", mode = "list", 
[10:21:21.161]                             envir = envir, inherits = FALSE)
[10:21:21.161]                           if (inherits(master, c("SOCKnode", 
[10:21:21.161]                             "SOCK0node"))) {
[10:21:21.161]                             sendCondition <<- function(cond) {
[10:21:21.161]                               data <- list(type = "VALUE", value = cond, 
[10:21:21.161]                                 success = TRUE)
[10:21:21.161]                               parallel_sendData(master, data)
[10:21:21.161]                             }
[10:21:21.161]                             return(sendCondition)
[10:21:21.161]                           }
[10:21:21.161]                         }
[10:21:21.161]                         frame <- frame + 1L
[10:21:21.161]                         envir <- sys.frame(frame)
[10:21:21.161]                       }
[10:21:21.161]                     }
[10:21:21.161]                     sendCondition <<- function(cond) NULL
[10:21:21.161]                   }
[10:21:21.161]                 })
[10:21:21.161]                 withCallingHandlers({
[10:21:21.161]                   2
[10:21:21.161]                 }, immediateCondition = function(cond) {
[10:21:21.161]                   sendCondition <- ...future.makeSendCondition()
[10:21:21.161]                   sendCondition(cond)
[10:21:21.161]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.161]                   {
[10:21:21.161]                     inherits <- base::inherits
[10:21:21.161]                     invokeRestart <- base::invokeRestart
[10:21:21.161]                     is.null <- base::is.null
[10:21:21.161]                     muffled <- FALSE
[10:21:21.161]                     if (inherits(cond, "message")) {
[10:21:21.161]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.161]                       if (muffled) 
[10:21:21.161]                         invokeRestart("muffleMessage")
[10:21:21.161]                     }
[10:21:21.161]                     else if (inherits(cond, "warning")) {
[10:21:21.161]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.161]                       if (muffled) 
[10:21:21.161]                         invokeRestart("muffleWarning")
[10:21:21.161]                     }
[10:21:21.161]                     else if (inherits(cond, "condition")) {
[10:21:21.161]                       if (!is.null(pattern)) {
[10:21:21.161]                         computeRestarts <- base::computeRestarts
[10:21:21.161]                         grepl <- base::grepl
[10:21:21.161]                         restarts <- computeRestarts(cond)
[10:21:21.161]                         for (restart in restarts) {
[10:21:21.161]                           name <- restart$name
[10:21:21.161]                           if (is.null(name)) 
[10:21:21.161]                             next
[10:21:21.161]                           if (!grepl(pattern, name)) 
[10:21:21.161]                             next
[10:21:21.161]                           invokeRestart(restart)
[10:21:21.161]                           muffled <- TRUE
[10:21:21.161]                           break
[10:21:21.161]                         }
[10:21:21.161]                       }
[10:21:21.161]                     }
[10:21:21.161]                     invisible(muffled)
[10:21:21.161]                   }
[10:21:21.161]                   muffleCondition(cond)
[10:21:21.161]                 })
[10:21:21.161]             }))
[10:21:21.161]             future::FutureResult(value = ...future.value$value, 
[10:21:21.161]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.161]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.161]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.161]                     ...future.globalenv.names))
[10:21:21.161]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.161]         }, condition = base::local({
[10:21:21.161]             c <- base::c
[10:21:21.161]             inherits <- base::inherits
[10:21:21.161]             invokeRestart <- base::invokeRestart
[10:21:21.161]             length <- base::length
[10:21:21.161]             list <- base::list
[10:21:21.161]             seq.int <- base::seq.int
[10:21:21.161]             signalCondition <- base::signalCondition
[10:21:21.161]             sys.calls <- base::sys.calls
[10:21:21.161]             `[[` <- base::`[[`
[10:21:21.161]             `+` <- base::`+`
[10:21:21.161]             `<<-` <- base::`<<-`
[10:21:21.161]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.161]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.161]                   3L)]
[10:21:21.161]             }
[10:21:21.161]             function(cond) {
[10:21:21.161]                 is_error <- inherits(cond, "error")
[10:21:21.161]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.161]                   NULL)
[10:21:21.161]                 if (is_error) {
[10:21:21.161]                   sessionInformation <- function() {
[10:21:21.161]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.161]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.161]                       search = base::search(), system = base::Sys.info())
[10:21:21.161]                   }
[10:21:21.161]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.161]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.161]                     cond$call), session = sessionInformation(), 
[10:21:21.161]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.161]                   signalCondition(cond)
[10:21:21.161]                 }
[10:21:21.161]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.161]                 "immediateCondition"))) {
[10:21:21.161]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.161]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.161]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.161]                   if (TRUE && !signal) {
[10:21:21.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.161]                     {
[10:21:21.161]                       inherits <- base::inherits
[10:21:21.161]                       invokeRestart <- base::invokeRestart
[10:21:21.161]                       is.null <- base::is.null
[10:21:21.161]                       muffled <- FALSE
[10:21:21.161]                       if (inherits(cond, "message")) {
[10:21:21.161]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.161]                         if (muffled) 
[10:21:21.161]                           invokeRestart("muffleMessage")
[10:21:21.161]                       }
[10:21:21.161]                       else if (inherits(cond, "warning")) {
[10:21:21.161]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.161]                         if (muffled) 
[10:21:21.161]                           invokeRestart("muffleWarning")
[10:21:21.161]                       }
[10:21:21.161]                       else if (inherits(cond, "condition")) {
[10:21:21.161]                         if (!is.null(pattern)) {
[10:21:21.161]                           computeRestarts <- base::computeRestarts
[10:21:21.161]                           grepl <- base::grepl
[10:21:21.161]                           restarts <- computeRestarts(cond)
[10:21:21.161]                           for (restart in restarts) {
[10:21:21.161]                             name <- restart$name
[10:21:21.161]                             if (is.null(name)) 
[10:21:21.161]                               next
[10:21:21.161]                             if (!grepl(pattern, name)) 
[10:21:21.161]                               next
[10:21:21.161]                             invokeRestart(restart)
[10:21:21.161]                             muffled <- TRUE
[10:21:21.161]                             break
[10:21:21.161]                           }
[10:21:21.161]                         }
[10:21:21.161]                       }
[10:21:21.161]                       invisible(muffled)
[10:21:21.161]                     }
[10:21:21.161]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.161]                   }
[10:21:21.161]                 }
[10:21:21.161]                 else {
[10:21:21.161]                   if (TRUE) {
[10:21:21.161]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.161]                     {
[10:21:21.161]                       inherits <- base::inherits
[10:21:21.161]                       invokeRestart <- base::invokeRestart
[10:21:21.161]                       is.null <- base::is.null
[10:21:21.161]                       muffled <- FALSE
[10:21:21.161]                       if (inherits(cond, "message")) {
[10:21:21.161]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.161]                         if (muffled) 
[10:21:21.161]                           invokeRestart("muffleMessage")
[10:21:21.161]                       }
[10:21:21.161]                       else if (inherits(cond, "warning")) {
[10:21:21.161]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.161]                         if (muffled) 
[10:21:21.161]                           invokeRestart("muffleWarning")
[10:21:21.161]                       }
[10:21:21.161]                       else if (inherits(cond, "condition")) {
[10:21:21.161]                         if (!is.null(pattern)) {
[10:21:21.161]                           computeRestarts <- base::computeRestarts
[10:21:21.161]                           grepl <- base::grepl
[10:21:21.161]                           restarts <- computeRestarts(cond)
[10:21:21.161]                           for (restart in restarts) {
[10:21:21.161]                             name <- restart$name
[10:21:21.161]                             if (is.null(name)) 
[10:21:21.161]                               next
[10:21:21.161]                             if (!grepl(pattern, name)) 
[10:21:21.161]                               next
[10:21:21.161]                             invokeRestart(restart)
[10:21:21.161]                             muffled <- TRUE
[10:21:21.161]                             break
[10:21:21.161]                           }
[10:21:21.161]                         }
[10:21:21.161]                       }
[10:21:21.161]                       invisible(muffled)
[10:21:21.161]                     }
[10:21:21.161]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.161]                   }
[10:21:21.161]                 }
[10:21:21.161]             }
[10:21:21.161]         }))
[10:21:21.161]     }, error = function(ex) {
[10:21:21.161]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.161]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.161]                 ...future.rng), started = ...future.startTime, 
[10:21:21.161]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.161]             version = "1.8"), class = "FutureResult")
[10:21:21.161]     }, finally = {
[10:21:21.161]         if (!identical(...future.workdir, getwd())) 
[10:21:21.161]             setwd(...future.workdir)
[10:21:21.161]         {
[10:21:21.161]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.161]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.161]             }
[10:21:21.161]             base::options(...future.oldOptions)
[10:21:21.161]             if (.Platform$OS.type == "windows") {
[10:21:21.161]                 old_names <- names(...future.oldEnvVars)
[10:21:21.161]                 envs <- base::Sys.getenv()
[10:21:21.161]                 names <- names(envs)
[10:21:21.161]                 common <- intersect(names, old_names)
[10:21:21.161]                 added <- setdiff(names, old_names)
[10:21:21.161]                 removed <- setdiff(old_names, names)
[10:21:21.161]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.161]                   envs[common]]
[10:21:21.161]                 NAMES <- toupper(changed)
[10:21:21.161]                 args <- list()
[10:21:21.161]                 for (kk in seq_along(NAMES)) {
[10:21:21.161]                   name <- changed[[kk]]
[10:21:21.161]                   NAME <- NAMES[[kk]]
[10:21:21.161]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.161]                     next
[10:21:21.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.161]                 }
[10:21:21.161]                 NAMES <- toupper(added)
[10:21:21.161]                 for (kk in seq_along(NAMES)) {
[10:21:21.161]                   name <- added[[kk]]
[10:21:21.161]                   NAME <- NAMES[[kk]]
[10:21:21.161]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.161]                     next
[10:21:21.161]                   args[[name]] <- ""
[10:21:21.161]                 }
[10:21:21.161]                 NAMES <- toupper(removed)
[10:21:21.161]                 for (kk in seq_along(NAMES)) {
[10:21:21.161]                   name <- removed[[kk]]
[10:21:21.161]                   NAME <- NAMES[[kk]]
[10:21:21.161]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.161]                     next
[10:21:21.161]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.161]                 }
[10:21:21.161]                 if (length(args) > 0) 
[10:21:21.161]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.161]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.161]             }
[10:21:21.161]             else {
[10:21:21.161]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.161]             }
[10:21:21.161]             {
[10:21:21.161]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.161]                   0L) {
[10:21:21.161]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.161]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.161]                   base::options(opts)
[10:21:21.161]                 }
[10:21:21.161]                 {
[10:21:21.161]                   {
[10:21:21.161]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.161]                     NULL
[10:21:21.161]                   }
[10:21:21.161]                   options(future.plan = NULL)
[10:21:21.161]                   if (is.na(NA_character_)) 
[10:21:21.161]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.161]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.161]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.161]                     .init = FALSE)
[10:21:21.161]                 }
[10:21:21.161]             }
[10:21:21.161]         }
[10:21:21.161]     })
[10:21:21.161]     if (TRUE) {
[10:21:21.161]         base::sink(type = "output", split = FALSE)
[10:21:21.161]         if (TRUE) {
[10:21:21.161]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.161]         }
[10:21:21.161]         else {
[10:21:21.161]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.161]         }
[10:21:21.161]         base::close(...future.stdout)
[10:21:21.161]         ...future.stdout <- NULL
[10:21:21.161]     }
[10:21:21.161]     ...future.result$conditions <- ...future.conditions
[10:21:21.161]     ...future.result$finished <- base::Sys.time()
[10:21:21.161]     ...future.result
[10:21:21.161] }
[10:21:21.165] MultisessionFuture started
[10:21:21.165] - Launch lazy future ... done
[10:21:21.165] run() for ‘MultisessionFuture’ ... done
[10:21:21.165] getGlobalsAndPackages() ...
[10:21:21.165] Searching for globals...
[10:21:21.165] 
[10:21:21.165] Searching for globals ... DONE
[10:21:21.165] - globals: [0] <none>
[10:21:21.166] getGlobalsAndPackages() ... DONE
[10:21:21.166] run() for ‘Future’ ...
[10:21:21.166] - state: ‘created’
[10:21:21.166] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.180] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.180] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:21.180]   - Field: ‘node’
[10:21:21.180]   - Field: ‘label’
[10:21:21.180]   - Field: ‘local’
[10:21:21.180]   - Field: ‘owner’
[10:21:21.180]   - Field: ‘envir’
[10:21:21.180]   - Field: ‘workers’
[10:21:21.180]   - Field: ‘packages’
[10:21:21.181]   - Field: ‘gc’
[10:21:21.181]   - Field: ‘conditions’
[10:21:21.181]   - Field: ‘persistent’
[10:21:21.181]   - Field: ‘expr’
[10:21:21.181]   - Field: ‘uuid’
[10:21:21.181]   - Field: ‘seed’
[10:21:21.181]   - Field: ‘version’
[10:21:21.181]   - Field: ‘result’
[10:21:21.181]   - Field: ‘asynchronous’
[10:21:21.181]   - Field: ‘calls’
[10:21:21.181]   - Field: ‘globals’
[10:21:21.181]   - Field: ‘stdout’
[10:21:21.182]   - Field: ‘earlySignal’
[10:21:21.182]   - Field: ‘lazy’
[10:21:21.182]   - Field: ‘state’
[10:21:21.182] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:21.182] - Launch lazy future ...
[10:21:21.182] Packages needed by the future expression (n = 0): <none>
[10:21:21.182] Packages needed by future strategies (n = 0): <none>
[10:21:21.183] {
[10:21:21.183]     {
[10:21:21.183]         {
[10:21:21.183]             ...future.startTime <- base::Sys.time()
[10:21:21.183]             {
[10:21:21.183]                 {
[10:21:21.183]                   {
[10:21:21.183]                     {
[10:21:21.183]                       base::local({
[10:21:21.183]                         has_future <- base::requireNamespace("future", 
[10:21:21.183]                           quietly = TRUE)
[10:21:21.183]                         if (has_future) {
[10:21:21.183]                           ns <- base::getNamespace("future")
[10:21:21.183]                           version <- ns[[".package"]][["version"]]
[10:21:21.183]                           if (is.null(version)) 
[10:21:21.183]                             version <- utils::packageVersion("future")
[10:21:21.183]                         }
[10:21:21.183]                         else {
[10:21:21.183]                           version <- NULL
[10:21:21.183]                         }
[10:21:21.183]                         if (!has_future || version < "1.8.0") {
[10:21:21.183]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.183]                             "", base::R.version$version.string), 
[10:21:21.183]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.183]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.183]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.183]                               "release", "version")], collapse = " "), 
[10:21:21.183]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.183]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.183]                             info)
[10:21:21.183]                           info <- base::paste(info, collapse = "; ")
[10:21:21.183]                           if (!has_future) {
[10:21:21.183]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.183]                               info)
[10:21:21.183]                           }
[10:21:21.183]                           else {
[10:21:21.183]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.183]                               info, version)
[10:21:21.183]                           }
[10:21:21.183]                           base::stop(msg)
[10:21:21.183]                         }
[10:21:21.183]                       })
[10:21:21.183]                     }
[10:21:21.183]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.183]                     base::options(mc.cores = 1L)
[10:21:21.183]                   }
[10:21:21.183]                   ...future.strategy.old <- future::plan("list")
[10:21:21.183]                   options(future.plan = NULL)
[10:21:21.183]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.183]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.183]                 }
[10:21:21.183]                 ...future.workdir <- getwd()
[10:21:21.183]             }
[10:21:21.183]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.183]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.183]         }
[10:21:21.183]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.183]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.183]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.183]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.183]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.183]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.183]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.183]             base::names(...future.oldOptions))
[10:21:21.183]     }
[10:21:21.183]     if (FALSE) {
[10:21:21.183]     }
[10:21:21.183]     else {
[10:21:21.183]         if (TRUE) {
[10:21:21.183]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.183]                 open = "w")
[10:21:21.183]         }
[10:21:21.183]         else {
[10:21:21.183]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.183]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.183]         }
[10:21:21.183]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.183]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.183]             base::sink(type = "output", split = FALSE)
[10:21:21.183]             base::close(...future.stdout)
[10:21:21.183]         }, add = TRUE)
[10:21:21.183]     }
[10:21:21.183]     ...future.frame <- base::sys.nframe()
[10:21:21.183]     ...future.conditions <- base::list()
[10:21:21.183]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.183]     if (FALSE) {
[10:21:21.183]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.183]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.183]     }
[10:21:21.183]     ...future.result <- base::tryCatch({
[10:21:21.183]         base::withCallingHandlers({
[10:21:21.183]             ...future.value <- base::withVisible(base::local({
[10:21:21.183]                 ...future.makeSendCondition <- base::local({
[10:21:21.183]                   sendCondition <- NULL
[10:21:21.183]                   function(frame = 1L) {
[10:21:21.183]                     if (is.function(sendCondition)) 
[10:21:21.183]                       return(sendCondition)
[10:21:21.183]                     ns <- getNamespace("parallel")
[10:21:21.183]                     if (exists("sendData", mode = "function", 
[10:21:21.183]                       envir = ns)) {
[10:21:21.183]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:21.183]                         envir = ns)
[10:21:21.183]                       envir <- sys.frame(frame)
[10:21:21.183]                       master <- NULL
[10:21:21.183]                       while (!identical(envir, .GlobalEnv) && 
[10:21:21.183]                         !identical(envir, emptyenv())) {
[10:21:21.183]                         if (exists("master", mode = "list", envir = envir, 
[10:21:21.183]                           inherits = FALSE)) {
[10:21:21.183]                           master <- get("master", mode = "list", 
[10:21:21.183]                             envir = envir, inherits = FALSE)
[10:21:21.183]                           if (inherits(master, c("SOCKnode", 
[10:21:21.183]                             "SOCK0node"))) {
[10:21:21.183]                             sendCondition <<- function(cond) {
[10:21:21.183]                               data <- list(type = "VALUE", value = cond, 
[10:21:21.183]                                 success = TRUE)
[10:21:21.183]                               parallel_sendData(master, data)
[10:21:21.183]                             }
[10:21:21.183]                             return(sendCondition)
[10:21:21.183]                           }
[10:21:21.183]                         }
[10:21:21.183]                         frame <- frame + 1L
[10:21:21.183]                         envir <- sys.frame(frame)
[10:21:21.183]                       }
[10:21:21.183]                     }
[10:21:21.183]                     sendCondition <<- function(cond) NULL
[10:21:21.183]                   }
[10:21:21.183]                 })
[10:21:21.183]                 withCallingHandlers({
[10:21:21.183]                   NULL
[10:21:21.183]                 }, immediateCondition = function(cond) {
[10:21:21.183]                   sendCondition <- ...future.makeSendCondition()
[10:21:21.183]                   sendCondition(cond)
[10:21:21.183]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.183]                   {
[10:21:21.183]                     inherits <- base::inherits
[10:21:21.183]                     invokeRestart <- base::invokeRestart
[10:21:21.183]                     is.null <- base::is.null
[10:21:21.183]                     muffled <- FALSE
[10:21:21.183]                     if (inherits(cond, "message")) {
[10:21:21.183]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.183]                       if (muffled) 
[10:21:21.183]                         invokeRestart("muffleMessage")
[10:21:21.183]                     }
[10:21:21.183]                     else if (inherits(cond, "warning")) {
[10:21:21.183]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.183]                       if (muffled) 
[10:21:21.183]                         invokeRestart("muffleWarning")
[10:21:21.183]                     }
[10:21:21.183]                     else if (inherits(cond, "condition")) {
[10:21:21.183]                       if (!is.null(pattern)) {
[10:21:21.183]                         computeRestarts <- base::computeRestarts
[10:21:21.183]                         grepl <- base::grepl
[10:21:21.183]                         restarts <- computeRestarts(cond)
[10:21:21.183]                         for (restart in restarts) {
[10:21:21.183]                           name <- restart$name
[10:21:21.183]                           if (is.null(name)) 
[10:21:21.183]                             next
[10:21:21.183]                           if (!grepl(pattern, name)) 
[10:21:21.183]                             next
[10:21:21.183]                           invokeRestart(restart)
[10:21:21.183]                           muffled <- TRUE
[10:21:21.183]                           break
[10:21:21.183]                         }
[10:21:21.183]                       }
[10:21:21.183]                     }
[10:21:21.183]                     invisible(muffled)
[10:21:21.183]                   }
[10:21:21.183]                   muffleCondition(cond)
[10:21:21.183]                 })
[10:21:21.183]             }))
[10:21:21.183]             future::FutureResult(value = ...future.value$value, 
[10:21:21.183]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.183]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.183]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.183]                     ...future.globalenv.names))
[10:21:21.183]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.183]         }, condition = base::local({
[10:21:21.183]             c <- base::c
[10:21:21.183]             inherits <- base::inherits
[10:21:21.183]             invokeRestart <- base::invokeRestart
[10:21:21.183]             length <- base::length
[10:21:21.183]             list <- base::list
[10:21:21.183]             seq.int <- base::seq.int
[10:21:21.183]             signalCondition <- base::signalCondition
[10:21:21.183]             sys.calls <- base::sys.calls
[10:21:21.183]             `[[` <- base::`[[`
[10:21:21.183]             `+` <- base::`+`
[10:21:21.183]             `<<-` <- base::`<<-`
[10:21:21.183]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.183]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.183]                   3L)]
[10:21:21.183]             }
[10:21:21.183]             function(cond) {
[10:21:21.183]                 is_error <- inherits(cond, "error")
[10:21:21.183]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.183]                   NULL)
[10:21:21.183]                 if (is_error) {
[10:21:21.183]                   sessionInformation <- function() {
[10:21:21.183]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.183]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.183]                       search = base::search(), system = base::Sys.info())
[10:21:21.183]                   }
[10:21:21.183]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.183]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.183]                     cond$call), session = sessionInformation(), 
[10:21:21.183]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.183]                   signalCondition(cond)
[10:21:21.183]                 }
[10:21:21.183]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.183]                 "immediateCondition"))) {
[10:21:21.183]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.183]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.183]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.183]                   if (TRUE && !signal) {
[10:21:21.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.183]                     {
[10:21:21.183]                       inherits <- base::inherits
[10:21:21.183]                       invokeRestart <- base::invokeRestart
[10:21:21.183]                       is.null <- base::is.null
[10:21:21.183]                       muffled <- FALSE
[10:21:21.183]                       if (inherits(cond, "message")) {
[10:21:21.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.183]                         if (muffled) 
[10:21:21.183]                           invokeRestart("muffleMessage")
[10:21:21.183]                       }
[10:21:21.183]                       else if (inherits(cond, "warning")) {
[10:21:21.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.183]                         if (muffled) 
[10:21:21.183]                           invokeRestart("muffleWarning")
[10:21:21.183]                       }
[10:21:21.183]                       else if (inherits(cond, "condition")) {
[10:21:21.183]                         if (!is.null(pattern)) {
[10:21:21.183]                           computeRestarts <- base::computeRestarts
[10:21:21.183]                           grepl <- base::grepl
[10:21:21.183]                           restarts <- computeRestarts(cond)
[10:21:21.183]                           for (restart in restarts) {
[10:21:21.183]                             name <- restart$name
[10:21:21.183]                             if (is.null(name)) 
[10:21:21.183]                               next
[10:21:21.183]                             if (!grepl(pattern, name)) 
[10:21:21.183]                               next
[10:21:21.183]                             invokeRestart(restart)
[10:21:21.183]                             muffled <- TRUE
[10:21:21.183]                             break
[10:21:21.183]                           }
[10:21:21.183]                         }
[10:21:21.183]                       }
[10:21:21.183]                       invisible(muffled)
[10:21:21.183]                     }
[10:21:21.183]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.183]                   }
[10:21:21.183]                 }
[10:21:21.183]                 else {
[10:21:21.183]                   if (TRUE) {
[10:21:21.183]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.183]                     {
[10:21:21.183]                       inherits <- base::inherits
[10:21:21.183]                       invokeRestart <- base::invokeRestart
[10:21:21.183]                       is.null <- base::is.null
[10:21:21.183]                       muffled <- FALSE
[10:21:21.183]                       if (inherits(cond, "message")) {
[10:21:21.183]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.183]                         if (muffled) 
[10:21:21.183]                           invokeRestart("muffleMessage")
[10:21:21.183]                       }
[10:21:21.183]                       else if (inherits(cond, "warning")) {
[10:21:21.183]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.183]                         if (muffled) 
[10:21:21.183]                           invokeRestart("muffleWarning")
[10:21:21.183]                       }
[10:21:21.183]                       else if (inherits(cond, "condition")) {
[10:21:21.183]                         if (!is.null(pattern)) {
[10:21:21.183]                           computeRestarts <- base::computeRestarts
[10:21:21.183]                           grepl <- base::grepl
[10:21:21.183]                           restarts <- computeRestarts(cond)
[10:21:21.183]                           for (restart in restarts) {
[10:21:21.183]                             name <- restart$name
[10:21:21.183]                             if (is.null(name)) 
[10:21:21.183]                               next
[10:21:21.183]                             if (!grepl(pattern, name)) 
[10:21:21.183]                               next
[10:21:21.183]                             invokeRestart(restart)
[10:21:21.183]                             muffled <- TRUE
[10:21:21.183]                             break
[10:21:21.183]                           }
[10:21:21.183]                         }
[10:21:21.183]                       }
[10:21:21.183]                       invisible(muffled)
[10:21:21.183]                     }
[10:21:21.183]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.183]                   }
[10:21:21.183]                 }
[10:21:21.183]             }
[10:21:21.183]         }))
[10:21:21.183]     }, error = function(ex) {
[10:21:21.183]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.183]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.183]                 ...future.rng), started = ...future.startTime, 
[10:21:21.183]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.183]             version = "1.8"), class = "FutureResult")
[10:21:21.183]     }, finally = {
[10:21:21.183]         if (!identical(...future.workdir, getwd())) 
[10:21:21.183]             setwd(...future.workdir)
[10:21:21.183]         {
[10:21:21.183]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.183]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.183]             }
[10:21:21.183]             base::options(...future.oldOptions)
[10:21:21.183]             if (.Platform$OS.type == "windows") {
[10:21:21.183]                 old_names <- names(...future.oldEnvVars)
[10:21:21.183]                 envs <- base::Sys.getenv()
[10:21:21.183]                 names <- names(envs)
[10:21:21.183]                 common <- intersect(names, old_names)
[10:21:21.183]                 added <- setdiff(names, old_names)
[10:21:21.183]                 removed <- setdiff(old_names, names)
[10:21:21.183]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.183]                   envs[common]]
[10:21:21.183]                 NAMES <- toupper(changed)
[10:21:21.183]                 args <- list()
[10:21:21.183]                 for (kk in seq_along(NAMES)) {
[10:21:21.183]                   name <- changed[[kk]]
[10:21:21.183]                   NAME <- NAMES[[kk]]
[10:21:21.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.183]                     next
[10:21:21.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.183]                 }
[10:21:21.183]                 NAMES <- toupper(added)
[10:21:21.183]                 for (kk in seq_along(NAMES)) {
[10:21:21.183]                   name <- added[[kk]]
[10:21:21.183]                   NAME <- NAMES[[kk]]
[10:21:21.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.183]                     next
[10:21:21.183]                   args[[name]] <- ""
[10:21:21.183]                 }
[10:21:21.183]                 NAMES <- toupper(removed)
[10:21:21.183]                 for (kk in seq_along(NAMES)) {
[10:21:21.183]                   name <- removed[[kk]]
[10:21:21.183]                   NAME <- NAMES[[kk]]
[10:21:21.183]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.183]                     next
[10:21:21.183]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.183]                 }
[10:21:21.183]                 if (length(args) > 0) 
[10:21:21.183]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.183]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.183]             }
[10:21:21.183]             else {
[10:21:21.183]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.183]             }
[10:21:21.183]             {
[10:21:21.183]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.183]                   0L) {
[10:21:21.183]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.183]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.183]                   base::options(opts)
[10:21:21.183]                 }
[10:21:21.183]                 {
[10:21:21.183]                   {
[10:21:21.183]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.183]                     NULL
[10:21:21.183]                   }
[10:21:21.183]                   options(future.plan = NULL)
[10:21:21.183]                   if (is.na(NA_character_)) 
[10:21:21.183]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.183]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.183]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.183]                     .init = FALSE)
[10:21:21.183]                 }
[10:21:21.183]             }
[10:21:21.183]         }
[10:21:21.183]     })
[10:21:21.183]     if (TRUE) {
[10:21:21.183]         base::sink(type = "output", split = FALSE)
[10:21:21.183]         if (TRUE) {
[10:21:21.183]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.183]         }
[10:21:21.183]         else {
[10:21:21.183]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.183]         }
[10:21:21.183]         base::close(...future.stdout)
[10:21:21.183]         ...future.stdout <- NULL
[10:21:21.183]     }
[10:21:21.183]     ...future.result$conditions <- ...future.conditions
[10:21:21.183]     ...future.result$finished <- base::Sys.time()
[10:21:21.183]     ...future.result
[10:21:21.183] }
[10:21:21.186] MultisessionFuture started
[10:21:21.186] - Launch lazy future ... done
[10:21:21.186] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e68160e8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e6b5d300> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e68160e8> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55e8e6b5d300> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[10:21:21.214] resolve() on list ...
[10:21:21.214]  recursive: 0
[10:21:21.214]  length: 6
[10:21:21.214]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[10:21:21.214] signalConditionsASAP(numeric, pos=1) ...
[10:21:21.215] - nx: 6
[10:21:21.215] - relay: TRUE
[10:21:21.215] - stdout: TRUE
[10:21:21.215] - signal: TRUE
[10:21:21.215] - resignal: FALSE
[10:21:21.215] - force: TRUE
[10:21:21.215] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.215] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.215]  - until=2
[10:21:21.215]  - relaying element #2
[10:21:21.215] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.215] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.216] signalConditionsASAP(NULL, pos=1) ... done
[10:21:21.216]  length: 5 (resolved future 1)
[10:21:21.216] receiveMessageFromWorker() for ClusterFuture ...
[10:21:21.216] - Validating connection of MultisessionFuture
[10:21:21.216] - received message: FutureResult
[10:21:21.216] - Received FutureResult
[10:21:21.217] - Erased future from FutureRegistry
[10:21:21.217] result() for ClusterFuture ...
[10:21:21.217] - result already collected: FutureResult
[10:21:21.217] result() for ClusterFuture ... done
[10:21:21.217] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:21.217] Future #2
[10:21:21.217] result() for ClusterFuture ...
[10:21:21.217] - result already collected: FutureResult
[10:21:21.217] result() for ClusterFuture ... done
[10:21:21.217] result() for ClusterFuture ...
[10:21:21.218] - result already collected: FutureResult
[10:21:21.218] result() for ClusterFuture ... done
[10:21:21.218] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:21.218] - nx: 6
[10:21:21.218] - relay: TRUE
[10:21:21.218] - stdout: TRUE
[10:21:21.218] - signal: TRUE
[10:21:21.218] - resignal: FALSE
[10:21:21.218] - force: TRUE
[10:21:21.218] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.218] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:21.218]  - until=2
[10:21:21.219]  - relaying element #2
[10:21:21.219] result() for ClusterFuture ...
[10:21:21.219] - result already collected: FutureResult
[10:21:21.219] result() for ClusterFuture ... done
[10:21:21.219] result() for ClusterFuture ...
[10:21:21.219] - result already collected: FutureResult
[10:21:21.219] result() for ClusterFuture ... done
[10:21:21.219] result() for ClusterFuture ...
[10:21:21.219] - result already collected: FutureResult
[10:21:21.219] result() for ClusterFuture ... done
[10:21:21.219] result() for ClusterFuture ...
[10:21:21.219] - result already collected: FutureResult
[10:21:21.220] result() for ClusterFuture ... done
[10:21:21.220] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.220] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.220] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:21.220]  length: 4 (resolved future 2)
[10:21:21.228] receiveMessageFromWorker() for ClusterFuture ...
[10:21:21.228] - Validating connection of MultisessionFuture
[10:21:21.229] - received message: FutureResult
[10:21:21.229] - Received FutureResult
[10:21:21.229] - Erased future from FutureRegistry
[10:21:21.229] result() for ClusterFuture ...
[10:21:21.229] - result already collected: FutureResult
[10:21:21.229] result() for ClusterFuture ... done
[10:21:21.229] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:21.229] Future #3
[10:21:21.229] result() for ClusterFuture ...
[10:21:21.229] - result already collected: FutureResult
[10:21:21.230] result() for ClusterFuture ... done
[10:21:21.230] result() for ClusterFuture ...
[10:21:21.230] - result already collected: FutureResult
[10:21:21.230] result() for ClusterFuture ... done
[10:21:21.230] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:21.230] - nx: 6
[10:21:21.230] - relay: TRUE
[10:21:21.230] - stdout: TRUE
[10:21:21.230] - signal: TRUE
[10:21:21.230] - resignal: FALSE
[10:21:21.230] - force: TRUE
[10:21:21.235] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.235] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:21.236]  - until=3
[10:21:21.236]  - relaying element #3
[10:21:21.236] result() for ClusterFuture ...
[10:21:21.236] - result already collected: FutureResult
[10:21:21.237] result() for ClusterFuture ... done
[10:21:21.237] result() for ClusterFuture ...
[10:21:21.237] - result already collected: FutureResult
[10:21:21.237] result() for ClusterFuture ... done
[10:21:21.238] result() for ClusterFuture ...
[10:21:21.238] - result already collected: FutureResult
[10:21:21.238] result() for ClusterFuture ... done
[10:21:21.238] result() for ClusterFuture ...
[10:21:21.238] - result already collected: FutureResult
[10:21:21.238] result() for ClusterFuture ... done
[10:21:21.238] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.239] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.239] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:21.239]  length: 3 (resolved future 3)
[10:21:21.239] signalConditionsASAP(NULL, pos=4) ...
[10:21:21.239] - nx: 6
[10:21:21.239] - relay: TRUE
[10:21:21.239] - stdout: TRUE
[10:21:21.239] - signal: TRUE
[10:21:21.240] - resignal: FALSE
[10:21:21.240] - force: TRUE
[10:21:21.240] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.240] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.240]  - until=5
[10:21:21.240]  - relaying element #5
[10:21:21.240] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:21.241] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.241] signalConditionsASAP(NULL, pos=4) ... done
[10:21:21.241]  length: 2 (resolved future 4)
[10:21:21.241] signalConditionsASAP(NULL, pos=5) ...
[10:21:21.241] - nx: 6
[10:21:21.241] - relay: TRUE
[10:21:21.242] - stdout: TRUE
[10:21:21.242] - signal: TRUE
[10:21:21.242] - resignal: FALSE
[10:21:21.242] - force: TRUE
[10:21:21.242] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:21.242] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.242]  - until=6
[10:21:21.243]  - relaying element #6
[10:21:21.243] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:21.243] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.243] signalConditionsASAP(NULL, pos=5) ... done
[10:21:21.243]  length: 1 (resolved future 5)
[10:21:21.244] signalConditionsASAP(numeric, pos=6) ...
[10:21:21.244] - nx: 6
[10:21:21.244] - relay: TRUE
[10:21:21.244] - stdout: TRUE
[10:21:21.244] - signal: TRUE
[10:21:21.244] - resignal: FALSE
[10:21:21.244] - force: TRUE
[10:21:21.245] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:21.245] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.245]  - until=6
[10:21:21.245] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:21.245] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.245] signalConditionsASAP(numeric, pos=6) ... done
[10:21:21.245]  length: 0 (resolved future 6)
[10:21:21.246] Relaying remaining futures
[10:21:21.246] signalConditionsASAP(NULL, pos=0) ...
[10:21:21.246] - nx: 6
[10:21:21.246] - relay: TRUE
[10:21:21.246] - stdout: TRUE
[10:21:21.246] - signal: TRUE
[10:21:21.247] - resignal: FALSE
[10:21:21.247] - force: TRUE
[10:21:21.247] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:21.247] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[10:21:21.247] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:21.247] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:21.248] signalConditionsASAP(NULL, pos=0) ... done
[10:21:21.248] resolve() on list ... DONE
[10:21:21.248] result() for ClusterFuture ...
[10:21:21.248] - result already collected: FutureResult
[10:21:21.248] result() for ClusterFuture ... done
[10:21:21.248] result() for ClusterFuture ...
[10:21:21.249] - result already collected: FutureResult
[10:21:21.249] result() for ClusterFuture ... done
[10:21:21.249] result() for ClusterFuture ...
[10:21:21.249] - result already collected: FutureResult
[10:21:21.249] result() for ClusterFuture ... done
[10:21:21.249] result() for ClusterFuture ...
[10:21:21.250] - result already collected: FutureResult
[10:21:21.250] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[10:21:21.256] plan(): Setting new future strategy stack:
[10:21:21.256] List of future strategies:
[10:21:21.256] 1. multicore:
[10:21:21.256]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.256]    - tweaked: FALSE
[10:21:21.256]    - call: plan(strategy)
[10:21:21.260] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:21:21.260] getGlobalsAndPackages() ...
[10:21:21.260] Searching for globals...
[10:21:21.261] 
[10:21:21.261] Searching for globals ... DONE
[10:21:21.261] - globals: [0] <none>
[10:21:21.261] getGlobalsAndPackages() ... DONE
[10:21:21.262] run() for ‘Future’ ...
[10:21:21.262] - state: ‘created’
[10:21:21.262] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.264] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.265] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.265]   - Field: ‘label’
[10:21:21.265]   - Field: ‘local’
[10:21:21.265]   - Field: ‘owner’
[10:21:21.265]   - Field: ‘envir’
[10:21:21.265]   - Field: ‘workers’
[10:21:21.265]   - Field: ‘packages’
[10:21:21.266]   - Field: ‘gc’
[10:21:21.266]   - Field: ‘job’
[10:21:21.266]   - Field: ‘conditions’
[10:21:21.266]   - Field: ‘expr’
[10:21:21.266]   - Field: ‘uuid’
[10:21:21.266]   - Field: ‘seed’
[10:21:21.266]   - Field: ‘version’
[10:21:21.266]   - Field: ‘result’
[10:21:21.267]   - Field: ‘asynchronous’
[10:21:21.267]   - Field: ‘calls’
[10:21:21.267]   - Field: ‘globals’
[10:21:21.267]   - Field: ‘stdout’
[10:21:21.267]   - Field: ‘earlySignal’
[10:21:21.267]   - Field: ‘lazy’
[10:21:21.267]   - Field: ‘state’
[10:21:21.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.268] - Launch lazy future ...
[10:21:21.268] Packages needed by the future expression (n = 0): <none>
[10:21:21.268] Packages needed by future strategies (n = 0): <none>
[10:21:21.269] {
[10:21:21.269]     {
[10:21:21.269]         {
[10:21:21.269]             ...future.startTime <- base::Sys.time()
[10:21:21.269]             {
[10:21:21.269]                 {
[10:21:21.269]                   {
[10:21:21.269]                     {
[10:21:21.269]                       base::local({
[10:21:21.269]                         has_future <- base::requireNamespace("future", 
[10:21:21.269]                           quietly = TRUE)
[10:21:21.269]                         if (has_future) {
[10:21:21.269]                           ns <- base::getNamespace("future")
[10:21:21.269]                           version <- ns[[".package"]][["version"]]
[10:21:21.269]                           if (is.null(version)) 
[10:21:21.269]                             version <- utils::packageVersion("future")
[10:21:21.269]                         }
[10:21:21.269]                         else {
[10:21:21.269]                           version <- NULL
[10:21:21.269]                         }
[10:21:21.269]                         if (!has_future || version < "1.8.0") {
[10:21:21.269]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.269]                             "", base::R.version$version.string), 
[10:21:21.269]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.269]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.269]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.269]                               "release", "version")], collapse = " "), 
[10:21:21.269]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.269]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.269]                             info)
[10:21:21.269]                           info <- base::paste(info, collapse = "; ")
[10:21:21.269]                           if (!has_future) {
[10:21:21.269]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.269]                               info)
[10:21:21.269]                           }
[10:21:21.269]                           else {
[10:21:21.269]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.269]                               info, version)
[10:21:21.269]                           }
[10:21:21.269]                           base::stop(msg)
[10:21:21.269]                         }
[10:21:21.269]                       })
[10:21:21.269]                     }
[10:21:21.269]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.269]                     base::options(mc.cores = 1L)
[10:21:21.269]                   }
[10:21:21.269]                   ...future.strategy.old <- future::plan("list")
[10:21:21.269]                   options(future.plan = NULL)
[10:21:21.269]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.269]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.269]                 }
[10:21:21.269]                 ...future.workdir <- getwd()
[10:21:21.269]             }
[10:21:21.269]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.269]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.269]         }
[10:21:21.269]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.269]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.269]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.269]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.269]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.269]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.269]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.269]             base::names(...future.oldOptions))
[10:21:21.269]     }
[10:21:21.269]     if (FALSE) {
[10:21:21.269]     }
[10:21:21.269]     else {
[10:21:21.269]         if (TRUE) {
[10:21:21.269]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.269]                 open = "w")
[10:21:21.269]         }
[10:21:21.269]         else {
[10:21:21.269]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.269]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.269]         }
[10:21:21.269]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.269]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.269]             base::sink(type = "output", split = FALSE)
[10:21:21.269]             base::close(...future.stdout)
[10:21:21.269]         }, add = TRUE)
[10:21:21.269]     }
[10:21:21.269]     ...future.frame <- base::sys.nframe()
[10:21:21.269]     ...future.conditions <- base::list()
[10:21:21.269]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.269]     if (FALSE) {
[10:21:21.269]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.269]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.269]     }
[10:21:21.269]     ...future.result <- base::tryCatch({
[10:21:21.269]         base::withCallingHandlers({
[10:21:21.269]             ...future.value <- base::withVisible(base::local({
[10:21:21.269]                 withCallingHandlers({
[10:21:21.269]                   2
[10:21:21.269]                 }, immediateCondition = function(cond) {
[10:21:21.269]                   save_rds <- function (object, pathname, ...) 
[10:21:21.269]                   {
[10:21:21.269]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.269]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.269]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.269]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.269]                         fi_tmp[["mtime"]])
[10:21:21.269]                     }
[10:21:21.269]                     tryCatch({
[10:21:21.269]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.269]                     }, error = function(ex) {
[10:21:21.269]                       msg <- conditionMessage(ex)
[10:21:21.269]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.269]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.269]                         fi_tmp[["mtime"]], msg)
[10:21:21.269]                       ex$message <- msg
[10:21:21.269]                       stop(ex)
[10:21:21.269]                     })
[10:21:21.269]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.269]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.269]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.269]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.269]                       fi <- file.info(pathname)
[10:21:21.269]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.269]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.269]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.269]                         fi[["size"]], fi[["mtime"]])
[10:21:21.269]                       stop(msg)
[10:21:21.269]                     }
[10:21:21.269]                     invisible(pathname)
[10:21:21.269]                   }
[10:21:21.269]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.269]                     rootPath = tempdir()) 
[10:21:21.269]                   {
[10:21:21.269]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.269]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.269]                       tmpdir = path, fileext = ".rds")
[10:21:21.269]                     save_rds(obj, file)
[10:21:21.269]                   }
[10:21:21.269]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.269]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.269]                   {
[10:21:21.269]                     inherits <- base::inherits
[10:21:21.269]                     invokeRestart <- base::invokeRestart
[10:21:21.269]                     is.null <- base::is.null
[10:21:21.269]                     muffled <- FALSE
[10:21:21.269]                     if (inherits(cond, "message")) {
[10:21:21.269]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.269]                       if (muffled) 
[10:21:21.269]                         invokeRestart("muffleMessage")
[10:21:21.269]                     }
[10:21:21.269]                     else if (inherits(cond, "warning")) {
[10:21:21.269]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.269]                       if (muffled) 
[10:21:21.269]                         invokeRestart("muffleWarning")
[10:21:21.269]                     }
[10:21:21.269]                     else if (inherits(cond, "condition")) {
[10:21:21.269]                       if (!is.null(pattern)) {
[10:21:21.269]                         computeRestarts <- base::computeRestarts
[10:21:21.269]                         grepl <- base::grepl
[10:21:21.269]                         restarts <- computeRestarts(cond)
[10:21:21.269]                         for (restart in restarts) {
[10:21:21.269]                           name <- restart$name
[10:21:21.269]                           if (is.null(name)) 
[10:21:21.269]                             next
[10:21:21.269]                           if (!grepl(pattern, name)) 
[10:21:21.269]                             next
[10:21:21.269]                           invokeRestart(restart)
[10:21:21.269]                           muffled <- TRUE
[10:21:21.269]                           break
[10:21:21.269]                         }
[10:21:21.269]                       }
[10:21:21.269]                     }
[10:21:21.269]                     invisible(muffled)
[10:21:21.269]                   }
[10:21:21.269]                   muffleCondition(cond)
[10:21:21.269]                 })
[10:21:21.269]             }))
[10:21:21.269]             future::FutureResult(value = ...future.value$value, 
[10:21:21.269]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.269]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.269]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.269]                     ...future.globalenv.names))
[10:21:21.269]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.269]         }, condition = base::local({
[10:21:21.269]             c <- base::c
[10:21:21.269]             inherits <- base::inherits
[10:21:21.269]             invokeRestart <- base::invokeRestart
[10:21:21.269]             length <- base::length
[10:21:21.269]             list <- base::list
[10:21:21.269]             seq.int <- base::seq.int
[10:21:21.269]             signalCondition <- base::signalCondition
[10:21:21.269]             sys.calls <- base::sys.calls
[10:21:21.269]             `[[` <- base::`[[`
[10:21:21.269]             `+` <- base::`+`
[10:21:21.269]             `<<-` <- base::`<<-`
[10:21:21.269]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.269]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.269]                   3L)]
[10:21:21.269]             }
[10:21:21.269]             function(cond) {
[10:21:21.269]                 is_error <- inherits(cond, "error")
[10:21:21.269]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.269]                   NULL)
[10:21:21.269]                 if (is_error) {
[10:21:21.269]                   sessionInformation <- function() {
[10:21:21.269]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.269]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.269]                       search = base::search(), system = base::Sys.info())
[10:21:21.269]                   }
[10:21:21.269]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.269]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.269]                     cond$call), session = sessionInformation(), 
[10:21:21.269]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.269]                   signalCondition(cond)
[10:21:21.269]                 }
[10:21:21.269]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.269]                 "immediateCondition"))) {
[10:21:21.269]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.269]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.269]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.269]                   if (TRUE && !signal) {
[10:21:21.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.269]                     {
[10:21:21.269]                       inherits <- base::inherits
[10:21:21.269]                       invokeRestart <- base::invokeRestart
[10:21:21.269]                       is.null <- base::is.null
[10:21:21.269]                       muffled <- FALSE
[10:21:21.269]                       if (inherits(cond, "message")) {
[10:21:21.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.269]                         if (muffled) 
[10:21:21.269]                           invokeRestart("muffleMessage")
[10:21:21.269]                       }
[10:21:21.269]                       else if (inherits(cond, "warning")) {
[10:21:21.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.269]                         if (muffled) 
[10:21:21.269]                           invokeRestart("muffleWarning")
[10:21:21.269]                       }
[10:21:21.269]                       else if (inherits(cond, "condition")) {
[10:21:21.269]                         if (!is.null(pattern)) {
[10:21:21.269]                           computeRestarts <- base::computeRestarts
[10:21:21.269]                           grepl <- base::grepl
[10:21:21.269]                           restarts <- computeRestarts(cond)
[10:21:21.269]                           for (restart in restarts) {
[10:21:21.269]                             name <- restart$name
[10:21:21.269]                             if (is.null(name)) 
[10:21:21.269]                               next
[10:21:21.269]                             if (!grepl(pattern, name)) 
[10:21:21.269]                               next
[10:21:21.269]                             invokeRestart(restart)
[10:21:21.269]                             muffled <- TRUE
[10:21:21.269]                             break
[10:21:21.269]                           }
[10:21:21.269]                         }
[10:21:21.269]                       }
[10:21:21.269]                       invisible(muffled)
[10:21:21.269]                     }
[10:21:21.269]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.269]                   }
[10:21:21.269]                 }
[10:21:21.269]                 else {
[10:21:21.269]                   if (TRUE) {
[10:21:21.269]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.269]                     {
[10:21:21.269]                       inherits <- base::inherits
[10:21:21.269]                       invokeRestart <- base::invokeRestart
[10:21:21.269]                       is.null <- base::is.null
[10:21:21.269]                       muffled <- FALSE
[10:21:21.269]                       if (inherits(cond, "message")) {
[10:21:21.269]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.269]                         if (muffled) 
[10:21:21.269]                           invokeRestart("muffleMessage")
[10:21:21.269]                       }
[10:21:21.269]                       else if (inherits(cond, "warning")) {
[10:21:21.269]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.269]                         if (muffled) 
[10:21:21.269]                           invokeRestart("muffleWarning")
[10:21:21.269]                       }
[10:21:21.269]                       else if (inherits(cond, "condition")) {
[10:21:21.269]                         if (!is.null(pattern)) {
[10:21:21.269]                           computeRestarts <- base::computeRestarts
[10:21:21.269]                           grepl <- base::grepl
[10:21:21.269]                           restarts <- computeRestarts(cond)
[10:21:21.269]                           for (restart in restarts) {
[10:21:21.269]                             name <- restart$name
[10:21:21.269]                             if (is.null(name)) 
[10:21:21.269]                               next
[10:21:21.269]                             if (!grepl(pattern, name)) 
[10:21:21.269]                               next
[10:21:21.269]                             invokeRestart(restart)
[10:21:21.269]                             muffled <- TRUE
[10:21:21.269]                             break
[10:21:21.269]                           }
[10:21:21.269]                         }
[10:21:21.269]                       }
[10:21:21.269]                       invisible(muffled)
[10:21:21.269]                     }
[10:21:21.269]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.269]                   }
[10:21:21.269]                 }
[10:21:21.269]             }
[10:21:21.269]         }))
[10:21:21.269]     }, error = function(ex) {
[10:21:21.269]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.269]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.269]                 ...future.rng), started = ...future.startTime, 
[10:21:21.269]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.269]             version = "1.8"), class = "FutureResult")
[10:21:21.269]     }, finally = {
[10:21:21.269]         if (!identical(...future.workdir, getwd())) 
[10:21:21.269]             setwd(...future.workdir)
[10:21:21.269]         {
[10:21:21.269]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.269]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.269]             }
[10:21:21.269]             base::options(...future.oldOptions)
[10:21:21.269]             if (.Platform$OS.type == "windows") {
[10:21:21.269]                 old_names <- names(...future.oldEnvVars)
[10:21:21.269]                 envs <- base::Sys.getenv()
[10:21:21.269]                 names <- names(envs)
[10:21:21.269]                 common <- intersect(names, old_names)
[10:21:21.269]                 added <- setdiff(names, old_names)
[10:21:21.269]                 removed <- setdiff(old_names, names)
[10:21:21.269]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.269]                   envs[common]]
[10:21:21.269]                 NAMES <- toupper(changed)
[10:21:21.269]                 args <- list()
[10:21:21.269]                 for (kk in seq_along(NAMES)) {
[10:21:21.269]                   name <- changed[[kk]]
[10:21:21.269]                   NAME <- NAMES[[kk]]
[10:21:21.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.269]                     next
[10:21:21.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.269]                 }
[10:21:21.269]                 NAMES <- toupper(added)
[10:21:21.269]                 for (kk in seq_along(NAMES)) {
[10:21:21.269]                   name <- added[[kk]]
[10:21:21.269]                   NAME <- NAMES[[kk]]
[10:21:21.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.269]                     next
[10:21:21.269]                   args[[name]] <- ""
[10:21:21.269]                 }
[10:21:21.269]                 NAMES <- toupper(removed)
[10:21:21.269]                 for (kk in seq_along(NAMES)) {
[10:21:21.269]                   name <- removed[[kk]]
[10:21:21.269]                   NAME <- NAMES[[kk]]
[10:21:21.269]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.269]                     next
[10:21:21.269]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.269]                 }
[10:21:21.269]                 if (length(args) > 0) 
[10:21:21.269]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.269]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.269]             }
[10:21:21.269]             else {
[10:21:21.269]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.269]             }
[10:21:21.269]             {
[10:21:21.269]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.269]                   0L) {
[10:21:21.269]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.269]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.269]                   base::options(opts)
[10:21:21.269]                 }
[10:21:21.269]                 {
[10:21:21.269]                   {
[10:21:21.269]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.269]                     NULL
[10:21:21.269]                   }
[10:21:21.269]                   options(future.plan = NULL)
[10:21:21.269]                   if (is.na(NA_character_)) 
[10:21:21.269]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.269]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.269]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.269]                     .init = FALSE)
[10:21:21.269]                 }
[10:21:21.269]             }
[10:21:21.269]         }
[10:21:21.269]     })
[10:21:21.269]     if (TRUE) {
[10:21:21.269]         base::sink(type = "output", split = FALSE)
[10:21:21.269]         if (TRUE) {
[10:21:21.269]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.269]         }
[10:21:21.269]         else {
[10:21:21.269]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.269]         }
[10:21:21.269]         base::close(...future.stdout)
[10:21:21.269]         ...future.stdout <- NULL
[10:21:21.269]     }
[10:21:21.269]     ...future.result$conditions <- ...future.conditions
[10:21:21.269]     ...future.result$finished <- base::Sys.time()
[10:21:21.269]     ...future.result
[10:21:21.269] }
[10:21:21.272] requestCore(): workers = 2
[10:21:21.275] MulticoreFuture started
[10:21:21.275] - Launch lazy future ... done
[10:21:21.276] run() for ‘MulticoreFuture’ ... done
[10:21:21.276] getGlobalsAndPackages() ...
[10:21:21.276] Searching for globals...
[10:21:21.276] plan(): Setting new future strategy stack:
[10:21:21.277] 
[10:21:21.276] List of future strategies:
[10:21:21.276] 1. sequential:
[10:21:21.276]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.276]    - tweaked: FALSE
[10:21:21.276]    - call: NULL
[10:21:21.277] Searching for globals ... DONE
[10:21:21.277] plan(): nbrOfWorkers() = 1
[10:21:21.277] - globals: [0] <none>
[10:21:21.278] getGlobalsAndPackages() ... DONE
[10:21:21.278] run() for ‘Future’ ...
[10:21:21.279] - state: ‘created’
[10:21:21.279] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.280] plan(): Setting new future strategy stack:
[10:21:21.280] List of future strategies:
[10:21:21.280] 1. multicore:
[10:21:21.280]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.280]    - tweaked: FALSE
[10:21:21.280]    - call: plan(strategy)
[10:21:21.283] plan(): nbrOfWorkers() = 2
[10:21:21.283] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.283] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.283]   - Field: ‘label’
[10:21:21.283]   - Field: ‘local’
[10:21:21.284]   - Field: ‘owner’
[10:21:21.284]   - Field: ‘envir’
[10:21:21.284]   - Field: ‘workers’
[10:21:21.284]   - Field: ‘packages’
[10:21:21.284]   - Field: ‘gc’
[10:21:21.284]   - Field: ‘job’
[10:21:21.285]   - Field: ‘conditions’
[10:21:21.285]   - Field: ‘expr’
[10:21:21.285]   - Field: ‘uuid’
[10:21:21.285]   - Field: ‘seed’
[10:21:21.285]   - Field: ‘version’
[10:21:21.285]   - Field: ‘result’
[10:21:21.285]   - Field: ‘asynchronous’
[10:21:21.286]   - Field: ‘calls’
[10:21:21.286]   - Field: ‘globals’
[10:21:21.286]   - Field: ‘stdout’
[10:21:21.286]   - Field: ‘earlySignal’
[10:21:21.286]   - Field: ‘lazy’
[10:21:21.286]   - Field: ‘state’
[10:21:21.287] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.287] - Launch lazy future ...
[10:21:21.287] Packages needed by the future expression (n = 0): <none>
[10:21:21.287] Packages needed by future strategies (n = 0): <none>
[10:21:21.288] {
[10:21:21.288]     {
[10:21:21.288]         {
[10:21:21.288]             ...future.startTime <- base::Sys.time()
[10:21:21.288]             {
[10:21:21.288]                 {
[10:21:21.288]                   {
[10:21:21.288]                     {
[10:21:21.288]                       base::local({
[10:21:21.288]                         has_future <- base::requireNamespace("future", 
[10:21:21.288]                           quietly = TRUE)
[10:21:21.288]                         if (has_future) {
[10:21:21.288]                           ns <- base::getNamespace("future")
[10:21:21.288]                           version <- ns[[".package"]][["version"]]
[10:21:21.288]                           if (is.null(version)) 
[10:21:21.288]                             version <- utils::packageVersion("future")
[10:21:21.288]                         }
[10:21:21.288]                         else {
[10:21:21.288]                           version <- NULL
[10:21:21.288]                         }
[10:21:21.288]                         if (!has_future || version < "1.8.0") {
[10:21:21.288]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.288]                             "", base::R.version$version.string), 
[10:21:21.288]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.288]                               "release", "version")], collapse = " "), 
[10:21:21.288]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.288]                             info)
[10:21:21.288]                           info <- base::paste(info, collapse = "; ")
[10:21:21.288]                           if (!has_future) {
[10:21:21.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.288]                               info)
[10:21:21.288]                           }
[10:21:21.288]                           else {
[10:21:21.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.288]                               info, version)
[10:21:21.288]                           }
[10:21:21.288]                           base::stop(msg)
[10:21:21.288]                         }
[10:21:21.288]                       })
[10:21:21.288]                     }
[10:21:21.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.288]                     base::options(mc.cores = 1L)
[10:21:21.288]                   }
[10:21:21.288]                   ...future.strategy.old <- future::plan("list")
[10:21:21.288]                   options(future.plan = NULL)
[10:21:21.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.288]                 }
[10:21:21.288]                 ...future.workdir <- getwd()
[10:21:21.288]             }
[10:21:21.288]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.288]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.288]         }
[10:21:21.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.288]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.288]             base::names(...future.oldOptions))
[10:21:21.288]     }
[10:21:21.288]     if (FALSE) {
[10:21:21.288]     }
[10:21:21.288]     else {
[10:21:21.288]         if (TRUE) {
[10:21:21.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.288]                 open = "w")
[10:21:21.288]         }
[10:21:21.288]         else {
[10:21:21.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.288]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.288]         }
[10:21:21.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.288]             base::sink(type = "output", split = FALSE)
[10:21:21.288]             base::close(...future.stdout)
[10:21:21.288]         }, add = TRUE)
[10:21:21.288]     }
[10:21:21.288]     ...future.frame <- base::sys.nframe()
[10:21:21.288]     ...future.conditions <- base::list()
[10:21:21.288]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.288]     if (FALSE) {
[10:21:21.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.288]     }
[10:21:21.288]     ...future.result <- base::tryCatch({
[10:21:21.288]         base::withCallingHandlers({
[10:21:21.288]             ...future.value <- base::withVisible(base::local({
[10:21:21.288]                 withCallingHandlers({
[10:21:21.288]                   NULL
[10:21:21.288]                 }, immediateCondition = function(cond) {
[10:21:21.288]                   save_rds <- function (object, pathname, ...) 
[10:21:21.288]                   {
[10:21:21.288]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.288]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.288]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.288]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.288]                         fi_tmp[["mtime"]])
[10:21:21.288]                     }
[10:21:21.288]                     tryCatch({
[10:21:21.288]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.288]                     }, error = function(ex) {
[10:21:21.288]                       msg <- conditionMessage(ex)
[10:21:21.288]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.288]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.288]                         fi_tmp[["mtime"]], msg)
[10:21:21.288]                       ex$message <- msg
[10:21:21.288]                       stop(ex)
[10:21:21.288]                     })
[10:21:21.288]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.288]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.288]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.288]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.288]                       fi <- file.info(pathname)
[10:21:21.288]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.288]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.288]                         fi[["size"]], fi[["mtime"]])
[10:21:21.288]                       stop(msg)
[10:21:21.288]                     }
[10:21:21.288]                     invisible(pathname)
[10:21:21.288]                   }
[10:21:21.288]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.288]                     rootPath = tempdir()) 
[10:21:21.288]                   {
[10:21:21.288]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.288]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.288]                       tmpdir = path, fileext = ".rds")
[10:21:21.288]                     save_rds(obj, file)
[10:21:21.288]                   }
[10:21:21.288]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.288]                   {
[10:21:21.288]                     inherits <- base::inherits
[10:21:21.288]                     invokeRestart <- base::invokeRestart
[10:21:21.288]                     is.null <- base::is.null
[10:21:21.288]                     muffled <- FALSE
[10:21:21.288]                     if (inherits(cond, "message")) {
[10:21:21.288]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.288]                       if (muffled) 
[10:21:21.288]                         invokeRestart("muffleMessage")
[10:21:21.288]                     }
[10:21:21.288]                     else if (inherits(cond, "warning")) {
[10:21:21.288]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.288]                       if (muffled) 
[10:21:21.288]                         invokeRestart("muffleWarning")
[10:21:21.288]                     }
[10:21:21.288]                     else if (inherits(cond, "condition")) {
[10:21:21.288]                       if (!is.null(pattern)) {
[10:21:21.288]                         computeRestarts <- base::computeRestarts
[10:21:21.288]                         grepl <- base::grepl
[10:21:21.288]                         restarts <- computeRestarts(cond)
[10:21:21.288]                         for (restart in restarts) {
[10:21:21.288]                           name <- restart$name
[10:21:21.288]                           if (is.null(name)) 
[10:21:21.288]                             next
[10:21:21.288]                           if (!grepl(pattern, name)) 
[10:21:21.288]                             next
[10:21:21.288]                           invokeRestart(restart)
[10:21:21.288]                           muffled <- TRUE
[10:21:21.288]                           break
[10:21:21.288]                         }
[10:21:21.288]                       }
[10:21:21.288]                     }
[10:21:21.288]                     invisible(muffled)
[10:21:21.288]                   }
[10:21:21.288]                   muffleCondition(cond)
[10:21:21.288]                 })
[10:21:21.288]             }))
[10:21:21.288]             future::FutureResult(value = ...future.value$value, 
[10:21:21.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.288]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.288]                     ...future.globalenv.names))
[10:21:21.288]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.288]         }, condition = base::local({
[10:21:21.288]             c <- base::c
[10:21:21.288]             inherits <- base::inherits
[10:21:21.288]             invokeRestart <- base::invokeRestart
[10:21:21.288]             length <- base::length
[10:21:21.288]             list <- base::list
[10:21:21.288]             seq.int <- base::seq.int
[10:21:21.288]             signalCondition <- base::signalCondition
[10:21:21.288]             sys.calls <- base::sys.calls
[10:21:21.288]             `[[` <- base::`[[`
[10:21:21.288]             `+` <- base::`+`
[10:21:21.288]             `<<-` <- base::`<<-`
[10:21:21.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.288]                   3L)]
[10:21:21.288]             }
[10:21:21.288]             function(cond) {
[10:21:21.288]                 is_error <- inherits(cond, "error")
[10:21:21.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.288]                   NULL)
[10:21:21.288]                 if (is_error) {
[10:21:21.288]                   sessionInformation <- function() {
[10:21:21.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.288]                       search = base::search(), system = base::Sys.info())
[10:21:21.288]                   }
[10:21:21.288]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.288]                     cond$call), session = sessionInformation(), 
[10:21:21.288]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.288]                   signalCondition(cond)
[10:21:21.288]                 }
[10:21:21.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.288]                 "immediateCondition"))) {
[10:21:21.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.288]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.288]                   if (TRUE && !signal) {
[10:21:21.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.288]                     {
[10:21:21.288]                       inherits <- base::inherits
[10:21:21.288]                       invokeRestart <- base::invokeRestart
[10:21:21.288]                       is.null <- base::is.null
[10:21:21.288]                       muffled <- FALSE
[10:21:21.288]                       if (inherits(cond, "message")) {
[10:21:21.288]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.288]                         if (muffled) 
[10:21:21.288]                           invokeRestart("muffleMessage")
[10:21:21.288]                       }
[10:21:21.288]                       else if (inherits(cond, "warning")) {
[10:21:21.288]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.288]                         if (muffled) 
[10:21:21.288]                           invokeRestart("muffleWarning")
[10:21:21.288]                       }
[10:21:21.288]                       else if (inherits(cond, "condition")) {
[10:21:21.288]                         if (!is.null(pattern)) {
[10:21:21.288]                           computeRestarts <- base::computeRestarts
[10:21:21.288]                           grepl <- base::grepl
[10:21:21.288]                           restarts <- computeRestarts(cond)
[10:21:21.288]                           for (restart in restarts) {
[10:21:21.288]                             name <- restart$name
[10:21:21.288]                             if (is.null(name)) 
[10:21:21.288]                               next
[10:21:21.288]                             if (!grepl(pattern, name)) 
[10:21:21.288]                               next
[10:21:21.288]                             invokeRestart(restart)
[10:21:21.288]                             muffled <- TRUE
[10:21:21.288]                             break
[10:21:21.288]                           }
[10:21:21.288]                         }
[10:21:21.288]                       }
[10:21:21.288]                       invisible(muffled)
[10:21:21.288]                     }
[10:21:21.288]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.288]                   }
[10:21:21.288]                 }
[10:21:21.288]                 else {
[10:21:21.288]                   if (TRUE) {
[10:21:21.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.288]                     {
[10:21:21.288]                       inherits <- base::inherits
[10:21:21.288]                       invokeRestart <- base::invokeRestart
[10:21:21.288]                       is.null <- base::is.null
[10:21:21.288]                       muffled <- FALSE
[10:21:21.288]                       if (inherits(cond, "message")) {
[10:21:21.288]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.288]                         if (muffled) 
[10:21:21.288]                           invokeRestart("muffleMessage")
[10:21:21.288]                       }
[10:21:21.288]                       else if (inherits(cond, "warning")) {
[10:21:21.288]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.288]                         if (muffled) 
[10:21:21.288]                           invokeRestart("muffleWarning")
[10:21:21.288]                       }
[10:21:21.288]                       else if (inherits(cond, "condition")) {
[10:21:21.288]                         if (!is.null(pattern)) {
[10:21:21.288]                           computeRestarts <- base::computeRestarts
[10:21:21.288]                           grepl <- base::grepl
[10:21:21.288]                           restarts <- computeRestarts(cond)
[10:21:21.288]                           for (restart in restarts) {
[10:21:21.288]                             name <- restart$name
[10:21:21.288]                             if (is.null(name)) 
[10:21:21.288]                               next
[10:21:21.288]                             if (!grepl(pattern, name)) 
[10:21:21.288]                               next
[10:21:21.288]                             invokeRestart(restart)
[10:21:21.288]                             muffled <- TRUE
[10:21:21.288]                             break
[10:21:21.288]                           }
[10:21:21.288]                         }
[10:21:21.288]                       }
[10:21:21.288]                       invisible(muffled)
[10:21:21.288]                     }
[10:21:21.288]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.288]                   }
[10:21:21.288]                 }
[10:21:21.288]             }
[10:21:21.288]         }))
[10:21:21.288]     }, error = function(ex) {
[10:21:21.288]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.288]                 ...future.rng), started = ...future.startTime, 
[10:21:21.288]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.288]             version = "1.8"), class = "FutureResult")
[10:21:21.288]     }, finally = {
[10:21:21.288]         if (!identical(...future.workdir, getwd())) 
[10:21:21.288]             setwd(...future.workdir)
[10:21:21.288]         {
[10:21:21.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.288]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.288]             }
[10:21:21.288]             base::options(...future.oldOptions)
[10:21:21.288]             if (.Platform$OS.type == "windows") {
[10:21:21.288]                 old_names <- names(...future.oldEnvVars)
[10:21:21.288]                 envs <- base::Sys.getenv()
[10:21:21.288]                 names <- names(envs)
[10:21:21.288]                 common <- intersect(names, old_names)
[10:21:21.288]                 added <- setdiff(names, old_names)
[10:21:21.288]                 removed <- setdiff(old_names, names)
[10:21:21.288]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.288]                   envs[common]]
[10:21:21.288]                 NAMES <- toupper(changed)
[10:21:21.288]                 args <- list()
[10:21:21.288]                 for (kk in seq_along(NAMES)) {
[10:21:21.288]                   name <- changed[[kk]]
[10:21:21.288]                   NAME <- NAMES[[kk]]
[10:21:21.288]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.288]                     next
[10:21:21.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.288]                 }
[10:21:21.288]                 NAMES <- toupper(added)
[10:21:21.288]                 for (kk in seq_along(NAMES)) {
[10:21:21.288]                   name <- added[[kk]]
[10:21:21.288]                   NAME <- NAMES[[kk]]
[10:21:21.288]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.288]                     next
[10:21:21.288]                   args[[name]] <- ""
[10:21:21.288]                 }
[10:21:21.288]                 NAMES <- toupper(removed)
[10:21:21.288]                 for (kk in seq_along(NAMES)) {
[10:21:21.288]                   name <- removed[[kk]]
[10:21:21.288]                   NAME <- NAMES[[kk]]
[10:21:21.288]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.288]                     next
[10:21:21.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.288]                 }
[10:21:21.288]                 if (length(args) > 0) 
[10:21:21.288]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.288]             }
[10:21:21.288]             else {
[10:21:21.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.288]             }
[10:21:21.288]             {
[10:21:21.288]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.288]                   0L) {
[10:21:21.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.288]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.288]                   base::options(opts)
[10:21:21.288]                 }
[10:21:21.288]                 {
[10:21:21.288]                   {
[10:21:21.288]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.288]                     NULL
[10:21:21.288]                   }
[10:21:21.288]                   options(future.plan = NULL)
[10:21:21.288]                   if (is.na(NA_character_)) 
[10:21:21.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.288]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.288]                     .init = FALSE)
[10:21:21.288]                 }
[10:21:21.288]             }
[10:21:21.288]         }
[10:21:21.288]     })
[10:21:21.288]     if (TRUE) {
[10:21:21.288]         base::sink(type = "output", split = FALSE)
[10:21:21.288]         if (TRUE) {
[10:21:21.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.288]         }
[10:21:21.288]         else {
[10:21:21.288]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.288]         }
[10:21:21.288]         base::close(...future.stdout)
[10:21:21.288]         ...future.stdout <- NULL
[10:21:21.288]     }
[10:21:21.288]     ...future.result$conditions <- ...future.conditions
[10:21:21.288]     ...future.result$finished <- base::Sys.time()
[10:21:21.288]     ...future.result
[10:21:21.288] }
[10:21:21.292] requestCore(): workers = 2
[10:21:21.295] MulticoreFuture started
[10:21:21.295] - Launch lazy future ... done
[10:21:21.296] run() for ‘MulticoreFuture’ ... done
[10:21:21.296] plan(): Setting new future strategy stack:
[10:21:21.296] getGlobalsAndPackages() ...
[10:21:21.297] Searching for globals...
[10:21:21.296] List of future strategies:
[10:21:21.296] 1. sequential:
[10:21:21.296]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.296]    - tweaked: FALSE
[10:21:21.296]    - call: NULL
[10:21:21.298] plan(): nbrOfWorkers() = 1
[10:21:21.298] - globals found: [1] ‘{’
[10:21:21.299] Searching for globals ... DONE
[10:21:21.299] Resolving globals: FALSE
[10:21:21.299] 
[10:21:21.299] 
[10:21:21.300] getGlobalsAndPackages() ... DONE
[10:21:21.300] plan(): Setting new future strategy stack:
[10:21:21.300] run() for ‘Future’ ...
[10:21:21.300] - state: ‘created’
[10:21:21.300] List of future strategies:
[10:21:21.300] 1. multicore:
[10:21:21.300]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.300]    - tweaked: FALSE
[10:21:21.300]    - call: plan(strategy)
[10:21:21.300] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.303] plan(): nbrOfWorkers() = 2
[10:21:21.303] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.304]   - Field: ‘label’
[10:21:21.304]   - Field: ‘local’
[10:21:21.304]   - Field: ‘owner’
[10:21:21.304]   - Field: ‘envir’
[10:21:21.304]   - Field: ‘workers’
[10:21:21.304]   - Field: ‘packages’
[10:21:21.305]   - Field: ‘gc’
[10:21:21.305]   - Field: ‘job’
[10:21:21.305]   - Field: ‘conditions’
[10:21:21.305]   - Field: ‘expr’
[10:21:21.305]   - Field: ‘uuid’
[10:21:21.305]   - Field: ‘seed’
[10:21:21.305]   - Field: ‘version’
[10:21:21.306]   - Field: ‘result’
[10:21:21.306]   - Field: ‘asynchronous’
[10:21:21.306]   - Field: ‘calls’
[10:21:21.306]   - Field: ‘globals’
[10:21:21.306]   - Field: ‘stdout’
[10:21:21.306]   - Field: ‘earlySignal’
[10:21:21.306]   - Field: ‘lazy’
[10:21:21.306]   - Field: ‘state’
[10:21:21.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.307] - Launch lazy future ...
[10:21:21.307] Packages needed by the future expression (n = 0): <none>
[10:21:21.307] Packages needed by future strategies (n = 0): <none>
[10:21:21.308] {
[10:21:21.308]     {
[10:21:21.308]         {
[10:21:21.308]             ...future.startTime <- base::Sys.time()
[10:21:21.308]             {
[10:21:21.308]                 {
[10:21:21.308]                   {
[10:21:21.308]                     {
[10:21:21.308]                       base::local({
[10:21:21.308]                         has_future <- base::requireNamespace("future", 
[10:21:21.308]                           quietly = TRUE)
[10:21:21.308]                         if (has_future) {
[10:21:21.308]                           ns <- base::getNamespace("future")
[10:21:21.308]                           version <- ns[[".package"]][["version"]]
[10:21:21.308]                           if (is.null(version)) 
[10:21:21.308]                             version <- utils::packageVersion("future")
[10:21:21.308]                         }
[10:21:21.308]                         else {
[10:21:21.308]                           version <- NULL
[10:21:21.308]                         }
[10:21:21.308]                         if (!has_future || version < "1.8.0") {
[10:21:21.308]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.308]                             "", base::R.version$version.string), 
[10:21:21.308]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.308]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.308]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.308]                               "release", "version")], collapse = " "), 
[10:21:21.308]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.308]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.308]                             info)
[10:21:21.308]                           info <- base::paste(info, collapse = "; ")
[10:21:21.308]                           if (!has_future) {
[10:21:21.308]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.308]                               info)
[10:21:21.308]                           }
[10:21:21.308]                           else {
[10:21:21.308]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.308]                               info, version)
[10:21:21.308]                           }
[10:21:21.308]                           base::stop(msg)
[10:21:21.308]                         }
[10:21:21.308]                       })
[10:21:21.308]                     }
[10:21:21.308]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.308]                     base::options(mc.cores = 1L)
[10:21:21.308]                   }
[10:21:21.308]                   ...future.strategy.old <- future::plan("list")
[10:21:21.308]                   options(future.plan = NULL)
[10:21:21.308]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.308]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.308]                 }
[10:21:21.308]                 ...future.workdir <- getwd()
[10:21:21.308]             }
[10:21:21.308]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.308]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.308]         }
[10:21:21.308]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.308]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.308]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.308]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.308]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.308]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.308]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.308]             base::names(...future.oldOptions))
[10:21:21.308]     }
[10:21:21.308]     if (FALSE) {
[10:21:21.308]     }
[10:21:21.308]     else {
[10:21:21.308]         if (TRUE) {
[10:21:21.308]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.308]                 open = "w")
[10:21:21.308]         }
[10:21:21.308]         else {
[10:21:21.308]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.308]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.308]         }
[10:21:21.308]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.308]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.308]             base::sink(type = "output", split = FALSE)
[10:21:21.308]             base::close(...future.stdout)
[10:21:21.308]         }, add = TRUE)
[10:21:21.308]     }
[10:21:21.308]     ...future.frame <- base::sys.nframe()
[10:21:21.308]     ...future.conditions <- base::list()
[10:21:21.308]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.308]     if (FALSE) {
[10:21:21.308]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.308]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.308]     }
[10:21:21.308]     ...future.result <- base::tryCatch({
[10:21:21.308]         base::withCallingHandlers({
[10:21:21.308]             ...future.value <- base::withVisible(base::local({
[10:21:21.308]                 withCallingHandlers({
[10:21:21.308]                   {
[10:21:21.308]                     4
[10:21:21.308]                   }
[10:21:21.308]                 }, immediateCondition = function(cond) {
[10:21:21.308]                   save_rds <- function (object, pathname, ...) 
[10:21:21.308]                   {
[10:21:21.308]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.308]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.308]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.308]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.308]                         fi_tmp[["mtime"]])
[10:21:21.308]                     }
[10:21:21.308]                     tryCatch({
[10:21:21.308]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.308]                     }, error = function(ex) {
[10:21:21.308]                       msg <- conditionMessage(ex)
[10:21:21.308]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.308]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.308]                         fi_tmp[["mtime"]], msg)
[10:21:21.308]                       ex$message <- msg
[10:21:21.308]                       stop(ex)
[10:21:21.308]                     })
[10:21:21.308]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.308]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.308]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.308]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.308]                       fi <- file.info(pathname)
[10:21:21.308]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.308]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.308]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.308]                         fi[["size"]], fi[["mtime"]])
[10:21:21.308]                       stop(msg)
[10:21:21.308]                     }
[10:21:21.308]                     invisible(pathname)
[10:21:21.308]                   }
[10:21:21.308]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.308]                     rootPath = tempdir()) 
[10:21:21.308]                   {
[10:21:21.308]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.308]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.308]                       tmpdir = path, fileext = ".rds")
[10:21:21.308]                     save_rds(obj, file)
[10:21:21.308]                   }
[10:21:21.308]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.308]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.308]                   {
[10:21:21.308]                     inherits <- base::inherits
[10:21:21.308]                     invokeRestart <- base::invokeRestart
[10:21:21.308]                     is.null <- base::is.null
[10:21:21.308]                     muffled <- FALSE
[10:21:21.308]                     if (inherits(cond, "message")) {
[10:21:21.308]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.308]                       if (muffled) 
[10:21:21.308]                         invokeRestart("muffleMessage")
[10:21:21.308]                     }
[10:21:21.308]                     else if (inherits(cond, "warning")) {
[10:21:21.308]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.308]                       if (muffled) 
[10:21:21.308]                         invokeRestart("muffleWarning")
[10:21:21.308]                     }
[10:21:21.308]                     else if (inherits(cond, "condition")) {
[10:21:21.308]                       if (!is.null(pattern)) {
[10:21:21.308]                         computeRestarts <- base::computeRestarts
[10:21:21.308]                         grepl <- base::grepl
[10:21:21.308]                         restarts <- computeRestarts(cond)
[10:21:21.308]                         for (restart in restarts) {
[10:21:21.308]                           name <- restart$name
[10:21:21.308]                           if (is.null(name)) 
[10:21:21.308]                             next
[10:21:21.308]                           if (!grepl(pattern, name)) 
[10:21:21.308]                             next
[10:21:21.308]                           invokeRestart(restart)
[10:21:21.308]                           muffled <- TRUE
[10:21:21.308]                           break
[10:21:21.308]                         }
[10:21:21.308]                       }
[10:21:21.308]                     }
[10:21:21.308]                     invisible(muffled)
[10:21:21.308]                   }
[10:21:21.308]                   muffleCondition(cond)
[10:21:21.308]                 })
[10:21:21.308]             }))
[10:21:21.308]             future::FutureResult(value = ...future.value$value, 
[10:21:21.308]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.308]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.308]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.308]                     ...future.globalenv.names))
[10:21:21.308]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.308]         }, condition = base::local({
[10:21:21.308]             c <- base::c
[10:21:21.308]             inherits <- base::inherits
[10:21:21.308]             invokeRestart <- base::invokeRestart
[10:21:21.308]             length <- base::length
[10:21:21.308]             list <- base::list
[10:21:21.308]             seq.int <- base::seq.int
[10:21:21.308]             signalCondition <- base::signalCondition
[10:21:21.308]             sys.calls <- base::sys.calls
[10:21:21.308]             `[[` <- base::`[[`
[10:21:21.308]             `+` <- base::`+`
[10:21:21.308]             `<<-` <- base::`<<-`
[10:21:21.308]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.308]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.308]                   3L)]
[10:21:21.308]             }
[10:21:21.308]             function(cond) {
[10:21:21.308]                 is_error <- inherits(cond, "error")
[10:21:21.308]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.308]                   NULL)
[10:21:21.308]                 if (is_error) {
[10:21:21.308]                   sessionInformation <- function() {
[10:21:21.308]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.308]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.308]                       search = base::search(), system = base::Sys.info())
[10:21:21.308]                   }
[10:21:21.308]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.308]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.308]                     cond$call), session = sessionInformation(), 
[10:21:21.308]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.308]                   signalCondition(cond)
[10:21:21.308]                 }
[10:21:21.308]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.308]                 "immediateCondition"))) {
[10:21:21.308]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.308]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.308]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.308]                   if (TRUE && !signal) {
[10:21:21.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.308]                     {
[10:21:21.308]                       inherits <- base::inherits
[10:21:21.308]                       invokeRestart <- base::invokeRestart
[10:21:21.308]                       is.null <- base::is.null
[10:21:21.308]                       muffled <- FALSE
[10:21:21.308]                       if (inherits(cond, "message")) {
[10:21:21.308]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.308]                         if (muffled) 
[10:21:21.308]                           invokeRestart("muffleMessage")
[10:21:21.308]                       }
[10:21:21.308]                       else if (inherits(cond, "warning")) {
[10:21:21.308]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.308]                         if (muffled) 
[10:21:21.308]                           invokeRestart("muffleWarning")
[10:21:21.308]                       }
[10:21:21.308]                       else if (inherits(cond, "condition")) {
[10:21:21.308]                         if (!is.null(pattern)) {
[10:21:21.308]                           computeRestarts <- base::computeRestarts
[10:21:21.308]                           grepl <- base::grepl
[10:21:21.308]                           restarts <- computeRestarts(cond)
[10:21:21.308]                           for (restart in restarts) {
[10:21:21.308]                             name <- restart$name
[10:21:21.308]                             if (is.null(name)) 
[10:21:21.308]                               next
[10:21:21.308]                             if (!grepl(pattern, name)) 
[10:21:21.308]                               next
[10:21:21.308]                             invokeRestart(restart)
[10:21:21.308]                             muffled <- TRUE
[10:21:21.308]                             break
[10:21:21.308]                           }
[10:21:21.308]                         }
[10:21:21.308]                       }
[10:21:21.308]                       invisible(muffled)
[10:21:21.308]                     }
[10:21:21.308]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.308]                   }
[10:21:21.308]                 }
[10:21:21.308]                 else {
[10:21:21.308]                   if (TRUE) {
[10:21:21.308]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.308]                     {
[10:21:21.308]                       inherits <- base::inherits
[10:21:21.308]                       invokeRestart <- base::invokeRestart
[10:21:21.308]                       is.null <- base::is.null
[10:21:21.308]                       muffled <- FALSE
[10:21:21.308]                       if (inherits(cond, "message")) {
[10:21:21.308]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.308]                         if (muffled) 
[10:21:21.308]                           invokeRestart("muffleMessage")
[10:21:21.308]                       }
[10:21:21.308]                       else if (inherits(cond, "warning")) {
[10:21:21.308]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.308]                         if (muffled) 
[10:21:21.308]                           invokeRestart("muffleWarning")
[10:21:21.308]                       }
[10:21:21.308]                       else if (inherits(cond, "condition")) {
[10:21:21.308]                         if (!is.null(pattern)) {
[10:21:21.308]                           computeRestarts <- base::computeRestarts
[10:21:21.308]                           grepl <- base::grepl
[10:21:21.308]                           restarts <- computeRestarts(cond)
[10:21:21.308]                           for (restart in restarts) {
[10:21:21.308]                             name <- restart$name
[10:21:21.308]                             if (is.null(name)) 
[10:21:21.308]                               next
[10:21:21.308]                             if (!grepl(pattern, name)) 
[10:21:21.308]                               next
[10:21:21.308]                             invokeRestart(restart)
[10:21:21.308]                             muffled <- TRUE
[10:21:21.308]                             break
[10:21:21.308]                           }
[10:21:21.308]                         }
[10:21:21.308]                       }
[10:21:21.308]                       invisible(muffled)
[10:21:21.308]                     }
[10:21:21.308]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.308]                   }
[10:21:21.308]                 }
[10:21:21.308]             }
[10:21:21.308]         }))
[10:21:21.308]     }, error = function(ex) {
[10:21:21.308]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.308]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.308]                 ...future.rng), started = ...future.startTime, 
[10:21:21.308]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.308]             version = "1.8"), class = "FutureResult")
[10:21:21.308]     }, finally = {
[10:21:21.308]         if (!identical(...future.workdir, getwd())) 
[10:21:21.308]             setwd(...future.workdir)
[10:21:21.308]         {
[10:21:21.308]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.308]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.308]             }
[10:21:21.308]             base::options(...future.oldOptions)
[10:21:21.308]             if (.Platform$OS.type == "windows") {
[10:21:21.308]                 old_names <- names(...future.oldEnvVars)
[10:21:21.308]                 envs <- base::Sys.getenv()
[10:21:21.308]                 names <- names(envs)
[10:21:21.308]                 common <- intersect(names, old_names)
[10:21:21.308]                 added <- setdiff(names, old_names)
[10:21:21.308]                 removed <- setdiff(old_names, names)
[10:21:21.308]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.308]                   envs[common]]
[10:21:21.308]                 NAMES <- toupper(changed)
[10:21:21.308]                 args <- list()
[10:21:21.308]                 for (kk in seq_along(NAMES)) {
[10:21:21.308]                   name <- changed[[kk]]
[10:21:21.308]                   NAME <- NAMES[[kk]]
[10:21:21.308]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.308]                     next
[10:21:21.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.308]                 }
[10:21:21.308]                 NAMES <- toupper(added)
[10:21:21.308]                 for (kk in seq_along(NAMES)) {
[10:21:21.308]                   name <- added[[kk]]
[10:21:21.308]                   NAME <- NAMES[[kk]]
[10:21:21.308]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.308]                     next
[10:21:21.308]                   args[[name]] <- ""
[10:21:21.308]                 }
[10:21:21.308]                 NAMES <- toupper(removed)
[10:21:21.308]                 for (kk in seq_along(NAMES)) {
[10:21:21.308]                   name <- removed[[kk]]
[10:21:21.308]                   NAME <- NAMES[[kk]]
[10:21:21.308]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.308]                     next
[10:21:21.308]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.308]                 }
[10:21:21.308]                 if (length(args) > 0) 
[10:21:21.308]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.308]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.308]             }
[10:21:21.308]             else {
[10:21:21.308]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.308]             }
[10:21:21.308]             {
[10:21:21.308]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.308]                   0L) {
[10:21:21.308]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.308]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.308]                   base::options(opts)
[10:21:21.308]                 }
[10:21:21.308]                 {
[10:21:21.308]                   {
[10:21:21.308]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.308]                     NULL
[10:21:21.308]                   }
[10:21:21.308]                   options(future.plan = NULL)
[10:21:21.308]                   if (is.na(NA_character_)) 
[10:21:21.308]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.308]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.308]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.308]                     .init = FALSE)
[10:21:21.308]                 }
[10:21:21.308]             }
[10:21:21.308]         }
[10:21:21.308]     })
[10:21:21.308]     if (TRUE) {
[10:21:21.308]         base::sink(type = "output", split = FALSE)
[10:21:21.308]         if (TRUE) {
[10:21:21.308]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.308]         }
[10:21:21.308]         else {
[10:21:21.308]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.308]         }
[10:21:21.308]         base::close(...future.stdout)
[10:21:21.308]         ...future.stdout <- NULL
[10:21:21.308]     }
[10:21:21.308]     ...future.result$conditions <- ...future.conditions
[10:21:21.308]     ...future.result$finished <- base::Sys.time()
[10:21:21.308]     ...future.result
[10:21:21.308] }
[10:21:21.311] requestCore(): workers = 2
[10:21:21.312] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:21.323] result() for MulticoreFuture ...
[10:21:21.324] result() for MulticoreFuture ...
[10:21:21.324] result() for MulticoreFuture ... done
[10:21:21.324] result() for MulticoreFuture ... done
[10:21:21.324] result() for MulticoreFuture ...
[10:21:21.324] result() for MulticoreFuture ... done
[10:21:21.327] MulticoreFuture started
[10:21:21.328] - Launch lazy future ... done
[10:21:21.328] run() for ‘MulticoreFuture’ ... done
[10:21:21.329] plan(): Setting new future strategy stack:
<environment: 0x55e8e4bc9048> 
[10:21:21.329] List of future strategies:
[10:21:21.329] 1. sequential:
[10:21:21.329]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.329]    - tweaked: FALSE
[10:21:21.329]    - call: NULL
[10:21:21.330] plan(): nbrOfWorkers() = 1
<environment: 0x55e8e66952b8> 
[10:21:21.333] plan(): Setting new future strategy stack:
[10:21:21.333] List of future strategies:
[10:21:21.333] 1. multicore:
[10:21:21.333]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.333]    - tweaked: FALSE
[10:21:21.333]    - call: plan(strategy)
[10:21:21.337] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:21.339] resolve() on environment ...
[10:21:21.339]  recursive: 0
[10:21:21.340]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:21.340] signalConditionsASAP(numeric, pos=1) ...
[10:21:21.340] - nx: 4
[10:21:21.340] - relay: TRUE
[10:21:21.341] - stdout: TRUE
[10:21:21.341] - signal: TRUE
[10:21:21.341] - resignal: FALSE
[10:21:21.341] - force: TRUE
[10:21:21.341] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.341] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.341]  - until=2
[10:21:21.342]  - relaying element #2
[10:21:21.342] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.342] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.342] signalConditionsASAP(NULL, pos=1) ... done
[10:21:21.342]  length: 3 (resolved future 1)
[10:21:21.342] Future #2
[10:21:21.343] result() for MulticoreFuture ...
[10:21:21.343] result() for MulticoreFuture ... done
[10:21:21.343] result() for MulticoreFuture ...
[10:21:21.343] result() for MulticoreFuture ... done
[10:21:21.343] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:21.343] - nx: 4
[10:21:21.343] - relay: TRUE
[10:21:21.343] - stdout: TRUE
[10:21:21.344] - signal: TRUE
[10:21:21.344] - resignal: FALSE
[10:21:21.344] - force: TRUE
[10:21:21.344] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.344] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.344]  - until=2
[10:21:21.344]  - relaying element #2
[10:21:21.344] result() for MulticoreFuture ...
[10:21:21.344] result() for MulticoreFuture ... done
[10:21:21.345] result() for MulticoreFuture ...
[10:21:21.345] result() for MulticoreFuture ... done
[10:21:21.345] result() for MulticoreFuture ...
[10:21:21.345] result() for MulticoreFuture ... done
[10:21:21.345] result() for MulticoreFuture ...
[10:21:21.345] result() for MulticoreFuture ... done
[10:21:21.345] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.345] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.346] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:21.346]  length: 2 (resolved future 2)
[10:21:21.346] Future #3
[10:21:21.346] result() for MulticoreFuture ...
[10:21:21.347] result() for MulticoreFuture ...
[10:21:21.347] result() for MulticoreFuture ... done
[10:21:21.347] result() for MulticoreFuture ... done
[10:21:21.348] result() for MulticoreFuture ...
[10:21:21.348] result() for MulticoreFuture ... done
[10:21:21.348] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:21.348] - nx: 4
[10:21:21.348] - relay: TRUE
[10:21:21.348] - stdout: TRUE
[10:21:21.348] - signal: TRUE
[10:21:21.348] - resignal: FALSE
[10:21:21.349] - force: TRUE
[10:21:21.349] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.349] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.349]  - until=3
[10:21:21.349]  - relaying element #3
[10:21:21.349] result() for MulticoreFuture ...
[10:21:21.349] result() for MulticoreFuture ... done
[10:21:21.349] result() for MulticoreFuture ...
[10:21:21.350] result() for MulticoreFuture ... done
[10:21:21.350] result() for MulticoreFuture ...
[10:21:21.350] result() for MulticoreFuture ... done
[10:21:21.350] result() for MulticoreFuture ...
[10:21:21.350] result() for MulticoreFuture ... done
[10:21:21.350] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.350] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.351] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:21.351]  length: 1 (resolved future 3)
[10:21:21.351] Future #4
[10:21:21.351] result() for MulticoreFuture ...
[10:21:21.352] result() for MulticoreFuture ...
[10:21:21.352] result() for MulticoreFuture ... done
[10:21:21.352] result() for MulticoreFuture ... done
[10:21:21.352] result() for MulticoreFuture ...
[10:21:21.353] result() for MulticoreFuture ... done
[10:21:21.353] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:21.353] - nx: 4
[10:21:21.353] - relay: TRUE
[10:21:21.353] - stdout: TRUE
[10:21:21.353] - signal: TRUE
[10:21:21.354] - resignal: FALSE
[10:21:21.354] - force: TRUE
[10:21:21.354] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.354] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.354]  - until=4
[10:21:21.354]  - relaying element #4
[10:21:21.355] result() for MulticoreFuture ...
[10:21:21.355] result() for MulticoreFuture ... done
[10:21:21.355] result() for MulticoreFuture ...
[10:21:21.355] result() for MulticoreFuture ... done
[10:21:21.355] result() for MulticoreFuture ...
[10:21:21.355] result() for MulticoreFuture ... done
[10:21:21.356] result() for MulticoreFuture ...
[10:21:21.356] result() for MulticoreFuture ... done
[10:21:21.356] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.356] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.356] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:21.356]  length: 0 (resolved future 4)
[10:21:21.356] Relaying remaining futures
[10:21:21.356] signalConditionsASAP(NULL, pos=0) ...
[10:21:21.357] - nx: 4
[10:21:21.357] - relay: TRUE
[10:21:21.357] - stdout: TRUE
[10:21:21.357] - signal: TRUE
[10:21:21.357] - resignal: FALSE
[10:21:21.357] - force: TRUE
[10:21:21.357] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.357] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:21.357] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.357] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.358] signalConditionsASAP(NULL, pos=0) ... done
[10:21:21.358] resolve() on environment ... DONE
[10:21:21.358] result() for MulticoreFuture ...
[10:21:21.358] result() for MulticoreFuture ... done
[10:21:21.358] result() for MulticoreFuture ...
[10:21:21.358] result() for MulticoreFuture ... done
[10:21:21.358] result() for MulticoreFuture ...
[10:21:21.358] result() for MulticoreFuture ... done
[10:21:21.358] result() for MulticoreFuture ...
[10:21:21.359] result() for MulticoreFuture ... done
[10:21:21.359] result() for MulticoreFuture ...
[10:21:21.359] result() for MulticoreFuture ... done
[10:21:21.359] result() for MulticoreFuture ...
[10:21:21.359] result() for MulticoreFuture ... done
<environment: 0x55e8e674a4f0> 
Dimensions: c(1, 6)
[10:21:21.360] getGlobalsAndPackages() ...
[10:21:21.360] Searching for globals...
[10:21:21.360] 
[10:21:21.360] Searching for globals ... DONE
[10:21:21.360] - globals: [0] <none>
[10:21:21.360] getGlobalsAndPackages() ... DONE
[10:21:21.361] run() for ‘Future’ ...
[10:21:21.361] - state: ‘created’
[10:21:21.361] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.363] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.363] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.364]   - Field: ‘label’
[10:21:21.364]   - Field: ‘local’
[10:21:21.364]   - Field: ‘owner’
[10:21:21.364]   - Field: ‘envir’
[10:21:21.364]   - Field: ‘workers’
[10:21:21.364]   - Field: ‘packages’
[10:21:21.364]   - Field: ‘gc’
[10:21:21.364]   - Field: ‘job’
[10:21:21.364]   - Field: ‘conditions’
[10:21:21.365]   - Field: ‘expr’
[10:21:21.365]   - Field: ‘uuid’
[10:21:21.365]   - Field: ‘seed’
[10:21:21.365]   - Field: ‘version’
[10:21:21.365]   - Field: ‘result’
[10:21:21.365]   - Field: ‘asynchronous’
[10:21:21.365]   - Field: ‘calls’
[10:21:21.365]   - Field: ‘globals’
[10:21:21.365]   - Field: ‘stdout’
[10:21:21.365]   - Field: ‘earlySignal’
[10:21:21.366]   - Field: ‘lazy’
[10:21:21.366]   - Field: ‘state’
[10:21:21.366] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.366] - Launch lazy future ...
[10:21:21.366] Packages needed by the future expression (n = 0): <none>
[10:21:21.366] Packages needed by future strategies (n = 0): <none>
[10:21:21.367] {
[10:21:21.367]     {
[10:21:21.367]         {
[10:21:21.367]             ...future.startTime <- base::Sys.time()
[10:21:21.367]             {
[10:21:21.367]                 {
[10:21:21.367]                   {
[10:21:21.367]                     {
[10:21:21.367]                       base::local({
[10:21:21.367]                         has_future <- base::requireNamespace("future", 
[10:21:21.367]                           quietly = TRUE)
[10:21:21.367]                         if (has_future) {
[10:21:21.367]                           ns <- base::getNamespace("future")
[10:21:21.367]                           version <- ns[[".package"]][["version"]]
[10:21:21.367]                           if (is.null(version)) 
[10:21:21.367]                             version <- utils::packageVersion("future")
[10:21:21.367]                         }
[10:21:21.367]                         else {
[10:21:21.367]                           version <- NULL
[10:21:21.367]                         }
[10:21:21.367]                         if (!has_future || version < "1.8.0") {
[10:21:21.367]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.367]                             "", base::R.version$version.string), 
[10:21:21.367]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.367]                               "release", "version")], collapse = " "), 
[10:21:21.367]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.367]                             info)
[10:21:21.367]                           info <- base::paste(info, collapse = "; ")
[10:21:21.367]                           if (!has_future) {
[10:21:21.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.367]                               info)
[10:21:21.367]                           }
[10:21:21.367]                           else {
[10:21:21.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.367]                               info, version)
[10:21:21.367]                           }
[10:21:21.367]                           base::stop(msg)
[10:21:21.367]                         }
[10:21:21.367]                       })
[10:21:21.367]                     }
[10:21:21.367]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.367]                     base::options(mc.cores = 1L)
[10:21:21.367]                   }
[10:21:21.367]                   ...future.strategy.old <- future::plan("list")
[10:21:21.367]                   options(future.plan = NULL)
[10:21:21.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.367]                 }
[10:21:21.367]                 ...future.workdir <- getwd()
[10:21:21.367]             }
[10:21:21.367]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.367]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.367]         }
[10:21:21.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.367]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.367]             base::names(...future.oldOptions))
[10:21:21.367]     }
[10:21:21.367]     if (FALSE) {
[10:21:21.367]     }
[10:21:21.367]     else {
[10:21:21.367]         if (TRUE) {
[10:21:21.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.367]                 open = "w")
[10:21:21.367]         }
[10:21:21.367]         else {
[10:21:21.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.367]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.367]         }
[10:21:21.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.367]             base::sink(type = "output", split = FALSE)
[10:21:21.367]             base::close(...future.stdout)
[10:21:21.367]         }, add = TRUE)
[10:21:21.367]     }
[10:21:21.367]     ...future.frame <- base::sys.nframe()
[10:21:21.367]     ...future.conditions <- base::list()
[10:21:21.367]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.367]     if (FALSE) {
[10:21:21.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.367]     }
[10:21:21.367]     ...future.result <- base::tryCatch({
[10:21:21.367]         base::withCallingHandlers({
[10:21:21.367]             ...future.value <- base::withVisible(base::local({
[10:21:21.367]                 withCallingHandlers({
[10:21:21.367]                   2
[10:21:21.367]                 }, immediateCondition = function(cond) {
[10:21:21.367]                   save_rds <- function (object, pathname, ...) 
[10:21:21.367]                   {
[10:21:21.367]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.367]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.367]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.367]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.367]                         fi_tmp[["mtime"]])
[10:21:21.367]                     }
[10:21:21.367]                     tryCatch({
[10:21:21.367]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.367]                     }, error = function(ex) {
[10:21:21.367]                       msg <- conditionMessage(ex)
[10:21:21.367]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.367]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.367]                         fi_tmp[["mtime"]], msg)
[10:21:21.367]                       ex$message <- msg
[10:21:21.367]                       stop(ex)
[10:21:21.367]                     })
[10:21:21.367]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.367]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.367]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.367]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.367]                       fi <- file.info(pathname)
[10:21:21.367]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.367]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.367]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.367]                         fi[["size"]], fi[["mtime"]])
[10:21:21.367]                       stop(msg)
[10:21:21.367]                     }
[10:21:21.367]                     invisible(pathname)
[10:21:21.367]                   }
[10:21:21.367]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.367]                     rootPath = tempdir()) 
[10:21:21.367]                   {
[10:21:21.367]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.367]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.367]                       tmpdir = path, fileext = ".rds")
[10:21:21.367]                     save_rds(obj, file)
[10:21:21.367]                   }
[10:21:21.367]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.367]                   {
[10:21:21.367]                     inherits <- base::inherits
[10:21:21.367]                     invokeRestart <- base::invokeRestart
[10:21:21.367]                     is.null <- base::is.null
[10:21:21.367]                     muffled <- FALSE
[10:21:21.367]                     if (inherits(cond, "message")) {
[10:21:21.367]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.367]                       if (muffled) 
[10:21:21.367]                         invokeRestart("muffleMessage")
[10:21:21.367]                     }
[10:21:21.367]                     else if (inherits(cond, "warning")) {
[10:21:21.367]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.367]                       if (muffled) 
[10:21:21.367]                         invokeRestart("muffleWarning")
[10:21:21.367]                     }
[10:21:21.367]                     else if (inherits(cond, "condition")) {
[10:21:21.367]                       if (!is.null(pattern)) {
[10:21:21.367]                         computeRestarts <- base::computeRestarts
[10:21:21.367]                         grepl <- base::grepl
[10:21:21.367]                         restarts <- computeRestarts(cond)
[10:21:21.367]                         for (restart in restarts) {
[10:21:21.367]                           name <- restart$name
[10:21:21.367]                           if (is.null(name)) 
[10:21:21.367]                             next
[10:21:21.367]                           if (!grepl(pattern, name)) 
[10:21:21.367]                             next
[10:21:21.367]                           invokeRestart(restart)
[10:21:21.367]                           muffled <- TRUE
[10:21:21.367]                           break
[10:21:21.367]                         }
[10:21:21.367]                       }
[10:21:21.367]                     }
[10:21:21.367]                     invisible(muffled)
[10:21:21.367]                   }
[10:21:21.367]                   muffleCondition(cond)
[10:21:21.367]                 })
[10:21:21.367]             }))
[10:21:21.367]             future::FutureResult(value = ...future.value$value, 
[10:21:21.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.367]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.367]                     ...future.globalenv.names))
[10:21:21.367]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.367]         }, condition = base::local({
[10:21:21.367]             c <- base::c
[10:21:21.367]             inherits <- base::inherits
[10:21:21.367]             invokeRestart <- base::invokeRestart
[10:21:21.367]             length <- base::length
[10:21:21.367]             list <- base::list
[10:21:21.367]             seq.int <- base::seq.int
[10:21:21.367]             signalCondition <- base::signalCondition
[10:21:21.367]             sys.calls <- base::sys.calls
[10:21:21.367]             `[[` <- base::`[[`
[10:21:21.367]             `+` <- base::`+`
[10:21:21.367]             `<<-` <- base::`<<-`
[10:21:21.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.367]                   3L)]
[10:21:21.367]             }
[10:21:21.367]             function(cond) {
[10:21:21.367]                 is_error <- inherits(cond, "error")
[10:21:21.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.367]                   NULL)
[10:21:21.367]                 if (is_error) {
[10:21:21.367]                   sessionInformation <- function() {
[10:21:21.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.367]                       search = base::search(), system = base::Sys.info())
[10:21:21.367]                   }
[10:21:21.367]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.367]                     cond$call), session = sessionInformation(), 
[10:21:21.367]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.367]                   signalCondition(cond)
[10:21:21.367]                 }
[10:21:21.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.367]                 "immediateCondition"))) {
[10:21:21.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.367]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.367]                   if (TRUE && !signal) {
[10:21:21.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.367]                     {
[10:21:21.367]                       inherits <- base::inherits
[10:21:21.367]                       invokeRestart <- base::invokeRestart
[10:21:21.367]                       is.null <- base::is.null
[10:21:21.367]                       muffled <- FALSE
[10:21:21.367]                       if (inherits(cond, "message")) {
[10:21:21.367]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.367]                         if (muffled) 
[10:21:21.367]                           invokeRestart("muffleMessage")
[10:21:21.367]                       }
[10:21:21.367]                       else if (inherits(cond, "warning")) {
[10:21:21.367]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.367]                         if (muffled) 
[10:21:21.367]                           invokeRestart("muffleWarning")
[10:21:21.367]                       }
[10:21:21.367]                       else if (inherits(cond, "condition")) {
[10:21:21.367]                         if (!is.null(pattern)) {
[10:21:21.367]                           computeRestarts <- base::computeRestarts
[10:21:21.367]                           grepl <- base::grepl
[10:21:21.367]                           restarts <- computeRestarts(cond)
[10:21:21.367]                           for (restart in restarts) {
[10:21:21.367]                             name <- restart$name
[10:21:21.367]                             if (is.null(name)) 
[10:21:21.367]                               next
[10:21:21.367]                             if (!grepl(pattern, name)) 
[10:21:21.367]                               next
[10:21:21.367]                             invokeRestart(restart)
[10:21:21.367]                             muffled <- TRUE
[10:21:21.367]                             break
[10:21:21.367]                           }
[10:21:21.367]                         }
[10:21:21.367]                       }
[10:21:21.367]                       invisible(muffled)
[10:21:21.367]                     }
[10:21:21.367]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.367]                   }
[10:21:21.367]                 }
[10:21:21.367]                 else {
[10:21:21.367]                   if (TRUE) {
[10:21:21.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.367]                     {
[10:21:21.367]                       inherits <- base::inherits
[10:21:21.367]                       invokeRestart <- base::invokeRestart
[10:21:21.367]                       is.null <- base::is.null
[10:21:21.367]                       muffled <- FALSE
[10:21:21.367]                       if (inherits(cond, "message")) {
[10:21:21.367]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.367]                         if (muffled) 
[10:21:21.367]                           invokeRestart("muffleMessage")
[10:21:21.367]                       }
[10:21:21.367]                       else if (inherits(cond, "warning")) {
[10:21:21.367]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.367]                         if (muffled) 
[10:21:21.367]                           invokeRestart("muffleWarning")
[10:21:21.367]                       }
[10:21:21.367]                       else if (inherits(cond, "condition")) {
[10:21:21.367]                         if (!is.null(pattern)) {
[10:21:21.367]                           computeRestarts <- base::computeRestarts
[10:21:21.367]                           grepl <- base::grepl
[10:21:21.367]                           restarts <- computeRestarts(cond)
[10:21:21.367]                           for (restart in restarts) {
[10:21:21.367]                             name <- restart$name
[10:21:21.367]                             if (is.null(name)) 
[10:21:21.367]                               next
[10:21:21.367]                             if (!grepl(pattern, name)) 
[10:21:21.367]                               next
[10:21:21.367]                             invokeRestart(restart)
[10:21:21.367]                             muffled <- TRUE
[10:21:21.367]                             break
[10:21:21.367]                           }
[10:21:21.367]                         }
[10:21:21.367]                       }
[10:21:21.367]                       invisible(muffled)
[10:21:21.367]                     }
[10:21:21.367]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.367]                   }
[10:21:21.367]                 }
[10:21:21.367]             }
[10:21:21.367]         }))
[10:21:21.367]     }, error = function(ex) {
[10:21:21.367]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.367]                 ...future.rng), started = ...future.startTime, 
[10:21:21.367]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.367]             version = "1.8"), class = "FutureResult")
[10:21:21.367]     }, finally = {
[10:21:21.367]         if (!identical(...future.workdir, getwd())) 
[10:21:21.367]             setwd(...future.workdir)
[10:21:21.367]         {
[10:21:21.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.367]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.367]             }
[10:21:21.367]             base::options(...future.oldOptions)
[10:21:21.367]             if (.Platform$OS.type == "windows") {
[10:21:21.367]                 old_names <- names(...future.oldEnvVars)
[10:21:21.367]                 envs <- base::Sys.getenv()
[10:21:21.367]                 names <- names(envs)
[10:21:21.367]                 common <- intersect(names, old_names)
[10:21:21.367]                 added <- setdiff(names, old_names)
[10:21:21.367]                 removed <- setdiff(old_names, names)
[10:21:21.367]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.367]                   envs[common]]
[10:21:21.367]                 NAMES <- toupper(changed)
[10:21:21.367]                 args <- list()
[10:21:21.367]                 for (kk in seq_along(NAMES)) {
[10:21:21.367]                   name <- changed[[kk]]
[10:21:21.367]                   NAME <- NAMES[[kk]]
[10:21:21.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.367]                     next
[10:21:21.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.367]                 }
[10:21:21.367]                 NAMES <- toupper(added)
[10:21:21.367]                 for (kk in seq_along(NAMES)) {
[10:21:21.367]                   name <- added[[kk]]
[10:21:21.367]                   NAME <- NAMES[[kk]]
[10:21:21.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.367]                     next
[10:21:21.367]                   args[[name]] <- ""
[10:21:21.367]                 }
[10:21:21.367]                 NAMES <- toupper(removed)
[10:21:21.367]                 for (kk in seq_along(NAMES)) {
[10:21:21.367]                   name <- removed[[kk]]
[10:21:21.367]                   NAME <- NAMES[[kk]]
[10:21:21.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.367]                     next
[10:21:21.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.367]                 }
[10:21:21.367]                 if (length(args) > 0) 
[10:21:21.367]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.367]             }
[10:21:21.367]             else {
[10:21:21.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.367]             }
[10:21:21.367]             {
[10:21:21.367]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.367]                   0L) {
[10:21:21.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.367]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.367]                   base::options(opts)
[10:21:21.367]                 }
[10:21:21.367]                 {
[10:21:21.367]                   {
[10:21:21.367]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.367]                     NULL
[10:21:21.367]                   }
[10:21:21.367]                   options(future.plan = NULL)
[10:21:21.367]                   if (is.na(NA_character_)) 
[10:21:21.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.367]                     .init = FALSE)
[10:21:21.367]                 }
[10:21:21.367]             }
[10:21:21.367]         }
[10:21:21.367]     })
[10:21:21.367]     if (TRUE) {
[10:21:21.367]         base::sink(type = "output", split = FALSE)
[10:21:21.367]         if (TRUE) {
[10:21:21.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.367]         }
[10:21:21.367]         else {
[10:21:21.367]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.367]         }
[10:21:21.367]         base::close(...future.stdout)
[10:21:21.367]         ...future.stdout <- NULL
[10:21:21.367]     }
[10:21:21.367]     ...future.result$conditions <- ...future.conditions
[10:21:21.367]     ...future.result$finished <- base::Sys.time()
[10:21:21.367]     ...future.result
[10:21:21.367] }
[10:21:21.370] requestCore(): workers = 2
[10:21:21.372] MulticoreFuture started
[10:21:21.372] - Launch lazy future ... done
[10:21:21.372] run() for ‘MulticoreFuture’ ... done
[10:21:21.373] getGlobalsAndPackages() ...
[10:21:21.373] Searching for globals...
[10:21:21.373] plan(): Setting new future strategy stack:
[10:21:21.374] 
[10:21:21.374] Searching for globals ... DONE
[10:21:21.373] List of future strategies:
[10:21:21.373] 1. sequential:
[10:21:21.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.373]    - tweaked: FALSE
[10:21:21.373]    - call: NULL
[10:21:21.374] - globals: [0] <none>
[10:21:21.374] getGlobalsAndPackages() ... DONE
[10:21:21.374] plan(): nbrOfWorkers() = 1
[10:21:21.375] run() for ‘Future’ ...
[10:21:21.375] - state: ‘created’
[10:21:21.375] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.376] plan(): Setting new future strategy stack:
[10:21:21.376] List of future strategies:
[10:21:21.376] 1. multicore:
[10:21:21.376]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.376]    - tweaked: FALSE
[10:21:21.376]    - call: plan(strategy)
[10:21:21.378] plan(): nbrOfWorkers() = 2
[10:21:21.378] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.379] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.379]   - Field: ‘label’
[10:21:21.379]   - Field: ‘local’
[10:21:21.379]   - Field: ‘owner’
[10:21:21.379]   - Field: ‘envir’
[10:21:21.379]   - Field: ‘workers’
[10:21:21.379]   - Field: ‘packages’
[10:21:21.379]   - Field: ‘gc’
[10:21:21.380]   - Field: ‘job’
[10:21:21.380]   - Field: ‘conditions’
[10:21:21.380]   - Field: ‘expr’
[10:21:21.380]   - Field: ‘uuid’
[10:21:21.380]   - Field: ‘seed’
[10:21:21.380]   - Field: ‘version’
[10:21:21.380]   - Field: ‘result’
[10:21:21.381]   - Field: ‘asynchronous’
[10:21:21.381]   - Field: ‘calls’
[10:21:21.381]   - Field: ‘globals’
[10:21:21.381]   - Field: ‘stdout’
[10:21:21.381]   - Field: ‘earlySignal’
[10:21:21.381]   - Field: ‘lazy’
[10:21:21.381]   - Field: ‘state’
[10:21:21.381] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.382] - Launch lazy future ...
[10:21:21.382] Packages needed by the future expression (n = 0): <none>
[10:21:21.382] Packages needed by future strategies (n = 0): <none>
[10:21:21.383] {
[10:21:21.383]     {
[10:21:21.383]         {
[10:21:21.383]             ...future.startTime <- base::Sys.time()
[10:21:21.383]             {
[10:21:21.383]                 {
[10:21:21.383]                   {
[10:21:21.383]                     {
[10:21:21.383]                       base::local({
[10:21:21.383]                         has_future <- base::requireNamespace("future", 
[10:21:21.383]                           quietly = TRUE)
[10:21:21.383]                         if (has_future) {
[10:21:21.383]                           ns <- base::getNamespace("future")
[10:21:21.383]                           version <- ns[[".package"]][["version"]]
[10:21:21.383]                           if (is.null(version)) 
[10:21:21.383]                             version <- utils::packageVersion("future")
[10:21:21.383]                         }
[10:21:21.383]                         else {
[10:21:21.383]                           version <- NULL
[10:21:21.383]                         }
[10:21:21.383]                         if (!has_future || version < "1.8.0") {
[10:21:21.383]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.383]                             "", base::R.version$version.string), 
[10:21:21.383]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.383]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.383]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.383]                               "release", "version")], collapse = " "), 
[10:21:21.383]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.383]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.383]                             info)
[10:21:21.383]                           info <- base::paste(info, collapse = "; ")
[10:21:21.383]                           if (!has_future) {
[10:21:21.383]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.383]                               info)
[10:21:21.383]                           }
[10:21:21.383]                           else {
[10:21:21.383]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.383]                               info, version)
[10:21:21.383]                           }
[10:21:21.383]                           base::stop(msg)
[10:21:21.383]                         }
[10:21:21.383]                       })
[10:21:21.383]                     }
[10:21:21.383]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.383]                     base::options(mc.cores = 1L)
[10:21:21.383]                   }
[10:21:21.383]                   ...future.strategy.old <- future::plan("list")
[10:21:21.383]                   options(future.plan = NULL)
[10:21:21.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.383]                 }
[10:21:21.383]                 ...future.workdir <- getwd()
[10:21:21.383]             }
[10:21:21.383]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.383]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.383]         }
[10:21:21.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.383]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.383]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.383]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.383]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.383]             base::names(...future.oldOptions))
[10:21:21.383]     }
[10:21:21.383]     if (FALSE) {
[10:21:21.383]     }
[10:21:21.383]     else {
[10:21:21.383]         if (TRUE) {
[10:21:21.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.383]                 open = "w")
[10:21:21.383]         }
[10:21:21.383]         else {
[10:21:21.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.383]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.383]         }
[10:21:21.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.383]             base::sink(type = "output", split = FALSE)
[10:21:21.383]             base::close(...future.stdout)
[10:21:21.383]         }, add = TRUE)
[10:21:21.383]     }
[10:21:21.383]     ...future.frame <- base::sys.nframe()
[10:21:21.383]     ...future.conditions <- base::list()
[10:21:21.383]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.383]     if (FALSE) {
[10:21:21.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.383]     }
[10:21:21.383]     ...future.result <- base::tryCatch({
[10:21:21.383]         base::withCallingHandlers({
[10:21:21.383]             ...future.value <- base::withVisible(base::local({
[10:21:21.383]                 withCallingHandlers({
[10:21:21.383]                   NULL
[10:21:21.383]                 }, immediateCondition = function(cond) {
[10:21:21.383]                   save_rds <- function (object, pathname, ...) 
[10:21:21.383]                   {
[10:21:21.383]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.383]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.383]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.383]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.383]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.383]                         fi_tmp[["mtime"]])
[10:21:21.383]                     }
[10:21:21.383]                     tryCatch({
[10:21:21.383]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.383]                     }, error = function(ex) {
[10:21:21.383]                       msg <- conditionMessage(ex)
[10:21:21.383]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.383]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.383]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.383]                         fi_tmp[["mtime"]], msg)
[10:21:21.383]                       ex$message <- msg
[10:21:21.383]                       stop(ex)
[10:21:21.383]                     })
[10:21:21.383]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.383]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.383]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.383]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.383]                       fi <- file.info(pathname)
[10:21:21.383]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.383]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.383]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.383]                         fi[["size"]], fi[["mtime"]])
[10:21:21.383]                       stop(msg)
[10:21:21.383]                     }
[10:21:21.383]                     invisible(pathname)
[10:21:21.383]                   }
[10:21:21.383]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.383]                     rootPath = tempdir()) 
[10:21:21.383]                   {
[10:21:21.383]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.383]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.383]                       tmpdir = path, fileext = ".rds")
[10:21:21.383]                     save_rds(obj, file)
[10:21:21.383]                   }
[10:21:21.383]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.383]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.383]                   {
[10:21:21.383]                     inherits <- base::inherits
[10:21:21.383]                     invokeRestart <- base::invokeRestart
[10:21:21.383]                     is.null <- base::is.null
[10:21:21.383]                     muffled <- FALSE
[10:21:21.383]                     if (inherits(cond, "message")) {
[10:21:21.383]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.383]                       if (muffled) 
[10:21:21.383]                         invokeRestart("muffleMessage")
[10:21:21.383]                     }
[10:21:21.383]                     else if (inherits(cond, "warning")) {
[10:21:21.383]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.383]                       if (muffled) 
[10:21:21.383]                         invokeRestart("muffleWarning")
[10:21:21.383]                     }
[10:21:21.383]                     else if (inherits(cond, "condition")) {
[10:21:21.383]                       if (!is.null(pattern)) {
[10:21:21.383]                         computeRestarts <- base::computeRestarts
[10:21:21.383]                         grepl <- base::grepl
[10:21:21.383]                         restarts <- computeRestarts(cond)
[10:21:21.383]                         for (restart in restarts) {
[10:21:21.383]                           name <- restart$name
[10:21:21.383]                           if (is.null(name)) 
[10:21:21.383]                             next
[10:21:21.383]                           if (!grepl(pattern, name)) 
[10:21:21.383]                             next
[10:21:21.383]                           invokeRestart(restart)
[10:21:21.383]                           muffled <- TRUE
[10:21:21.383]                           break
[10:21:21.383]                         }
[10:21:21.383]                       }
[10:21:21.383]                     }
[10:21:21.383]                     invisible(muffled)
[10:21:21.383]                   }
[10:21:21.383]                   muffleCondition(cond)
[10:21:21.383]                 })
[10:21:21.383]             }))
[10:21:21.383]             future::FutureResult(value = ...future.value$value, 
[10:21:21.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.383]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.383]                     ...future.globalenv.names))
[10:21:21.383]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.383]         }, condition = base::local({
[10:21:21.383]             c <- base::c
[10:21:21.383]             inherits <- base::inherits
[10:21:21.383]             invokeRestart <- base::invokeRestart
[10:21:21.383]             length <- base::length
[10:21:21.383]             list <- base::list
[10:21:21.383]             seq.int <- base::seq.int
[10:21:21.383]             signalCondition <- base::signalCondition
[10:21:21.383]             sys.calls <- base::sys.calls
[10:21:21.383]             `[[` <- base::`[[`
[10:21:21.383]             `+` <- base::`+`
[10:21:21.383]             `<<-` <- base::`<<-`
[10:21:21.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.383]                   3L)]
[10:21:21.383]             }
[10:21:21.383]             function(cond) {
[10:21:21.383]                 is_error <- inherits(cond, "error")
[10:21:21.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.383]                   NULL)
[10:21:21.383]                 if (is_error) {
[10:21:21.383]                   sessionInformation <- function() {
[10:21:21.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.383]                       search = base::search(), system = base::Sys.info())
[10:21:21.383]                   }
[10:21:21.383]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.383]                     cond$call), session = sessionInformation(), 
[10:21:21.383]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.383]                   signalCondition(cond)
[10:21:21.383]                 }
[10:21:21.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.383]                 "immediateCondition"))) {
[10:21:21.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.383]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.383]                   if (TRUE && !signal) {
[10:21:21.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.383]                     {
[10:21:21.383]                       inherits <- base::inherits
[10:21:21.383]                       invokeRestart <- base::invokeRestart
[10:21:21.383]                       is.null <- base::is.null
[10:21:21.383]                       muffled <- FALSE
[10:21:21.383]                       if (inherits(cond, "message")) {
[10:21:21.383]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.383]                         if (muffled) 
[10:21:21.383]                           invokeRestart("muffleMessage")
[10:21:21.383]                       }
[10:21:21.383]                       else if (inherits(cond, "warning")) {
[10:21:21.383]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.383]                         if (muffled) 
[10:21:21.383]                           invokeRestart("muffleWarning")
[10:21:21.383]                       }
[10:21:21.383]                       else if (inherits(cond, "condition")) {
[10:21:21.383]                         if (!is.null(pattern)) {
[10:21:21.383]                           computeRestarts <- base::computeRestarts
[10:21:21.383]                           grepl <- base::grepl
[10:21:21.383]                           restarts <- computeRestarts(cond)
[10:21:21.383]                           for (restart in restarts) {
[10:21:21.383]                             name <- restart$name
[10:21:21.383]                             if (is.null(name)) 
[10:21:21.383]                               next
[10:21:21.383]                             if (!grepl(pattern, name)) 
[10:21:21.383]                               next
[10:21:21.383]                             invokeRestart(restart)
[10:21:21.383]                             muffled <- TRUE
[10:21:21.383]                             break
[10:21:21.383]                           }
[10:21:21.383]                         }
[10:21:21.383]                       }
[10:21:21.383]                       invisible(muffled)
[10:21:21.383]                     }
[10:21:21.383]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.383]                   }
[10:21:21.383]                 }
[10:21:21.383]                 else {
[10:21:21.383]                   if (TRUE) {
[10:21:21.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.383]                     {
[10:21:21.383]                       inherits <- base::inherits
[10:21:21.383]                       invokeRestart <- base::invokeRestart
[10:21:21.383]                       is.null <- base::is.null
[10:21:21.383]                       muffled <- FALSE
[10:21:21.383]                       if (inherits(cond, "message")) {
[10:21:21.383]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.383]                         if (muffled) 
[10:21:21.383]                           invokeRestart("muffleMessage")
[10:21:21.383]                       }
[10:21:21.383]                       else if (inherits(cond, "warning")) {
[10:21:21.383]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.383]                         if (muffled) 
[10:21:21.383]                           invokeRestart("muffleWarning")
[10:21:21.383]                       }
[10:21:21.383]                       else if (inherits(cond, "condition")) {
[10:21:21.383]                         if (!is.null(pattern)) {
[10:21:21.383]                           computeRestarts <- base::computeRestarts
[10:21:21.383]                           grepl <- base::grepl
[10:21:21.383]                           restarts <- computeRestarts(cond)
[10:21:21.383]                           for (restart in restarts) {
[10:21:21.383]                             name <- restart$name
[10:21:21.383]                             if (is.null(name)) 
[10:21:21.383]                               next
[10:21:21.383]                             if (!grepl(pattern, name)) 
[10:21:21.383]                               next
[10:21:21.383]                             invokeRestart(restart)
[10:21:21.383]                             muffled <- TRUE
[10:21:21.383]                             break
[10:21:21.383]                           }
[10:21:21.383]                         }
[10:21:21.383]                       }
[10:21:21.383]                       invisible(muffled)
[10:21:21.383]                     }
[10:21:21.383]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.383]                   }
[10:21:21.383]                 }
[10:21:21.383]             }
[10:21:21.383]         }))
[10:21:21.383]     }, error = function(ex) {
[10:21:21.383]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.383]                 ...future.rng), started = ...future.startTime, 
[10:21:21.383]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.383]             version = "1.8"), class = "FutureResult")
[10:21:21.383]     }, finally = {
[10:21:21.383]         if (!identical(...future.workdir, getwd())) 
[10:21:21.383]             setwd(...future.workdir)
[10:21:21.383]         {
[10:21:21.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.383]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.383]             }
[10:21:21.383]             base::options(...future.oldOptions)
[10:21:21.383]             if (.Platform$OS.type == "windows") {
[10:21:21.383]                 old_names <- names(...future.oldEnvVars)
[10:21:21.383]                 envs <- base::Sys.getenv()
[10:21:21.383]                 names <- names(envs)
[10:21:21.383]                 common <- intersect(names, old_names)
[10:21:21.383]                 added <- setdiff(names, old_names)
[10:21:21.383]                 removed <- setdiff(old_names, names)
[10:21:21.383]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.383]                   envs[common]]
[10:21:21.383]                 NAMES <- toupper(changed)
[10:21:21.383]                 args <- list()
[10:21:21.383]                 for (kk in seq_along(NAMES)) {
[10:21:21.383]                   name <- changed[[kk]]
[10:21:21.383]                   NAME <- NAMES[[kk]]
[10:21:21.383]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.383]                     next
[10:21:21.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.383]                 }
[10:21:21.383]                 NAMES <- toupper(added)
[10:21:21.383]                 for (kk in seq_along(NAMES)) {
[10:21:21.383]                   name <- added[[kk]]
[10:21:21.383]                   NAME <- NAMES[[kk]]
[10:21:21.383]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.383]                     next
[10:21:21.383]                   args[[name]] <- ""
[10:21:21.383]                 }
[10:21:21.383]                 NAMES <- toupper(removed)
[10:21:21.383]                 for (kk in seq_along(NAMES)) {
[10:21:21.383]                   name <- removed[[kk]]
[10:21:21.383]                   NAME <- NAMES[[kk]]
[10:21:21.383]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.383]                     next
[10:21:21.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.383]                 }
[10:21:21.383]                 if (length(args) > 0) 
[10:21:21.383]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.383]             }
[10:21:21.383]             else {
[10:21:21.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.383]             }
[10:21:21.383]             {
[10:21:21.383]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.383]                   0L) {
[10:21:21.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.383]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.383]                   base::options(opts)
[10:21:21.383]                 }
[10:21:21.383]                 {
[10:21:21.383]                   {
[10:21:21.383]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.383]                     NULL
[10:21:21.383]                   }
[10:21:21.383]                   options(future.plan = NULL)
[10:21:21.383]                   if (is.na(NA_character_)) 
[10:21:21.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.383]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.383]                     .init = FALSE)
[10:21:21.383]                 }
[10:21:21.383]             }
[10:21:21.383]         }
[10:21:21.383]     })
[10:21:21.383]     if (TRUE) {
[10:21:21.383]         base::sink(type = "output", split = FALSE)
[10:21:21.383]         if (TRUE) {
[10:21:21.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.383]         }
[10:21:21.383]         else {
[10:21:21.383]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.383]         }
[10:21:21.383]         base::close(...future.stdout)
[10:21:21.383]         ...future.stdout <- NULL
[10:21:21.383]     }
[10:21:21.383]     ...future.result$conditions <- ...future.conditions
[10:21:21.383]     ...future.result$finished <- base::Sys.time()
[10:21:21.383]     ...future.result
[10:21:21.383] }
[10:21:21.386] requestCore(): workers = 2
[10:21:21.389] MulticoreFuture started
[10:21:21.389] - Launch lazy future ... done
[10:21:21.389] run() for ‘MulticoreFuture’ ... done
[10:21:21.390] plan(): Setting new future strategy stack:
[10:21:21.390] getGlobalsAndPackages() ...
[10:21:21.390] Searching for globals...
[10:21:21.390] List of future strategies:
[10:21:21.390] 1. sequential:
[10:21:21.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.390]    - tweaked: FALSE
[10:21:21.390]    - call: NULL
[10:21:21.391] plan(): nbrOfWorkers() = 1
[10:21:21.392] - globals found: [1] ‘{’
[10:21:21.392] Searching for globals ... DONE
[10:21:21.392] Resolving globals: FALSE
[10:21:21.392] 
[10:21:21.393] 
[10:21:21.393] getGlobalsAndPackages() ... DONE
[10:21:21.393] plan(): Setting new future strategy stack:
[10:21:21.393] run() for ‘Future’ ...
[10:21:21.393] - state: ‘created’
[10:21:21.394] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.393] List of future strategies:
[10:21:21.393] 1. multicore:
[10:21:21.393]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.393]    - tweaked: FALSE
[10:21:21.393]    - call: plan(strategy)
[10:21:21.396] plan(): nbrOfWorkers() = 2
[10:21:21.396] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.397] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.397]   - Field: ‘label’
[10:21:21.397]   - Field: ‘local’
[10:21:21.397]   - Field: ‘owner’
[10:21:21.397]   - Field: ‘envir’
[10:21:21.397]   - Field: ‘workers’
[10:21:21.397]   - Field: ‘packages’
[10:21:21.398]   - Field: ‘gc’
[10:21:21.398]   - Field: ‘job’
[10:21:21.398]   - Field: ‘conditions’
[10:21:21.398]   - Field: ‘expr’
[10:21:21.398]   - Field: ‘uuid’
[10:21:21.398]   - Field: ‘seed’
[10:21:21.398]   - Field: ‘version’
[10:21:21.398]   - Field: ‘result’
[10:21:21.399]   - Field: ‘asynchronous’
[10:21:21.399]   - Field: ‘calls’
[10:21:21.399]   - Field: ‘globals’
[10:21:21.399]   - Field: ‘stdout’
[10:21:21.399]   - Field: ‘earlySignal’
[10:21:21.399]   - Field: ‘lazy’
[10:21:21.399]   - Field: ‘state’
[10:21:21.400] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.400] - Launch lazy future ...
[10:21:21.400] Packages needed by the future expression (n = 0): <none>
[10:21:21.407] Packages needed by future strategies (n = 0): <none>
[10:21:21.408] {
[10:21:21.408]     {
[10:21:21.408]         {
[10:21:21.408]             ...future.startTime <- base::Sys.time()
[10:21:21.408]             {
[10:21:21.408]                 {
[10:21:21.408]                   {
[10:21:21.408]                     {
[10:21:21.408]                       base::local({
[10:21:21.408]                         has_future <- base::requireNamespace("future", 
[10:21:21.408]                           quietly = TRUE)
[10:21:21.408]                         if (has_future) {
[10:21:21.408]                           ns <- base::getNamespace("future")
[10:21:21.408]                           version <- ns[[".package"]][["version"]]
[10:21:21.408]                           if (is.null(version)) 
[10:21:21.408]                             version <- utils::packageVersion("future")
[10:21:21.408]                         }
[10:21:21.408]                         else {
[10:21:21.408]                           version <- NULL
[10:21:21.408]                         }
[10:21:21.408]                         if (!has_future || version < "1.8.0") {
[10:21:21.408]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.408]                             "", base::R.version$version.string), 
[10:21:21.408]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.408]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.408]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.408]                               "release", "version")], collapse = " "), 
[10:21:21.408]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.408]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.408]                             info)
[10:21:21.408]                           info <- base::paste(info, collapse = "; ")
[10:21:21.408]                           if (!has_future) {
[10:21:21.408]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.408]                               info)
[10:21:21.408]                           }
[10:21:21.408]                           else {
[10:21:21.408]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.408]                               info, version)
[10:21:21.408]                           }
[10:21:21.408]                           base::stop(msg)
[10:21:21.408]                         }
[10:21:21.408]                       })
[10:21:21.408]                     }
[10:21:21.408]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.408]                     base::options(mc.cores = 1L)
[10:21:21.408]                   }
[10:21:21.408]                   ...future.strategy.old <- future::plan("list")
[10:21:21.408]                   options(future.plan = NULL)
[10:21:21.408]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.408]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.408]                 }
[10:21:21.408]                 ...future.workdir <- getwd()
[10:21:21.408]             }
[10:21:21.408]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.408]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.408]         }
[10:21:21.408]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.408]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.408]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.408]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.408]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.408]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.408]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.408]             base::names(...future.oldOptions))
[10:21:21.408]     }
[10:21:21.408]     if (FALSE) {
[10:21:21.408]     }
[10:21:21.408]     else {
[10:21:21.408]         if (TRUE) {
[10:21:21.408]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.408]                 open = "w")
[10:21:21.408]         }
[10:21:21.408]         else {
[10:21:21.408]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.408]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.408]         }
[10:21:21.408]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.408]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.408]             base::sink(type = "output", split = FALSE)
[10:21:21.408]             base::close(...future.stdout)
[10:21:21.408]         }, add = TRUE)
[10:21:21.408]     }
[10:21:21.408]     ...future.frame <- base::sys.nframe()
[10:21:21.408]     ...future.conditions <- base::list()
[10:21:21.408]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.408]     if (FALSE) {
[10:21:21.408]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.408]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.408]     }
[10:21:21.408]     ...future.result <- base::tryCatch({
[10:21:21.408]         base::withCallingHandlers({
[10:21:21.408]             ...future.value <- base::withVisible(base::local({
[10:21:21.408]                 withCallingHandlers({
[10:21:21.408]                   {
[10:21:21.408]                     4
[10:21:21.408]                   }
[10:21:21.408]                 }, immediateCondition = function(cond) {
[10:21:21.408]                   save_rds <- function (object, pathname, ...) 
[10:21:21.408]                   {
[10:21:21.408]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.408]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.408]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.408]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.408]                         fi_tmp[["mtime"]])
[10:21:21.408]                     }
[10:21:21.408]                     tryCatch({
[10:21:21.408]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.408]                     }, error = function(ex) {
[10:21:21.408]                       msg <- conditionMessage(ex)
[10:21:21.408]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.408]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.408]                         fi_tmp[["mtime"]], msg)
[10:21:21.408]                       ex$message <- msg
[10:21:21.408]                       stop(ex)
[10:21:21.408]                     })
[10:21:21.408]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.408]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.408]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.408]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.408]                       fi <- file.info(pathname)
[10:21:21.408]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.408]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.408]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.408]                         fi[["size"]], fi[["mtime"]])
[10:21:21.408]                       stop(msg)
[10:21:21.408]                     }
[10:21:21.408]                     invisible(pathname)
[10:21:21.408]                   }
[10:21:21.408]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.408]                     rootPath = tempdir()) 
[10:21:21.408]                   {
[10:21:21.408]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.408]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.408]                       tmpdir = path, fileext = ".rds")
[10:21:21.408]                     save_rds(obj, file)
[10:21:21.408]                   }
[10:21:21.408]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.408]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.408]                   {
[10:21:21.408]                     inherits <- base::inherits
[10:21:21.408]                     invokeRestart <- base::invokeRestart
[10:21:21.408]                     is.null <- base::is.null
[10:21:21.408]                     muffled <- FALSE
[10:21:21.408]                     if (inherits(cond, "message")) {
[10:21:21.408]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.408]                       if (muffled) 
[10:21:21.408]                         invokeRestart("muffleMessage")
[10:21:21.408]                     }
[10:21:21.408]                     else if (inherits(cond, "warning")) {
[10:21:21.408]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.408]                       if (muffled) 
[10:21:21.408]                         invokeRestart("muffleWarning")
[10:21:21.408]                     }
[10:21:21.408]                     else if (inherits(cond, "condition")) {
[10:21:21.408]                       if (!is.null(pattern)) {
[10:21:21.408]                         computeRestarts <- base::computeRestarts
[10:21:21.408]                         grepl <- base::grepl
[10:21:21.408]                         restarts <- computeRestarts(cond)
[10:21:21.408]                         for (restart in restarts) {
[10:21:21.408]                           name <- restart$name
[10:21:21.408]                           if (is.null(name)) 
[10:21:21.408]                             next
[10:21:21.408]                           if (!grepl(pattern, name)) 
[10:21:21.408]                             next
[10:21:21.408]                           invokeRestart(restart)
[10:21:21.408]                           muffled <- TRUE
[10:21:21.408]                           break
[10:21:21.408]                         }
[10:21:21.408]                       }
[10:21:21.408]                     }
[10:21:21.408]                     invisible(muffled)
[10:21:21.408]                   }
[10:21:21.408]                   muffleCondition(cond)
[10:21:21.408]                 })
[10:21:21.408]             }))
[10:21:21.408]             future::FutureResult(value = ...future.value$value, 
[10:21:21.408]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.408]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.408]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.408]                     ...future.globalenv.names))
[10:21:21.408]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.408]         }, condition = base::local({
[10:21:21.408]             c <- base::c
[10:21:21.408]             inherits <- base::inherits
[10:21:21.408]             invokeRestart <- base::invokeRestart
[10:21:21.408]             length <- base::length
[10:21:21.408]             list <- base::list
[10:21:21.408]             seq.int <- base::seq.int
[10:21:21.408]             signalCondition <- base::signalCondition
[10:21:21.408]             sys.calls <- base::sys.calls
[10:21:21.408]             `[[` <- base::`[[`
[10:21:21.408]             `+` <- base::`+`
[10:21:21.408]             `<<-` <- base::`<<-`
[10:21:21.408]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.408]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.408]                   3L)]
[10:21:21.408]             }
[10:21:21.408]             function(cond) {
[10:21:21.408]                 is_error <- inherits(cond, "error")
[10:21:21.408]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.408]                   NULL)
[10:21:21.408]                 if (is_error) {
[10:21:21.408]                   sessionInformation <- function() {
[10:21:21.408]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.408]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.408]                       search = base::search(), system = base::Sys.info())
[10:21:21.408]                   }
[10:21:21.408]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.408]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.408]                     cond$call), session = sessionInformation(), 
[10:21:21.408]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.408]                   signalCondition(cond)
[10:21:21.408]                 }
[10:21:21.408]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.408]                 "immediateCondition"))) {
[10:21:21.408]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.408]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.408]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.408]                   if (TRUE && !signal) {
[10:21:21.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.408]                     {
[10:21:21.408]                       inherits <- base::inherits
[10:21:21.408]                       invokeRestart <- base::invokeRestart
[10:21:21.408]                       is.null <- base::is.null
[10:21:21.408]                       muffled <- FALSE
[10:21:21.408]                       if (inherits(cond, "message")) {
[10:21:21.408]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.408]                         if (muffled) 
[10:21:21.408]                           invokeRestart("muffleMessage")
[10:21:21.408]                       }
[10:21:21.408]                       else if (inherits(cond, "warning")) {
[10:21:21.408]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.408]                         if (muffled) 
[10:21:21.408]                           invokeRestart("muffleWarning")
[10:21:21.408]                       }
[10:21:21.408]                       else if (inherits(cond, "condition")) {
[10:21:21.408]                         if (!is.null(pattern)) {
[10:21:21.408]                           computeRestarts <- base::computeRestarts
[10:21:21.408]                           grepl <- base::grepl
[10:21:21.408]                           restarts <- computeRestarts(cond)
[10:21:21.408]                           for (restart in restarts) {
[10:21:21.408]                             name <- restart$name
[10:21:21.408]                             if (is.null(name)) 
[10:21:21.408]                               next
[10:21:21.408]                             if (!grepl(pattern, name)) 
[10:21:21.408]                               next
[10:21:21.408]                             invokeRestart(restart)
[10:21:21.408]                             muffled <- TRUE
[10:21:21.408]                             break
[10:21:21.408]                           }
[10:21:21.408]                         }
[10:21:21.408]                       }
[10:21:21.408]                       invisible(muffled)
[10:21:21.408]                     }
[10:21:21.408]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.408]                   }
[10:21:21.408]                 }
[10:21:21.408]                 else {
[10:21:21.408]                   if (TRUE) {
[10:21:21.408]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.408]                     {
[10:21:21.408]                       inherits <- base::inherits
[10:21:21.408]                       invokeRestart <- base::invokeRestart
[10:21:21.408]                       is.null <- base::is.null
[10:21:21.408]                       muffled <- FALSE
[10:21:21.408]                       if (inherits(cond, "message")) {
[10:21:21.408]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.408]                         if (muffled) 
[10:21:21.408]                           invokeRestart("muffleMessage")
[10:21:21.408]                       }
[10:21:21.408]                       else if (inherits(cond, "warning")) {
[10:21:21.408]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.408]                         if (muffled) 
[10:21:21.408]                           invokeRestart("muffleWarning")
[10:21:21.408]                       }
[10:21:21.408]                       else if (inherits(cond, "condition")) {
[10:21:21.408]                         if (!is.null(pattern)) {
[10:21:21.408]                           computeRestarts <- base::computeRestarts
[10:21:21.408]                           grepl <- base::grepl
[10:21:21.408]                           restarts <- computeRestarts(cond)
[10:21:21.408]                           for (restart in restarts) {
[10:21:21.408]                             name <- restart$name
[10:21:21.408]                             if (is.null(name)) 
[10:21:21.408]                               next
[10:21:21.408]                             if (!grepl(pattern, name)) 
[10:21:21.408]                               next
[10:21:21.408]                             invokeRestart(restart)
[10:21:21.408]                             muffled <- TRUE
[10:21:21.408]                             break
[10:21:21.408]                           }
[10:21:21.408]                         }
[10:21:21.408]                       }
[10:21:21.408]                       invisible(muffled)
[10:21:21.408]                     }
[10:21:21.408]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.408]                   }
[10:21:21.408]                 }
[10:21:21.408]             }
[10:21:21.408]         }))
[10:21:21.408]     }, error = function(ex) {
[10:21:21.408]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.408]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.408]                 ...future.rng), started = ...future.startTime, 
[10:21:21.408]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.408]             version = "1.8"), class = "FutureResult")
[10:21:21.408]     }, finally = {
[10:21:21.408]         if (!identical(...future.workdir, getwd())) 
[10:21:21.408]             setwd(...future.workdir)
[10:21:21.408]         {
[10:21:21.408]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.408]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.408]             }
[10:21:21.408]             base::options(...future.oldOptions)
[10:21:21.408]             if (.Platform$OS.type == "windows") {
[10:21:21.408]                 old_names <- names(...future.oldEnvVars)
[10:21:21.408]                 envs <- base::Sys.getenv()
[10:21:21.408]                 names <- names(envs)
[10:21:21.408]                 common <- intersect(names, old_names)
[10:21:21.408]                 added <- setdiff(names, old_names)
[10:21:21.408]                 removed <- setdiff(old_names, names)
[10:21:21.408]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.408]                   envs[common]]
[10:21:21.408]                 NAMES <- toupper(changed)
[10:21:21.408]                 args <- list()
[10:21:21.408]                 for (kk in seq_along(NAMES)) {
[10:21:21.408]                   name <- changed[[kk]]
[10:21:21.408]                   NAME <- NAMES[[kk]]
[10:21:21.408]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.408]                     next
[10:21:21.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.408]                 }
[10:21:21.408]                 NAMES <- toupper(added)
[10:21:21.408]                 for (kk in seq_along(NAMES)) {
[10:21:21.408]                   name <- added[[kk]]
[10:21:21.408]                   NAME <- NAMES[[kk]]
[10:21:21.408]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.408]                     next
[10:21:21.408]                   args[[name]] <- ""
[10:21:21.408]                 }
[10:21:21.408]                 NAMES <- toupper(removed)
[10:21:21.408]                 for (kk in seq_along(NAMES)) {
[10:21:21.408]                   name <- removed[[kk]]
[10:21:21.408]                   NAME <- NAMES[[kk]]
[10:21:21.408]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.408]                     next
[10:21:21.408]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.408]                 }
[10:21:21.408]                 if (length(args) > 0) 
[10:21:21.408]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.408]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.408]             }
[10:21:21.408]             else {
[10:21:21.408]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.408]             }
[10:21:21.408]             {
[10:21:21.408]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.408]                   0L) {
[10:21:21.408]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.408]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.408]                   base::options(opts)
[10:21:21.408]                 }
[10:21:21.408]                 {
[10:21:21.408]                   {
[10:21:21.408]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.408]                     NULL
[10:21:21.408]                   }
[10:21:21.408]                   options(future.plan = NULL)
[10:21:21.408]                   if (is.na(NA_character_)) 
[10:21:21.408]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.408]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.408]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.408]                     .init = FALSE)
[10:21:21.408]                 }
[10:21:21.408]             }
[10:21:21.408]         }
[10:21:21.408]     })
[10:21:21.408]     if (TRUE) {
[10:21:21.408]         base::sink(type = "output", split = FALSE)
[10:21:21.408]         if (TRUE) {
[10:21:21.408]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.408]         }
[10:21:21.408]         else {
[10:21:21.408]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.408]         }
[10:21:21.408]         base::close(...future.stdout)
[10:21:21.408]         ...future.stdout <- NULL
[10:21:21.408]     }
[10:21:21.408]     ...future.result$conditions <- ...future.conditions
[10:21:21.408]     ...future.result$finished <- base::Sys.time()
[10:21:21.408]     ...future.result
[10:21:21.408] }
[10:21:21.411] requestCore(): workers = 2
[10:21:21.411] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:21.434] result() for MulticoreFuture ...
[10:21:21.435] result() for MulticoreFuture ...
[10:21:21.435] result() for MulticoreFuture ... done
[10:21:21.436] result() for MulticoreFuture ... done
[10:21:21.436] result() for MulticoreFuture ...
[10:21:21.436] result() for MulticoreFuture ... done
[10:21:21.439] MulticoreFuture started
[10:21:21.439] - Launch lazy future ... done
[10:21:21.439] run() for ‘MulticoreFuture’ ... done
[10:21:21.440] plan(): Setting new future strategy stack:
<environment: 0x55e8e6d72ff8> 
[10:21:21.440] List of future strategies:
[10:21:21.440] 1. sequential:
[10:21:21.440]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.440]    - tweaked: FALSE
[10:21:21.440]    - call: NULL
[10:21:21.442] plan(): nbrOfWorkers() = 1
<environment: 0x55e8e4d60a48> 
[10:21:21.445] plan(): Setting new future strategy stack:
[10:21:21.445] List of future strategies:
[10:21:21.445] 1. multicore:
[10:21:21.445]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.445]    - tweaked: FALSE
[10:21:21.445]    - call: plan(strategy)
[10:21:21.448] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:21.450] resolve() on environment ...
[10:21:21.450]  recursive: 0
[10:21:21.451]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:21.452] signalConditionsASAP(numeric, pos=1) ...
[10:21:21.452] - nx: 4
[10:21:21.452] - relay: TRUE
[10:21:21.452] - stdout: TRUE
[10:21:21.452] - signal: TRUE
[10:21:21.452] - resignal: FALSE
[10:21:21.452] - force: TRUE
[10:21:21.452] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.453] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.453]  - until=2
[10:21:21.453]  - relaying element #2
[10:21:21.453] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.453] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.453] signalConditionsASAP(NULL, pos=1) ... done
[10:21:21.453]  length: 3 (resolved future 1)
[10:21:21.454] Future #2
[10:21:21.454] result() for MulticoreFuture ...
[10:21:21.454] result() for MulticoreFuture ... done
[10:21:21.454] result() for MulticoreFuture ...
[10:21:21.454] result() for MulticoreFuture ... done
[10:21:21.454] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:21.455] - nx: 4
[10:21:21.455] - relay: TRUE
[10:21:21.455] - stdout: TRUE
[10:21:21.455] - signal: TRUE
[10:21:21.455] - resignal: FALSE
[10:21:21.455] - force: TRUE
[10:21:21.455] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.455] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.455]  - until=2
[10:21:21.456]  - relaying element #2
[10:21:21.456] result() for MulticoreFuture ...
[10:21:21.456] result() for MulticoreFuture ... done
[10:21:21.456] result() for MulticoreFuture ...
[10:21:21.456] result() for MulticoreFuture ... done
[10:21:21.456] result() for MulticoreFuture ...
[10:21:21.457] result() for MulticoreFuture ... done
[10:21:21.457] result() for MulticoreFuture ...
[10:21:21.457] result() for MulticoreFuture ... done
[10:21:21.457] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.457] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.457] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:21.457]  length: 2 (resolved future 2)
[10:21:21.458] Future #3
[10:21:21.458] result() for MulticoreFuture ...
[10:21:21.459] result() for MulticoreFuture ...
[10:21:21.459] result() for MulticoreFuture ... done
[10:21:21.459] result() for MulticoreFuture ... done
[10:21:21.459] result() for MulticoreFuture ...
[10:21:21.459] result() for MulticoreFuture ... done
[10:21:21.460] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:21.460] - nx: 4
[10:21:21.460] - relay: TRUE
[10:21:21.460] - stdout: TRUE
[10:21:21.460] - signal: TRUE
[10:21:21.460] - resignal: FALSE
[10:21:21.461] - force: TRUE
[10:21:21.461] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.461] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.461]  - until=3
[10:21:21.461]  - relaying element #3
[10:21:21.461] result() for MulticoreFuture ...
[10:21:21.462] result() for MulticoreFuture ... done
[10:21:21.462] result() for MulticoreFuture ...
[10:21:21.462] result() for MulticoreFuture ... done
[10:21:21.462] result() for MulticoreFuture ...
[10:21:21.462] result() for MulticoreFuture ... done
[10:21:21.463] result() for MulticoreFuture ...
[10:21:21.463] result() for MulticoreFuture ... done
[10:21:21.463] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.463] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.463] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:21.463]  length: 1 (resolved future 3)
[10:21:21.464] Future #4
[10:21:21.464] result() for MulticoreFuture ...
[10:21:21.465] result() for MulticoreFuture ...
[10:21:21.465] result() for MulticoreFuture ... done
[10:21:21.465] result() for MulticoreFuture ... done
[10:21:21.465] result() for MulticoreFuture ...
[10:21:21.465] result() for MulticoreFuture ... done
[10:21:21.466] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:21.466] - nx: 4
[10:21:21.466] - relay: TRUE
[10:21:21.466] - stdout: TRUE
[10:21:21.466] - signal: TRUE
[10:21:21.466] - resignal: FALSE
[10:21:21.466] - force: TRUE
[10:21:21.467] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.467] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.467]  - until=4
[10:21:21.467]  - relaying element #4
[10:21:21.467] result() for MulticoreFuture ...
[10:21:21.467] result() for MulticoreFuture ... done
[10:21:21.468] result() for MulticoreFuture ...
[10:21:21.468] result() for MulticoreFuture ... done
[10:21:21.468] result() for MulticoreFuture ...
[10:21:21.468] result() for MulticoreFuture ... done
[10:21:21.468] result() for MulticoreFuture ...
[10:21:21.468] result() for MulticoreFuture ... done
[10:21:21.469] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.469] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.469] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:21.469]  length: 0 (resolved future 4)
[10:21:21.469] Relaying remaining futures
[10:21:21.469] signalConditionsASAP(NULL, pos=0) ...
[10:21:21.469] - nx: 4
[10:21:21.470] - relay: TRUE
[10:21:21.470] - stdout: TRUE
[10:21:21.470] - signal: TRUE
[10:21:21.470] - resignal: FALSE
[10:21:21.470] - force: TRUE
[10:21:21.470] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.470] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:21.470] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.470] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.470] signalConditionsASAP(NULL, pos=0) ... done
[10:21:21.471] resolve() on environment ... DONE
[10:21:21.471] result() for MulticoreFuture ...
[10:21:21.471] result() for MulticoreFuture ... done
[10:21:21.471] result() for MulticoreFuture ...
[10:21:21.471] result() for MulticoreFuture ... done
[10:21:21.471] result() for MulticoreFuture ...
[10:21:21.471] result() for MulticoreFuture ... done
[10:21:21.471] result() for MulticoreFuture ...
[10:21:21.471] result() for MulticoreFuture ... done
[10:21:21.472] result() for MulticoreFuture ...
[10:21:21.472] result() for MulticoreFuture ... done
[10:21:21.472] result() for MulticoreFuture ...
[10:21:21.472] result() for MulticoreFuture ... done
<environment: 0x55e8e4b0dcb0> 
Dimensions: c(2, 3)
[10:21:21.472] getGlobalsAndPackages() ...
[10:21:21.473] Searching for globals...
[10:21:21.473] 
[10:21:21.473] Searching for globals ... DONE
[10:21:21.473] - globals: [0] <none>
[10:21:21.473] getGlobalsAndPackages() ... DONE
[10:21:21.474] run() for ‘Future’ ...
[10:21:21.474] - state: ‘created’
[10:21:21.474] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.476] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.476] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.476]   - Field: ‘label’
[10:21:21.476]   - Field: ‘local’
[10:21:21.476]   - Field: ‘owner’
[10:21:21.477]   - Field: ‘envir’
[10:21:21.477]   - Field: ‘workers’
[10:21:21.477]   - Field: ‘packages’
[10:21:21.477]   - Field: ‘gc’
[10:21:21.477]   - Field: ‘job’
[10:21:21.477]   - Field: ‘conditions’
[10:21:21.477]   - Field: ‘expr’
[10:21:21.477]   - Field: ‘uuid’
[10:21:21.477]   - Field: ‘seed’
[10:21:21.478]   - Field: ‘version’
[10:21:21.478]   - Field: ‘result’
[10:21:21.478]   - Field: ‘asynchronous’
[10:21:21.478]   - Field: ‘calls’
[10:21:21.478]   - Field: ‘globals’
[10:21:21.478]   - Field: ‘stdout’
[10:21:21.478]   - Field: ‘earlySignal’
[10:21:21.478]   - Field: ‘lazy’
[10:21:21.478]   - Field: ‘state’
[10:21:21.478] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.479] - Launch lazy future ...
[10:21:21.479] Packages needed by the future expression (n = 0): <none>
[10:21:21.479] Packages needed by future strategies (n = 0): <none>
[10:21:21.480] {
[10:21:21.480]     {
[10:21:21.480]         {
[10:21:21.480]             ...future.startTime <- base::Sys.time()
[10:21:21.480]             {
[10:21:21.480]                 {
[10:21:21.480]                   {
[10:21:21.480]                     {
[10:21:21.480]                       base::local({
[10:21:21.480]                         has_future <- base::requireNamespace("future", 
[10:21:21.480]                           quietly = TRUE)
[10:21:21.480]                         if (has_future) {
[10:21:21.480]                           ns <- base::getNamespace("future")
[10:21:21.480]                           version <- ns[[".package"]][["version"]]
[10:21:21.480]                           if (is.null(version)) 
[10:21:21.480]                             version <- utils::packageVersion("future")
[10:21:21.480]                         }
[10:21:21.480]                         else {
[10:21:21.480]                           version <- NULL
[10:21:21.480]                         }
[10:21:21.480]                         if (!has_future || version < "1.8.0") {
[10:21:21.480]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.480]                             "", base::R.version$version.string), 
[10:21:21.480]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.480]                               "release", "version")], collapse = " "), 
[10:21:21.480]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.480]                             info)
[10:21:21.480]                           info <- base::paste(info, collapse = "; ")
[10:21:21.480]                           if (!has_future) {
[10:21:21.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.480]                               info)
[10:21:21.480]                           }
[10:21:21.480]                           else {
[10:21:21.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.480]                               info, version)
[10:21:21.480]                           }
[10:21:21.480]                           base::stop(msg)
[10:21:21.480]                         }
[10:21:21.480]                       })
[10:21:21.480]                     }
[10:21:21.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.480]                     base::options(mc.cores = 1L)
[10:21:21.480]                   }
[10:21:21.480]                   ...future.strategy.old <- future::plan("list")
[10:21:21.480]                   options(future.plan = NULL)
[10:21:21.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.480]                 }
[10:21:21.480]                 ...future.workdir <- getwd()
[10:21:21.480]             }
[10:21:21.480]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.480]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.480]         }
[10:21:21.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.480]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.480]             base::names(...future.oldOptions))
[10:21:21.480]     }
[10:21:21.480]     if (FALSE) {
[10:21:21.480]     }
[10:21:21.480]     else {
[10:21:21.480]         if (TRUE) {
[10:21:21.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.480]                 open = "w")
[10:21:21.480]         }
[10:21:21.480]         else {
[10:21:21.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.480]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.480]         }
[10:21:21.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.480]             base::sink(type = "output", split = FALSE)
[10:21:21.480]             base::close(...future.stdout)
[10:21:21.480]         }, add = TRUE)
[10:21:21.480]     }
[10:21:21.480]     ...future.frame <- base::sys.nframe()
[10:21:21.480]     ...future.conditions <- base::list()
[10:21:21.480]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.480]     if (FALSE) {
[10:21:21.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.480]     }
[10:21:21.480]     ...future.result <- base::tryCatch({
[10:21:21.480]         base::withCallingHandlers({
[10:21:21.480]             ...future.value <- base::withVisible(base::local({
[10:21:21.480]                 withCallingHandlers({
[10:21:21.480]                   2
[10:21:21.480]                 }, immediateCondition = function(cond) {
[10:21:21.480]                   save_rds <- function (object, pathname, ...) 
[10:21:21.480]                   {
[10:21:21.480]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.480]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.480]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.480]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.480]                         fi_tmp[["mtime"]])
[10:21:21.480]                     }
[10:21:21.480]                     tryCatch({
[10:21:21.480]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.480]                     }, error = function(ex) {
[10:21:21.480]                       msg <- conditionMessage(ex)
[10:21:21.480]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.480]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.480]                         fi_tmp[["mtime"]], msg)
[10:21:21.480]                       ex$message <- msg
[10:21:21.480]                       stop(ex)
[10:21:21.480]                     })
[10:21:21.480]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.480]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.480]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.480]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.480]                       fi <- file.info(pathname)
[10:21:21.480]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.480]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.480]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.480]                         fi[["size"]], fi[["mtime"]])
[10:21:21.480]                       stop(msg)
[10:21:21.480]                     }
[10:21:21.480]                     invisible(pathname)
[10:21:21.480]                   }
[10:21:21.480]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.480]                     rootPath = tempdir()) 
[10:21:21.480]                   {
[10:21:21.480]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.480]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.480]                       tmpdir = path, fileext = ".rds")
[10:21:21.480]                     save_rds(obj, file)
[10:21:21.480]                   }
[10:21:21.480]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.480]                   {
[10:21:21.480]                     inherits <- base::inherits
[10:21:21.480]                     invokeRestart <- base::invokeRestart
[10:21:21.480]                     is.null <- base::is.null
[10:21:21.480]                     muffled <- FALSE
[10:21:21.480]                     if (inherits(cond, "message")) {
[10:21:21.480]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.480]                       if (muffled) 
[10:21:21.480]                         invokeRestart("muffleMessage")
[10:21:21.480]                     }
[10:21:21.480]                     else if (inherits(cond, "warning")) {
[10:21:21.480]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.480]                       if (muffled) 
[10:21:21.480]                         invokeRestart("muffleWarning")
[10:21:21.480]                     }
[10:21:21.480]                     else if (inherits(cond, "condition")) {
[10:21:21.480]                       if (!is.null(pattern)) {
[10:21:21.480]                         computeRestarts <- base::computeRestarts
[10:21:21.480]                         grepl <- base::grepl
[10:21:21.480]                         restarts <- computeRestarts(cond)
[10:21:21.480]                         for (restart in restarts) {
[10:21:21.480]                           name <- restart$name
[10:21:21.480]                           if (is.null(name)) 
[10:21:21.480]                             next
[10:21:21.480]                           if (!grepl(pattern, name)) 
[10:21:21.480]                             next
[10:21:21.480]                           invokeRestart(restart)
[10:21:21.480]                           muffled <- TRUE
[10:21:21.480]                           break
[10:21:21.480]                         }
[10:21:21.480]                       }
[10:21:21.480]                     }
[10:21:21.480]                     invisible(muffled)
[10:21:21.480]                   }
[10:21:21.480]                   muffleCondition(cond)
[10:21:21.480]                 })
[10:21:21.480]             }))
[10:21:21.480]             future::FutureResult(value = ...future.value$value, 
[10:21:21.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.480]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.480]                     ...future.globalenv.names))
[10:21:21.480]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.480]         }, condition = base::local({
[10:21:21.480]             c <- base::c
[10:21:21.480]             inherits <- base::inherits
[10:21:21.480]             invokeRestart <- base::invokeRestart
[10:21:21.480]             length <- base::length
[10:21:21.480]             list <- base::list
[10:21:21.480]             seq.int <- base::seq.int
[10:21:21.480]             signalCondition <- base::signalCondition
[10:21:21.480]             sys.calls <- base::sys.calls
[10:21:21.480]             `[[` <- base::`[[`
[10:21:21.480]             `+` <- base::`+`
[10:21:21.480]             `<<-` <- base::`<<-`
[10:21:21.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.480]                   3L)]
[10:21:21.480]             }
[10:21:21.480]             function(cond) {
[10:21:21.480]                 is_error <- inherits(cond, "error")
[10:21:21.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.480]                   NULL)
[10:21:21.480]                 if (is_error) {
[10:21:21.480]                   sessionInformation <- function() {
[10:21:21.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.480]                       search = base::search(), system = base::Sys.info())
[10:21:21.480]                   }
[10:21:21.480]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.480]                     cond$call), session = sessionInformation(), 
[10:21:21.480]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.480]                   signalCondition(cond)
[10:21:21.480]                 }
[10:21:21.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.480]                 "immediateCondition"))) {
[10:21:21.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.480]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.480]                   if (TRUE && !signal) {
[10:21:21.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.480]                     {
[10:21:21.480]                       inherits <- base::inherits
[10:21:21.480]                       invokeRestart <- base::invokeRestart
[10:21:21.480]                       is.null <- base::is.null
[10:21:21.480]                       muffled <- FALSE
[10:21:21.480]                       if (inherits(cond, "message")) {
[10:21:21.480]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.480]                         if (muffled) 
[10:21:21.480]                           invokeRestart("muffleMessage")
[10:21:21.480]                       }
[10:21:21.480]                       else if (inherits(cond, "warning")) {
[10:21:21.480]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.480]                         if (muffled) 
[10:21:21.480]                           invokeRestart("muffleWarning")
[10:21:21.480]                       }
[10:21:21.480]                       else if (inherits(cond, "condition")) {
[10:21:21.480]                         if (!is.null(pattern)) {
[10:21:21.480]                           computeRestarts <- base::computeRestarts
[10:21:21.480]                           grepl <- base::grepl
[10:21:21.480]                           restarts <- computeRestarts(cond)
[10:21:21.480]                           for (restart in restarts) {
[10:21:21.480]                             name <- restart$name
[10:21:21.480]                             if (is.null(name)) 
[10:21:21.480]                               next
[10:21:21.480]                             if (!grepl(pattern, name)) 
[10:21:21.480]                               next
[10:21:21.480]                             invokeRestart(restart)
[10:21:21.480]                             muffled <- TRUE
[10:21:21.480]                             break
[10:21:21.480]                           }
[10:21:21.480]                         }
[10:21:21.480]                       }
[10:21:21.480]                       invisible(muffled)
[10:21:21.480]                     }
[10:21:21.480]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.480]                   }
[10:21:21.480]                 }
[10:21:21.480]                 else {
[10:21:21.480]                   if (TRUE) {
[10:21:21.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.480]                     {
[10:21:21.480]                       inherits <- base::inherits
[10:21:21.480]                       invokeRestart <- base::invokeRestart
[10:21:21.480]                       is.null <- base::is.null
[10:21:21.480]                       muffled <- FALSE
[10:21:21.480]                       if (inherits(cond, "message")) {
[10:21:21.480]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.480]                         if (muffled) 
[10:21:21.480]                           invokeRestart("muffleMessage")
[10:21:21.480]                       }
[10:21:21.480]                       else if (inherits(cond, "warning")) {
[10:21:21.480]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.480]                         if (muffled) 
[10:21:21.480]                           invokeRestart("muffleWarning")
[10:21:21.480]                       }
[10:21:21.480]                       else if (inherits(cond, "condition")) {
[10:21:21.480]                         if (!is.null(pattern)) {
[10:21:21.480]                           computeRestarts <- base::computeRestarts
[10:21:21.480]                           grepl <- base::grepl
[10:21:21.480]                           restarts <- computeRestarts(cond)
[10:21:21.480]                           for (restart in restarts) {
[10:21:21.480]                             name <- restart$name
[10:21:21.480]                             if (is.null(name)) 
[10:21:21.480]                               next
[10:21:21.480]                             if (!grepl(pattern, name)) 
[10:21:21.480]                               next
[10:21:21.480]                             invokeRestart(restart)
[10:21:21.480]                             muffled <- TRUE
[10:21:21.480]                             break
[10:21:21.480]                           }
[10:21:21.480]                         }
[10:21:21.480]                       }
[10:21:21.480]                       invisible(muffled)
[10:21:21.480]                     }
[10:21:21.480]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.480]                   }
[10:21:21.480]                 }
[10:21:21.480]             }
[10:21:21.480]         }))
[10:21:21.480]     }, error = function(ex) {
[10:21:21.480]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.480]                 ...future.rng), started = ...future.startTime, 
[10:21:21.480]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.480]             version = "1.8"), class = "FutureResult")
[10:21:21.480]     }, finally = {
[10:21:21.480]         if (!identical(...future.workdir, getwd())) 
[10:21:21.480]             setwd(...future.workdir)
[10:21:21.480]         {
[10:21:21.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.480]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.480]             }
[10:21:21.480]             base::options(...future.oldOptions)
[10:21:21.480]             if (.Platform$OS.type == "windows") {
[10:21:21.480]                 old_names <- names(...future.oldEnvVars)
[10:21:21.480]                 envs <- base::Sys.getenv()
[10:21:21.480]                 names <- names(envs)
[10:21:21.480]                 common <- intersect(names, old_names)
[10:21:21.480]                 added <- setdiff(names, old_names)
[10:21:21.480]                 removed <- setdiff(old_names, names)
[10:21:21.480]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.480]                   envs[common]]
[10:21:21.480]                 NAMES <- toupper(changed)
[10:21:21.480]                 args <- list()
[10:21:21.480]                 for (kk in seq_along(NAMES)) {
[10:21:21.480]                   name <- changed[[kk]]
[10:21:21.480]                   NAME <- NAMES[[kk]]
[10:21:21.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.480]                     next
[10:21:21.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.480]                 }
[10:21:21.480]                 NAMES <- toupper(added)
[10:21:21.480]                 for (kk in seq_along(NAMES)) {
[10:21:21.480]                   name <- added[[kk]]
[10:21:21.480]                   NAME <- NAMES[[kk]]
[10:21:21.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.480]                     next
[10:21:21.480]                   args[[name]] <- ""
[10:21:21.480]                 }
[10:21:21.480]                 NAMES <- toupper(removed)
[10:21:21.480]                 for (kk in seq_along(NAMES)) {
[10:21:21.480]                   name <- removed[[kk]]
[10:21:21.480]                   NAME <- NAMES[[kk]]
[10:21:21.480]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.480]                     next
[10:21:21.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.480]                 }
[10:21:21.480]                 if (length(args) > 0) 
[10:21:21.480]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.480]             }
[10:21:21.480]             else {
[10:21:21.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.480]             }
[10:21:21.480]             {
[10:21:21.480]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.480]                   0L) {
[10:21:21.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.480]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.480]                   base::options(opts)
[10:21:21.480]                 }
[10:21:21.480]                 {
[10:21:21.480]                   {
[10:21:21.480]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.480]                     NULL
[10:21:21.480]                   }
[10:21:21.480]                   options(future.plan = NULL)
[10:21:21.480]                   if (is.na(NA_character_)) 
[10:21:21.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.480]                     .init = FALSE)
[10:21:21.480]                 }
[10:21:21.480]             }
[10:21:21.480]         }
[10:21:21.480]     })
[10:21:21.480]     if (TRUE) {
[10:21:21.480]         base::sink(type = "output", split = FALSE)
[10:21:21.480]         if (TRUE) {
[10:21:21.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.480]         }
[10:21:21.480]         else {
[10:21:21.480]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.480]         }
[10:21:21.480]         base::close(...future.stdout)
[10:21:21.480]         ...future.stdout <- NULL
[10:21:21.480]     }
[10:21:21.480]     ...future.result$conditions <- ...future.conditions
[10:21:21.480]     ...future.result$finished <- base::Sys.time()
[10:21:21.480]     ...future.result
[10:21:21.480] }
[10:21:21.482] requestCore(): workers = 2
[10:21:21.484] MulticoreFuture started
[10:21:21.485] - Launch lazy future ... done
[10:21:21.485] run() for ‘MulticoreFuture’ ... done
[10:21:21.485] getGlobalsAndPackages() ...
[10:21:21.485] Searching for globals...
[10:21:21.486] plan(): Setting new future strategy stack:
[10:21:21.486] 
[10:21:21.486] Searching for globals ... DONE
[10:21:21.486] List of future strategies:
[10:21:21.486] 1. sequential:
[10:21:21.486]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.486]    - tweaked: FALSE
[10:21:21.486]    - call: NULL
[10:21:21.486] - globals: [0] <none>
[10:21:21.487] getGlobalsAndPackages() ... DONE
[10:21:21.487] plan(): nbrOfWorkers() = 1
[10:21:21.487] run() for ‘Future’ ...
[10:21:21.487] - state: ‘created’
[10:21:21.487] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.489] plan(): Setting new future strategy stack:
[10:21:21.489] List of future strategies:
[10:21:21.489] 1. multicore:
[10:21:21.489]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.489]    - tweaked: FALSE
[10:21:21.489]    - call: plan(strategy)
[10:21:21.491] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.491] plan(): nbrOfWorkers() = 2
[10:21:21.491]   - Field: ‘label’
[10:21:21.491]   - Field: ‘local’
[10:21:21.491]   - Field: ‘owner’
[10:21:21.492]   - Field: ‘envir’
[10:21:21.492]   - Field: ‘workers’
[10:21:21.492]   - Field: ‘packages’
[10:21:21.492]   - Field: ‘gc’
[10:21:21.492]   - Field: ‘job’
[10:21:21.492]   - Field: ‘conditions’
[10:21:21.492]   - Field: ‘expr’
[10:21:21.492]   - Field: ‘uuid’
[10:21:21.493]   - Field: ‘seed’
[10:21:21.493]   - Field: ‘version’
[10:21:21.493]   - Field: ‘result’
[10:21:21.493]   - Field: ‘asynchronous’
[10:21:21.493]   - Field: ‘calls’
[10:21:21.493]   - Field: ‘globals’
[10:21:21.493]   - Field: ‘stdout’
[10:21:21.494]   - Field: ‘earlySignal’
[10:21:21.494]   - Field: ‘lazy’
[10:21:21.494]   - Field: ‘state’
[10:21:21.494] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.494] - Launch lazy future ...
[10:21:21.495] Packages needed by the future expression (n = 0): <none>
[10:21:21.495] Packages needed by future strategies (n = 0): <none>
[10:21:21.495] {
[10:21:21.495]     {
[10:21:21.495]         {
[10:21:21.495]             ...future.startTime <- base::Sys.time()
[10:21:21.495]             {
[10:21:21.495]                 {
[10:21:21.495]                   {
[10:21:21.495]                     {
[10:21:21.495]                       base::local({
[10:21:21.495]                         has_future <- base::requireNamespace("future", 
[10:21:21.495]                           quietly = TRUE)
[10:21:21.495]                         if (has_future) {
[10:21:21.495]                           ns <- base::getNamespace("future")
[10:21:21.495]                           version <- ns[[".package"]][["version"]]
[10:21:21.495]                           if (is.null(version)) 
[10:21:21.495]                             version <- utils::packageVersion("future")
[10:21:21.495]                         }
[10:21:21.495]                         else {
[10:21:21.495]                           version <- NULL
[10:21:21.495]                         }
[10:21:21.495]                         if (!has_future || version < "1.8.0") {
[10:21:21.495]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.495]                             "", base::R.version$version.string), 
[10:21:21.495]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.495]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.495]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.495]                               "release", "version")], collapse = " "), 
[10:21:21.495]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.495]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.495]                             info)
[10:21:21.495]                           info <- base::paste(info, collapse = "; ")
[10:21:21.495]                           if (!has_future) {
[10:21:21.495]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.495]                               info)
[10:21:21.495]                           }
[10:21:21.495]                           else {
[10:21:21.495]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.495]                               info, version)
[10:21:21.495]                           }
[10:21:21.495]                           base::stop(msg)
[10:21:21.495]                         }
[10:21:21.495]                       })
[10:21:21.495]                     }
[10:21:21.495]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.495]                     base::options(mc.cores = 1L)
[10:21:21.495]                   }
[10:21:21.495]                   ...future.strategy.old <- future::plan("list")
[10:21:21.495]                   options(future.plan = NULL)
[10:21:21.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.495]                 }
[10:21:21.495]                 ...future.workdir <- getwd()
[10:21:21.495]             }
[10:21:21.495]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.495]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.495]         }
[10:21:21.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.495]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.495]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.495]             base::names(...future.oldOptions))
[10:21:21.495]     }
[10:21:21.495]     if (FALSE) {
[10:21:21.495]     }
[10:21:21.495]     else {
[10:21:21.495]         if (TRUE) {
[10:21:21.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.495]                 open = "w")
[10:21:21.495]         }
[10:21:21.495]         else {
[10:21:21.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.495]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.495]         }
[10:21:21.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.495]             base::sink(type = "output", split = FALSE)
[10:21:21.495]             base::close(...future.stdout)
[10:21:21.495]         }, add = TRUE)
[10:21:21.495]     }
[10:21:21.495]     ...future.frame <- base::sys.nframe()
[10:21:21.495]     ...future.conditions <- base::list()
[10:21:21.495]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.495]     if (FALSE) {
[10:21:21.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.495]     }
[10:21:21.495]     ...future.result <- base::tryCatch({
[10:21:21.495]         base::withCallingHandlers({
[10:21:21.495]             ...future.value <- base::withVisible(base::local({
[10:21:21.495]                 withCallingHandlers({
[10:21:21.495]                   NULL
[10:21:21.495]                 }, immediateCondition = function(cond) {
[10:21:21.495]                   save_rds <- function (object, pathname, ...) 
[10:21:21.495]                   {
[10:21:21.495]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.495]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.495]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.495]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.495]                         fi_tmp[["mtime"]])
[10:21:21.495]                     }
[10:21:21.495]                     tryCatch({
[10:21:21.495]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.495]                     }, error = function(ex) {
[10:21:21.495]                       msg <- conditionMessage(ex)
[10:21:21.495]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.495]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.495]                         fi_tmp[["mtime"]], msg)
[10:21:21.495]                       ex$message <- msg
[10:21:21.495]                       stop(ex)
[10:21:21.495]                     })
[10:21:21.495]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.495]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.495]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.495]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.495]                       fi <- file.info(pathname)
[10:21:21.495]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.495]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.495]                         fi[["size"]], fi[["mtime"]])
[10:21:21.495]                       stop(msg)
[10:21:21.495]                     }
[10:21:21.495]                     invisible(pathname)
[10:21:21.495]                   }
[10:21:21.495]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.495]                     rootPath = tempdir()) 
[10:21:21.495]                   {
[10:21:21.495]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.495]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.495]                       tmpdir = path, fileext = ".rds")
[10:21:21.495]                     save_rds(obj, file)
[10:21:21.495]                   }
[10:21:21.495]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.495]                   {
[10:21:21.495]                     inherits <- base::inherits
[10:21:21.495]                     invokeRestart <- base::invokeRestart
[10:21:21.495]                     is.null <- base::is.null
[10:21:21.495]                     muffled <- FALSE
[10:21:21.495]                     if (inherits(cond, "message")) {
[10:21:21.495]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.495]                       if (muffled) 
[10:21:21.495]                         invokeRestart("muffleMessage")
[10:21:21.495]                     }
[10:21:21.495]                     else if (inherits(cond, "warning")) {
[10:21:21.495]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.495]                       if (muffled) 
[10:21:21.495]                         invokeRestart("muffleWarning")
[10:21:21.495]                     }
[10:21:21.495]                     else if (inherits(cond, "condition")) {
[10:21:21.495]                       if (!is.null(pattern)) {
[10:21:21.495]                         computeRestarts <- base::computeRestarts
[10:21:21.495]                         grepl <- base::grepl
[10:21:21.495]                         restarts <- computeRestarts(cond)
[10:21:21.495]                         for (restart in restarts) {
[10:21:21.495]                           name <- restart$name
[10:21:21.495]                           if (is.null(name)) 
[10:21:21.495]                             next
[10:21:21.495]                           if (!grepl(pattern, name)) 
[10:21:21.495]                             next
[10:21:21.495]                           invokeRestart(restart)
[10:21:21.495]                           muffled <- TRUE
[10:21:21.495]                           break
[10:21:21.495]                         }
[10:21:21.495]                       }
[10:21:21.495]                     }
[10:21:21.495]                     invisible(muffled)
[10:21:21.495]                   }
[10:21:21.495]                   muffleCondition(cond)
[10:21:21.495]                 })
[10:21:21.495]             }))
[10:21:21.495]             future::FutureResult(value = ...future.value$value, 
[10:21:21.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.495]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.495]                     ...future.globalenv.names))
[10:21:21.495]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.495]         }, condition = base::local({
[10:21:21.495]             c <- base::c
[10:21:21.495]             inherits <- base::inherits
[10:21:21.495]             invokeRestart <- base::invokeRestart
[10:21:21.495]             length <- base::length
[10:21:21.495]             list <- base::list
[10:21:21.495]             seq.int <- base::seq.int
[10:21:21.495]             signalCondition <- base::signalCondition
[10:21:21.495]             sys.calls <- base::sys.calls
[10:21:21.495]             `[[` <- base::`[[`
[10:21:21.495]             `+` <- base::`+`
[10:21:21.495]             `<<-` <- base::`<<-`
[10:21:21.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.495]                   3L)]
[10:21:21.495]             }
[10:21:21.495]             function(cond) {
[10:21:21.495]                 is_error <- inherits(cond, "error")
[10:21:21.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.495]                   NULL)
[10:21:21.495]                 if (is_error) {
[10:21:21.495]                   sessionInformation <- function() {
[10:21:21.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.495]                       search = base::search(), system = base::Sys.info())
[10:21:21.495]                   }
[10:21:21.495]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.495]                     cond$call), session = sessionInformation(), 
[10:21:21.495]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.495]                   signalCondition(cond)
[10:21:21.495]                 }
[10:21:21.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.495]                 "immediateCondition"))) {
[10:21:21.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.495]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.495]                   if (TRUE && !signal) {
[10:21:21.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.495]                     {
[10:21:21.495]                       inherits <- base::inherits
[10:21:21.495]                       invokeRestart <- base::invokeRestart
[10:21:21.495]                       is.null <- base::is.null
[10:21:21.495]                       muffled <- FALSE
[10:21:21.495]                       if (inherits(cond, "message")) {
[10:21:21.495]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.495]                         if (muffled) 
[10:21:21.495]                           invokeRestart("muffleMessage")
[10:21:21.495]                       }
[10:21:21.495]                       else if (inherits(cond, "warning")) {
[10:21:21.495]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.495]                         if (muffled) 
[10:21:21.495]                           invokeRestart("muffleWarning")
[10:21:21.495]                       }
[10:21:21.495]                       else if (inherits(cond, "condition")) {
[10:21:21.495]                         if (!is.null(pattern)) {
[10:21:21.495]                           computeRestarts <- base::computeRestarts
[10:21:21.495]                           grepl <- base::grepl
[10:21:21.495]                           restarts <- computeRestarts(cond)
[10:21:21.495]                           for (restart in restarts) {
[10:21:21.495]                             name <- restart$name
[10:21:21.495]                             if (is.null(name)) 
[10:21:21.495]                               next
[10:21:21.495]                             if (!grepl(pattern, name)) 
[10:21:21.495]                               next
[10:21:21.495]                             invokeRestart(restart)
[10:21:21.495]                             muffled <- TRUE
[10:21:21.495]                             break
[10:21:21.495]                           }
[10:21:21.495]                         }
[10:21:21.495]                       }
[10:21:21.495]                       invisible(muffled)
[10:21:21.495]                     }
[10:21:21.495]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.495]                   }
[10:21:21.495]                 }
[10:21:21.495]                 else {
[10:21:21.495]                   if (TRUE) {
[10:21:21.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.495]                     {
[10:21:21.495]                       inherits <- base::inherits
[10:21:21.495]                       invokeRestart <- base::invokeRestart
[10:21:21.495]                       is.null <- base::is.null
[10:21:21.495]                       muffled <- FALSE
[10:21:21.495]                       if (inherits(cond, "message")) {
[10:21:21.495]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.495]                         if (muffled) 
[10:21:21.495]                           invokeRestart("muffleMessage")
[10:21:21.495]                       }
[10:21:21.495]                       else if (inherits(cond, "warning")) {
[10:21:21.495]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.495]                         if (muffled) 
[10:21:21.495]                           invokeRestart("muffleWarning")
[10:21:21.495]                       }
[10:21:21.495]                       else if (inherits(cond, "condition")) {
[10:21:21.495]                         if (!is.null(pattern)) {
[10:21:21.495]                           computeRestarts <- base::computeRestarts
[10:21:21.495]                           grepl <- base::grepl
[10:21:21.495]                           restarts <- computeRestarts(cond)
[10:21:21.495]                           for (restart in restarts) {
[10:21:21.495]                             name <- restart$name
[10:21:21.495]                             if (is.null(name)) 
[10:21:21.495]                               next
[10:21:21.495]                             if (!grepl(pattern, name)) 
[10:21:21.495]                               next
[10:21:21.495]                             invokeRestart(restart)
[10:21:21.495]                             muffled <- TRUE
[10:21:21.495]                             break
[10:21:21.495]                           }
[10:21:21.495]                         }
[10:21:21.495]                       }
[10:21:21.495]                       invisible(muffled)
[10:21:21.495]                     }
[10:21:21.495]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.495]                   }
[10:21:21.495]                 }
[10:21:21.495]             }
[10:21:21.495]         }))
[10:21:21.495]     }, error = function(ex) {
[10:21:21.495]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.495]                 ...future.rng), started = ...future.startTime, 
[10:21:21.495]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.495]             version = "1.8"), class = "FutureResult")
[10:21:21.495]     }, finally = {
[10:21:21.495]         if (!identical(...future.workdir, getwd())) 
[10:21:21.495]             setwd(...future.workdir)
[10:21:21.495]         {
[10:21:21.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.495]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.495]             }
[10:21:21.495]             base::options(...future.oldOptions)
[10:21:21.495]             if (.Platform$OS.type == "windows") {
[10:21:21.495]                 old_names <- names(...future.oldEnvVars)
[10:21:21.495]                 envs <- base::Sys.getenv()
[10:21:21.495]                 names <- names(envs)
[10:21:21.495]                 common <- intersect(names, old_names)
[10:21:21.495]                 added <- setdiff(names, old_names)
[10:21:21.495]                 removed <- setdiff(old_names, names)
[10:21:21.495]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.495]                   envs[common]]
[10:21:21.495]                 NAMES <- toupper(changed)
[10:21:21.495]                 args <- list()
[10:21:21.495]                 for (kk in seq_along(NAMES)) {
[10:21:21.495]                   name <- changed[[kk]]
[10:21:21.495]                   NAME <- NAMES[[kk]]
[10:21:21.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.495]                     next
[10:21:21.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.495]                 }
[10:21:21.495]                 NAMES <- toupper(added)
[10:21:21.495]                 for (kk in seq_along(NAMES)) {
[10:21:21.495]                   name <- added[[kk]]
[10:21:21.495]                   NAME <- NAMES[[kk]]
[10:21:21.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.495]                     next
[10:21:21.495]                   args[[name]] <- ""
[10:21:21.495]                 }
[10:21:21.495]                 NAMES <- toupper(removed)
[10:21:21.495]                 for (kk in seq_along(NAMES)) {
[10:21:21.495]                   name <- removed[[kk]]
[10:21:21.495]                   NAME <- NAMES[[kk]]
[10:21:21.495]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.495]                     next
[10:21:21.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.495]                 }
[10:21:21.495]                 if (length(args) > 0) 
[10:21:21.495]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.495]             }
[10:21:21.495]             else {
[10:21:21.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.495]             }
[10:21:21.495]             {
[10:21:21.495]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.495]                   0L) {
[10:21:21.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.495]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.495]                   base::options(opts)
[10:21:21.495]                 }
[10:21:21.495]                 {
[10:21:21.495]                   {
[10:21:21.495]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.495]                     NULL
[10:21:21.495]                   }
[10:21:21.495]                   options(future.plan = NULL)
[10:21:21.495]                   if (is.na(NA_character_)) 
[10:21:21.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.495]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.495]                     .init = FALSE)
[10:21:21.495]                 }
[10:21:21.495]             }
[10:21:21.495]         }
[10:21:21.495]     })
[10:21:21.495]     if (TRUE) {
[10:21:21.495]         base::sink(type = "output", split = FALSE)
[10:21:21.495]         if (TRUE) {
[10:21:21.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.495]         }
[10:21:21.495]         else {
[10:21:21.495]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.495]         }
[10:21:21.495]         base::close(...future.stdout)
[10:21:21.495]         ...future.stdout <- NULL
[10:21:21.495]     }
[10:21:21.495]     ...future.result$conditions <- ...future.conditions
[10:21:21.495]     ...future.result$finished <- base::Sys.time()
[10:21:21.495]     ...future.result
[10:21:21.495] }
[10:21:21.499] requestCore(): workers = 2
[10:21:21.501] MulticoreFuture started
[10:21:21.502] - Launch lazy future ... done
[10:21:21.502] run() for ‘MulticoreFuture’ ... done
[10:21:21.502] plan(): Setting new future strategy stack:
[10:21:21.503] getGlobalsAndPackages() ...
[10:21:21.503] Searching for globals...
[10:21:21.503] List of future strategies:
[10:21:21.503] 1. sequential:
[10:21:21.503]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.503]    - tweaked: FALSE
[10:21:21.503]    - call: NULL
[10:21:21.504] plan(): nbrOfWorkers() = 1
[10:21:21.504] - globals found: [1] ‘{’
[10:21:21.504] Searching for globals ... DONE
[10:21:21.504] Resolving globals: FALSE
[10:21:21.505] 
[10:21:21.505] 
[10:21:21.505] getGlobalsAndPackages() ... DONE
[10:21:21.506] run() for ‘Future’ ...
[10:21:21.506] - state: ‘created’
[10:21:21.506] plan(): Setting new future strategy stack:
[10:21:21.506] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.506] List of future strategies:
[10:21:21.506] 1. multicore:
[10:21:21.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.506]    - tweaked: FALSE
[10:21:21.506]    - call: plan(strategy)
[10:21:21.509] plan(): nbrOfWorkers() = 2
[10:21:21.509] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.509] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.509]   - Field: ‘label’
[10:21:21.510]   - Field: ‘local’
[10:21:21.510]   - Field: ‘owner’
[10:21:21.510]   - Field: ‘envir’
[10:21:21.510]   - Field: ‘workers’
[10:21:21.510]   - Field: ‘packages’
[10:21:21.510]   - Field: ‘gc’
[10:21:21.510]   - Field: ‘job’
[10:21:21.510]   - Field: ‘conditions’
[10:21:21.511]   - Field: ‘expr’
[10:21:21.511]   - Field: ‘uuid’
[10:21:21.511]   - Field: ‘seed’
[10:21:21.511]   - Field: ‘version’
[10:21:21.511]   - Field: ‘result’
[10:21:21.511]   - Field: ‘asynchronous’
[10:21:21.511]   - Field: ‘calls’
[10:21:21.511]   - Field: ‘globals’
[10:21:21.512]   - Field: ‘stdout’
[10:21:21.512]   - Field: ‘earlySignal’
[10:21:21.512]   - Field: ‘lazy’
[10:21:21.512]   - Field: ‘state’
[10:21:21.512] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.512] - Launch lazy future ...
[10:21:21.513] Packages needed by the future expression (n = 0): <none>
[10:21:21.513] Packages needed by future strategies (n = 0): <none>
[10:21:21.514] {
[10:21:21.514]     {
[10:21:21.514]         {
[10:21:21.514]             ...future.startTime <- base::Sys.time()
[10:21:21.514]             {
[10:21:21.514]                 {
[10:21:21.514]                   {
[10:21:21.514]                     {
[10:21:21.514]                       base::local({
[10:21:21.514]                         has_future <- base::requireNamespace("future", 
[10:21:21.514]                           quietly = TRUE)
[10:21:21.514]                         if (has_future) {
[10:21:21.514]                           ns <- base::getNamespace("future")
[10:21:21.514]                           version <- ns[[".package"]][["version"]]
[10:21:21.514]                           if (is.null(version)) 
[10:21:21.514]                             version <- utils::packageVersion("future")
[10:21:21.514]                         }
[10:21:21.514]                         else {
[10:21:21.514]                           version <- NULL
[10:21:21.514]                         }
[10:21:21.514]                         if (!has_future || version < "1.8.0") {
[10:21:21.514]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.514]                             "", base::R.version$version.string), 
[10:21:21.514]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.514]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.514]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.514]                               "release", "version")], collapse = " "), 
[10:21:21.514]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.514]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.514]                             info)
[10:21:21.514]                           info <- base::paste(info, collapse = "; ")
[10:21:21.514]                           if (!has_future) {
[10:21:21.514]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.514]                               info)
[10:21:21.514]                           }
[10:21:21.514]                           else {
[10:21:21.514]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.514]                               info, version)
[10:21:21.514]                           }
[10:21:21.514]                           base::stop(msg)
[10:21:21.514]                         }
[10:21:21.514]                       })
[10:21:21.514]                     }
[10:21:21.514]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.514]                     base::options(mc.cores = 1L)
[10:21:21.514]                   }
[10:21:21.514]                   ...future.strategy.old <- future::plan("list")
[10:21:21.514]                   options(future.plan = NULL)
[10:21:21.514]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.514]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.514]                 }
[10:21:21.514]                 ...future.workdir <- getwd()
[10:21:21.514]             }
[10:21:21.514]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.514]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.514]         }
[10:21:21.514]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.514]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.514]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.514]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.514]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.514]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.514]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.514]             base::names(...future.oldOptions))
[10:21:21.514]     }
[10:21:21.514]     if (FALSE) {
[10:21:21.514]     }
[10:21:21.514]     else {
[10:21:21.514]         if (TRUE) {
[10:21:21.514]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.514]                 open = "w")
[10:21:21.514]         }
[10:21:21.514]         else {
[10:21:21.514]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.514]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.514]         }
[10:21:21.514]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.514]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.514]             base::sink(type = "output", split = FALSE)
[10:21:21.514]             base::close(...future.stdout)
[10:21:21.514]         }, add = TRUE)
[10:21:21.514]     }
[10:21:21.514]     ...future.frame <- base::sys.nframe()
[10:21:21.514]     ...future.conditions <- base::list()
[10:21:21.514]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.514]     if (FALSE) {
[10:21:21.514]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.514]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.514]     }
[10:21:21.514]     ...future.result <- base::tryCatch({
[10:21:21.514]         base::withCallingHandlers({
[10:21:21.514]             ...future.value <- base::withVisible(base::local({
[10:21:21.514]                 withCallingHandlers({
[10:21:21.514]                   {
[10:21:21.514]                     4
[10:21:21.514]                   }
[10:21:21.514]                 }, immediateCondition = function(cond) {
[10:21:21.514]                   save_rds <- function (object, pathname, ...) 
[10:21:21.514]                   {
[10:21:21.514]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.514]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.514]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.514]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.514]                         fi_tmp[["mtime"]])
[10:21:21.514]                     }
[10:21:21.514]                     tryCatch({
[10:21:21.514]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.514]                     }, error = function(ex) {
[10:21:21.514]                       msg <- conditionMessage(ex)
[10:21:21.514]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.514]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.514]                         fi_tmp[["mtime"]], msg)
[10:21:21.514]                       ex$message <- msg
[10:21:21.514]                       stop(ex)
[10:21:21.514]                     })
[10:21:21.514]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.514]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.514]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.514]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.514]                       fi <- file.info(pathname)
[10:21:21.514]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.514]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.514]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.514]                         fi[["size"]], fi[["mtime"]])
[10:21:21.514]                       stop(msg)
[10:21:21.514]                     }
[10:21:21.514]                     invisible(pathname)
[10:21:21.514]                   }
[10:21:21.514]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.514]                     rootPath = tempdir()) 
[10:21:21.514]                   {
[10:21:21.514]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.514]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.514]                       tmpdir = path, fileext = ".rds")
[10:21:21.514]                     save_rds(obj, file)
[10:21:21.514]                   }
[10:21:21.514]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.514]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.514]                   {
[10:21:21.514]                     inherits <- base::inherits
[10:21:21.514]                     invokeRestart <- base::invokeRestart
[10:21:21.514]                     is.null <- base::is.null
[10:21:21.514]                     muffled <- FALSE
[10:21:21.514]                     if (inherits(cond, "message")) {
[10:21:21.514]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.514]                       if (muffled) 
[10:21:21.514]                         invokeRestart("muffleMessage")
[10:21:21.514]                     }
[10:21:21.514]                     else if (inherits(cond, "warning")) {
[10:21:21.514]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.514]                       if (muffled) 
[10:21:21.514]                         invokeRestart("muffleWarning")
[10:21:21.514]                     }
[10:21:21.514]                     else if (inherits(cond, "condition")) {
[10:21:21.514]                       if (!is.null(pattern)) {
[10:21:21.514]                         computeRestarts <- base::computeRestarts
[10:21:21.514]                         grepl <- base::grepl
[10:21:21.514]                         restarts <- computeRestarts(cond)
[10:21:21.514]                         for (restart in restarts) {
[10:21:21.514]                           name <- restart$name
[10:21:21.514]                           if (is.null(name)) 
[10:21:21.514]                             next
[10:21:21.514]                           if (!grepl(pattern, name)) 
[10:21:21.514]                             next
[10:21:21.514]                           invokeRestart(restart)
[10:21:21.514]                           muffled <- TRUE
[10:21:21.514]                           break
[10:21:21.514]                         }
[10:21:21.514]                       }
[10:21:21.514]                     }
[10:21:21.514]                     invisible(muffled)
[10:21:21.514]                   }
[10:21:21.514]                   muffleCondition(cond)
[10:21:21.514]                 })
[10:21:21.514]             }))
[10:21:21.514]             future::FutureResult(value = ...future.value$value, 
[10:21:21.514]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.514]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.514]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.514]                     ...future.globalenv.names))
[10:21:21.514]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.514]         }, condition = base::local({
[10:21:21.514]             c <- base::c
[10:21:21.514]             inherits <- base::inherits
[10:21:21.514]             invokeRestart <- base::invokeRestart
[10:21:21.514]             length <- base::length
[10:21:21.514]             list <- base::list
[10:21:21.514]             seq.int <- base::seq.int
[10:21:21.514]             signalCondition <- base::signalCondition
[10:21:21.514]             sys.calls <- base::sys.calls
[10:21:21.514]             `[[` <- base::`[[`
[10:21:21.514]             `+` <- base::`+`
[10:21:21.514]             `<<-` <- base::`<<-`
[10:21:21.514]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.514]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.514]                   3L)]
[10:21:21.514]             }
[10:21:21.514]             function(cond) {
[10:21:21.514]                 is_error <- inherits(cond, "error")
[10:21:21.514]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.514]                   NULL)
[10:21:21.514]                 if (is_error) {
[10:21:21.514]                   sessionInformation <- function() {
[10:21:21.514]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.514]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.514]                       search = base::search(), system = base::Sys.info())
[10:21:21.514]                   }
[10:21:21.514]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.514]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.514]                     cond$call), session = sessionInformation(), 
[10:21:21.514]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.514]                   signalCondition(cond)
[10:21:21.514]                 }
[10:21:21.514]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.514]                 "immediateCondition"))) {
[10:21:21.514]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.514]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.514]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.514]                   if (TRUE && !signal) {
[10:21:21.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.514]                     {
[10:21:21.514]                       inherits <- base::inherits
[10:21:21.514]                       invokeRestart <- base::invokeRestart
[10:21:21.514]                       is.null <- base::is.null
[10:21:21.514]                       muffled <- FALSE
[10:21:21.514]                       if (inherits(cond, "message")) {
[10:21:21.514]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.514]                         if (muffled) 
[10:21:21.514]                           invokeRestart("muffleMessage")
[10:21:21.514]                       }
[10:21:21.514]                       else if (inherits(cond, "warning")) {
[10:21:21.514]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.514]                         if (muffled) 
[10:21:21.514]                           invokeRestart("muffleWarning")
[10:21:21.514]                       }
[10:21:21.514]                       else if (inherits(cond, "condition")) {
[10:21:21.514]                         if (!is.null(pattern)) {
[10:21:21.514]                           computeRestarts <- base::computeRestarts
[10:21:21.514]                           grepl <- base::grepl
[10:21:21.514]                           restarts <- computeRestarts(cond)
[10:21:21.514]                           for (restart in restarts) {
[10:21:21.514]                             name <- restart$name
[10:21:21.514]                             if (is.null(name)) 
[10:21:21.514]                               next
[10:21:21.514]                             if (!grepl(pattern, name)) 
[10:21:21.514]                               next
[10:21:21.514]                             invokeRestart(restart)
[10:21:21.514]                             muffled <- TRUE
[10:21:21.514]                             break
[10:21:21.514]                           }
[10:21:21.514]                         }
[10:21:21.514]                       }
[10:21:21.514]                       invisible(muffled)
[10:21:21.514]                     }
[10:21:21.514]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.514]                   }
[10:21:21.514]                 }
[10:21:21.514]                 else {
[10:21:21.514]                   if (TRUE) {
[10:21:21.514]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.514]                     {
[10:21:21.514]                       inherits <- base::inherits
[10:21:21.514]                       invokeRestart <- base::invokeRestart
[10:21:21.514]                       is.null <- base::is.null
[10:21:21.514]                       muffled <- FALSE
[10:21:21.514]                       if (inherits(cond, "message")) {
[10:21:21.514]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.514]                         if (muffled) 
[10:21:21.514]                           invokeRestart("muffleMessage")
[10:21:21.514]                       }
[10:21:21.514]                       else if (inherits(cond, "warning")) {
[10:21:21.514]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.514]                         if (muffled) 
[10:21:21.514]                           invokeRestart("muffleWarning")
[10:21:21.514]                       }
[10:21:21.514]                       else if (inherits(cond, "condition")) {
[10:21:21.514]                         if (!is.null(pattern)) {
[10:21:21.514]                           computeRestarts <- base::computeRestarts
[10:21:21.514]                           grepl <- base::grepl
[10:21:21.514]                           restarts <- computeRestarts(cond)
[10:21:21.514]                           for (restart in restarts) {
[10:21:21.514]                             name <- restart$name
[10:21:21.514]                             if (is.null(name)) 
[10:21:21.514]                               next
[10:21:21.514]                             if (!grepl(pattern, name)) 
[10:21:21.514]                               next
[10:21:21.514]                             invokeRestart(restart)
[10:21:21.514]                             muffled <- TRUE
[10:21:21.514]                             break
[10:21:21.514]                           }
[10:21:21.514]                         }
[10:21:21.514]                       }
[10:21:21.514]                       invisible(muffled)
[10:21:21.514]                     }
[10:21:21.514]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.514]                   }
[10:21:21.514]                 }
[10:21:21.514]             }
[10:21:21.514]         }))
[10:21:21.514]     }, error = function(ex) {
[10:21:21.514]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.514]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.514]                 ...future.rng), started = ...future.startTime, 
[10:21:21.514]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.514]             version = "1.8"), class = "FutureResult")
[10:21:21.514]     }, finally = {
[10:21:21.514]         if (!identical(...future.workdir, getwd())) 
[10:21:21.514]             setwd(...future.workdir)
[10:21:21.514]         {
[10:21:21.514]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.514]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.514]             }
[10:21:21.514]             base::options(...future.oldOptions)
[10:21:21.514]             if (.Platform$OS.type == "windows") {
[10:21:21.514]                 old_names <- names(...future.oldEnvVars)
[10:21:21.514]                 envs <- base::Sys.getenv()
[10:21:21.514]                 names <- names(envs)
[10:21:21.514]                 common <- intersect(names, old_names)
[10:21:21.514]                 added <- setdiff(names, old_names)
[10:21:21.514]                 removed <- setdiff(old_names, names)
[10:21:21.514]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.514]                   envs[common]]
[10:21:21.514]                 NAMES <- toupper(changed)
[10:21:21.514]                 args <- list()
[10:21:21.514]                 for (kk in seq_along(NAMES)) {
[10:21:21.514]                   name <- changed[[kk]]
[10:21:21.514]                   NAME <- NAMES[[kk]]
[10:21:21.514]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.514]                     next
[10:21:21.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.514]                 }
[10:21:21.514]                 NAMES <- toupper(added)
[10:21:21.514]                 for (kk in seq_along(NAMES)) {
[10:21:21.514]                   name <- added[[kk]]
[10:21:21.514]                   NAME <- NAMES[[kk]]
[10:21:21.514]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.514]                     next
[10:21:21.514]                   args[[name]] <- ""
[10:21:21.514]                 }
[10:21:21.514]                 NAMES <- toupper(removed)
[10:21:21.514]                 for (kk in seq_along(NAMES)) {
[10:21:21.514]                   name <- removed[[kk]]
[10:21:21.514]                   NAME <- NAMES[[kk]]
[10:21:21.514]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.514]                     next
[10:21:21.514]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.514]                 }
[10:21:21.514]                 if (length(args) > 0) 
[10:21:21.514]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.514]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.514]             }
[10:21:21.514]             else {
[10:21:21.514]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.514]             }
[10:21:21.514]             {
[10:21:21.514]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.514]                   0L) {
[10:21:21.514]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.514]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.514]                   base::options(opts)
[10:21:21.514]                 }
[10:21:21.514]                 {
[10:21:21.514]                   {
[10:21:21.514]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.514]                     NULL
[10:21:21.514]                   }
[10:21:21.514]                   options(future.plan = NULL)
[10:21:21.514]                   if (is.na(NA_character_)) 
[10:21:21.514]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.514]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.514]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.514]                     .init = FALSE)
[10:21:21.514]                 }
[10:21:21.514]             }
[10:21:21.514]         }
[10:21:21.514]     })
[10:21:21.514]     if (TRUE) {
[10:21:21.514]         base::sink(type = "output", split = FALSE)
[10:21:21.514]         if (TRUE) {
[10:21:21.514]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.514]         }
[10:21:21.514]         else {
[10:21:21.514]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.514]         }
[10:21:21.514]         base::close(...future.stdout)
[10:21:21.514]         ...future.stdout <- NULL
[10:21:21.514]     }
[10:21:21.514]     ...future.result$conditions <- ...future.conditions
[10:21:21.514]     ...future.result$finished <- base::Sys.time()
[10:21:21.514]     ...future.result
[10:21:21.514] }
[10:21:21.517] requestCore(): workers = 2
[10:21:21.517] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:21.528] result() for MulticoreFuture ...
[10:21:21.529] result() for MulticoreFuture ...
[10:21:21.529] result() for MulticoreFuture ... done
[10:21:21.529] result() for MulticoreFuture ... done
[10:21:21.529] result() for MulticoreFuture ...
[10:21:21.529] result() for MulticoreFuture ... done
[10:21:21.532] MulticoreFuture started
[10:21:21.532] - Launch lazy future ... done
[10:21:21.533] run() for ‘MulticoreFuture’ ... done
[10:21:21.533] plan(): Setting new future strategy stack:
<environment: 0x55e8e63e0118> 
[10:21:21.534] List of future strategies:
[10:21:21.534] 1. sequential:
[10:21:21.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.534]    - tweaked: FALSE
[10:21:21.534]    - call: NULL
[10:21:21.535] plan(): nbrOfWorkers() = 1
<environment: 0x55e8e6d15c58> 
[10:21:21.538] plan(): Setting new future strategy stack:
[10:21:21.538] List of future strategies:
[10:21:21.538] 1. multicore:
[10:21:21.538]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.538]    - tweaked: FALSE
[10:21:21.538]    - call: plan(strategy)
[10:21:21.541] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:21.543] resolve() on environment ...
[10:21:21.543]  recursive: 0
[10:21:21.544]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:21.544] signalConditionsASAP(numeric, pos=1) ...
[10:21:21.544] - nx: 4
[10:21:21.545] - relay: TRUE
[10:21:21.545] - stdout: TRUE
[10:21:21.545] - signal: TRUE
[10:21:21.545] - resignal: FALSE
[10:21:21.545] - force: TRUE
[10:21:21.545] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.545] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.545]  - until=2
[10:21:21.546]  - relaying element #2
[10:21:21.546] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.546] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.546] signalConditionsASAP(NULL, pos=1) ... done
[10:21:21.546]  length: 3 (resolved future 1)
[10:21:21.546] Future #2
[10:21:21.546] result() for MulticoreFuture ...
[10:21:21.547] result() for MulticoreFuture ... done
[10:21:21.547] result() for MulticoreFuture ...
[10:21:21.547] result() for MulticoreFuture ... done
[10:21:21.547] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:21.547] - nx: 4
[10:21:21.547] - relay: TRUE
[10:21:21.547] - stdout: TRUE
[10:21:21.547] - signal: TRUE
[10:21:21.548] - resignal: FALSE
[10:21:21.548] - force: TRUE
[10:21:21.548] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.548] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.548]  - until=2
[10:21:21.548]  - relaying element #2
[10:21:21.548] result() for MulticoreFuture ...
[10:21:21.548] result() for MulticoreFuture ... done
[10:21:21.548] result() for MulticoreFuture ...
[10:21:21.549] result() for MulticoreFuture ... done
[10:21:21.549] result() for MulticoreFuture ...
[10:21:21.549] result() for MulticoreFuture ... done
[10:21:21.549] result() for MulticoreFuture ...
[10:21:21.549] result() for MulticoreFuture ... done
[10:21:21.549] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.549] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.549] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:21.550]  length: 2 (resolved future 2)
[10:21:21.550] Future #3
[10:21:21.550] result() for MulticoreFuture ...
[10:21:21.551] result() for MulticoreFuture ...
[10:21:21.551] result() for MulticoreFuture ... done
[10:21:21.551] result() for MulticoreFuture ... done
[10:21:21.551] result() for MulticoreFuture ...
[10:21:21.551] result() for MulticoreFuture ... done
[10:21:21.552] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:21.552] - nx: 4
[10:21:21.552] - relay: TRUE
[10:21:21.552] - stdout: TRUE
[10:21:21.552] - signal: TRUE
[10:21:21.552] - resignal: FALSE
[10:21:21.552] - force: TRUE
[10:21:21.552] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.552] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.553]  - until=3
[10:21:21.553]  - relaying element #3
[10:21:21.553] result() for MulticoreFuture ...
[10:21:21.553] result() for MulticoreFuture ... done
[10:21:21.553] result() for MulticoreFuture ...
[10:21:21.553] result() for MulticoreFuture ... done
[10:21:21.553] result() for MulticoreFuture ...
[10:21:21.553] result() for MulticoreFuture ... done
[10:21:21.554] result() for MulticoreFuture ...
[10:21:21.554] result() for MulticoreFuture ... done
[10:21:21.554] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.554] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.554] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:21.554]  length: 1 (resolved future 3)
[10:21:21.554] Future #4
[10:21:21.555] result() for MulticoreFuture ...
[10:21:21.555] result() for MulticoreFuture ...
[10:21:21.555] result() for MulticoreFuture ... done
[10:21:21.556] result() for MulticoreFuture ... done
[10:21:21.556] result() for MulticoreFuture ...
[10:21:21.556] result() for MulticoreFuture ... done
[10:21:21.556] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:21.556] - nx: 4
[10:21:21.557] - relay: TRUE
[10:21:21.557] - stdout: TRUE
[10:21:21.557] - signal: TRUE
[10:21:21.557] - resignal: FALSE
[10:21:21.557] - force: TRUE
[10:21:21.557] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.557] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.558]  - until=4
[10:21:21.558]  - relaying element #4
[10:21:21.558] result() for MulticoreFuture ...
[10:21:21.558] result() for MulticoreFuture ... done
[10:21:21.558] result() for MulticoreFuture ...
[10:21:21.558] result() for MulticoreFuture ... done
[10:21:21.559] result() for MulticoreFuture ...
[10:21:21.559] result() for MulticoreFuture ... done
[10:21:21.559] result() for MulticoreFuture ...
[10:21:21.559] result() for MulticoreFuture ... done
[10:21:21.559] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.559] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.560] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:21.560]  length: 0 (resolved future 4)
[10:21:21.560] Relaying remaining futures
[10:21:21.560] signalConditionsASAP(NULL, pos=0) ...
[10:21:21.560] - nx: 4
[10:21:21.560] - relay: TRUE
[10:21:21.560] - stdout: TRUE
[10:21:21.560] - signal: TRUE
[10:21:21.560] - resignal: FALSE
[10:21:21.560] - force: TRUE
[10:21:21.560] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.561] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:21.561] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.561] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.561] signalConditionsASAP(NULL, pos=0) ... done
[10:21:21.561] resolve() on environment ... DONE
[10:21:21.561] result() for MulticoreFuture ...
[10:21:21.561] result() for MulticoreFuture ... done
[10:21:21.561] result() for MulticoreFuture ...
[10:21:21.561] result() for MulticoreFuture ... done
[10:21:21.562] result() for MulticoreFuture ...
[10:21:21.562] result() for MulticoreFuture ... done
[10:21:21.562] result() for MulticoreFuture ...
[10:21:21.562] result() for MulticoreFuture ... done
[10:21:21.562] result() for MulticoreFuture ...
[10:21:21.562] result() for MulticoreFuture ... done
[10:21:21.562] result() for MulticoreFuture ...
[10:21:21.562] result() for MulticoreFuture ... done
<environment: 0x55e8e6dd3730> 
Dimensions: c(2, 3, 1)
[10:21:21.563] getGlobalsAndPackages() ...
[10:21:21.563] Searching for globals...
[10:21:21.563] 
[10:21:21.564] Searching for globals ... DONE
[10:21:21.564] - globals: [0] <none>
[10:21:21.564] getGlobalsAndPackages() ... DONE
[10:21:21.564] run() for ‘Future’ ...
[10:21:21.564] - state: ‘created’
[10:21:21.564] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.566] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.567] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.567]   - Field: ‘label’
[10:21:21.567]   - Field: ‘local’
[10:21:21.567]   - Field: ‘owner’
[10:21:21.567]   - Field: ‘envir’
[10:21:21.567]   - Field: ‘workers’
[10:21:21.571]   - Field: ‘packages’
[10:21:21.571]   - Field: ‘gc’
[10:21:21.571]   - Field: ‘job’
[10:21:21.571]   - Field: ‘conditions’
[10:21:21.571]   - Field: ‘expr’
[10:21:21.571]   - Field: ‘uuid’
[10:21:21.571]   - Field: ‘seed’
[10:21:21.572]   - Field: ‘version’
[10:21:21.572]   - Field: ‘result’
[10:21:21.572]   - Field: ‘asynchronous’
[10:21:21.572]   - Field: ‘calls’
[10:21:21.572]   - Field: ‘globals’
[10:21:21.572]   - Field: ‘stdout’
[10:21:21.572]   - Field: ‘earlySignal’
[10:21:21.572]   - Field: ‘lazy’
[10:21:21.572]   - Field: ‘state’
[10:21:21.572] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.573] - Launch lazy future ...
[10:21:21.573] Packages needed by the future expression (n = 0): <none>
[10:21:21.573] Packages needed by future strategies (n = 0): <none>
[10:21:21.574] {
[10:21:21.574]     {
[10:21:21.574]         {
[10:21:21.574]             ...future.startTime <- base::Sys.time()
[10:21:21.574]             {
[10:21:21.574]                 {
[10:21:21.574]                   {
[10:21:21.574]                     {
[10:21:21.574]                       base::local({
[10:21:21.574]                         has_future <- base::requireNamespace("future", 
[10:21:21.574]                           quietly = TRUE)
[10:21:21.574]                         if (has_future) {
[10:21:21.574]                           ns <- base::getNamespace("future")
[10:21:21.574]                           version <- ns[[".package"]][["version"]]
[10:21:21.574]                           if (is.null(version)) 
[10:21:21.574]                             version <- utils::packageVersion("future")
[10:21:21.574]                         }
[10:21:21.574]                         else {
[10:21:21.574]                           version <- NULL
[10:21:21.574]                         }
[10:21:21.574]                         if (!has_future || version < "1.8.0") {
[10:21:21.574]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.574]                             "", base::R.version$version.string), 
[10:21:21.574]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.574]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.574]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.574]                               "release", "version")], collapse = " "), 
[10:21:21.574]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.574]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.574]                             info)
[10:21:21.574]                           info <- base::paste(info, collapse = "; ")
[10:21:21.574]                           if (!has_future) {
[10:21:21.574]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.574]                               info)
[10:21:21.574]                           }
[10:21:21.574]                           else {
[10:21:21.574]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.574]                               info, version)
[10:21:21.574]                           }
[10:21:21.574]                           base::stop(msg)
[10:21:21.574]                         }
[10:21:21.574]                       })
[10:21:21.574]                     }
[10:21:21.574]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.574]                     base::options(mc.cores = 1L)
[10:21:21.574]                   }
[10:21:21.574]                   ...future.strategy.old <- future::plan("list")
[10:21:21.574]                   options(future.plan = NULL)
[10:21:21.574]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.574]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.574]                 }
[10:21:21.574]                 ...future.workdir <- getwd()
[10:21:21.574]             }
[10:21:21.574]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.574]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.574]         }
[10:21:21.574]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.574]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.574]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.574]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.574]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.574]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.574]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.574]             base::names(...future.oldOptions))
[10:21:21.574]     }
[10:21:21.574]     if (FALSE) {
[10:21:21.574]     }
[10:21:21.574]     else {
[10:21:21.574]         if (TRUE) {
[10:21:21.574]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.574]                 open = "w")
[10:21:21.574]         }
[10:21:21.574]         else {
[10:21:21.574]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.574]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.574]         }
[10:21:21.574]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.574]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.574]             base::sink(type = "output", split = FALSE)
[10:21:21.574]             base::close(...future.stdout)
[10:21:21.574]         }, add = TRUE)
[10:21:21.574]     }
[10:21:21.574]     ...future.frame <- base::sys.nframe()
[10:21:21.574]     ...future.conditions <- base::list()
[10:21:21.574]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.574]     if (FALSE) {
[10:21:21.574]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.574]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.574]     }
[10:21:21.574]     ...future.result <- base::tryCatch({
[10:21:21.574]         base::withCallingHandlers({
[10:21:21.574]             ...future.value <- base::withVisible(base::local({
[10:21:21.574]                 withCallingHandlers({
[10:21:21.574]                   2
[10:21:21.574]                 }, immediateCondition = function(cond) {
[10:21:21.574]                   save_rds <- function (object, pathname, ...) 
[10:21:21.574]                   {
[10:21:21.574]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.574]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.574]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.574]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.574]                         fi_tmp[["mtime"]])
[10:21:21.574]                     }
[10:21:21.574]                     tryCatch({
[10:21:21.574]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.574]                     }, error = function(ex) {
[10:21:21.574]                       msg <- conditionMessage(ex)
[10:21:21.574]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.574]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.574]                         fi_tmp[["mtime"]], msg)
[10:21:21.574]                       ex$message <- msg
[10:21:21.574]                       stop(ex)
[10:21:21.574]                     })
[10:21:21.574]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.574]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.574]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.574]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.574]                       fi <- file.info(pathname)
[10:21:21.574]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.574]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.574]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.574]                         fi[["size"]], fi[["mtime"]])
[10:21:21.574]                       stop(msg)
[10:21:21.574]                     }
[10:21:21.574]                     invisible(pathname)
[10:21:21.574]                   }
[10:21:21.574]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.574]                     rootPath = tempdir()) 
[10:21:21.574]                   {
[10:21:21.574]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.574]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.574]                       tmpdir = path, fileext = ".rds")
[10:21:21.574]                     save_rds(obj, file)
[10:21:21.574]                   }
[10:21:21.574]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.574]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.574]                   {
[10:21:21.574]                     inherits <- base::inherits
[10:21:21.574]                     invokeRestart <- base::invokeRestart
[10:21:21.574]                     is.null <- base::is.null
[10:21:21.574]                     muffled <- FALSE
[10:21:21.574]                     if (inherits(cond, "message")) {
[10:21:21.574]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.574]                       if (muffled) 
[10:21:21.574]                         invokeRestart("muffleMessage")
[10:21:21.574]                     }
[10:21:21.574]                     else if (inherits(cond, "warning")) {
[10:21:21.574]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.574]                       if (muffled) 
[10:21:21.574]                         invokeRestart("muffleWarning")
[10:21:21.574]                     }
[10:21:21.574]                     else if (inherits(cond, "condition")) {
[10:21:21.574]                       if (!is.null(pattern)) {
[10:21:21.574]                         computeRestarts <- base::computeRestarts
[10:21:21.574]                         grepl <- base::grepl
[10:21:21.574]                         restarts <- computeRestarts(cond)
[10:21:21.574]                         for (restart in restarts) {
[10:21:21.574]                           name <- restart$name
[10:21:21.574]                           if (is.null(name)) 
[10:21:21.574]                             next
[10:21:21.574]                           if (!grepl(pattern, name)) 
[10:21:21.574]                             next
[10:21:21.574]                           invokeRestart(restart)
[10:21:21.574]                           muffled <- TRUE
[10:21:21.574]                           break
[10:21:21.574]                         }
[10:21:21.574]                       }
[10:21:21.574]                     }
[10:21:21.574]                     invisible(muffled)
[10:21:21.574]                   }
[10:21:21.574]                   muffleCondition(cond)
[10:21:21.574]                 })
[10:21:21.574]             }))
[10:21:21.574]             future::FutureResult(value = ...future.value$value, 
[10:21:21.574]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.574]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.574]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.574]                     ...future.globalenv.names))
[10:21:21.574]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.574]         }, condition = base::local({
[10:21:21.574]             c <- base::c
[10:21:21.574]             inherits <- base::inherits
[10:21:21.574]             invokeRestart <- base::invokeRestart
[10:21:21.574]             length <- base::length
[10:21:21.574]             list <- base::list
[10:21:21.574]             seq.int <- base::seq.int
[10:21:21.574]             signalCondition <- base::signalCondition
[10:21:21.574]             sys.calls <- base::sys.calls
[10:21:21.574]             `[[` <- base::`[[`
[10:21:21.574]             `+` <- base::`+`
[10:21:21.574]             `<<-` <- base::`<<-`
[10:21:21.574]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.574]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.574]                   3L)]
[10:21:21.574]             }
[10:21:21.574]             function(cond) {
[10:21:21.574]                 is_error <- inherits(cond, "error")
[10:21:21.574]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.574]                   NULL)
[10:21:21.574]                 if (is_error) {
[10:21:21.574]                   sessionInformation <- function() {
[10:21:21.574]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.574]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.574]                       search = base::search(), system = base::Sys.info())
[10:21:21.574]                   }
[10:21:21.574]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.574]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.574]                     cond$call), session = sessionInformation(), 
[10:21:21.574]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.574]                   signalCondition(cond)
[10:21:21.574]                 }
[10:21:21.574]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.574]                 "immediateCondition"))) {
[10:21:21.574]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.574]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.574]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.574]                   if (TRUE && !signal) {
[10:21:21.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.574]                     {
[10:21:21.574]                       inherits <- base::inherits
[10:21:21.574]                       invokeRestart <- base::invokeRestart
[10:21:21.574]                       is.null <- base::is.null
[10:21:21.574]                       muffled <- FALSE
[10:21:21.574]                       if (inherits(cond, "message")) {
[10:21:21.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.574]                         if (muffled) 
[10:21:21.574]                           invokeRestart("muffleMessage")
[10:21:21.574]                       }
[10:21:21.574]                       else if (inherits(cond, "warning")) {
[10:21:21.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.574]                         if (muffled) 
[10:21:21.574]                           invokeRestart("muffleWarning")
[10:21:21.574]                       }
[10:21:21.574]                       else if (inherits(cond, "condition")) {
[10:21:21.574]                         if (!is.null(pattern)) {
[10:21:21.574]                           computeRestarts <- base::computeRestarts
[10:21:21.574]                           grepl <- base::grepl
[10:21:21.574]                           restarts <- computeRestarts(cond)
[10:21:21.574]                           for (restart in restarts) {
[10:21:21.574]                             name <- restart$name
[10:21:21.574]                             if (is.null(name)) 
[10:21:21.574]                               next
[10:21:21.574]                             if (!grepl(pattern, name)) 
[10:21:21.574]                               next
[10:21:21.574]                             invokeRestart(restart)
[10:21:21.574]                             muffled <- TRUE
[10:21:21.574]                             break
[10:21:21.574]                           }
[10:21:21.574]                         }
[10:21:21.574]                       }
[10:21:21.574]                       invisible(muffled)
[10:21:21.574]                     }
[10:21:21.574]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.574]                   }
[10:21:21.574]                 }
[10:21:21.574]                 else {
[10:21:21.574]                   if (TRUE) {
[10:21:21.574]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.574]                     {
[10:21:21.574]                       inherits <- base::inherits
[10:21:21.574]                       invokeRestart <- base::invokeRestart
[10:21:21.574]                       is.null <- base::is.null
[10:21:21.574]                       muffled <- FALSE
[10:21:21.574]                       if (inherits(cond, "message")) {
[10:21:21.574]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.574]                         if (muffled) 
[10:21:21.574]                           invokeRestart("muffleMessage")
[10:21:21.574]                       }
[10:21:21.574]                       else if (inherits(cond, "warning")) {
[10:21:21.574]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.574]                         if (muffled) 
[10:21:21.574]                           invokeRestart("muffleWarning")
[10:21:21.574]                       }
[10:21:21.574]                       else if (inherits(cond, "condition")) {
[10:21:21.574]                         if (!is.null(pattern)) {
[10:21:21.574]                           computeRestarts <- base::computeRestarts
[10:21:21.574]                           grepl <- base::grepl
[10:21:21.574]                           restarts <- computeRestarts(cond)
[10:21:21.574]                           for (restart in restarts) {
[10:21:21.574]                             name <- restart$name
[10:21:21.574]                             if (is.null(name)) 
[10:21:21.574]                               next
[10:21:21.574]                             if (!grepl(pattern, name)) 
[10:21:21.574]                               next
[10:21:21.574]                             invokeRestart(restart)
[10:21:21.574]                             muffled <- TRUE
[10:21:21.574]                             break
[10:21:21.574]                           }
[10:21:21.574]                         }
[10:21:21.574]                       }
[10:21:21.574]                       invisible(muffled)
[10:21:21.574]                     }
[10:21:21.574]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.574]                   }
[10:21:21.574]                 }
[10:21:21.574]             }
[10:21:21.574]         }))
[10:21:21.574]     }, error = function(ex) {
[10:21:21.574]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.574]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.574]                 ...future.rng), started = ...future.startTime, 
[10:21:21.574]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.574]             version = "1.8"), class = "FutureResult")
[10:21:21.574]     }, finally = {
[10:21:21.574]         if (!identical(...future.workdir, getwd())) 
[10:21:21.574]             setwd(...future.workdir)
[10:21:21.574]         {
[10:21:21.574]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.574]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.574]             }
[10:21:21.574]             base::options(...future.oldOptions)
[10:21:21.574]             if (.Platform$OS.type == "windows") {
[10:21:21.574]                 old_names <- names(...future.oldEnvVars)
[10:21:21.574]                 envs <- base::Sys.getenv()
[10:21:21.574]                 names <- names(envs)
[10:21:21.574]                 common <- intersect(names, old_names)
[10:21:21.574]                 added <- setdiff(names, old_names)
[10:21:21.574]                 removed <- setdiff(old_names, names)
[10:21:21.574]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.574]                   envs[common]]
[10:21:21.574]                 NAMES <- toupper(changed)
[10:21:21.574]                 args <- list()
[10:21:21.574]                 for (kk in seq_along(NAMES)) {
[10:21:21.574]                   name <- changed[[kk]]
[10:21:21.574]                   NAME <- NAMES[[kk]]
[10:21:21.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.574]                     next
[10:21:21.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.574]                 }
[10:21:21.574]                 NAMES <- toupper(added)
[10:21:21.574]                 for (kk in seq_along(NAMES)) {
[10:21:21.574]                   name <- added[[kk]]
[10:21:21.574]                   NAME <- NAMES[[kk]]
[10:21:21.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.574]                     next
[10:21:21.574]                   args[[name]] <- ""
[10:21:21.574]                 }
[10:21:21.574]                 NAMES <- toupper(removed)
[10:21:21.574]                 for (kk in seq_along(NAMES)) {
[10:21:21.574]                   name <- removed[[kk]]
[10:21:21.574]                   NAME <- NAMES[[kk]]
[10:21:21.574]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.574]                     next
[10:21:21.574]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.574]                 }
[10:21:21.574]                 if (length(args) > 0) 
[10:21:21.574]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.574]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.574]             }
[10:21:21.574]             else {
[10:21:21.574]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.574]             }
[10:21:21.574]             {
[10:21:21.574]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.574]                   0L) {
[10:21:21.574]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.574]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.574]                   base::options(opts)
[10:21:21.574]                 }
[10:21:21.574]                 {
[10:21:21.574]                   {
[10:21:21.574]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.574]                     NULL
[10:21:21.574]                   }
[10:21:21.574]                   options(future.plan = NULL)
[10:21:21.574]                   if (is.na(NA_character_)) 
[10:21:21.574]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.574]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.574]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.574]                     .init = FALSE)
[10:21:21.574]                 }
[10:21:21.574]             }
[10:21:21.574]         }
[10:21:21.574]     })
[10:21:21.574]     if (TRUE) {
[10:21:21.574]         base::sink(type = "output", split = FALSE)
[10:21:21.574]         if (TRUE) {
[10:21:21.574]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.574]         }
[10:21:21.574]         else {
[10:21:21.574]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.574]         }
[10:21:21.574]         base::close(...future.stdout)
[10:21:21.574]         ...future.stdout <- NULL
[10:21:21.574]     }
[10:21:21.574]     ...future.result$conditions <- ...future.conditions
[10:21:21.574]     ...future.result$finished <- base::Sys.time()
[10:21:21.574]     ...future.result
[10:21:21.574] }
[10:21:21.576] requestCore(): workers = 2
[10:21:21.578] MulticoreFuture started
[10:21:21.578] - Launch lazy future ... done
[10:21:21.579] run() for ‘MulticoreFuture’ ... done
[10:21:21.579] getGlobalsAndPackages() ...
[10:21:21.579] Searching for globals...
[10:21:21.579] plan(): Setting new future strategy stack:
[10:21:21.580] 
[10:21:21.579] List of future strategies:
[10:21:21.579] 1. sequential:
[10:21:21.579]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.579]    - tweaked: FALSE
[10:21:21.579]    - call: NULL
[10:21:21.580] Searching for globals ... DONE
[10:21:21.580] - globals: [0] <none>
[10:21:21.580] plan(): nbrOfWorkers() = 1
[10:21:21.581] getGlobalsAndPackages() ... DONE
[10:21:21.581] run() for ‘Future’ ...
[10:21:21.581] - state: ‘created’
[10:21:21.581] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.582] plan(): Setting new future strategy stack:
[10:21:21.583] List of future strategies:
[10:21:21.583] 1. multicore:
[10:21:21.583]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.583]    - tweaked: FALSE
[10:21:21.583]    - call: plan(strategy)
[10:21:21.585] plan(): nbrOfWorkers() = 2
[10:21:21.585] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.585] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.585]   - Field: ‘label’
[10:21:21.585]   - Field: ‘local’
[10:21:21.586]   - Field: ‘owner’
[10:21:21.586]   - Field: ‘envir’
[10:21:21.586]   - Field: ‘workers’
[10:21:21.586]   - Field: ‘packages’
[10:21:21.586]   - Field: ‘gc’
[10:21:21.586]   - Field: ‘job’
[10:21:21.586]   - Field: ‘conditions’
[10:21:21.587]   - Field: ‘expr’
[10:21:21.587]   - Field: ‘uuid’
[10:21:21.587]   - Field: ‘seed’
[10:21:21.587]   - Field: ‘version’
[10:21:21.587]   - Field: ‘result’
[10:21:21.587]   - Field: ‘asynchronous’
[10:21:21.587]   - Field: ‘calls’
[10:21:21.588]   - Field: ‘globals’
[10:21:21.588]   - Field: ‘stdout’
[10:21:21.588]   - Field: ‘earlySignal’
[10:21:21.588]   - Field: ‘lazy’
[10:21:21.588]   - Field: ‘state’
[10:21:21.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.589] - Launch lazy future ...
[10:21:21.589] Packages needed by the future expression (n = 0): <none>
[10:21:21.589] Packages needed by future strategies (n = 0): <none>
[10:21:21.590] {
[10:21:21.590]     {
[10:21:21.590]         {
[10:21:21.590]             ...future.startTime <- base::Sys.time()
[10:21:21.590]             {
[10:21:21.590]                 {
[10:21:21.590]                   {
[10:21:21.590]                     {
[10:21:21.590]                       base::local({
[10:21:21.590]                         has_future <- base::requireNamespace("future", 
[10:21:21.590]                           quietly = TRUE)
[10:21:21.590]                         if (has_future) {
[10:21:21.590]                           ns <- base::getNamespace("future")
[10:21:21.590]                           version <- ns[[".package"]][["version"]]
[10:21:21.590]                           if (is.null(version)) 
[10:21:21.590]                             version <- utils::packageVersion("future")
[10:21:21.590]                         }
[10:21:21.590]                         else {
[10:21:21.590]                           version <- NULL
[10:21:21.590]                         }
[10:21:21.590]                         if (!has_future || version < "1.8.0") {
[10:21:21.590]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.590]                             "", base::R.version$version.string), 
[10:21:21.590]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.590]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.590]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.590]                               "release", "version")], collapse = " "), 
[10:21:21.590]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.590]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.590]                             info)
[10:21:21.590]                           info <- base::paste(info, collapse = "; ")
[10:21:21.590]                           if (!has_future) {
[10:21:21.590]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.590]                               info)
[10:21:21.590]                           }
[10:21:21.590]                           else {
[10:21:21.590]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.590]                               info, version)
[10:21:21.590]                           }
[10:21:21.590]                           base::stop(msg)
[10:21:21.590]                         }
[10:21:21.590]                       })
[10:21:21.590]                     }
[10:21:21.590]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.590]                     base::options(mc.cores = 1L)
[10:21:21.590]                   }
[10:21:21.590]                   ...future.strategy.old <- future::plan("list")
[10:21:21.590]                   options(future.plan = NULL)
[10:21:21.590]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.590]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.590]                 }
[10:21:21.590]                 ...future.workdir <- getwd()
[10:21:21.590]             }
[10:21:21.590]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.590]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.590]         }
[10:21:21.590]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.590]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.590]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.590]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.590]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.590]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.590]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.590]             base::names(...future.oldOptions))
[10:21:21.590]     }
[10:21:21.590]     if (FALSE) {
[10:21:21.590]     }
[10:21:21.590]     else {
[10:21:21.590]         if (TRUE) {
[10:21:21.590]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.590]                 open = "w")
[10:21:21.590]         }
[10:21:21.590]         else {
[10:21:21.590]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.590]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.590]         }
[10:21:21.590]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.590]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.590]             base::sink(type = "output", split = FALSE)
[10:21:21.590]             base::close(...future.stdout)
[10:21:21.590]         }, add = TRUE)
[10:21:21.590]     }
[10:21:21.590]     ...future.frame <- base::sys.nframe()
[10:21:21.590]     ...future.conditions <- base::list()
[10:21:21.590]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.590]     if (FALSE) {
[10:21:21.590]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.590]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.590]     }
[10:21:21.590]     ...future.result <- base::tryCatch({
[10:21:21.590]         base::withCallingHandlers({
[10:21:21.590]             ...future.value <- base::withVisible(base::local({
[10:21:21.590]                 withCallingHandlers({
[10:21:21.590]                   NULL
[10:21:21.590]                 }, immediateCondition = function(cond) {
[10:21:21.590]                   save_rds <- function (object, pathname, ...) 
[10:21:21.590]                   {
[10:21:21.590]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.590]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.590]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.590]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.590]                         fi_tmp[["mtime"]])
[10:21:21.590]                     }
[10:21:21.590]                     tryCatch({
[10:21:21.590]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.590]                     }, error = function(ex) {
[10:21:21.590]                       msg <- conditionMessage(ex)
[10:21:21.590]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.590]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.590]                         fi_tmp[["mtime"]], msg)
[10:21:21.590]                       ex$message <- msg
[10:21:21.590]                       stop(ex)
[10:21:21.590]                     })
[10:21:21.590]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.590]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.590]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.590]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.590]                       fi <- file.info(pathname)
[10:21:21.590]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.590]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.590]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.590]                         fi[["size"]], fi[["mtime"]])
[10:21:21.590]                       stop(msg)
[10:21:21.590]                     }
[10:21:21.590]                     invisible(pathname)
[10:21:21.590]                   }
[10:21:21.590]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.590]                     rootPath = tempdir()) 
[10:21:21.590]                   {
[10:21:21.590]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.590]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.590]                       tmpdir = path, fileext = ".rds")
[10:21:21.590]                     save_rds(obj, file)
[10:21:21.590]                   }
[10:21:21.590]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.590]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.590]                   {
[10:21:21.590]                     inherits <- base::inherits
[10:21:21.590]                     invokeRestart <- base::invokeRestart
[10:21:21.590]                     is.null <- base::is.null
[10:21:21.590]                     muffled <- FALSE
[10:21:21.590]                     if (inherits(cond, "message")) {
[10:21:21.590]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.590]                       if (muffled) 
[10:21:21.590]                         invokeRestart("muffleMessage")
[10:21:21.590]                     }
[10:21:21.590]                     else if (inherits(cond, "warning")) {
[10:21:21.590]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.590]                       if (muffled) 
[10:21:21.590]                         invokeRestart("muffleWarning")
[10:21:21.590]                     }
[10:21:21.590]                     else if (inherits(cond, "condition")) {
[10:21:21.590]                       if (!is.null(pattern)) {
[10:21:21.590]                         computeRestarts <- base::computeRestarts
[10:21:21.590]                         grepl <- base::grepl
[10:21:21.590]                         restarts <- computeRestarts(cond)
[10:21:21.590]                         for (restart in restarts) {
[10:21:21.590]                           name <- restart$name
[10:21:21.590]                           if (is.null(name)) 
[10:21:21.590]                             next
[10:21:21.590]                           if (!grepl(pattern, name)) 
[10:21:21.590]                             next
[10:21:21.590]                           invokeRestart(restart)
[10:21:21.590]                           muffled <- TRUE
[10:21:21.590]                           break
[10:21:21.590]                         }
[10:21:21.590]                       }
[10:21:21.590]                     }
[10:21:21.590]                     invisible(muffled)
[10:21:21.590]                   }
[10:21:21.590]                   muffleCondition(cond)
[10:21:21.590]                 })
[10:21:21.590]             }))
[10:21:21.590]             future::FutureResult(value = ...future.value$value, 
[10:21:21.590]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.590]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.590]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.590]                     ...future.globalenv.names))
[10:21:21.590]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.590]         }, condition = base::local({
[10:21:21.590]             c <- base::c
[10:21:21.590]             inherits <- base::inherits
[10:21:21.590]             invokeRestart <- base::invokeRestart
[10:21:21.590]             length <- base::length
[10:21:21.590]             list <- base::list
[10:21:21.590]             seq.int <- base::seq.int
[10:21:21.590]             signalCondition <- base::signalCondition
[10:21:21.590]             sys.calls <- base::sys.calls
[10:21:21.590]             `[[` <- base::`[[`
[10:21:21.590]             `+` <- base::`+`
[10:21:21.590]             `<<-` <- base::`<<-`
[10:21:21.590]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.590]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.590]                   3L)]
[10:21:21.590]             }
[10:21:21.590]             function(cond) {
[10:21:21.590]                 is_error <- inherits(cond, "error")
[10:21:21.590]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.590]                   NULL)
[10:21:21.590]                 if (is_error) {
[10:21:21.590]                   sessionInformation <- function() {
[10:21:21.590]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.590]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.590]                       search = base::search(), system = base::Sys.info())
[10:21:21.590]                   }
[10:21:21.590]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.590]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.590]                     cond$call), session = sessionInformation(), 
[10:21:21.590]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.590]                   signalCondition(cond)
[10:21:21.590]                 }
[10:21:21.590]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.590]                 "immediateCondition"))) {
[10:21:21.590]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.590]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.590]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.590]                   if (TRUE && !signal) {
[10:21:21.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.590]                     {
[10:21:21.590]                       inherits <- base::inherits
[10:21:21.590]                       invokeRestart <- base::invokeRestart
[10:21:21.590]                       is.null <- base::is.null
[10:21:21.590]                       muffled <- FALSE
[10:21:21.590]                       if (inherits(cond, "message")) {
[10:21:21.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.590]                         if (muffled) 
[10:21:21.590]                           invokeRestart("muffleMessage")
[10:21:21.590]                       }
[10:21:21.590]                       else if (inherits(cond, "warning")) {
[10:21:21.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.590]                         if (muffled) 
[10:21:21.590]                           invokeRestart("muffleWarning")
[10:21:21.590]                       }
[10:21:21.590]                       else if (inherits(cond, "condition")) {
[10:21:21.590]                         if (!is.null(pattern)) {
[10:21:21.590]                           computeRestarts <- base::computeRestarts
[10:21:21.590]                           grepl <- base::grepl
[10:21:21.590]                           restarts <- computeRestarts(cond)
[10:21:21.590]                           for (restart in restarts) {
[10:21:21.590]                             name <- restart$name
[10:21:21.590]                             if (is.null(name)) 
[10:21:21.590]                               next
[10:21:21.590]                             if (!grepl(pattern, name)) 
[10:21:21.590]                               next
[10:21:21.590]                             invokeRestart(restart)
[10:21:21.590]                             muffled <- TRUE
[10:21:21.590]                             break
[10:21:21.590]                           }
[10:21:21.590]                         }
[10:21:21.590]                       }
[10:21:21.590]                       invisible(muffled)
[10:21:21.590]                     }
[10:21:21.590]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.590]                   }
[10:21:21.590]                 }
[10:21:21.590]                 else {
[10:21:21.590]                   if (TRUE) {
[10:21:21.590]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.590]                     {
[10:21:21.590]                       inherits <- base::inherits
[10:21:21.590]                       invokeRestart <- base::invokeRestart
[10:21:21.590]                       is.null <- base::is.null
[10:21:21.590]                       muffled <- FALSE
[10:21:21.590]                       if (inherits(cond, "message")) {
[10:21:21.590]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.590]                         if (muffled) 
[10:21:21.590]                           invokeRestart("muffleMessage")
[10:21:21.590]                       }
[10:21:21.590]                       else if (inherits(cond, "warning")) {
[10:21:21.590]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.590]                         if (muffled) 
[10:21:21.590]                           invokeRestart("muffleWarning")
[10:21:21.590]                       }
[10:21:21.590]                       else if (inherits(cond, "condition")) {
[10:21:21.590]                         if (!is.null(pattern)) {
[10:21:21.590]                           computeRestarts <- base::computeRestarts
[10:21:21.590]                           grepl <- base::grepl
[10:21:21.590]                           restarts <- computeRestarts(cond)
[10:21:21.590]                           for (restart in restarts) {
[10:21:21.590]                             name <- restart$name
[10:21:21.590]                             if (is.null(name)) 
[10:21:21.590]                               next
[10:21:21.590]                             if (!grepl(pattern, name)) 
[10:21:21.590]                               next
[10:21:21.590]                             invokeRestart(restart)
[10:21:21.590]                             muffled <- TRUE
[10:21:21.590]                             break
[10:21:21.590]                           }
[10:21:21.590]                         }
[10:21:21.590]                       }
[10:21:21.590]                       invisible(muffled)
[10:21:21.590]                     }
[10:21:21.590]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.590]                   }
[10:21:21.590]                 }
[10:21:21.590]             }
[10:21:21.590]         }))
[10:21:21.590]     }, error = function(ex) {
[10:21:21.590]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.590]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.590]                 ...future.rng), started = ...future.startTime, 
[10:21:21.590]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.590]             version = "1.8"), class = "FutureResult")
[10:21:21.590]     }, finally = {
[10:21:21.590]         if (!identical(...future.workdir, getwd())) 
[10:21:21.590]             setwd(...future.workdir)
[10:21:21.590]         {
[10:21:21.590]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.590]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.590]             }
[10:21:21.590]             base::options(...future.oldOptions)
[10:21:21.590]             if (.Platform$OS.type == "windows") {
[10:21:21.590]                 old_names <- names(...future.oldEnvVars)
[10:21:21.590]                 envs <- base::Sys.getenv()
[10:21:21.590]                 names <- names(envs)
[10:21:21.590]                 common <- intersect(names, old_names)
[10:21:21.590]                 added <- setdiff(names, old_names)
[10:21:21.590]                 removed <- setdiff(old_names, names)
[10:21:21.590]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.590]                   envs[common]]
[10:21:21.590]                 NAMES <- toupper(changed)
[10:21:21.590]                 args <- list()
[10:21:21.590]                 for (kk in seq_along(NAMES)) {
[10:21:21.590]                   name <- changed[[kk]]
[10:21:21.590]                   NAME <- NAMES[[kk]]
[10:21:21.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.590]                     next
[10:21:21.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.590]                 }
[10:21:21.590]                 NAMES <- toupper(added)
[10:21:21.590]                 for (kk in seq_along(NAMES)) {
[10:21:21.590]                   name <- added[[kk]]
[10:21:21.590]                   NAME <- NAMES[[kk]]
[10:21:21.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.590]                     next
[10:21:21.590]                   args[[name]] <- ""
[10:21:21.590]                 }
[10:21:21.590]                 NAMES <- toupper(removed)
[10:21:21.590]                 for (kk in seq_along(NAMES)) {
[10:21:21.590]                   name <- removed[[kk]]
[10:21:21.590]                   NAME <- NAMES[[kk]]
[10:21:21.590]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.590]                     next
[10:21:21.590]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.590]                 }
[10:21:21.590]                 if (length(args) > 0) 
[10:21:21.590]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.590]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.590]             }
[10:21:21.590]             else {
[10:21:21.590]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.590]             }
[10:21:21.590]             {
[10:21:21.590]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.590]                   0L) {
[10:21:21.590]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.590]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.590]                   base::options(opts)
[10:21:21.590]                 }
[10:21:21.590]                 {
[10:21:21.590]                   {
[10:21:21.590]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.590]                     NULL
[10:21:21.590]                   }
[10:21:21.590]                   options(future.plan = NULL)
[10:21:21.590]                   if (is.na(NA_character_)) 
[10:21:21.590]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.590]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.590]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.590]                     .init = FALSE)
[10:21:21.590]                 }
[10:21:21.590]             }
[10:21:21.590]         }
[10:21:21.590]     })
[10:21:21.590]     if (TRUE) {
[10:21:21.590]         base::sink(type = "output", split = FALSE)
[10:21:21.590]         if (TRUE) {
[10:21:21.590]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.590]         }
[10:21:21.590]         else {
[10:21:21.590]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.590]         }
[10:21:21.590]         base::close(...future.stdout)
[10:21:21.590]         ...future.stdout <- NULL
[10:21:21.590]     }
[10:21:21.590]     ...future.result$conditions <- ...future.conditions
[10:21:21.590]     ...future.result$finished <- base::Sys.time()
[10:21:21.590]     ...future.result
[10:21:21.590] }
[10:21:21.593] requestCore(): workers = 2
[10:21:21.596] MulticoreFuture started
[10:21:21.596] - Launch lazy future ... done
[10:21:21.596] run() for ‘MulticoreFuture’ ... done
[10:21:21.597] plan(): Setting new future strategy stack:
[10:21:21.597] getGlobalsAndPackages() ...
[10:21:21.597] Searching for globals...
[10:21:21.597] List of future strategies:
[10:21:21.597] 1. sequential:
[10:21:21.597]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.597]    - tweaked: FALSE
[10:21:21.597]    - call: NULL
[10:21:21.598] plan(): nbrOfWorkers() = 1
[10:21:21.599] - globals found: [1] ‘{’
[10:21:21.599] Searching for globals ... DONE
[10:21:21.599] Resolving globals: FALSE
[10:21:21.600] 
[10:21:21.600] 
[10:21:21.600] getGlobalsAndPackages() ... DONE
[10:21:21.600] run() for ‘Future’ ...
[10:21:21.600] plan(): Setting new future strategy stack:
[10:21:21.600] - state: ‘created’
[10:21:21.601] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.601] List of future strategies:
[10:21:21.601] 1. multicore:
[10:21:21.601]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.601]    - tweaked: FALSE
[10:21:21.601]    - call: plan(strategy)
[10:21:21.603] plan(): nbrOfWorkers() = 2
[10:21:21.604] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.604]   - Field: ‘label’
[10:21:21.604]   - Field: ‘local’
[10:21:21.604]   - Field: ‘owner’
[10:21:21.605]   - Field: ‘envir’
[10:21:21.605]   - Field: ‘workers’
[10:21:21.605]   - Field: ‘packages’
[10:21:21.605]   - Field: ‘gc’
[10:21:21.605]   - Field: ‘job’
[10:21:21.605]   - Field: ‘conditions’
[10:21:21.605]   - Field: ‘expr’
[10:21:21.606]   - Field: ‘uuid’
[10:21:21.606]   - Field: ‘seed’
[10:21:21.606]   - Field: ‘version’
[10:21:21.606]   - Field: ‘result’
[10:21:21.606]   - Field: ‘asynchronous’
[10:21:21.606]   - Field: ‘calls’
[10:21:21.606]   - Field: ‘globals’
[10:21:21.607]   - Field: ‘stdout’
[10:21:21.607]   - Field: ‘earlySignal’
[10:21:21.607]   - Field: ‘lazy’
[10:21:21.607]   - Field: ‘state’
[10:21:21.607] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.607] - Launch lazy future ...
[10:21:21.608] Packages needed by the future expression (n = 0): <none>
[10:21:21.608] Packages needed by future strategies (n = 0): <none>
[10:21:21.609] {
[10:21:21.609]     {
[10:21:21.609]         {
[10:21:21.609]             ...future.startTime <- base::Sys.time()
[10:21:21.609]             {
[10:21:21.609]                 {
[10:21:21.609]                   {
[10:21:21.609]                     {
[10:21:21.609]                       base::local({
[10:21:21.609]                         has_future <- base::requireNamespace("future", 
[10:21:21.609]                           quietly = TRUE)
[10:21:21.609]                         if (has_future) {
[10:21:21.609]                           ns <- base::getNamespace("future")
[10:21:21.609]                           version <- ns[[".package"]][["version"]]
[10:21:21.609]                           if (is.null(version)) 
[10:21:21.609]                             version <- utils::packageVersion("future")
[10:21:21.609]                         }
[10:21:21.609]                         else {
[10:21:21.609]                           version <- NULL
[10:21:21.609]                         }
[10:21:21.609]                         if (!has_future || version < "1.8.0") {
[10:21:21.609]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.609]                             "", base::R.version$version.string), 
[10:21:21.609]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.609]                               "release", "version")], collapse = " "), 
[10:21:21.609]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.609]                             info)
[10:21:21.609]                           info <- base::paste(info, collapse = "; ")
[10:21:21.609]                           if (!has_future) {
[10:21:21.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.609]                               info)
[10:21:21.609]                           }
[10:21:21.609]                           else {
[10:21:21.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.609]                               info, version)
[10:21:21.609]                           }
[10:21:21.609]                           base::stop(msg)
[10:21:21.609]                         }
[10:21:21.609]                       })
[10:21:21.609]                     }
[10:21:21.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.609]                     base::options(mc.cores = 1L)
[10:21:21.609]                   }
[10:21:21.609]                   ...future.strategy.old <- future::plan("list")
[10:21:21.609]                   options(future.plan = NULL)
[10:21:21.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.609]                 }
[10:21:21.609]                 ...future.workdir <- getwd()
[10:21:21.609]             }
[10:21:21.609]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.609]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.609]         }
[10:21:21.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.609]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.609]             base::names(...future.oldOptions))
[10:21:21.609]     }
[10:21:21.609]     if (FALSE) {
[10:21:21.609]     }
[10:21:21.609]     else {
[10:21:21.609]         if (TRUE) {
[10:21:21.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.609]                 open = "w")
[10:21:21.609]         }
[10:21:21.609]         else {
[10:21:21.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.609]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.609]         }
[10:21:21.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.609]             base::sink(type = "output", split = FALSE)
[10:21:21.609]             base::close(...future.stdout)
[10:21:21.609]         }, add = TRUE)
[10:21:21.609]     }
[10:21:21.609]     ...future.frame <- base::sys.nframe()
[10:21:21.609]     ...future.conditions <- base::list()
[10:21:21.609]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.609]     if (FALSE) {
[10:21:21.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.609]     }
[10:21:21.609]     ...future.result <- base::tryCatch({
[10:21:21.609]         base::withCallingHandlers({
[10:21:21.609]             ...future.value <- base::withVisible(base::local({
[10:21:21.609]                 withCallingHandlers({
[10:21:21.609]                   {
[10:21:21.609]                     4
[10:21:21.609]                   }
[10:21:21.609]                 }, immediateCondition = function(cond) {
[10:21:21.609]                   save_rds <- function (object, pathname, ...) 
[10:21:21.609]                   {
[10:21:21.609]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.609]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.609]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.609]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.609]                         fi_tmp[["mtime"]])
[10:21:21.609]                     }
[10:21:21.609]                     tryCatch({
[10:21:21.609]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.609]                     }, error = function(ex) {
[10:21:21.609]                       msg <- conditionMessage(ex)
[10:21:21.609]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.609]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.609]                         fi_tmp[["mtime"]], msg)
[10:21:21.609]                       ex$message <- msg
[10:21:21.609]                       stop(ex)
[10:21:21.609]                     })
[10:21:21.609]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.609]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.609]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.609]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.609]                       fi <- file.info(pathname)
[10:21:21.609]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.609]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.609]                         fi[["size"]], fi[["mtime"]])
[10:21:21.609]                       stop(msg)
[10:21:21.609]                     }
[10:21:21.609]                     invisible(pathname)
[10:21:21.609]                   }
[10:21:21.609]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.609]                     rootPath = tempdir()) 
[10:21:21.609]                   {
[10:21:21.609]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.609]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.609]                       tmpdir = path, fileext = ".rds")
[10:21:21.609]                     save_rds(obj, file)
[10:21:21.609]                   }
[10:21:21.609]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.609]                   {
[10:21:21.609]                     inherits <- base::inherits
[10:21:21.609]                     invokeRestart <- base::invokeRestart
[10:21:21.609]                     is.null <- base::is.null
[10:21:21.609]                     muffled <- FALSE
[10:21:21.609]                     if (inherits(cond, "message")) {
[10:21:21.609]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.609]                       if (muffled) 
[10:21:21.609]                         invokeRestart("muffleMessage")
[10:21:21.609]                     }
[10:21:21.609]                     else if (inherits(cond, "warning")) {
[10:21:21.609]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.609]                       if (muffled) 
[10:21:21.609]                         invokeRestart("muffleWarning")
[10:21:21.609]                     }
[10:21:21.609]                     else if (inherits(cond, "condition")) {
[10:21:21.609]                       if (!is.null(pattern)) {
[10:21:21.609]                         computeRestarts <- base::computeRestarts
[10:21:21.609]                         grepl <- base::grepl
[10:21:21.609]                         restarts <- computeRestarts(cond)
[10:21:21.609]                         for (restart in restarts) {
[10:21:21.609]                           name <- restart$name
[10:21:21.609]                           if (is.null(name)) 
[10:21:21.609]                             next
[10:21:21.609]                           if (!grepl(pattern, name)) 
[10:21:21.609]                             next
[10:21:21.609]                           invokeRestart(restart)
[10:21:21.609]                           muffled <- TRUE
[10:21:21.609]                           break
[10:21:21.609]                         }
[10:21:21.609]                       }
[10:21:21.609]                     }
[10:21:21.609]                     invisible(muffled)
[10:21:21.609]                   }
[10:21:21.609]                   muffleCondition(cond)
[10:21:21.609]                 })
[10:21:21.609]             }))
[10:21:21.609]             future::FutureResult(value = ...future.value$value, 
[10:21:21.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.609]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.609]                     ...future.globalenv.names))
[10:21:21.609]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.609]         }, condition = base::local({
[10:21:21.609]             c <- base::c
[10:21:21.609]             inherits <- base::inherits
[10:21:21.609]             invokeRestart <- base::invokeRestart
[10:21:21.609]             length <- base::length
[10:21:21.609]             list <- base::list
[10:21:21.609]             seq.int <- base::seq.int
[10:21:21.609]             signalCondition <- base::signalCondition
[10:21:21.609]             sys.calls <- base::sys.calls
[10:21:21.609]             `[[` <- base::`[[`
[10:21:21.609]             `+` <- base::`+`
[10:21:21.609]             `<<-` <- base::`<<-`
[10:21:21.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.609]                   3L)]
[10:21:21.609]             }
[10:21:21.609]             function(cond) {
[10:21:21.609]                 is_error <- inherits(cond, "error")
[10:21:21.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.609]                   NULL)
[10:21:21.609]                 if (is_error) {
[10:21:21.609]                   sessionInformation <- function() {
[10:21:21.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.609]                       search = base::search(), system = base::Sys.info())
[10:21:21.609]                   }
[10:21:21.609]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.609]                     cond$call), session = sessionInformation(), 
[10:21:21.609]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.609]                   signalCondition(cond)
[10:21:21.609]                 }
[10:21:21.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.609]                 "immediateCondition"))) {
[10:21:21.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.609]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.609]                   if (TRUE && !signal) {
[10:21:21.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.609]                     {
[10:21:21.609]                       inherits <- base::inherits
[10:21:21.609]                       invokeRestart <- base::invokeRestart
[10:21:21.609]                       is.null <- base::is.null
[10:21:21.609]                       muffled <- FALSE
[10:21:21.609]                       if (inherits(cond, "message")) {
[10:21:21.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.609]                         if (muffled) 
[10:21:21.609]                           invokeRestart("muffleMessage")
[10:21:21.609]                       }
[10:21:21.609]                       else if (inherits(cond, "warning")) {
[10:21:21.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.609]                         if (muffled) 
[10:21:21.609]                           invokeRestart("muffleWarning")
[10:21:21.609]                       }
[10:21:21.609]                       else if (inherits(cond, "condition")) {
[10:21:21.609]                         if (!is.null(pattern)) {
[10:21:21.609]                           computeRestarts <- base::computeRestarts
[10:21:21.609]                           grepl <- base::grepl
[10:21:21.609]                           restarts <- computeRestarts(cond)
[10:21:21.609]                           for (restart in restarts) {
[10:21:21.609]                             name <- restart$name
[10:21:21.609]                             if (is.null(name)) 
[10:21:21.609]                               next
[10:21:21.609]                             if (!grepl(pattern, name)) 
[10:21:21.609]                               next
[10:21:21.609]                             invokeRestart(restart)
[10:21:21.609]                             muffled <- TRUE
[10:21:21.609]                             break
[10:21:21.609]                           }
[10:21:21.609]                         }
[10:21:21.609]                       }
[10:21:21.609]                       invisible(muffled)
[10:21:21.609]                     }
[10:21:21.609]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.609]                   }
[10:21:21.609]                 }
[10:21:21.609]                 else {
[10:21:21.609]                   if (TRUE) {
[10:21:21.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.609]                     {
[10:21:21.609]                       inherits <- base::inherits
[10:21:21.609]                       invokeRestart <- base::invokeRestart
[10:21:21.609]                       is.null <- base::is.null
[10:21:21.609]                       muffled <- FALSE
[10:21:21.609]                       if (inherits(cond, "message")) {
[10:21:21.609]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.609]                         if (muffled) 
[10:21:21.609]                           invokeRestart("muffleMessage")
[10:21:21.609]                       }
[10:21:21.609]                       else if (inherits(cond, "warning")) {
[10:21:21.609]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.609]                         if (muffled) 
[10:21:21.609]                           invokeRestart("muffleWarning")
[10:21:21.609]                       }
[10:21:21.609]                       else if (inherits(cond, "condition")) {
[10:21:21.609]                         if (!is.null(pattern)) {
[10:21:21.609]                           computeRestarts <- base::computeRestarts
[10:21:21.609]                           grepl <- base::grepl
[10:21:21.609]                           restarts <- computeRestarts(cond)
[10:21:21.609]                           for (restart in restarts) {
[10:21:21.609]                             name <- restart$name
[10:21:21.609]                             if (is.null(name)) 
[10:21:21.609]                               next
[10:21:21.609]                             if (!grepl(pattern, name)) 
[10:21:21.609]                               next
[10:21:21.609]                             invokeRestart(restart)
[10:21:21.609]                             muffled <- TRUE
[10:21:21.609]                             break
[10:21:21.609]                           }
[10:21:21.609]                         }
[10:21:21.609]                       }
[10:21:21.609]                       invisible(muffled)
[10:21:21.609]                     }
[10:21:21.609]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.609]                   }
[10:21:21.609]                 }
[10:21:21.609]             }
[10:21:21.609]         }))
[10:21:21.609]     }, error = function(ex) {
[10:21:21.609]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.609]                 ...future.rng), started = ...future.startTime, 
[10:21:21.609]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.609]             version = "1.8"), class = "FutureResult")
[10:21:21.609]     }, finally = {
[10:21:21.609]         if (!identical(...future.workdir, getwd())) 
[10:21:21.609]             setwd(...future.workdir)
[10:21:21.609]         {
[10:21:21.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.609]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.609]             }
[10:21:21.609]             base::options(...future.oldOptions)
[10:21:21.609]             if (.Platform$OS.type == "windows") {
[10:21:21.609]                 old_names <- names(...future.oldEnvVars)
[10:21:21.609]                 envs <- base::Sys.getenv()
[10:21:21.609]                 names <- names(envs)
[10:21:21.609]                 common <- intersect(names, old_names)
[10:21:21.609]                 added <- setdiff(names, old_names)
[10:21:21.609]                 removed <- setdiff(old_names, names)
[10:21:21.609]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.609]                   envs[common]]
[10:21:21.609]                 NAMES <- toupper(changed)
[10:21:21.609]                 args <- list()
[10:21:21.609]                 for (kk in seq_along(NAMES)) {
[10:21:21.609]                   name <- changed[[kk]]
[10:21:21.609]                   NAME <- NAMES[[kk]]
[10:21:21.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.609]                     next
[10:21:21.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.609]                 }
[10:21:21.609]                 NAMES <- toupper(added)
[10:21:21.609]                 for (kk in seq_along(NAMES)) {
[10:21:21.609]                   name <- added[[kk]]
[10:21:21.609]                   NAME <- NAMES[[kk]]
[10:21:21.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.609]                     next
[10:21:21.609]                   args[[name]] <- ""
[10:21:21.609]                 }
[10:21:21.609]                 NAMES <- toupper(removed)
[10:21:21.609]                 for (kk in seq_along(NAMES)) {
[10:21:21.609]                   name <- removed[[kk]]
[10:21:21.609]                   NAME <- NAMES[[kk]]
[10:21:21.609]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.609]                     next
[10:21:21.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.609]                 }
[10:21:21.609]                 if (length(args) > 0) 
[10:21:21.609]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.609]             }
[10:21:21.609]             else {
[10:21:21.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.609]             }
[10:21:21.609]             {
[10:21:21.609]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.609]                   0L) {
[10:21:21.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.609]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.609]                   base::options(opts)
[10:21:21.609]                 }
[10:21:21.609]                 {
[10:21:21.609]                   {
[10:21:21.609]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.609]                     NULL
[10:21:21.609]                   }
[10:21:21.609]                   options(future.plan = NULL)
[10:21:21.609]                   if (is.na(NA_character_)) 
[10:21:21.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.609]                     .init = FALSE)
[10:21:21.609]                 }
[10:21:21.609]             }
[10:21:21.609]         }
[10:21:21.609]     })
[10:21:21.609]     if (TRUE) {
[10:21:21.609]         base::sink(type = "output", split = FALSE)
[10:21:21.609]         if (TRUE) {
[10:21:21.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.609]         }
[10:21:21.609]         else {
[10:21:21.609]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.609]         }
[10:21:21.609]         base::close(...future.stdout)
[10:21:21.609]         ...future.stdout <- NULL
[10:21:21.609]     }
[10:21:21.609]     ...future.result$conditions <- ...future.conditions
[10:21:21.609]     ...future.result$finished <- base::Sys.time()
[10:21:21.609]     ...future.result
[10:21:21.609] }
[10:21:21.612] requestCore(): workers = 2
[10:21:21.612] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:21.623] result() for MulticoreFuture ...
[10:21:21.624] result() for MulticoreFuture ...
[10:21:21.624] result() for MulticoreFuture ... done
[10:21:21.624] result() for MulticoreFuture ... done
[10:21:21.624] result() for MulticoreFuture ...
[10:21:21.625] result() for MulticoreFuture ... done
[10:21:21.627] MulticoreFuture started
[10:21:21.628] - Launch lazy future ... done
[10:21:21.628] run() for ‘MulticoreFuture’ ... done
[10:21:21.629] plan(): Setting new future strategy stack:
<environment: 0x55e8e768d208> 
[10:21:21.629] List of future strategies:
[10:21:21.629] 1. sequential:
[10:21:21.629]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.629]    - tweaked: FALSE
[10:21:21.629]    - call: NULL
[10:21:21.631] plan(): nbrOfWorkers() = 1
<environment: 0x55e8e315a1b8> 
[10:21:21.633] plan(): Setting new future strategy stack:
[10:21:21.633] List of future strategies:
[10:21:21.633] 1. multicore:
[10:21:21.633]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.633]    - tweaked: FALSE
[10:21:21.633]    - call: plan(strategy)
[10:21:21.637] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:21.639] resolve() on environment ...
[10:21:21.640]  recursive: 0
[10:21:21.641]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:21.641] signalConditionsASAP(numeric, pos=1) ...
[10:21:21.641] - nx: 4
[10:21:21.641] - relay: TRUE
[10:21:21.641] - stdout: TRUE
[10:21:21.642] - signal: TRUE
[10:21:21.642] - resignal: FALSE
[10:21:21.642] - force: TRUE
[10:21:21.642] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.642] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.642]  - until=2
[10:21:21.642]  - relaying element #2
[10:21:21.643] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.643] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.643] signalConditionsASAP(NULL, pos=1) ... done
[10:21:21.643]  length: 3 (resolved future 1)
[10:21:21.643] Future #2
[10:21:21.643] result() for MulticoreFuture ...
[10:21:21.644] result() for MulticoreFuture ... done
[10:21:21.644] result() for MulticoreFuture ...
[10:21:21.644] result() for MulticoreFuture ... done
[10:21:21.644] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:21.644] - nx: 4
[10:21:21.644] - relay: TRUE
[10:21:21.645] - stdout: TRUE
[10:21:21.645] - signal: TRUE
[10:21:21.645] - resignal: FALSE
[10:21:21.645] - force: TRUE
[10:21:21.645] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.645] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.645]  - until=2
[10:21:21.645]  - relaying element #2
[10:21:21.646] result() for MulticoreFuture ...
[10:21:21.646] result() for MulticoreFuture ... done
[10:21:21.646] result() for MulticoreFuture ...
[10:21:21.646] result() for MulticoreFuture ... done
[10:21:21.646] result() for MulticoreFuture ...
[10:21:21.646] result() for MulticoreFuture ... done
[10:21:21.646] result() for MulticoreFuture ...
[10:21:21.647] result() for MulticoreFuture ... done
[10:21:21.647] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.647] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.647] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:21.647]  length: 2 (resolved future 2)
[10:21:21.648] Future #3
[10:21:21.648] result() for MulticoreFuture ...
[10:21:21.649] result() for MulticoreFuture ...
[10:21:21.649] result() for MulticoreFuture ... done
[10:21:21.649] result() for MulticoreFuture ... done
[10:21:21.649] result() for MulticoreFuture ...
[10:21:21.649] result() for MulticoreFuture ... done
[10:21:21.649] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:21.649] - nx: 4
[10:21:21.649] - relay: TRUE
[10:21:21.650] - stdout: TRUE
[10:21:21.650] - signal: TRUE
[10:21:21.650] - resignal: FALSE
[10:21:21.650] - force: TRUE
[10:21:21.650] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.650] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.650]  - until=3
[10:21:21.650]  - relaying element #3
[10:21:21.651] result() for MulticoreFuture ...
[10:21:21.651] result() for MulticoreFuture ... done
[10:21:21.651] result() for MulticoreFuture ...
[10:21:21.651] result() for MulticoreFuture ... done
[10:21:21.651] result() for MulticoreFuture ...
[10:21:21.651] result() for MulticoreFuture ... done
[10:21:21.651] result() for MulticoreFuture ...
[10:21:21.652] result() for MulticoreFuture ... done
[10:21:21.652] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.652] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.652] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:21.652]  length: 1 (resolved future 3)
[10:21:21.652] Future #4
[10:21:21.653] result() for MulticoreFuture ...
[10:21:21.653] result() for MulticoreFuture ...
[10:21:21.653] result() for MulticoreFuture ... done
[10:21:21.654] result() for MulticoreFuture ... done
[10:21:21.654] result() for MulticoreFuture ...
[10:21:21.654] result() for MulticoreFuture ... done
[10:21:21.654] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:21.654] - nx: 4
[10:21:21.655] - relay: TRUE
[10:21:21.655] - stdout: TRUE
[10:21:21.655] - signal: TRUE
[10:21:21.655] - resignal: FALSE
[10:21:21.655] - force: TRUE
[10:21:21.655] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.656] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.656]  - until=4
[10:21:21.656]  - relaying element #4
[10:21:21.656] result() for MulticoreFuture ...
[10:21:21.656] result() for MulticoreFuture ... done
[10:21:21.656] result() for MulticoreFuture ...
[10:21:21.657] result() for MulticoreFuture ... done
[10:21:21.657] result() for MulticoreFuture ...
[10:21:21.657] result() for MulticoreFuture ... done
[10:21:21.657] result() for MulticoreFuture ...
[10:21:21.657] result() for MulticoreFuture ... done
[10:21:21.657] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.658] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.658] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:21.658]  length: 0 (resolved future 4)
[10:21:21.658] Relaying remaining futures
[10:21:21.658] signalConditionsASAP(NULL, pos=0) ...
[10:21:21.658] - nx: 4
[10:21:21.658] - relay: TRUE
[10:21:21.658] - stdout: TRUE
[10:21:21.658] - signal: TRUE
[10:21:21.659] - resignal: FALSE
[10:21:21.659] - force: TRUE
[10:21:21.659] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.659] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:21.659] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.659] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.659] signalConditionsASAP(NULL, pos=0) ... done
[10:21:21.659] resolve() on environment ... DONE
[10:21:21.659] result() for MulticoreFuture ...
[10:21:21.660] result() for MulticoreFuture ... done
[10:21:21.660] result() for MulticoreFuture ...
[10:21:21.660] result() for MulticoreFuture ... done
[10:21:21.660] result() for MulticoreFuture ...
[10:21:21.660] result() for MulticoreFuture ... done
[10:21:21.660] result() for MulticoreFuture ...
[10:21:21.660] result() for MulticoreFuture ... done
[10:21:21.660] result() for MulticoreFuture ...
[10:21:21.660] result() for MulticoreFuture ... done
[10:21:21.661] result() for MulticoreFuture ...
[10:21:21.661] result() for MulticoreFuture ... done
<environment: 0x55e8e450a428> 
Dimensions: c(2, 1, 3, 1)
[10:21:21.661] getGlobalsAndPackages() ...
[10:21:21.661] Searching for globals...
[10:21:21.662] 
[10:21:21.662] Searching for globals ... DONE
[10:21:21.662] - globals: [0] <none>
[10:21:21.662] getGlobalsAndPackages() ... DONE
[10:21:21.662] run() for ‘Future’ ...
[10:21:21.663] - state: ‘created’
[10:21:21.663] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.665] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.665] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.665]   - Field: ‘label’
[10:21:21.665]   - Field: ‘local’
[10:21:21.665]   - Field: ‘owner’
[10:21:21.665]   - Field: ‘envir’
[10:21:21.665]   - Field: ‘workers’
[10:21:21.666]   - Field: ‘packages’
[10:21:21.666]   - Field: ‘gc’
[10:21:21.666]   - Field: ‘job’
[10:21:21.666]   - Field: ‘conditions’
[10:21:21.666]   - Field: ‘expr’
[10:21:21.666]   - Field: ‘uuid’
[10:21:21.666]   - Field: ‘seed’
[10:21:21.666]   - Field: ‘version’
[10:21:21.666]   - Field: ‘result’
[10:21:21.666]   - Field: ‘asynchronous’
[10:21:21.667]   - Field: ‘calls’
[10:21:21.667]   - Field: ‘globals’
[10:21:21.667]   - Field: ‘stdout’
[10:21:21.667]   - Field: ‘earlySignal’
[10:21:21.667]   - Field: ‘lazy’
[10:21:21.667]   - Field: ‘state’
[10:21:21.667] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.667] - Launch lazy future ...
[10:21:21.668] Packages needed by the future expression (n = 0): <none>
[10:21:21.668] Packages needed by future strategies (n = 0): <none>
[10:21:21.668] {
[10:21:21.668]     {
[10:21:21.668]         {
[10:21:21.668]             ...future.startTime <- base::Sys.time()
[10:21:21.668]             {
[10:21:21.668]                 {
[10:21:21.668]                   {
[10:21:21.668]                     {
[10:21:21.668]                       base::local({
[10:21:21.668]                         has_future <- base::requireNamespace("future", 
[10:21:21.668]                           quietly = TRUE)
[10:21:21.668]                         if (has_future) {
[10:21:21.668]                           ns <- base::getNamespace("future")
[10:21:21.668]                           version <- ns[[".package"]][["version"]]
[10:21:21.668]                           if (is.null(version)) 
[10:21:21.668]                             version <- utils::packageVersion("future")
[10:21:21.668]                         }
[10:21:21.668]                         else {
[10:21:21.668]                           version <- NULL
[10:21:21.668]                         }
[10:21:21.668]                         if (!has_future || version < "1.8.0") {
[10:21:21.668]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.668]                             "", base::R.version$version.string), 
[10:21:21.668]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.668]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.668]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.668]                               "release", "version")], collapse = " "), 
[10:21:21.668]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.668]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.668]                             info)
[10:21:21.668]                           info <- base::paste(info, collapse = "; ")
[10:21:21.668]                           if (!has_future) {
[10:21:21.668]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.668]                               info)
[10:21:21.668]                           }
[10:21:21.668]                           else {
[10:21:21.668]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.668]                               info, version)
[10:21:21.668]                           }
[10:21:21.668]                           base::stop(msg)
[10:21:21.668]                         }
[10:21:21.668]                       })
[10:21:21.668]                     }
[10:21:21.668]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.668]                     base::options(mc.cores = 1L)
[10:21:21.668]                   }
[10:21:21.668]                   ...future.strategy.old <- future::plan("list")
[10:21:21.668]                   options(future.plan = NULL)
[10:21:21.668]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.668]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.668]                 }
[10:21:21.668]                 ...future.workdir <- getwd()
[10:21:21.668]             }
[10:21:21.668]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.668]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.668]         }
[10:21:21.668]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.668]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.668]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.668]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.668]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.668]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.668]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.668]             base::names(...future.oldOptions))
[10:21:21.668]     }
[10:21:21.668]     if (FALSE) {
[10:21:21.668]     }
[10:21:21.668]     else {
[10:21:21.668]         if (TRUE) {
[10:21:21.668]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.668]                 open = "w")
[10:21:21.668]         }
[10:21:21.668]         else {
[10:21:21.668]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.668]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.668]         }
[10:21:21.668]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.668]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.668]             base::sink(type = "output", split = FALSE)
[10:21:21.668]             base::close(...future.stdout)
[10:21:21.668]         }, add = TRUE)
[10:21:21.668]     }
[10:21:21.668]     ...future.frame <- base::sys.nframe()
[10:21:21.668]     ...future.conditions <- base::list()
[10:21:21.668]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.668]     if (FALSE) {
[10:21:21.668]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.668]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.668]     }
[10:21:21.668]     ...future.result <- base::tryCatch({
[10:21:21.668]         base::withCallingHandlers({
[10:21:21.668]             ...future.value <- base::withVisible(base::local({
[10:21:21.668]                 withCallingHandlers({
[10:21:21.668]                   2
[10:21:21.668]                 }, immediateCondition = function(cond) {
[10:21:21.668]                   save_rds <- function (object, pathname, ...) 
[10:21:21.668]                   {
[10:21:21.668]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.668]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.668]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.668]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.668]                         fi_tmp[["mtime"]])
[10:21:21.668]                     }
[10:21:21.668]                     tryCatch({
[10:21:21.668]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.668]                     }, error = function(ex) {
[10:21:21.668]                       msg <- conditionMessage(ex)
[10:21:21.668]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.668]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.668]                         fi_tmp[["mtime"]], msg)
[10:21:21.668]                       ex$message <- msg
[10:21:21.668]                       stop(ex)
[10:21:21.668]                     })
[10:21:21.668]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.668]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.668]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.668]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.668]                       fi <- file.info(pathname)
[10:21:21.668]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.668]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.668]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.668]                         fi[["size"]], fi[["mtime"]])
[10:21:21.668]                       stop(msg)
[10:21:21.668]                     }
[10:21:21.668]                     invisible(pathname)
[10:21:21.668]                   }
[10:21:21.668]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.668]                     rootPath = tempdir()) 
[10:21:21.668]                   {
[10:21:21.668]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.668]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.668]                       tmpdir = path, fileext = ".rds")
[10:21:21.668]                     save_rds(obj, file)
[10:21:21.668]                   }
[10:21:21.668]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.668]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.668]                   {
[10:21:21.668]                     inherits <- base::inherits
[10:21:21.668]                     invokeRestart <- base::invokeRestart
[10:21:21.668]                     is.null <- base::is.null
[10:21:21.668]                     muffled <- FALSE
[10:21:21.668]                     if (inherits(cond, "message")) {
[10:21:21.668]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.668]                       if (muffled) 
[10:21:21.668]                         invokeRestart("muffleMessage")
[10:21:21.668]                     }
[10:21:21.668]                     else if (inherits(cond, "warning")) {
[10:21:21.668]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.668]                       if (muffled) 
[10:21:21.668]                         invokeRestart("muffleWarning")
[10:21:21.668]                     }
[10:21:21.668]                     else if (inherits(cond, "condition")) {
[10:21:21.668]                       if (!is.null(pattern)) {
[10:21:21.668]                         computeRestarts <- base::computeRestarts
[10:21:21.668]                         grepl <- base::grepl
[10:21:21.668]                         restarts <- computeRestarts(cond)
[10:21:21.668]                         for (restart in restarts) {
[10:21:21.668]                           name <- restart$name
[10:21:21.668]                           if (is.null(name)) 
[10:21:21.668]                             next
[10:21:21.668]                           if (!grepl(pattern, name)) 
[10:21:21.668]                             next
[10:21:21.668]                           invokeRestart(restart)
[10:21:21.668]                           muffled <- TRUE
[10:21:21.668]                           break
[10:21:21.668]                         }
[10:21:21.668]                       }
[10:21:21.668]                     }
[10:21:21.668]                     invisible(muffled)
[10:21:21.668]                   }
[10:21:21.668]                   muffleCondition(cond)
[10:21:21.668]                 })
[10:21:21.668]             }))
[10:21:21.668]             future::FutureResult(value = ...future.value$value, 
[10:21:21.668]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.668]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.668]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.668]                     ...future.globalenv.names))
[10:21:21.668]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.668]         }, condition = base::local({
[10:21:21.668]             c <- base::c
[10:21:21.668]             inherits <- base::inherits
[10:21:21.668]             invokeRestart <- base::invokeRestart
[10:21:21.668]             length <- base::length
[10:21:21.668]             list <- base::list
[10:21:21.668]             seq.int <- base::seq.int
[10:21:21.668]             signalCondition <- base::signalCondition
[10:21:21.668]             sys.calls <- base::sys.calls
[10:21:21.668]             `[[` <- base::`[[`
[10:21:21.668]             `+` <- base::`+`
[10:21:21.668]             `<<-` <- base::`<<-`
[10:21:21.668]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.668]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.668]                   3L)]
[10:21:21.668]             }
[10:21:21.668]             function(cond) {
[10:21:21.668]                 is_error <- inherits(cond, "error")
[10:21:21.668]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.668]                   NULL)
[10:21:21.668]                 if (is_error) {
[10:21:21.668]                   sessionInformation <- function() {
[10:21:21.668]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.668]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.668]                       search = base::search(), system = base::Sys.info())
[10:21:21.668]                   }
[10:21:21.668]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.668]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.668]                     cond$call), session = sessionInformation(), 
[10:21:21.668]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.668]                   signalCondition(cond)
[10:21:21.668]                 }
[10:21:21.668]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.668]                 "immediateCondition"))) {
[10:21:21.668]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.668]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.668]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.668]                   if (TRUE && !signal) {
[10:21:21.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.668]                     {
[10:21:21.668]                       inherits <- base::inherits
[10:21:21.668]                       invokeRestart <- base::invokeRestart
[10:21:21.668]                       is.null <- base::is.null
[10:21:21.668]                       muffled <- FALSE
[10:21:21.668]                       if (inherits(cond, "message")) {
[10:21:21.668]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.668]                         if (muffled) 
[10:21:21.668]                           invokeRestart("muffleMessage")
[10:21:21.668]                       }
[10:21:21.668]                       else if (inherits(cond, "warning")) {
[10:21:21.668]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.668]                         if (muffled) 
[10:21:21.668]                           invokeRestart("muffleWarning")
[10:21:21.668]                       }
[10:21:21.668]                       else if (inherits(cond, "condition")) {
[10:21:21.668]                         if (!is.null(pattern)) {
[10:21:21.668]                           computeRestarts <- base::computeRestarts
[10:21:21.668]                           grepl <- base::grepl
[10:21:21.668]                           restarts <- computeRestarts(cond)
[10:21:21.668]                           for (restart in restarts) {
[10:21:21.668]                             name <- restart$name
[10:21:21.668]                             if (is.null(name)) 
[10:21:21.668]                               next
[10:21:21.668]                             if (!grepl(pattern, name)) 
[10:21:21.668]                               next
[10:21:21.668]                             invokeRestart(restart)
[10:21:21.668]                             muffled <- TRUE
[10:21:21.668]                             break
[10:21:21.668]                           }
[10:21:21.668]                         }
[10:21:21.668]                       }
[10:21:21.668]                       invisible(muffled)
[10:21:21.668]                     }
[10:21:21.668]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.668]                   }
[10:21:21.668]                 }
[10:21:21.668]                 else {
[10:21:21.668]                   if (TRUE) {
[10:21:21.668]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.668]                     {
[10:21:21.668]                       inherits <- base::inherits
[10:21:21.668]                       invokeRestart <- base::invokeRestart
[10:21:21.668]                       is.null <- base::is.null
[10:21:21.668]                       muffled <- FALSE
[10:21:21.668]                       if (inherits(cond, "message")) {
[10:21:21.668]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.668]                         if (muffled) 
[10:21:21.668]                           invokeRestart("muffleMessage")
[10:21:21.668]                       }
[10:21:21.668]                       else if (inherits(cond, "warning")) {
[10:21:21.668]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.668]                         if (muffled) 
[10:21:21.668]                           invokeRestart("muffleWarning")
[10:21:21.668]                       }
[10:21:21.668]                       else if (inherits(cond, "condition")) {
[10:21:21.668]                         if (!is.null(pattern)) {
[10:21:21.668]                           computeRestarts <- base::computeRestarts
[10:21:21.668]                           grepl <- base::grepl
[10:21:21.668]                           restarts <- computeRestarts(cond)
[10:21:21.668]                           for (restart in restarts) {
[10:21:21.668]                             name <- restart$name
[10:21:21.668]                             if (is.null(name)) 
[10:21:21.668]                               next
[10:21:21.668]                             if (!grepl(pattern, name)) 
[10:21:21.668]                               next
[10:21:21.668]                             invokeRestart(restart)
[10:21:21.668]                             muffled <- TRUE
[10:21:21.668]                             break
[10:21:21.668]                           }
[10:21:21.668]                         }
[10:21:21.668]                       }
[10:21:21.668]                       invisible(muffled)
[10:21:21.668]                     }
[10:21:21.668]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.668]                   }
[10:21:21.668]                 }
[10:21:21.668]             }
[10:21:21.668]         }))
[10:21:21.668]     }, error = function(ex) {
[10:21:21.668]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.668]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.668]                 ...future.rng), started = ...future.startTime, 
[10:21:21.668]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.668]             version = "1.8"), class = "FutureResult")
[10:21:21.668]     }, finally = {
[10:21:21.668]         if (!identical(...future.workdir, getwd())) 
[10:21:21.668]             setwd(...future.workdir)
[10:21:21.668]         {
[10:21:21.668]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.668]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.668]             }
[10:21:21.668]             base::options(...future.oldOptions)
[10:21:21.668]             if (.Platform$OS.type == "windows") {
[10:21:21.668]                 old_names <- names(...future.oldEnvVars)
[10:21:21.668]                 envs <- base::Sys.getenv()
[10:21:21.668]                 names <- names(envs)
[10:21:21.668]                 common <- intersect(names, old_names)
[10:21:21.668]                 added <- setdiff(names, old_names)
[10:21:21.668]                 removed <- setdiff(old_names, names)
[10:21:21.668]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.668]                   envs[common]]
[10:21:21.668]                 NAMES <- toupper(changed)
[10:21:21.668]                 args <- list()
[10:21:21.668]                 for (kk in seq_along(NAMES)) {
[10:21:21.668]                   name <- changed[[kk]]
[10:21:21.668]                   NAME <- NAMES[[kk]]
[10:21:21.668]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.668]                     next
[10:21:21.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.668]                 }
[10:21:21.668]                 NAMES <- toupper(added)
[10:21:21.668]                 for (kk in seq_along(NAMES)) {
[10:21:21.668]                   name <- added[[kk]]
[10:21:21.668]                   NAME <- NAMES[[kk]]
[10:21:21.668]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.668]                     next
[10:21:21.668]                   args[[name]] <- ""
[10:21:21.668]                 }
[10:21:21.668]                 NAMES <- toupper(removed)
[10:21:21.668]                 for (kk in seq_along(NAMES)) {
[10:21:21.668]                   name <- removed[[kk]]
[10:21:21.668]                   NAME <- NAMES[[kk]]
[10:21:21.668]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.668]                     next
[10:21:21.668]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.668]                 }
[10:21:21.668]                 if (length(args) > 0) 
[10:21:21.668]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.668]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.668]             }
[10:21:21.668]             else {
[10:21:21.668]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.668]             }
[10:21:21.668]             {
[10:21:21.668]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.668]                   0L) {
[10:21:21.668]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.668]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.668]                   base::options(opts)
[10:21:21.668]                 }
[10:21:21.668]                 {
[10:21:21.668]                   {
[10:21:21.668]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.668]                     NULL
[10:21:21.668]                   }
[10:21:21.668]                   options(future.plan = NULL)
[10:21:21.668]                   if (is.na(NA_character_)) 
[10:21:21.668]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.668]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.668]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.668]                     .init = FALSE)
[10:21:21.668]                 }
[10:21:21.668]             }
[10:21:21.668]         }
[10:21:21.668]     })
[10:21:21.668]     if (TRUE) {
[10:21:21.668]         base::sink(type = "output", split = FALSE)
[10:21:21.668]         if (TRUE) {
[10:21:21.668]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.668]         }
[10:21:21.668]         else {
[10:21:21.668]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.668]         }
[10:21:21.668]         base::close(...future.stdout)
[10:21:21.668]         ...future.stdout <- NULL
[10:21:21.668]     }
[10:21:21.668]     ...future.result$conditions <- ...future.conditions
[10:21:21.668]     ...future.result$finished <- base::Sys.time()
[10:21:21.668]     ...future.result
[10:21:21.668] }
[10:21:21.671] requestCore(): workers = 2
[10:21:21.673] MulticoreFuture started
[10:21:21.673] - Launch lazy future ... done
[10:21:21.674] run() for ‘MulticoreFuture’ ... done
[10:21:21.674] getGlobalsAndPackages() ...
[10:21:21.674] Searching for globals...
[10:21:21.674] plan(): Setting new future strategy stack:
[10:21:21.675] 
[10:21:21.675] Searching for globals ... DONE
[10:21:21.675] - globals: [0] <none>
[10:21:21.674] List of future strategies:
[10:21:21.674] 1. sequential:
[10:21:21.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.674]    - tweaked: FALSE
[10:21:21.674]    - call: NULL
[10:21:21.675] getGlobalsAndPackages() ... DONE
[10:21:21.675] plan(): nbrOfWorkers() = 1
[10:21:21.676] run() for ‘Future’ ...
[10:21:21.676] - state: ‘created’
[10:21:21.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.677] plan(): Setting new future strategy stack:
[10:21:21.677] List of future strategies:
[10:21:21.677] 1. multicore:
[10:21:21.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.677]    - tweaked: FALSE
[10:21:21.677]    - call: plan(strategy)
[10:21:21.679] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.680] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.680] plan(): nbrOfWorkers() = 2
[10:21:21.680]   - Field: ‘label’
[10:21:21.680]   - Field: ‘local’
[10:21:21.680]   - Field: ‘owner’
[10:21:21.680]   - Field: ‘envir’
[10:21:21.680]   - Field: ‘workers’
[10:21:21.680]   - Field: ‘packages’
[10:21:21.681]   - Field: ‘gc’
[10:21:21.681]   - Field: ‘job’
[10:21:21.681]   - Field: ‘conditions’
[10:21:21.681]   - Field: ‘expr’
[10:21:21.681]   - Field: ‘uuid’
[10:21:21.681]   - Field: ‘seed’
[10:21:21.681]   - Field: ‘version’
[10:21:21.681]   - Field: ‘result’
[10:21:21.682]   - Field: ‘asynchronous’
[10:21:21.682]   - Field: ‘calls’
[10:21:21.682]   - Field: ‘globals’
[10:21:21.682]   - Field: ‘stdout’
[10:21:21.682]   - Field: ‘earlySignal’
[10:21:21.682]   - Field: ‘lazy’
[10:21:21.682]   - Field: ‘state’
[10:21:21.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.683] - Launch lazy future ...
[10:21:21.683] Packages needed by the future expression (n = 0): <none>
[10:21:21.683] Packages needed by future strategies (n = 0): <none>
[10:21:21.684] {
[10:21:21.684]     {
[10:21:21.684]         {
[10:21:21.684]             ...future.startTime <- base::Sys.time()
[10:21:21.684]             {
[10:21:21.684]                 {
[10:21:21.684]                   {
[10:21:21.684]                     {
[10:21:21.684]                       base::local({
[10:21:21.684]                         has_future <- base::requireNamespace("future", 
[10:21:21.684]                           quietly = TRUE)
[10:21:21.684]                         if (has_future) {
[10:21:21.684]                           ns <- base::getNamespace("future")
[10:21:21.684]                           version <- ns[[".package"]][["version"]]
[10:21:21.684]                           if (is.null(version)) 
[10:21:21.684]                             version <- utils::packageVersion("future")
[10:21:21.684]                         }
[10:21:21.684]                         else {
[10:21:21.684]                           version <- NULL
[10:21:21.684]                         }
[10:21:21.684]                         if (!has_future || version < "1.8.0") {
[10:21:21.684]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.684]                             "", base::R.version$version.string), 
[10:21:21.684]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.684]                               "release", "version")], collapse = " "), 
[10:21:21.684]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.684]                             info)
[10:21:21.684]                           info <- base::paste(info, collapse = "; ")
[10:21:21.684]                           if (!has_future) {
[10:21:21.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.684]                               info)
[10:21:21.684]                           }
[10:21:21.684]                           else {
[10:21:21.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.684]                               info, version)
[10:21:21.684]                           }
[10:21:21.684]                           base::stop(msg)
[10:21:21.684]                         }
[10:21:21.684]                       })
[10:21:21.684]                     }
[10:21:21.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.684]                     base::options(mc.cores = 1L)
[10:21:21.684]                   }
[10:21:21.684]                   ...future.strategy.old <- future::plan("list")
[10:21:21.684]                   options(future.plan = NULL)
[10:21:21.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.684]                 }
[10:21:21.684]                 ...future.workdir <- getwd()
[10:21:21.684]             }
[10:21:21.684]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.684]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.684]         }
[10:21:21.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.684]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.684]             base::names(...future.oldOptions))
[10:21:21.684]     }
[10:21:21.684]     if (FALSE) {
[10:21:21.684]     }
[10:21:21.684]     else {
[10:21:21.684]         if (TRUE) {
[10:21:21.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.684]                 open = "w")
[10:21:21.684]         }
[10:21:21.684]         else {
[10:21:21.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.684]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.684]         }
[10:21:21.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.684]             base::sink(type = "output", split = FALSE)
[10:21:21.684]             base::close(...future.stdout)
[10:21:21.684]         }, add = TRUE)
[10:21:21.684]     }
[10:21:21.684]     ...future.frame <- base::sys.nframe()
[10:21:21.684]     ...future.conditions <- base::list()
[10:21:21.684]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.684]     if (FALSE) {
[10:21:21.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.684]     }
[10:21:21.684]     ...future.result <- base::tryCatch({
[10:21:21.684]         base::withCallingHandlers({
[10:21:21.684]             ...future.value <- base::withVisible(base::local({
[10:21:21.684]                 withCallingHandlers({
[10:21:21.684]                   NULL
[10:21:21.684]                 }, immediateCondition = function(cond) {
[10:21:21.684]                   save_rds <- function (object, pathname, ...) 
[10:21:21.684]                   {
[10:21:21.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.684]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.684]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.684]                         fi_tmp[["mtime"]])
[10:21:21.684]                     }
[10:21:21.684]                     tryCatch({
[10:21:21.684]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.684]                     }, error = function(ex) {
[10:21:21.684]                       msg <- conditionMessage(ex)
[10:21:21.684]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.684]                         fi_tmp[["mtime"]], msg)
[10:21:21.684]                       ex$message <- msg
[10:21:21.684]                       stop(ex)
[10:21:21.684]                     })
[10:21:21.684]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.684]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.684]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.684]                       fi <- file.info(pathname)
[10:21:21.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.684]                         fi[["size"]], fi[["mtime"]])
[10:21:21.684]                       stop(msg)
[10:21:21.684]                     }
[10:21:21.684]                     invisible(pathname)
[10:21:21.684]                   }
[10:21:21.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.684]                     rootPath = tempdir()) 
[10:21:21.684]                   {
[10:21:21.684]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.684]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.684]                       tmpdir = path, fileext = ".rds")
[10:21:21.684]                     save_rds(obj, file)
[10:21:21.684]                   }
[10:21:21.684]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.684]                   {
[10:21:21.684]                     inherits <- base::inherits
[10:21:21.684]                     invokeRestart <- base::invokeRestart
[10:21:21.684]                     is.null <- base::is.null
[10:21:21.684]                     muffled <- FALSE
[10:21:21.684]                     if (inherits(cond, "message")) {
[10:21:21.684]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.684]                       if (muffled) 
[10:21:21.684]                         invokeRestart("muffleMessage")
[10:21:21.684]                     }
[10:21:21.684]                     else if (inherits(cond, "warning")) {
[10:21:21.684]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.684]                       if (muffled) 
[10:21:21.684]                         invokeRestart("muffleWarning")
[10:21:21.684]                     }
[10:21:21.684]                     else if (inherits(cond, "condition")) {
[10:21:21.684]                       if (!is.null(pattern)) {
[10:21:21.684]                         computeRestarts <- base::computeRestarts
[10:21:21.684]                         grepl <- base::grepl
[10:21:21.684]                         restarts <- computeRestarts(cond)
[10:21:21.684]                         for (restart in restarts) {
[10:21:21.684]                           name <- restart$name
[10:21:21.684]                           if (is.null(name)) 
[10:21:21.684]                             next
[10:21:21.684]                           if (!grepl(pattern, name)) 
[10:21:21.684]                             next
[10:21:21.684]                           invokeRestart(restart)
[10:21:21.684]                           muffled <- TRUE
[10:21:21.684]                           break
[10:21:21.684]                         }
[10:21:21.684]                       }
[10:21:21.684]                     }
[10:21:21.684]                     invisible(muffled)
[10:21:21.684]                   }
[10:21:21.684]                   muffleCondition(cond)
[10:21:21.684]                 })
[10:21:21.684]             }))
[10:21:21.684]             future::FutureResult(value = ...future.value$value, 
[10:21:21.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.684]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.684]                     ...future.globalenv.names))
[10:21:21.684]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.684]         }, condition = base::local({
[10:21:21.684]             c <- base::c
[10:21:21.684]             inherits <- base::inherits
[10:21:21.684]             invokeRestart <- base::invokeRestart
[10:21:21.684]             length <- base::length
[10:21:21.684]             list <- base::list
[10:21:21.684]             seq.int <- base::seq.int
[10:21:21.684]             signalCondition <- base::signalCondition
[10:21:21.684]             sys.calls <- base::sys.calls
[10:21:21.684]             `[[` <- base::`[[`
[10:21:21.684]             `+` <- base::`+`
[10:21:21.684]             `<<-` <- base::`<<-`
[10:21:21.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.684]                   3L)]
[10:21:21.684]             }
[10:21:21.684]             function(cond) {
[10:21:21.684]                 is_error <- inherits(cond, "error")
[10:21:21.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.684]                   NULL)
[10:21:21.684]                 if (is_error) {
[10:21:21.684]                   sessionInformation <- function() {
[10:21:21.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.684]                       search = base::search(), system = base::Sys.info())
[10:21:21.684]                   }
[10:21:21.684]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.684]                     cond$call), session = sessionInformation(), 
[10:21:21.684]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.684]                   signalCondition(cond)
[10:21:21.684]                 }
[10:21:21.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.684]                 "immediateCondition"))) {
[10:21:21.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.684]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.684]                   if (TRUE && !signal) {
[10:21:21.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.684]                     {
[10:21:21.684]                       inherits <- base::inherits
[10:21:21.684]                       invokeRestart <- base::invokeRestart
[10:21:21.684]                       is.null <- base::is.null
[10:21:21.684]                       muffled <- FALSE
[10:21:21.684]                       if (inherits(cond, "message")) {
[10:21:21.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.684]                         if (muffled) 
[10:21:21.684]                           invokeRestart("muffleMessage")
[10:21:21.684]                       }
[10:21:21.684]                       else if (inherits(cond, "warning")) {
[10:21:21.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.684]                         if (muffled) 
[10:21:21.684]                           invokeRestart("muffleWarning")
[10:21:21.684]                       }
[10:21:21.684]                       else if (inherits(cond, "condition")) {
[10:21:21.684]                         if (!is.null(pattern)) {
[10:21:21.684]                           computeRestarts <- base::computeRestarts
[10:21:21.684]                           grepl <- base::grepl
[10:21:21.684]                           restarts <- computeRestarts(cond)
[10:21:21.684]                           for (restart in restarts) {
[10:21:21.684]                             name <- restart$name
[10:21:21.684]                             if (is.null(name)) 
[10:21:21.684]                               next
[10:21:21.684]                             if (!grepl(pattern, name)) 
[10:21:21.684]                               next
[10:21:21.684]                             invokeRestart(restart)
[10:21:21.684]                             muffled <- TRUE
[10:21:21.684]                             break
[10:21:21.684]                           }
[10:21:21.684]                         }
[10:21:21.684]                       }
[10:21:21.684]                       invisible(muffled)
[10:21:21.684]                     }
[10:21:21.684]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.684]                   }
[10:21:21.684]                 }
[10:21:21.684]                 else {
[10:21:21.684]                   if (TRUE) {
[10:21:21.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.684]                     {
[10:21:21.684]                       inherits <- base::inherits
[10:21:21.684]                       invokeRestart <- base::invokeRestart
[10:21:21.684]                       is.null <- base::is.null
[10:21:21.684]                       muffled <- FALSE
[10:21:21.684]                       if (inherits(cond, "message")) {
[10:21:21.684]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.684]                         if (muffled) 
[10:21:21.684]                           invokeRestart("muffleMessage")
[10:21:21.684]                       }
[10:21:21.684]                       else if (inherits(cond, "warning")) {
[10:21:21.684]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.684]                         if (muffled) 
[10:21:21.684]                           invokeRestart("muffleWarning")
[10:21:21.684]                       }
[10:21:21.684]                       else if (inherits(cond, "condition")) {
[10:21:21.684]                         if (!is.null(pattern)) {
[10:21:21.684]                           computeRestarts <- base::computeRestarts
[10:21:21.684]                           grepl <- base::grepl
[10:21:21.684]                           restarts <- computeRestarts(cond)
[10:21:21.684]                           for (restart in restarts) {
[10:21:21.684]                             name <- restart$name
[10:21:21.684]                             if (is.null(name)) 
[10:21:21.684]                               next
[10:21:21.684]                             if (!grepl(pattern, name)) 
[10:21:21.684]                               next
[10:21:21.684]                             invokeRestart(restart)
[10:21:21.684]                             muffled <- TRUE
[10:21:21.684]                             break
[10:21:21.684]                           }
[10:21:21.684]                         }
[10:21:21.684]                       }
[10:21:21.684]                       invisible(muffled)
[10:21:21.684]                     }
[10:21:21.684]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.684]                   }
[10:21:21.684]                 }
[10:21:21.684]             }
[10:21:21.684]         }))
[10:21:21.684]     }, error = function(ex) {
[10:21:21.684]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.684]                 ...future.rng), started = ...future.startTime, 
[10:21:21.684]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.684]             version = "1.8"), class = "FutureResult")
[10:21:21.684]     }, finally = {
[10:21:21.684]         if (!identical(...future.workdir, getwd())) 
[10:21:21.684]             setwd(...future.workdir)
[10:21:21.684]         {
[10:21:21.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.684]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.684]             }
[10:21:21.684]             base::options(...future.oldOptions)
[10:21:21.684]             if (.Platform$OS.type == "windows") {
[10:21:21.684]                 old_names <- names(...future.oldEnvVars)
[10:21:21.684]                 envs <- base::Sys.getenv()
[10:21:21.684]                 names <- names(envs)
[10:21:21.684]                 common <- intersect(names, old_names)
[10:21:21.684]                 added <- setdiff(names, old_names)
[10:21:21.684]                 removed <- setdiff(old_names, names)
[10:21:21.684]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.684]                   envs[common]]
[10:21:21.684]                 NAMES <- toupper(changed)
[10:21:21.684]                 args <- list()
[10:21:21.684]                 for (kk in seq_along(NAMES)) {
[10:21:21.684]                   name <- changed[[kk]]
[10:21:21.684]                   NAME <- NAMES[[kk]]
[10:21:21.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.684]                     next
[10:21:21.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.684]                 }
[10:21:21.684]                 NAMES <- toupper(added)
[10:21:21.684]                 for (kk in seq_along(NAMES)) {
[10:21:21.684]                   name <- added[[kk]]
[10:21:21.684]                   NAME <- NAMES[[kk]]
[10:21:21.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.684]                     next
[10:21:21.684]                   args[[name]] <- ""
[10:21:21.684]                 }
[10:21:21.684]                 NAMES <- toupper(removed)
[10:21:21.684]                 for (kk in seq_along(NAMES)) {
[10:21:21.684]                   name <- removed[[kk]]
[10:21:21.684]                   NAME <- NAMES[[kk]]
[10:21:21.684]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.684]                     next
[10:21:21.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.684]                 }
[10:21:21.684]                 if (length(args) > 0) 
[10:21:21.684]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.684]             }
[10:21:21.684]             else {
[10:21:21.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.684]             }
[10:21:21.684]             {
[10:21:21.684]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.684]                   0L) {
[10:21:21.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.684]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.684]                   base::options(opts)
[10:21:21.684]                 }
[10:21:21.684]                 {
[10:21:21.684]                   {
[10:21:21.684]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.684]                     NULL
[10:21:21.684]                   }
[10:21:21.684]                   options(future.plan = NULL)
[10:21:21.684]                   if (is.na(NA_character_)) 
[10:21:21.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.684]                     .init = FALSE)
[10:21:21.684]                 }
[10:21:21.684]             }
[10:21:21.684]         }
[10:21:21.684]     })
[10:21:21.684]     if (TRUE) {
[10:21:21.684]         base::sink(type = "output", split = FALSE)
[10:21:21.684]         if (TRUE) {
[10:21:21.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.684]         }
[10:21:21.684]         else {
[10:21:21.684]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.684]         }
[10:21:21.684]         base::close(...future.stdout)
[10:21:21.684]         ...future.stdout <- NULL
[10:21:21.684]     }
[10:21:21.684]     ...future.result$conditions <- ...future.conditions
[10:21:21.684]     ...future.result$finished <- base::Sys.time()
[10:21:21.684]     ...future.result
[10:21:21.684] }
[10:21:21.687] requestCore(): workers = 2
[10:21:21.689] MulticoreFuture started
[10:21:21.690] - Launch lazy future ... done
[10:21:21.690] run() for ‘MulticoreFuture’ ... done
[10:21:21.690] plan(): Setting new future strategy stack:
[10:21:21.691] getGlobalsAndPackages() ...
[10:21:21.691] Searching for globals...
[10:21:21.691] List of future strategies:
[10:21:21.691] 1. sequential:
[10:21:21.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.691]    - tweaked: FALSE
[10:21:21.691]    - call: NULL
[10:21:21.692] plan(): nbrOfWorkers() = 1
[10:21:21.692] - globals found: [1] ‘{’
[10:21:21.692] Searching for globals ... DONE
[10:21:21.693] Resolving globals: FALSE
[10:21:21.693] 
[10:21:21.693] 
[10:21:21.693] getGlobalsAndPackages() ... DONE
[10:21:21.694] plan(): Setting new future strategy stack:
[10:21:21.694] run() for ‘Future’ ...
[10:21:21.694] - state: ‘created’
[10:21:21.694] List of future strategies:
[10:21:21.694] 1. multicore:
[10:21:21.694]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.694]    - tweaked: FALSE
[10:21:21.694]    - call: plan(strategy)
[10:21:21.694] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:21.697] plan(): nbrOfWorkers() = 2
[10:21:21.697] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:21.697] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:21.697]   - Field: ‘label’
[10:21:21.697]   - Field: ‘local’
[10:21:21.698]   - Field: ‘owner’
[10:21:21.698]   - Field: ‘envir’
[10:21:21.698]   - Field: ‘workers’
[10:21:21.698]   - Field: ‘packages’
[10:21:21.698]   - Field: ‘gc’
[10:21:21.698]   - Field: ‘job’
[10:21:21.698]   - Field: ‘conditions’
[10:21:21.698]   - Field: ‘expr’
[10:21:21.699]   - Field: ‘uuid’
[10:21:21.699]   - Field: ‘seed’
[10:21:21.699]   - Field: ‘version’
[10:21:21.699]   - Field: ‘result’
[10:21:21.699]   - Field: ‘asynchronous’
[10:21:21.699]   - Field: ‘calls’
[10:21:21.699]   - Field: ‘globals’
[10:21:21.699]   - Field: ‘stdout’
[10:21:21.700]   - Field: ‘earlySignal’
[10:21:21.700]   - Field: ‘lazy’
[10:21:21.700]   - Field: ‘state’
[10:21:21.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:21.700] - Launch lazy future ...
[10:21:21.700] Packages needed by the future expression (n = 0): <none>
[10:21:21.701] Packages needed by future strategies (n = 0): <none>
[10:21:21.701] {
[10:21:21.701]     {
[10:21:21.701]         {
[10:21:21.701]             ...future.startTime <- base::Sys.time()
[10:21:21.701]             {
[10:21:21.701]                 {
[10:21:21.701]                   {
[10:21:21.701]                     {
[10:21:21.701]                       base::local({
[10:21:21.701]                         has_future <- base::requireNamespace("future", 
[10:21:21.701]                           quietly = TRUE)
[10:21:21.701]                         if (has_future) {
[10:21:21.701]                           ns <- base::getNamespace("future")
[10:21:21.701]                           version <- ns[[".package"]][["version"]]
[10:21:21.701]                           if (is.null(version)) 
[10:21:21.701]                             version <- utils::packageVersion("future")
[10:21:21.701]                         }
[10:21:21.701]                         else {
[10:21:21.701]                           version <- NULL
[10:21:21.701]                         }
[10:21:21.701]                         if (!has_future || version < "1.8.0") {
[10:21:21.701]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:21.701]                             "", base::R.version$version.string), 
[10:21:21.701]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:21.701]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:21.701]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:21.701]                               "release", "version")], collapse = " "), 
[10:21:21.701]                             hostname = base::Sys.info()[["nodename"]])
[10:21:21.701]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:21.701]                             info)
[10:21:21.701]                           info <- base::paste(info, collapse = "; ")
[10:21:21.701]                           if (!has_future) {
[10:21:21.701]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:21.701]                               info)
[10:21:21.701]                           }
[10:21:21.701]                           else {
[10:21:21.701]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:21.701]                               info, version)
[10:21:21.701]                           }
[10:21:21.701]                           base::stop(msg)
[10:21:21.701]                         }
[10:21:21.701]                       })
[10:21:21.701]                     }
[10:21:21.701]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:21.701]                     base::options(mc.cores = 1L)
[10:21:21.701]                   }
[10:21:21.701]                   ...future.strategy.old <- future::plan("list")
[10:21:21.701]                   options(future.plan = NULL)
[10:21:21.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:21.701]                 }
[10:21:21.701]                 ...future.workdir <- getwd()
[10:21:21.701]             }
[10:21:21.701]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:21.701]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:21.701]         }
[10:21:21.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:21.701]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:21.701]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:21.701]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:21.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:21.701]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:21.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:21.701]             base::names(...future.oldOptions))
[10:21:21.701]     }
[10:21:21.701]     if (FALSE) {
[10:21:21.701]     }
[10:21:21.701]     else {
[10:21:21.701]         if (TRUE) {
[10:21:21.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:21.701]                 open = "w")
[10:21:21.701]         }
[10:21:21.701]         else {
[10:21:21.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:21.701]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:21.701]         }
[10:21:21.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:21.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:21.701]             base::sink(type = "output", split = FALSE)
[10:21:21.701]             base::close(...future.stdout)
[10:21:21.701]         }, add = TRUE)
[10:21:21.701]     }
[10:21:21.701]     ...future.frame <- base::sys.nframe()
[10:21:21.701]     ...future.conditions <- base::list()
[10:21:21.701]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:21.701]     if (FALSE) {
[10:21:21.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:21.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:21.701]     }
[10:21:21.701]     ...future.result <- base::tryCatch({
[10:21:21.701]         base::withCallingHandlers({
[10:21:21.701]             ...future.value <- base::withVisible(base::local({
[10:21:21.701]                 withCallingHandlers({
[10:21:21.701]                   {
[10:21:21.701]                     4
[10:21:21.701]                   }
[10:21:21.701]                 }, immediateCondition = function(cond) {
[10:21:21.701]                   save_rds <- function (object, pathname, ...) 
[10:21:21.701]                   {
[10:21:21.701]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:21.701]                     if (file_test("-f", pathname_tmp)) {
[10:21:21.701]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.701]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:21.701]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.701]                         fi_tmp[["mtime"]])
[10:21:21.701]                     }
[10:21:21.701]                     tryCatch({
[10:21:21.701]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:21.701]                     }, error = function(ex) {
[10:21:21.701]                       msg <- conditionMessage(ex)
[10:21:21.701]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.701]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:21.701]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.701]                         fi_tmp[["mtime"]], msg)
[10:21:21.701]                       ex$message <- msg
[10:21:21.701]                       stop(ex)
[10:21:21.701]                     })
[10:21:21.701]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:21.701]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:21.701]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:21.701]                       fi_tmp <- file.info(pathname_tmp)
[10:21:21.701]                       fi <- file.info(pathname)
[10:21:21.701]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:21.701]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:21.701]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:21.701]                         fi[["size"]], fi[["mtime"]])
[10:21:21.701]                       stop(msg)
[10:21:21.701]                     }
[10:21:21.701]                     invisible(pathname)
[10:21:21.701]                   }
[10:21:21.701]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:21.701]                     rootPath = tempdir()) 
[10:21:21.701]                   {
[10:21:21.701]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:21.701]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:21.701]                       tmpdir = path, fileext = ".rds")
[10:21:21.701]                     save_rds(obj, file)
[10:21:21.701]                   }
[10:21:21.701]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:21.701]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.701]                   {
[10:21:21.701]                     inherits <- base::inherits
[10:21:21.701]                     invokeRestart <- base::invokeRestart
[10:21:21.701]                     is.null <- base::is.null
[10:21:21.701]                     muffled <- FALSE
[10:21:21.701]                     if (inherits(cond, "message")) {
[10:21:21.701]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:21.701]                       if (muffled) 
[10:21:21.701]                         invokeRestart("muffleMessage")
[10:21:21.701]                     }
[10:21:21.701]                     else if (inherits(cond, "warning")) {
[10:21:21.701]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:21.701]                       if (muffled) 
[10:21:21.701]                         invokeRestart("muffleWarning")
[10:21:21.701]                     }
[10:21:21.701]                     else if (inherits(cond, "condition")) {
[10:21:21.701]                       if (!is.null(pattern)) {
[10:21:21.701]                         computeRestarts <- base::computeRestarts
[10:21:21.701]                         grepl <- base::grepl
[10:21:21.701]                         restarts <- computeRestarts(cond)
[10:21:21.701]                         for (restart in restarts) {
[10:21:21.701]                           name <- restart$name
[10:21:21.701]                           if (is.null(name)) 
[10:21:21.701]                             next
[10:21:21.701]                           if (!grepl(pattern, name)) 
[10:21:21.701]                             next
[10:21:21.701]                           invokeRestart(restart)
[10:21:21.701]                           muffled <- TRUE
[10:21:21.701]                           break
[10:21:21.701]                         }
[10:21:21.701]                       }
[10:21:21.701]                     }
[10:21:21.701]                     invisible(muffled)
[10:21:21.701]                   }
[10:21:21.701]                   muffleCondition(cond)
[10:21:21.701]                 })
[10:21:21.701]             }))
[10:21:21.701]             future::FutureResult(value = ...future.value$value, 
[10:21:21.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.701]                   ...future.rng), globalenv = if (FALSE) 
[10:21:21.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:21.701]                     ...future.globalenv.names))
[10:21:21.701]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:21.701]         }, condition = base::local({
[10:21:21.701]             c <- base::c
[10:21:21.701]             inherits <- base::inherits
[10:21:21.701]             invokeRestart <- base::invokeRestart
[10:21:21.701]             length <- base::length
[10:21:21.701]             list <- base::list
[10:21:21.701]             seq.int <- base::seq.int
[10:21:21.701]             signalCondition <- base::signalCondition
[10:21:21.701]             sys.calls <- base::sys.calls
[10:21:21.701]             `[[` <- base::`[[`
[10:21:21.701]             `+` <- base::`+`
[10:21:21.701]             `<<-` <- base::`<<-`
[10:21:21.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:21.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:21.701]                   3L)]
[10:21:21.701]             }
[10:21:21.701]             function(cond) {
[10:21:21.701]                 is_error <- inherits(cond, "error")
[10:21:21.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:21.701]                   NULL)
[10:21:21.701]                 if (is_error) {
[10:21:21.701]                   sessionInformation <- function() {
[10:21:21.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:21.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:21.701]                       search = base::search(), system = base::Sys.info())
[10:21:21.701]                   }
[10:21:21.701]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:21.701]                     cond$call), session = sessionInformation(), 
[10:21:21.701]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:21.701]                   signalCondition(cond)
[10:21:21.701]                 }
[10:21:21.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:21.701]                 "immediateCondition"))) {
[10:21:21.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:21.701]                   ...future.conditions[[length(...future.conditions) + 
[10:21:21.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:21.701]                   if (TRUE && !signal) {
[10:21:21.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.701]                     {
[10:21:21.701]                       inherits <- base::inherits
[10:21:21.701]                       invokeRestart <- base::invokeRestart
[10:21:21.701]                       is.null <- base::is.null
[10:21:21.701]                       muffled <- FALSE
[10:21:21.701]                       if (inherits(cond, "message")) {
[10:21:21.701]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.701]                         if (muffled) 
[10:21:21.701]                           invokeRestart("muffleMessage")
[10:21:21.701]                       }
[10:21:21.701]                       else if (inherits(cond, "warning")) {
[10:21:21.701]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.701]                         if (muffled) 
[10:21:21.701]                           invokeRestart("muffleWarning")
[10:21:21.701]                       }
[10:21:21.701]                       else if (inherits(cond, "condition")) {
[10:21:21.701]                         if (!is.null(pattern)) {
[10:21:21.701]                           computeRestarts <- base::computeRestarts
[10:21:21.701]                           grepl <- base::grepl
[10:21:21.701]                           restarts <- computeRestarts(cond)
[10:21:21.701]                           for (restart in restarts) {
[10:21:21.701]                             name <- restart$name
[10:21:21.701]                             if (is.null(name)) 
[10:21:21.701]                               next
[10:21:21.701]                             if (!grepl(pattern, name)) 
[10:21:21.701]                               next
[10:21:21.701]                             invokeRestart(restart)
[10:21:21.701]                             muffled <- TRUE
[10:21:21.701]                             break
[10:21:21.701]                           }
[10:21:21.701]                         }
[10:21:21.701]                       }
[10:21:21.701]                       invisible(muffled)
[10:21:21.701]                     }
[10:21:21.701]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.701]                   }
[10:21:21.701]                 }
[10:21:21.701]                 else {
[10:21:21.701]                   if (TRUE) {
[10:21:21.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:21.701]                     {
[10:21:21.701]                       inherits <- base::inherits
[10:21:21.701]                       invokeRestart <- base::invokeRestart
[10:21:21.701]                       is.null <- base::is.null
[10:21:21.701]                       muffled <- FALSE
[10:21:21.701]                       if (inherits(cond, "message")) {
[10:21:21.701]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:21.701]                         if (muffled) 
[10:21:21.701]                           invokeRestart("muffleMessage")
[10:21:21.701]                       }
[10:21:21.701]                       else if (inherits(cond, "warning")) {
[10:21:21.701]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:21.701]                         if (muffled) 
[10:21:21.701]                           invokeRestart("muffleWarning")
[10:21:21.701]                       }
[10:21:21.701]                       else if (inherits(cond, "condition")) {
[10:21:21.701]                         if (!is.null(pattern)) {
[10:21:21.701]                           computeRestarts <- base::computeRestarts
[10:21:21.701]                           grepl <- base::grepl
[10:21:21.701]                           restarts <- computeRestarts(cond)
[10:21:21.701]                           for (restart in restarts) {
[10:21:21.701]                             name <- restart$name
[10:21:21.701]                             if (is.null(name)) 
[10:21:21.701]                               next
[10:21:21.701]                             if (!grepl(pattern, name)) 
[10:21:21.701]                               next
[10:21:21.701]                             invokeRestart(restart)
[10:21:21.701]                             muffled <- TRUE
[10:21:21.701]                             break
[10:21:21.701]                           }
[10:21:21.701]                         }
[10:21:21.701]                       }
[10:21:21.701]                       invisible(muffled)
[10:21:21.701]                     }
[10:21:21.701]                     muffleCondition(cond, pattern = "^muffle")
[10:21:21.701]                   }
[10:21:21.701]                 }
[10:21:21.701]             }
[10:21:21.701]         }))
[10:21:21.701]     }, error = function(ex) {
[10:21:21.701]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:21.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:21.701]                 ...future.rng), started = ...future.startTime, 
[10:21:21.701]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:21.701]             version = "1.8"), class = "FutureResult")
[10:21:21.701]     }, finally = {
[10:21:21.701]         if (!identical(...future.workdir, getwd())) 
[10:21:21.701]             setwd(...future.workdir)
[10:21:21.701]         {
[10:21:21.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:21.701]                 ...future.oldOptions$nwarnings <- NULL
[10:21:21.701]             }
[10:21:21.701]             base::options(...future.oldOptions)
[10:21:21.701]             if (.Platform$OS.type == "windows") {
[10:21:21.701]                 old_names <- names(...future.oldEnvVars)
[10:21:21.701]                 envs <- base::Sys.getenv()
[10:21:21.701]                 names <- names(envs)
[10:21:21.701]                 common <- intersect(names, old_names)
[10:21:21.701]                 added <- setdiff(names, old_names)
[10:21:21.701]                 removed <- setdiff(old_names, names)
[10:21:21.701]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:21.701]                   envs[common]]
[10:21:21.701]                 NAMES <- toupper(changed)
[10:21:21.701]                 args <- list()
[10:21:21.701]                 for (kk in seq_along(NAMES)) {
[10:21:21.701]                   name <- changed[[kk]]
[10:21:21.701]                   NAME <- NAMES[[kk]]
[10:21:21.701]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.701]                     next
[10:21:21.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.701]                 }
[10:21:21.701]                 NAMES <- toupper(added)
[10:21:21.701]                 for (kk in seq_along(NAMES)) {
[10:21:21.701]                   name <- added[[kk]]
[10:21:21.701]                   NAME <- NAMES[[kk]]
[10:21:21.701]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.701]                     next
[10:21:21.701]                   args[[name]] <- ""
[10:21:21.701]                 }
[10:21:21.701]                 NAMES <- toupper(removed)
[10:21:21.701]                 for (kk in seq_along(NAMES)) {
[10:21:21.701]                   name <- removed[[kk]]
[10:21:21.701]                   NAME <- NAMES[[kk]]
[10:21:21.701]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:21.701]                     next
[10:21:21.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:21.701]                 }
[10:21:21.701]                 if (length(args) > 0) 
[10:21:21.701]                   base::do.call(base::Sys.setenv, args = args)
[10:21:21.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:21.701]             }
[10:21:21.701]             else {
[10:21:21.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:21.701]             }
[10:21:21.701]             {
[10:21:21.701]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:21.701]                   0L) {
[10:21:21.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:21.701]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:21.701]                   base::options(opts)
[10:21:21.701]                 }
[10:21:21.701]                 {
[10:21:21.701]                   {
[10:21:21.701]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:21.701]                     NULL
[10:21:21.701]                   }
[10:21:21.701]                   options(future.plan = NULL)
[10:21:21.701]                   if (is.na(NA_character_)) 
[10:21:21.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:21.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:21.701]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:21.701]                     .init = FALSE)
[10:21:21.701]                 }
[10:21:21.701]             }
[10:21:21.701]         }
[10:21:21.701]     })
[10:21:21.701]     if (TRUE) {
[10:21:21.701]         base::sink(type = "output", split = FALSE)
[10:21:21.701]         if (TRUE) {
[10:21:21.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:21.701]         }
[10:21:21.701]         else {
[10:21:21.701]             ...future.result["stdout"] <- base::list(NULL)
[10:21:21.701]         }
[10:21:21.701]         base::close(...future.stdout)
[10:21:21.701]         ...future.stdout <- NULL
[10:21:21.701]     }
[10:21:21.701]     ...future.result$conditions <- ...future.conditions
[10:21:21.701]     ...future.result$finished <- base::Sys.time()
[10:21:21.701]     ...future.result
[10:21:21.701] }
[10:21:21.704] requestCore(): workers = 2
[10:21:21.705] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:21.715] result() for MulticoreFuture ...
[10:21:21.716] result() for MulticoreFuture ...
[10:21:21.717] result() for MulticoreFuture ... done
[10:21:21.717] result() for MulticoreFuture ... done
[10:21:21.717] result() for MulticoreFuture ...
[10:21:21.717] result() for MulticoreFuture ... done
[10:21:21.720] MulticoreFuture started
[10:21:21.720] - Launch lazy future ... done
[10:21:21.720] run() for ‘MulticoreFuture’ ... done
[10:21:21.721] plan(): Setting new future strategy stack:
<environment: 0x55e8e6626460> 
[10:21:21.721] List of future strategies:
[10:21:21.721] 1. sequential:
[10:21:21.721]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:21.721]    - tweaked: FALSE
[10:21:21.721]    - call: NULL
[10:21:21.722] plan(): nbrOfWorkers() = 1
<environment: 0x55e8e6fdf270> 
[10:21:21.725] plan(): Setting new future strategy stack:
[10:21:21.725] List of future strategies:
[10:21:21.725] 1. multicore:
[10:21:21.725]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:21.725]    - tweaked: FALSE
[10:21:21.725]    - call: plan(strategy)
[10:21:21.728] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:21.731] resolve() on environment ...
[10:21:21.731]  recursive: 0
[10:21:21.731]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:21.732] signalConditionsASAP(numeric, pos=1) ...
[10:21:21.732] - nx: 4
[10:21:21.732] - relay: TRUE
[10:21:21.732] - stdout: TRUE
[10:21:21.732] - signal: TRUE
[10:21:21.732] - resignal: FALSE
[10:21:21.732] - force: TRUE
[10:21:21.732] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.733] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.733]  - until=2
[10:21:21.733]  - relaying element #2
[10:21:21.733] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.733] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.733] signalConditionsASAP(NULL, pos=1) ... done
[10:21:21.733]  length: 3 (resolved future 1)
[10:21:21.733] Future #2
[10:21:21.734] result() for MulticoreFuture ...
[10:21:21.734] result() for MulticoreFuture ... done
[10:21:21.734] result() for MulticoreFuture ...
[10:21:21.734] result() for MulticoreFuture ... done
[10:21:21.734] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:21.734] - nx: 4
[10:21:21.734] - relay: TRUE
[10:21:21.735] - stdout: TRUE
[10:21:21.735] - signal: TRUE
[10:21:21.735] - resignal: FALSE
[10:21:21.735] - force: TRUE
[10:21:21.735] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:21.735] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:21.735]  - until=2
[10:21:21.735]  - relaying element #2
[10:21:21.735] result() for MulticoreFuture ...
[10:21:21.736] result() for MulticoreFuture ... done
[10:21:21.736] result() for MulticoreFuture ...
[10:21:21.736] result() for MulticoreFuture ... done
[10:21:21.736] result() for MulticoreFuture ...
[10:21:21.736] result() for MulticoreFuture ... done
[10:21:21.736] result() for MulticoreFuture ...
[10:21:21.736] result() for MulticoreFuture ... done
[10:21:21.736] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.736] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.737] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:21.737]  length: 2 (resolved future 2)
[10:21:21.737] Future #3
[10:21:21.737] result() for MulticoreFuture ...
[10:21:21.738] result() for MulticoreFuture ...
[10:21:21.738] result() for MulticoreFuture ... done
[10:21:21.738] result() for MulticoreFuture ... done
[10:21:21.738] result() for MulticoreFuture ...
[10:21:21.739] result() for MulticoreFuture ... done
[10:21:21.739] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:21.739] - nx: 4
[10:21:21.739] - relay: TRUE
[10:21:21.739] - stdout: TRUE
[10:21:21.739] - signal: TRUE
[10:21:21.739] - resignal: FALSE
[10:21:21.739] - force: TRUE
[10:21:21.739] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:21.740] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:21.740]  - until=3
[10:21:21.740]  - relaying element #3
[10:21:21.740] result() for MulticoreFuture ...
[10:21:21.740] result() for MulticoreFuture ... done
[10:21:21.740] result() for MulticoreFuture ...
[10:21:21.740] result() for MulticoreFuture ... done
[10:21:21.741] result() for MulticoreFuture ...
[10:21:21.741] result() for MulticoreFuture ... done
[10:21:21.741] result() for MulticoreFuture ...
[10:21:21.741] result() for MulticoreFuture ... done
[10:21:21.741] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.741] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.741] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:21.741]  length: 1 (resolved future 3)
[10:21:21.742] Future #4
[10:21:21.742] result() for MulticoreFuture ...
[10:21:21.743] result() for MulticoreFuture ...
[10:21:21.743] result() for MulticoreFuture ... done
[10:21:21.743] result() for MulticoreFuture ... done
[10:21:21.743] result() for MulticoreFuture ...
[10:21:21.743] result() for MulticoreFuture ... done
[10:21:21.743] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:21.744] - nx: 4
[10:21:21.744] - relay: TRUE
[10:21:21.744] - stdout: TRUE
[10:21:21.744] - signal: TRUE
[10:21:21.744] - resignal: FALSE
[10:21:21.744] - force: TRUE
[10:21:21.745] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:21.745] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:21.745]  - until=4
[10:21:21.745]  - relaying element #4
[10:21:21.745] result() for MulticoreFuture ...
[10:21:21.745] result() for MulticoreFuture ... done
[10:21:21.746] result() for MulticoreFuture ...
[10:21:21.746] result() for MulticoreFuture ... done
[10:21:21.746] result() for MulticoreFuture ...
[10:21:21.746] result() for MulticoreFuture ... done
[10:21:21.746] result() for MulticoreFuture ...
[10:21:21.746] result() for MulticoreFuture ... done
[10:21:21.747] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.747] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.747] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:21.751]  length: 0 (resolved future 4)
[10:21:21.751] Relaying remaining futures
[10:21:21.751] signalConditionsASAP(NULL, pos=0) ...
[10:21:21.751] - nx: 4
[10:21:21.752] - relay: TRUE
[10:21:21.752] - stdout: TRUE
[10:21:21.752] - signal: TRUE
[10:21:21.752] - resignal: FALSE
[10:21:21.752] - force: TRUE
[10:21:21.752] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.752] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:21.752] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:21.752] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:21.752] signalConditionsASAP(NULL, pos=0) ... done
[10:21:21.753] resolve() on environment ... DONE
[10:21:21.753] result() for MulticoreFuture ...
[10:21:21.753] result() for MulticoreFuture ... done
[10:21:21.753] result() for MulticoreFuture ...
[10:21:21.753] result() for MulticoreFuture ... done
[10:21:21.753] result() for MulticoreFuture ...
[10:21:21.753] result() for MulticoreFuture ... done
[10:21:21.753] result() for MulticoreFuture ...
[10:21:21.753] result() for MulticoreFuture ... done
[10:21:21.754] result() for MulticoreFuture ...
[10:21:21.754] result() for MulticoreFuture ... done
[10:21:21.754] result() for MulticoreFuture ...
[10:21:21.754] result() for MulticoreFuture ... done
<environment: 0x55e8e7143ff8> 
Type of future: multisession
[10:21:21.754] plan(): Setting new future strategy stack:
[10:21:21.755] List of future strategies:
[10:21:21.755] 1. multisession:
[10:21:21.755]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:21.755]    - tweaked: FALSE
[10:21:21.755]    - call: plan(strategy)
[10:21:21.755] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:21.755] multisession:
[10:21:21.755] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:21.755] - tweaked: FALSE
[10:21:21.755] - call: plan(strategy)
[10:21:21.757] getGlobalsAndPackages() ...
[10:21:21.757] Not searching for globals
[10:21:21.757] - globals: [0] <none>
[10:21:21.757] getGlobalsAndPackages() ... DONE
[10:21:22.020] Packages needed by the future expression (n = 0): <none>
[10:21:22.020] Packages needed by future strategies (n = 0): <none>
[10:21:22.021] {
[10:21:22.021]     {
[10:21:22.021]         {
[10:21:22.021]             ...future.startTime <- base::Sys.time()
[10:21:22.021]             {
[10:21:22.021]                 {
[10:21:22.021]                   {
[10:21:22.021]                     {
[10:21:22.021]                       base::local({
[10:21:22.021]                         has_future <- base::requireNamespace("future", 
[10:21:22.021]                           quietly = TRUE)
[10:21:22.021]                         if (has_future) {
[10:21:22.021]                           ns <- base::getNamespace("future")
[10:21:22.021]                           version <- ns[[".package"]][["version"]]
[10:21:22.021]                           if (is.null(version)) 
[10:21:22.021]                             version <- utils::packageVersion("future")
[10:21:22.021]                         }
[10:21:22.021]                         else {
[10:21:22.021]                           version <- NULL
[10:21:22.021]                         }
[10:21:22.021]                         if (!has_future || version < "1.8.0") {
[10:21:22.021]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.021]                             "", base::R.version$version.string), 
[10:21:22.021]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.021]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.021]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.021]                               "release", "version")], collapse = " "), 
[10:21:22.021]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.021]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.021]                             info)
[10:21:22.021]                           info <- base::paste(info, collapse = "; ")
[10:21:22.021]                           if (!has_future) {
[10:21:22.021]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.021]                               info)
[10:21:22.021]                           }
[10:21:22.021]                           else {
[10:21:22.021]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.021]                               info, version)
[10:21:22.021]                           }
[10:21:22.021]                           base::stop(msg)
[10:21:22.021]                         }
[10:21:22.021]                       })
[10:21:22.021]                     }
[10:21:22.021]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.021]                     base::options(mc.cores = 1L)
[10:21:22.021]                   }
[10:21:22.021]                   ...future.strategy.old <- future::plan("list")
[10:21:22.021]                   options(future.plan = NULL)
[10:21:22.021]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.021]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.021]                 }
[10:21:22.021]                 ...future.workdir <- getwd()
[10:21:22.021]             }
[10:21:22.021]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.021]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.021]         }
[10:21:22.021]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.021]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.021]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.021]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.021]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.021]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.021]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.021]             base::names(...future.oldOptions))
[10:21:22.021]     }
[10:21:22.021]     if (FALSE) {
[10:21:22.021]     }
[10:21:22.021]     else {
[10:21:22.021]         if (TRUE) {
[10:21:22.021]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.021]                 open = "w")
[10:21:22.021]         }
[10:21:22.021]         else {
[10:21:22.021]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.021]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.021]         }
[10:21:22.021]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.021]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.021]             base::sink(type = "output", split = FALSE)
[10:21:22.021]             base::close(...future.stdout)
[10:21:22.021]         }, add = TRUE)
[10:21:22.021]     }
[10:21:22.021]     ...future.frame <- base::sys.nframe()
[10:21:22.021]     ...future.conditions <- base::list()
[10:21:22.021]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.021]     if (FALSE) {
[10:21:22.021]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.021]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.021]     }
[10:21:22.021]     ...future.result <- base::tryCatch({
[10:21:22.021]         base::withCallingHandlers({
[10:21:22.021]             ...future.value <- base::withVisible(base::local({
[10:21:22.021]                 ...future.makeSendCondition <- base::local({
[10:21:22.021]                   sendCondition <- NULL
[10:21:22.021]                   function(frame = 1L) {
[10:21:22.021]                     if (is.function(sendCondition)) 
[10:21:22.021]                       return(sendCondition)
[10:21:22.021]                     ns <- getNamespace("parallel")
[10:21:22.021]                     if (exists("sendData", mode = "function", 
[10:21:22.021]                       envir = ns)) {
[10:21:22.021]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.021]                         envir = ns)
[10:21:22.021]                       envir <- sys.frame(frame)
[10:21:22.021]                       master <- NULL
[10:21:22.021]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.021]                         !identical(envir, emptyenv())) {
[10:21:22.021]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.021]                           inherits = FALSE)) {
[10:21:22.021]                           master <- get("master", mode = "list", 
[10:21:22.021]                             envir = envir, inherits = FALSE)
[10:21:22.021]                           if (inherits(master, c("SOCKnode", 
[10:21:22.021]                             "SOCK0node"))) {
[10:21:22.021]                             sendCondition <<- function(cond) {
[10:21:22.021]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.021]                                 success = TRUE)
[10:21:22.021]                               parallel_sendData(master, data)
[10:21:22.021]                             }
[10:21:22.021]                             return(sendCondition)
[10:21:22.021]                           }
[10:21:22.021]                         }
[10:21:22.021]                         frame <- frame + 1L
[10:21:22.021]                         envir <- sys.frame(frame)
[10:21:22.021]                       }
[10:21:22.021]                     }
[10:21:22.021]                     sendCondition <<- function(cond) NULL
[10:21:22.021]                   }
[10:21:22.021]                 })
[10:21:22.021]                 withCallingHandlers({
[10:21:22.021]                   NA
[10:21:22.021]                 }, immediateCondition = function(cond) {
[10:21:22.021]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.021]                   sendCondition(cond)
[10:21:22.021]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.021]                   {
[10:21:22.021]                     inherits <- base::inherits
[10:21:22.021]                     invokeRestart <- base::invokeRestart
[10:21:22.021]                     is.null <- base::is.null
[10:21:22.021]                     muffled <- FALSE
[10:21:22.021]                     if (inherits(cond, "message")) {
[10:21:22.021]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.021]                       if (muffled) 
[10:21:22.021]                         invokeRestart("muffleMessage")
[10:21:22.021]                     }
[10:21:22.021]                     else if (inherits(cond, "warning")) {
[10:21:22.021]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.021]                       if (muffled) 
[10:21:22.021]                         invokeRestart("muffleWarning")
[10:21:22.021]                     }
[10:21:22.021]                     else if (inherits(cond, "condition")) {
[10:21:22.021]                       if (!is.null(pattern)) {
[10:21:22.021]                         computeRestarts <- base::computeRestarts
[10:21:22.021]                         grepl <- base::grepl
[10:21:22.021]                         restarts <- computeRestarts(cond)
[10:21:22.021]                         for (restart in restarts) {
[10:21:22.021]                           name <- restart$name
[10:21:22.021]                           if (is.null(name)) 
[10:21:22.021]                             next
[10:21:22.021]                           if (!grepl(pattern, name)) 
[10:21:22.021]                             next
[10:21:22.021]                           invokeRestart(restart)
[10:21:22.021]                           muffled <- TRUE
[10:21:22.021]                           break
[10:21:22.021]                         }
[10:21:22.021]                       }
[10:21:22.021]                     }
[10:21:22.021]                     invisible(muffled)
[10:21:22.021]                   }
[10:21:22.021]                   muffleCondition(cond)
[10:21:22.021]                 })
[10:21:22.021]             }))
[10:21:22.021]             future::FutureResult(value = ...future.value$value, 
[10:21:22.021]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.021]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.021]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.021]                     ...future.globalenv.names))
[10:21:22.021]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.021]         }, condition = base::local({
[10:21:22.021]             c <- base::c
[10:21:22.021]             inherits <- base::inherits
[10:21:22.021]             invokeRestart <- base::invokeRestart
[10:21:22.021]             length <- base::length
[10:21:22.021]             list <- base::list
[10:21:22.021]             seq.int <- base::seq.int
[10:21:22.021]             signalCondition <- base::signalCondition
[10:21:22.021]             sys.calls <- base::sys.calls
[10:21:22.021]             `[[` <- base::`[[`
[10:21:22.021]             `+` <- base::`+`
[10:21:22.021]             `<<-` <- base::`<<-`
[10:21:22.021]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.021]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.021]                   3L)]
[10:21:22.021]             }
[10:21:22.021]             function(cond) {
[10:21:22.021]                 is_error <- inherits(cond, "error")
[10:21:22.021]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.021]                   NULL)
[10:21:22.021]                 if (is_error) {
[10:21:22.021]                   sessionInformation <- function() {
[10:21:22.021]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.021]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.021]                       search = base::search(), system = base::Sys.info())
[10:21:22.021]                   }
[10:21:22.021]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.021]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.021]                     cond$call), session = sessionInformation(), 
[10:21:22.021]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.021]                   signalCondition(cond)
[10:21:22.021]                 }
[10:21:22.021]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.021]                 "immediateCondition"))) {
[10:21:22.021]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.021]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.021]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.021]                   if (TRUE && !signal) {
[10:21:22.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.021]                     {
[10:21:22.021]                       inherits <- base::inherits
[10:21:22.021]                       invokeRestart <- base::invokeRestart
[10:21:22.021]                       is.null <- base::is.null
[10:21:22.021]                       muffled <- FALSE
[10:21:22.021]                       if (inherits(cond, "message")) {
[10:21:22.021]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.021]                         if (muffled) 
[10:21:22.021]                           invokeRestart("muffleMessage")
[10:21:22.021]                       }
[10:21:22.021]                       else if (inherits(cond, "warning")) {
[10:21:22.021]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.021]                         if (muffled) 
[10:21:22.021]                           invokeRestart("muffleWarning")
[10:21:22.021]                       }
[10:21:22.021]                       else if (inherits(cond, "condition")) {
[10:21:22.021]                         if (!is.null(pattern)) {
[10:21:22.021]                           computeRestarts <- base::computeRestarts
[10:21:22.021]                           grepl <- base::grepl
[10:21:22.021]                           restarts <- computeRestarts(cond)
[10:21:22.021]                           for (restart in restarts) {
[10:21:22.021]                             name <- restart$name
[10:21:22.021]                             if (is.null(name)) 
[10:21:22.021]                               next
[10:21:22.021]                             if (!grepl(pattern, name)) 
[10:21:22.021]                               next
[10:21:22.021]                             invokeRestart(restart)
[10:21:22.021]                             muffled <- TRUE
[10:21:22.021]                             break
[10:21:22.021]                           }
[10:21:22.021]                         }
[10:21:22.021]                       }
[10:21:22.021]                       invisible(muffled)
[10:21:22.021]                     }
[10:21:22.021]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.021]                   }
[10:21:22.021]                 }
[10:21:22.021]                 else {
[10:21:22.021]                   if (TRUE) {
[10:21:22.021]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.021]                     {
[10:21:22.021]                       inherits <- base::inherits
[10:21:22.021]                       invokeRestart <- base::invokeRestart
[10:21:22.021]                       is.null <- base::is.null
[10:21:22.021]                       muffled <- FALSE
[10:21:22.021]                       if (inherits(cond, "message")) {
[10:21:22.021]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.021]                         if (muffled) 
[10:21:22.021]                           invokeRestart("muffleMessage")
[10:21:22.021]                       }
[10:21:22.021]                       else if (inherits(cond, "warning")) {
[10:21:22.021]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.021]                         if (muffled) 
[10:21:22.021]                           invokeRestart("muffleWarning")
[10:21:22.021]                       }
[10:21:22.021]                       else if (inherits(cond, "condition")) {
[10:21:22.021]                         if (!is.null(pattern)) {
[10:21:22.021]                           computeRestarts <- base::computeRestarts
[10:21:22.021]                           grepl <- base::grepl
[10:21:22.021]                           restarts <- computeRestarts(cond)
[10:21:22.021]                           for (restart in restarts) {
[10:21:22.021]                             name <- restart$name
[10:21:22.021]                             if (is.null(name)) 
[10:21:22.021]                               next
[10:21:22.021]                             if (!grepl(pattern, name)) 
[10:21:22.021]                               next
[10:21:22.021]                             invokeRestart(restart)
[10:21:22.021]                             muffled <- TRUE
[10:21:22.021]                             break
[10:21:22.021]                           }
[10:21:22.021]                         }
[10:21:22.021]                       }
[10:21:22.021]                       invisible(muffled)
[10:21:22.021]                     }
[10:21:22.021]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.021]                   }
[10:21:22.021]                 }
[10:21:22.021]             }
[10:21:22.021]         }))
[10:21:22.021]     }, error = function(ex) {
[10:21:22.021]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.021]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.021]                 ...future.rng), started = ...future.startTime, 
[10:21:22.021]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.021]             version = "1.8"), class = "FutureResult")
[10:21:22.021]     }, finally = {
[10:21:22.021]         if (!identical(...future.workdir, getwd())) 
[10:21:22.021]             setwd(...future.workdir)
[10:21:22.021]         {
[10:21:22.021]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.021]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.021]             }
[10:21:22.021]             base::options(...future.oldOptions)
[10:21:22.021]             if (.Platform$OS.type == "windows") {
[10:21:22.021]                 old_names <- names(...future.oldEnvVars)
[10:21:22.021]                 envs <- base::Sys.getenv()
[10:21:22.021]                 names <- names(envs)
[10:21:22.021]                 common <- intersect(names, old_names)
[10:21:22.021]                 added <- setdiff(names, old_names)
[10:21:22.021]                 removed <- setdiff(old_names, names)
[10:21:22.021]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.021]                   envs[common]]
[10:21:22.021]                 NAMES <- toupper(changed)
[10:21:22.021]                 args <- list()
[10:21:22.021]                 for (kk in seq_along(NAMES)) {
[10:21:22.021]                   name <- changed[[kk]]
[10:21:22.021]                   NAME <- NAMES[[kk]]
[10:21:22.021]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.021]                     next
[10:21:22.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.021]                 }
[10:21:22.021]                 NAMES <- toupper(added)
[10:21:22.021]                 for (kk in seq_along(NAMES)) {
[10:21:22.021]                   name <- added[[kk]]
[10:21:22.021]                   NAME <- NAMES[[kk]]
[10:21:22.021]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.021]                     next
[10:21:22.021]                   args[[name]] <- ""
[10:21:22.021]                 }
[10:21:22.021]                 NAMES <- toupper(removed)
[10:21:22.021]                 for (kk in seq_along(NAMES)) {
[10:21:22.021]                   name <- removed[[kk]]
[10:21:22.021]                   NAME <- NAMES[[kk]]
[10:21:22.021]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.021]                     next
[10:21:22.021]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.021]                 }
[10:21:22.021]                 if (length(args) > 0) 
[10:21:22.021]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.021]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.021]             }
[10:21:22.021]             else {
[10:21:22.021]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.021]             }
[10:21:22.021]             {
[10:21:22.021]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.021]                   0L) {
[10:21:22.021]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.021]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.021]                   base::options(opts)
[10:21:22.021]                 }
[10:21:22.021]                 {
[10:21:22.021]                   {
[10:21:22.021]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.021]                     NULL
[10:21:22.021]                   }
[10:21:22.021]                   options(future.plan = NULL)
[10:21:22.021]                   if (is.na(NA_character_)) 
[10:21:22.021]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.021]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.021]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.021]                     .init = FALSE)
[10:21:22.021]                 }
[10:21:22.021]             }
[10:21:22.021]         }
[10:21:22.021]     })
[10:21:22.021]     if (TRUE) {
[10:21:22.021]         base::sink(type = "output", split = FALSE)
[10:21:22.021]         if (TRUE) {
[10:21:22.021]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.021]         }
[10:21:22.021]         else {
[10:21:22.021]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.021]         }
[10:21:22.021]         base::close(...future.stdout)
[10:21:22.021]         ...future.stdout <- NULL
[10:21:22.021]     }
[10:21:22.021]     ...future.result$conditions <- ...future.conditions
[10:21:22.021]     ...future.result$finished <- base::Sys.time()
[10:21:22.021]     ...future.result
[10:21:22.021] }
[10:21:22.072] MultisessionFuture started
[10:21:22.073] result() for ClusterFuture ...
[10:21:22.073] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.073] - Validating connection of MultisessionFuture
[10:21:22.104] - received message: FutureResult
[10:21:22.104] - Received FutureResult
[10:21:22.104] - Erased future from FutureRegistry
[10:21:22.104] result() for ClusterFuture ...
[10:21:22.104] - result already collected: FutureResult
[10:21:22.104] result() for ClusterFuture ... done
[10:21:22.105] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.105] result() for ClusterFuture ... done
[10:21:22.105] result() for ClusterFuture ...
[10:21:22.105] - result already collected: FutureResult
[10:21:22.105] result() for ClusterFuture ... done
[10:21:22.105] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:22.107] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:21:22.107] getGlobalsAndPackages() ...
[10:21:22.107] Searching for globals...
[10:21:22.108] 
[10:21:22.108] Searching for globals ... DONE
[10:21:22.108] - globals: [0] <none>
[10:21:22.108] getGlobalsAndPackages() ... DONE
[10:21:22.108] run() for ‘Future’ ...
[10:21:22.108] - state: ‘created’
[10:21:22.109] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.123] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.123] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.123]   - Field: ‘node’
[10:21:22.123]   - Field: ‘label’
[10:21:22.123]   - Field: ‘local’
[10:21:22.124]   - Field: ‘owner’
[10:21:22.124]   - Field: ‘envir’
[10:21:22.124]   - Field: ‘workers’
[10:21:22.124]   - Field: ‘packages’
[10:21:22.124]   - Field: ‘gc’
[10:21:22.124]   - Field: ‘conditions’
[10:21:22.124]   - Field: ‘persistent’
[10:21:22.124]   - Field: ‘expr’
[10:21:22.124]   - Field: ‘uuid’
[10:21:22.125]   - Field: ‘seed’
[10:21:22.125]   - Field: ‘version’
[10:21:22.125]   - Field: ‘result’
[10:21:22.125]   - Field: ‘asynchronous’
[10:21:22.125]   - Field: ‘calls’
[10:21:22.125]   - Field: ‘globals’
[10:21:22.125]   - Field: ‘stdout’
[10:21:22.125]   - Field: ‘earlySignal’
[10:21:22.125]   - Field: ‘lazy’
[10:21:22.126]   - Field: ‘state’
[10:21:22.126] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.126] - Launch lazy future ...
[10:21:22.126] Packages needed by the future expression (n = 0): <none>
[10:21:22.126] Packages needed by future strategies (n = 0): <none>
[10:21:22.127] {
[10:21:22.127]     {
[10:21:22.127]         {
[10:21:22.127]             ...future.startTime <- base::Sys.time()
[10:21:22.127]             {
[10:21:22.127]                 {
[10:21:22.127]                   {
[10:21:22.127]                     {
[10:21:22.127]                       base::local({
[10:21:22.127]                         has_future <- base::requireNamespace("future", 
[10:21:22.127]                           quietly = TRUE)
[10:21:22.127]                         if (has_future) {
[10:21:22.127]                           ns <- base::getNamespace("future")
[10:21:22.127]                           version <- ns[[".package"]][["version"]]
[10:21:22.127]                           if (is.null(version)) 
[10:21:22.127]                             version <- utils::packageVersion("future")
[10:21:22.127]                         }
[10:21:22.127]                         else {
[10:21:22.127]                           version <- NULL
[10:21:22.127]                         }
[10:21:22.127]                         if (!has_future || version < "1.8.0") {
[10:21:22.127]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.127]                             "", base::R.version$version.string), 
[10:21:22.127]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.127]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.127]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.127]                               "release", "version")], collapse = " "), 
[10:21:22.127]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.127]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.127]                             info)
[10:21:22.127]                           info <- base::paste(info, collapse = "; ")
[10:21:22.127]                           if (!has_future) {
[10:21:22.127]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.127]                               info)
[10:21:22.127]                           }
[10:21:22.127]                           else {
[10:21:22.127]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.127]                               info, version)
[10:21:22.127]                           }
[10:21:22.127]                           base::stop(msg)
[10:21:22.127]                         }
[10:21:22.127]                       })
[10:21:22.127]                     }
[10:21:22.127]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.127]                     base::options(mc.cores = 1L)
[10:21:22.127]                   }
[10:21:22.127]                   ...future.strategy.old <- future::plan("list")
[10:21:22.127]                   options(future.plan = NULL)
[10:21:22.127]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.127]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.127]                 }
[10:21:22.127]                 ...future.workdir <- getwd()
[10:21:22.127]             }
[10:21:22.127]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.127]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.127]         }
[10:21:22.127]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.127]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.127]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.127]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.127]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.127]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.127]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.127]             base::names(...future.oldOptions))
[10:21:22.127]     }
[10:21:22.127]     if (FALSE) {
[10:21:22.127]     }
[10:21:22.127]     else {
[10:21:22.127]         if (TRUE) {
[10:21:22.127]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.127]                 open = "w")
[10:21:22.127]         }
[10:21:22.127]         else {
[10:21:22.127]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.127]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.127]         }
[10:21:22.127]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.127]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.127]             base::sink(type = "output", split = FALSE)
[10:21:22.127]             base::close(...future.stdout)
[10:21:22.127]         }, add = TRUE)
[10:21:22.127]     }
[10:21:22.127]     ...future.frame <- base::sys.nframe()
[10:21:22.127]     ...future.conditions <- base::list()
[10:21:22.127]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.127]     if (FALSE) {
[10:21:22.127]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.127]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.127]     }
[10:21:22.127]     ...future.result <- base::tryCatch({
[10:21:22.127]         base::withCallingHandlers({
[10:21:22.127]             ...future.value <- base::withVisible(base::local({
[10:21:22.127]                 ...future.makeSendCondition <- base::local({
[10:21:22.127]                   sendCondition <- NULL
[10:21:22.127]                   function(frame = 1L) {
[10:21:22.127]                     if (is.function(sendCondition)) 
[10:21:22.127]                       return(sendCondition)
[10:21:22.127]                     ns <- getNamespace("parallel")
[10:21:22.127]                     if (exists("sendData", mode = "function", 
[10:21:22.127]                       envir = ns)) {
[10:21:22.127]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.127]                         envir = ns)
[10:21:22.127]                       envir <- sys.frame(frame)
[10:21:22.127]                       master <- NULL
[10:21:22.127]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.127]                         !identical(envir, emptyenv())) {
[10:21:22.127]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.127]                           inherits = FALSE)) {
[10:21:22.127]                           master <- get("master", mode = "list", 
[10:21:22.127]                             envir = envir, inherits = FALSE)
[10:21:22.127]                           if (inherits(master, c("SOCKnode", 
[10:21:22.127]                             "SOCK0node"))) {
[10:21:22.127]                             sendCondition <<- function(cond) {
[10:21:22.127]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.127]                                 success = TRUE)
[10:21:22.127]                               parallel_sendData(master, data)
[10:21:22.127]                             }
[10:21:22.127]                             return(sendCondition)
[10:21:22.127]                           }
[10:21:22.127]                         }
[10:21:22.127]                         frame <- frame + 1L
[10:21:22.127]                         envir <- sys.frame(frame)
[10:21:22.127]                       }
[10:21:22.127]                     }
[10:21:22.127]                     sendCondition <<- function(cond) NULL
[10:21:22.127]                   }
[10:21:22.127]                 })
[10:21:22.127]                 withCallingHandlers({
[10:21:22.127]                   2
[10:21:22.127]                 }, immediateCondition = function(cond) {
[10:21:22.127]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.127]                   sendCondition(cond)
[10:21:22.127]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.127]                   {
[10:21:22.127]                     inherits <- base::inherits
[10:21:22.127]                     invokeRestart <- base::invokeRestart
[10:21:22.127]                     is.null <- base::is.null
[10:21:22.127]                     muffled <- FALSE
[10:21:22.127]                     if (inherits(cond, "message")) {
[10:21:22.127]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.127]                       if (muffled) 
[10:21:22.127]                         invokeRestart("muffleMessage")
[10:21:22.127]                     }
[10:21:22.127]                     else if (inherits(cond, "warning")) {
[10:21:22.127]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.127]                       if (muffled) 
[10:21:22.127]                         invokeRestart("muffleWarning")
[10:21:22.127]                     }
[10:21:22.127]                     else if (inherits(cond, "condition")) {
[10:21:22.127]                       if (!is.null(pattern)) {
[10:21:22.127]                         computeRestarts <- base::computeRestarts
[10:21:22.127]                         grepl <- base::grepl
[10:21:22.127]                         restarts <- computeRestarts(cond)
[10:21:22.127]                         for (restart in restarts) {
[10:21:22.127]                           name <- restart$name
[10:21:22.127]                           if (is.null(name)) 
[10:21:22.127]                             next
[10:21:22.127]                           if (!grepl(pattern, name)) 
[10:21:22.127]                             next
[10:21:22.127]                           invokeRestart(restart)
[10:21:22.127]                           muffled <- TRUE
[10:21:22.127]                           break
[10:21:22.127]                         }
[10:21:22.127]                       }
[10:21:22.127]                     }
[10:21:22.127]                     invisible(muffled)
[10:21:22.127]                   }
[10:21:22.127]                   muffleCondition(cond)
[10:21:22.127]                 })
[10:21:22.127]             }))
[10:21:22.127]             future::FutureResult(value = ...future.value$value, 
[10:21:22.127]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.127]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.127]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.127]                     ...future.globalenv.names))
[10:21:22.127]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.127]         }, condition = base::local({
[10:21:22.127]             c <- base::c
[10:21:22.127]             inherits <- base::inherits
[10:21:22.127]             invokeRestart <- base::invokeRestart
[10:21:22.127]             length <- base::length
[10:21:22.127]             list <- base::list
[10:21:22.127]             seq.int <- base::seq.int
[10:21:22.127]             signalCondition <- base::signalCondition
[10:21:22.127]             sys.calls <- base::sys.calls
[10:21:22.127]             `[[` <- base::`[[`
[10:21:22.127]             `+` <- base::`+`
[10:21:22.127]             `<<-` <- base::`<<-`
[10:21:22.127]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.127]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.127]                   3L)]
[10:21:22.127]             }
[10:21:22.127]             function(cond) {
[10:21:22.127]                 is_error <- inherits(cond, "error")
[10:21:22.127]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.127]                   NULL)
[10:21:22.127]                 if (is_error) {
[10:21:22.127]                   sessionInformation <- function() {
[10:21:22.127]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.127]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.127]                       search = base::search(), system = base::Sys.info())
[10:21:22.127]                   }
[10:21:22.127]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.127]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.127]                     cond$call), session = sessionInformation(), 
[10:21:22.127]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.127]                   signalCondition(cond)
[10:21:22.127]                 }
[10:21:22.127]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.127]                 "immediateCondition"))) {
[10:21:22.127]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.127]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.127]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.127]                   if (TRUE && !signal) {
[10:21:22.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.127]                     {
[10:21:22.127]                       inherits <- base::inherits
[10:21:22.127]                       invokeRestart <- base::invokeRestart
[10:21:22.127]                       is.null <- base::is.null
[10:21:22.127]                       muffled <- FALSE
[10:21:22.127]                       if (inherits(cond, "message")) {
[10:21:22.127]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.127]                         if (muffled) 
[10:21:22.127]                           invokeRestart("muffleMessage")
[10:21:22.127]                       }
[10:21:22.127]                       else if (inherits(cond, "warning")) {
[10:21:22.127]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.127]                         if (muffled) 
[10:21:22.127]                           invokeRestart("muffleWarning")
[10:21:22.127]                       }
[10:21:22.127]                       else if (inherits(cond, "condition")) {
[10:21:22.127]                         if (!is.null(pattern)) {
[10:21:22.127]                           computeRestarts <- base::computeRestarts
[10:21:22.127]                           grepl <- base::grepl
[10:21:22.127]                           restarts <- computeRestarts(cond)
[10:21:22.127]                           for (restart in restarts) {
[10:21:22.127]                             name <- restart$name
[10:21:22.127]                             if (is.null(name)) 
[10:21:22.127]                               next
[10:21:22.127]                             if (!grepl(pattern, name)) 
[10:21:22.127]                               next
[10:21:22.127]                             invokeRestart(restart)
[10:21:22.127]                             muffled <- TRUE
[10:21:22.127]                             break
[10:21:22.127]                           }
[10:21:22.127]                         }
[10:21:22.127]                       }
[10:21:22.127]                       invisible(muffled)
[10:21:22.127]                     }
[10:21:22.127]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.127]                   }
[10:21:22.127]                 }
[10:21:22.127]                 else {
[10:21:22.127]                   if (TRUE) {
[10:21:22.127]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.127]                     {
[10:21:22.127]                       inherits <- base::inherits
[10:21:22.127]                       invokeRestart <- base::invokeRestart
[10:21:22.127]                       is.null <- base::is.null
[10:21:22.127]                       muffled <- FALSE
[10:21:22.127]                       if (inherits(cond, "message")) {
[10:21:22.127]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.127]                         if (muffled) 
[10:21:22.127]                           invokeRestart("muffleMessage")
[10:21:22.127]                       }
[10:21:22.127]                       else if (inherits(cond, "warning")) {
[10:21:22.127]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.127]                         if (muffled) 
[10:21:22.127]                           invokeRestart("muffleWarning")
[10:21:22.127]                       }
[10:21:22.127]                       else if (inherits(cond, "condition")) {
[10:21:22.127]                         if (!is.null(pattern)) {
[10:21:22.127]                           computeRestarts <- base::computeRestarts
[10:21:22.127]                           grepl <- base::grepl
[10:21:22.127]                           restarts <- computeRestarts(cond)
[10:21:22.127]                           for (restart in restarts) {
[10:21:22.127]                             name <- restart$name
[10:21:22.127]                             if (is.null(name)) 
[10:21:22.127]                               next
[10:21:22.127]                             if (!grepl(pattern, name)) 
[10:21:22.127]                               next
[10:21:22.127]                             invokeRestart(restart)
[10:21:22.127]                             muffled <- TRUE
[10:21:22.127]                             break
[10:21:22.127]                           }
[10:21:22.127]                         }
[10:21:22.127]                       }
[10:21:22.127]                       invisible(muffled)
[10:21:22.127]                     }
[10:21:22.127]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.127]                   }
[10:21:22.127]                 }
[10:21:22.127]             }
[10:21:22.127]         }))
[10:21:22.127]     }, error = function(ex) {
[10:21:22.127]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.127]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.127]                 ...future.rng), started = ...future.startTime, 
[10:21:22.127]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.127]             version = "1.8"), class = "FutureResult")
[10:21:22.127]     }, finally = {
[10:21:22.127]         if (!identical(...future.workdir, getwd())) 
[10:21:22.127]             setwd(...future.workdir)
[10:21:22.127]         {
[10:21:22.127]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.127]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.127]             }
[10:21:22.127]             base::options(...future.oldOptions)
[10:21:22.127]             if (.Platform$OS.type == "windows") {
[10:21:22.127]                 old_names <- names(...future.oldEnvVars)
[10:21:22.127]                 envs <- base::Sys.getenv()
[10:21:22.127]                 names <- names(envs)
[10:21:22.127]                 common <- intersect(names, old_names)
[10:21:22.127]                 added <- setdiff(names, old_names)
[10:21:22.127]                 removed <- setdiff(old_names, names)
[10:21:22.127]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.127]                   envs[common]]
[10:21:22.127]                 NAMES <- toupper(changed)
[10:21:22.127]                 args <- list()
[10:21:22.127]                 for (kk in seq_along(NAMES)) {
[10:21:22.127]                   name <- changed[[kk]]
[10:21:22.127]                   NAME <- NAMES[[kk]]
[10:21:22.127]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.127]                     next
[10:21:22.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.127]                 }
[10:21:22.127]                 NAMES <- toupper(added)
[10:21:22.127]                 for (kk in seq_along(NAMES)) {
[10:21:22.127]                   name <- added[[kk]]
[10:21:22.127]                   NAME <- NAMES[[kk]]
[10:21:22.127]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.127]                     next
[10:21:22.127]                   args[[name]] <- ""
[10:21:22.127]                 }
[10:21:22.127]                 NAMES <- toupper(removed)
[10:21:22.127]                 for (kk in seq_along(NAMES)) {
[10:21:22.127]                   name <- removed[[kk]]
[10:21:22.127]                   NAME <- NAMES[[kk]]
[10:21:22.127]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.127]                     next
[10:21:22.127]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.127]                 }
[10:21:22.127]                 if (length(args) > 0) 
[10:21:22.127]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.127]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.127]             }
[10:21:22.127]             else {
[10:21:22.127]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.127]             }
[10:21:22.127]             {
[10:21:22.127]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.127]                   0L) {
[10:21:22.127]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.127]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.127]                   base::options(opts)
[10:21:22.127]                 }
[10:21:22.127]                 {
[10:21:22.127]                   {
[10:21:22.127]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.127]                     NULL
[10:21:22.127]                   }
[10:21:22.127]                   options(future.plan = NULL)
[10:21:22.127]                   if (is.na(NA_character_)) 
[10:21:22.127]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.127]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.127]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.127]                     .init = FALSE)
[10:21:22.127]                 }
[10:21:22.127]             }
[10:21:22.127]         }
[10:21:22.127]     })
[10:21:22.127]     if (TRUE) {
[10:21:22.127]         base::sink(type = "output", split = FALSE)
[10:21:22.127]         if (TRUE) {
[10:21:22.127]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.127]         }
[10:21:22.127]         else {
[10:21:22.127]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.127]         }
[10:21:22.127]         base::close(...future.stdout)
[10:21:22.127]         ...future.stdout <- NULL
[10:21:22.127]     }
[10:21:22.127]     ...future.result$conditions <- ...future.conditions
[10:21:22.127]     ...future.result$finished <- base::Sys.time()
[10:21:22.127]     ...future.result
[10:21:22.127] }
[10:21:22.130] MultisessionFuture started
[10:21:22.130] - Launch lazy future ... done
[10:21:22.130] run() for ‘MultisessionFuture’ ... done
[10:21:22.130] getGlobalsAndPackages() ...
[10:21:22.131] Searching for globals...
[10:21:22.131] 
[10:21:22.131] Searching for globals ... DONE
[10:21:22.131] - globals: [0] <none>
[10:21:22.131] getGlobalsAndPackages() ... DONE
[10:21:22.132] run() for ‘Future’ ...
[10:21:22.132] - state: ‘created’
[10:21:22.132] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.148] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.148] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.148]   - Field: ‘node’
[10:21:22.148]   - Field: ‘label’
[10:21:22.148]   - Field: ‘local’
[10:21:22.148]   - Field: ‘owner’
[10:21:22.148]   - Field: ‘envir’
[10:21:22.148]   - Field: ‘workers’
[10:21:22.149]   - Field: ‘packages’
[10:21:22.149]   - Field: ‘gc’
[10:21:22.149]   - Field: ‘conditions’
[10:21:22.149]   - Field: ‘persistent’
[10:21:22.149]   - Field: ‘expr’
[10:21:22.149]   - Field: ‘uuid’
[10:21:22.149]   - Field: ‘seed’
[10:21:22.149]   - Field: ‘version’
[10:21:22.149]   - Field: ‘result’
[10:21:22.149]   - Field: ‘asynchronous’
[10:21:22.150]   - Field: ‘calls’
[10:21:22.150]   - Field: ‘globals’
[10:21:22.150]   - Field: ‘stdout’
[10:21:22.150]   - Field: ‘earlySignal’
[10:21:22.150]   - Field: ‘lazy’
[10:21:22.150]   - Field: ‘state’
[10:21:22.150] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.150] - Launch lazy future ...
[10:21:22.151] Packages needed by the future expression (n = 0): <none>
[10:21:22.151] Packages needed by future strategies (n = 0): <none>
[10:21:22.151] {
[10:21:22.151]     {
[10:21:22.151]         {
[10:21:22.151]             ...future.startTime <- base::Sys.time()
[10:21:22.151]             {
[10:21:22.151]                 {
[10:21:22.151]                   {
[10:21:22.151]                     {
[10:21:22.151]                       base::local({
[10:21:22.151]                         has_future <- base::requireNamespace("future", 
[10:21:22.151]                           quietly = TRUE)
[10:21:22.151]                         if (has_future) {
[10:21:22.151]                           ns <- base::getNamespace("future")
[10:21:22.151]                           version <- ns[[".package"]][["version"]]
[10:21:22.151]                           if (is.null(version)) 
[10:21:22.151]                             version <- utils::packageVersion("future")
[10:21:22.151]                         }
[10:21:22.151]                         else {
[10:21:22.151]                           version <- NULL
[10:21:22.151]                         }
[10:21:22.151]                         if (!has_future || version < "1.8.0") {
[10:21:22.151]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.151]                             "", base::R.version$version.string), 
[10:21:22.151]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.151]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.151]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.151]                               "release", "version")], collapse = " "), 
[10:21:22.151]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.151]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.151]                             info)
[10:21:22.151]                           info <- base::paste(info, collapse = "; ")
[10:21:22.151]                           if (!has_future) {
[10:21:22.151]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.151]                               info)
[10:21:22.151]                           }
[10:21:22.151]                           else {
[10:21:22.151]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.151]                               info, version)
[10:21:22.151]                           }
[10:21:22.151]                           base::stop(msg)
[10:21:22.151]                         }
[10:21:22.151]                       })
[10:21:22.151]                     }
[10:21:22.151]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.151]                     base::options(mc.cores = 1L)
[10:21:22.151]                   }
[10:21:22.151]                   ...future.strategy.old <- future::plan("list")
[10:21:22.151]                   options(future.plan = NULL)
[10:21:22.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.151]                 }
[10:21:22.151]                 ...future.workdir <- getwd()
[10:21:22.151]             }
[10:21:22.151]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.151]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.151]         }
[10:21:22.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.151]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.151]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.151]             base::names(...future.oldOptions))
[10:21:22.151]     }
[10:21:22.151]     if (FALSE) {
[10:21:22.151]     }
[10:21:22.151]     else {
[10:21:22.151]         if (TRUE) {
[10:21:22.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.151]                 open = "w")
[10:21:22.151]         }
[10:21:22.151]         else {
[10:21:22.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.151]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.151]         }
[10:21:22.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.151]             base::sink(type = "output", split = FALSE)
[10:21:22.151]             base::close(...future.stdout)
[10:21:22.151]         }, add = TRUE)
[10:21:22.151]     }
[10:21:22.151]     ...future.frame <- base::sys.nframe()
[10:21:22.151]     ...future.conditions <- base::list()
[10:21:22.151]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.151]     if (FALSE) {
[10:21:22.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.151]     }
[10:21:22.151]     ...future.result <- base::tryCatch({
[10:21:22.151]         base::withCallingHandlers({
[10:21:22.151]             ...future.value <- base::withVisible(base::local({
[10:21:22.151]                 ...future.makeSendCondition <- base::local({
[10:21:22.151]                   sendCondition <- NULL
[10:21:22.151]                   function(frame = 1L) {
[10:21:22.151]                     if (is.function(sendCondition)) 
[10:21:22.151]                       return(sendCondition)
[10:21:22.151]                     ns <- getNamespace("parallel")
[10:21:22.151]                     if (exists("sendData", mode = "function", 
[10:21:22.151]                       envir = ns)) {
[10:21:22.151]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.151]                         envir = ns)
[10:21:22.151]                       envir <- sys.frame(frame)
[10:21:22.151]                       master <- NULL
[10:21:22.151]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.151]                         !identical(envir, emptyenv())) {
[10:21:22.151]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.151]                           inherits = FALSE)) {
[10:21:22.151]                           master <- get("master", mode = "list", 
[10:21:22.151]                             envir = envir, inherits = FALSE)
[10:21:22.151]                           if (inherits(master, c("SOCKnode", 
[10:21:22.151]                             "SOCK0node"))) {
[10:21:22.151]                             sendCondition <<- function(cond) {
[10:21:22.151]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.151]                                 success = TRUE)
[10:21:22.151]                               parallel_sendData(master, data)
[10:21:22.151]                             }
[10:21:22.151]                             return(sendCondition)
[10:21:22.151]                           }
[10:21:22.151]                         }
[10:21:22.151]                         frame <- frame + 1L
[10:21:22.151]                         envir <- sys.frame(frame)
[10:21:22.151]                       }
[10:21:22.151]                     }
[10:21:22.151]                     sendCondition <<- function(cond) NULL
[10:21:22.151]                   }
[10:21:22.151]                 })
[10:21:22.151]                 withCallingHandlers({
[10:21:22.151]                   NULL
[10:21:22.151]                 }, immediateCondition = function(cond) {
[10:21:22.151]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.151]                   sendCondition(cond)
[10:21:22.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.151]                   {
[10:21:22.151]                     inherits <- base::inherits
[10:21:22.151]                     invokeRestart <- base::invokeRestart
[10:21:22.151]                     is.null <- base::is.null
[10:21:22.151]                     muffled <- FALSE
[10:21:22.151]                     if (inherits(cond, "message")) {
[10:21:22.151]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.151]                       if (muffled) 
[10:21:22.151]                         invokeRestart("muffleMessage")
[10:21:22.151]                     }
[10:21:22.151]                     else if (inherits(cond, "warning")) {
[10:21:22.151]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.151]                       if (muffled) 
[10:21:22.151]                         invokeRestart("muffleWarning")
[10:21:22.151]                     }
[10:21:22.151]                     else if (inherits(cond, "condition")) {
[10:21:22.151]                       if (!is.null(pattern)) {
[10:21:22.151]                         computeRestarts <- base::computeRestarts
[10:21:22.151]                         grepl <- base::grepl
[10:21:22.151]                         restarts <- computeRestarts(cond)
[10:21:22.151]                         for (restart in restarts) {
[10:21:22.151]                           name <- restart$name
[10:21:22.151]                           if (is.null(name)) 
[10:21:22.151]                             next
[10:21:22.151]                           if (!grepl(pattern, name)) 
[10:21:22.151]                             next
[10:21:22.151]                           invokeRestart(restart)
[10:21:22.151]                           muffled <- TRUE
[10:21:22.151]                           break
[10:21:22.151]                         }
[10:21:22.151]                       }
[10:21:22.151]                     }
[10:21:22.151]                     invisible(muffled)
[10:21:22.151]                   }
[10:21:22.151]                   muffleCondition(cond)
[10:21:22.151]                 })
[10:21:22.151]             }))
[10:21:22.151]             future::FutureResult(value = ...future.value$value, 
[10:21:22.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.151]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.151]                     ...future.globalenv.names))
[10:21:22.151]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.151]         }, condition = base::local({
[10:21:22.151]             c <- base::c
[10:21:22.151]             inherits <- base::inherits
[10:21:22.151]             invokeRestart <- base::invokeRestart
[10:21:22.151]             length <- base::length
[10:21:22.151]             list <- base::list
[10:21:22.151]             seq.int <- base::seq.int
[10:21:22.151]             signalCondition <- base::signalCondition
[10:21:22.151]             sys.calls <- base::sys.calls
[10:21:22.151]             `[[` <- base::`[[`
[10:21:22.151]             `+` <- base::`+`
[10:21:22.151]             `<<-` <- base::`<<-`
[10:21:22.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.151]                   3L)]
[10:21:22.151]             }
[10:21:22.151]             function(cond) {
[10:21:22.151]                 is_error <- inherits(cond, "error")
[10:21:22.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.151]                   NULL)
[10:21:22.151]                 if (is_error) {
[10:21:22.151]                   sessionInformation <- function() {
[10:21:22.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.151]                       search = base::search(), system = base::Sys.info())
[10:21:22.151]                   }
[10:21:22.151]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.151]                     cond$call), session = sessionInformation(), 
[10:21:22.151]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.151]                   signalCondition(cond)
[10:21:22.151]                 }
[10:21:22.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.151]                 "immediateCondition"))) {
[10:21:22.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.151]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.151]                   if (TRUE && !signal) {
[10:21:22.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.151]                     {
[10:21:22.151]                       inherits <- base::inherits
[10:21:22.151]                       invokeRestart <- base::invokeRestart
[10:21:22.151]                       is.null <- base::is.null
[10:21:22.151]                       muffled <- FALSE
[10:21:22.151]                       if (inherits(cond, "message")) {
[10:21:22.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.151]                         if (muffled) 
[10:21:22.151]                           invokeRestart("muffleMessage")
[10:21:22.151]                       }
[10:21:22.151]                       else if (inherits(cond, "warning")) {
[10:21:22.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.151]                         if (muffled) 
[10:21:22.151]                           invokeRestart("muffleWarning")
[10:21:22.151]                       }
[10:21:22.151]                       else if (inherits(cond, "condition")) {
[10:21:22.151]                         if (!is.null(pattern)) {
[10:21:22.151]                           computeRestarts <- base::computeRestarts
[10:21:22.151]                           grepl <- base::grepl
[10:21:22.151]                           restarts <- computeRestarts(cond)
[10:21:22.151]                           for (restart in restarts) {
[10:21:22.151]                             name <- restart$name
[10:21:22.151]                             if (is.null(name)) 
[10:21:22.151]                               next
[10:21:22.151]                             if (!grepl(pattern, name)) 
[10:21:22.151]                               next
[10:21:22.151]                             invokeRestart(restart)
[10:21:22.151]                             muffled <- TRUE
[10:21:22.151]                             break
[10:21:22.151]                           }
[10:21:22.151]                         }
[10:21:22.151]                       }
[10:21:22.151]                       invisible(muffled)
[10:21:22.151]                     }
[10:21:22.151]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.151]                   }
[10:21:22.151]                 }
[10:21:22.151]                 else {
[10:21:22.151]                   if (TRUE) {
[10:21:22.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.151]                     {
[10:21:22.151]                       inherits <- base::inherits
[10:21:22.151]                       invokeRestart <- base::invokeRestart
[10:21:22.151]                       is.null <- base::is.null
[10:21:22.151]                       muffled <- FALSE
[10:21:22.151]                       if (inherits(cond, "message")) {
[10:21:22.151]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.151]                         if (muffled) 
[10:21:22.151]                           invokeRestart("muffleMessage")
[10:21:22.151]                       }
[10:21:22.151]                       else if (inherits(cond, "warning")) {
[10:21:22.151]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.151]                         if (muffled) 
[10:21:22.151]                           invokeRestart("muffleWarning")
[10:21:22.151]                       }
[10:21:22.151]                       else if (inherits(cond, "condition")) {
[10:21:22.151]                         if (!is.null(pattern)) {
[10:21:22.151]                           computeRestarts <- base::computeRestarts
[10:21:22.151]                           grepl <- base::grepl
[10:21:22.151]                           restarts <- computeRestarts(cond)
[10:21:22.151]                           for (restart in restarts) {
[10:21:22.151]                             name <- restart$name
[10:21:22.151]                             if (is.null(name)) 
[10:21:22.151]                               next
[10:21:22.151]                             if (!grepl(pattern, name)) 
[10:21:22.151]                               next
[10:21:22.151]                             invokeRestart(restart)
[10:21:22.151]                             muffled <- TRUE
[10:21:22.151]                             break
[10:21:22.151]                           }
[10:21:22.151]                         }
[10:21:22.151]                       }
[10:21:22.151]                       invisible(muffled)
[10:21:22.151]                     }
[10:21:22.151]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.151]                   }
[10:21:22.151]                 }
[10:21:22.151]             }
[10:21:22.151]         }))
[10:21:22.151]     }, error = function(ex) {
[10:21:22.151]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.151]                 ...future.rng), started = ...future.startTime, 
[10:21:22.151]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.151]             version = "1.8"), class = "FutureResult")
[10:21:22.151]     }, finally = {
[10:21:22.151]         if (!identical(...future.workdir, getwd())) 
[10:21:22.151]             setwd(...future.workdir)
[10:21:22.151]         {
[10:21:22.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.151]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.151]             }
[10:21:22.151]             base::options(...future.oldOptions)
[10:21:22.151]             if (.Platform$OS.type == "windows") {
[10:21:22.151]                 old_names <- names(...future.oldEnvVars)
[10:21:22.151]                 envs <- base::Sys.getenv()
[10:21:22.151]                 names <- names(envs)
[10:21:22.151]                 common <- intersect(names, old_names)
[10:21:22.151]                 added <- setdiff(names, old_names)
[10:21:22.151]                 removed <- setdiff(old_names, names)
[10:21:22.151]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.151]                   envs[common]]
[10:21:22.151]                 NAMES <- toupper(changed)
[10:21:22.151]                 args <- list()
[10:21:22.151]                 for (kk in seq_along(NAMES)) {
[10:21:22.151]                   name <- changed[[kk]]
[10:21:22.151]                   NAME <- NAMES[[kk]]
[10:21:22.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.151]                     next
[10:21:22.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.151]                 }
[10:21:22.151]                 NAMES <- toupper(added)
[10:21:22.151]                 for (kk in seq_along(NAMES)) {
[10:21:22.151]                   name <- added[[kk]]
[10:21:22.151]                   NAME <- NAMES[[kk]]
[10:21:22.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.151]                     next
[10:21:22.151]                   args[[name]] <- ""
[10:21:22.151]                 }
[10:21:22.151]                 NAMES <- toupper(removed)
[10:21:22.151]                 for (kk in seq_along(NAMES)) {
[10:21:22.151]                   name <- removed[[kk]]
[10:21:22.151]                   NAME <- NAMES[[kk]]
[10:21:22.151]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.151]                     next
[10:21:22.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.151]                 }
[10:21:22.151]                 if (length(args) > 0) 
[10:21:22.151]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.151]             }
[10:21:22.151]             else {
[10:21:22.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.151]             }
[10:21:22.151]             {
[10:21:22.151]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.151]                   0L) {
[10:21:22.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.151]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.151]                   base::options(opts)
[10:21:22.151]                 }
[10:21:22.151]                 {
[10:21:22.151]                   {
[10:21:22.151]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.151]                     NULL
[10:21:22.151]                   }
[10:21:22.151]                   options(future.plan = NULL)
[10:21:22.151]                   if (is.na(NA_character_)) 
[10:21:22.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.151]                     .init = FALSE)
[10:21:22.151]                 }
[10:21:22.151]             }
[10:21:22.151]         }
[10:21:22.151]     })
[10:21:22.151]     if (TRUE) {
[10:21:22.151]         base::sink(type = "output", split = FALSE)
[10:21:22.151]         if (TRUE) {
[10:21:22.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.151]         }
[10:21:22.151]         else {
[10:21:22.151]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.151]         }
[10:21:22.151]         base::close(...future.stdout)
[10:21:22.151]         ...future.stdout <- NULL
[10:21:22.151]     }
[10:21:22.151]     ...future.result$conditions <- ...future.conditions
[10:21:22.151]     ...future.result$finished <- base::Sys.time()
[10:21:22.151]     ...future.result
[10:21:22.151] }
[10:21:22.204] MultisessionFuture started
[10:21:22.204] - Launch lazy future ... done
[10:21:22.204] run() for ‘MultisessionFuture’ ... done
[10:21:22.204] getGlobalsAndPackages() ...
[10:21:22.205] Searching for globals...
[10:21:22.205] - globals found: [1] ‘{’
[10:21:22.205] Searching for globals ... DONE
[10:21:22.206] Resolving globals: FALSE
[10:21:22.206] 
[10:21:22.206] 
[10:21:22.206] getGlobalsAndPackages() ... DONE
[10:21:22.206] run() for ‘Future’ ...
[10:21:22.207] - state: ‘created’
[10:21:22.207] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.222] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.222]   - Field: ‘node’
[10:21:22.222]   - Field: ‘label’
[10:21:22.222]   - Field: ‘local’
[10:21:22.222]   - Field: ‘owner’
[10:21:22.222]   - Field: ‘envir’
[10:21:22.222]   - Field: ‘workers’
[10:21:22.222]   - Field: ‘packages’
[10:21:22.223]   - Field: ‘gc’
[10:21:22.223]   - Field: ‘conditions’
[10:21:22.223]   - Field: ‘persistent’
[10:21:22.223]   - Field: ‘expr’
[10:21:22.223]   - Field: ‘uuid’
[10:21:22.223]   - Field: ‘seed’
[10:21:22.223]   - Field: ‘version’
[10:21:22.223]   - Field: ‘result’
[10:21:22.223]   - Field: ‘asynchronous’
[10:21:22.223]   - Field: ‘calls’
[10:21:22.224]   - Field: ‘globals’
[10:21:22.224]   - Field: ‘stdout’
[10:21:22.224]   - Field: ‘earlySignal’
[10:21:22.224]   - Field: ‘lazy’
[10:21:22.224]   - Field: ‘state’
[10:21:22.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.224] - Launch lazy future ...
[10:21:22.225] Packages needed by the future expression (n = 0): <none>
[10:21:22.225] Packages needed by future strategies (n = 0): <none>
[10:21:22.225] {
[10:21:22.225]     {
[10:21:22.225]         {
[10:21:22.225]             ...future.startTime <- base::Sys.time()
[10:21:22.225]             {
[10:21:22.225]                 {
[10:21:22.225]                   {
[10:21:22.225]                     {
[10:21:22.225]                       base::local({
[10:21:22.225]                         has_future <- base::requireNamespace("future", 
[10:21:22.225]                           quietly = TRUE)
[10:21:22.225]                         if (has_future) {
[10:21:22.225]                           ns <- base::getNamespace("future")
[10:21:22.225]                           version <- ns[[".package"]][["version"]]
[10:21:22.225]                           if (is.null(version)) 
[10:21:22.225]                             version <- utils::packageVersion("future")
[10:21:22.225]                         }
[10:21:22.225]                         else {
[10:21:22.225]                           version <- NULL
[10:21:22.225]                         }
[10:21:22.225]                         if (!has_future || version < "1.8.0") {
[10:21:22.225]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.225]                             "", base::R.version$version.string), 
[10:21:22.225]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.225]                               "release", "version")], collapse = " "), 
[10:21:22.225]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.225]                             info)
[10:21:22.225]                           info <- base::paste(info, collapse = "; ")
[10:21:22.225]                           if (!has_future) {
[10:21:22.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.225]                               info)
[10:21:22.225]                           }
[10:21:22.225]                           else {
[10:21:22.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.225]                               info, version)
[10:21:22.225]                           }
[10:21:22.225]                           base::stop(msg)
[10:21:22.225]                         }
[10:21:22.225]                       })
[10:21:22.225]                     }
[10:21:22.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.225]                     base::options(mc.cores = 1L)
[10:21:22.225]                   }
[10:21:22.225]                   ...future.strategy.old <- future::plan("list")
[10:21:22.225]                   options(future.plan = NULL)
[10:21:22.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.225]                 }
[10:21:22.225]                 ...future.workdir <- getwd()
[10:21:22.225]             }
[10:21:22.225]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.225]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.225]         }
[10:21:22.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.225]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.225]             base::names(...future.oldOptions))
[10:21:22.225]     }
[10:21:22.225]     if (FALSE) {
[10:21:22.225]     }
[10:21:22.225]     else {
[10:21:22.225]         if (TRUE) {
[10:21:22.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.225]                 open = "w")
[10:21:22.225]         }
[10:21:22.225]         else {
[10:21:22.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.225]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.225]         }
[10:21:22.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.225]             base::sink(type = "output", split = FALSE)
[10:21:22.225]             base::close(...future.stdout)
[10:21:22.225]         }, add = TRUE)
[10:21:22.225]     }
[10:21:22.225]     ...future.frame <- base::sys.nframe()
[10:21:22.225]     ...future.conditions <- base::list()
[10:21:22.225]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.225]     if (FALSE) {
[10:21:22.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.225]     }
[10:21:22.225]     ...future.result <- base::tryCatch({
[10:21:22.225]         base::withCallingHandlers({
[10:21:22.225]             ...future.value <- base::withVisible(base::local({
[10:21:22.225]                 ...future.makeSendCondition <- base::local({
[10:21:22.225]                   sendCondition <- NULL
[10:21:22.225]                   function(frame = 1L) {
[10:21:22.225]                     if (is.function(sendCondition)) 
[10:21:22.225]                       return(sendCondition)
[10:21:22.225]                     ns <- getNamespace("parallel")
[10:21:22.225]                     if (exists("sendData", mode = "function", 
[10:21:22.225]                       envir = ns)) {
[10:21:22.225]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.225]                         envir = ns)
[10:21:22.225]                       envir <- sys.frame(frame)
[10:21:22.225]                       master <- NULL
[10:21:22.225]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.225]                         !identical(envir, emptyenv())) {
[10:21:22.225]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.225]                           inherits = FALSE)) {
[10:21:22.225]                           master <- get("master", mode = "list", 
[10:21:22.225]                             envir = envir, inherits = FALSE)
[10:21:22.225]                           if (inherits(master, c("SOCKnode", 
[10:21:22.225]                             "SOCK0node"))) {
[10:21:22.225]                             sendCondition <<- function(cond) {
[10:21:22.225]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.225]                                 success = TRUE)
[10:21:22.225]                               parallel_sendData(master, data)
[10:21:22.225]                             }
[10:21:22.225]                             return(sendCondition)
[10:21:22.225]                           }
[10:21:22.225]                         }
[10:21:22.225]                         frame <- frame + 1L
[10:21:22.225]                         envir <- sys.frame(frame)
[10:21:22.225]                       }
[10:21:22.225]                     }
[10:21:22.225]                     sendCondition <<- function(cond) NULL
[10:21:22.225]                   }
[10:21:22.225]                 })
[10:21:22.225]                 withCallingHandlers({
[10:21:22.225]                   {
[10:21:22.225]                     4
[10:21:22.225]                   }
[10:21:22.225]                 }, immediateCondition = function(cond) {
[10:21:22.225]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.225]                   sendCondition(cond)
[10:21:22.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.225]                   {
[10:21:22.225]                     inherits <- base::inherits
[10:21:22.225]                     invokeRestart <- base::invokeRestart
[10:21:22.225]                     is.null <- base::is.null
[10:21:22.225]                     muffled <- FALSE
[10:21:22.225]                     if (inherits(cond, "message")) {
[10:21:22.225]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.225]                       if (muffled) 
[10:21:22.225]                         invokeRestart("muffleMessage")
[10:21:22.225]                     }
[10:21:22.225]                     else if (inherits(cond, "warning")) {
[10:21:22.225]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.225]                       if (muffled) 
[10:21:22.225]                         invokeRestart("muffleWarning")
[10:21:22.225]                     }
[10:21:22.225]                     else if (inherits(cond, "condition")) {
[10:21:22.225]                       if (!is.null(pattern)) {
[10:21:22.225]                         computeRestarts <- base::computeRestarts
[10:21:22.225]                         grepl <- base::grepl
[10:21:22.225]                         restarts <- computeRestarts(cond)
[10:21:22.225]                         for (restart in restarts) {
[10:21:22.225]                           name <- restart$name
[10:21:22.225]                           if (is.null(name)) 
[10:21:22.225]                             next
[10:21:22.225]                           if (!grepl(pattern, name)) 
[10:21:22.225]                             next
[10:21:22.225]                           invokeRestart(restart)
[10:21:22.225]                           muffled <- TRUE
[10:21:22.225]                           break
[10:21:22.225]                         }
[10:21:22.225]                       }
[10:21:22.225]                     }
[10:21:22.225]                     invisible(muffled)
[10:21:22.225]                   }
[10:21:22.225]                   muffleCondition(cond)
[10:21:22.225]                 })
[10:21:22.225]             }))
[10:21:22.225]             future::FutureResult(value = ...future.value$value, 
[10:21:22.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.225]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.225]                     ...future.globalenv.names))
[10:21:22.225]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.225]         }, condition = base::local({
[10:21:22.225]             c <- base::c
[10:21:22.225]             inherits <- base::inherits
[10:21:22.225]             invokeRestart <- base::invokeRestart
[10:21:22.225]             length <- base::length
[10:21:22.225]             list <- base::list
[10:21:22.225]             seq.int <- base::seq.int
[10:21:22.225]             signalCondition <- base::signalCondition
[10:21:22.225]             sys.calls <- base::sys.calls
[10:21:22.225]             `[[` <- base::`[[`
[10:21:22.225]             `+` <- base::`+`
[10:21:22.225]             `<<-` <- base::`<<-`
[10:21:22.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.225]                   3L)]
[10:21:22.225]             }
[10:21:22.225]             function(cond) {
[10:21:22.225]                 is_error <- inherits(cond, "error")
[10:21:22.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.225]                   NULL)
[10:21:22.225]                 if (is_error) {
[10:21:22.225]                   sessionInformation <- function() {
[10:21:22.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.225]                       search = base::search(), system = base::Sys.info())
[10:21:22.225]                   }
[10:21:22.225]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.225]                     cond$call), session = sessionInformation(), 
[10:21:22.225]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.225]                   signalCondition(cond)
[10:21:22.225]                 }
[10:21:22.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.225]                 "immediateCondition"))) {
[10:21:22.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.225]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.225]                   if (TRUE && !signal) {
[10:21:22.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.225]                     {
[10:21:22.225]                       inherits <- base::inherits
[10:21:22.225]                       invokeRestart <- base::invokeRestart
[10:21:22.225]                       is.null <- base::is.null
[10:21:22.225]                       muffled <- FALSE
[10:21:22.225]                       if (inherits(cond, "message")) {
[10:21:22.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.225]                         if (muffled) 
[10:21:22.225]                           invokeRestart("muffleMessage")
[10:21:22.225]                       }
[10:21:22.225]                       else if (inherits(cond, "warning")) {
[10:21:22.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.225]                         if (muffled) 
[10:21:22.225]                           invokeRestart("muffleWarning")
[10:21:22.225]                       }
[10:21:22.225]                       else if (inherits(cond, "condition")) {
[10:21:22.225]                         if (!is.null(pattern)) {
[10:21:22.225]                           computeRestarts <- base::computeRestarts
[10:21:22.225]                           grepl <- base::grepl
[10:21:22.225]                           restarts <- computeRestarts(cond)
[10:21:22.225]                           for (restart in restarts) {
[10:21:22.225]                             name <- restart$name
[10:21:22.225]                             if (is.null(name)) 
[10:21:22.225]                               next
[10:21:22.225]                             if (!grepl(pattern, name)) 
[10:21:22.225]                               next
[10:21:22.225]                             invokeRestart(restart)
[10:21:22.225]                             muffled <- TRUE
[10:21:22.225]                             break
[10:21:22.225]                           }
[10:21:22.225]                         }
[10:21:22.225]                       }
[10:21:22.225]                       invisible(muffled)
[10:21:22.225]                     }
[10:21:22.225]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.225]                   }
[10:21:22.225]                 }
[10:21:22.225]                 else {
[10:21:22.225]                   if (TRUE) {
[10:21:22.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.225]                     {
[10:21:22.225]                       inherits <- base::inherits
[10:21:22.225]                       invokeRestart <- base::invokeRestart
[10:21:22.225]                       is.null <- base::is.null
[10:21:22.225]                       muffled <- FALSE
[10:21:22.225]                       if (inherits(cond, "message")) {
[10:21:22.225]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.225]                         if (muffled) 
[10:21:22.225]                           invokeRestart("muffleMessage")
[10:21:22.225]                       }
[10:21:22.225]                       else if (inherits(cond, "warning")) {
[10:21:22.225]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.225]                         if (muffled) 
[10:21:22.225]                           invokeRestart("muffleWarning")
[10:21:22.225]                       }
[10:21:22.225]                       else if (inherits(cond, "condition")) {
[10:21:22.225]                         if (!is.null(pattern)) {
[10:21:22.225]                           computeRestarts <- base::computeRestarts
[10:21:22.225]                           grepl <- base::grepl
[10:21:22.225]                           restarts <- computeRestarts(cond)
[10:21:22.225]                           for (restart in restarts) {
[10:21:22.225]                             name <- restart$name
[10:21:22.225]                             if (is.null(name)) 
[10:21:22.225]                               next
[10:21:22.225]                             if (!grepl(pattern, name)) 
[10:21:22.225]                               next
[10:21:22.225]                             invokeRestart(restart)
[10:21:22.225]                             muffled <- TRUE
[10:21:22.225]                             break
[10:21:22.225]                           }
[10:21:22.225]                         }
[10:21:22.225]                       }
[10:21:22.225]                       invisible(muffled)
[10:21:22.225]                     }
[10:21:22.225]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.225]                   }
[10:21:22.225]                 }
[10:21:22.225]             }
[10:21:22.225]         }))
[10:21:22.225]     }, error = function(ex) {
[10:21:22.225]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.225]                 ...future.rng), started = ...future.startTime, 
[10:21:22.225]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.225]             version = "1.8"), class = "FutureResult")
[10:21:22.225]     }, finally = {
[10:21:22.225]         if (!identical(...future.workdir, getwd())) 
[10:21:22.225]             setwd(...future.workdir)
[10:21:22.225]         {
[10:21:22.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.225]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.225]             }
[10:21:22.225]             base::options(...future.oldOptions)
[10:21:22.225]             if (.Platform$OS.type == "windows") {
[10:21:22.225]                 old_names <- names(...future.oldEnvVars)
[10:21:22.225]                 envs <- base::Sys.getenv()
[10:21:22.225]                 names <- names(envs)
[10:21:22.225]                 common <- intersect(names, old_names)
[10:21:22.225]                 added <- setdiff(names, old_names)
[10:21:22.225]                 removed <- setdiff(old_names, names)
[10:21:22.225]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.225]                   envs[common]]
[10:21:22.225]                 NAMES <- toupper(changed)
[10:21:22.225]                 args <- list()
[10:21:22.225]                 for (kk in seq_along(NAMES)) {
[10:21:22.225]                   name <- changed[[kk]]
[10:21:22.225]                   NAME <- NAMES[[kk]]
[10:21:22.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.225]                     next
[10:21:22.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.225]                 }
[10:21:22.225]                 NAMES <- toupper(added)
[10:21:22.225]                 for (kk in seq_along(NAMES)) {
[10:21:22.225]                   name <- added[[kk]]
[10:21:22.225]                   NAME <- NAMES[[kk]]
[10:21:22.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.225]                     next
[10:21:22.225]                   args[[name]] <- ""
[10:21:22.225]                 }
[10:21:22.225]                 NAMES <- toupper(removed)
[10:21:22.225]                 for (kk in seq_along(NAMES)) {
[10:21:22.225]                   name <- removed[[kk]]
[10:21:22.225]                   NAME <- NAMES[[kk]]
[10:21:22.225]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.225]                     next
[10:21:22.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.225]                 }
[10:21:22.225]                 if (length(args) > 0) 
[10:21:22.225]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.225]             }
[10:21:22.225]             else {
[10:21:22.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.225]             }
[10:21:22.225]             {
[10:21:22.225]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.225]                   0L) {
[10:21:22.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.225]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.225]                   base::options(opts)
[10:21:22.225]                 }
[10:21:22.225]                 {
[10:21:22.225]                   {
[10:21:22.225]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.225]                     NULL
[10:21:22.225]                   }
[10:21:22.225]                   options(future.plan = NULL)
[10:21:22.225]                   if (is.na(NA_character_)) 
[10:21:22.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.225]                     .init = FALSE)
[10:21:22.225]                 }
[10:21:22.225]             }
[10:21:22.225]         }
[10:21:22.225]     })
[10:21:22.225]     if (TRUE) {
[10:21:22.225]         base::sink(type = "output", split = FALSE)
[10:21:22.225]         if (TRUE) {
[10:21:22.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.225]         }
[10:21:22.225]         else {
[10:21:22.225]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.225]         }
[10:21:22.225]         base::close(...future.stdout)
[10:21:22.225]         ...future.stdout <- NULL
[10:21:22.225]     }
[10:21:22.225]     ...future.result$conditions <- ...future.conditions
[10:21:22.225]     ...future.result$finished <- base::Sys.time()
[10:21:22.225]     ...future.result
[10:21:22.225] }
[10:21:22.227] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:22.238] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.239] - Validating connection of MultisessionFuture
[10:21:22.239] - received message: FutureResult
[10:21:22.239] - Received FutureResult
[10:21:22.239] - Erased future from FutureRegistry
[10:21:22.239] result() for ClusterFuture ...
[10:21:22.239] - result already collected: FutureResult
[10:21:22.239] result() for ClusterFuture ... done
[10:21:22.239] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.240] result() for ClusterFuture ...
[10:21:22.240] - result already collected: FutureResult
[10:21:22.240] result() for ClusterFuture ... done
[10:21:22.240] result() for ClusterFuture ...
[10:21:22.240] - result already collected: FutureResult
[10:21:22.240] result() for ClusterFuture ... done
[10:21:22.241] MultisessionFuture started
[10:21:22.241] - Launch lazy future ... done
[10:21:22.242] run() for ‘MultisessionFuture’ ... done
<environment: 0x55e8e4d17e40> 
<environment: 0x55e8e6892a00> 
[10:21:22.244] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.245] - Validating connection of MultisessionFuture
[10:21:22.245] - received message: FutureResult
[10:21:22.245] - Received FutureResult
[10:21:22.245] - Erased future from FutureRegistry
[10:21:22.245] result() for ClusterFuture ...
[10:21:22.245] - result already collected: FutureResult
[10:21:22.246] result() for ClusterFuture ... done
[10:21:22.246] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:22.258] resolve() on environment ...
[10:21:22.258]  recursive: 0
[10:21:22.259]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:22.259] signalConditionsASAP(numeric, pos=1) ...
[10:21:22.259] - nx: 4
[10:21:22.259] - relay: TRUE
[10:21:22.259] - stdout: TRUE
[10:21:22.259] - signal: TRUE
[10:21:22.259] - resignal: FALSE
[10:21:22.259] - force: TRUE
[10:21:22.259] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.260] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.260]  - until=2
[10:21:22.260]  - relaying element #2
[10:21:22.260] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.260] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.260] signalConditionsASAP(NULL, pos=1) ... done
[10:21:22.260]  length: 3 (resolved future 1)
[10:21:22.260] Future #2
[10:21:22.260] result() for ClusterFuture ...
[10:21:22.260] - result already collected: FutureResult
[10:21:22.261] result() for ClusterFuture ... done
[10:21:22.261] result() for ClusterFuture ...
[10:21:22.261] - result already collected: FutureResult
[10:21:22.261] result() for ClusterFuture ... done
[10:21:22.261] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:22.261] - nx: 4
[10:21:22.261] - relay: TRUE
[10:21:22.261] - stdout: TRUE
[10:21:22.261] - signal: TRUE
[10:21:22.261] - resignal: FALSE
[10:21:22.261] - force: TRUE
[10:21:22.262] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.262] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.262]  - until=2
[10:21:22.262]  - relaying element #2
[10:21:22.262] result() for ClusterFuture ...
[10:21:22.262] - result already collected: FutureResult
[10:21:22.262] result() for ClusterFuture ... done
[10:21:22.262] result() for ClusterFuture ...
[10:21:22.262] - result already collected: FutureResult
[10:21:22.262] result() for ClusterFuture ... done
[10:21:22.263] result() for ClusterFuture ...
[10:21:22.263] - result already collected: FutureResult
[10:21:22.263] result() for ClusterFuture ... done
[10:21:22.263] result() for ClusterFuture ...
[10:21:22.263] - result already collected: FutureResult
[10:21:22.263] result() for ClusterFuture ... done
[10:21:22.263] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.263] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.263] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:22.263]  length: 2 (resolved future 2)
[10:21:22.264] Future #3
[10:21:22.264] result() for ClusterFuture ...
[10:21:22.264] - result already collected: FutureResult
[10:21:22.264] result() for ClusterFuture ... done
[10:21:22.264] result() for ClusterFuture ...
[10:21:22.264] - result already collected: FutureResult
[10:21:22.264] result() for ClusterFuture ... done
[10:21:22.264] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:22.264] - nx: 4
[10:21:22.264] - relay: TRUE
[10:21:22.265] - stdout: TRUE
[10:21:22.265] - signal: TRUE
[10:21:22.265] - resignal: FALSE
[10:21:22.265] - force: TRUE
[10:21:22.265] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.265] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.265]  - until=3
[10:21:22.265]  - relaying element #3
[10:21:22.265] result() for ClusterFuture ...
[10:21:22.265] - result already collected: FutureResult
[10:21:22.265] result() for ClusterFuture ... done
[10:21:22.266] result() for ClusterFuture ...
[10:21:22.266] - result already collected: FutureResult
[10:21:22.266] result() for ClusterFuture ... done
[10:21:22.266] result() for ClusterFuture ...
[10:21:22.266] - result already collected: FutureResult
[10:21:22.266] result() for ClusterFuture ... done
[10:21:22.266] result() for ClusterFuture ...
[10:21:22.266] - result already collected: FutureResult
[10:21:22.266] result() for ClusterFuture ... done
[10:21:22.266] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.266] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.267] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:22.267]  length: 1 (resolved future 3)
[10:21:22.288] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.288] - Validating connection of MultisessionFuture
[10:21:22.288] - received message: FutureResult
[10:21:22.288] - Received FutureResult
[10:21:22.289] - Erased future from FutureRegistry
[10:21:22.289] result() for ClusterFuture ...
[10:21:22.289] - result already collected: FutureResult
[10:21:22.289] result() for ClusterFuture ... done
[10:21:22.289] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.289] Future #4
[10:21:22.289] result() for ClusterFuture ...
[10:21:22.289] - result already collected: FutureResult
[10:21:22.289] result() for ClusterFuture ... done
[10:21:22.289] result() for ClusterFuture ...
[10:21:22.289] - result already collected: FutureResult
[10:21:22.290] result() for ClusterFuture ... done
[10:21:22.290] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:22.290] - nx: 4
[10:21:22.290] - relay: TRUE
[10:21:22.290] - stdout: TRUE
[10:21:22.290] - signal: TRUE
[10:21:22.290] - resignal: FALSE
[10:21:22.290] - force: TRUE
[10:21:22.290] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.290] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.291]  - until=4
[10:21:22.291]  - relaying element #4
[10:21:22.291] result() for ClusterFuture ...
[10:21:22.291] - result already collected: FutureResult
[10:21:22.291] result() for ClusterFuture ... done
[10:21:22.291] result() for ClusterFuture ...
[10:21:22.291] - result already collected: FutureResult
[10:21:22.291] result() for ClusterFuture ... done
[10:21:22.291] result() for ClusterFuture ...
[10:21:22.291] - result already collected: FutureResult
[10:21:22.291] result() for ClusterFuture ... done
[10:21:22.291] result() for ClusterFuture ...
[10:21:22.292] - result already collected: FutureResult
[10:21:22.292] result() for ClusterFuture ... done
[10:21:22.292] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.292] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.292] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:22.292]  length: 0 (resolved future 4)
[10:21:22.292] Relaying remaining futures
[10:21:22.292] signalConditionsASAP(NULL, pos=0) ...
[10:21:22.292] - nx: 4
[10:21:22.292] - relay: TRUE
[10:21:22.292] - stdout: TRUE
[10:21:22.292] - signal: TRUE
[10:21:22.293] - resignal: FALSE
[10:21:22.293] - force: TRUE
[10:21:22.293] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.293] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:22.293] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.293] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.293] signalConditionsASAP(NULL, pos=0) ... done
[10:21:22.293] resolve() on environment ... DONE
[10:21:22.293] result() for ClusterFuture ...
[10:21:22.293] - result already collected: FutureResult
[10:21:22.293] result() for ClusterFuture ... done
[10:21:22.294] result() for ClusterFuture ...
[10:21:22.294] - result already collected: FutureResult
[10:21:22.294] result() for ClusterFuture ... done
[10:21:22.294] result() for ClusterFuture ...
[10:21:22.294] - result already collected: FutureResult
[10:21:22.294] result() for ClusterFuture ... done
[10:21:22.294] result() for ClusterFuture ...
[10:21:22.294] - result already collected: FutureResult
[10:21:22.294] result() for ClusterFuture ... done
[10:21:22.294] result() for ClusterFuture ...
[10:21:22.294] - result already collected: FutureResult
[10:21:22.294] result() for ClusterFuture ... done
[10:21:22.295] result() for ClusterFuture ...
[10:21:22.295] - result already collected: FutureResult
[10:21:22.295] result() for ClusterFuture ... done
<environment: 0x55e8e69d7b38> 
Dimensions: c(1, 6)
[10:21:22.295] getGlobalsAndPackages() ...
[10:21:22.295] Searching for globals...
[10:21:22.296] 
[10:21:22.296] Searching for globals ... DONE
[10:21:22.296] - globals: [0] <none>
[10:21:22.296] getGlobalsAndPackages() ... DONE
[10:21:22.296] run() for ‘Future’ ...
[10:21:22.296] - state: ‘created’
[10:21:22.296] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.311] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.311] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.311]   - Field: ‘node’
[10:21:22.311]   - Field: ‘label’
[10:21:22.311]   - Field: ‘local’
[10:21:22.311]   - Field: ‘owner’
[10:21:22.311]   - Field: ‘envir’
[10:21:22.311]   - Field: ‘workers’
[10:21:22.311]   - Field: ‘packages’
[10:21:22.311]   - Field: ‘gc’
[10:21:22.312]   - Field: ‘conditions’
[10:21:22.312]   - Field: ‘persistent’
[10:21:22.312]   - Field: ‘expr’
[10:21:22.312]   - Field: ‘uuid’
[10:21:22.312]   - Field: ‘seed’
[10:21:22.312]   - Field: ‘version’
[10:21:22.312]   - Field: ‘result’
[10:21:22.312]   - Field: ‘asynchronous’
[10:21:22.312]   - Field: ‘calls’
[10:21:22.312]   - Field: ‘globals’
[10:21:22.312]   - Field: ‘stdout’
[10:21:22.313]   - Field: ‘earlySignal’
[10:21:22.313]   - Field: ‘lazy’
[10:21:22.313]   - Field: ‘state’
[10:21:22.313] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.313] - Launch lazy future ...
[10:21:22.313] Packages needed by the future expression (n = 0): <none>
[10:21:22.313] Packages needed by future strategies (n = 0): <none>
[10:21:22.314] {
[10:21:22.314]     {
[10:21:22.314]         {
[10:21:22.314]             ...future.startTime <- base::Sys.time()
[10:21:22.314]             {
[10:21:22.314]                 {
[10:21:22.314]                   {
[10:21:22.314]                     {
[10:21:22.314]                       base::local({
[10:21:22.314]                         has_future <- base::requireNamespace("future", 
[10:21:22.314]                           quietly = TRUE)
[10:21:22.314]                         if (has_future) {
[10:21:22.314]                           ns <- base::getNamespace("future")
[10:21:22.314]                           version <- ns[[".package"]][["version"]]
[10:21:22.314]                           if (is.null(version)) 
[10:21:22.314]                             version <- utils::packageVersion("future")
[10:21:22.314]                         }
[10:21:22.314]                         else {
[10:21:22.314]                           version <- NULL
[10:21:22.314]                         }
[10:21:22.314]                         if (!has_future || version < "1.8.0") {
[10:21:22.314]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.314]                             "", base::R.version$version.string), 
[10:21:22.314]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.314]                               "release", "version")], collapse = " "), 
[10:21:22.314]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.314]                             info)
[10:21:22.314]                           info <- base::paste(info, collapse = "; ")
[10:21:22.314]                           if (!has_future) {
[10:21:22.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.314]                               info)
[10:21:22.314]                           }
[10:21:22.314]                           else {
[10:21:22.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.314]                               info, version)
[10:21:22.314]                           }
[10:21:22.314]                           base::stop(msg)
[10:21:22.314]                         }
[10:21:22.314]                       })
[10:21:22.314]                     }
[10:21:22.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.314]                     base::options(mc.cores = 1L)
[10:21:22.314]                   }
[10:21:22.314]                   ...future.strategy.old <- future::plan("list")
[10:21:22.314]                   options(future.plan = NULL)
[10:21:22.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.314]                 }
[10:21:22.314]                 ...future.workdir <- getwd()
[10:21:22.314]             }
[10:21:22.314]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.314]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.314]         }
[10:21:22.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.314]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.314]             base::names(...future.oldOptions))
[10:21:22.314]     }
[10:21:22.314]     if (FALSE) {
[10:21:22.314]     }
[10:21:22.314]     else {
[10:21:22.314]         if (TRUE) {
[10:21:22.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.314]                 open = "w")
[10:21:22.314]         }
[10:21:22.314]         else {
[10:21:22.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.314]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.314]         }
[10:21:22.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.314]             base::sink(type = "output", split = FALSE)
[10:21:22.314]             base::close(...future.stdout)
[10:21:22.314]         }, add = TRUE)
[10:21:22.314]     }
[10:21:22.314]     ...future.frame <- base::sys.nframe()
[10:21:22.314]     ...future.conditions <- base::list()
[10:21:22.314]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.314]     if (FALSE) {
[10:21:22.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.314]     }
[10:21:22.314]     ...future.result <- base::tryCatch({
[10:21:22.314]         base::withCallingHandlers({
[10:21:22.314]             ...future.value <- base::withVisible(base::local({
[10:21:22.314]                 ...future.makeSendCondition <- base::local({
[10:21:22.314]                   sendCondition <- NULL
[10:21:22.314]                   function(frame = 1L) {
[10:21:22.314]                     if (is.function(sendCondition)) 
[10:21:22.314]                       return(sendCondition)
[10:21:22.314]                     ns <- getNamespace("parallel")
[10:21:22.314]                     if (exists("sendData", mode = "function", 
[10:21:22.314]                       envir = ns)) {
[10:21:22.314]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.314]                         envir = ns)
[10:21:22.314]                       envir <- sys.frame(frame)
[10:21:22.314]                       master <- NULL
[10:21:22.314]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.314]                         !identical(envir, emptyenv())) {
[10:21:22.314]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.314]                           inherits = FALSE)) {
[10:21:22.314]                           master <- get("master", mode = "list", 
[10:21:22.314]                             envir = envir, inherits = FALSE)
[10:21:22.314]                           if (inherits(master, c("SOCKnode", 
[10:21:22.314]                             "SOCK0node"))) {
[10:21:22.314]                             sendCondition <<- function(cond) {
[10:21:22.314]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.314]                                 success = TRUE)
[10:21:22.314]                               parallel_sendData(master, data)
[10:21:22.314]                             }
[10:21:22.314]                             return(sendCondition)
[10:21:22.314]                           }
[10:21:22.314]                         }
[10:21:22.314]                         frame <- frame + 1L
[10:21:22.314]                         envir <- sys.frame(frame)
[10:21:22.314]                       }
[10:21:22.314]                     }
[10:21:22.314]                     sendCondition <<- function(cond) NULL
[10:21:22.314]                   }
[10:21:22.314]                 })
[10:21:22.314]                 withCallingHandlers({
[10:21:22.314]                   2
[10:21:22.314]                 }, immediateCondition = function(cond) {
[10:21:22.314]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.314]                   sendCondition(cond)
[10:21:22.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.314]                   {
[10:21:22.314]                     inherits <- base::inherits
[10:21:22.314]                     invokeRestart <- base::invokeRestart
[10:21:22.314]                     is.null <- base::is.null
[10:21:22.314]                     muffled <- FALSE
[10:21:22.314]                     if (inherits(cond, "message")) {
[10:21:22.314]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.314]                       if (muffled) 
[10:21:22.314]                         invokeRestart("muffleMessage")
[10:21:22.314]                     }
[10:21:22.314]                     else if (inherits(cond, "warning")) {
[10:21:22.314]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.314]                       if (muffled) 
[10:21:22.314]                         invokeRestart("muffleWarning")
[10:21:22.314]                     }
[10:21:22.314]                     else if (inherits(cond, "condition")) {
[10:21:22.314]                       if (!is.null(pattern)) {
[10:21:22.314]                         computeRestarts <- base::computeRestarts
[10:21:22.314]                         grepl <- base::grepl
[10:21:22.314]                         restarts <- computeRestarts(cond)
[10:21:22.314]                         for (restart in restarts) {
[10:21:22.314]                           name <- restart$name
[10:21:22.314]                           if (is.null(name)) 
[10:21:22.314]                             next
[10:21:22.314]                           if (!grepl(pattern, name)) 
[10:21:22.314]                             next
[10:21:22.314]                           invokeRestart(restart)
[10:21:22.314]                           muffled <- TRUE
[10:21:22.314]                           break
[10:21:22.314]                         }
[10:21:22.314]                       }
[10:21:22.314]                     }
[10:21:22.314]                     invisible(muffled)
[10:21:22.314]                   }
[10:21:22.314]                   muffleCondition(cond)
[10:21:22.314]                 })
[10:21:22.314]             }))
[10:21:22.314]             future::FutureResult(value = ...future.value$value, 
[10:21:22.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.314]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.314]                     ...future.globalenv.names))
[10:21:22.314]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.314]         }, condition = base::local({
[10:21:22.314]             c <- base::c
[10:21:22.314]             inherits <- base::inherits
[10:21:22.314]             invokeRestart <- base::invokeRestart
[10:21:22.314]             length <- base::length
[10:21:22.314]             list <- base::list
[10:21:22.314]             seq.int <- base::seq.int
[10:21:22.314]             signalCondition <- base::signalCondition
[10:21:22.314]             sys.calls <- base::sys.calls
[10:21:22.314]             `[[` <- base::`[[`
[10:21:22.314]             `+` <- base::`+`
[10:21:22.314]             `<<-` <- base::`<<-`
[10:21:22.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.314]                   3L)]
[10:21:22.314]             }
[10:21:22.314]             function(cond) {
[10:21:22.314]                 is_error <- inherits(cond, "error")
[10:21:22.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.314]                   NULL)
[10:21:22.314]                 if (is_error) {
[10:21:22.314]                   sessionInformation <- function() {
[10:21:22.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.314]                       search = base::search(), system = base::Sys.info())
[10:21:22.314]                   }
[10:21:22.314]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.314]                     cond$call), session = sessionInformation(), 
[10:21:22.314]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.314]                   signalCondition(cond)
[10:21:22.314]                 }
[10:21:22.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.314]                 "immediateCondition"))) {
[10:21:22.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.314]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.314]                   if (TRUE && !signal) {
[10:21:22.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.314]                     {
[10:21:22.314]                       inherits <- base::inherits
[10:21:22.314]                       invokeRestart <- base::invokeRestart
[10:21:22.314]                       is.null <- base::is.null
[10:21:22.314]                       muffled <- FALSE
[10:21:22.314]                       if (inherits(cond, "message")) {
[10:21:22.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.314]                         if (muffled) 
[10:21:22.314]                           invokeRestart("muffleMessage")
[10:21:22.314]                       }
[10:21:22.314]                       else if (inherits(cond, "warning")) {
[10:21:22.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.314]                         if (muffled) 
[10:21:22.314]                           invokeRestart("muffleWarning")
[10:21:22.314]                       }
[10:21:22.314]                       else if (inherits(cond, "condition")) {
[10:21:22.314]                         if (!is.null(pattern)) {
[10:21:22.314]                           computeRestarts <- base::computeRestarts
[10:21:22.314]                           grepl <- base::grepl
[10:21:22.314]                           restarts <- computeRestarts(cond)
[10:21:22.314]                           for (restart in restarts) {
[10:21:22.314]                             name <- restart$name
[10:21:22.314]                             if (is.null(name)) 
[10:21:22.314]                               next
[10:21:22.314]                             if (!grepl(pattern, name)) 
[10:21:22.314]                               next
[10:21:22.314]                             invokeRestart(restart)
[10:21:22.314]                             muffled <- TRUE
[10:21:22.314]                             break
[10:21:22.314]                           }
[10:21:22.314]                         }
[10:21:22.314]                       }
[10:21:22.314]                       invisible(muffled)
[10:21:22.314]                     }
[10:21:22.314]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.314]                   }
[10:21:22.314]                 }
[10:21:22.314]                 else {
[10:21:22.314]                   if (TRUE) {
[10:21:22.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.314]                     {
[10:21:22.314]                       inherits <- base::inherits
[10:21:22.314]                       invokeRestart <- base::invokeRestart
[10:21:22.314]                       is.null <- base::is.null
[10:21:22.314]                       muffled <- FALSE
[10:21:22.314]                       if (inherits(cond, "message")) {
[10:21:22.314]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.314]                         if (muffled) 
[10:21:22.314]                           invokeRestart("muffleMessage")
[10:21:22.314]                       }
[10:21:22.314]                       else if (inherits(cond, "warning")) {
[10:21:22.314]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.314]                         if (muffled) 
[10:21:22.314]                           invokeRestart("muffleWarning")
[10:21:22.314]                       }
[10:21:22.314]                       else if (inherits(cond, "condition")) {
[10:21:22.314]                         if (!is.null(pattern)) {
[10:21:22.314]                           computeRestarts <- base::computeRestarts
[10:21:22.314]                           grepl <- base::grepl
[10:21:22.314]                           restarts <- computeRestarts(cond)
[10:21:22.314]                           for (restart in restarts) {
[10:21:22.314]                             name <- restart$name
[10:21:22.314]                             if (is.null(name)) 
[10:21:22.314]                               next
[10:21:22.314]                             if (!grepl(pattern, name)) 
[10:21:22.314]                               next
[10:21:22.314]                             invokeRestart(restart)
[10:21:22.314]                             muffled <- TRUE
[10:21:22.314]                             break
[10:21:22.314]                           }
[10:21:22.314]                         }
[10:21:22.314]                       }
[10:21:22.314]                       invisible(muffled)
[10:21:22.314]                     }
[10:21:22.314]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.314]                   }
[10:21:22.314]                 }
[10:21:22.314]             }
[10:21:22.314]         }))
[10:21:22.314]     }, error = function(ex) {
[10:21:22.314]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.314]                 ...future.rng), started = ...future.startTime, 
[10:21:22.314]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.314]             version = "1.8"), class = "FutureResult")
[10:21:22.314]     }, finally = {
[10:21:22.314]         if (!identical(...future.workdir, getwd())) 
[10:21:22.314]             setwd(...future.workdir)
[10:21:22.314]         {
[10:21:22.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.314]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.314]             }
[10:21:22.314]             base::options(...future.oldOptions)
[10:21:22.314]             if (.Platform$OS.type == "windows") {
[10:21:22.314]                 old_names <- names(...future.oldEnvVars)
[10:21:22.314]                 envs <- base::Sys.getenv()
[10:21:22.314]                 names <- names(envs)
[10:21:22.314]                 common <- intersect(names, old_names)
[10:21:22.314]                 added <- setdiff(names, old_names)
[10:21:22.314]                 removed <- setdiff(old_names, names)
[10:21:22.314]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.314]                   envs[common]]
[10:21:22.314]                 NAMES <- toupper(changed)
[10:21:22.314]                 args <- list()
[10:21:22.314]                 for (kk in seq_along(NAMES)) {
[10:21:22.314]                   name <- changed[[kk]]
[10:21:22.314]                   NAME <- NAMES[[kk]]
[10:21:22.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.314]                     next
[10:21:22.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.314]                 }
[10:21:22.314]                 NAMES <- toupper(added)
[10:21:22.314]                 for (kk in seq_along(NAMES)) {
[10:21:22.314]                   name <- added[[kk]]
[10:21:22.314]                   NAME <- NAMES[[kk]]
[10:21:22.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.314]                     next
[10:21:22.314]                   args[[name]] <- ""
[10:21:22.314]                 }
[10:21:22.314]                 NAMES <- toupper(removed)
[10:21:22.314]                 for (kk in seq_along(NAMES)) {
[10:21:22.314]                   name <- removed[[kk]]
[10:21:22.314]                   NAME <- NAMES[[kk]]
[10:21:22.314]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.314]                     next
[10:21:22.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.314]                 }
[10:21:22.314]                 if (length(args) > 0) 
[10:21:22.314]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.314]             }
[10:21:22.314]             else {
[10:21:22.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.314]             }
[10:21:22.314]             {
[10:21:22.314]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.314]                   0L) {
[10:21:22.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.314]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.314]                   base::options(opts)
[10:21:22.314]                 }
[10:21:22.314]                 {
[10:21:22.314]                   {
[10:21:22.314]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.314]                     NULL
[10:21:22.314]                   }
[10:21:22.314]                   options(future.plan = NULL)
[10:21:22.314]                   if (is.na(NA_character_)) 
[10:21:22.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.314]                     .init = FALSE)
[10:21:22.314]                 }
[10:21:22.314]             }
[10:21:22.314]         }
[10:21:22.314]     })
[10:21:22.314]     if (TRUE) {
[10:21:22.314]         base::sink(type = "output", split = FALSE)
[10:21:22.314]         if (TRUE) {
[10:21:22.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.314]         }
[10:21:22.314]         else {
[10:21:22.314]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.314]         }
[10:21:22.314]         base::close(...future.stdout)
[10:21:22.314]         ...future.stdout <- NULL
[10:21:22.314]     }
[10:21:22.314]     ...future.result$conditions <- ...future.conditions
[10:21:22.314]     ...future.result$finished <- base::Sys.time()
[10:21:22.314]     ...future.result
[10:21:22.314] }
[10:21:22.317] MultisessionFuture started
[10:21:22.317] - Launch lazy future ... done
[10:21:22.317] run() for ‘MultisessionFuture’ ... done
[10:21:22.317] getGlobalsAndPackages() ...
[10:21:22.317] Searching for globals...
[10:21:22.324] 
[10:21:22.324] Searching for globals ... DONE
[10:21:22.324] - globals: [0] <none>
[10:21:22.324] getGlobalsAndPackages() ... DONE
[10:21:22.325] run() for ‘Future’ ...
[10:21:22.325] - state: ‘created’
[10:21:22.325] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.339] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.339] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.339]   - Field: ‘node’
[10:21:22.339]   - Field: ‘label’
[10:21:22.340]   - Field: ‘local’
[10:21:22.340]   - Field: ‘owner’
[10:21:22.340]   - Field: ‘envir’
[10:21:22.340]   - Field: ‘workers’
[10:21:22.340]   - Field: ‘packages’
[10:21:22.340]   - Field: ‘gc’
[10:21:22.340]   - Field: ‘conditions’
[10:21:22.340]   - Field: ‘persistent’
[10:21:22.340]   - Field: ‘expr’
[10:21:22.340]   - Field: ‘uuid’
[10:21:22.340]   - Field: ‘seed’
[10:21:22.341]   - Field: ‘version’
[10:21:22.341]   - Field: ‘result’
[10:21:22.341]   - Field: ‘asynchronous’
[10:21:22.341]   - Field: ‘calls’
[10:21:22.341]   - Field: ‘globals’
[10:21:22.341]   - Field: ‘stdout’
[10:21:22.341]   - Field: ‘earlySignal’
[10:21:22.341]   - Field: ‘lazy’
[10:21:22.341]   - Field: ‘state’
[10:21:22.341] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.341] - Launch lazy future ...
[10:21:22.342] Packages needed by the future expression (n = 0): <none>
[10:21:22.342] Packages needed by future strategies (n = 0): <none>
[10:21:22.342] {
[10:21:22.342]     {
[10:21:22.342]         {
[10:21:22.342]             ...future.startTime <- base::Sys.time()
[10:21:22.342]             {
[10:21:22.342]                 {
[10:21:22.342]                   {
[10:21:22.342]                     {
[10:21:22.342]                       base::local({
[10:21:22.342]                         has_future <- base::requireNamespace("future", 
[10:21:22.342]                           quietly = TRUE)
[10:21:22.342]                         if (has_future) {
[10:21:22.342]                           ns <- base::getNamespace("future")
[10:21:22.342]                           version <- ns[[".package"]][["version"]]
[10:21:22.342]                           if (is.null(version)) 
[10:21:22.342]                             version <- utils::packageVersion("future")
[10:21:22.342]                         }
[10:21:22.342]                         else {
[10:21:22.342]                           version <- NULL
[10:21:22.342]                         }
[10:21:22.342]                         if (!has_future || version < "1.8.0") {
[10:21:22.342]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.342]                             "", base::R.version$version.string), 
[10:21:22.342]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.342]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.342]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.342]                               "release", "version")], collapse = " "), 
[10:21:22.342]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.342]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.342]                             info)
[10:21:22.342]                           info <- base::paste(info, collapse = "; ")
[10:21:22.342]                           if (!has_future) {
[10:21:22.342]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.342]                               info)
[10:21:22.342]                           }
[10:21:22.342]                           else {
[10:21:22.342]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.342]                               info, version)
[10:21:22.342]                           }
[10:21:22.342]                           base::stop(msg)
[10:21:22.342]                         }
[10:21:22.342]                       })
[10:21:22.342]                     }
[10:21:22.342]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.342]                     base::options(mc.cores = 1L)
[10:21:22.342]                   }
[10:21:22.342]                   ...future.strategy.old <- future::plan("list")
[10:21:22.342]                   options(future.plan = NULL)
[10:21:22.342]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.342]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.342]                 }
[10:21:22.342]                 ...future.workdir <- getwd()
[10:21:22.342]             }
[10:21:22.342]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.342]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.342]         }
[10:21:22.342]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.342]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.342]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.342]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.342]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.342]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.342]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.342]             base::names(...future.oldOptions))
[10:21:22.342]     }
[10:21:22.342]     if (FALSE) {
[10:21:22.342]     }
[10:21:22.342]     else {
[10:21:22.342]         if (TRUE) {
[10:21:22.342]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.342]                 open = "w")
[10:21:22.342]         }
[10:21:22.342]         else {
[10:21:22.342]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.342]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.342]         }
[10:21:22.342]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.342]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.342]             base::sink(type = "output", split = FALSE)
[10:21:22.342]             base::close(...future.stdout)
[10:21:22.342]         }, add = TRUE)
[10:21:22.342]     }
[10:21:22.342]     ...future.frame <- base::sys.nframe()
[10:21:22.342]     ...future.conditions <- base::list()
[10:21:22.342]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.342]     if (FALSE) {
[10:21:22.342]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.342]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.342]     }
[10:21:22.342]     ...future.result <- base::tryCatch({
[10:21:22.342]         base::withCallingHandlers({
[10:21:22.342]             ...future.value <- base::withVisible(base::local({
[10:21:22.342]                 ...future.makeSendCondition <- base::local({
[10:21:22.342]                   sendCondition <- NULL
[10:21:22.342]                   function(frame = 1L) {
[10:21:22.342]                     if (is.function(sendCondition)) 
[10:21:22.342]                       return(sendCondition)
[10:21:22.342]                     ns <- getNamespace("parallel")
[10:21:22.342]                     if (exists("sendData", mode = "function", 
[10:21:22.342]                       envir = ns)) {
[10:21:22.342]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.342]                         envir = ns)
[10:21:22.342]                       envir <- sys.frame(frame)
[10:21:22.342]                       master <- NULL
[10:21:22.342]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.342]                         !identical(envir, emptyenv())) {
[10:21:22.342]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.342]                           inherits = FALSE)) {
[10:21:22.342]                           master <- get("master", mode = "list", 
[10:21:22.342]                             envir = envir, inherits = FALSE)
[10:21:22.342]                           if (inherits(master, c("SOCKnode", 
[10:21:22.342]                             "SOCK0node"))) {
[10:21:22.342]                             sendCondition <<- function(cond) {
[10:21:22.342]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.342]                                 success = TRUE)
[10:21:22.342]                               parallel_sendData(master, data)
[10:21:22.342]                             }
[10:21:22.342]                             return(sendCondition)
[10:21:22.342]                           }
[10:21:22.342]                         }
[10:21:22.342]                         frame <- frame + 1L
[10:21:22.342]                         envir <- sys.frame(frame)
[10:21:22.342]                       }
[10:21:22.342]                     }
[10:21:22.342]                     sendCondition <<- function(cond) NULL
[10:21:22.342]                   }
[10:21:22.342]                 })
[10:21:22.342]                 withCallingHandlers({
[10:21:22.342]                   NULL
[10:21:22.342]                 }, immediateCondition = function(cond) {
[10:21:22.342]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.342]                   sendCondition(cond)
[10:21:22.342]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.342]                   {
[10:21:22.342]                     inherits <- base::inherits
[10:21:22.342]                     invokeRestart <- base::invokeRestart
[10:21:22.342]                     is.null <- base::is.null
[10:21:22.342]                     muffled <- FALSE
[10:21:22.342]                     if (inherits(cond, "message")) {
[10:21:22.342]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.342]                       if (muffled) 
[10:21:22.342]                         invokeRestart("muffleMessage")
[10:21:22.342]                     }
[10:21:22.342]                     else if (inherits(cond, "warning")) {
[10:21:22.342]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.342]                       if (muffled) 
[10:21:22.342]                         invokeRestart("muffleWarning")
[10:21:22.342]                     }
[10:21:22.342]                     else if (inherits(cond, "condition")) {
[10:21:22.342]                       if (!is.null(pattern)) {
[10:21:22.342]                         computeRestarts <- base::computeRestarts
[10:21:22.342]                         grepl <- base::grepl
[10:21:22.342]                         restarts <- computeRestarts(cond)
[10:21:22.342]                         for (restart in restarts) {
[10:21:22.342]                           name <- restart$name
[10:21:22.342]                           if (is.null(name)) 
[10:21:22.342]                             next
[10:21:22.342]                           if (!grepl(pattern, name)) 
[10:21:22.342]                             next
[10:21:22.342]                           invokeRestart(restart)
[10:21:22.342]                           muffled <- TRUE
[10:21:22.342]                           break
[10:21:22.342]                         }
[10:21:22.342]                       }
[10:21:22.342]                     }
[10:21:22.342]                     invisible(muffled)
[10:21:22.342]                   }
[10:21:22.342]                   muffleCondition(cond)
[10:21:22.342]                 })
[10:21:22.342]             }))
[10:21:22.342]             future::FutureResult(value = ...future.value$value, 
[10:21:22.342]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.342]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.342]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.342]                     ...future.globalenv.names))
[10:21:22.342]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.342]         }, condition = base::local({
[10:21:22.342]             c <- base::c
[10:21:22.342]             inherits <- base::inherits
[10:21:22.342]             invokeRestart <- base::invokeRestart
[10:21:22.342]             length <- base::length
[10:21:22.342]             list <- base::list
[10:21:22.342]             seq.int <- base::seq.int
[10:21:22.342]             signalCondition <- base::signalCondition
[10:21:22.342]             sys.calls <- base::sys.calls
[10:21:22.342]             `[[` <- base::`[[`
[10:21:22.342]             `+` <- base::`+`
[10:21:22.342]             `<<-` <- base::`<<-`
[10:21:22.342]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.342]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.342]                   3L)]
[10:21:22.342]             }
[10:21:22.342]             function(cond) {
[10:21:22.342]                 is_error <- inherits(cond, "error")
[10:21:22.342]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.342]                   NULL)
[10:21:22.342]                 if (is_error) {
[10:21:22.342]                   sessionInformation <- function() {
[10:21:22.342]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.342]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.342]                       search = base::search(), system = base::Sys.info())
[10:21:22.342]                   }
[10:21:22.342]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.342]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.342]                     cond$call), session = sessionInformation(), 
[10:21:22.342]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.342]                   signalCondition(cond)
[10:21:22.342]                 }
[10:21:22.342]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.342]                 "immediateCondition"))) {
[10:21:22.342]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.342]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.342]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.342]                   if (TRUE && !signal) {
[10:21:22.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.342]                     {
[10:21:22.342]                       inherits <- base::inherits
[10:21:22.342]                       invokeRestart <- base::invokeRestart
[10:21:22.342]                       is.null <- base::is.null
[10:21:22.342]                       muffled <- FALSE
[10:21:22.342]                       if (inherits(cond, "message")) {
[10:21:22.342]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.342]                         if (muffled) 
[10:21:22.342]                           invokeRestart("muffleMessage")
[10:21:22.342]                       }
[10:21:22.342]                       else if (inherits(cond, "warning")) {
[10:21:22.342]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.342]                         if (muffled) 
[10:21:22.342]                           invokeRestart("muffleWarning")
[10:21:22.342]                       }
[10:21:22.342]                       else if (inherits(cond, "condition")) {
[10:21:22.342]                         if (!is.null(pattern)) {
[10:21:22.342]                           computeRestarts <- base::computeRestarts
[10:21:22.342]                           grepl <- base::grepl
[10:21:22.342]                           restarts <- computeRestarts(cond)
[10:21:22.342]                           for (restart in restarts) {
[10:21:22.342]                             name <- restart$name
[10:21:22.342]                             if (is.null(name)) 
[10:21:22.342]                               next
[10:21:22.342]                             if (!grepl(pattern, name)) 
[10:21:22.342]                               next
[10:21:22.342]                             invokeRestart(restart)
[10:21:22.342]                             muffled <- TRUE
[10:21:22.342]                             break
[10:21:22.342]                           }
[10:21:22.342]                         }
[10:21:22.342]                       }
[10:21:22.342]                       invisible(muffled)
[10:21:22.342]                     }
[10:21:22.342]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.342]                   }
[10:21:22.342]                 }
[10:21:22.342]                 else {
[10:21:22.342]                   if (TRUE) {
[10:21:22.342]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.342]                     {
[10:21:22.342]                       inherits <- base::inherits
[10:21:22.342]                       invokeRestart <- base::invokeRestart
[10:21:22.342]                       is.null <- base::is.null
[10:21:22.342]                       muffled <- FALSE
[10:21:22.342]                       if (inherits(cond, "message")) {
[10:21:22.342]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.342]                         if (muffled) 
[10:21:22.342]                           invokeRestart("muffleMessage")
[10:21:22.342]                       }
[10:21:22.342]                       else if (inherits(cond, "warning")) {
[10:21:22.342]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.342]                         if (muffled) 
[10:21:22.342]                           invokeRestart("muffleWarning")
[10:21:22.342]                       }
[10:21:22.342]                       else if (inherits(cond, "condition")) {
[10:21:22.342]                         if (!is.null(pattern)) {
[10:21:22.342]                           computeRestarts <- base::computeRestarts
[10:21:22.342]                           grepl <- base::grepl
[10:21:22.342]                           restarts <- computeRestarts(cond)
[10:21:22.342]                           for (restart in restarts) {
[10:21:22.342]                             name <- restart$name
[10:21:22.342]                             if (is.null(name)) 
[10:21:22.342]                               next
[10:21:22.342]                             if (!grepl(pattern, name)) 
[10:21:22.342]                               next
[10:21:22.342]                             invokeRestart(restart)
[10:21:22.342]                             muffled <- TRUE
[10:21:22.342]                             break
[10:21:22.342]                           }
[10:21:22.342]                         }
[10:21:22.342]                       }
[10:21:22.342]                       invisible(muffled)
[10:21:22.342]                     }
[10:21:22.342]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.342]                   }
[10:21:22.342]                 }
[10:21:22.342]             }
[10:21:22.342]         }))
[10:21:22.342]     }, error = function(ex) {
[10:21:22.342]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.342]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.342]                 ...future.rng), started = ...future.startTime, 
[10:21:22.342]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.342]             version = "1.8"), class = "FutureResult")
[10:21:22.342]     }, finally = {
[10:21:22.342]         if (!identical(...future.workdir, getwd())) 
[10:21:22.342]             setwd(...future.workdir)
[10:21:22.342]         {
[10:21:22.342]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.342]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.342]             }
[10:21:22.342]             base::options(...future.oldOptions)
[10:21:22.342]             if (.Platform$OS.type == "windows") {
[10:21:22.342]                 old_names <- names(...future.oldEnvVars)
[10:21:22.342]                 envs <- base::Sys.getenv()
[10:21:22.342]                 names <- names(envs)
[10:21:22.342]                 common <- intersect(names, old_names)
[10:21:22.342]                 added <- setdiff(names, old_names)
[10:21:22.342]                 removed <- setdiff(old_names, names)
[10:21:22.342]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.342]                   envs[common]]
[10:21:22.342]                 NAMES <- toupper(changed)
[10:21:22.342]                 args <- list()
[10:21:22.342]                 for (kk in seq_along(NAMES)) {
[10:21:22.342]                   name <- changed[[kk]]
[10:21:22.342]                   NAME <- NAMES[[kk]]
[10:21:22.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.342]                     next
[10:21:22.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.342]                 }
[10:21:22.342]                 NAMES <- toupper(added)
[10:21:22.342]                 for (kk in seq_along(NAMES)) {
[10:21:22.342]                   name <- added[[kk]]
[10:21:22.342]                   NAME <- NAMES[[kk]]
[10:21:22.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.342]                     next
[10:21:22.342]                   args[[name]] <- ""
[10:21:22.342]                 }
[10:21:22.342]                 NAMES <- toupper(removed)
[10:21:22.342]                 for (kk in seq_along(NAMES)) {
[10:21:22.342]                   name <- removed[[kk]]
[10:21:22.342]                   NAME <- NAMES[[kk]]
[10:21:22.342]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.342]                     next
[10:21:22.342]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.342]                 }
[10:21:22.342]                 if (length(args) > 0) 
[10:21:22.342]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.342]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.342]             }
[10:21:22.342]             else {
[10:21:22.342]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.342]             }
[10:21:22.342]             {
[10:21:22.342]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.342]                   0L) {
[10:21:22.342]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.342]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.342]                   base::options(opts)
[10:21:22.342]                 }
[10:21:22.342]                 {
[10:21:22.342]                   {
[10:21:22.342]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.342]                     NULL
[10:21:22.342]                   }
[10:21:22.342]                   options(future.plan = NULL)
[10:21:22.342]                   if (is.na(NA_character_)) 
[10:21:22.342]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.342]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.342]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.342]                     .init = FALSE)
[10:21:22.342]                 }
[10:21:22.342]             }
[10:21:22.342]         }
[10:21:22.342]     })
[10:21:22.342]     if (TRUE) {
[10:21:22.342]         base::sink(type = "output", split = FALSE)
[10:21:22.342]         if (TRUE) {
[10:21:22.342]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.342]         }
[10:21:22.342]         else {
[10:21:22.342]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.342]         }
[10:21:22.342]         base::close(...future.stdout)
[10:21:22.342]         ...future.stdout <- NULL
[10:21:22.342]     }
[10:21:22.342]     ...future.result$conditions <- ...future.conditions
[10:21:22.342]     ...future.result$finished <- base::Sys.time()
[10:21:22.342]     ...future.result
[10:21:22.342] }
[10:21:22.347] MultisessionFuture started
[10:21:22.347] - Launch lazy future ... done
[10:21:22.347] run() for ‘MultisessionFuture’ ... done
[10:21:22.347] getGlobalsAndPackages() ...
[10:21:22.347] Searching for globals...
[10:21:22.348] - globals found: [1] ‘{’
[10:21:22.348] Searching for globals ... DONE
[10:21:22.348] Resolving globals: FALSE
[10:21:22.349] 
[10:21:22.349] 
[10:21:22.349] getGlobalsAndPackages() ... DONE
[10:21:22.349] run() for ‘Future’ ...
[10:21:22.349] - state: ‘created’
[10:21:22.349] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.364] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.364] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.364]   - Field: ‘node’
[10:21:22.364]   - Field: ‘label’
[10:21:22.364]   - Field: ‘local’
[10:21:22.364]   - Field: ‘owner’
[10:21:22.364]   - Field: ‘envir’
[10:21:22.364]   - Field: ‘workers’
[10:21:22.364]   - Field: ‘packages’
[10:21:22.364]   - Field: ‘gc’
[10:21:22.365]   - Field: ‘conditions’
[10:21:22.365]   - Field: ‘persistent’
[10:21:22.365]   - Field: ‘expr’
[10:21:22.365]   - Field: ‘uuid’
[10:21:22.365]   - Field: ‘seed’
[10:21:22.365]   - Field: ‘version’
[10:21:22.365]   - Field: ‘result’
[10:21:22.365]   - Field: ‘asynchronous’
[10:21:22.365]   - Field: ‘calls’
[10:21:22.365]   - Field: ‘globals’
[10:21:22.365]   - Field: ‘stdout’
[10:21:22.365]   - Field: ‘earlySignal’
[10:21:22.366]   - Field: ‘lazy’
[10:21:22.366]   - Field: ‘state’
[10:21:22.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.366] - Launch lazy future ...
[10:21:22.366] Packages needed by the future expression (n = 0): <none>
[10:21:22.366] Packages needed by future strategies (n = 0): <none>
[10:21:22.367] {
[10:21:22.367]     {
[10:21:22.367]         {
[10:21:22.367]             ...future.startTime <- base::Sys.time()
[10:21:22.367]             {
[10:21:22.367]                 {
[10:21:22.367]                   {
[10:21:22.367]                     {
[10:21:22.367]                       base::local({
[10:21:22.367]                         has_future <- base::requireNamespace("future", 
[10:21:22.367]                           quietly = TRUE)
[10:21:22.367]                         if (has_future) {
[10:21:22.367]                           ns <- base::getNamespace("future")
[10:21:22.367]                           version <- ns[[".package"]][["version"]]
[10:21:22.367]                           if (is.null(version)) 
[10:21:22.367]                             version <- utils::packageVersion("future")
[10:21:22.367]                         }
[10:21:22.367]                         else {
[10:21:22.367]                           version <- NULL
[10:21:22.367]                         }
[10:21:22.367]                         if (!has_future || version < "1.8.0") {
[10:21:22.367]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.367]                             "", base::R.version$version.string), 
[10:21:22.367]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.367]                               "release", "version")], collapse = " "), 
[10:21:22.367]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.367]                             info)
[10:21:22.367]                           info <- base::paste(info, collapse = "; ")
[10:21:22.367]                           if (!has_future) {
[10:21:22.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.367]                               info)
[10:21:22.367]                           }
[10:21:22.367]                           else {
[10:21:22.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.367]                               info, version)
[10:21:22.367]                           }
[10:21:22.367]                           base::stop(msg)
[10:21:22.367]                         }
[10:21:22.367]                       })
[10:21:22.367]                     }
[10:21:22.367]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.367]                     base::options(mc.cores = 1L)
[10:21:22.367]                   }
[10:21:22.367]                   ...future.strategy.old <- future::plan("list")
[10:21:22.367]                   options(future.plan = NULL)
[10:21:22.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.367]                 }
[10:21:22.367]                 ...future.workdir <- getwd()
[10:21:22.367]             }
[10:21:22.367]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.367]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.367]         }
[10:21:22.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.367]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.367]             base::names(...future.oldOptions))
[10:21:22.367]     }
[10:21:22.367]     if (FALSE) {
[10:21:22.367]     }
[10:21:22.367]     else {
[10:21:22.367]         if (TRUE) {
[10:21:22.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.367]                 open = "w")
[10:21:22.367]         }
[10:21:22.367]         else {
[10:21:22.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.367]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.367]         }
[10:21:22.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.367]             base::sink(type = "output", split = FALSE)
[10:21:22.367]             base::close(...future.stdout)
[10:21:22.367]         }, add = TRUE)
[10:21:22.367]     }
[10:21:22.367]     ...future.frame <- base::sys.nframe()
[10:21:22.367]     ...future.conditions <- base::list()
[10:21:22.367]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.367]     if (FALSE) {
[10:21:22.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.367]     }
[10:21:22.367]     ...future.result <- base::tryCatch({
[10:21:22.367]         base::withCallingHandlers({
[10:21:22.367]             ...future.value <- base::withVisible(base::local({
[10:21:22.367]                 ...future.makeSendCondition <- base::local({
[10:21:22.367]                   sendCondition <- NULL
[10:21:22.367]                   function(frame = 1L) {
[10:21:22.367]                     if (is.function(sendCondition)) 
[10:21:22.367]                       return(sendCondition)
[10:21:22.367]                     ns <- getNamespace("parallel")
[10:21:22.367]                     if (exists("sendData", mode = "function", 
[10:21:22.367]                       envir = ns)) {
[10:21:22.367]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.367]                         envir = ns)
[10:21:22.367]                       envir <- sys.frame(frame)
[10:21:22.367]                       master <- NULL
[10:21:22.367]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.367]                         !identical(envir, emptyenv())) {
[10:21:22.367]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.367]                           inherits = FALSE)) {
[10:21:22.367]                           master <- get("master", mode = "list", 
[10:21:22.367]                             envir = envir, inherits = FALSE)
[10:21:22.367]                           if (inherits(master, c("SOCKnode", 
[10:21:22.367]                             "SOCK0node"))) {
[10:21:22.367]                             sendCondition <<- function(cond) {
[10:21:22.367]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.367]                                 success = TRUE)
[10:21:22.367]                               parallel_sendData(master, data)
[10:21:22.367]                             }
[10:21:22.367]                             return(sendCondition)
[10:21:22.367]                           }
[10:21:22.367]                         }
[10:21:22.367]                         frame <- frame + 1L
[10:21:22.367]                         envir <- sys.frame(frame)
[10:21:22.367]                       }
[10:21:22.367]                     }
[10:21:22.367]                     sendCondition <<- function(cond) NULL
[10:21:22.367]                   }
[10:21:22.367]                 })
[10:21:22.367]                 withCallingHandlers({
[10:21:22.367]                   {
[10:21:22.367]                     4
[10:21:22.367]                   }
[10:21:22.367]                 }, immediateCondition = function(cond) {
[10:21:22.367]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.367]                   sendCondition(cond)
[10:21:22.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.367]                   {
[10:21:22.367]                     inherits <- base::inherits
[10:21:22.367]                     invokeRestart <- base::invokeRestart
[10:21:22.367]                     is.null <- base::is.null
[10:21:22.367]                     muffled <- FALSE
[10:21:22.367]                     if (inherits(cond, "message")) {
[10:21:22.367]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.367]                       if (muffled) 
[10:21:22.367]                         invokeRestart("muffleMessage")
[10:21:22.367]                     }
[10:21:22.367]                     else if (inherits(cond, "warning")) {
[10:21:22.367]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.367]                       if (muffled) 
[10:21:22.367]                         invokeRestart("muffleWarning")
[10:21:22.367]                     }
[10:21:22.367]                     else if (inherits(cond, "condition")) {
[10:21:22.367]                       if (!is.null(pattern)) {
[10:21:22.367]                         computeRestarts <- base::computeRestarts
[10:21:22.367]                         grepl <- base::grepl
[10:21:22.367]                         restarts <- computeRestarts(cond)
[10:21:22.367]                         for (restart in restarts) {
[10:21:22.367]                           name <- restart$name
[10:21:22.367]                           if (is.null(name)) 
[10:21:22.367]                             next
[10:21:22.367]                           if (!grepl(pattern, name)) 
[10:21:22.367]                             next
[10:21:22.367]                           invokeRestart(restart)
[10:21:22.367]                           muffled <- TRUE
[10:21:22.367]                           break
[10:21:22.367]                         }
[10:21:22.367]                       }
[10:21:22.367]                     }
[10:21:22.367]                     invisible(muffled)
[10:21:22.367]                   }
[10:21:22.367]                   muffleCondition(cond)
[10:21:22.367]                 })
[10:21:22.367]             }))
[10:21:22.367]             future::FutureResult(value = ...future.value$value, 
[10:21:22.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.367]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.367]                     ...future.globalenv.names))
[10:21:22.367]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.367]         }, condition = base::local({
[10:21:22.367]             c <- base::c
[10:21:22.367]             inherits <- base::inherits
[10:21:22.367]             invokeRestart <- base::invokeRestart
[10:21:22.367]             length <- base::length
[10:21:22.367]             list <- base::list
[10:21:22.367]             seq.int <- base::seq.int
[10:21:22.367]             signalCondition <- base::signalCondition
[10:21:22.367]             sys.calls <- base::sys.calls
[10:21:22.367]             `[[` <- base::`[[`
[10:21:22.367]             `+` <- base::`+`
[10:21:22.367]             `<<-` <- base::`<<-`
[10:21:22.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.367]                   3L)]
[10:21:22.367]             }
[10:21:22.367]             function(cond) {
[10:21:22.367]                 is_error <- inherits(cond, "error")
[10:21:22.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.367]                   NULL)
[10:21:22.367]                 if (is_error) {
[10:21:22.367]                   sessionInformation <- function() {
[10:21:22.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.367]                       search = base::search(), system = base::Sys.info())
[10:21:22.367]                   }
[10:21:22.367]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.367]                     cond$call), session = sessionInformation(), 
[10:21:22.367]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.367]                   signalCondition(cond)
[10:21:22.367]                 }
[10:21:22.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.367]                 "immediateCondition"))) {
[10:21:22.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.367]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.367]                   if (TRUE && !signal) {
[10:21:22.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.367]                     {
[10:21:22.367]                       inherits <- base::inherits
[10:21:22.367]                       invokeRestart <- base::invokeRestart
[10:21:22.367]                       is.null <- base::is.null
[10:21:22.367]                       muffled <- FALSE
[10:21:22.367]                       if (inherits(cond, "message")) {
[10:21:22.367]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.367]                         if (muffled) 
[10:21:22.367]                           invokeRestart("muffleMessage")
[10:21:22.367]                       }
[10:21:22.367]                       else if (inherits(cond, "warning")) {
[10:21:22.367]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.367]                         if (muffled) 
[10:21:22.367]                           invokeRestart("muffleWarning")
[10:21:22.367]                       }
[10:21:22.367]                       else if (inherits(cond, "condition")) {
[10:21:22.367]                         if (!is.null(pattern)) {
[10:21:22.367]                           computeRestarts <- base::computeRestarts
[10:21:22.367]                           grepl <- base::grepl
[10:21:22.367]                           restarts <- computeRestarts(cond)
[10:21:22.367]                           for (restart in restarts) {
[10:21:22.367]                             name <- restart$name
[10:21:22.367]                             if (is.null(name)) 
[10:21:22.367]                               next
[10:21:22.367]                             if (!grepl(pattern, name)) 
[10:21:22.367]                               next
[10:21:22.367]                             invokeRestart(restart)
[10:21:22.367]                             muffled <- TRUE
[10:21:22.367]                             break
[10:21:22.367]                           }
[10:21:22.367]                         }
[10:21:22.367]                       }
[10:21:22.367]                       invisible(muffled)
[10:21:22.367]                     }
[10:21:22.367]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.367]                   }
[10:21:22.367]                 }
[10:21:22.367]                 else {
[10:21:22.367]                   if (TRUE) {
[10:21:22.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.367]                     {
[10:21:22.367]                       inherits <- base::inherits
[10:21:22.367]                       invokeRestart <- base::invokeRestart
[10:21:22.367]                       is.null <- base::is.null
[10:21:22.367]                       muffled <- FALSE
[10:21:22.367]                       if (inherits(cond, "message")) {
[10:21:22.367]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.367]                         if (muffled) 
[10:21:22.367]                           invokeRestart("muffleMessage")
[10:21:22.367]                       }
[10:21:22.367]                       else if (inherits(cond, "warning")) {
[10:21:22.367]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.367]                         if (muffled) 
[10:21:22.367]                           invokeRestart("muffleWarning")
[10:21:22.367]                       }
[10:21:22.367]                       else if (inherits(cond, "condition")) {
[10:21:22.367]                         if (!is.null(pattern)) {
[10:21:22.367]                           computeRestarts <- base::computeRestarts
[10:21:22.367]                           grepl <- base::grepl
[10:21:22.367]                           restarts <- computeRestarts(cond)
[10:21:22.367]                           for (restart in restarts) {
[10:21:22.367]                             name <- restart$name
[10:21:22.367]                             if (is.null(name)) 
[10:21:22.367]                               next
[10:21:22.367]                             if (!grepl(pattern, name)) 
[10:21:22.367]                               next
[10:21:22.367]                             invokeRestart(restart)
[10:21:22.367]                             muffled <- TRUE
[10:21:22.367]                             break
[10:21:22.367]                           }
[10:21:22.367]                         }
[10:21:22.367]                       }
[10:21:22.367]                       invisible(muffled)
[10:21:22.367]                     }
[10:21:22.367]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.367]                   }
[10:21:22.367]                 }
[10:21:22.367]             }
[10:21:22.367]         }))
[10:21:22.367]     }, error = function(ex) {
[10:21:22.367]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.367]                 ...future.rng), started = ...future.startTime, 
[10:21:22.367]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.367]             version = "1.8"), class = "FutureResult")
[10:21:22.367]     }, finally = {
[10:21:22.367]         if (!identical(...future.workdir, getwd())) 
[10:21:22.367]             setwd(...future.workdir)
[10:21:22.367]         {
[10:21:22.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.367]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.367]             }
[10:21:22.367]             base::options(...future.oldOptions)
[10:21:22.367]             if (.Platform$OS.type == "windows") {
[10:21:22.367]                 old_names <- names(...future.oldEnvVars)
[10:21:22.367]                 envs <- base::Sys.getenv()
[10:21:22.367]                 names <- names(envs)
[10:21:22.367]                 common <- intersect(names, old_names)
[10:21:22.367]                 added <- setdiff(names, old_names)
[10:21:22.367]                 removed <- setdiff(old_names, names)
[10:21:22.367]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.367]                   envs[common]]
[10:21:22.367]                 NAMES <- toupper(changed)
[10:21:22.367]                 args <- list()
[10:21:22.367]                 for (kk in seq_along(NAMES)) {
[10:21:22.367]                   name <- changed[[kk]]
[10:21:22.367]                   NAME <- NAMES[[kk]]
[10:21:22.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.367]                     next
[10:21:22.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.367]                 }
[10:21:22.367]                 NAMES <- toupper(added)
[10:21:22.367]                 for (kk in seq_along(NAMES)) {
[10:21:22.367]                   name <- added[[kk]]
[10:21:22.367]                   NAME <- NAMES[[kk]]
[10:21:22.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.367]                     next
[10:21:22.367]                   args[[name]] <- ""
[10:21:22.367]                 }
[10:21:22.367]                 NAMES <- toupper(removed)
[10:21:22.367]                 for (kk in seq_along(NAMES)) {
[10:21:22.367]                   name <- removed[[kk]]
[10:21:22.367]                   NAME <- NAMES[[kk]]
[10:21:22.367]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.367]                     next
[10:21:22.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.367]                 }
[10:21:22.367]                 if (length(args) > 0) 
[10:21:22.367]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.367]             }
[10:21:22.367]             else {
[10:21:22.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.367]             }
[10:21:22.367]             {
[10:21:22.367]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.367]                   0L) {
[10:21:22.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.367]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.367]                   base::options(opts)
[10:21:22.367]                 }
[10:21:22.367]                 {
[10:21:22.367]                   {
[10:21:22.367]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.367]                     NULL
[10:21:22.367]                   }
[10:21:22.367]                   options(future.plan = NULL)
[10:21:22.367]                   if (is.na(NA_character_)) 
[10:21:22.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.367]                     .init = FALSE)
[10:21:22.367]                 }
[10:21:22.367]             }
[10:21:22.367]         }
[10:21:22.367]     })
[10:21:22.367]     if (TRUE) {
[10:21:22.367]         base::sink(type = "output", split = FALSE)
[10:21:22.367]         if (TRUE) {
[10:21:22.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.367]         }
[10:21:22.367]         else {
[10:21:22.367]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.367]         }
[10:21:22.367]         base::close(...future.stdout)
[10:21:22.367]         ...future.stdout <- NULL
[10:21:22.367]     }
[10:21:22.367]     ...future.result$conditions <- ...future.conditions
[10:21:22.367]     ...future.result$finished <- base::Sys.time()
[10:21:22.367]     ...future.result
[10:21:22.367] }
[10:21:22.369] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:22.380] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.380] - Validating connection of MultisessionFuture
[10:21:22.380] - received message: FutureResult
[10:21:22.380] - Received FutureResult
[10:21:22.380] - Erased future from FutureRegistry
[10:21:22.380] result() for ClusterFuture ...
[10:21:22.380] - result already collected: FutureResult
[10:21:22.381] result() for ClusterFuture ... done
[10:21:22.381] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.381] result() for ClusterFuture ...
[10:21:22.381] - result already collected: FutureResult
[10:21:22.381] result() for ClusterFuture ... done
[10:21:22.381] result() for ClusterFuture ...
[10:21:22.381] - result already collected: FutureResult
[10:21:22.381] result() for ClusterFuture ... done
[10:21:22.382] MultisessionFuture started
[10:21:22.382] - Launch lazy future ... done
[10:21:22.382] run() for ‘MultisessionFuture’ ... done
<environment: 0x55e8e7260ce0> 
<environment: 0x55e8e38ae140> 
[10:21:22.389] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.389] - Validating connection of MultisessionFuture
[10:21:22.389] - received message: FutureResult
[10:21:22.390] - Received FutureResult
[10:21:22.390] - Erased future from FutureRegistry
[10:21:22.390] result() for ClusterFuture ...
[10:21:22.390] - result already collected: FutureResult
[10:21:22.390] result() for ClusterFuture ... done
[10:21:22.390] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:22.402] resolve() on environment ...
[10:21:22.402]  recursive: 0
[10:21:22.402]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:22.403] signalConditionsASAP(numeric, pos=1) ...
[10:21:22.403] - nx: 4
[10:21:22.403] - relay: TRUE
[10:21:22.403] - stdout: TRUE
[10:21:22.403] - signal: TRUE
[10:21:22.403] - resignal: FALSE
[10:21:22.403] - force: TRUE
[10:21:22.403] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.403] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.403]  - until=2
[10:21:22.403]  - relaying element #2
[10:21:22.404] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.404] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.404] signalConditionsASAP(NULL, pos=1) ... done
[10:21:22.404]  length: 3 (resolved future 1)
[10:21:22.404] Future #2
[10:21:22.404] result() for ClusterFuture ...
[10:21:22.404] - result already collected: FutureResult
[10:21:22.404] result() for ClusterFuture ... done
[10:21:22.404] result() for ClusterFuture ...
[10:21:22.404] - result already collected: FutureResult
[10:21:22.404] result() for ClusterFuture ... done
[10:21:22.405] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:22.405] - nx: 4
[10:21:22.405] - relay: TRUE
[10:21:22.405] - stdout: TRUE
[10:21:22.405] - signal: TRUE
[10:21:22.405] - resignal: FALSE
[10:21:22.405] - force: TRUE
[10:21:22.405] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.405] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.405]  - until=2
[10:21:22.405]  - relaying element #2
[10:21:22.405] result() for ClusterFuture ...
[10:21:22.405] - result already collected: FutureResult
[10:21:22.406] result() for ClusterFuture ... done
[10:21:22.406] result() for ClusterFuture ...
[10:21:22.406] - result already collected: FutureResult
[10:21:22.406] result() for ClusterFuture ... done
[10:21:22.406] result() for ClusterFuture ...
[10:21:22.406] - result already collected: FutureResult
[10:21:22.406] result() for ClusterFuture ... done
[10:21:22.406] result() for ClusterFuture ...
[10:21:22.406] - result already collected: FutureResult
[10:21:22.406] result() for ClusterFuture ... done
[10:21:22.406] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.407] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.407] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:22.407]  length: 2 (resolved future 2)
[10:21:22.407] Future #3
[10:21:22.407] result() for ClusterFuture ...
[10:21:22.407] - result already collected: FutureResult
[10:21:22.407] result() for ClusterFuture ... done
[10:21:22.407] result() for ClusterFuture ...
[10:21:22.407] - result already collected: FutureResult
[10:21:22.407] result() for ClusterFuture ... done
[10:21:22.407] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:22.407] - nx: 4
[10:21:22.408] - relay: TRUE
[10:21:22.408] - stdout: TRUE
[10:21:22.408] - signal: TRUE
[10:21:22.408] - resignal: FALSE
[10:21:22.408] - force: TRUE
[10:21:22.408] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.408] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.408]  - until=3
[10:21:22.408]  - relaying element #3
[10:21:22.408] result() for ClusterFuture ...
[10:21:22.408] - result already collected: FutureResult
[10:21:22.408] result() for ClusterFuture ... done
[10:21:22.409] result() for ClusterFuture ...
[10:21:22.409] - result already collected: FutureResult
[10:21:22.409] result() for ClusterFuture ... done
[10:21:22.409] result() for ClusterFuture ...
[10:21:22.409] - result already collected: FutureResult
[10:21:22.409] result() for ClusterFuture ... done
[10:21:22.409] result() for ClusterFuture ...
[10:21:22.409] - result already collected: FutureResult
[10:21:22.409] result() for ClusterFuture ... done
[10:21:22.409] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.409] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.409] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:22.410]  length: 1 (resolved future 3)
[10:21:22.431] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.431] - Validating connection of MultisessionFuture
[10:21:22.431] - received message: FutureResult
[10:21:22.431] - Received FutureResult
[10:21:22.431] - Erased future from FutureRegistry
[10:21:22.431] result() for ClusterFuture ...
[10:21:22.431] - result already collected: FutureResult
[10:21:22.432] result() for ClusterFuture ... done
[10:21:22.432] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.432] Future #4
[10:21:22.432] result() for ClusterFuture ...
[10:21:22.432] - result already collected: FutureResult
[10:21:22.432] result() for ClusterFuture ... done
[10:21:22.432] result() for ClusterFuture ...
[10:21:22.432] - result already collected: FutureResult
[10:21:22.432] result() for ClusterFuture ... done
[10:21:22.432] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:22.432] - nx: 4
[10:21:22.432] - relay: TRUE
[10:21:22.433] - stdout: TRUE
[10:21:22.433] - signal: TRUE
[10:21:22.433] - resignal: FALSE
[10:21:22.433] - force: TRUE
[10:21:22.433] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.433] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.433]  - until=4
[10:21:22.433]  - relaying element #4
[10:21:22.433] result() for ClusterFuture ...
[10:21:22.433] - result already collected: FutureResult
[10:21:22.433] result() for ClusterFuture ... done
[10:21:22.433] result() for ClusterFuture ...
[10:21:22.434] - result already collected: FutureResult
[10:21:22.434] result() for ClusterFuture ... done
[10:21:22.434] result() for ClusterFuture ...
[10:21:22.434] - result already collected: FutureResult
[10:21:22.434] result() for ClusterFuture ... done
[10:21:22.434] result() for ClusterFuture ...
[10:21:22.434] - result already collected: FutureResult
[10:21:22.434] result() for ClusterFuture ... done
[10:21:22.434] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.434] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.434] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:22.435]  length: 0 (resolved future 4)
[10:21:22.435] Relaying remaining futures
[10:21:22.435] signalConditionsASAP(NULL, pos=0) ...
[10:21:22.435] - nx: 4
[10:21:22.435] - relay: TRUE
[10:21:22.435] - stdout: TRUE
[10:21:22.435] - signal: TRUE
[10:21:22.435] - resignal: FALSE
[10:21:22.435] - force: TRUE
[10:21:22.435] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.435] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:22.436] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.436] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.436] signalConditionsASAP(NULL, pos=0) ... done
[10:21:22.436] resolve() on environment ... DONE
[10:21:22.436] result() for ClusterFuture ...
[10:21:22.436] - result already collected: FutureResult
[10:21:22.436] result() for ClusterFuture ... done
[10:21:22.436] result() for ClusterFuture ...
[10:21:22.436] - result already collected: FutureResult
[10:21:22.436] result() for ClusterFuture ... done
[10:21:22.437] result() for ClusterFuture ...
[10:21:22.437] - result already collected: FutureResult
[10:21:22.437] result() for ClusterFuture ... done
[10:21:22.437] result() for ClusterFuture ...
[10:21:22.437] - result already collected: FutureResult
[10:21:22.437] result() for ClusterFuture ... done
[10:21:22.437] result() for ClusterFuture ...
[10:21:22.437] - result already collected: FutureResult
[10:21:22.437] result() for ClusterFuture ... done
[10:21:22.437] result() for ClusterFuture ...
[10:21:22.437] - result already collected: FutureResult
[10:21:22.437] result() for ClusterFuture ... done
<environment: 0x55e8e443b868> 
Dimensions: c(2, 3)
[10:21:22.438] getGlobalsAndPackages() ...
[10:21:22.438] Searching for globals...
[10:21:22.438] 
[10:21:22.438] Searching for globals ... DONE
[10:21:22.439] - globals: [0] <none>
[10:21:22.439] getGlobalsAndPackages() ... DONE
[10:21:22.439] run() for ‘Future’ ...
[10:21:22.439] - state: ‘created’
[10:21:22.439] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.453] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.453]   - Field: ‘node’
[10:21:22.453]   - Field: ‘label’
[10:21:22.454]   - Field: ‘local’
[10:21:22.454]   - Field: ‘owner’
[10:21:22.454]   - Field: ‘envir’
[10:21:22.454]   - Field: ‘workers’
[10:21:22.454]   - Field: ‘packages’
[10:21:22.454]   - Field: ‘gc’
[10:21:22.454]   - Field: ‘conditions’
[10:21:22.454]   - Field: ‘persistent’
[10:21:22.454]   - Field: ‘expr’
[10:21:22.454]   - Field: ‘uuid’
[10:21:22.454]   - Field: ‘seed’
[10:21:22.455]   - Field: ‘version’
[10:21:22.455]   - Field: ‘result’
[10:21:22.455]   - Field: ‘asynchronous’
[10:21:22.455]   - Field: ‘calls’
[10:21:22.455]   - Field: ‘globals’
[10:21:22.455]   - Field: ‘stdout’
[10:21:22.455]   - Field: ‘earlySignal’
[10:21:22.455]   - Field: ‘lazy’
[10:21:22.455]   - Field: ‘state’
[10:21:22.455] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.455] - Launch lazy future ...
[10:21:22.456] Packages needed by the future expression (n = 0): <none>
[10:21:22.456] Packages needed by future strategies (n = 0): <none>
[10:21:22.456] {
[10:21:22.456]     {
[10:21:22.456]         {
[10:21:22.456]             ...future.startTime <- base::Sys.time()
[10:21:22.456]             {
[10:21:22.456]                 {
[10:21:22.456]                   {
[10:21:22.456]                     {
[10:21:22.456]                       base::local({
[10:21:22.456]                         has_future <- base::requireNamespace("future", 
[10:21:22.456]                           quietly = TRUE)
[10:21:22.456]                         if (has_future) {
[10:21:22.456]                           ns <- base::getNamespace("future")
[10:21:22.456]                           version <- ns[[".package"]][["version"]]
[10:21:22.456]                           if (is.null(version)) 
[10:21:22.456]                             version <- utils::packageVersion("future")
[10:21:22.456]                         }
[10:21:22.456]                         else {
[10:21:22.456]                           version <- NULL
[10:21:22.456]                         }
[10:21:22.456]                         if (!has_future || version < "1.8.0") {
[10:21:22.456]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.456]                             "", base::R.version$version.string), 
[10:21:22.456]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.456]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.456]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.456]                               "release", "version")], collapse = " "), 
[10:21:22.456]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.456]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.456]                             info)
[10:21:22.456]                           info <- base::paste(info, collapse = "; ")
[10:21:22.456]                           if (!has_future) {
[10:21:22.456]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.456]                               info)
[10:21:22.456]                           }
[10:21:22.456]                           else {
[10:21:22.456]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.456]                               info, version)
[10:21:22.456]                           }
[10:21:22.456]                           base::stop(msg)
[10:21:22.456]                         }
[10:21:22.456]                       })
[10:21:22.456]                     }
[10:21:22.456]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.456]                     base::options(mc.cores = 1L)
[10:21:22.456]                   }
[10:21:22.456]                   ...future.strategy.old <- future::plan("list")
[10:21:22.456]                   options(future.plan = NULL)
[10:21:22.456]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.456]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.456]                 }
[10:21:22.456]                 ...future.workdir <- getwd()
[10:21:22.456]             }
[10:21:22.456]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.456]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.456]         }
[10:21:22.456]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.456]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.456]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.456]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.456]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.456]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.456]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.456]             base::names(...future.oldOptions))
[10:21:22.456]     }
[10:21:22.456]     if (FALSE) {
[10:21:22.456]     }
[10:21:22.456]     else {
[10:21:22.456]         if (TRUE) {
[10:21:22.456]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.456]                 open = "w")
[10:21:22.456]         }
[10:21:22.456]         else {
[10:21:22.456]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.456]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.456]         }
[10:21:22.456]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.456]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.456]             base::sink(type = "output", split = FALSE)
[10:21:22.456]             base::close(...future.stdout)
[10:21:22.456]         }, add = TRUE)
[10:21:22.456]     }
[10:21:22.456]     ...future.frame <- base::sys.nframe()
[10:21:22.456]     ...future.conditions <- base::list()
[10:21:22.456]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.456]     if (FALSE) {
[10:21:22.456]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.456]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.456]     }
[10:21:22.456]     ...future.result <- base::tryCatch({
[10:21:22.456]         base::withCallingHandlers({
[10:21:22.456]             ...future.value <- base::withVisible(base::local({
[10:21:22.456]                 ...future.makeSendCondition <- base::local({
[10:21:22.456]                   sendCondition <- NULL
[10:21:22.456]                   function(frame = 1L) {
[10:21:22.456]                     if (is.function(sendCondition)) 
[10:21:22.456]                       return(sendCondition)
[10:21:22.456]                     ns <- getNamespace("parallel")
[10:21:22.456]                     if (exists("sendData", mode = "function", 
[10:21:22.456]                       envir = ns)) {
[10:21:22.456]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.456]                         envir = ns)
[10:21:22.456]                       envir <- sys.frame(frame)
[10:21:22.456]                       master <- NULL
[10:21:22.456]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.456]                         !identical(envir, emptyenv())) {
[10:21:22.456]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.456]                           inherits = FALSE)) {
[10:21:22.456]                           master <- get("master", mode = "list", 
[10:21:22.456]                             envir = envir, inherits = FALSE)
[10:21:22.456]                           if (inherits(master, c("SOCKnode", 
[10:21:22.456]                             "SOCK0node"))) {
[10:21:22.456]                             sendCondition <<- function(cond) {
[10:21:22.456]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.456]                                 success = TRUE)
[10:21:22.456]                               parallel_sendData(master, data)
[10:21:22.456]                             }
[10:21:22.456]                             return(sendCondition)
[10:21:22.456]                           }
[10:21:22.456]                         }
[10:21:22.456]                         frame <- frame + 1L
[10:21:22.456]                         envir <- sys.frame(frame)
[10:21:22.456]                       }
[10:21:22.456]                     }
[10:21:22.456]                     sendCondition <<- function(cond) NULL
[10:21:22.456]                   }
[10:21:22.456]                 })
[10:21:22.456]                 withCallingHandlers({
[10:21:22.456]                   2
[10:21:22.456]                 }, immediateCondition = function(cond) {
[10:21:22.456]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.456]                   sendCondition(cond)
[10:21:22.456]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.456]                   {
[10:21:22.456]                     inherits <- base::inherits
[10:21:22.456]                     invokeRestart <- base::invokeRestart
[10:21:22.456]                     is.null <- base::is.null
[10:21:22.456]                     muffled <- FALSE
[10:21:22.456]                     if (inherits(cond, "message")) {
[10:21:22.456]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.456]                       if (muffled) 
[10:21:22.456]                         invokeRestart("muffleMessage")
[10:21:22.456]                     }
[10:21:22.456]                     else if (inherits(cond, "warning")) {
[10:21:22.456]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.456]                       if (muffled) 
[10:21:22.456]                         invokeRestart("muffleWarning")
[10:21:22.456]                     }
[10:21:22.456]                     else if (inherits(cond, "condition")) {
[10:21:22.456]                       if (!is.null(pattern)) {
[10:21:22.456]                         computeRestarts <- base::computeRestarts
[10:21:22.456]                         grepl <- base::grepl
[10:21:22.456]                         restarts <- computeRestarts(cond)
[10:21:22.456]                         for (restart in restarts) {
[10:21:22.456]                           name <- restart$name
[10:21:22.456]                           if (is.null(name)) 
[10:21:22.456]                             next
[10:21:22.456]                           if (!grepl(pattern, name)) 
[10:21:22.456]                             next
[10:21:22.456]                           invokeRestart(restart)
[10:21:22.456]                           muffled <- TRUE
[10:21:22.456]                           break
[10:21:22.456]                         }
[10:21:22.456]                       }
[10:21:22.456]                     }
[10:21:22.456]                     invisible(muffled)
[10:21:22.456]                   }
[10:21:22.456]                   muffleCondition(cond)
[10:21:22.456]                 })
[10:21:22.456]             }))
[10:21:22.456]             future::FutureResult(value = ...future.value$value, 
[10:21:22.456]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.456]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.456]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.456]                     ...future.globalenv.names))
[10:21:22.456]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.456]         }, condition = base::local({
[10:21:22.456]             c <- base::c
[10:21:22.456]             inherits <- base::inherits
[10:21:22.456]             invokeRestart <- base::invokeRestart
[10:21:22.456]             length <- base::length
[10:21:22.456]             list <- base::list
[10:21:22.456]             seq.int <- base::seq.int
[10:21:22.456]             signalCondition <- base::signalCondition
[10:21:22.456]             sys.calls <- base::sys.calls
[10:21:22.456]             `[[` <- base::`[[`
[10:21:22.456]             `+` <- base::`+`
[10:21:22.456]             `<<-` <- base::`<<-`
[10:21:22.456]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.456]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.456]                   3L)]
[10:21:22.456]             }
[10:21:22.456]             function(cond) {
[10:21:22.456]                 is_error <- inherits(cond, "error")
[10:21:22.456]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.456]                   NULL)
[10:21:22.456]                 if (is_error) {
[10:21:22.456]                   sessionInformation <- function() {
[10:21:22.456]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.456]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.456]                       search = base::search(), system = base::Sys.info())
[10:21:22.456]                   }
[10:21:22.456]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.456]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.456]                     cond$call), session = sessionInformation(), 
[10:21:22.456]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.456]                   signalCondition(cond)
[10:21:22.456]                 }
[10:21:22.456]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.456]                 "immediateCondition"))) {
[10:21:22.456]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.456]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.456]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.456]                   if (TRUE && !signal) {
[10:21:22.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.456]                     {
[10:21:22.456]                       inherits <- base::inherits
[10:21:22.456]                       invokeRestart <- base::invokeRestart
[10:21:22.456]                       is.null <- base::is.null
[10:21:22.456]                       muffled <- FALSE
[10:21:22.456]                       if (inherits(cond, "message")) {
[10:21:22.456]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.456]                         if (muffled) 
[10:21:22.456]                           invokeRestart("muffleMessage")
[10:21:22.456]                       }
[10:21:22.456]                       else if (inherits(cond, "warning")) {
[10:21:22.456]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.456]                         if (muffled) 
[10:21:22.456]                           invokeRestart("muffleWarning")
[10:21:22.456]                       }
[10:21:22.456]                       else if (inherits(cond, "condition")) {
[10:21:22.456]                         if (!is.null(pattern)) {
[10:21:22.456]                           computeRestarts <- base::computeRestarts
[10:21:22.456]                           grepl <- base::grepl
[10:21:22.456]                           restarts <- computeRestarts(cond)
[10:21:22.456]                           for (restart in restarts) {
[10:21:22.456]                             name <- restart$name
[10:21:22.456]                             if (is.null(name)) 
[10:21:22.456]                               next
[10:21:22.456]                             if (!grepl(pattern, name)) 
[10:21:22.456]                               next
[10:21:22.456]                             invokeRestart(restart)
[10:21:22.456]                             muffled <- TRUE
[10:21:22.456]                             break
[10:21:22.456]                           }
[10:21:22.456]                         }
[10:21:22.456]                       }
[10:21:22.456]                       invisible(muffled)
[10:21:22.456]                     }
[10:21:22.456]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.456]                   }
[10:21:22.456]                 }
[10:21:22.456]                 else {
[10:21:22.456]                   if (TRUE) {
[10:21:22.456]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.456]                     {
[10:21:22.456]                       inherits <- base::inherits
[10:21:22.456]                       invokeRestart <- base::invokeRestart
[10:21:22.456]                       is.null <- base::is.null
[10:21:22.456]                       muffled <- FALSE
[10:21:22.456]                       if (inherits(cond, "message")) {
[10:21:22.456]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.456]                         if (muffled) 
[10:21:22.456]                           invokeRestart("muffleMessage")
[10:21:22.456]                       }
[10:21:22.456]                       else if (inherits(cond, "warning")) {
[10:21:22.456]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.456]                         if (muffled) 
[10:21:22.456]                           invokeRestart("muffleWarning")
[10:21:22.456]                       }
[10:21:22.456]                       else if (inherits(cond, "condition")) {
[10:21:22.456]                         if (!is.null(pattern)) {
[10:21:22.456]                           computeRestarts <- base::computeRestarts
[10:21:22.456]                           grepl <- base::grepl
[10:21:22.456]                           restarts <- computeRestarts(cond)
[10:21:22.456]                           for (restart in restarts) {
[10:21:22.456]                             name <- restart$name
[10:21:22.456]                             if (is.null(name)) 
[10:21:22.456]                               next
[10:21:22.456]                             if (!grepl(pattern, name)) 
[10:21:22.456]                               next
[10:21:22.456]                             invokeRestart(restart)
[10:21:22.456]                             muffled <- TRUE
[10:21:22.456]                             break
[10:21:22.456]                           }
[10:21:22.456]                         }
[10:21:22.456]                       }
[10:21:22.456]                       invisible(muffled)
[10:21:22.456]                     }
[10:21:22.456]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.456]                   }
[10:21:22.456]                 }
[10:21:22.456]             }
[10:21:22.456]         }))
[10:21:22.456]     }, error = function(ex) {
[10:21:22.456]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.456]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.456]                 ...future.rng), started = ...future.startTime, 
[10:21:22.456]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.456]             version = "1.8"), class = "FutureResult")
[10:21:22.456]     }, finally = {
[10:21:22.456]         if (!identical(...future.workdir, getwd())) 
[10:21:22.456]             setwd(...future.workdir)
[10:21:22.456]         {
[10:21:22.456]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.456]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.456]             }
[10:21:22.456]             base::options(...future.oldOptions)
[10:21:22.456]             if (.Platform$OS.type == "windows") {
[10:21:22.456]                 old_names <- names(...future.oldEnvVars)
[10:21:22.456]                 envs <- base::Sys.getenv()
[10:21:22.456]                 names <- names(envs)
[10:21:22.456]                 common <- intersect(names, old_names)
[10:21:22.456]                 added <- setdiff(names, old_names)
[10:21:22.456]                 removed <- setdiff(old_names, names)
[10:21:22.456]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.456]                   envs[common]]
[10:21:22.456]                 NAMES <- toupper(changed)
[10:21:22.456]                 args <- list()
[10:21:22.456]                 for (kk in seq_along(NAMES)) {
[10:21:22.456]                   name <- changed[[kk]]
[10:21:22.456]                   NAME <- NAMES[[kk]]
[10:21:22.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.456]                     next
[10:21:22.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.456]                 }
[10:21:22.456]                 NAMES <- toupper(added)
[10:21:22.456]                 for (kk in seq_along(NAMES)) {
[10:21:22.456]                   name <- added[[kk]]
[10:21:22.456]                   NAME <- NAMES[[kk]]
[10:21:22.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.456]                     next
[10:21:22.456]                   args[[name]] <- ""
[10:21:22.456]                 }
[10:21:22.456]                 NAMES <- toupper(removed)
[10:21:22.456]                 for (kk in seq_along(NAMES)) {
[10:21:22.456]                   name <- removed[[kk]]
[10:21:22.456]                   NAME <- NAMES[[kk]]
[10:21:22.456]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.456]                     next
[10:21:22.456]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.456]                 }
[10:21:22.456]                 if (length(args) > 0) 
[10:21:22.456]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.456]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.456]             }
[10:21:22.456]             else {
[10:21:22.456]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.456]             }
[10:21:22.456]             {
[10:21:22.456]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.456]                   0L) {
[10:21:22.456]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.456]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.456]                   base::options(opts)
[10:21:22.456]                 }
[10:21:22.456]                 {
[10:21:22.456]                   {
[10:21:22.456]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.456]                     NULL
[10:21:22.456]                   }
[10:21:22.456]                   options(future.plan = NULL)
[10:21:22.456]                   if (is.na(NA_character_)) 
[10:21:22.456]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.456]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.456]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.456]                     .init = FALSE)
[10:21:22.456]                 }
[10:21:22.456]             }
[10:21:22.456]         }
[10:21:22.456]     })
[10:21:22.456]     if (TRUE) {
[10:21:22.456]         base::sink(type = "output", split = FALSE)
[10:21:22.456]         if (TRUE) {
[10:21:22.456]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.456]         }
[10:21:22.456]         else {
[10:21:22.456]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.456]         }
[10:21:22.456]         base::close(...future.stdout)
[10:21:22.456]         ...future.stdout <- NULL
[10:21:22.456]     }
[10:21:22.456]     ...future.result$conditions <- ...future.conditions
[10:21:22.456]     ...future.result$finished <- base::Sys.time()
[10:21:22.456]     ...future.result
[10:21:22.456] }
[10:21:22.459] MultisessionFuture started
[10:21:22.459] - Launch lazy future ... done
[10:21:22.459] run() for ‘MultisessionFuture’ ... done
[10:21:22.460] getGlobalsAndPackages() ...
[10:21:22.460] Searching for globals...
[10:21:22.460] 
[10:21:22.460] Searching for globals ... DONE
[10:21:22.460] - globals: [0] <none>
[10:21:22.460] getGlobalsAndPackages() ... DONE
[10:21:22.461] run() for ‘Future’ ...
[10:21:22.461] - state: ‘created’
[10:21:22.461] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.475] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.475] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.475]   - Field: ‘node’
[10:21:22.475]   - Field: ‘label’
[10:21:22.475]   - Field: ‘local’
[10:21:22.475]   - Field: ‘owner’
[10:21:22.475]   - Field: ‘envir’
[10:21:22.475]   - Field: ‘workers’
[10:21:22.475]   - Field: ‘packages’
[10:21:22.475]   - Field: ‘gc’
[10:21:22.476]   - Field: ‘conditions’
[10:21:22.476]   - Field: ‘persistent’
[10:21:22.476]   - Field: ‘expr’
[10:21:22.476]   - Field: ‘uuid’
[10:21:22.476]   - Field: ‘seed’
[10:21:22.476]   - Field: ‘version’
[10:21:22.476]   - Field: ‘result’
[10:21:22.476]   - Field: ‘asynchronous’
[10:21:22.476]   - Field: ‘calls’
[10:21:22.476]   - Field: ‘globals’
[10:21:22.476]   - Field: ‘stdout’
[10:21:22.476]   - Field: ‘earlySignal’
[10:21:22.477]   - Field: ‘lazy’
[10:21:22.477]   - Field: ‘state’
[10:21:22.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.477] - Launch lazy future ...
[10:21:22.477] Packages needed by the future expression (n = 0): <none>
[10:21:22.477] Packages needed by future strategies (n = 0): <none>
[10:21:22.478] {
[10:21:22.478]     {
[10:21:22.478]         {
[10:21:22.478]             ...future.startTime <- base::Sys.time()
[10:21:22.478]             {
[10:21:22.478]                 {
[10:21:22.478]                   {
[10:21:22.478]                     {
[10:21:22.478]                       base::local({
[10:21:22.478]                         has_future <- base::requireNamespace("future", 
[10:21:22.478]                           quietly = TRUE)
[10:21:22.478]                         if (has_future) {
[10:21:22.478]                           ns <- base::getNamespace("future")
[10:21:22.478]                           version <- ns[[".package"]][["version"]]
[10:21:22.478]                           if (is.null(version)) 
[10:21:22.478]                             version <- utils::packageVersion("future")
[10:21:22.478]                         }
[10:21:22.478]                         else {
[10:21:22.478]                           version <- NULL
[10:21:22.478]                         }
[10:21:22.478]                         if (!has_future || version < "1.8.0") {
[10:21:22.478]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.478]                             "", base::R.version$version.string), 
[10:21:22.478]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.478]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.478]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.478]                               "release", "version")], collapse = " "), 
[10:21:22.478]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.478]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.478]                             info)
[10:21:22.478]                           info <- base::paste(info, collapse = "; ")
[10:21:22.478]                           if (!has_future) {
[10:21:22.478]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.478]                               info)
[10:21:22.478]                           }
[10:21:22.478]                           else {
[10:21:22.478]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.478]                               info, version)
[10:21:22.478]                           }
[10:21:22.478]                           base::stop(msg)
[10:21:22.478]                         }
[10:21:22.478]                       })
[10:21:22.478]                     }
[10:21:22.478]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.478]                     base::options(mc.cores = 1L)
[10:21:22.478]                   }
[10:21:22.478]                   ...future.strategy.old <- future::plan("list")
[10:21:22.478]                   options(future.plan = NULL)
[10:21:22.478]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.478]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.478]                 }
[10:21:22.478]                 ...future.workdir <- getwd()
[10:21:22.478]             }
[10:21:22.478]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.478]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.478]         }
[10:21:22.478]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.478]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.478]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.478]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.478]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.478]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.478]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.478]             base::names(...future.oldOptions))
[10:21:22.478]     }
[10:21:22.478]     if (FALSE) {
[10:21:22.478]     }
[10:21:22.478]     else {
[10:21:22.478]         if (TRUE) {
[10:21:22.478]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.478]                 open = "w")
[10:21:22.478]         }
[10:21:22.478]         else {
[10:21:22.478]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.478]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.478]         }
[10:21:22.478]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.478]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.478]             base::sink(type = "output", split = FALSE)
[10:21:22.478]             base::close(...future.stdout)
[10:21:22.478]         }, add = TRUE)
[10:21:22.478]     }
[10:21:22.478]     ...future.frame <- base::sys.nframe()
[10:21:22.478]     ...future.conditions <- base::list()
[10:21:22.478]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.478]     if (FALSE) {
[10:21:22.478]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.478]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.478]     }
[10:21:22.478]     ...future.result <- base::tryCatch({
[10:21:22.478]         base::withCallingHandlers({
[10:21:22.478]             ...future.value <- base::withVisible(base::local({
[10:21:22.478]                 ...future.makeSendCondition <- base::local({
[10:21:22.478]                   sendCondition <- NULL
[10:21:22.478]                   function(frame = 1L) {
[10:21:22.478]                     if (is.function(sendCondition)) 
[10:21:22.478]                       return(sendCondition)
[10:21:22.478]                     ns <- getNamespace("parallel")
[10:21:22.478]                     if (exists("sendData", mode = "function", 
[10:21:22.478]                       envir = ns)) {
[10:21:22.478]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.478]                         envir = ns)
[10:21:22.478]                       envir <- sys.frame(frame)
[10:21:22.478]                       master <- NULL
[10:21:22.478]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.478]                         !identical(envir, emptyenv())) {
[10:21:22.478]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.478]                           inherits = FALSE)) {
[10:21:22.478]                           master <- get("master", mode = "list", 
[10:21:22.478]                             envir = envir, inherits = FALSE)
[10:21:22.478]                           if (inherits(master, c("SOCKnode", 
[10:21:22.478]                             "SOCK0node"))) {
[10:21:22.478]                             sendCondition <<- function(cond) {
[10:21:22.478]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.478]                                 success = TRUE)
[10:21:22.478]                               parallel_sendData(master, data)
[10:21:22.478]                             }
[10:21:22.478]                             return(sendCondition)
[10:21:22.478]                           }
[10:21:22.478]                         }
[10:21:22.478]                         frame <- frame + 1L
[10:21:22.478]                         envir <- sys.frame(frame)
[10:21:22.478]                       }
[10:21:22.478]                     }
[10:21:22.478]                     sendCondition <<- function(cond) NULL
[10:21:22.478]                   }
[10:21:22.478]                 })
[10:21:22.478]                 withCallingHandlers({
[10:21:22.478]                   NULL
[10:21:22.478]                 }, immediateCondition = function(cond) {
[10:21:22.478]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.478]                   sendCondition(cond)
[10:21:22.478]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.478]                   {
[10:21:22.478]                     inherits <- base::inherits
[10:21:22.478]                     invokeRestart <- base::invokeRestart
[10:21:22.478]                     is.null <- base::is.null
[10:21:22.478]                     muffled <- FALSE
[10:21:22.478]                     if (inherits(cond, "message")) {
[10:21:22.478]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.478]                       if (muffled) 
[10:21:22.478]                         invokeRestart("muffleMessage")
[10:21:22.478]                     }
[10:21:22.478]                     else if (inherits(cond, "warning")) {
[10:21:22.478]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.478]                       if (muffled) 
[10:21:22.478]                         invokeRestart("muffleWarning")
[10:21:22.478]                     }
[10:21:22.478]                     else if (inherits(cond, "condition")) {
[10:21:22.478]                       if (!is.null(pattern)) {
[10:21:22.478]                         computeRestarts <- base::computeRestarts
[10:21:22.478]                         grepl <- base::grepl
[10:21:22.478]                         restarts <- computeRestarts(cond)
[10:21:22.478]                         for (restart in restarts) {
[10:21:22.478]                           name <- restart$name
[10:21:22.478]                           if (is.null(name)) 
[10:21:22.478]                             next
[10:21:22.478]                           if (!grepl(pattern, name)) 
[10:21:22.478]                             next
[10:21:22.478]                           invokeRestart(restart)
[10:21:22.478]                           muffled <- TRUE
[10:21:22.478]                           break
[10:21:22.478]                         }
[10:21:22.478]                       }
[10:21:22.478]                     }
[10:21:22.478]                     invisible(muffled)
[10:21:22.478]                   }
[10:21:22.478]                   muffleCondition(cond)
[10:21:22.478]                 })
[10:21:22.478]             }))
[10:21:22.478]             future::FutureResult(value = ...future.value$value, 
[10:21:22.478]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.478]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.478]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.478]                     ...future.globalenv.names))
[10:21:22.478]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.478]         }, condition = base::local({
[10:21:22.478]             c <- base::c
[10:21:22.478]             inherits <- base::inherits
[10:21:22.478]             invokeRestart <- base::invokeRestart
[10:21:22.478]             length <- base::length
[10:21:22.478]             list <- base::list
[10:21:22.478]             seq.int <- base::seq.int
[10:21:22.478]             signalCondition <- base::signalCondition
[10:21:22.478]             sys.calls <- base::sys.calls
[10:21:22.478]             `[[` <- base::`[[`
[10:21:22.478]             `+` <- base::`+`
[10:21:22.478]             `<<-` <- base::`<<-`
[10:21:22.478]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.478]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.478]                   3L)]
[10:21:22.478]             }
[10:21:22.478]             function(cond) {
[10:21:22.478]                 is_error <- inherits(cond, "error")
[10:21:22.478]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.478]                   NULL)
[10:21:22.478]                 if (is_error) {
[10:21:22.478]                   sessionInformation <- function() {
[10:21:22.478]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.478]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.478]                       search = base::search(), system = base::Sys.info())
[10:21:22.478]                   }
[10:21:22.478]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.478]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.478]                     cond$call), session = sessionInformation(), 
[10:21:22.478]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.478]                   signalCondition(cond)
[10:21:22.478]                 }
[10:21:22.478]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.478]                 "immediateCondition"))) {
[10:21:22.478]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.478]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.478]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.478]                   if (TRUE && !signal) {
[10:21:22.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.478]                     {
[10:21:22.478]                       inherits <- base::inherits
[10:21:22.478]                       invokeRestart <- base::invokeRestart
[10:21:22.478]                       is.null <- base::is.null
[10:21:22.478]                       muffled <- FALSE
[10:21:22.478]                       if (inherits(cond, "message")) {
[10:21:22.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.478]                         if (muffled) 
[10:21:22.478]                           invokeRestart("muffleMessage")
[10:21:22.478]                       }
[10:21:22.478]                       else if (inherits(cond, "warning")) {
[10:21:22.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.478]                         if (muffled) 
[10:21:22.478]                           invokeRestart("muffleWarning")
[10:21:22.478]                       }
[10:21:22.478]                       else if (inherits(cond, "condition")) {
[10:21:22.478]                         if (!is.null(pattern)) {
[10:21:22.478]                           computeRestarts <- base::computeRestarts
[10:21:22.478]                           grepl <- base::grepl
[10:21:22.478]                           restarts <- computeRestarts(cond)
[10:21:22.478]                           for (restart in restarts) {
[10:21:22.478]                             name <- restart$name
[10:21:22.478]                             if (is.null(name)) 
[10:21:22.478]                               next
[10:21:22.478]                             if (!grepl(pattern, name)) 
[10:21:22.478]                               next
[10:21:22.478]                             invokeRestart(restart)
[10:21:22.478]                             muffled <- TRUE
[10:21:22.478]                             break
[10:21:22.478]                           }
[10:21:22.478]                         }
[10:21:22.478]                       }
[10:21:22.478]                       invisible(muffled)
[10:21:22.478]                     }
[10:21:22.478]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.478]                   }
[10:21:22.478]                 }
[10:21:22.478]                 else {
[10:21:22.478]                   if (TRUE) {
[10:21:22.478]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.478]                     {
[10:21:22.478]                       inherits <- base::inherits
[10:21:22.478]                       invokeRestart <- base::invokeRestart
[10:21:22.478]                       is.null <- base::is.null
[10:21:22.478]                       muffled <- FALSE
[10:21:22.478]                       if (inherits(cond, "message")) {
[10:21:22.478]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.478]                         if (muffled) 
[10:21:22.478]                           invokeRestart("muffleMessage")
[10:21:22.478]                       }
[10:21:22.478]                       else if (inherits(cond, "warning")) {
[10:21:22.478]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.478]                         if (muffled) 
[10:21:22.478]                           invokeRestart("muffleWarning")
[10:21:22.478]                       }
[10:21:22.478]                       else if (inherits(cond, "condition")) {
[10:21:22.478]                         if (!is.null(pattern)) {
[10:21:22.478]                           computeRestarts <- base::computeRestarts
[10:21:22.478]                           grepl <- base::grepl
[10:21:22.478]                           restarts <- computeRestarts(cond)
[10:21:22.478]                           for (restart in restarts) {
[10:21:22.478]                             name <- restart$name
[10:21:22.478]                             if (is.null(name)) 
[10:21:22.478]                               next
[10:21:22.478]                             if (!grepl(pattern, name)) 
[10:21:22.478]                               next
[10:21:22.478]                             invokeRestart(restart)
[10:21:22.478]                             muffled <- TRUE
[10:21:22.478]                             break
[10:21:22.478]                           }
[10:21:22.478]                         }
[10:21:22.478]                       }
[10:21:22.478]                       invisible(muffled)
[10:21:22.478]                     }
[10:21:22.478]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.478]                   }
[10:21:22.478]                 }
[10:21:22.478]             }
[10:21:22.478]         }))
[10:21:22.478]     }, error = function(ex) {
[10:21:22.478]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.478]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.478]                 ...future.rng), started = ...future.startTime, 
[10:21:22.478]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.478]             version = "1.8"), class = "FutureResult")
[10:21:22.478]     }, finally = {
[10:21:22.478]         if (!identical(...future.workdir, getwd())) 
[10:21:22.478]             setwd(...future.workdir)
[10:21:22.478]         {
[10:21:22.478]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.478]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.478]             }
[10:21:22.478]             base::options(...future.oldOptions)
[10:21:22.478]             if (.Platform$OS.type == "windows") {
[10:21:22.478]                 old_names <- names(...future.oldEnvVars)
[10:21:22.478]                 envs <- base::Sys.getenv()
[10:21:22.478]                 names <- names(envs)
[10:21:22.478]                 common <- intersect(names, old_names)
[10:21:22.478]                 added <- setdiff(names, old_names)
[10:21:22.478]                 removed <- setdiff(old_names, names)
[10:21:22.478]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.478]                   envs[common]]
[10:21:22.478]                 NAMES <- toupper(changed)
[10:21:22.478]                 args <- list()
[10:21:22.478]                 for (kk in seq_along(NAMES)) {
[10:21:22.478]                   name <- changed[[kk]]
[10:21:22.478]                   NAME <- NAMES[[kk]]
[10:21:22.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.478]                     next
[10:21:22.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.478]                 }
[10:21:22.478]                 NAMES <- toupper(added)
[10:21:22.478]                 for (kk in seq_along(NAMES)) {
[10:21:22.478]                   name <- added[[kk]]
[10:21:22.478]                   NAME <- NAMES[[kk]]
[10:21:22.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.478]                     next
[10:21:22.478]                   args[[name]] <- ""
[10:21:22.478]                 }
[10:21:22.478]                 NAMES <- toupper(removed)
[10:21:22.478]                 for (kk in seq_along(NAMES)) {
[10:21:22.478]                   name <- removed[[kk]]
[10:21:22.478]                   NAME <- NAMES[[kk]]
[10:21:22.478]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.478]                     next
[10:21:22.478]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.478]                 }
[10:21:22.478]                 if (length(args) > 0) 
[10:21:22.478]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.478]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.478]             }
[10:21:22.478]             else {
[10:21:22.478]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.478]             }
[10:21:22.478]             {
[10:21:22.478]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.478]                   0L) {
[10:21:22.478]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.478]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.478]                   base::options(opts)
[10:21:22.478]                 }
[10:21:22.478]                 {
[10:21:22.478]                   {
[10:21:22.478]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.478]                     NULL
[10:21:22.478]                   }
[10:21:22.478]                   options(future.plan = NULL)
[10:21:22.478]                   if (is.na(NA_character_)) 
[10:21:22.478]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.478]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.478]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.478]                     .init = FALSE)
[10:21:22.478]                 }
[10:21:22.478]             }
[10:21:22.478]         }
[10:21:22.478]     })
[10:21:22.478]     if (TRUE) {
[10:21:22.478]         base::sink(type = "output", split = FALSE)
[10:21:22.478]         if (TRUE) {
[10:21:22.478]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.478]         }
[10:21:22.478]         else {
[10:21:22.478]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.478]         }
[10:21:22.478]         base::close(...future.stdout)
[10:21:22.478]         ...future.stdout <- NULL
[10:21:22.478]     }
[10:21:22.478]     ...future.result$conditions <- ...future.conditions
[10:21:22.478]     ...future.result$finished <- base::Sys.time()
[10:21:22.478]     ...future.result
[10:21:22.478] }
[10:21:22.480] MultisessionFuture started
[10:21:22.481] - Launch lazy future ... done
[10:21:22.481] run() for ‘MultisessionFuture’ ... done
[10:21:22.481] getGlobalsAndPackages() ...
[10:21:22.481] Searching for globals...
[10:21:22.482] - globals found: [1] ‘{’
[10:21:22.482] Searching for globals ... DONE
[10:21:22.482] Resolving globals: FALSE
[10:21:22.482] 
[10:21:22.482] 
[10:21:22.482] getGlobalsAndPackages() ... DONE
[10:21:22.483] run() for ‘Future’ ...
[10:21:22.483] - state: ‘created’
[10:21:22.483] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.497] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.497] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.497]   - Field: ‘node’
[10:21:22.497]   - Field: ‘label’
[10:21:22.497]   - Field: ‘local’
[10:21:22.497]   - Field: ‘owner’
[10:21:22.497]   - Field: ‘envir’
[10:21:22.497]   - Field: ‘workers’
[10:21:22.497]   - Field: ‘packages’
[10:21:22.497]   - Field: ‘gc’
[10:21:22.498]   - Field: ‘conditions’
[10:21:22.498]   - Field: ‘persistent’
[10:21:22.498]   - Field: ‘expr’
[10:21:22.498]   - Field: ‘uuid’
[10:21:22.498]   - Field: ‘seed’
[10:21:22.498]   - Field: ‘version’
[10:21:22.498]   - Field: ‘result’
[10:21:22.498]   - Field: ‘asynchronous’
[10:21:22.498]   - Field: ‘calls’
[10:21:22.498]   - Field: ‘globals’
[10:21:22.498]   - Field: ‘stdout’
[10:21:22.498]   - Field: ‘earlySignal’
[10:21:22.499]   - Field: ‘lazy’
[10:21:22.499]   - Field: ‘state’
[10:21:22.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.499] - Launch lazy future ...
[10:21:22.499] Packages needed by the future expression (n = 0): <none>
[10:21:22.499] Packages needed by future strategies (n = 0): <none>
[10:21:22.500] {
[10:21:22.500]     {
[10:21:22.500]         {
[10:21:22.500]             ...future.startTime <- base::Sys.time()
[10:21:22.500]             {
[10:21:22.500]                 {
[10:21:22.500]                   {
[10:21:22.500]                     {
[10:21:22.500]                       base::local({
[10:21:22.500]                         has_future <- base::requireNamespace("future", 
[10:21:22.500]                           quietly = TRUE)
[10:21:22.500]                         if (has_future) {
[10:21:22.500]                           ns <- base::getNamespace("future")
[10:21:22.500]                           version <- ns[[".package"]][["version"]]
[10:21:22.500]                           if (is.null(version)) 
[10:21:22.500]                             version <- utils::packageVersion("future")
[10:21:22.500]                         }
[10:21:22.500]                         else {
[10:21:22.500]                           version <- NULL
[10:21:22.500]                         }
[10:21:22.500]                         if (!has_future || version < "1.8.0") {
[10:21:22.500]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.500]                             "", base::R.version$version.string), 
[10:21:22.500]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.500]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.500]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.500]                               "release", "version")], collapse = " "), 
[10:21:22.500]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.500]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.500]                             info)
[10:21:22.500]                           info <- base::paste(info, collapse = "; ")
[10:21:22.500]                           if (!has_future) {
[10:21:22.500]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.500]                               info)
[10:21:22.500]                           }
[10:21:22.500]                           else {
[10:21:22.500]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.500]                               info, version)
[10:21:22.500]                           }
[10:21:22.500]                           base::stop(msg)
[10:21:22.500]                         }
[10:21:22.500]                       })
[10:21:22.500]                     }
[10:21:22.500]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.500]                     base::options(mc.cores = 1L)
[10:21:22.500]                   }
[10:21:22.500]                   ...future.strategy.old <- future::plan("list")
[10:21:22.500]                   options(future.plan = NULL)
[10:21:22.500]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.500]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.500]                 }
[10:21:22.500]                 ...future.workdir <- getwd()
[10:21:22.500]             }
[10:21:22.500]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.500]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.500]         }
[10:21:22.500]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.500]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.500]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.500]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.500]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.500]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.500]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.500]             base::names(...future.oldOptions))
[10:21:22.500]     }
[10:21:22.500]     if (FALSE) {
[10:21:22.500]     }
[10:21:22.500]     else {
[10:21:22.500]         if (TRUE) {
[10:21:22.500]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.500]                 open = "w")
[10:21:22.500]         }
[10:21:22.500]         else {
[10:21:22.500]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.500]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.500]         }
[10:21:22.500]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.500]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.500]             base::sink(type = "output", split = FALSE)
[10:21:22.500]             base::close(...future.stdout)
[10:21:22.500]         }, add = TRUE)
[10:21:22.500]     }
[10:21:22.500]     ...future.frame <- base::sys.nframe()
[10:21:22.500]     ...future.conditions <- base::list()
[10:21:22.500]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.500]     if (FALSE) {
[10:21:22.500]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.500]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.500]     }
[10:21:22.500]     ...future.result <- base::tryCatch({
[10:21:22.500]         base::withCallingHandlers({
[10:21:22.500]             ...future.value <- base::withVisible(base::local({
[10:21:22.500]                 ...future.makeSendCondition <- base::local({
[10:21:22.500]                   sendCondition <- NULL
[10:21:22.500]                   function(frame = 1L) {
[10:21:22.500]                     if (is.function(sendCondition)) 
[10:21:22.500]                       return(sendCondition)
[10:21:22.500]                     ns <- getNamespace("parallel")
[10:21:22.500]                     if (exists("sendData", mode = "function", 
[10:21:22.500]                       envir = ns)) {
[10:21:22.500]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.500]                         envir = ns)
[10:21:22.500]                       envir <- sys.frame(frame)
[10:21:22.500]                       master <- NULL
[10:21:22.500]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.500]                         !identical(envir, emptyenv())) {
[10:21:22.500]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.500]                           inherits = FALSE)) {
[10:21:22.500]                           master <- get("master", mode = "list", 
[10:21:22.500]                             envir = envir, inherits = FALSE)
[10:21:22.500]                           if (inherits(master, c("SOCKnode", 
[10:21:22.500]                             "SOCK0node"))) {
[10:21:22.500]                             sendCondition <<- function(cond) {
[10:21:22.500]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.500]                                 success = TRUE)
[10:21:22.500]                               parallel_sendData(master, data)
[10:21:22.500]                             }
[10:21:22.500]                             return(sendCondition)
[10:21:22.500]                           }
[10:21:22.500]                         }
[10:21:22.500]                         frame <- frame + 1L
[10:21:22.500]                         envir <- sys.frame(frame)
[10:21:22.500]                       }
[10:21:22.500]                     }
[10:21:22.500]                     sendCondition <<- function(cond) NULL
[10:21:22.500]                   }
[10:21:22.500]                 })
[10:21:22.500]                 withCallingHandlers({
[10:21:22.500]                   {
[10:21:22.500]                     4
[10:21:22.500]                   }
[10:21:22.500]                 }, immediateCondition = function(cond) {
[10:21:22.500]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.500]                   sendCondition(cond)
[10:21:22.500]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.500]                   {
[10:21:22.500]                     inherits <- base::inherits
[10:21:22.500]                     invokeRestart <- base::invokeRestart
[10:21:22.500]                     is.null <- base::is.null
[10:21:22.500]                     muffled <- FALSE
[10:21:22.500]                     if (inherits(cond, "message")) {
[10:21:22.500]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.500]                       if (muffled) 
[10:21:22.500]                         invokeRestart("muffleMessage")
[10:21:22.500]                     }
[10:21:22.500]                     else if (inherits(cond, "warning")) {
[10:21:22.500]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.500]                       if (muffled) 
[10:21:22.500]                         invokeRestart("muffleWarning")
[10:21:22.500]                     }
[10:21:22.500]                     else if (inherits(cond, "condition")) {
[10:21:22.500]                       if (!is.null(pattern)) {
[10:21:22.500]                         computeRestarts <- base::computeRestarts
[10:21:22.500]                         grepl <- base::grepl
[10:21:22.500]                         restarts <- computeRestarts(cond)
[10:21:22.500]                         for (restart in restarts) {
[10:21:22.500]                           name <- restart$name
[10:21:22.500]                           if (is.null(name)) 
[10:21:22.500]                             next
[10:21:22.500]                           if (!grepl(pattern, name)) 
[10:21:22.500]                             next
[10:21:22.500]                           invokeRestart(restart)
[10:21:22.500]                           muffled <- TRUE
[10:21:22.500]                           break
[10:21:22.500]                         }
[10:21:22.500]                       }
[10:21:22.500]                     }
[10:21:22.500]                     invisible(muffled)
[10:21:22.500]                   }
[10:21:22.500]                   muffleCondition(cond)
[10:21:22.500]                 })
[10:21:22.500]             }))
[10:21:22.500]             future::FutureResult(value = ...future.value$value, 
[10:21:22.500]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.500]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.500]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.500]                     ...future.globalenv.names))
[10:21:22.500]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.500]         }, condition = base::local({
[10:21:22.500]             c <- base::c
[10:21:22.500]             inherits <- base::inherits
[10:21:22.500]             invokeRestart <- base::invokeRestart
[10:21:22.500]             length <- base::length
[10:21:22.500]             list <- base::list
[10:21:22.500]             seq.int <- base::seq.int
[10:21:22.500]             signalCondition <- base::signalCondition
[10:21:22.500]             sys.calls <- base::sys.calls
[10:21:22.500]             `[[` <- base::`[[`
[10:21:22.500]             `+` <- base::`+`
[10:21:22.500]             `<<-` <- base::`<<-`
[10:21:22.500]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.500]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.500]                   3L)]
[10:21:22.500]             }
[10:21:22.500]             function(cond) {
[10:21:22.500]                 is_error <- inherits(cond, "error")
[10:21:22.500]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.500]                   NULL)
[10:21:22.500]                 if (is_error) {
[10:21:22.500]                   sessionInformation <- function() {
[10:21:22.500]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.500]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.500]                       search = base::search(), system = base::Sys.info())
[10:21:22.500]                   }
[10:21:22.500]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.500]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.500]                     cond$call), session = sessionInformation(), 
[10:21:22.500]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.500]                   signalCondition(cond)
[10:21:22.500]                 }
[10:21:22.500]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.500]                 "immediateCondition"))) {
[10:21:22.500]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.500]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.500]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.500]                   if (TRUE && !signal) {
[10:21:22.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.500]                     {
[10:21:22.500]                       inherits <- base::inherits
[10:21:22.500]                       invokeRestart <- base::invokeRestart
[10:21:22.500]                       is.null <- base::is.null
[10:21:22.500]                       muffled <- FALSE
[10:21:22.500]                       if (inherits(cond, "message")) {
[10:21:22.500]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.500]                         if (muffled) 
[10:21:22.500]                           invokeRestart("muffleMessage")
[10:21:22.500]                       }
[10:21:22.500]                       else if (inherits(cond, "warning")) {
[10:21:22.500]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.500]                         if (muffled) 
[10:21:22.500]                           invokeRestart("muffleWarning")
[10:21:22.500]                       }
[10:21:22.500]                       else if (inherits(cond, "condition")) {
[10:21:22.500]                         if (!is.null(pattern)) {
[10:21:22.500]                           computeRestarts <- base::computeRestarts
[10:21:22.500]                           grepl <- base::grepl
[10:21:22.500]                           restarts <- computeRestarts(cond)
[10:21:22.500]                           for (restart in restarts) {
[10:21:22.500]                             name <- restart$name
[10:21:22.500]                             if (is.null(name)) 
[10:21:22.500]                               next
[10:21:22.500]                             if (!grepl(pattern, name)) 
[10:21:22.500]                               next
[10:21:22.500]                             invokeRestart(restart)
[10:21:22.500]                             muffled <- TRUE
[10:21:22.500]                             break
[10:21:22.500]                           }
[10:21:22.500]                         }
[10:21:22.500]                       }
[10:21:22.500]                       invisible(muffled)
[10:21:22.500]                     }
[10:21:22.500]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.500]                   }
[10:21:22.500]                 }
[10:21:22.500]                 else {
[10:21:22.500]                   if (TRUE) {
[10:21:22.500]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.500]                     {
[10:21:22.500]                       inherits <- base::inherits
[10:21:22.500]                       invokeRestart <- base::invokeRestart
[10:21:22.500]                       is.null <- base::is.null
[10:21:22.500]                       muffled <- FALSE
[10:21:22.500]                       if (inherits(cond, "message")) {
[10:21:22.500]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.500]                         if (muffled) 
[10:21:22.500]                           invokeRestart("muffleMessage")
[10:21:22.500]                       }
[10:21:22.500]                       else if (inherits(cond, "warning")) {
[10:21:22.500]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.500]                         if (muffled) 
[10:21:22.500]                           invokeRestart("muffleWarning")
[10:21:22.500]                       }
[10:21:22.500]                       else if (inherits(cond, "condition")) {
[10:21:22.500]                         if (!is.null(pattern)) {
[10:21:22.500]                           computeRestarts <- base::computeRestarts
[10:21:22.500]                           grepl <- base::grepl
[10:21:22.500]                           restarts <- computeRestarts(cond)
[10:21:22.500]                           for (restart in restarts) {
[10:21:22.500]                             name <- restart$name
[10:21:22.500]                             if (is.null(name)) 
[10:21:22.500]                               next
[10:21:22.500]                             if (!grepl(pattern, name)) 
[10:21:22.500]                               next
[10:21:22.500]                             invokeRestart(restart)
[10:21:22.500]                             muffled <- TRUE
[10:21:22.500]                             break
[10:21:22.500]                           }
[10:21:22.500]                         }
[10:21:22.500]                       }
[10:21:22.500]                       invisible(muffled)
[10:21:22.500]                     }
[10:21:22.500]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.500]                   }
[10:21:22.500]                 }
[10:21:22.500]             }
[10:21:22.500]         }))
[10:21:22.500]     }, error = function(ex) {
[10:21:22.500]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.500]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.500]                 ...future.rng), started = ...future.startTime, 
[10:21:22.500]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.500]             version = "1.8"), class = "FutureResult")
[10:21:22.500]     }, finally = {
[10:21:22.500]         if (!identical(...future.workdir, getwd())) 
[10:21:22.500]             setwd(...future.workdir)
[10:21:22.500]         {
[10:21:22.500]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.500]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.500]             }
[10:21:22.500]             base::options(...future.oldOptions)
[10:21:22.500]             if (.Platform$OS.type == "windows") {
[10:21:22.500]                 old_names <- names(...future.oldEnvVars)
[10:21:22.500]                 envs <- base::Sys.getenv()
[10:21:22.500]                 names <- names(envs)
[10:21:22.500]                 common <- intersect(names, old_names)
[10:21:22.500]                 added <- setdiff(names, old_names)
[10:21:22.500]                 removed <- setdiff(old_names, names)
[10:21:22.500]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.500]                   envs[common]]
[10:21:22.500]                 NAMES <- toupper(changed)
[10:21:22.500]                 args <- list()
[10:21:22.500]                 for (kk in seq_along(NAMES)) {
[10:21:22.500]                   name <- changed[[kk]]
[10:21:22.500]                   NAME <- NAMES[[kk]]
[10:21:22.500]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.500]                     next
[10:21:22.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.500]                 }
[10:21:22.500]                 NAMES <- toupper(added)
[10:21:22.500]                 for (kk in seq_along(NAMES)) {
[10:21:22.500]                   name <- added[[kk]]
[10:21:22.500]                   NAME <- NAMES[[kk]]
[10:21:22.500]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.500]                     next
[10:21:22.500]                   args[[name]] <- ""
[10:21:22.500]                 }
[10:21:22.500]                 NAMES <- toupper(removed)
[10:21:22.500]                 for (kk in seq_along(NAMES)) {
[10:21:22.500]                   name <- removed[[kk]]
[10:21:22.500]                   NAME <- NAMES[[kk]]
[10:21:22.500]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.500]                     next
[10:21:22.500]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.500]                 }
[10:21:22.500]                 if (length(args) > 0) 
[10:21:22.500]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.500]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.500]             }
[10:21:22.500]             else {
[10:21:22.500]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.500]             }
[10:21:22.500]             {
[10:21:22.500]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.500]                   0L) {
[10:21:22.500]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.500]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.500]                   base::options(opts)
[10:21:22.500]                 }
[10:21:22.500]                 {
[10:21:22.500]                   {
[10:21:22.500]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.500]                     NULL
[10:21:22.500]                   }
[10:21:22.500]                   options(future.plan = NULL)
[10:21:22.500]                   if (is.na(NA_character_)) 
[10:21:22.500]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.500]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.500]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.500]                     .init = FALSE)
[10:21:22.500]                 }
[10:21:22.500]             }
[10:21:22.500]         }
[10:21:22.500]     })
[10:21:22.500]     if (TRUE) {
[10:21:22.500]         base::sink(type = "output", split = FALSE)
[10:21:22.500]         if (TRUE) {
[10:21:22.500]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.500]         }
[10:21:22.500]         else {
[10:21:22.500]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.500]         }
[10:21:22.500]         base::close(...future.stdout)
[10:21:22.500]         ...future.stdout <- NULL
[10:21:22.500]     }
[10:21:22.500]     ...future.result$conditions <- ...future.conditions
[10:21:22.500]     ...future.result$finished <- base::Sys.time()
[10:21:22.500]     ...future.result
[10:21:22.500] }
[10:21:22.502] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:22.513] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.513] - Validating connection of MultisessionFuture
[10:21:22.513] - received message: FutureResult
[10:21:22.513] - Received FutureResult
[10:21:22.513] - Erased future from FutureRegistry
[10:21:22.513] result() for ClusterFuture ...
[10:21:22.513] - result already collected: FutureResult
[10:21:22.513] result() for ClusterFuture ... done
[10:21:22.514] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.514] result() for ClusterFuture ...
[10:21:22.514] - result already collected: FutureResult
[10:21:22.514] result() for ClusterFuture ... done
[10:21:22.514] result() for ClusterFuture ...
[10:21:22.514] - result already collected: FutureResult
[10:21:22.514] result() for ClusterFuture ... done
[10:21:22.515] MultisessionFuture started
[10:21:22.515] - Launch lazy future ... done
[10:21:22.515] run() for ‘MultisessionFuture’ ... done
<environment: 0x55e8e677c5d0> 
<environment: 0x55e8e74bf748> 
[10:21:22.523] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.523] - Validating connection of MultisessionFuture
[10:21:22.523] - received message: FutureResult
[10:21:22.524] - Received FutureResult
[10:21:22.524] - Erased future from FutureRegistry
[10:21:22.524] result() for ClusterFuture ...
[10:21:22.524] - result already collected: FutureResult
[10:21:22.524] result() for ClusterFuture ... done
[10:21:22.524] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:22.536] resolve() on environment ...
[10:21:22.536]  recursive: 0
[10:21:22.536]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:22.537] signalConditionsASAP(numeric, pos=1) ...
[10:21:22.537] - nx: 4
[10:21:22.539] - relay: TRUE
[10:21:22.539] - stdout: TRUE
[10:21:22.539] - signal: TRUE
[10:21:22.540] - resignal: FALSE
[10:21:22.540] - force: TRUE
[10:21:22.540] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.540] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.540]  - until=2
[10:21:22.540]  - relaying element #2
[10:21:22.540] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.540] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.540] signalConditionsASAP(NULL, pos=1) ... done
[10:21:22.540]  length: 3 (resolved future 1)
[10:21:22.541] Future #2
[10:21:22.541] result() for ClusterFuture ...
[10:21:22.541] - result already collected: FutureResult
[10:21:22.541] result() for ClusterFuture ... done
[10:21:22.541] result() for ClusterFuture ...
[10:21:22.541] - result already collected: FutureResult
[10:21:22.541] result() for ClusterFuture ... done
[10:21:22.541] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:22.541] - nx: 4
[10:21:22.541] - relay: TRUE
[10:21:22.541] - stdout: TRUE
[10:21:22.541] - signal: TRUE
[10:21:22.542] - resignal: FALSE
[10:21:22.542] - force: TRUE
[10:21:22.542] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.542] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.542]  - until=2
[10:21:22.542]  - relaying element #2
[10:21:22.542] result() for ClusterFuture ...
[10:21:22.542] - result already collected: FutureResult
[10:21:22.542] result() for ClusterFuture ... done
[10:21:22.542] result() for ClusterFuture ...
[10:21:22.542] - result already collected: FutureResult
[10:21:22.542] result() for ClusterFuture ... done
[10:21:22.543] result() for ClusterFuture ...
[10:21:22.543] - result already collected: FutureResult
[10:21:22.543] result() for ClusterFuture ... done
[10:21:22.543] result() for ClusterFuture ...
[10:21:22.543] - result already collected: FutureResult
[10:21:22.543] result() for ClusterFuture ... done
[10:21:22.543] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.543] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.543] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:22.543]  length: 2 (resolved future 2)
[10:21:22.543] Future #3
[10:21:22.543] result() for ClusterFuture ...
[10:21:22.543] - result already collected: FutureResult
[10:21:22.544] result() for ClusterFuture ... done
[10:21:22.544] result() for ClusterFuture ...
[10:21:22.544] - result already collected: FutureResult
[10:21:22.544] result() for ClusterFuture ... done
[10:21:22.544] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:22.544] - nx: 4
[10:21:22.544] - relay: TRUE
[10:21:22.544] - stdout: TRUE
[10:21:22.544] - signal: TRUE
[10:21:22.544] - resignal: FALSE
[10:21:22.544] - force: TRUE
[10:21:22.544] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.545] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.545]  - until=3
[10:21:22.545]  - relaying element #3
[10:21:22.545] result() for ClusterFuture ...
[10:21:22.545] - result already collected: FutureResult
[10:21:22.545] result() for ClusterFuture ... done
[10:21:22.545] result() for ClusterFuture ...
[10:21:22.545] - result already collected: FutureResult
[10:21:22.545] result() for ClusterFuture ... done
[10:21:22.545] result() for ClusterFuture ...
[10:21:22.545] - result already collected: FutureResult
[10:21:22.545] result() for ClusterFuture ... done
[10:21:22.546] result() for ClusterFuture ...
[10:21:22.546] - result already collected: FutureResult
[10:21:22.546] result() for ClusterFuture ... done
[10:21:22.546] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.546] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.546] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:22.546]  length: 1 (resolved future 3)
[10:21:22.567] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.567] - Validating connection of MultisessionFuture
[10:21:22.568] - received message: FutureResult
[10:21:22.568] - Received FutureResult
[10:21:22.568] - Erased future from FutureRegistry
[10:21:22.568] result() for ClusterFuture ...
[10:21:22.568] - result already collected: FutureResult
[10:21:22.568] result() for ClusterFuture ... done
[10:21:22.568] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.568] Future #4
[10:21:22.568] result() for ClusterFuture ...
[10:21:22.568] - result already collected: FutureResult
[10:21:22.568] result() for ClusterFuture ... done
[10:21:22.569] result() for ClusterFuture ...
[10:21:22.569] - result already collected: FutureResult
[10:21:22.569] result() for ClusterFuture ... done
[10:21:22.569] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:22.569] - nx: 4
[10:21:22.569] - relay: TRUE
[10:21:22.569] - stdout: TRUE
[10:21:22.569] - signal: TRUE
[10:21:22.569] - resignal: FALSE
[10:21:22.569] - force: TRUE
[10:21:22.569] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.569] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.569]  - until=4
[10:21:22.570]  - relaying element #4
[10:21:22.570] result() for ClusterFuture ...
[10:21:22.570] - result already collected: FutureResult
[10:21:22.570] result() for ClusterFuture ... done
[10:21:22.570] result() for ClusterFuture ...
[10:21:22.570] - result already collected: FutureResult
[10:21:22.570] result() for ClusterFuture ... done
[10:21:22.570] result() for ClusterFuture ...
[10:21:22.570] - result already collected: FutureResult
[10:21:22.570] result() for ClusterFuture ... done
[10:21:22.570] result() for ClusterFuture ...
[10:21:22.570] - result already collected: FutureResult
[10:21:22.571] result() for ClusterFuture ... done
[10:21:22.571] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.571] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.571] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:22.571]  length: 0 (resolved future 4)
[10:21:22.571] Relaying remaining futures
[10:21:22.571] signalConditionsASAP(NULL, pos=0) ...
[10:21:22.571] - nx: 4
[10:21:22.571] - relay: TRUE
[10:21:22.571] - stdout: TRUE
[10:21:22.571] - signal: TRUE
[10:21:22.571] - resignal: FALSE
[10:21:22.571] - force: TRUE
[10:21:22.572] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.572] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:22.572] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.572] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.572] signalConditionsASAP(NULL, pos=0) ... done
[10:21:22.572] resolve() on environment ... DONE
[10:21:22.572] result() for ClusterFuture ...
[10:21:22.572] - result already collected: FutureResult
[10:21:22.572] result() for ClusterFuture ... done
[10:21:22.572] result() for ClusterFuture ...
[10:21:22.572] - result already collected: FutureResult
[10:21:22.572] result() for ClusterFuture ... done
[10:21:22.573] result() for ClusterFuture ...
[10:21:22.573] - result already collected: FutureResult
[10:21:22.573] result() for ClusterFuture ... done
[10:21:22.573] result() for ClusterFuture ...
[10:21:22.573] - result already collected: FutureResult
[10:21:22.573] result() for ClusterFuture ... done
[10:21:22.573] result() for ClusterFuture ...
[10:21:22.573] - result already collected: FutureResult
[10:21:22.573] result() for ClusterFuture ... done
[10:21:22.573] result() for ClusterFuture ...
[10:21:22.573] - result already collected: FutureResult
[10:21:22.573] result() for ClusterFuture ... done
<environment: 0x55e8e76b9840> 
Dimensions: c(2, 3, 1)
[10:21:22.574] getGlobalsAndPackages() ...
[10:21:22.574] Searching for globals...
[10:21:22.574] 
[10:21:22.574] Searching for globals ... DONE
[10:21:22.574] - globals: [0] <none>
[10:21:22.575] getGlobalsAndPackages() ... DONE
[10:21:22.575] run() for ‘Future’ ...
[10:21:22.575] - state: ‘created’
[10:21:22.575] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.589] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.589] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.589]   - Field: ‘node’
[10:21:22.589]   - Field: ‘label’
[10:21:22.589]   - Field: ‘local’
[10:21:22.589]   - Field: ‘owner’
[10:21:22.589]   - Field: ‘envir’
[10:21:22.589]   - Field: ‘workers’
[10:21:22.589]   - Field: ‘packages’
[10:21:22.589]   - Field: ‘gc’
[10:21:22.590]   - Field: ‘conditions’
[10:21:22.590]   - Field: ‘persistent’
[10:21:22.590]   - Field: ‘expr’
[10:21:22.590]   - Field: ‘uuid’
[10:21:22.590]   - Field: ‘seed’
[10:21:22.590]   - Field: ‘version’
[10:21:22.590]   - Field: ‘result’
[10:21:22.590]   - Field: ‘asynchronous’
[10:21:22.590]   - Field: ‘calls’
[10:21:22.590]   - Field: ‘globals’
[10:21:22.590]   - Field: ‘stdout’
[10:21:22.591]   - Field: ‘earlySignal’
[10:21:22.591]   - Field: ‘lazy’
[10:21:22.591]   - Field: ‘state’
[10:21:22.591] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.591] - Launch lazy future ...
[10:21:22.591] Packages needed by the future expression (n = 0): <none>
[10:21:22.591] Packages needed by future strategies (n = 0): <none>
[10:21:22.592] {
[10:21:22.592]     {
[10:21:22.592]         {
[10:21:22.592]             ...future.startTime <- base::Sys.time()
[10:21:22.592]             {
[10:21:22.592]                 {
[10:21:22.592]                   {
[10:21:22.592]                     {
[10:21:22.592]                       base::local({
[10:21:22.592]                         has_future <- base::requireNamespace("future", 
[10:21:22.592]                           quietly = TRUE)
[10:21:22.592]                         if (has_future) {
[10:21:22.592]                           ns <- base::getNamespace("future")
[10:21:22.592]                           version <- ns[[".package"]][["version"]]
[10:21:22.592]                           if (is.null(version)) 
[10:21:22.592]                             version <- utils::packageVersion("future")
[10:21:22.592]                         }
[10:21:22.592]                         else {
[10:21:22.592]                           version <- NULL
[10:21:22.592]                         }
[10:21:22.592]                         if (!has_future || version < "1.8.0") {
[10:21:22.592]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.592]                             "", base::R.version$version.string), 
[10:21:22.592]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.592]                               "release", "version")], collapse = " "), 
[10:21:22.592]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.592]                             info)
[10:21:22.592]                           info <- base::paste(info, collapse = "; ")
[10:21:22.592]                           if (!has_future) {
[10:21:22.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.592]                               info)
[10:21:22.592]                           }
[10:21:22.592]                           else {
[10:21:22.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.592]                               info, version)
[10:21:22.592]                           }
[10:21:22.592]                           base::stop(msg)
[10:21:22.592]                         }
[10:21:22.592]                       })
[10:21:22.592]                     }
[10:21:22.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.592]                     base::options(mc.cores = 1L)
[10:21:22.592]                   }
[10:21:22.592]                   ...future.strategy.old <- future::plan("list")
[10:21:22.592]                   options(future.plan = NULL)
[10:21:22.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.592]                 }
[10:21:22.592]                 ...future.workdir <- getwd()
[10:21:22.592]             }
[10:21:22.592]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.592]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.592]         }
[10:21:22.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.592]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.592]             base::names(...future.oldOptions))
[10:21:22.592]     }
[10:21:22.592]     if (FALSE) {
[10:21:22.592]     }
[10:21:22.592]     else {
[10:21:22.592]         if (TRUE) {
[10:21:22.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.592]                 open = "w")
[10:21:22.592]         }
[10:21:22.592]         else {
[10:21:22.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.592]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.592]         }
[10:21:22.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.592]             base::sink(type = "output", split = FALSE)
[10:21:22.592]             base::close(...future.stdout)
[10:21:22.592]         }, add = TRUE)
[10:21:22.592]     }
[10:21:22.592]     ...future.frame <- base::sys.nframe()
[10:21:22.592]     ...future.conditions <- base::list()
[10:21:22.592]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.592]     if (FALSE) {
[10:21:22.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.592]     }
[10:21:22.592]     ...future.result <- base::tryCatch({
[10:21:22.592]         base::withCallingHandlers({
[10:21:22.592]             ...future.value <- base::withVisible(base::local({
[10:21:22.592]                 ...future.makeSendCondition <- base::local({
[10:21:22.592]                   sendCondition <- NULL
[10:21:22.592]                   function(frame = 1L) {
[10:21:22.592]                     if (is.function(sendCondition)) 
[10:21:22.592]                       return(sendCondition)
[10:21:22.592]                     ns <- getNamespace("parallel")
[10:21:22.592]                     if (exists("sendData", mode = "function", 
[10:21:22.592]                       envir = ns)) {
[10:21:22.592]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.592]                         envir = ns)
[10:21:22.592]                       envir <- sys.frame(frame)
[10:21:22.592]                       master <- NULL
[10:21:22.592]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.592]                         !identical(envir, emptyenv())) {
[10:21:22.592]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.592]                           inherits = FALSE)) {
[10:21:22.592]                           master <- get("master", mode = "list", 
[10:21:22.592]                             envir = envir, inherits = FALSE)
[10:21:22.592]                           if (inherits(master, c("SOCKnode", 
[10:21:22.592]                             "SOCK0node"))) {
[10:21:22.592]                             sendCondition <<- function(cond) {
[10:21:22.592]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.592]                                 success = TRUE)
[10:21:22.592]                               parallel_sendData(master, data)
[10:21:22.592]                             }
[10:21:22.592]                             return(sendCondition)
[10:21:22.592]                           }
[10:21:22.592]                         }
[10:21:22.592]                         frame <- frame + 1L
[10:21:22.592]                         envir <- sys.frame(frame)
[10:21:22.592]                       }
[10:21:22.592]                     }
[10:21:22.592]                     sendCondition <<- function(cond) NULL
[10:21:22.592]                   }
[10:21:22.592]                 })
[10:21:22.592]                 withCallingHandlers({
[10:21:22.592]                   2
[10:21:22.592]                 }, immediateCondition = function(cond) {
[10:21:22.592]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.592]                   sendCondition(cond)
[10:21:22.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.592]                   {
[10:21:22.592]                     inherits <- base::inherits
[10:21:22.592]                     invokeRestart <- base::invokeRestart
[10:21:22.592]                     is.null <- base::is.null
[10:21:22.592]                     muffled <- FALSE
[10:21:22.592]                     if (inherits(cond, "message")) {
[10:21:22.592]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.592]                       if (muffled) 
[10:21:22.592]                         invokeRestart("muffleMessage")
[10:21:22.592]                     }
[10:21:22.592]                     else if (inherits(cond, "warning")) {
[10:21:22.592]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.592]                       if (muffled) 
[10:21:22.592]                         invokeRestart("muffleWarning")
[10:21:22.592]                     }
[10:21:22.592]                     else if (inherits(cond, "condition")) {
[10:21:22.592]                       if (!is.null(pattern)) {
[10:21:22.592]                         computeRestarts <- base::computeRestarts
[10:21:22.592]                         grepl <- base::grepl
[10:21:22.592]                         restarts <- computeRestarts(cond)
[10:21:22.592]                         for (restart in restarts) {
[10:21:22.592]                           name <- restart$name
[10:21:22.592]                           if (is.null(name)) 
[10:21:22.592]                             next
[10:21:22.592]                           if (!grepl(pattern, name)) 
[10:21:22.592]                             next
[10:21:22.592]                           invokeRestart(restart)
[10:21:22.592]                           muffled <- TRUE
[10:21:22.592]                           break
[10:21:22.592]                         }
[10:21:22.592]                       }
[10:21:22.592]                     }
[10:21:22.592]                     invisible(muffled)
[10:21:22.592]                   }
[10:21:22.592]                   muffleCondition(cond)
[10:21:22.592]                 })
[10:21:22.592]             }))
[10:21:22.592]             future::FutureResult(value = ...future.value$value, 
[10:21:22.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.592]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.592]                     ...future.globalenv.names))
[10:21:22.592]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.592]         }, condition = base::local({
[10:21:22.592]             c <- base::c
[10:21:22.592]             inherits <- base::inherits
[10:21:22.592]             invokeRestart <- base::invokeRestart
[10:21:22.592]             length <- base::length
[10:21:22.592]             list <- base::list
[10:21:22.592]             seq.int <- base::seq.int
[10:21:22.592]             signalCondition <- base::signalCondition
[10:21:22.592]             sys.calls <- base::sys.calls
[10:21:22.592]             `[[` <- base::`[[`
[10:21:22.592]             `+` <- base::`+`
[10:21:22.592]             `<<-` <- base::`<<-`
[10:21:22.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.592]                   3L)]
[10:21:22.592]             }
[10:21:22.592]             function(cond) {
[10:21:22.592]                 is_error <- inherits(cond, "error")
[10:21:22.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.592]                   NULL)
[10:21:22.592]                 if (is_error) {
[10:21:22.592]                   sessionInformation <- function() {
[10:21:22.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.592]                       search = base::search(), system = base::Sys.info())
[10:21:22.592]                   }
[10:21:22.592]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.592]                     cond$call), session = sessionInformation(), 
[10:21:22.592]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.592]                   signalCondition(cond)
[10:21:22.592]                 }
[10:21:22.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.592]                 "immediateCondition"))) {
[10:21:22.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.592]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.592]                   if (TRUE && !signal) {
[10:21:22.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.592]                     {
[10:21:22.592]                       inherits <- base::inherits
[10:21:22.592]                       invokeRestart <- base::invokeRestart
[10:21:22.592]                       is.null <- base::is.null
[10:21:22.592]                       muffled <- FALSE
[10:21:22.592]                       if (inherits(cond, "message")) {
[10:21:22.592]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.592]                         if (muffled) 
[10:21:22.592]                           invokeRestart("muffleMessage")
[10:21:22.592]                       }
[10:21:22.592]                       else if (inherits(cond, "warning")) {
[10:21:22.592]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.592]                         if (muffled) 
[10:21:22.592]                           invokeRestart("muffleWarning")
[10:21:22.592]                       }
[10:21:22.592]                       else if (inherits(cond, "condition")) {
[10:21:22.592]                         if (!is.null(pattern)) {
[10:21:22.592]                           computeRestarts <- base::computeRestarts
[10:21:22.592]                           grepl <- base::grepl
[10:21:22.592]                           restarts <- computeRestarts(cond)
[10:21:22.592]                           for (restart in restarts) {
[10:21:22.592]                             name <- restart$name
[10:21:22.592]                             if (is.null(name)) 
[10:21:22.592]                               next
[10:21:22.592]                             if (!grepl(pattern, name)) 
[10:21:22.592]                               next
[10:21:22.592]                             invokeRestart(restart)
[10:21:22.592]                             muffled <- TRUE
[10:21:22.592]                             break
[10:21:22.592]                           }
[10:21:22.592]                         }
[10:21:22.592]                       }
[10:21:22.592]                       invisible(muffled)
[10:21:22.592]                     }
[10:21:22.592]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.592]                   }
[10:21:22.592]                 }
[10:21:22.592]                 else {
[10:21:22.592]                   if (TRUE) {
[10:21:22.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.592]                     {
[10:21:22.592]                       inherits <- base::inherits
[10:21:22.592]                       invokeRestart <- base::invokeRestart
[10:21:22.592]                       is.null <- base::is.null
[10:21:22.592]                       muffled <- FALSE
[10:21:22.592]                       if (inherits(cond, "message")) {
[10:21:22.592]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.592]                         if (muffled) 
[10:21:22.592]                           invokeRestart("muffleMessage")
[10:21:22.592]                       }
[10:21:22.592]                       else if (inherits(cond, "warning")) {
[10:21:22.592]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.592]                         if (muffled) 
[10:21:22.592]                           invokeRestart("muffleWarning")
[10:21:22.592]                       }
[10:21:22.592]                       else if (inherits(cond, "condition")) {
[10:21:22.592]                         if (!is.null(pattern)) {
[10:21:22.592]                           computeRestarts <- base::computeRestarts
[10:21:22.592]                           grepl <- base::grepl
[10:21:22.592]                           restarts <- computeRestarts(cond)
[10:21:22.592]                           for (restart in restarts) {
[10:21:22.592]                             name <- restart$name
[10:21:22.592]                             if (is.null(name)) 
[10:21:22.592]                               next
[10:21:22.592]                             if (!grepl(pattern, name)) 
[10:21:22.592]                               next
[10:21:22.592]                             invokeRestart(restart)
[10:21:22.592]                             muffled <- TRUE
[10:21:22.592]                             break
[10:21:22.592]                           }
[10:21:22.592]                         }
[10:21:22.592]                       }
[10:21:22.592]                       invisible(muffled)
[10:21:22.592]                     }
[10:21:22.592]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.592]                   }
[10:21:22.592]                 }
[10:21:22.592]             }
[10:21:22.592]         }))
[10:21:22.592]     }, error = function(ex) {
[10:21:22.592]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.592]                 ...future.rng), started = ...future.startTime, 
[10:21:22.592]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.592]             version = "1.8"), class = "FutureResult")
[10:21:22.592]     }, finally = {
[10:21:22.592]         if (!identical(...future.workdir, getwd())) 
[10:21:22.592]             setwd(...future.workdir)
[10:21:22.592]         {
[10:21:22.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.592]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.592]             }
[10:21:22.592]             base::options(...future.oldOptions)
[10:21:22.592]             if (.Platform$OS.type == "windows") {
[10:21:22.592]                 old_names <- names(...future.oldEnvVars)
[10:21:22.592]                 envs <- base::Sys.getenv()
[10:21:22.592]                 names <- names(envs)
[10:21:22.592]                 common <- intersect(names, old_names)
[10:21:22.592]                 added <- setdiff(names, old_names)
[10:21:22.592]                 removed <- setdiff(old_names, names)
[10:21:22.592]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.592]                   envs[common]]
[10:21:22.592]                 NAMES <- toupper(changed)
[10:21:22.592]                 args <- list()
[10:21:22.592]                 for (kk in seq_along(NAMES)) {
[10:21:22.592]                   name <- changed[[kk]]
[10:21:22.592]                   NAME <- NAMES[[kk]]
[10:21:22.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.592]                     next
[10:21:22.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.592]                 }
[10:21:22.592]                 NAMES <- toupper(added)
[10:21:22.592]                 for (kk in seq_along(NAMES)) {
[10:21:22.592]                   name <- added[[kk]]
[10:21:22.592]                   NAME <- NAMES[[kk]]
[10:21:22.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.592]                     next
[10:21:22.592]                   args[[name]] <- ""
[10:21:22.592]                 }
[10:21:22.592]                 NAMES <- toupper(removed)
[10:21:22.592]                 for (kk in seq_along(NAMES)) {
[10:21:22.592]                   name <- removed[[kk]]
[10:21:22.592]                   NAME <- NAMES[[kk]]
[10:21:22.592]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.592]                     next
[10:21:22.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.592]                 }
[10:21:22.592]                 if (length(args) > 0) 
[10:21:22.592]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.592]             }
[10:21:22.592]             else {
[10:21:22.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.592]             }
[10:21:22.592]             {
[10:21:22.592]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.592]                   0L) {
[10:21:22.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.592]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.592]                   base::options(opts)
[10:21:22.592]                 }
[10:21:22.592]                 {
[10:21:22.592]                   {
[10:21:22.592]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.592]                     NULL
[10:21:22.592]                   }
[10:21:22.592]                   options(future.plan = NULL)
[10:21:22.592]                   if (is.na(NA_character_)) 
[10:21:22.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.592]                     .init = FALSE)
[10:21:22.592]                 }
[10:21:22.592]             }
[10:21:22.592]         }
[10:21:22.592]     })
[10:21:22.592]     if (TRUE) {
[10:21:22.592]         base::sink(type = "output", split = FALSE)
[10:21:22.592]         if (TRUE) {
[10:21:22.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.592]         }
[10:21:22.592]         else {
[10:21:22.592]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.592]         }
[10:21:22.592]         base::close(...future.stdout)
[10:21:22.592]         ...future.stdout <- NULL
[10:21:22.592]     }
[10:21:22.592]     ...future.result$conditions <- ...future.conditions
[10:21:22.592]     ...future.result$finished <- base::Sys.time()
[10:21:22.592]     ...future.result
[10:21:22.592] }
[10:21:22.595] MultisessionFuture started
[10:21:22.595] - Launch lazy future ... done
[10:21:22.595] run() for ‘MultisessionFuture’ ... done
[10:21:22.595] getGlobalsAndPackages() ...
[10:21:22.595] Searching for globals...
[10:21:22.595] 
[10:21:22.595] Searching for globals ... DONE
[10:21:22.596] - globals: [0] <none>
[10:21:22.596] getGlobalsAndPackages() ... DONE
[10:21:22.596] run() for ‘Future’ ...
[10:21:22.596] - state: ‘created’
[10:21:22.596] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.610] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.610] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.610]   - Field: ‘node’
[10:21:22.610]   - Field: ‘label’
[10:21:22.610]   - Field: ‘local’
[10:21:22.610]   - Field: ‘owner’
[10:21:22.610]   - Field: ‘envir’
[10:21:22.610]   - Field: ‘workers’
[10:21:22.611]   - Field: ‘packages’
[10:21:22.611]   - Field: ‘gc’
[10:21:22.611]   - Field: ‘conditions’
[10:21:22.611]   - Field: ‘persistent’
[10:21:22.611]   - Field: ‘expr’
[10:21:22.611]   - Field: ‘uuid’
[10:21:22.611]   - Field: ‘seed’
[10:21:22.611]   - Field: ‘version’
[10:21:22.611]   - Field: ‘result’
[10:21:22.611]   - Field: ‘asynchronous’
[10:21:22.611]   - Field: ‘calls’
[10:21:22.612]   - Field: ‘globals’
[10:21:22.612]   - Field: ‘stdout’
[10:21:22.612]   - Field: ‘earlySignal’
[10:21:22.612]   - Field: ‘lazy’
[10:21:22.612]   - Field: ‘state’
[10:21:22.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.612] - Launch lazy future ...
[10:21:22.612] Packages needed by the future expression (n = 0): <none>
[10:21:22.612] Packages needed by future strategies (n = 0): <none>
[10:21:22.613] {
[10:21:22.613]     {
[10:21:22.613]         {
[10:21:22.613]             ...future.startTime <- base::Sys.time()
[10:21:22.613]             {
[10:21:22.613]                 {
[10:21:22.613]                   {
[10:21:22.613]                     {
[10:21:22.613]                       base::local({
[10:21:22.613]                         has_future <- base::requireNamespace("future", 
[10:21:22.613]                           quietly = TRUE)
[10:21:22.613]                         if (has_future) {
[10:21:22.613]                           ns <- base::getNamespace("future")
[10:21:22.613]                           version <- ns[[".package"]][["version"]]
[10:21:22.613]                           if (is.null(version)) 
[10:21:22.613]                             version <- utils::packageVersion("future")
[10:21:22.613]                         }
[10:21:22.613]                         else {
[10:21:22.613]                           version <- NULL
[10:21:22.613]                         }
[10:21:22.613]                         if (!has_future || version < "1.8.0") {
[10:21:22.613]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.613]                             "", base::R.version$version.string), 
[10:21:22.613]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.613]                               "release", "version")], collapse = " "), 
[10:21:22.613]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.613]                             info)
[10:21:22.613]                           info <- base::paste(info, collapse = "; ")
[10:21:22.613]                           if (!has_future) {
[10:21:22.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.613]                               info)
[10:21:22.613]                           }
[10:21:22.613]                           else {
[10:21:22.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.613]                               info, version)
[10:21:22.613]                           }
[10:21:22.613]                           base::stop(msg)
[10:21:22.613]                         }
[10:21:22.613]                       })
[10:21:22.613]                     }
[10:21:22.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.613]                     base::options(mc.cores = 1L)
[10:21:22.613]                   }
[10:21:22.613]                   ...future.strategy.old <- future::plan("list")
[10:21:22.613]                   options(future.plan = NULL)
[10:21:22.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.613]                 }
[10:21:22.613]                 ...future.workdir <- getwd()
[10:21:22.613]             }
[10:21:22.613]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.613]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.613]         }
[10:21:22.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.613]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.613]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.613]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.613]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.613]             base::names(...future.oldOptions))
[10:21:22.613]     }
[10:21:22.613]     if (FALSE) {
[10:21:22.613]     }
[10:21:22.613]     else {
[10:21:22.613]         if (TRUE) {
[10:21:22.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.613]                 open = "w")
[10:21:22.613]         }
[10:21:22.613]         else {
[10:21:22.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.613]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.613]         }
[10:21:22.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.613]             base::sink(type = "output", split = FALSE)
[10:21:22.613]             base::close(...future.stdout)
[10:21:22.613]         }, add = TRUE)
[10:21:22.613]     }
[10:21:22.613]     ...future.frame <- base::sys.nframe()
[10:21:22.613]     ...future.conditions <- base::list()
[10:21:22.613]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.613]     if (FALSE) {
[10:21:22.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.613]     }
[10:21:22.613]     ...future.result <- base::tryCatch({
[10:21:22.613]         base::withCallingHandlers({
[10:21:22.613]             ...future.value <- base::withVisible(base::local({
[10:21:22.613]                 ...future.makeSendCondition <- base::local({
[10:21:22.613]                   sendCondition <- NULL
[10:21:22.613]                   function(frame = 1L) {
[10:21:22.613]                     if (is.function(sendCondition)) 
[10:21:22.613]                       return(sendCondition)
[10:21:22.613]                     ns <- getNamespace("parallel")
[10:21:22.613]                     if (exists("sendData", mode = "function", 
[10:21:22.613]                       envir = ns)) {
[10:21:22.613]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.613]                         envir = ns)
[10:21:22.613]                       envir <- sys.frame(frame)
[10:21:22.613]                       master <- NULL
[10:21:22.613]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.613]                         !identical(envir, emptyenv())) {
[10:21:22.613]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.613]                           inherits = FALSE)) {
[10:21:22.613]                           master <- get("master", mode = "list", 
[10:21:22.613]                             envir = envir, inherits = FALSE)
[10:21:22.613]                           if (inherits(master, c("SOCKnode", 
[10:21:22.613]                             "SOCK0node"))) {
[10:21:22.613]                             sendCondition <<- function(cond) {
[10:21:22.613]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.613]                                 success = TRUE)
[10:21:22.613]                               parallel_sendData(master, data)
[10:21:22.613]                             }
[10:21:22.613]                             return(sendCondition)
[10:21:22.613]                           }
[10:21:22.613]                         }
[10:21:22.613]                         frame <- frame + 1L
[10:21:22.613]                         envir <- sys.frame(frame)
[10:21:22.613]                       }
[10:21:22.613]                     }
[10:21:22.613]                     sendCondition <<- function(cond) NULL
[10:21:22.613]                   }
[10:21:22.613]                 })
[10:21:22.613]                 withCallingHandlers({
[10:21:22.613]                   NULL
[10:21:22.613]                 }, immediateCondition = function(cond) {
[10:21:22.613]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.613]                   sendCondition(cond)
[10:21:22.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.613]                   {
[10:21:22.613]                     inherits <- base::inherits
[10:21:22.613]                     invokeRestart <- base::invokeRestart
[10:21:22.613]                     is.null <- base::is.null
[10:21:22.613]                     muffled <- FALSE
[10:21:22.613]                     if (inherits(cond, "message")) {
[10:21:22.613]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.613]                       if (muffled) 
[10:21:22.613]                         invokeRestart("muffleMessage")
[10:21:22.613]                     }
[10:21:22.613]                     else if (inherits(cond, "warning")) {
[10:21:22.613]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.613]                       if (muffled) 
[10:21:22.613]                         invokeRestart("muffleWarning")
[10:21:22.613]                     }
[10:21:22.613]                     else if (inherits(cond, "condition")) {
[10:21:22.613]                       if (!is.null(pattern)) {
[10:21:22.613]                         computeRestarts <- base::computeRestarts
[10:21:22.613]                         grepl <- base::grepl
[10:21:22.613]                         restarts <- computeRestarts(cond)
[10:21:22.613]                         for (restart in restarts) {
[10:21:22.613]                           name <- restart$name
[10:21:22.613]                           if (is.null(name)) 
[10:21:22.613]                             next
[10:21:22.613]                           if (!grepl(pattern, name)) 
[10:21:22.613]                             next
[10:21:22.613]                           invokeRestart(restart)
[10:21:22.613]                           muffled <- TRUE
[10:21:22.613]                           break
[10:21:22.613]                         }
[10:21:22.613]                       }
[10:21:22.613]                     }
[10:21:22.613]                     invisible(muffled)
[10:21:22.613]                   }
[10:21:22.613]                   muffleCondition(cond)
[10:21:22.613]                 })
[10:21:22.613]             }))
[10:21:22.613]             future::FutureResult(value = ...future.value$value, 
[10:21:22.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.613]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.613]                     ...future.globalenv.names))
[10:21:22.613]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.613]         }, condition = base::local({
[10:21:22.613]             c <- base::c
[10:21:22.613]             inherits <- base::inherits
[10:21:22.613]             invokeRestart <- base::invokeRestart
[10:21:22.613]             length <- base::length
[10:21:22.613]             list <- base::list
[10:21:22.613]             seq.int <- base::seq.int
[10:21:22.613]             signalCondition <- base::signalCondition
[10:21:22.613]             sys.calls <- base::sys.calls
[10:21:22.613]             `[[` <- base::`[[`
[10:21:22.613]             `+` <- base::`+`
[10:21:22.613]             `<<-` <- base::`<<-`
[10:21:22.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.613]                   3L)]
[10:21:22.613]             }
[10:21:22.613]             function(cond) {
[10:21:22.613]                 is_error <- inherits(cond, "error")
[10:21:22.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.613]                   NULL)
[10:21:22.613]                 if (is_error) {
[10:21:22.613]                   sessionInformation <- function() {
[10:21:22.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.613]                       search = base::search(), system = base::Sys.info())
[10:21:22.613]                   }
[10:21:22.613]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.613]                     cond$call), session = sessionInformation(), 
[10:21:22.613]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.613]                   signalCondition(cond)
[10:21:22.613]                 }
[10:21:22.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.613]                 "immediateCondition"))) {
[10:21:22.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.613]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.613]                   if (TRUE && !signal) {
[10:21:22.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.613]                     {
[10:21:22.613]                       inherits <- base::inherits
[10:21:22.613]                       invokeRestart <- base::invokeRestart
[10:21:22.613]                       is.null <- base::is.null
[10:21:22.613]                       muffled <- FALSE
[10:21:22.613]                       if (inherits(cond, "message")) {
[10:21:22.613]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.613]                         if (muffled) 
[10:21:22.613]                           invokeRestart("muffleMessage")
[10:21:22.613]                       }
[10:21:22.613]                       else if (inherits(cond, "warning")) {
[10:21:22.613]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.613]                         if (muffled) 
[10:21:22.613]                           invokeRestart("muffleWarning")
[10:21:22.613]                       }
[10:21:22.613]                       else if (inherits(cond, "condition")) {
[10:21:22.613]                         if (!is.null(pattern)) {
[10:21:22.613]                           computeRestarts <- base::computeRestarts
[10:21:22.613]                           grepl <- base::grepl
[10:21:22.613]                           restarts <- computeRestarts(cond)
[10:21:22.613]                           for (restart in restarts) {
[10:21:22.613]                             name <- restart$name
[10:21:22.613]                             if (is.null(name)) 
[10:21:22.613]                               next
[10:21:22.613]                             if (!grepl(pattern, name)) 
[10:21:22.613]                               next
[10:21:22.613]                             invokeRestart(restart)
[10:21:22.613]                             muffled <- TRUE
[10:21:22.613]                             break
[10:21:22.613]                           }
[10:21:22.613]                         }
[10:21:22.613]                       }
[10:21:22.613]                       invisible(muffled)
[10:21:22.613]                     }
[10:21:22.613]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.613]                   }
[10:21:22.613]                 }
[10:21:22.613]                 else {
[10:21:22.613]                   if (TRUE) {
[10:21:22.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.613]                     {
[10:21:22.613]                       inherits <- base::inherits
[10:21:22.613]                       invokeRestart <- base::invokeRestart
[10:21:22.613]                       is.null <- base::is.null
[10:21:22.613]                       muffled <- FALSE
[10:21:22.613]                       if (inherits(cond, "message")) {
[10:21:22.613]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.613]                         if (muffled) 
[10:21:22.613]                           invokeRestart("muffleMessage")
[10:21:22.613]                       }
[10:21:22.613]                       else if (inherits(cond, "warning")) {
[10:21:22.613]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.613]                         if (muffled) 
[10:21:22.613]                           invokeRestart("muffleWarning")
[10:21:22.613]                       }
[10:21:22.613]                       else if (inherits(cond, "condition")) {
[10:21:22.613]                         if (!is.null(pattern)) {
[10:21:22.613]                           computeRestarts <- base::computeRestarts
[10:21:22.613]                           grepl <- base::grepl
[10:21:22.613]                           restarts <- computeRestarts(cond)
[10:21:22.613]                           for (restart in restarts) {
[10:21:22.613]                             name <- restart$name
[10:21:22.613]                             if (is.null(name)) 
[10:21:22.613]                               next
[10:21:22.613]                             if (!grepl(pattern, name)) 
[10:21:22.613]                               next
[10:21:22.613]                             invokeRestart(restart)
[10:21:22.613]                             muffled <- TRUE
[10:21:22.613]                             break
[10:21:22.613]                           }
[10:21:22.613]                         }
[10:21:22.613]                       }
[10:21:22.613]                       invisible(muffled)
[10:21:22.613]                     }
[10:21:22.613]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.613]                   }
[10:21:22.613]                 }
[10:21:22.613]             }
[10:21:22.613]         }))
[10:21:22.613]     }, error = function(ex) {
[10:21:22.613]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.613]                 ...future.rng), started = ...future.startTime, 
[10:21:22.613]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.613]             version = "1.8"), class = "FutureResult")
[10:21:22.613]     }, finally = {
[10:21:22.613]         if (!identical(...future.workdir, getwd())) 
[10:21:22.613]             setwd(...future.workdir)
[10:21:22.613]         {
[10:21:22.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.613]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.613]             }
[10:21:22.613]             base::options(...future.oldOptions)
[10:21:22.613]             if (.Platform$OS.type == "windows") {
[10:21:22.613]                 old_names <- names(...future.oldEnvVars)
[10:21:22.613]                 envs <- base::Sys.getenv()
[10:21:22.613]                 names <- names(envs)
[10:21:22.613]                 common <- intersect(names, old_names)
[10:21:22.613]                 added <- setdiff(names, old_names)
[10:21:22.613]                 removed <- setdiff(old_names, names)
[10:21:22.613]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.613]                   envs[common]]
[10:21:22.613]                 NAMES <- toupper(changed)
[10:21:22.613]                 args <- list()
[10:21:22.613]                 for (kk in seq_along(NAMES)) {
[10:21:22.613]                   name <- changed[[kk]]
[10:21:22.613]                   NAME <- NAMES[[kk]]
[10:21:22.613]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.613]                     next
[10:21:22.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.613]                 }
[10:21:22.613]                 NAMES <- toupper(added)
[10:21:22.613]                 for (kk in seq_along(NAMES)) {
[10:21:22.613]                   name <- added[[kk]]
[10:21:22.613]                   NAME <- NAMES[[kk]]
[10:21:22.613]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.613]                     next
[10:21:22.613]                   args[[name]] <- ""
[10:21:22.613]                 }
[10:21:22.613]                 NAMES <- toupper(removed)
[10:21:22.613]                 for (kk in seq_along(NAMES)) {
[10:21:22.613]                   name <- removed[[kk]]
[10:21:22.613]                   NAME <- NAMES[[kk]]
[10:21:22.613]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.613]                     next
[10:21:22.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.613]                 }
[10:21:22.613]                 if (length(args) > 0) 
[10:21:22.613]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.613]             }
[10:21:22.613]             else {
[10:21:22.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.613]             }
[10:21:22.613]             {
[10:21:22.613]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.613]                   0L) {
[10:21:22.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.613]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.613]                   base::options(opts)
[10:21:22.613]                 }
[10:21:22.613]                 {
[10:21:22.613]                   {
[10:21:22.613]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.613]                     NULL
[10:21:22.613]                   }
[10:21:22.613]                   options(future.plan = NULL)
[10:21:22.613]                   if (is.na(NA_character_)) 
[10:21:22.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.613]                     .init = FALSE)
[10:21:22.613]                 }
[10:21:22.613]             }
[10:21:22.613]         }
[10:21:22.613]     })
[10:21:22.613]     if (TRUE) {
[10:21:22.613]         base::sink(type = "output", split = FALSE)
[10:21:22.613]         if (TRUE) {
[10:21:22.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.613]         }
[10:21:22.613]         else {
[10:21:22.613]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.613]         }
[10:21:22.613]         base::close(...future.stdout)
[10:21:22.613]         ...future.stdout <- NULL
[10:21:22.613]     }
[10:21:22.613]     ...future.result$conditions <- ...future.conditions
[10:21:22.613]     ...future.result$finished <- base::Sys.time()
[10:21:22.613]     ...future.result
[10:21:22.613] }
[10:21:22.616] MultisessionFuture started
[10:21:22.616] - Launch lazy future ... done
[10:21:22.616] run() for ‘MultisessionFuture’ ... done
[10:21:22.616] getGlobalsAndPackages() ...
[10:21:22.616] Searching for globals...
[10:21:22.617] - globals found: [1] ‘{’
[10:21:22.617] Searching for globals ... DONE
[10:21:22.617] Resolving globals: FALSE
[10:21:22.617] 
[10:21:22.617] 
[10:21:22.618] getGlobalsAndPackages() ... DONE
[10:21:22.618] run() for ‘Future’ ...
[10:21:22.618] - state: ‘created’
[10:21:22.618] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.632] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.632] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.632]   - Field: ‘node’
[10:21:22.632]   - Field: ‘label’
[10:21:22.632]   - Field: ‘local’
[10:21:22.632]   - Field: ‘owner’
[10:21:22.632]   - Field: ‘envir’
[10:21:22.633]   - Field: ‘workers’
[10:21:22.633]   - Field: ‘packages’
[10:21:22.633]   - Field: ‘gc’
[10:21:22.633]   - Field: ‘conditions’
[10:21:22.633]   - Field: ‘persistent’
[10:21:22.633]   - Field: ‘expr’
[10:21:22.633]   - Field: ‘uuid’
[10:21:22.633]   - Field: ‘seed’
[10:21:22.633]   - Field: ‘version’
[10:21:22.633]   - Field: ‘result’
[10:21:22.633]   - Field: ‘asynchronous’
[10:21:22.634]   - Field: ‘calls’
[10:21:22.634]   - Field: ‘globals’
[10:21:22.634]   - Field: ‘stdout’
[10:21:22.634]   - Field: ‘earlySignal’
[10:21:22.634]   - Field: ‘lazy’
[10:21:22.634]   - Field: ‘state’
[10:21:22.634] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.634] - Launch lazy future ...
[10:21:22.634] Packages needed by the future expression (n = 0): <none>
[10:21:22.634] Packages needed by future strategies (n = 0): <none>
[10:21:22.635] {
[10:21:22.635]     {
[10:21:22.635]         {
[10:21:22.635]             ...future.startTime <- base::Sys.time()
[10:21:22.635]             {
[10:21:22.635]                 {
[10:21:22.635]                   {
[10:21:22.635]                     {
[10:21:22.635]                       base::local({
[10:21:22.635]                         has_future <- base::requireNamespace("future", 
[10:21:22.635]                           quietly = TRUE)
[10:21:22.635]                         if (has_future) {
[10:21:22.635]                           ns <- base::getNamespace("future")
[10:21:22.635]                           version <- ns[[".package"]][["version"]]
[10:21:22.635]                           if (is.null(version)) 
[10:21:22.635]                             version <- utils::packageVersion("future")
[10:21:22.635]                         }
[10:21:22.635]                         else {
[10:21:22.635]                           version <- NULL
[10:21:22.635]                         }
[10:21:22.635]                         if (!has_future || version < "1.8.0") {
[10:21:22.635]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.635]                             "", base::R.version$version.string), 
[10:21:22.635]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.635]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.635]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.635]                               "release", "version")], collapse = " "), 
[10:21:22.635]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.635]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.635]                             info)
[10:21:22.635]                           info <- base::paste(info, collapse = "; ")
[10:21:22.635]                           if (!has_future) {
[10:21:22.635]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.635]                               info)
[10:21:22.635]                           }
[10:21:22.635]                           else {
[10:21:22.635]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.635]                               info, version)
[10:21:22.635]                           }
[10:21:22.635]                           base::stop(msg)
[10:21:22.635]                         }
[10:21:22.635]                       })
[10:21:22.635]                     }
[10:21:22.635]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.635]                     base::options(mc.cores = 1L)
[10:21:22.635]                   }
[10:21:22.635]                   ...future.strategy.old <- future::plan("list")
[10:21:22.635]                   options(future.plan = NULL)
[10:21:22.635]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.635]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.635]                 }
[10:21:22.635]                 ...future.workdir <- getwd()
[10:21:22.635]             }
[10:21:22.635]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.635]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.635]         }
[10:21:22.635]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.635]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.635]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.635]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.635]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.635]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.635]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.635]             base::names(...future.oldOptions))
[10:21:22.635]     }
[10:21:22.635]     if (FALSE) {
[10:21:22.635]     }
[10:21:22.635]     else {
[10:21:22.635]         if (TRUE) {
[10:21:22.635]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.635]                 open = "w")
[10:21:22.635]         }
[10:21:22.635]         else {
[10:21:22.635]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.635]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.635]         }
[10:21:22.635]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.635]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.635]             base::sink(type = "output", split = FALSE)
[10:21:22.635]             base::close(...future.stdout)
[10:21:22.635]         }, add = TRUE)
[10:21:22.635]     }
[10:21:22.635]     ...future.frame <- base::sys.nframe()
[10:21:22.635]     ...future.conditions <- base::list()
[10:21:22.635]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.635]     if (FALSE) {
[10:21:22.635]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.635]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.635]     }
[10:21:22.635]     ...future.result <- base::tryCatch({
[10:21:22.635]         base::withCallingHandlers({
[10:21:22.635]             ...future.value <- base::withVisible(base::local({
[10:21:22.635]                 ...future.makeSendCondition <- base::local({
[10:21:22.635]                   sendCondition <- NULL
[10:21:22.635]                   function(frame = 1L) {
[10:21:22.635]                     if (is.function(sendCondition)) 
[10:21:22.635]                       return(sendCondition)
[10:21:22.635]                     ns <- getNamespace("parallel")
[10:21:22.635]                     if (exists("sendData", mode = "function", 
[10:21:22.635]                       envir = ns)) {
[10:21:22.635]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.635]                         envir = ns)
[10:21:22.635]                       envir <- sys.frame(frame)
[10:21:22.635]                       master <- NULL
[10:21:22.635]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.635]                         !identical(envir, emptyenv())) {
[10:21:22.635]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.635]                           inherits = FALSE)) {
[10:21:22.635]                           master <- get("master", mode = "list", 
[10:21:22.635]                             envir = envir, inherits = FALSE)
[10:21:22.635]                           if (inherits(master, c("SOCKnode", 
[10:21:22.635]                             "SOCK0node"))) {
[10:21:22.635]                             sendCondition <<- function(cond) {
[10:21:22.635]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.635]                                 success = TRUE)
[10:21:22.635]                               parallel_sendData(master, data)
[10:21:22.635]                             }
[10:21:22.635]                             return(sendCondition)
[10:21:22.635]                           }
[10:21:22.635]                         }
[10:21:22.635]                         frame <- frame + 1L
[10:21:22.635]                         envir <- sys.frame(frame)
[10:21:22.635]                       }
[10:21:22.635]                     }
[10:21:22.635]                     sendCondition <<- function(cond) NULL
[10:21:22.635]                   }
[10:21:22.635]                 })
[10:21:22.635]                 withCallingHandlers({
[10:21:22.635]                   {
[10:21:22.635]                     4
[10:21:22.635]                   }
[10:21:22.635]                 }, immediateCondition = function(cond) {
[10:21:22.635]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.635]                   sendCondition(cond)
[10:21:22.635]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.635]                   {
[10:21:22.635]                     inherits <- base::inherits
[10:21:22.635]                     invokeRestart <- base::invokeRestart
[10:21:22.635]                     is.null <- base::is.null
[10:21:22.635]                     muffled <- FALSE
[10:21:22.635]                     if (inherits(cond, "message")) {
[10:21:22.635]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.635]                       if (muffled) 
[10:21:22.635]                         invokeRestart("muffleMessage")
[10:21:22.635]                     }
[10:21:22.635]                     else if (inherits(cond, "warning")) {
[10:21:22.635]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.635]                       if (muffled) 
[10:21:22.635]                         invokeRestart("muffleWarning")
[10:21:22.635]                     }
[10:21:22.635]                     else if (inherits(cond, "condition")) {
[10:21:22.635]                       if (!is.null(pattern)) {
[10:21:22.635]                         computeRestarts <- base::computeRestarts
[10:21:22.635]                         grepl <- base::grepl
[10:21:22.635]                         restarts <- computeRestarts(cond)
[10:21:22.635]                         for (restart in restarts) {
[10:21:22.635]                           name <- restart$name
[10:21:22.635]                           if (is.null(name)) 
[10:21:22.635]                             next
[10:21:22.635]                           if (!grepl(pattern, name)) 
[10:21:22.635]                             next
[10:21:22.635]                           invokeRestart(restart)
[10:21:22.635]                           muffled <- TRUE
[10:21:22.635]                           break
[10:21:22.635]                         }
[10:21:22.635]                       }
[10:21:22.635]                     }
[10:21:22.635]                     invisible(muffled)
[10:21:22.635]                   }
[10:21:22.635]                   muffleCondition(cond)
[10:21:22.635]                 })
[10:21:22.635]             }))
[10:21:22.635]             future::FutureResult(value = ...future.value$value, 
[10:21:22.635]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.635]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.635]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.635]                     ...future.globalenv.names))
[10:21:22.635]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.635]         }, condition = base::local({
[10:21:22.635]             c <- base::c
[10:21:22.635]             inherits <- base::inherits
[10:21:22.635]             invokeRestart <- base::invokeRestart
[10:21:22.635]             length <- base::length
[10:21:22.635]             list <- base::list
[10:21:22.635]             seq.int <- base::seq.int
[10:21:22.635]             signalCondition <- base::signalCondition
[10:21:22.635]             sys.calls <- base::sys.calls
[10:21:22.635]             `[[` <- base::`[[`
[10:21:22.635]             `+` <- base::`+`
[10:21:22.635]             `<<-` <- base::`<<-`
[10:21:22.635]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.635]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.635]                   3L)]
[10:21:22.635]             }
[10:21:22.635]             function(cond) {
[10:21:22.635]                 is_error <- inherits(cond, "error")
[10:21:22.635]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.635]                   NULL)
[10:21:22.635]                 if (is_error) {
[10:21:22.635]                   sessionInformation <- function() {
[10:21:22.635]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.635]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.635]                       search = base::search(), system = base::Sys.info())
[10:21:22.635]                   }
[10:21:22.635]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.635]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.635]                     cond$call), session = sessionInformation(), 
[10:21:22.635]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.635]                   signalCondition(cond)
[10:21:22.635]                 }
[10:21:22.635]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.635]                 "immediateCondition"))) {
[10:21:22.635]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.635]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.635]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.635]                   if (TRUE && !signal) {
[10:21:22.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.635]                     {
[10:21:22.635]                       inherits <- base::inherits
[10:21:22.635]                       invokeRestart <- base::invokeRestart
[10:21:22.635]                       is.null <- base::is.null
[10:21:22.635]                       muffled <- FALSE
[10:21:22.635]                       if (inherits(cond, "message")) {
[10:21:22.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.635]                         if (muffled) 
[10:21:22.635]                           invokeRestart("muffleMessage")
[10:21:22.635]                       }
[10:21:22.635]                       else if (inherits(cond, "warning")) {
[10:21:22.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.635]                         if (muffled) 
[10:21:22.635]                           invokeRestart("muffleWarning")
[10:21:22.635]                       }
[10:21:22.635]                       else if (inherits(cond, "condition")) {
[10:21:22.635]                         if (!is.null(pattern)) {
[10:21:22.635]                           computeRestarts <- base::computeRestarts
[10:21:22.635]                           grepl <- base::grepl
[10:21:22.635]                           restarts <- computeRestarts(cond)
[10:21:22.635]                           for (restart in restarts) {
[10:21:22.635]                             name <- restart$name
[10:21:22.635]                             if (is.null(name)) 
[10:21:22.635]                               next
[10:21:22.635]                             if (!grepl(pattern, name)) 
[10:21:22.635]                               next
[10:21:22.635]                             invokeRestart(restart)
[10:21:22.635]                             muffled <- TRUE
[10:21:22.635]                             break
[10:21:22.635]                           }
[10:21:22.635]                         }
[10:21:22.635]                       }
[10:21:22.635]                       invisible(muffled)
[10:21:22.635]                     }
[10:21:22.635]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.635]                   }
[10:21:22.635]                 }
[10:21:22.635]                 else {
[10:21:22.635]                   if (TRUE) {
[10:21:22.635]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.635]                     {
[10:21:22.635]                       inherits <- base::inherits
[10:21:22.635]                       invokeRestart <- base::invokeRestart
[10:21:22.635]                       is.null <- base::is.null
[10:21:22.635]                       muffled <- FALSE
[10:21:22.635]                       if (inherits(cond, "message")) {
[10:21:22.635]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.635]                         if (muffled) 
[10:21:22.635]                           invokeRestart("muffleMessage")
[10:21:22.635]                       }
[10:21:22.635]                       else if (inherits(cond, "warning")) {
[10:21:22.635]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.635]                         if (muffled) 
[10:21:22.635]                           invokeRestart("muffleWarning")
[10:21:22.635]                       }
[10:21:22.635]                       else if (inherits(cond, "condition")) {
[10:21:22.635]                         if (!is.null(pattern)) {
[10:21:22.635]                           computeRestarts <- base::computeRestarts
[10:21:22.635]                           grepl <- base::grepl
[10:21:22.635]                           restarts <- computeRestarts(cond)
[10:21:22.635]                           for (restart in restarts) {
[10:21:22.635]                             name <- restart$name
[10:21:22.635]                             if (is.null(name)) 
[10:21:22.635]                               next
[10:21:22.635]                             if (!grepl(pattern, name)) 
[10:21:22.635]                               next
[10:21:22.635]                             invokeRestart(restart)
[10:21:22.635]                             muffled <- TRUE
[10:21:22.635]                             break
[10:21:22.635]                           }
[10:21:22.635]                         }
[10:21:22.635]                       }
[10:21:22.635]                       invisible(muffled)
[10:21:22.635]                     }
[10:21:22.635]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.635]                   }
[10:21:22.635]                 }
[10:21:22.635]             }
[10:21:22.635]         }))
[10:21:22.635]     }, error = function(ex) {
[10:21:22.635]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.635]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.635]                 ...future.rng), started = ...future.startTime, 
[10:21:22.635]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.635]             version = "1.8"), class = "FutureResult")
[10:21:22.635]     }, finally = {
[10:21:22.635]         if (!identical(...future.workdir, getwd())) 
[10:21:22.635]             setwd(...future.workdir)
[10:21:22.635]         {
[10:21:22.635]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.635]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.635]             }
[10:21:22.635]             base::options(...future.oldOptions)
[10:21:22.635]             if (.Platform$OS.type == "windows") {
[10:21:22.635]                 old_names <- names(...future.oldEnvVars)
[10:21:22.635]                 envs <- base::Sys.getenv()
[10:21:22.635]                 names <- names(envs)
[10:21:22.635]                 common <- intersect(names, old_names)
[10:21:22.635]                 added <- setdiff(names, old_names)
[10:21:22.635]                 removed <- setdiff(old_names, names)
[10:21:22.635]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.635]                   envs[common]]
[10:21:22.635]                 NAMES <- toupper(changed)
[10:21:22.635]                 args <- list()
[10:21:22.635]                 for (kk in seq_along(NAMES)) {
[10:21:22.635]                   name <- changed[[kk]]
[10:21:22.635]                   NAME <- NAMES[[kk]]
[10:21:22.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.635]                     next
[10:21:22.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.635]                 }
[10:21:22.635]                 NAMES <- toupper(added)
[10:21:22.635]                 for (kk in seq_along(NAMES)) {
[10:21:22.635]                   name <- added[[kk]]
[10:21:22.635]                   NAME <- NAMES[[kk]]
[10:21:22.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.635]                     next
[10:21:22.635]                   args[[name]] <- ""
[10:21:22.635]                 }
[10:21:22.635]                 NAMES <- toupper(removed)
[10:21:22.635]                 for (kk in seq_along(NAMES)) {
[10:21:22.635]                   name <- removed[[kk]]
[10:21:22.635]                   NAME <- NAMES[[kk]]
[10:21:22.635]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.635]                     next
[10:21:22.635]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.635]                 }
[10:21:22.635]                 if (length(args) > 0) 
[10:21:22.635]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.635]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.635]             }
[10:21:22.635]             else {
[10:21:22.635]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.635]             }
[10:21:22.635]             {
[10:21:22.635]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.635]                   0L) {
[10:21:22.635]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.635]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.635]                   base::options(opts)
[10:21:22.635]                 }
[10:21:22.635]                 {
[10:21:22.635]                   {
[10:21:22.635]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.635]                     NULL
[10:21:22.635]                   }
[10:21:22.635]                   options(future.plan = NULL)
[10:21:22.635]                   if (is.na(NA_character_)) 
[10:21:22.635]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.635]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.635]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.635]                     .init = FALSE)
[10:21:22.635]                 }
[10:21:22.635]             }
[10:21:22.635]         }
[10:21:22.635]     })
[10:21:22.635]     if (TRUE) {
[10:21:22.635]         base::sink(type = "output", split = FALSE)
[10:21:22.635]         if (TRUE) {
[10:21:22.635]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.635]         }
[10:21:22.635]         else {
[10:21:22.635]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.635]         }
[10:21:22.635]         base::close(...future.stdout)
[10:21:22.635]         ...future.stdout <- NULL
[10:21:22.635]     }
[10:21:22.635]     ...future.result$conditions <- ...future.conditions
[10:21:22.635]     ...future.result$finished <- base::Sys.time()
[10:21:22.635]     ...future.result
[10:21:22.635] }
[10:21:22.637] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:22.648] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.648] - Validating connection of MultisessionFuture
[10:21:22.648] - received message: FutureResult
[10:21:22.648] - Received FutureResult
[10:21:22.648] - Erased future from FutureRegistry
[10:21:22.648] result() for ClusterFuture ...
[10:21:22.649] - result already collected: FutureResult
[10:21:22.649] result() for ClusterFuture ... done
[10:21:22.649] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.649] result() for ClusterFuture ...
[10:21:22.649] - result already collected: FutureResult
[10:21:22.649] result() for ClusterFuture ... done
[10:21:22.649] result() for ClusterFuture ...
[10:21:22.649] - result already collected: FutureResult
[10:21:22.649] result() for ClusterFuture ... done
[10:21:22.650] MultisessionFuture started
[10:21:22.650] - Launch lazy future ... done
[10:21:22.650] run() for ‘MultisessionFuture’ ... done
<environment: 0x55e8e4aefde8> 
<environment: 0x55e8e6947c68> 
[10:21:22.658] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.658] - Validating connection of MultisessionFuture
[10:21:22.658] - received message: FutureResult
[10:21:22.659] - Received FutureResult
[10:21:22.659] - Erased future from FutureRegistry
[10:21:22.659] result() for ClusterFuture ...
[10:21:22.659] - result already collected: FutureResult
[10:21:22.659] result() for ClusterFuture ... done
[10:21:22.659] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:22.671] resolve() on environment ...
[10:21:22.671]  recursive: 0
[10:21:22.671]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:22.671] signalConditionsASAP(numeric, pos=1) ...
[10:21:22.672] - nx: 4
[10:21:22.672] - relay: TRUE
[10:21:22.672] - stdout: TRUE
[10:21:22.672] - signal: TRUE
[10:21:22.672] - resignal: FALSE
[10:21:22.672] - force: TRUE
[10:21:22.672] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.672] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.672]  - until=2
[10:21:22.672]  - relaying element #2
[10:21:22.672] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.672] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.673] signalConditionsASAP(NULL, pos=1) ... done
[10:21:22.673]  length: 3 (resolved future 1)
[10:21:22.673] Future #2
[10:21:22.673] result() for ClusterFuture ...
[10:21:22.673] - result already collected: FutureResult
[10:21:22.673] result() for ClusterFuture ... done
[10:21:22.673] result() for ClusterFuture ...
[10:21:22.673] - result already collected: FutureResult
[10:21:22.673] result() for ClusterFuture ... done
[10:21:22.673] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:22.673] - nx: 4
[10:21:22.674] - relay: TRUE
[10:21:22.674] - stdout: TRUE
[10:21:22.674] - signal: TRUE
[10:21:22.674] - resignal: FALSE
[10:21:22.674] - force: TRUE
[10:21:22.674] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.674] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.674]  - until=2
[10:21:22.674]  - relaying element #2
[10:21:22.674] result() for ClusterFuture ...
[10:21:22.674] - result already collected: FutureResult
[10:21:22.674] result() for ClusterFuture ... done
[10:21:22.675] result() for ClusterFuture ...
[10:21:22.675] - result already collected: FutureResult
[10:21:22.675] result() for ClusterFuture ... done
[10:21:22.675] result() for ClusterFuture ...
[10:21:22.675] - result already collected: FutureResult
[10:21:22.675] result() for ClusterFuture ... done
[10:21:22.675] result() for ClusterFuture ...
[10:21:22.675] - result already collected: FutureResult
[10:21:22.675] result() for ClusterFuture ... done
[10:21:22.675] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.675] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.675] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:22.676]  length: 2 (resolved future 2)
[10:21:22.676] Future #3
[10:21:22.676] result() for ClusterFuture ...
[10:21:22.676] - result already collected: FutureResult
[10:21:22.676] result() for ClusterFuture ... done
[10:21:22.676] result() for ClusterFuture ...
[10:21:22.676] - result already collected: FutureResult
[10:21:22.676] result() for ClusterFuture ... done
[10:21:22.676] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:22.676] - nx: 4
[10:21:22.676] - relay: TRUE
[10:21:22.676] - stdout: TRUE
[10:21:22.677] - signal: TRUE
[10:21:22.677] - resignal: FALSE
[10:21:22.677] - force: TRUE
[10:21:22.677] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.677] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.677]  - until=3
[10:21:22.677]  - relaying element #3
[10:21:22.677] result() for ClusterFuture ...
[10:21:22.677] - result already collected: FutureResult
[10:21:22.677] result() for ClusterFuture ... done
[10:21:22.677] result() for ClusterFuture ...
[10:21:22.677] - result already collected: FutureResult
[10:21:22.677] result() for ClusterFuture ... done
[10:21:22.678] result() for ClusterFuture ...
[10:21:22.678] - result already collected: FutureResult
[10:21:22.678] result() for ClusterFuture ... done
[10:21:22.678] result() for ClusterFuture ...
[10:21:22.678] - result already collected: FutureResult
[10:21:22.678] result() for ClusterFuture ... done
[10:21:22.678] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.678] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.678] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:22.678]  length: 1 (resolved future 3)
[10:21:22.699] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.699] - Validating connection of MultisessionFuture
[10:21:22.700] - received message: FutureResult
[10:21:22.700] - Received FutureResult
[10:21:22.700] - Erased future from FutureRegistry
[10:21:22.700] result() for ClusterFuture ...
[10:21:22.700] - result already collected: FutureResult
[10:21:22.700] result() for ClusterFuture ... done
[10:21:22.700] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.700] Future #4
[10:21:22.700] result() for ClusterFuture ...
[10:21:22.700] - result already collected: FutureResult
[10:21:22.700] result() for ClusterFuture ... done
[10:21:22.701] result() for ClusterFuture ...
[10:21:22.701] - result already collected: FutureResult
[10:21:22.701] result() for ClusterFuture ... done
[10:21:22.701] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:22.701] - nx: 4
[10:21:22.701] - relay: TRUE
[10:21:22.701] - stdout: TRUE
[10:21:22.701] - signal: TRUE
[10:21:22.701] - resignal: FALSE
[10:21:22.701] - force: TRUE
[10:21:22.701] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.701] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.702]  - until=4
[10:21:22.702]  - relaying element #4
[10:21:22.702] result() for ClusterFuture ...
[10:21:22.702] - result already collected: FutureResult
[10:21:22.702] result() for ClusterFuture ... done
[10:21:22.702] result() for ClusterFuture ...
[10:21:22.702] - result already collected: FutureResult
[10:21:22.702] result() for ClusterFuture ... done
[10:21:22.702] result() for ClusterFuture ...
[10:21:22.702] - result already collected: FutureResult
[10:21:22.702] result() for ClusterFuture ... done
[10:21:22.702] result() for ClusterFuture ...
[10:21:22.703] - result already collected: FutureResult
[10:21:22.703] result() for ClusterFuture ... done
[10:21:22.703] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.703] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.703] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:22.703]  length: 0 (resolved future 4)
[10:21:22.703] Relaying remaining futures
[10:21:22.703] signalConditionsASAP(NULL, pos=0) ...
[10:21:22.703] - nx: 4
[10:21:22.703] - relay: TRUE
[10:21:22.703] - stdout: TRUE
[10:21:22.703] - signal: TRUE
[10:21:22.703] - resignal: FALSE
[10:21:22.704] - force: TRUE
[10:21:22.704] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.704] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:22.704] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.704] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.704] signalConditionsASAP(NULL, pos=0) ... done
[10:21:22.704] resolve() on environment ... DONE
[10:21:22.704] result() for ClusterFuture ...
[10:21:22.704] - result already collected: FutureResult
[10:21:22.704] result() for ClusterFuture ... done
[10:21:22.704] result() for ClusterFuture ...
[10:21:22.705] - result already collected: FutureResult
[10:21:22.705] result() for ClusterFuture ... done
[10:21:22.705] result() for ClusterFuture ...
[10:21:22.705] - result already collected: FutureResult
[10:21:22.705] result() for ClusterFuture ... done
[10:21:22.705] result() for ClusterFuture ...
[10:21:22.705] - result already collected: FutureResult
[10:21:22.705] result() for ClusterFuture ... done
[10:21:22.705] result() for ClusterFuture ...
[10:21:22.705] - result already collected: FutureResult
[10:21:22.705] result() for ClusterFuture ... done
[10:21:22.705] result() for ClusterFuture ...
[10:21:22.705] - result already collected: FutureResult
[10:21:22.706] result() for ClusterFuture ... done
<environment: 0x55e8e6a8fc00> 
Dimensions: c(2, 1, 3, 1)
[10:21:22.706] getGlobalsAndPackages() ...
[10:21:22.706] Searching for globals...
[10:21:22.706] 
[10:21:22.706] Searching for globals ... DONE
[10:21:22.707] - globals: [0] <none>
[10:21:22.707] getGlobalsAndPackages() ... DONE
[10:21:22.707] run() for ‘Future’ ...
[10:21:22.707] - state: ‘created’
[10:21:22.707] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.721] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.721] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.721]   - Field: ‘node’
[10:21:22.721]   - Field: ‘label’
[10:21:22.721]   - Field: ‘local’
[10:21:22.721]   - Field: ‘owner’
[10:21:22.721]   - Field: ‘envir’
[10:21:22.722]   - Field: ‘workers’
[10:21:22.722]   - Field: ‘packages’
[10:21:22.722]   - Field: ‘gc’
[10:21:22.722]   - Field: ‘conditions’
[10:21:22.722]   - Field: ‘persistent’
[10:21:22.722]   - Field: ‘expr’
[10:21:22.722]   - Field: ‘uuid’
[10:21:22.722]   - Field: ‘seed’
[10:21:22.722]   - Field: ‘version’
[10:21:22.722]   - Field: ‘result’
[10:21:22.722]   - Field: ‘asynchronous’
[10:21:22.723]   - Field: ‘calls’
[10:21:22.723]   - Field: ‘globals’
[10:21:22.723]   - Field: ‘stdout’
[10:21:22.723]   - Field: ‘earlySignal’
[10:21:22.723]   - Field: ‘lazy’
[10:21:22.723]   - Field: ‘state’
[10:21:22.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.723] - Launch lazy future ...
[10:21:22.723] Packages needed by the future expression (n = 0): <none>
[10:21:22.726] Packages needed by future strategies (n = 0): <none>
[10:21:22.726] {
[10:21:22.726]     {
[10:21:22.726]         {
[10:21:22.726]             ...future.startTime <- base::Sys.time()
[10:21:22.726]             {
[10:21:22.726]                 {
[10:21:22.726]                   {
[10:21:22.726]                     {
[10:21:22.726]                       base::local({
[10:21:22.726]                         has_future <- base::requireNamespace("future", 
[10:21:22.726]                           quietly = TRUE)
[10:21:22.726]                         if (has_future) {
[10:21:22.726]                           ns <- base::getNamespace("future")
[10:21:22.726]                           version <- ns[[".package"]][["version"]]
[10:21:22.726]                           if (is.null(version)) 
[10:21:22.726]                             version <- utils::packageVersion("future")
[10:21:22.726]                         }
[10:21:22.726]                         else {
[10:21:22.726]                           version <- NULL
[10:21:22.726]                         }
[10:21:22.726]                         if (!has_future || version < "1.8.0") {
[10:21:22.726]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.726]                             "", base::R.version$version.string), 
[10:21:22.726]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.726]                               "release", "version")], collapse = " "), 
[10:21:22.726]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.726]                             info)
[10:21:22.726]                           info <- base::paste(info, collapse = "; ")
[10:21:22.726]                           if (!has_future) {
[10:21:22.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.726]                               info)
[10:21:22.726]                           }
[10:21:22.726]                           else {
[10:21:22.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.726]                               info, version)
[10:21:22.726]                           }
[10:21:22.726]                           base::stop(msg)
[10:21:22.726]                         }
[10:21:22.726]                       })
[10:21:22.726]                     }
[10:21:22.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.726]                     base::options(mc.cores = 1L)
[10:21:22.726]                   }
[10:21:22.726]                   ...future.strategy.old <- future::plan("list")
[10:21:22.726]                   options(future.plan = NULL)
[10:21:22.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.726]                 }
[10:21:22.726]                 ...future.workdir <- getwd()
[10:21:22.726]             }
[10:21:22.726]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.726]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.726]         }
[10:21:22.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.726]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.726]             base::names(...future.oldOptions))
[10:21:22.726]     }
[10:21:22.726]     if (FALSE) {
[10:21:22.726]     }
[10:21:22.726]     else {
[10:21:22.726]         if (TRUE) {
[10:21:22.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.726]                 open = "w")
[10:21:22.726]         }
[10:21:22.726]         else {
[10:21:22.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.726]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.726]         }
[10:21:22.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.726]             base::sink(type = "output", split = FALSE)
[10:21:22.726]             base::close(...future.stdout)
[10:21:22.726]         }, add = TRUE)
[10:21:22.726]     }
[10:21:22.726]     ...future.frame <- base::sys.nframe()
[10:21:22.726]     ...future.conditions <- base::list()
[10:21:22.726]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.726]     if (FALSE) {
[10:21:22.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.726]     }
[10:21:22.726]     ...future.result <- base::tryCatch({
[10:21:22.726]         base::withCallingHandlers({
[10:21:22.726]             ...future.value <- base::withVisible(base::local({
[10:21:22.726]                 ...future.makeSendCondition <- base::local({
[10:21:22.726]                   sendCondition <- NULL
[10:21:22.726]                   function(frame = 1L) {
[10:21:22.726]                     if (is.function(sendCondition)) 
[10:21:22.726]                       return(sendCondition)
[10:21:22.726]                     ns <- getNamespace("parallel")
[10:21:22.726]                     if (exists("sendData", mode = "function", 
[10:21:22.726]                       envir = ns)) {
[10:21:22.726]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.726]                         envir = ns)
[10:21:22.726]                       envir <- sys.frame(frame)
[10:21:22.726]                       master <- NULL
[10:21:22.726]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.726]                         !identical(envir, emptyenv())) {
[10:21:22.726]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.726]                           inherits = FALSE)) {
[10:21:22.726]                           master <- get("master", mode = "list", 
[10:21:22.726]                             envir = envir, inherits = FALSE)
[10:21:22.726]                           if (inherits(master, c("SOCKnode", 
[10:21:22.726]                             "SOCK0node"))) {
[10:21:22.726]                             sendCondition <<- function(cond) {
[10:21:22.726]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.726]                                 success = TRUE)
[10:21:22.726]                               parallel_sendData(master, data)
[10:21:22.726]                             }
[10:21:22.726]                             return(sendCondition)
[10:21:22.726]                           }
[10:21:22.726]                         }
[10:21:22.726]                         frame <- frame + 1L
[10:21:22.726]                         envir <- sys.frame(frame)
[10:21:22.726]                       }
[10:21:22.726]                     }
[10:21:22.726]                     sendCondition <<- function(cond) NULL
[10:21:22.726]                   }
[10:21:22.726]                 })
[10:21:22.726]                 withCallingHandlers({
[10:21:22.726]                   2
[10:21:22.726]                 }, immediateCondition = function(cond) {
[10:21:22.726]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.726]                   sendCondition(cond)
[10:21:22.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.726]                   {
[10:21:22.726]                     inherits <- base::inherits
[10:21:22.726]                     invokeRestart <- base::invokeRestart
[10:21:22.726]                     is.null <- base::is.null
[10:21:22.726]                     muffled <- FALSE
[10:21:22.726]                     if (inherits(cond, "message")) {
[10:21:22.726]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.726]                       if (muffled) 
[10:21:22.726]                         invokeRestart("muffleMessage")
[10:21:22.726]                     }
[10:21:22.726]                     else if (inherits(cond, "warning")) {
[10:21:22.726]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.726]                       if (muffled) 
[10:21:22.726]                         invokeRestart("muffleWarning")
[10:21:22.726]                     }
[10:21:22.726]                     else if (inherits(cond, "condition")) {
[10:21:22.726]                       if (!is.null(pattern)) {
[10:21:22.726]                         computeRestarts <- base::computeRestarts
[10:21:22.726]                         grepl <- base::grepl
[10:21:22.726]                         restarts <- computeRestarts(cond)
[10:21:22.726]                         for (restart in restarts) {
[10:21:22.726]                           name <- restart$name
[10:21:22.726]                           if (is.null(name)) 
[10:21:22.726]                             next
[10:21:22.726]                           if (!grepl(pattern, name)) 
[10:21:22.726]                             next
[10:21:22.726]                           invokeRestart(restart)
[10:21:22.726]                           muffled <- TRUE
[10:21:22.726]                           break
[10:21:22.726]                         }
[10:21:22.726]                       }
[10:21:22.726]                     }
[10:21:22.726]                     invisible(muffled)
[10:21:22.726]                   }
[10:21:22.726]                   muffleCondition(cond)
[10:21:22.726]                 })
[10:21:22.726]             }))
[10:21:22.726]             future::FutureResult(value = ...future.value$value, 
[10:21:22.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.726]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.726]                     ...future.globalenv.names))
[10:21:22.726]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.726]         }, condition = base::local({
[10:21:22.726]             c <- base::c
[10:21:22.726]             inherits <- base::inherits
[10:21:22.726]             invokeRestart <- base::invokeRestart
[10:21:22.726]             length <- base::length
[10:21:22.726]             list <- base::list
[10:21:22.726]             seq.int <- base::seq.int
[10:21:22.726]             signalCondition <- base::signalCondition
[10:21:22.726]             sys.calls <- base::sys.calls
[10:21:22.726]             `[[` <- base::`[[`
[10:21:22.726]             `+` <- base::`+`
[10:21:22.726]             `<<-` <- base::`<<-`
[10:21:22.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.726]                   3L)]
[10:21:22.726]             }
[10:21:22.726]             function(cond) {
[10:21:22.726]                 is_error <- inherits(cond, "error")
[10:21:22.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.726]                   NULL)
[10:21:22.726]                 if (is_error) {
[10:21:22.726]                   sessionInformation <- function() {
[10:21:22.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.726]                       search = base::search(), system = base::Sys.info())
[10:21:22.726]                   }
[10:21:22.726]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.726]                     cond$call), session = sessionInformation(), 
[10:21:22.726]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.726]                   signalCondition(cond)
[10:21:22.726]                 }
[10:21:22.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.726]                 "immediateCondition"))) {
[10:21:22.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.726]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.726]                   if (TRUE && !signal) {
[10:21:22.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.726]                     {
[10:21:22.726]                       inherits <- base::inherits
[10:21:22.726]                       invokeRestart <- base::invokeRestart
[10:21:22.726]                       is.null <- base::is.null
[10:21:22.726]                       muffled <- FALSE
[10:21:22.726]                       if (inherits(cond, "message")) {
[10:21:22.726]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.726]                         if (muffled) 
[10:21:22.726]                           invokeRestart("muffleMessage")
[10:21:22.726]                       }
[10:21:22.726]                       else if (inherits(cond, "warning")) {
[10:21:22.726]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.726]                         if (muffled) 
[10:21:22.726]                           invokeRestart("muffleWarning")
[10:21:22.726]                       }
[10:21:22.726]                       else if (inherits(cond, "condition")) {
[10:21:22.726]                         if (!is.null(pattern)) {
[10:21:22.726]                           computeRestarts <- base::computeRestarts
[10:21:22.726]                           grepl <- base::grepl
[10:21:22.726]                           restarts <- computeRestarts(cond)
[10:21:22.726]                           for (restart in restarts) {
[10:21:22.726]                             name <- restart$name
[10:21:22.726]                             if (is.null(name)) 
[10:21:22.726]                               next
[10:21:22.726]                             if (!grepl(pattern, name)) 
[10:21:22.726]                               next
[10:21:22.726]                             invokeRestart(restart)
[10:21:22.726]                             muffled <- TRUE
[10:21:22.726]                             break
[10:21:22.726]                           }
[10:21:22.726]                         }
[10:21:22.726]                       }
[10:21:22.726]                       invisible(muffled)
[10:21:22.726]                     }
[10:21:22.726]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.726]                   }
[10:21:22.726]                 }
[10:21:22.726]                 else {
[10:21:22.726]                   if (TRUE) {
[10:21:22.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.726]                     {
[10:21:22.726]                       inherits <- base::inherits
[10:21:22.726]                       invokeRestart <- base::invokeRestart
[10:21:22.726]                       is.null <- base::is.null
[10:21:22.726]                       muffled <- FALSE
[10:21:22.726]                       if (inherits(cond, "message")) {
[10:21:22.726]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.726]                         if (muffled) 
[10:21:22.726]                           invokeRestart("muffleMessage")
[10:21:22.726]                       }
[10:21:22.726]                       else if (inherits(cond, "warning")) {
[10:21:22.726]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.726]                         if (muffled) 
[10:21:22.726]                           invokeRestart("muffleWarning")
[10:21:22.726]                       }
[10:21:22.726]                       else if (inherits(cond, "condition")) {
[10:21:22.726]                         if (!is.null(pattern)) {
[10:21:22.726]                           computeRestarts <- base::computeRestarts
[10:21:22.726]                           grepl <- base::grepl
[10:21:22.726]                           restarts <- computeRestarts(cond)
[10:21:22.726]                           for (restart in restarts) {
[10:21:22.726]                             name <- restart$name
[10:21:22.726]                             if (is.null(name)) 
[10:21:22.726]                               next
[10:21:22.726]                             if (!grepl(pattern, name)) 
[10:21:22.726]                               next
[10:21:22.726]                             invokeRestart(restart)
[10:21:22.726]                             muffled <- TRUE
[10:21:22.726]                             break
[10:21:22.726]                           }
[10:21:22.726]                         }
[10:21:22.726]                       }
[10:21:22.726]                       invisible(muffled)
[10:21:22.726]                     }
[10:21:22.726]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.726]                   }
[10:21:22.726]                 }
[10:21:22.726]             }
[10:21:22.726]         }))
[10:21:22.726]     }, error = function(ex) {
[10:21:22.726]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.726]                 ...future.rng), started = ...future.startTime, 
[10:21:22.726]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.726]             version = "1.8"), class = "FutureResult")
[10:21:22.726]     }, finally = {
[10:21:22.726]         if (!identical(...future.workdir, getwd())) 
[10:21:22.726]             setwd(...future.workdir)
[10:21:22.726]         {
[10:21:22.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.726]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.726]             }
[10:21:22.726]             base::options(...future.oldOptions)
[10:21:22.726]             if (.Platform$OS.type == "windows") {
[10:21:22.726]                 old_names <- names(...future.oldEnvVars)
[10:21:22.726]                 envs <- base::Sys.getenv()
[10:21:22.726]                 names <- names(envs)
[10:21:22.726]                 common <- intersect(names, old_names)
[10:21:22.726]                 added <- setdiff(names, old_names)
[10:21:22.726]                 removed <- setdiff(old_names, names)
[10:21:22.726]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.726]                   envs[common]]
[10:21:22.726]                 NAMES <- toupper(changed)
[10:21:22.726]                 args <- list()
[10:21:22.726]                 for (kk in seq_along(NAMES)) {
[10:21:22.726]                   name <- changed[[kk]]
[10:21:22.726]                   NAME <- NAMES[[kk]]
[10:21:22.726]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.726]                     next
[10:21:22.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.726]                 }
[10:21:22.726]                 NAMES <- toupper(added)
[10:21:22.726]                 for (kk in seq_along(NAMES)) {
[10:21:22.726]                   name <- added[[kk]]
[10:21:22.726]                   NAME <- NAMES[[kk]]
[10:21:22.726]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.726]                     next
[10:21:22.726]                   args[[name]] <- ""
[10:21:22.726]                 }
[10:21:22.726]                 NAMES <- toupper(removed)
[10:21:22.726]                 for (kk in seq_along(NAMES)) {
[10:21:22.726]                   name <- removed[[kk]]
[10:21:22.726]                   NAME <- NAMES[[kk]]
[10:21:22.726]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.726]                     next
[10:21:22.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.726]                 }
[10:21:22.726]                 if (length(args) > 0) 
[10:21:22.726]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.726]             }
[10:21:22.726]             else {
[10:21:22.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.726]             }
[10:21:22.726]             {
[10:21:22.726]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.726]                   0L) {
[10:21:22.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.726]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.726]                   base::options(opts)
[10:21:22.726]                 }
[10:21:22.726]                 {
[10:21:22.726]                   {
[10:21:22.726]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.726]                     NULL
[10:21:22.726]                   }
[10:21:22.726]                   options(future.plan = NULL)
[10:21:22.726]                   if (is.na(NA_character_)) 
[10:21:22.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.726]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.726]                     .init = FALSE)
[10:21:22.726]                 }
[10:21:22.726]             }
[10:21:22.726]         }
[10:21:22.726]     })
[10:21:22.726]     if (TRUE) {
[10:21:22.726]         base::sink(type = "output", split = FALSE)
[10:21:22.726]         if (TRUE) {
[10:21:22.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.726]         }
[10:21:22.726]         else {
[10:21:22.726]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.726]         }
[10:21:22.726]         base::close(...future.stdout)
[10:21:22.726]         ...future.stdout <- NULL
[10:21:22.726]     }
[10:21:22.726]     ...future.result$conditions <- ...future.conditions
[10:21:22.726]     ...future.result$finished <- base::Sys.time()
[10:21:22.726]     ...future.result
[10:21:22.726] }
[10:21:22.729] MultisessionFuture started
[10:21:22.730] - Launch lazy future ... done
[10:21:22.730] run() for ‘MultisessionFuture’ ... done
[10:21:22.730] getGlobalsAndPackages() ...
[10:21:22.730] Searching for globals...
[10:21:22.730] 
[10:21:22.730] Searching for globals ... DONE
[10:21:22.730] - globals: [0] <none>
[10:21:22.730] getGlobalsAndPackages() ... DONE
[10:21:22.731] run() for ‘Future’ ...
[10:21:22.731] - state: ‘created’
[10:21:22.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.745] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.745] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.745]   - Field: ‘node’
[10:21:22.745]   - Field: ‘label’
[10:21:22.745]   - Field: ‘local’
[10:21:22.745]   - Field: ‘owner’
[10:21:22.745]   - Field: ‘envir’
[10:21:22.745]   - Field: ‘workers’
[10:21:22.745]   - Field: ‘packages’
[10:21:22.745]   - Field: ‘gc’
[10:21:22.746]   - Field: ‘conditions’
[10:21:22.746]   - Field: ‘persistent’
[10:21:22.746]   - Field: ‘expr’
[10:21:22.746]   - Field: ‘uuid’
[10:21:22.746]   - Field: ‘seed’
[10:21:22.746]   - Field: ‘version’
[10:21:22.746]   - Field: ‘result’
[10:21:22.746]   - Field: ‘asynchronous’
[10:21:22.746]   - Field: ‘calls’
[10:21:22.746]   - Field: ‘globals’
[10:21:22.746]   - Field: ‘stdout’
[10:21:22.746]   - Field: ‘earlySignal’
[10:21:22.746]   - Field: ‘lazy’
[10:21:22.747]   - Field: ‘state’
[10:21:22.747] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.747] - Launch lazy future ...
[10:21:22.747] Packages needed by the future expression (n = 0): <none>
[10:21:22.747] Packages needed by future strategies (n = 0): <none>
[10:21:22.748] {
[10:21:22.748]     {
[10:21:22.748]         {
[10:21:22.748]             ...future.startTime <- base::Sys.time()
[10:21:22.748]             {
[10:21:22.748]                 {
[10:21:22.748]                   {
[10:21:22.748]                     {
[10:21:22.748]                       base::local({
[10:21:22.748]                         has_future <- base::requireNamespace("future", 
[10:21:22.748]                           quietly = TRUE)
[10:21:22.748]                         if (has_future) {
[10:21:22.748]                           ns <- base::getNamespace("future")
[10:21:22.748]                           version <- ns[[".package"]][["version"]]
[10:21:22.748]                           if (is.null(version)) 
[10:21:22.748]                             version <- utils::packageVersion("future")
[10:21:22.748]                         }
[10:21:22.748]                         else {
[10:21:22.748]                           version <- NULL
[10:21:22.748]                         }
[10:21:22.748]                         if (!has_future || version < "1.8.0") {
[10:21:22.748]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.748]                             "", base::R.version$version.string), 
[10:21:22.748]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.748]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.748]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.748]                               "release", "version")], collapse = " "), 
[10:21:22.748]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.748]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.748]                             info)
[10:21:22.748]                           info <- base::paste(info, collapse = "; ")
[10:21:22.748]                           if (!has_future) {
[10:21:22.748]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.748]                               info)
[10:21:22.748]                           }
[10:21:22.748]                           else {
[10:21:22.748]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.748]                               info, version)
[10:21:22.748]                           }
[10:21:22.748]                           base::stop(msg)
[10:21:22.748]                         }
[10:21:22.748]                       })
[10:21:22.748]                     }
[10:21:22.748]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.748]                     base::options(mc.cores = 1L)
[10:21:22.748]                   }
[10:21:22.748]                   ...future.strategy.old <- future::plan("list")
[10:21:22.748]                   options(future.plan = NULL)
[10:21:22.748]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.748]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.748]                 }
[10:21:22.748]                 ...future.workdir <- getwd()
[10:21:22.748]             }
[10:21:22.748]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.748]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.748]         }
[10:21:22.748]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.748]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.748]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.748]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.748]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.748]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.748]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.748]             base::names(...future.oldOptions))
[10:21:22.748]     }
[10:21:22.748]     if (FALSE) {
[10:21:22.748]     }
[10:21:22.748]     else {
[10:21:22.748]         if (TRUE) {
[10:21:22.748]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.748]                 open = "w")
[10:21:22.748]         }
[10:21:22.748]         else {
[10:21:22.748]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.748]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.748]         }
[10:21:22.748]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.748]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.748]             base::sink(type = "output", split = FALSE)
[10:21:22.748]             base::close(...future.stdout)
[10:21:22.748]         }, add = TRUE)
[10:21:22.748]     }
[10:21:22.748]     ...future.frame <- base::sys.nframe()
[10:21:22.748]     ...future.conditions <- base::list()
[10:21:22.748]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.748]     if (FALSE) {
[10:21:22.748]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.748]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.748]     }
[10:21:22.748]     ...future.result <- base::tryCatch({
[10:21:22.748]         base::withCallingHandlers({
[10:21:22.748]             ...future.value <- base::withVisible(base::local({
[10:21:22.748]                 ...future.makeSendCondition <- base::local({
[10:21:22.748]                   sendCondition <- NULL
[10:21:22.748]                   function(frame = 1L) {
[10:21:22.748]                     if (is.function(sendCondition)) 
[10:21:22.748]                       return(sendCondition)
[10:21:22.748]                     ns <- getNamespace("parallel")
[10:21:22.748]                     if (exists("sendData", mode = "function", 
[10:21:22.748]                       envir = ns)) {
[10:21:22.748]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.748]                         envir = ns)
[10:21:22.748]                       envir <- sys.frame(frame)
[10:21:22.748]                       master <- NULL
[10:21:22.748]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.748]                         !identical(envir, emptyenv())) {
[10:21:22.748]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.748]                           inherits = FALSE)) {
[10:21:22.748]                           master <- get("master", mode = "list", 
[10:21:22.748]                             envir = envir, inherits = FALSE)
[10:21:22.748]                           if (inherits(master, c("SOCKnode", 
[10:21:22.748]                             "SOCK0node"))) {
[10:21:22.748]                             sendCondition <<- function(cond) {
[10:21:22.748]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.748]                                 success = TRUE)
[10:21:22.748]                               parallel_sendData(master, data)
[10:21:22.748]                             }
[10:21:22.748]                             return(sendCondition)
[10:21:22.748]                           }
[10:21:22.748]                         }
[10:21:22.748]                         frame <- frame + 1L
[10:21:22.748]                         envir <- sys.frame(frame)
[10:21:22.748]                       }
[10:21:22.748]                     }
[10:21:22.748]                     sendCondition <<- function(cond) NULL
[10:21:22.748]                   }
[10:21:22.748]                 })
[10:21:22.748]                 withCallingHandlers({
[10:21:22.748]                   NULL
[10:21:22.748]                 }, immediateCondition = function(cond) {
[10:21:22.748]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.748]                   sendCondition(cond)
[10:21:22.748]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.748]                   {
[10:21:22.748]                     inherits <- base::inherits
[10:21:22.748]                     invokeRestart <- base::invokeRestart
[10:21:22.748]                     is.null <- base::is.null
[10:21:22.748]                     muffled <- FALSE
[10:21:22.748]                     if (inherits(cond, "message")) {
[10:21:22.748]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.748]                       if (muffled) 
[10:21:22.748]                         invokeRestart("muffleMessage")
[10:21:22.748]                     }
[10:21:22.748]                     else if (inherits(cond, "warning")) {
[10:21:22.748]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.748]                       if (muffled) 
[10:21:22.748]                         invokeRestart("muffleWarning")
[10:21:22.748]                     }
[10:21:22.748]                     else if (inherits(cond, "condition")) {
[10:21:22.748]                       if (!is.null(pattern)) {
[10:21:22.748]                         computeRestarts <- base::computeRestarts
[10:21:22.748]                         grepl <- base::grepl
[10:21:22.748]                         restarts <- computeRestarts(cond)
[10:21:22.748]                         for (restart in restarts) {
[10:21:22.748]                           name <- restart$name
[10:21:22.748]                           if (is.null(name)) 
[10:21:22.748]                             next
[10:21:22.748]                           if (!grepl(pattern, name)) 
[10:21:22.748]                             next
[10:21:22.748]                           invokeRestart(restart)
[10:21:22.748]                           muffled <- TRUE
[10:21:22.748]                           break
[10:21:22.748]                         }
[10:21:22.748]                       }
[10:21:22.748]                     }
[10:21:22.748]                     invisible(muffled)
[10:21:22.748]                   }
[10:21:22.748]                   muffleCondition(cond)
[10:21:22.748]                 })
[10:21:22.748]             }))
[10:21:22.748]             future::FutureResult(value = ...future.value$value, 
[10:21:22.748]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.748]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.748]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.748]                     ...future.globalenv.names))
[10:21:22.748]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.748]         }, condition = base::local({
[10:21:22.748]             c <- base::c
[10:21:22.748]             inherits <- base::inherits
[10:21:22.748]             invokeRestart <- base::invokeRestart
[10:21:22.748]             length <- base::length
[10:21:22.748]             list <- base::list
[10:21:22.748]             seq.int <- base::seq.int
[10:21:22.748]             signalCondition <- base::signalCondition
[10:21:22.748]             sys.calls <- base::sys.calls
[10:21:22.748]             `[[` <- base::`[[`
[10:21:22.748]             `+` <- base::`+`
[10:21:22.748]             `<<-` <- base::`<<-`
[10:21:22.748]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.748]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.748]                   3L)]
[10:21:22.748]             }
[10:21:22.748]             function(cond) {
[10:21:22.748]                 is_error <- inherits(cond, "error")
[10:21:22.748]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.748]                   NULL)
[10:21:22.748]                 if (is_error) {
[10:21:22.748]                   sessionInformation <- function() {
[10:21:22.748]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.748]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.748]                       search = base::search(), system = base::Sys.info())
[10:21:22.748]                   }
[10:21:22.748]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.748]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.748]                     cond$call), session = sessionInformation(), 
[10:21:22.748]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.748]                   signalCondition(cond)
[10:21:22.748]                 }
[10:21:22.748]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.748]                 "immediateCondition"))) {
[10:21:22.748]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.748]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.748]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.748]                   if (TRUE && !signal) {
[10:21:22.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.748]                     {
[10:21:22.748]                       inherits <- base::inherits
[10:21:22.748]                       invokeRestart <- base::invokeRestart
[10:21:22.748]                       is.null <- base::is.null
[10:21:22.748]                       muffled <- FALSE
[10:21:22.748]                       if (inherits(cond, "message")) {
[10:21:22.748]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.748]                         if (muffled) 
[10:21:22.748]                           invokeRestart("muffleMessage")
[10:21:22.748]                       }
[10:21:22.748]                       else if (inherits(cond, "warning")) {
[10:21:22.748]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.748]                         if (muffled) 
[10:21:22.748]                           invokeRestart("muffleWarning")
[10:21:22.748]                       }
[10:21:22.748]                       else if (inherits(cond, "condition")) {
[10:21:22.748]                         if (!is.null(pattern)) {
[10:21:22.748]                           computeRestarts <- base::computeRestarts
[10:21:22.748]                           grepl <- base::grepl
[10:21:22.748]                           restarts <- computeRestarts(cond)
[10:21:22.748]                           for (restart in restarts) {
[10:21:22.748]                             name <- restart$name
[10:21:22.748]                             if (is.null(name)) 
[10:21:22.748]                               next
[10:21:22.748]                             if (!grepl(pattern, name)) 
[10:21:22.748]                               next
[10:21:22.748]                             invokeRestart(restart)
[10:21:22.748]                             muffled <- TRUE
[10:21:22.748]                             break
[10:21:22.748]                           }
[10:21:22.748]                         }
[10:21:22.748]                       }
[10:21:22.748]                       invisible(muffled)
[10:21:22.748]                     }
[10:21:22.748]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.748]                   }
[10:21:22.748]                 }
[10:21:22.748]                 else {
[10:21:22.748]                   if (TRUE) {
[10:21:22.748]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.748]                     {
[10:21:22.748]                       inherits <- base::inherits
[10:21:22.748]                       invokeRestart <- base::invokeRestart
[10:21:22.748]                       is.null <- base::is.null
[10:21:22.748]                       muffled <- FALSE
[10:21:22.748]                       if (inherits(cond, "message")) {
[10:21:22.748]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.748]                         if (muffled) 
[10:21:22.748]                           invokeRestart("muffleMessage")
[10:21:22.748]                       }
[10:21:22.748]                       else if (inherits(cond, "warning")) {
[10:21:22.748]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.748]                         if (muffled) 
[10:21:22.748]                           invokeRestart("muffleWarning")
[10:21:22.748]                       }
[10:21:22.748]                       else if (inherits(cond, "condition")) {
[10:21:22.748]                         if (!is.null(pattern)) {
[10:21:22.748]                           computeRestarts <- base::computeRestarts
[10:21:22.748]                           grepl <- base::grepl
[10:21:22.748]                           restarts <- computeRestarts(cond)
[10:21:22.748]                           for (restart in restarts) {
[10:21:22.748]                             name <- restart$name
[10:21:22.748]                             if (is.null(name)) 
[10:21:22.748]                               next
[10:21:22.748]                             if (!grepl(pattern, name)) 
[10:21:22.748]                               next
[10:21:22.748]                             invokeRestart(restart)
[10:21:22.748]                             muffled <- TRUE
[10:21:22.748]                             break
[10:21:22.748]                           }
[10:21:22.748]                         }
[10:21:22.748]                       }
[10:21:22.748]                       invisible(muffled)
[10:21:22.748]                     }
[10:21:22.748]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.748]                   }
[10:21:22.748]                 }
[10:21:22.748]             }
[10:21:22.748]         }))
[10:21:22.748]     }, error = function(ex) {
[10:21:22.748]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.748]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.748]                 ...future.rng), started = ...future.startTime, 
[10:21:22.748]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.748]             version = "1.8"), class = "FutureResult")
[10:21:22.748]     }, finally = {
[10:21:22.748]         if (!identical(...future.workdir, getwd())) 
[10:21:22.748]             setwd(...future.workdir)
[10:21:22.748]         {
[10:21:22.748]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.748]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.748]             }
[10:21:22.748]             base::options(...future.oldOptions)
[10:21:22.748]             if (.Platform$OS.type == "windows") {
[10:21:22.748]                 old_names <- names(...future.oldEnvVars)
[10:21:22.748]                 envs <- base::Sys.getenv()
[10:21:22.748]                 names <- names(envs)
[10:21:22.748]                 common <- intersect(names, old_names)
[10:21:22.748]                 added <- setdiff(names, old_names)
[10:21:22.748]                 removed <- setdiff(old_names, names)
[10:21:22.748]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.748]                   envs[common]]
[10:21:22.748]                 NAMES <- toupper(changed)
[10:21:22.748]                 args <- list()
[10:21:22.748]                 for (kk in seq_along(NAMES)) {
[10:21:22.748]                   name <- changed[[kk]]
[10:21:22.748]                   NAME <- NAMES[[kk]]
[10:21:22.748]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.748]                     next
[10:21:22.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.748]                 }
[10:21:22.748]                 NAMES <- toupper(added)
[10:21:22.748]                 for (kk in seq_along(NAMES)) {
[10:21:22.748]                   name <- added[[kk]]
[10:21:22.748]                   NAME <- NAMES[[kk]]
[10:21:22.748]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.748]                     next
[10:21:22.748]                   args[[name]] <- ""
[10:21:22.748]                 }
[10:21:22.748]                 NAMES <- toupper(removed)
[10:21:22.748]                 for (kk in seq_along(NAMES)) {
[10:21:22.748]                   name <- removed[[kk]]
[10:21:22.748]                   NAME <- NAMES[[kk]]
[10:21:22.748]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.748]                     next
[10:21:22.748]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.748]                 }
[10:21:22.748]                 if (length(args) > 0) 
[10:21:22.748]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.748]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.748]             }
[10:21:22.748]             else {
[10:21:22.748]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.748]             }
[10:21:22.748]             {
[10:21:22.748]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.748]                   0L) {
[10:21:22.748]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.748]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.748]                   base::options(opts)
[10:21:22.748]                 }
[10:21:22.748]                 {
[10:21:22.748]                   {
[10:21:22.748]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.748]                     NULL
[10:21:22.748]                   }
[10:21:22.748]                   options(future.plan = NULL)
[10:21:22.748]                   if (is.na(NA_character_)) 
[10:21:22.748]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.748]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.748]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.748]                     .init = FALSE)
[10:21:22.748]                 }
[10:21:22.748]             }
[10:21:22.748]         }
[10:21:22.748]     })
[10:21:22.748]     if (TRUE) {
[10:21:22.748]         base::sink(type = "output", split = FALSE)
[10:21:22.748]         if (TRUE) {
[10:21:22.748]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.748]         }
[10:21:22.748]         else {
[10:21:22.748]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.748]         }
[10:21:22.748]         base::close(...future.stdout)
[10:21:22.748]         ...future.stdout <- NULL
[10:21:22.748]     }
[10:21:22.748]     ...future.result$conditions <- ...future.conditions
[10:21:22.748]     ...future.result$finished <- base::Sys.time()
[10:21:22.748]     ...future.result
[10:21:22.748] }
[10:21:22.750] MultisessionFuture started
[10:21:22.751] - Launch lazy future ... done
[10:21:22.751] run() for ‘MultisessionFuture’ ... done
[10:21:22.751] getGlobalsAndPackages() ...
[10:21:22.751] Searching for globals...
[10:21:22.752] - globals found: [1] ‘{’
[10:21:22.752] Searching for globals ... DONE
[10:21:22.752] Resolving globals: FALSE
[10:21:22.752] 
[10:21:22.752] 
[10:21:22.752] getGlobalsAndPackages() ... DONE
[10:21:22.752] run() for ‘Future’ ...
[10:21:22.753] - state: ‘created’
[10:21:22.753] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.767] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:22.767]   - Field: ‘node’
[10:21:22.767]   - Field: ‘label’
[10:21:22.767]   - Field: ‘local’
[10:21:22.767]   - Field: ‘owner’
[10:21:22.767]   - Field: ‘envir’
[10:21:22.767]   - Field: ‘workers’
[10:21:22.767]   - Field: ‘packages’
[10:21:22.768]   - Field: ‘gc’
[10:21:22.768]   - Field: ‘conditions’
[10:21:22.768]   - Field: ‘persistent’
[10:21:22.768]   - Field: ‘expr’
[10:21:22.768]   - Field: ‘uuid’
[10:21:22.768]   - Field: ‘seed’
[10:21:22.768]   - Field: ‘version’
[10:21:22.768]   - Field: ‘result’
[10:21:22.768]   - Field: ‘asynchronous’
[10:21:22.768]   - Field: ‘calls’
[10:21:22.768]   - Field: ‘globals’
[10:21:22.768]   - Field: ‘stdout’
[10:21:22.769]   - Field: ‘earlySignal’
[10:21:22.769]   - Field: ‘lazy’
[10:21:22.769]   - Field: ‘state’
[10:21:22.769] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:22.769] - Launch lazy future ...
[10:21:22.769] Packages needed by the future expression (n = 0): <none>
[10:21:22.769] Packages needed by future strategies (n = 0): <none>
[10:21:22.770] {
[10:21:22.770]     {
[10:21:22.770]         {
[10:21:22.770]             ...future.startTime <- base::Sys.time()
[10:21:22.770]             {
[10:21:22.770]                 {
[10:21:22.770]                   {
[10:21:22.770]                     {
[10:21:22.770]                       base::local({
[10:21:22.770]                         has_future <- base::requireNamespace("future", 
[10:21:22.770]                           quietly = TRUE)
[10:21:22.770]                         if (has_future) {
[10:21:22.770]                           ns <- base::getNamespace("future")
[10:21:22.770]                           version <- ns[[".package"]][["version"]]
[10:21:22.770]                           if (is.null(version)) 
[10:21:22.770]                             version <- utils::packageVersion("future")
[10:21:22.770]                         }
[10:21:22.770]                         else {
[10:21:22.770]                           version <- NULL
[10:21:22.770]                         }
[10:21:22.770]                         if (!has_future || version < "1.8.0") {
[10:21:22.770]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.770]                             "", base::R.version$version.string), 
[10:21:22.770]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.770]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.770]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.770]                               "release", "version")], collapse = " "), 
[10:21:22.770]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.770]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.770]                             info)
[10:21:22.770]                           info <- base::paste(info, collapse = "; ")
[10:21:22.770]                           if (!has_future) {
[10:21:22.770]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.770]                               info)
[10:21:22.770]                           }
[10:21:22.770]                           else {
[10:21:22.770]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.770]                               info, version)
[10:21:22.770]                           }
[10:21:22.770]                           base::stop(msg)
[10:21:22.770]                         }
[10:21:22.770]                       })
[10:21:22.770]                     }
[10:21:22.770]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.770]                     base::options(mc.cores = 1L)
[10:21:22.770]                   }
[10:21:22.770]                   ...future.strategy.old <- future::plan("list")
[10:21:22.770]                   options(future.plan = NULL)
[10:21:22.770]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.770]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.770]                 }
[10:21:22.770]                 ...future.workdir <- getwd()
[10:21:22.770]             }
[10:21:22.770]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.770]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.770]         }
[10:21:22.770]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.770]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.770]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.770]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.770]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.770]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.770]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.770]             base::names(...future.oldOptions))
[10:21:22.770]     }
[10:21:22.770]     if (FALSE) {
[10:21:22.770]     }
[10:21:22.770]     else {
[10:21:22.770]         if (TRUE) {
[10:21:22.770]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.770]                 open = "w")
[10:21:22.770]         }
[10:21:22.770]         else {
[10:21:22.770]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.770]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.770]         }
[10:21:22.770]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.770]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.770]             base::sink(type = "output", split = FALSE)
[10:21:22.770]             base::close(...future.stdout)
[10:21:22.770]         }, add = TRUE)
[10:21:22.770]     }
[10:21:22.770]     ...future.frame <- base::sys.nframe()
[10:21:22.770]     ...future.conditions <- base::list()
[10:21:22.770]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.770]     if (FALSE) {
[10:21:22.770]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.770]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.770]     }
[10:21:22.770]     ...future.result <- base::tryCatch({
[10:21:22.770]         base::withCallingHandlers({
[10:21:22.770]             ...future.value <- base::withVisible(base::local({
[10:21:22.770]                 ...future.makeSendCondition <- base::local({
[10:21:22.770]                   sendCondition <- NULL
[10:21:22.770]                   function(frame = 1L) {
[10:21:22.770]                     if (is.function(sendCondition)) 
[10:21:22.770]                       return(sendCondition)
[10:21:22.770]                     ns <- getNamespace("parallel")
[10:21:22.770]                     if (exists("sendData", mode = "function", 
[10:21:22.770]                       envir = ns)) {
[10:21:22.770]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:22.770]                         envir = ns)
[10:21:22.770]                       envir <- sys.frame(frame)
[10:21:22.770]                       master <- NULL
[10:21:22.770]                       while (!identical(envir, .GlobalEnv) && 
[10:21:22.770]                         !identical(envir, emptyenv())) {
[10:21:22.770]                         if (exists("master", mode = "list", envir = envir, 
[10:21:22.770]                           inherits = FALSE)) {
[10:21:22.770]                           master <- get("master", mode = "list", 
[10:21:22.770]                             envir = envir, inherits = FALSE)
[10:21:22.770]                           if (inherits(master, c("SOCKnode", 
[10:21:22.770]                             "SOCK0node"))) {
[10:21:22.770]                             sendCondition <<- function(cond) {
[10:21:22.770]                               data <- list(type = "VALUE", value = cond, 
[10:21:22.770]                                 success = TRUE)
[10:21:22.770]                               parallel_sendData(master, data)
[10:21:22.770]                             }
[10:21:22.770]                             return(sendCondition)
[10:21:22.770]                           }
[10:21:22.770]                         }
[10:21:22.770]                         frame <- frame + 1L
[10:21:22.770]                         envir <- sys.frame(frame)
[10:21:22.770]                       }
[10:21:22.770]                     }
[10:21:22.770]                     sendCondition <<- function(cond) NULL
[10:21:22.770]                   }
[10:21:22.770]                 })
[10:21:22.770]                 withCallingHandlers({
[10:21:22.770]                   {
[10:21:22.770]                     4
[10:21:22.770]                   }
[10:21:22.770]                 }, immediateCondition = function(cond) {
[10:21:22.770]                   sendCondition <- ...future.makeSendCondition()
[10:21:22.770]                   sendCondition(cond)
[10:21:22.770]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.770]                   {
[10:21:22.770]                     inherits <- base::inherits
[10:21:22.770]                     invokeRestart <- base::invokeRestart
[10:21:22.770]                     is.null <- base::is.null
[10:21:22.770]                     muffled <- FALSE
[10:21:22.770]                     if (inherits(cond, "message")) {
[10:21:22.770]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.770]                       if (muffled) 
[10:21:22.770]                         invokeRestart("muffleMessage")
[10:21:22.770]                     }
[10:21:22.770]                     else if (inherits(cond, "warning")) {
[10:21:22.770]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.770]                       if (muffled) 
[10:21:22.770]                         invokeRestart("muffleWarning")
[10:21:22.770]                     }
[10:21:22.770]                     else if (inherits(cond, "condition")) {
[10:21:22.770]                       if (!is.null(pattern)) {
[10:21:22.770]                         computeRestarts <- base::computeRestarts
[10:21:22.770]                         grepl <- base::grepl
[10:21:22.770]                         restarts <- computeRestarts(cond)
[10:21:22.770]                         for (restart in restarts) {
[10:21:22.770]                           name <- restart$name
[10:21:22.770]                           if (is.null(name)) 
[10:21:22.770]                             next
[10:21:22.770]                           if (!grepl(pattern, name)) 
[10:21:22.770]                             next
[10:21:22.770]                           invokeRestart(restart)
[10:21:22.770]                           muffled <- TRUE
[10:21:22.770]                           break
[10:21:22.770]                         }
[10:21:22.770]                       }
[10:21:22.770]                     }
[10:21:22.770]                     invisible(muffled)
[10:21:22.770]                   }
[10:21:22.770]                   muffleCondition(cond)
[10:21:22.770]                 })
[10:21:22.770]             }))
[10:21:22.770]             future::FutureResult(value = ...future.value$value, 
[10:21:22.770]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.770]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.770]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.770]                     ...future.globalenv.names))
[10:21:22.770]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.770]         }, condition = base::local({
[10:21:22.770]             c <- base::c
[10:21:22.770]             inherits <- base::inherits
[10:21:22.770]             invokeRestart <- base::invokeRestart
[10:21:22.770]             length <- base::length
[10:21:22.770]             list <- base::list
[10:21:22.770]             seq.int <- base::seq.int
[10:21:22.770]             signalCondition <- base::signalCondition
[10:21:22.770]             sys.calls <- base::sys.calls
[10:21:22.770]             `[[` <- base::`[[`
[10:21:22.770]             `+` <- base::`+`
[10:21:22.770]             `<<-` <- base::`<<-`
[10:21:22.770]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.770]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.770]                   3L)]
[10:21:22.770]             }
[10:21:22.770]             function(cond) {
[10:21:22.770]                 is_error <- inherits(cond, "error")
[10:21:22.770]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.770]                   NULL)
[10:21:22.770]                 if (is_error) {
[10:21:22.770]                   sessionInformation <- function() {
[10:21:22.770]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.770]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.770]                       search = base::search(), system = base::Sys.info())
[10:21:22.770]                   }
[10:21:22.770]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.770]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.770]                     cond$call), session = sessionInformation(), 
[10:21:22.770]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.770]                   signalCondition(cond)
[10:21:22.770]                 }
[10:21:22.770]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.770]                 "immediateCondition"))) {
[10:21:22.770]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.770]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.770]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.770]                   if (TRUE && !signal) {
[10:21:22.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.770]                     {
[10:21:22.770]                       inherits <- base::inherits
[10:21:22.770]                       invokeRestart <- base::invokeRestart
[10:21:22.770]                       is.null <- base::is.null
[10:21:22.770]                       muffled <- FALSE
[10:21:22.770]                       if (inherits(cond, "message")) {
[10:21:22.770]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.770]                         if (muffled) 
[10:21:22.770]                           invokeRestart("muffleMessage")
[10:21:22.770]                       }
[10:21:22.770]                       else if (inherits(cond, "warning")) {
[10:21:22.770]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.770]                         if (muffled) 
[10:21:22.770]                           invokeRestart("muffleWarning")
[10:21:22.770]                       }
[10:21:22.770]                       else if (inherits(cond, "condition")) {
[10:21:22.770]                         if (!is.null(pattern)) {
[10:21:22.770]                           computeRestarts <- base::computeRestarts
[10:21:22.770]                           grepl <- base::grepl
[10:21:22.770]                           restarts <- computeRestarts(cond)
[10:21:22.770]                           for (restart in restarts) {
[10:21:22.770]                             name <- restart$name
[10:21:22.770]                             if (is.null(name)) 
[10:21:22.770]                               next
[10:21:22.770]                             if (!grepl(pattern, name)) 
[10:21:22.770]                               next
[10:21:22.770]                             invokeRestart(restart)
[10:21:22.770]                             muffled <- TRUE
[10:21:22.770]                             break
[10:21:22.770]                           }
[10:21:22.770]                         }
[10:21:22.770]                       }
[10:21:22.770]                       invisible(muffled)
[10:21:22.770]                     }
[10:21:22.770]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.770]                   }
[10:21:22.770]                 }
[10:21:22.770]                 else {
[10:21:22.770]                   if (TRUE) {
[10:21:22.770]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.770]                     {
[10:21:22.770]                       inherits <- base::inherits
[10:21:22.770]                       invokeRestart <- base::invokeRestart
[10:21:22.770]                       is.null <- base::is.null
[10:21:22.770]                       muffled <- FALSE
[10:21:22.770]                       if (inherits(cond, "message")) {
[10:21:22.770]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.770]                         if (muffled) 
[10:21:22.770]                           invokeRestart("muffleMessage")
[10:21:22.770]                       }
[10:21:22.770]                       else if (inherits(cond, "warning")) {
[10:21:22.770]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.770]                         if (muffled) 
[10:21:22.770]                           invokeRestart("muffleWarning")
[10:21:22.770]                       }
[10:21:22.770]                       else if (inherits(cond, "condition")) {
[10:21:22.770]                         if (!is.null(pattern)) {
[10:21:22.770]                           computeRestarts <- base::computeRestarts
[10:21:22.770]                           grepl <- base::grepl
[10:21:22.770]                           restarts <- computeRestarts(cond)
[10:21:22.770]                           for (restart in restarts) {
[10:21:22.770]                             name <- restart$name
[10:21:22.770]                             if (is.null(name)) 
[10:21:22.770]                               next
[10:21:22.770]                             if (!grepl(pattern, name)) 
[10:21:22.770]                               next
[10:21:22.770]                             invokeRestart(restart)
[10:21:22.770]                             muffled <- TRUE
[10:21:22.770]                             break
[10:21:22.770]                           }
[10:21:22.770]                         }
[10:21:22.770]                       }
[10:21:22.770]                       invisible(muffled)
[10:21:22.770]                     }
[10:21:22.770]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.770]                   }
[10:21:22.770]                 }
[10:21:22.770]             }
[10:21:22.770]         }))
[10:21:22.770]     }, error = function(ex) {
[10:21:22.770]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.770]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.770]                 ...future.rng), started = ...future.startTime, 
[10:21:22.770]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.770]             version = "1.8"), class = "FutureResult")
[10:21:22.770]     }, finally = {
[10:21:22.770]         if (!identical(...future.workdir, getwd())) 
[10:21:22.770]             setwd(...future.workdir)
[10:21:22.770]         {
[10:21:22.770]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.770]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.770]             }
[10:21:22.770]             base::options(...future.oldOptions)
[10:21:22.770]             if (.Platform$OS.type == "windows") {
[10:21:22.770]                 old_names <- names(...future.oldEnvVars)
[10:21:22.770]                 envs <- base::Sys.getenv()
[10:21:22.770]                 names <- names(envs)
[10:21:22.770]                 common <- intersect(names, old_names)
[10:21:22.770]                 added <- setdiff(names, old_names)
[10:21:22.770]                 removed <- setdiff(old_names, names)
[10:21:22.770]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.770]                   envs[common]]
[10:21:22.770]                 NAMES <- toupper(changed)
[10:21:22.770]                 args <- list()
[10:21:22.770]                 for (kk in seq_along(NAMES)) {
[10:21:22.770]                   name <- changed[[kk]]
[10:21:22.770]                   NAME <- NAMES[[kk]]
[10:21:22.770]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.770]                     next
[10:21:22.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.770]                 }
[10:21:22.770]                 NAMES <- toupper(added)
[10:21:22.770]                 for (kk in seq_along(NAMES)) {
[10:21:22.770]                   name <- added[[kk]]
[10:21:22.770]                   NAME <- NAMES[[kk]]
[10:21:22.770]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.770]                     next
[10:21:22.770]                   args[[name]] <- ""
[10:21:22.770]                 }
[10:21:22.770]                 NAMES <- toupper(removed)
[10:21:22.770]                 for (kk in seq_along(NAMES)) {
[10:21:22.770]                   name <- removed[[kk]]
[10:21:22.770]                   NAME <- NAMES[[kk]]
[10:21:22.770]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.770]                     next
[10:21:22.770]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.770]                 }
[10:21:22.770]                 if (length(args) > 0) 
[10:21:22.770]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.770]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.770]             }
[10:21:22.770]             else {
[10:21:22.770]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.770]             }
[10:21:22.770]             {
[10:21:22.770]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.770]                   0L) {
[10:21:22.770]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.770]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.770]                   base::options(opts)
[10:21:22.770]                 }
[10:21:22.770]                 {
[10:21:22.770]                   {
[10:21:22.770]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.770]                     NULL
[10:21:22.770]                   }
[10:21:22.770]                   options(future.plan = NULL)
[10:21:22.770]                   if (is.na(NA_character_)) 
[10:21:22.770]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.770]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.770]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.770]                     .init = FALSE)
[10:21:22.770]                 }
[10:21:22.770]             }
[10:21:22.770]         }
[10:21:22.770]     })
[10:21:22.770]     if (TRUE) {
[10:21:22.770]         base::sink(type = "output", split = FALSE)
[10:21:22.770]         if (TRUE) {
[10:21:22.770]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.770]         }
[10:21:22.770]         else {
[10:21:22.770]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.770]         }
[10:21:22.770]         base::close(...future.stdout)
[10:21:22.770]         ...future.stdout <- NULL
[10:21:22.770]     }
[10:21:22.770]     ...future.result$conditions <- ...future.conditions
[10:21:22.770]     ...future.result$finished <- base::Sys.time()
[10:21:22.770]     ...future.result
[10:21:22.770] }
[10:21:22.772] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:22.783] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.783] - Validating connection of MultisessionFuture
[10:21:22.783] - received message: FutureResult
[10:21:22.783] - Received FutureResult
[10:21:22.783] - Erased future from FutureRegistry
[10:21:22.783] result() for ClusterFuture ...
[10:21:22.783] - result already collected: FutureResult
[10:21:22.783] result() for ClusterFuture ... done
[10:21:22.783] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.783] result() for ClusterFuture ...
[10:21:22.784] - result already collected: FutureResult
[10:21:22.784] result() for ClusterFuture ... done
[10:21:22.784] result() for ClusterFuture ...
[10:21:22.784] - result already collected: FutureResult
[10:21:22.784] result() for ClusterFuture ... done
[10:21:22.785] MultisessionFuture started
[10:21:22.785] - Launch lazy future ... done
[10:21:22.785] run() for ‘MultisessionFuture’ ... done
<environment: 0x55e8e7356a10> 
<environment: 0x55e8e3c4d418> 
[10:21:22.793] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.793] - Validating connection of MultisessionFuture
[10:21:22.793] - received message: FutureResult
[10:21:22.793] - Received FutureResult
[10:21:22.794] - Erased future from FutureRegistry
[10:21:22.794] result() for ClusterFuture ...
[10:21:22.794] - result already collected: FutureResult
[10:21:22.794] result() for ClusterFuture ... done
[10:21:22.794] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[10:21:22.806] resolve() on environment ...
[10:21:22.806]  recursive: 0
[10:21:22.806]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[10:21:22.806] signalConditionsASAP(numeric, pos=1) ...
[10:21:22.806] - nx: 4
[10:21:22.807] - relay: TRUE
[10:21:22.807] - stdout: TRUE
[10:21:22.807] - signal: TRUE
[10:21:22.807] - resignal: FALSE
[10:21:22.807] - force: TRUE
[10:21:22.807] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.807] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.807]  - until=2
[10:21:22.807]  - relaying element #2
[10:21:22.807] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.807] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.807] signalConditionsASAP(NULL, pos=1) ... done
[10:21:22.807]  length: 3 (resolved future 1)
[10:21:22.808] Future #2
[10:21:22.808] result() for ClusterFuture ...
[10:21:22.808] - result already collected: FutureResult
[10:21:22.808] result() for ClusterFuture ... done
[10:21:22.808] result() for ClusterFuture ...
[10:21:22.808] - result already collected: FutureResult
[10:21:22.808] result() for ClusterFuture ... done
[10:21:22.808] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:22.808] - nx: 4
[10:21:22.808] - relay: TRUE
[10:21:22.808] - stdout: TRUE
[10:21:22.809] - signal: TRUE
[10:21:22.809] - resignal: FALSE
[10:21:22.809] - force: TRUE
[10:21:22.809] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[10:21:22.809] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[10:21:22.809]  - until=2
[10:21:22.809]  - relaying element #2
[10:21:22.809] result() for ClusterFuture ...
[10:21:22.809] - result already collected: FutureResult
[10:21:22.809] result() for ClusterFuture ... done
[10:21:22.809] result() for ClusterFuture ...
[10:21:22.809] - result already collected: FutureResult
[10:21:22.809] result() for ClusterFuture ... done
[10:21:22.810] result() for ClusterFuture ...
[10:21:22.810] - result already collected: FutureResult
[10:21:22.810] result() for ClusterFuture ... done
[10:21:22.810] result() for ClusterFuture ...
[10:21:22.810] - result already collected: FutureResult
[10:21:22.810] result() for ClusterFuture ... done
[10:21:22.810] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.810] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.810] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:22.810]  length: 2 (resolved future 2)
[10:21:22.810] Future #3
[10:21:22.811] result() for ClusterFuture ...
[10:21:22.811] - result already collected: FutureResult
[10:21:22.811] result() for ClusterFuture ... done
[10:21:22.811] result() for ClusterFuture ...
[10:21:22.811] - result already collected: FutureResult
[10:21:22.811] result() for ClusterFuture ... done
[10:21:22.811] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:22.811] - nx: 4
[10:21:22.811] - relay: TRUE
[10:21:22.811] - stdout: TRUE
[10:21:22.811] - signal: TRUE
[10:21:22.811] - resignal: FALSE
[10:21:22.811] - force: TRUE
[10:21:22.812] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[10:21:22.812] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[10:21:22.812]  - until=3
[10:21:22.812]  - relaying element #3
[10:21:22.812] result() for ClusterFuture ...
[10:21:22.812] - result already collected: FutureResult
[10:21:22.812] result() for ClusterFuture ... done
[10:21:22.812] result() for ClusterFuture ...
[10:21:22.812] - result already collected: FutureResult
[10:21:22.812] result() for ClusterFuture ... done
[10:21:22.812] result() for ClusterFuture ...
[10:21:22.813] - result already collected: FutureResult
[10:21:22.813] result() for ClusterFuture ... done
[10:21:22.813] result() for ClusterFuture ...
[10:21:22.813] - result already collected: FutureResult
[10:21:22.813] result() for ClusterFuture ... done
[10:21:22.813] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.813] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.813] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:22.813]  length: 1 (resolved future 3)
[10:21:22.834] receiveMessageFromWorker() for ClusterFuture ...
[10:21:22.834] - Validating connection of MultisessionFuture
[10:21:22.835] - received message: FutureResult
[10:21:22.835] - Received FutureResult
[10:21:22.835] - Erased future from FutureRegistry
[10:21:22.835] result() for ClusterFuture ...
[10:21:22.835] - result already collected: FutureResult
[10:21:22.835] result() for ClusterFuture ... done
[10:21:22.835] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:22.835] Future #4
[10:21:22.835] result() for ClusterFuture ...
[10:21:22.836] - result already collected: FutureResult
[10:21:22.836] result() for ClusterFuture ... done
[10:21:22.836] result() for ClusterFuture ...
[10:21:22.836] - result already collected: FutureResult
[10:21:22.836] result() for ClusterFuture ... done
[10:21:22.836] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:22.836] - nx: 4
[10:21:22.836] - relay: TRUE
[10:21:22.836] - stdout: TRUE
[10:21:22.836] - signal: TRUE
[10:21:22.836] - resignal: FALSE
[10:21:22.836] - force: TRUE
[10:21:22.836] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[10:21:22.837] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[10:21:22.837]  - until=4
[10:21:22.837]  - relaying element #4
[10:21:22.837] result() for ClusterFuture ...
[10:21:22.837] - result already collected: FutureResult
[10:21:22.837] result() for ClusterFuture ... done
[10:21:22.837] result() for ClusterFuture ...
[10:21:22.837] - result already collected: FutureResult
[10:21:22.837] result() for ClusterFuture ... done
[10:21:22.837] result() for ClusterFuture ...
[10:21:22.837] - result already collected: FutureResult
[10:21:22.837] result() for ClusterFuture ... done
[10:21:22.838] result() for ClusterFuture ...
[10:21:22.838] - result already collected: FutureResult
[10:21:22.838] result() for ClusterFuture ... done
[10:21:22.838] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.838] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.838] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:22.838]  length: 0 (resolved future 4)
[10:21:22.838] Relaying remaining futures
[10:21:22.838] signalConditionsASAP(NULL, pos=0) ...
[10:21:22.838] - nx: 4
[10:21:22.838] - relay: TRUE
[10:21:22.838] - stdout: TRUE
[10:21:22.839] - signal: TRUE
[10:21:22.839] - resignal: FALSE
[10:21:22.839] - force: TRUE
[10:21:22.839] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.839] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[10:21:22.839] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[10:21:22.839] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[10:21:22.839] signalConditionsASAP(NULL, pos=0) ... done
[10:21:22.839] resolve() on environment ... DONE
[10:21:22.839] result() for ClusterFuture ...
[10:21:22.839] - result already collected: FutureResult
[10:21:22.839] result() for ClusterFuture ... done
[10:21:22.840] result() for ClusterFuture ...
[10:21:22.840] - result already collected: FutureResult
[10:21:22.840] result() for ClusterFuture ... done
[10:21:22.840] result() for ClusterFuture ...
[10:21:22.840] - result already collected: FutureResult
[10:21:22.840] result() for ClusterFuture ... done
[10:21:22.840] result() for ClusterFuture ...
[10:21:22.840] - result already collected: FutureResult
[10:21:22.840] result() for ClusterFuture ... done
[10:21:22.840] result() for ClusterFuture ...
[10:21:22.840] - result already collected: FutureResult
[10:21:22.840] result() for ClusterFuture ... done
[10:21:22.841] result() for ClusterFuture ...
[10:21:22.841] - result already collected: FutureResult
[10:21:22.841] result() for ClusterFuture ... done
<environment: 0x55e8e3692408> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[10:21:22.841] plan(): Setting new future strategy stack:
[10:21:22.841] List of future strategies:
[10:21:22.841] 1. multicore:
[10:21:22.841]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:22.841]    - tweaked: FALSE
[10:21:22.841]    - call: plan(strategy)
[10:21:22.844] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:21:22.844] getGlobalsAndPackages() ...
[10:21:22.844] Searching for globals...
[10:21:22.845] 
[10:21:22.845] Searching for globals ... DONE
[10:21:22.845] - globals: [0] <none>
[10:21:22.845] getGlobalsAndPackages() ... DONE
[10:21:22.845] run() for ‘Future’ ...
[10:21:22.845] - state: ‘created’
[10:21:22.846] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.848] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.848] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:22.848]   - Field: ‘label’
[10:21:22.848]   - Field: ‘local’
[10:21:22.848]   - Field: ‘owner’
[10:21:22.849]   - Field: ‘envir’
[10:21:22.849]   - Field: ‘workers’
[10:21:22.849]   - Field: ‘packages’
[10:21:22.849]   - Field: ‘gc’
[10:21:22.849]   - Field: ‘job’
[10:21:22.849]   - Field: ‘conditions’
[10:21:22.849]   - Field: ‘expr’
[10:21:22.850]   - Field: ‘uuid’
[10:21:22.850]   - Field: ‘seed’
[10:21:22.850]   - Field: ‘version’
[10:21:22.850]   - Field: ‘result’
[10:21:22.850]   - Field: ‘asynchronous’
[10:21:22.850]   - Field: ‘calls’
[10:21:22.850]   - Field: ‘globals’
[10:21:22.850]   - Field: ‘stdout’
[10:21:22.851]   - Field: ‘earlySignal’
[10:21:22.851]   - Field: ‘lazy’
[10:21:22.851]   - Field: ‘state’
[10:21:22.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:22.851] - Launch lazy future ...
[10:21:22.851] Packages needed by the future expression (n = 0): <none>
[10:21:22.852] Packages needed by future strategies (n = 0): <none>
[10:21:22.852] {
[10:21:22.852]     {
[10:21:22.852]         {
[10:21:22.852]             ...future.startTime <- base::Sys.time()
[10:21:22.852]             {
[10:21:22.852]                 {
[10:21:22.852]                   {
[10:21:22.852]                     {
[10:21:22.852]                       base::local({
[10:21:22.852]                         has_future <- base::requireNamespace("future", 
[10:21:22.852]                           quietly = TRUE)
[10:21:22.852]                         if (has_future) {
[10:21:22.852]                           ns <- base::getNamespace("future")
[10:21:22.852]                           version <- ns[[".package"]][["version"]]
[10:21:22.852]                           if (is.null(version)) 
[10:21:22.852]                             version <- utils::packageVersion("future")
[10:21:22.852]                         }
[10:21:22.852]                         else {
[10:21:22.852]                           version <- NULL
[10:21:22.852]                         }
[10:21:22.852]                         if (!has_future || version < "1.8.0") {
[10:21:22.852]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.852]                             "", base::R.version$version.string), 
[10:21:22.852]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.852]                               "release", "version")], collapse = " "), 
[10:21:22.852]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.852]                             info)
[10:21:22.852]                           info <- base::paste(info, collapse = "; ")
[10:21:22.852]                           if (!has_future) {
[10:21:22.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.852]                               info)
[10:21:22.852]                           }
[10:21:22.852]                           else {
[10:21:22.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.852]                               info, version)
[10:21:22.852]                           }
[10:21:22.852]                           base::stop(msg)
[10:21:22.852]                         }
[10:21:22.852]                       })
[10:21:22.852]                     }
[10:21:22.852]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.852]                     base::options(mc.cores = 1L)
[10:21:22.852]                   }
[10:21:22.852]                   ...future.strategy.old <- future::plan("list")
[10:21:22.852]                   options(future.plan = NULL)
[10:21:22.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.852]                 }
[10:21:22.852]                 ...future.workdir <- getwd()
[10:21:22.852]             }
[10:21:22.852]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.852]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.852]         }
[10:21:22.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.852]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.852]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.852]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.852]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.852]             base::names(...future.oldOptions))
[10:21:22.852]     }
[10:21:22.852]     if (FALSE) {
[10:21:22.852]     }
[10:21:22.852]     else {
[10:21:22.852]         if (TRUE) {
[10:21:22.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.852]                 open = "w")
[10:21:22.852]         }
[10:21:22.852]         else {
[10:21:22.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.852]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.852]         }
[10:21:22.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.852]             base::sink(type = "output", split = FALSE)
[10:21:22.852]             base::close(...future.stdout)
[10:21:22.852]         }, add = TRUE)
[10:21:22.852]     }
[10:21:22.852]     ...future.frame <- base::sys.nframe()
[10:21:22.852]     ...future.conditions <- base::list()
[10:21:22.852]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.852]     if (FALSE) {
[10:21:22.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.852]     }
[10:21:22.852]     ...future.result <- base::tryCatch({
[10:21:22.852]         base::withCallingHandlers({
[10:21:22.852]             ...future.value <- base::withVisible(base::local({
[10:21:22.852]                 withCallingHandlers({
[10:21:22.852]                   2
[10:21:22.852]                 }, immediateCondition = function(cond) {
[10:21:22.852]                   save_rds <- function (object, pathname, ...) 
[10:21:22.852]                   {
[10:21:22.852]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:22.852]                     if (file_test("-f", pathname_tmp)) {
[10:21:22.852]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.852]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:22.852]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.852]                         fi_tmp[["mtime"]])
[10:21:22.852]                     }
[10:21:22.852]                     tryCatch({
[10:21:22.852]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:22.852]                     }, error = function(ex) {
[10:21:22.852]                       msg <- conditionMessage(ex)
[10:21:22.852]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.852]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:22.852]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.852]                         fi_tmp[["mtime"]], msg)
[10:21:22.852]                       ex$message <- msg
[10:21:22.852]                       stop(ex)
[10:21:22.852]                     })
[10:21:22.852]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:22.852]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:22.852]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:22.852]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.852]                       fi <- file.info(pathname)
[10:21:22.852]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:22.852]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.852]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:22.852]                         fi[["size"]], fi[["mtime"]])
[10:21:22.852]                       stop(msg)
[10:21:22.852]                     }
[10:21:22.852]                     invisible(pathname)
[10:21:22.852]                   }
[10:21:22.852]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:22.852]                     rootPath = tempdir()) 
[10:21:22.852]                   {
[10:21:22.852]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:22.852]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:22.852]                       tmpdir = path, fileext = ".rds")
[10:21:22.852]                     save_rds(obj, file)
[10:21:22.852]                   }
[10:21:22.852]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:22.852]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.852]                   {
[10:21:22.852]                     inherits <- base::inherits
[10:21:22.852]                     invokeRestart <- base::invokeRestart
[10:21:22.852]                     is.null <- base::is.null
[10:21:22.852]                     muffled <- FALSE
[10:21:22.852]                     if (inherits(cond, "message")) {
[10:21:22.852]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.852]                       if (muffled) 
[10:21:22.852]                         invokeRestart("muffleMessage")
[10:21:22.852]                     }
[10:21:22.852]                     else if (inherits(cond, "warning")) {
[10:21:22.852]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.852]                       if (muffled) 
[10:21:22.852]                         invokeRestart("muffleWarning")
[10:21:22.852]                     }
[10:21:22.852]                     else if (inherits(cond, "condition")) {
[10:21:22.852]                       if (!is.null(pattern)) {
[10:21:22.852]                         computeRestarts <- base::computeRestarts
[10:21:22.852]                         grepl <- base::grepl
[10:21:22.852]                         restarts <- computeRestarts(cond)
[10:21:22.852]                         for (restart in restarts) {
[10:21:22.852]                           name <- restart$name
[10:21:22.852]                           if (is.null(name)) 
[10:21:22.852]                             next
[10:21:22.852]                           if (!grepl(pattern, name)) 
[10:21:22.852]                             next
[10:21:22.852]                           invokeRestart(restart)
[10:21:22.852]                           muffled <- TRUE
[10:21:22.852]                           break
[10:21:22.852]                         }
[10:21:22.852]                       }
[10:21:22.852]                     }
[10:21:22.852]                     invisible(muffled)
[10:21:22.852]                   }
[10:21:22.852]                   muffleCondition(cond)
[10:21:22.852]                 })
[10:21:22.852]             }))
[10:21:22.852]             future::FutureResult(value = ...future.value$value, 
[10:21:22.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.852]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.852]                     ...future.globalenv.names))
[10:21:22.852]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.852]         }, condition = base::local({
[10:21:22.852]             c <- base::c
[10:21:22.852]             inherits <- base::inherits
[10:21:22.852]             invokeRestart <- base::invokeRestart
[10:21:22.852]             length <- base::length
[10:21:22.852]             list <- base::list
[10:21:22.852]             seq.int <- base::seq.int
[10:21:22.852]             signalCondition <- base::signalCondition
[10:21:22.852]             sys.calls <- base::sys.calls
[10:21:22.852]             `[[` <- base::`[[`
[10:21:22.852]             `+` <- base::`+`
[10:21:22.852]             `<<-` <- base::`<<-`
[10:21:22.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.852]                   3L)]
[10:21:22.852]             }
[10:21:22.852]             function(cond) {
[10:21:22.852]                 is_error <- inherits(cond, "error")
[10:21:22.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.852]                   NULL)
[10:21:22.852]                 if (is_error) {
[10:21:22.852]                   sessionInformation <- function() {
[10:21:22.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.852]                       search = base::search(), system = base::Sys.info())
[10:21:22.852]                   }
[10:21:22.852]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.852]                     cond$call), session = sessionInformation(), 
[10:21:22.852]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.852]                   signalCondition(cond)
[10:21:22.852]                 }
[10:21:22.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.852]                 "immediateCondition"))) {
[10:21:22.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.852]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.852]                   if (TRUE && !signal) {
[10:21:22.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.852]                     {
[10:21:22.852]                       inherits <- base::inherits
[10:21:22.852]                       invokeRestart <- base::invokeRestart
[10:21:22.852]                       is.null <- base::is.null
[10:21:22.852]                       muffled <- FALSE
[10:21:22.852]                       if (inherits(cond, "message")) {
[10:21:22.852]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.852]                         if (muffled) 
[10:21:22.852]                           invokeRestart("muffleMessage")
[10:21:22.852]                       }
[10:21:22.852]                       else if (inherits(cond, "warning")) {
[10:21:22.852]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.852]                         if (muffled) 
[10:21:22.852]                           invokeRestart("muffleWarning")
[10:21:22.852]                       }
[10:21:22.852]                       else if (inherits(cond, "condition")) {
[10:21:22.852]                         if (!is.null(pattern)) {
[10:21:22.852]                           computeRestarts <- base::computeRestarts
[10:21:22.852]                           grepl <- base::grepl
[10:21:22.852]                           restarts <- computeRestarts(cond)
[10:21:22.852]                           for (restart in restarts) {
[10:21:22.852]                             name <- restart$name
[10:21:22.852]                             if (is.null(name)) 
[10:21:22.852]                               next
[10:21:22.852]                             if (!grepl(pattern, name)) 
[10:21:22.852]                               next
[10:21:22.852]                             invokeRestart(restart)
[10:21:22.852]                             muffled <- TRUE
[10:21:22.852]                             break
[10:21:22.852]                           }
[10:21:22.852]                         }
[10:21:22.852]                       }
[10:21:22.852]                       invisible(muffled)
[10:21:22.852]                     }
[10:21:22.852]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.852]                   }
[10:21:22.852]                 }
[10:21:22.852]                 else {
[10:21:22.852]                   if (TRUE) {
[10:21:22.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.852]                     {
[10:21:22.852]                       inherits <- base::inherits
[10:21:22.852]                       invokeRestart <- base::invokeRestart
[10:21:22.852]                       is.null <- base::is.null
[10:21:22.852]                       muffled <- FALSE
[10:21:22.852]                       if (inherits(cond, "message")) {
[10:21:22.852]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.852]                         if (muffled) 
[10:21:22.852]                           invokeRestart("muffleMessage")
[10:21:22.852]                       }
[10:21:22.852]                       else if (inherits(cond, "warning")) {
[10:21:22.852]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.852]                         if (muffled) 
[10:21:22.852]                           invokeRestart("muffleWarning")
[10:21:22.852]                       }
[10:21:22.852]                       else if (inherits(cond, "condition")) {
[10:21:22.852]                         if (!is.null(pattern)) {
[10:21:22.852]                           computeRestarts <- base::computeRestarts
[10:21:22.852]                           grepl <- base::grepl
[10:21:22.852]                           restarts <- computeRestarts(cond)
[10:21:22.852]                           for (restart in restarts) {
[10:21:22.852]                             name <- restart$name
[10:21:22.852]                             if (is.null(name)) 
[10:21:22.852]                               next
[10:21:22.852]                             if (!grepl(pattern, name)) 
[10:21:22.852]                               next
[10:21:22.852]                             invokeRestart(restart)
[10:21:22.852]                             muffled <- TRUE
[10:21:22.852]                             break
[10:21:22.852]                           }
[10:21:22.852]                         }
[10:21:22.852]                       }
[10:21:22.852]                       invisible(muffled)
[10:21:22.852]                     }
[10:21:22.852]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.852]                   }
[10:21:22.852]                 }
[10:21:22.852]             }
[10:21:22.852]         }))
[10:21:22.852]     }, error = function(ex) {
[10:21:22.852]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.852]                 ...future.rng), started = ...future.startTime, 
[10:21:22.852]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.852]             version = "1.8"), class = "FutureResult")
[10:21:22.852]     }, finally = {
[10:21:22.852]         if (!identical(...future.workdir, getwd())) 
[10:21:22.852]             setwd(...future.workdir)
[10:21:22.852]         {
[10:21:22.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.852]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.852]             }
[10:21:22.852]             base::options(...future.oldOptions)
[10:21:22.852]             if (.Platform$OS.type == "windows") {
[10:21:22.852]                 old_names <- names(...future.oldEnvVars)
[10:21:22.852]                 envs <- base::Sys.getenv()
[10:21:22.852]                 names <- names(envs)
[10:21:22.852]                 common <- intersect(names, old_names)
[10:21:22.852]                 added <- setdiff(names, old_names)
[10:21:22.852]                 removed <- setdiff(old_names, names)
[10:21:22.852]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.852]                   envs[common]]
[10:21:22.852]                 NAMES <- toupper(changed)
[10:21:22.852]                 args <- list()
[10:21:22.852]                 for (kk in seq_along(NAMES)) {
[10:21:22.852]                   name <- changed[[kk]]
[10:21:22.852]                   NAME <- NAMES[[kk]]
[10:21:22.852]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.852]                     next
[10:21:22.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.852]                 }
[10:21:22.852]                 NAMES <- toupper(added)
[10:21:22.852]                 for (kk in seq_along(NAMES)) {
[10:21:22.852]                   name <- added[[kk]]
[10:21:22.852]                   NAME <- NAMES[[kk]]
[10:21:22.852]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.852]                     next
[10:21:22.852]                   args[[name]] <- ""
[10:21:22.852]                 }
[10:21:22.852]                 NAMES <- toupper(removed)
[10:21:22.852]                 for (kk in seq_along(NAMES)) {
[10:21:22.852]                   name <- removed[[kk]]
[10:21:22.852]                   NAME <- NAMES[[kk]]
[10:21:22.852]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.852]                     next
[10:21:22.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.852]                 }
[10:21:22.852]                 if (length(args) > 0) 
[10:21:22.852]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.852]             }
[10:21:22.852]             else {
[10:21:22.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.852]             }
[10:21:22.852]             {
[10:21:22.852]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.852]                   0L) {
[10:21:22.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.852]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.852]                   base::options(opts)
[10:21:22.852]                 }
[10:21:22.852]                 {
[10:21:22.852]                   {
[10:21:22.852]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.852]                     NULL
[10:21:22.852]                   }
[10:21:22.852]                   options(future.plan = NULL)
[10:21:22.852]                   if (is.na(NA_character_)) 
[10:21:22.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.852]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.852]                     .init = FALSE)
[10:21:22.852]                 }
[10:21:22.852]             }
[10:21:22.852]         }
[10:21:22.852]     })
[10:21:22.852]     if (TRUE) {
[10:21:22.852]         base::sink(type = "output", split = FALSE)
[10:21:22.852]         if (TRUE) {
[10:21:22.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.852]         }
[10:21:22.852]         else {
[10:21:22.852]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.852]         }
[10:21:22.852]         base::close(...future.stdout)
[10:21:22.852]         ...future.stdout <- NULL
[10:21:22.852]     }
[10:21:22.852]     ...future.result$conditions <- ...future.conditions
[10:21:22.852]     ...future.result$finished <- base::Sys.time()
[10:21:22.852]     ...future.result
[10:21:22.852] }
[10:21:22.855] requestCore(): workers = 2
[10:21:22.858] MulticoreFuture started
[10:21:22.858] - Launch lazy future ... done
[10:21:22.859] run() for ‘MulticoreFuture’ ... done
[10:21:22.859] getGlobalsAndPackages() ...
[10:21:22.859] plan(): Setting new future strategy stack:
[10:21:22.859] Searching for globals...
[10:21:22.859] List of future strategies:
[10:21:22.859] 1. sequential:
[10:21:22.859]    - args: function (..., envir = parent.[10:21:22.860] 
frame(), workers = "<NULL>")
[10:21:22.859]    - tweaked: FALSE
[10:21:22.859]    - call: NULL
[10:21:22.860] Searching for globals ... DONE
[10:21:22.860] plan(): nbrOfWorkers() = 1
[10:21:22.860] - globals: [0] <none>
[10:21:22.860] getGlobalsAndPackages() ... DONE
[10:21:22.861] run() for ‘Future’ ...
[10:21:22.861] - state: ‘created’
[10:21:22.861] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.862] plan(): Setting new future strategy stack:
[10:21:22.862] List of future strategies:
[10:21:22.862] 1. multicore:
[10:21:22.862]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:22.862]    - tweaked: FALSE
[10:21:22.862]    - call: plan(strategy)
[10:21:22.865] plan(): nbrOfWorkers() = 2
[10:21:22.865] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.865] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:22.865]   - Field: ‘label’
[10:21:22.865]   - Field: ‘local’
[10:21:22.866]   - Field: ‘owner’
[10:21:22.866]   - Field: ‘envir’
[10:21:22.866]   - Field: ‘workers’
[10:21:22.866]   - Field: ‘packages’
[10:21:22.866]   - Field: ‘gc’
[10:21:22.866]   - Field: ‘job’
[10:21:22.866]   - Field: ‘conditions’
[10:21:22.866]   - Field: ‘expr’
[10:21:22.867]   - Field: ‘uuid’
[10:21:22.867]   - Field: ‘seed’
[10:21:22.867]   - Field: ‘version’
[10:21:22.867]   - Field: ‘result’
[10:21:22.867]   - Field: ‘asynchronous’
[10:21:22.867]   - Field: ‘calls’
[10:21:22.867]   - Field: ‘globals’
[10:21:22.867]   - Field: ‘stdout’
[10:21:22.868]   - Field: ‘earlySignal’
[10:21:22.868]   - Field: ‘lazy’
[10:21:22.868]   - Field: ‘state’
[10:21:22.868] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:22.868] - Launch lazy future ...
[10:21:22.869] Packages needed by the future expression (n = 0): <none>
[10:21:22.869] Packages needed by future strategies (n = 0): <none>
[10:21:22.869] {
[10:21:22.869]     {
[10:21:22.869]         {
[10:21:22.869]             ...future.startTime <- base::Sys.time()
[10:21:22.869]             {
[10:21:22.869]                 {
[10:21:22.869]                   {
[10:21:22.869]                     {
[10:21:22.869]                       base::local({
[10:21:22.869]                         has_future <- base::requireNamespace("future", 
[10:21:22.869]                           quietly = TRUE)
[10:21:22.869]                         if (has_future) {
[10:21:22.869]                           ns <- base::getNamespace("future")
[10:21:22.869]                           version <- ns[[".package"]][["version"]]
[10:21:22.869]                           if (is.null(version)) 
[10:21:22.869]                             version <- utils::packageVersion("future")
[10:21:22.869]                         }
[10:21:22.869]                         else {
[10:21:22.869]                           version <- NULL
[10:21:22.869]                         }
[10:21:22.869]                         if (!has_future || version < "1.8.0") {
[10:21:22.869]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.869]                             "", base::R.version$version.string), 
[10:21:22.869]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.869]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.869]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.869]                               "release", "version")], collapse = " "), 
[10:21:22.869]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.869]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.869]                             info)
[10:21:22.869]                           info <- base::paste(info, collapse = "; ")
[10:21:22.869]                           if (!has_future) {
[10:21:22.869]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.869]                               info)
[10:21:22.869]                           }
[10:21:22.869]                           else {
[10:21:22.869]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.869]                               info, version)
[10:21:22.869]                           }
[10:21:22.869]                           base::stop(msg)
[10:21:22.869]                         }
[10:21:22.869]                       })
[10:21:22.869]                     }
[10:21:22.869]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.869]                     base::options(mc.cores = 1L)
[10:21:22.869]                   }
[10:21:22.869]                   ...future.strategy.old <- future::plan("list")
[10:21:22.869]                   options(future.plan = NULL)
[10:21:22.869]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.869]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.869]                 }
[10:21:22.869]                 ...future.workdir <- getwd()
[10:21:22.869]             }
[10:21:22.869]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.869]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.869]         }
[10:21:22.869]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.869]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.869]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.869]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.869]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.869]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.869]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.869]             base::names(...future.oldOptions))
[10:21:22.869]     }
[10:21:22.869]     if (FALSE) {
[10:21:22.869]     }
[10:21:22.869]     else {
[10:21:22.869]         if (TRUE) {
[10:21:22.869]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.869]                 open = "w")
[10:21:22.869]         }
[10:21:22.869]         else {
[10:21:22.869]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.869]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.869]         }
[10:21:22.869]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.869]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.869]             base::sink(type = "output", split = FALSE)
[10:21:22.869]             base::close(...future.stdout)
[10:21:22.869]         }, add = TRUE)
[10:21:22.869]     }
[10:21:22.869]     ...future.frame <- base::sys.nframe()
[10:21:22.869]     ...future.conditions <- base::list()
[10:21:22.869]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.869]     if (FALSE) {
[10:21:22.869]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.869]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.869]     }
[10:21:22.869]     ...future.result <- base::tryCatch({
[10:21:22.869]         base::withCallingHandlers({
[10:21:22.869]             ...future.value <- base::withVisible(base::local({
[10:21:22.869]                 withCallingHandlers({
[10:21:22.869]                   NULL
[10:21:22.869]                 }, immediateCondition = function(cond) {
[10:21:22.869]                   save_rds <- function (object, pathname, ...) 
[10:21:22.869]                   {
[10:21:22.869]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:22.869]                     if (file_test("-f", pathname_tmp)) {
[10:21:22.869]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.869]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:22.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.869]                         fi_tmp[["mtime"]])
[10:21:22.869]                     }
[10:21:22.869]                     tryCatch({
[10:21:22.869]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:22.869]                     }, error = function(ex) {
[10:21:22.869]                       msg <- conditionMessage(ex)
[10:21:22.869]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.869]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:22.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.869]                         fi_tmp[["mtime"]], msg)
[10:21:22.869]                       ex$message <- msg
[10:21:22.869]                       stop(ex)
[10:21:22.869]                     })
[10:21:22.869]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:22.869]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:22.869]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:22.869]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.869]                       fi <- file.info(pathname)
[10:21:22.869]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:22.869]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.869]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:22.869]                         fi[["size"]], fi[["mtime"]])
[10:21:22.869]                       stop(msg)
[10:21:22.869]                     }
[10:21:22.869]                     invisible(pathname)
[10:21:22.869]                   }
[10:21:22.869]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:22.869]                     rootPath = tempdir()) 
[10:21:22.869]                   {
[10:21:22.869]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:22.869]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:22.869]                       tmpdir = path, fileext = ".rds")
[10:21:22.869]                     save_rds(obj, file)
[10:21:22.869]                   }
[10:21:22.869]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:22.869]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.869]                   {
[10:21:22.869]                     inherits <- base::inherits
[10:21:22.869]                     invokeRestart <- base::invokeRestart
[10:21:22.869]                     is.null <- base::is.null
[10:21:22.869]                     muffled <- FALSE
[10:21:22.869]                     if (inherits(cond, "message")) {
[10:21:22.869]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.869]                       if (muffled) 
[10:21:22.869]                         invokeRestart("muffleMessage")
[10:21:22.869]                     }
[10:21:22.869]                     else if (inherits(cond, "warning")) {
[10:21:22.869]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.869]                       if (muffled) 
[10:21:22.869]                         invokeRestart("muffleWarning")
[10:21:22.869]                     }
[10:21:22.869]                     else if (inherits(cond, "condition")) {
[10:21:22.869]                       if (!is.null(pattern)) {
[10:21:22.869]                         computeRestarts <- base::computeRestarts
[10:21:22.869]                         grepl <- base::grepl
[10:21:22.869]                         restarts <- computeRestarts(cond)
[10:21:22.869]                         for (restart in restarts) {
[10:21:22.869]                           name <- restart$name
[10:21:22.869]                           if (is.null(name)) 
[10:21:22.869]                             next
[10:21:22.869]                           if (!grepl(pattern, name)) 
[10:21:22.869]                             next
[10:21:22.869]                           invokeRestart(restart)
[10:21:22.869]                           muffled <- TRUE
[10:21:22.869]                           break
[10:21:22.869]                         }
[10:21:22.869]                       }
[10:21:22.869]                     }
[10:21:22.869]                     invisible(muffled)
[10:21:22.869]                   }
[10:21:22.869]                   muffleCondition(cond)
[10:21:22.869]                 })
[10:21:22.869]             }))
[10:21:22.869]             future::FutureResult(value = ...future.value$value, 
[10:21:22.869]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.869]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.869]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.869]                     ...future.globalenv.names))
[10:21:22.869]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.869]         }, condition = base::local({
[10:21:22.869]             c <- base::c
[10:21:22.869]             inherits <- base::inherits
[10:21:22.869]             invokeRestart <- base::invokeRestart
[10:21:22.869]             length <- base::length
[10:21:22.869]             list <- base::list
[10:21:22.869]             seq.int <- base::seq.int
[10:21:22.869]             signalCondition <- base::signalCondition
[10:21:22.869]             sys.calls <- base::sys.calls
[10:21:22.869]             `[[` <- base::`[[`
[10:21:22.869]             `+` <- base::`+`
[10:21:22.869]             `<<-` <- base::`<<-`
[10:21:22.869]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.869]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.869]                   3L)]
[10:21:22.869]             }
[10:21:22.869]             function(cond) {
[10:21:22.869]                 is_error <- inherits(cond, "error")
[10:21:22.869]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.869]                   NULL)
[10:21:22.869]                 if (is_error) {
[10:21:22.869]                   sessionInformation <- function() {
[10:21:22.869]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.869]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.869]                       search = base::search(), system = base::Sys.info())
[10:21:22.869]                   }
[10:21:22.869]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.869]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.869]                     cond$call), session = sessionInformation(), 
[10:21:22.869]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.869]                   signalCondition(cond)
[10:21:22.869]                 }
[10:21:22.869]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.869]                 "immediateCondition"))) {
[10:21:22.869]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.869]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.869]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.869]                   if (TRUE && !signal) {
[10:21:22.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.869]                     {
[10:21:22.869]                       inherits <- base::inherits
[10:21:22.869]                       invokeRestart <- base::invokeRestart
[10:21:22.869]                       is.null <- base::is.null
[10:21:22.869]                       muffled <- FALSE
[10:21:22.869]                       if (inherits(cond, "message")) {
[10:21:22.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.869]                         if (muffled) 
[10:21:22.869]                           invokeRestart("muffleMessage")
[10:21:22.869]                       }
[10:21:22.869]                       else if (inherits(cond, "warning")) {
[10:21:22.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.869]                         if (muffled) 
[10:21:22.869]                           invokeRestart("muffleWarning")
[10:21:22.869]                       }
[10:21:22.869]                       else if (inherits(cond, "condition")) {
[10:21:22.869]                         if (!is.null(pattern)) {
[10:21:22.869]                           computeRestarts <- base::computeRestarts
[10:21:22.869]                           grepl <- base::grepl
[10:21:22.869]                           restarts <- computeRestarts(cond)
[10:21:22.869]                           for (restart in restarts) {
[10:21:22.869]                             name <- restart$name
[10:21:22.869]                             if (is.null(name)) 
[10:21:22.869]                               next
[10:21:22.869]                             if (!grepl(pattern, name)) 
[10:21:22.869]                               next
[10:21:22.869]                             invokeRestart(restart)
[10:21:22.869]                             muffled <- TRUE
[10:21:22.869]                             break
[10:21:22.869]                           }
[10:21:22.869]                         }
[10:21:22.869]                       }
[10:21:22.869]                       invisible(muffled)
[10:21:22.869]                     }
[10:21:22.869]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.869]                   }
[10:21:22.869]                 }
[10:21:22.869]                 else {
[10:21:22.869]                   if (TRUE) {
[10:21:22.869]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.869]                     {
[10:21:22.869]                       inherits <- base::inherits
[10:21:22.869]                       invokeRestart <- base::invokeRestart
[10:21:22.869]                       is.null <- base::is.null
[10:21:22.869]                       muffled <- FALSE
[10:21:22.869]                       if (inherits(cond, "message")) {
[10:21:22.869]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.869]                         if (muffled) 
[10:21:22.869]                           invokeRestart("muffleMessage")
[10:21:22.869]                       }
[10:21:22.869]                       else if (inherits(cond, "warning")) {
[10:21:22.869]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.869]                         if (muffled) 
[10:21:22.869]                           invokeRestart("muffleWarning")
[10:21:22.869]                       }
[10:21:22.869]                       else if (inherits(cond, "condition")) {
[10:21:22.869]                         if (!is.null(pattern)) {
[10:21:22.869]                           computeRestarts <- base::computeRestarts
[10:21:22.869]                           grepl <- base::grepl
[10:21:22.869]                           restarts <- computeRestarts(cond)
[10:21:22.869]                           for (restart in restarts) {
[10:21:22.869]                             name <- restart$name
[10:21:22.869]                             if (is.null(name)) 
[10:21:22.869]                               next
[10:21:22.869]                             if (!grepl(pattern, name)) 
[10:21:22.869]                               next
[10:21:22.869]                             invokeRestart(restart)
[10:21:22.869]                             muffled <- TRUE
[10:21:22.869]                             break
[10:21:22.869]                           }
[10:21:22.869]                         }
[10:21:22.869]                       }
[10:21:22.869]                       invisible(muffled)
[10:21:22.869]                     }
[10:21:22.869]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.869]                   }
[10:21:22.869]                 }
[10:21:22.869]             }
[10:21:22.869]         }))
[10:21:22.869]     }, error = function(ex) {
[10:21:22.869]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.869]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.869]                 ...future.rng), started = ...future.startTime, 
[10:21:22.869]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.869]             version = "1.8"), class = "FutureResult")
[10:21:22.869]     }, finally = {
[10:21:22.869]         if (!identical(...future.workdir, getwd())) 
[10:21:22.869]             setwd(...future.workdir)
[10:21:22.869]         {
[10:21:22.869]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.869]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.869]             }
[10:21:22.869]             base::options(...future.oldOptions)
[10:21:22.869]             if (.Platform$OS.type == "windows") {
[10:21:22.869]                 old_names <- names(...future.oldEnvVars)
[10:21:22.869]                 envs <- base::Sys.getenv()
[10:21:22.869]                 names <- names(envs)
[10:21:22.869]                 common <- intersect(names, old_names)
[10:21:22.869]                 added <- setdiff(names, old_names)
[10:21:22.869]                 removed <- setdiff(old_names, names)
[10:21:22.869]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.869]                   envs[common]]
[10:21:22.869]                 NAMES <- toupper(changed)
[10:21:22.869]                 args <- list()
[10:21:22.869]                 for (kk in seq_along(NAMES)) {
[10:21:22.869]                   name <- changed[[kk]]
[10:21:22.869]                   NAME <- NAMES[[kk]]
[10:21:22.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.869]                     next
[10:21:22.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.869]                 }
[10:21:22.869]                 NAMES <- toupper(added)
[10:21:22.869]                 for (kk in seq_along(NAMES)) {
[10:21:22.869]                   name <- added[[kk]]
[10:21:22.869]                   NAME <- NAMES[[kk]]
[10:21:22.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.869]                     next
[10:21:22.869]                   args[[name]] <- ""
[10:21:22.869]                 }
[10:21:22.869]                 NAMES <- toupper(removed)
[10:21:22.869]                 for (kk in seq_along(NAMES)) {
[10:21:22.869]                   name <- removed[[kk]]
[10:21:22.869]                   NAME <- NAMES[[kk]]
[10:21:22.869]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.869]                     next
[10:21:22.869]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.869]                 }
[10:21:22.869]                 if (length(args) > 0) 
[10:21:22.869]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.869]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.869]             }
[10:21:22.869]             else {
[10:21:22.869]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.869]             }
[10:21:22.869]             {
[10:21:22.869]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.869]                   0L) {
[10:21:22.869]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.869]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.869]                   base::options(opts)
[10:21:22.869]                 }
[10:21:22.869]                 {
[10:21:22.869]                   {
[10:21:22.869]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.869]                     NULL
[10:21:22.869]                   }
[10:21:22.869]                   options(future.plan = NULL)
[10:21:22.869]                   if (is.na(NA_character_)) 
[10:21:22.869]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.869]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.869]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.869]                     .init = FALSE)
[10:21:22.869]                 }
[10:21:22.869]             }
[10:21:22.869]         }
[10:21:22.869]     })
[10:21:22.869]     if (TRUE) {
[10:21:22.869]         base::sink(type = "output", split = FALSE)
[10:21:22.869]         if (TRUE) {
[10:21:22.869]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.869]         }
[10:21:22.869]         else {
[10:21:22.869]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.869]         }
[10:21:22.869]         base::close(...future.stdout)
[10:21:22.869]         ...future.stdout <- NULL
[10:21:22.869]     }
[10:21:22.869]     ...future.result$conditions <- ...future.conditions
[10:21:22.869]     ...future.result$finished <- base::Sys.time()
[10:21:22.869]     ...future.result
[10:21:22.869] }
[10:21:22.873] requestCore(): workers = 2
[10:21:22.876] MulticoreFuture started
[10:21:22.876] - Launch lazy future ... done
[10:21:22.876] run() for ‘MulticoreFuture’ ... done
[10:21:22.877] plan(): Setting new future strategy stack:
[10:21:22.877] getGlobalsAndPackages() ...
[10:21:22.877] Searching for globals...
[10:21:22.877] List of future strategies:
[10:21:22.877] 1. sequential:
[10:21:22.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:22.877]    - tweaked: FALSE
[10:21:22.877]    - call: NULL
[10:21:22.878] plan(): nbrOfWorkers() = 1
[10:21:22.879] - globals found: [1] ‘{’
[10:21:22.879] Searching for globals ... DONE
[10:21:22.879] Resolving globals: FALSE
[10:21:22.880] 
[10:21:22.880] 
[10:21:22.880] getGlobalsAndPackages() ... DONE
[10:21:22.880] plan(): Setting new future strategy stack:
[10:21:22.880] run() for ‘Future’ ...
[10:21:22.880] List of future strategies:
[10:21:22.880] 1. multicore:
[10:21:22.880]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:22.880]    - tweaked: FALSE
[10:21:22.880]    - call: plan(strategy)
[10:21:22.880] - state: ‘created’
[10:21:22.881] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.883] plan(): nbrOfWorkers() = 2
[10:21:22.883] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:22.884]   - Field: ‘label’
[10:21:22.884]   - Field: ‘local’
[10:21:22.884]   - Field: ‘owner’
[10:21:22.884]   - Field: ‘envir’
[10:21:22.884]   - Field: ‘workers’
[10:21:22.884]   - Field: ‘packages’
[10:21:22.885]   - Field: ‘gc’
[10:21:22.885]   - Field: ‘job’
[10:21:22.885]   - Field: ‘conditions’
[10:21:22.885]   - Field: ‘expr’
[10:21:22.885]   - Field: ‘uuid’
[10:21:22.885]   - Field: ‘seed’
[10:21:22.885]   - Field: ‘version’
[10:21:22.885]   - Field: ‘result’
[10:21:22.886]   - Field: ‘asynchronous’
[10:21:22.886]   - Field: ‘calls’
[10:21:22.886]   - Field: ‘globals’
[10:21:22.886]   - Field: ‘stdout’
[10:21:22.886]   - Field: ‘earlySignal’
[10:21:22.886]   - Field: ‘lazy’
[10:21:22.886]   - Field: ‘state’
[10:21:22.886] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:22.887] - Launch lazy future ...
[10:21:22.887] Packages needed by the future expression (n = 0): <none>
[10:21:22.887] Packages needed by future strategies (n = 0): <none>
[10:21:22.888] {
[10:21:22.888]     {
[10:21:22.888]         {
[10:21:22.888]             ...future.startTime <- base::Sys.time()
[10:21:22.888]             {
[10:21:22.888]                 {
[10:21:22.888]                   {
[10:21:22.888]                     {
[10:21:22.888]                       base::local({
[10:21:22.888]                         has_future <- base::requireNamespace("future", 
[10:21:22.888]                           quietly = TRUE)
[10:21:22.888]                         if (has_future) {
[10:21:22.888]                           ns <- base::getNamespace("future")
[10:21:22.888]                           version <- ns[[".package"]][["version"]]
[10:21:22.888]                           if (is.null(version)) 
[10:21:22.888]                             version <- utils::packageVersion("future")
[10:21:22.888]                         }
[10:21:22.888]                         else {
[10:21:22.888]                           version <- NULL
[10:21:22.888]                         }
[10:21:22.888]                         if (!has_future || version < "1.8.0") {
[10:21:22.888]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.888]                             "", base::R.version$version.string), 
[10:21:22.888]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.888]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.888]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.888]                               "release", "version")], collapse = " "), 
[10:21:22.888]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.888]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.888]                             info)
[10:21:22.888]                           info <- base::paste(info, collapse = "; ")
[10:21:22.888]                           if (!has_future) {
[10:21:22.888]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.888]                               info)
[10:21:22.888]                           }
[10:21:22.888]                           else {
[10:21:22.888]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.888]                               info, version)
[10:21:22.888]                           }
[10:21:22.888]                           base::stop(msg)
[10:21:22.888]                         }
[10:21:22.888]                       })
[10:21:22.888]                     }
[10:21:22.888]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.888]                     base::options(mc.cores = 1L)
[10:21:22.888]                   }
[10:21:22.888]                   ...future.strategy.old <- future::plan("list")
[10:21:22.888]                   options(future.plan = NULL)
[10:21:22.888]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.888]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.888]                 }
[10:21:22.888]                 ...future.workdir <- getwd()
[10:21:22.888]             }
[10:21:22.888]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.888]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.888]         }
[10:21:22.888]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.888]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.888]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.888]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.888]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.888]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.888]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.888]             base::names(...future.oldOptions))
[10:21:22.888]     }
[10:21:22.888]     if (FALSE) {
[10:21:22.888]     }
[10:21:22.888]     else {
[10:21:22.888]         if (TRUE) {
[10:21:22.888]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.888]                 open = "w")
[10:21:22.888]         }
[10:21:22.888]         else {
[10:21:22.888]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.888]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.888]         }
[10:21:22.888]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.888]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.888]             base::sink(type = "output", split = FALSE)
[10:21:22.888]             base::close(...future.stdout)
[10:21:22.888]         }, add = TRUE)
[10:21:22.888]     }
[10:21:22.888]     ...future.frame <- base::sys.nframe()
[10:21:22.888]     ...future.conditions <- base::list()
[10:21:22.888]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.888]     if (FALSE) {
[10:21:22.888]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.888]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.888]     }
[10:21:22.888]     ...future.result <- base::tryCatch({
[10:21:22.888]         base::withCallingHandlers({
[10:21:22.888]             ...future.value <- base::withVisible(base::local({
[10:21:22.888]                 withCallingHandlers({
[10:21:22.888]                   {
[10:21:22.888]                     4
[10:21:22.888]                   }
[10:21:22.888]                 }, immediateCondition = function(cond) {
[10:21:22.888]                   save_rds <- function (object, pathname, ...) 
[10:21:22.888]                   {
[10:21:22.888]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:22.888]                     if (file_test("-f", pathname_tmp)) {
[10:21:22.888]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.888]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:22.888]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.888]                         fi_tmp[["mtime"]])
[10:21:22.888]                     }
[10:21:22.888]                     tryCatch({
[10:21:22.888]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:22.888]                     }, error = function(ex) {
[10:21:22.888]                       msg <- conditionMessage(ex)
[10:21:22.888]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.888]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:22.888]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.888]                         fi_tmp[["mtime"]], msg)
[10:21:22.888]                       ex$message <- msg
[10:21:22.888]                       stop(ex)
[10:21:22.888]                     })
[10:21:22.888]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:22.888]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:22.888]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:22.888]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.888]                       fi <- file.info(pathname)
[10:21:22.888]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:22.888]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.888]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:22.888]                         fi[["size"]], fi[["mtime"]])
[10:21:22.888]                       stop(msg)
[10:21:22.888]                     }
[10:21:22.888]                     invisible(pathname)
[10:21:22.888]                   }
[10:21:22.888]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:22.888]                     rootPath = tempdir()) 
[10:21:22.888]                   {
[10:21:22.888]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:22.888]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:22.888]                       tmpdir = path, fileext = ".rds")
[10:21:22.888]                     save_rds(obj, file)
[10:21:22.888]                   }
[10:21:22.888]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:22.888]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.888]                   {
[10:21:22.888]                     inherits <- base::inherits
[10:21:22.888]                     invokeRestart <- base::invokeRestart
[10:21:22.888]                     is.null <- base::is.null
[10:21:22.888]                     muffled <- FALSE
[10:21:22.888]                     if (inherits(cond, "message")) {
[10:21:22.888]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.888]                       if (muffled) 
[10:21:22.888]                         invokeRestart("muffleMessage")
[10:21:22.888]                     }
[10:21:22.888]                     else if (inherits(cond, "warning")) {
[10:21:22.888]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.888]                       if (muffled) 
[10:21:22.888]                         invokeRestart("muffleWarning")
[10:21:22.888]                     }
[10:21:22.888]                     else if (inherits(cond, "condition")) {
[10:21:22.888]                       if (!is.null(pattern)) {
[10:21:22.888]                         computeRestarts <- base::computeRestarts
[10:21:22.888]                         grepl <- base::grepl
[10:21:22.888]                         restarts <- computeRestarts(cond)
[10:21:22.888]                         for (restart in restarts) {
[10:21:22.888]                           name <- restart$name
[10:21:22.888]                           if (is.null(name)) 
[10:21:22.888]                             next
[10:21:22.888]                           if (!grepl(pattern, name)) 
[10:21:22.888]                             next
[10:21:22.888]                           invokeRestart(restart)
[10:21:22.888]                           muffled <- TRUE
[10:21:22.888]                           break
[10:21:22.888]                         }
[10:21:22.888]                       }
[10:21:22.888]                     }
[10:21:22.888]                     invisible(muffled)
[10:21:22.888]                   }
[10:21:22.888]                   muffleCondition(cond)
[10:21:22.888]                 })
[10:21:22.888]             }))
[10:21:22.888]             future::FutureResult(value = ...future.value$value, 
[10:21:22.888]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.888]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.888]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.888]                     ...future.globalenv.names))
[10:21:22.888]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.888]         }, condition = base::local({
[10:21:22.888]             c <- base::c
[10:21:22.888]             inherits <- base::inherits
[10:21:22.888]             invokeRestart <- base::invokeRestart
[10:21:22.888]             length <- base::length
[10:21:22.888]             list <- base::list
[10:21:22.888]             seq.int <- base::seq.int
[10:21:22.888]             signalCondition <- base::signalCondition
[10:21:22.888]             sys.calls <- base::sys.calls
[10:21:22.888]             `[[` <- base::`[[`
[10:21:22.888]             `+` <- base::`+`
[10:21:22.888]             `<<-` <- base::`<<-`
[10:21:22.888]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.888]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.888]                   3L)]
[10:21:22.888]             }
[10:21:22.888]             function(cond) {
[10:21:22.888]                 is_error <- inherits(cond, "error")
[10:21:22.888]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.888]                   NULL)
[10:21:22.888]                 if (is_error) {
[10:21:22.888]                   sessionInformation <- function() {
[10:21:22.888]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.888]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.888]                       search = base::search(), system = base::Sys.info())
[10:21:22.888]                   }
[10:21:22.888]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.888]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.888]                     cond$call), session = sessionInformation(), 
[10:21:22.888]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.888]                   signalCondition(cond)
[10:21:22.888]                 }
[10:21:22.888]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.888]                 "immediateCondition"))) {
[10:21:22.888]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.888]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.888]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.888]                   if (TRUE && !signal) {
[10:21:22.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.888]                     {
[10:21:22.888]                       inherits <- base::inherits
[10:21:22.888]                       invokeRestart <- base::invokeRestart
[10:21:22.888]                       is.null <- base::is.null
[10:21:22.888]                       muffled <- FALSE
[10:21:22.888]                       if (inherits(cond, "message")) {
[10:21:22.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.888]                         if (muffled) 
[10:21:22.888]                           invokeRestart("muffleMessage")
[10:21:22.888]                       }
[10:21:22.888]                       else if (inherits(cond, "warning")) {
[10:21:22.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.888]                         if (muffled) 
[10:21:22.888]                           invokeRestart("muffleWarning")
[10:21:22.888]                       }
[10:21:22.888]                       else if (inherits(cond, "condition")) {
[10:21:22.888]                         if (!is.null(pattern)) {
[10:21:22.888]                           computeRestarts <- base::computeRestarts
[10:21:22.888]                           grepl <- base::grepl
[10:21:22.888]                           restarts <- computeRestarts(cond)
[10:21:22.888]                           for (restart in restarts) {
[10:21:22.888]                             name <- restart$name
[10:21:22.888]                             if (is.null(name)) 
[10:21:22.888]                               next
[10:21:22.888]                             if (!grepl(pattern, name)) 
[10:21:22.888]                               next
[10:21:22.888]                             invokeRestart(restart)
[10:21:22.888]                             muffled <- TRUE
[10:21:22.888]                             break
[10:21:22.888]                           }
[10:21:22.888]                         }
[10:21:22.888]                       }
[10:21:22.888]                       invisible(muffled)
[10:21:22.888]                     }
[10:21:22.888]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.888]                   }
[10:21:22.888]                 }
[10:21:22.888]                 else {
[10:21:22.888]                   if (TRUE) {
[10:21:22.888]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.888]                     {
[10:21:22.888]                       inherits <- base::inherits
[10:21:22.888]                       invokeRestart <- base::invokeRestart
[10:21:22.888]                       is.null <- base::is.null
[10:21:22.888]                       muffled <- FALSE
[10:21:22.888]                       if (inherits(cond, "message")) {
[10:21:22.888]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.888]                         if (muffled) 
[10:21:22.888]                           invokeRestart("muffleMessage")
[10:21:22.888]                       }
[10:21:22.888]                       else if (inherits(cond, "warning")) {
[10:21:22.888]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.888]                         if (muffled) 
[10:21:22.888]                           invokeRestart("muffleWarning")
[10:21:22.888]                       }
[10:21:22.888]                       else if (inherits(cond, "condition")) {
[10:21:22.888]                         if (!is.null(pattern)) {
[10:21:22.888]                           computeRestarts <- base::computeRestarts
[10:21:22.888]                           grepl <- base::grepl
[10:21:22.888]                           restarts <- computeRestarts(cond)
[10:21:22.888]                           for (restart in restarts) {
[10:21:22.888]                             name <- restart$name
[10:21:22.888]                             if (is.null(name)) 
[10:21:22.888]                               next
[10:21:22.888]                             if (!grepl(pattern, name)) 
[10:21:22.888]                               next
[10:21:22.888]                             invokeRestart(restart)
[10:21:22.888]                             muffled <- TRUE
[10:21:22.888]                             break
[10:21:22.888]                           }
[10:21:22.888]                         }
[10:21:22.888]                       }
[10:21:22.888]                       invisible(muffled)
[10:21:22.888]                     }
[10:21:22.888]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.888]                   }
[10:21:22.888]                 }
[10:21:22.888]             }
[10:21:22.888]         }))
[10:21:22.888]     }, error = function(ex) {
[10:21:22.888]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.888]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.888]                 ...future.rng), started = ...future.startTime, 
[10:21:22.888]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.888]             version = "1.8"), class = "FutureResult")
[10:21:22.888]     }, finally = {
[10:21:22.888]         if (!identical(...future.workdir, getwd())) 
[10:21:22.888]             setwd(...future.workdir)
[10:21:22.888]         {
[10:21:22.888]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.888]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.888]             }
[10:21:22.888]             base::options(...future.oldOptions)
[10:21:22.888]             if (.Platform$OS.type == "windows") {
[10:21:22.888]                 old_names <- names(...future.oldEnvVars)
[10:21:22.888]                 envs <- base::Sys.getenv()
[10:21:22.888]                 names <- names(envs)
[10:21:22.888]                 common <- intersect(names, old_names)
[10:21:22.888]                 added <- setdiff(names, old_names)
[10:21:22.888]                 removed <- setdiff(old_names, names)
[10:21:22.888]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.888]                   envs[common]]
[10:21:22.888]                 NAMES <- toupper(changed)
[10:21:22.888]                 args <- list()
[10:21:22.888]                 for (kk in seq_along(NAMES)) {
[10:21:22.888]                   name <- changed[[kk]]
[10:21:22.888]                   NAME <- NAMES[[kk]]
[10:21:22.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.888]                     next
[10:21:22.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.888]                 }
[10:21:22.888]                 NAMES <- toupper(added)
[10:21:22.888]                 for (kk in seq_along(NAMES)) {
[10:21:22.888]                   name <- added[[kk]]
[10:21:22.888]                   NAME <- NAMES[[kk]]
[10:21:22.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.888]                     next
[10:21:22.888]                   args[[name]] <- ""
[10:21:22.888]                 }
[10:21:22.888]                 NAMES <- toupper(removed)
[10:21:22.888]                 for (kk in seq_along(NAMES)) {
[10:21:22.888]                   name <- removed[[kk]]
[10:21:22.888]                   NAME <- NAMES[[kk]]
[10:21:22.888]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.888]                     next
[10:21:22.888]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.888]                 }
[10:21:22.888]                 if (length(args) > 0) 
[10:21:22.888]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.888]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.888]             }
[10:21:22.888]             else {
[10:21:22.888]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.888]             }
[10:21:22.888]             {
[10:21:22.888]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.888]                   0L) {
[10:21:22.888]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.888]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.888]                   base::options(opts)
[10:21:22.888]                 }
[10:21:22.888]                 {
[10:21:22.888]                   {
[10:21:22.888]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.888]                     NULL
[10:21:22.888]                   }
[10:21:22.888]                   options(future.plan = NULL)
[10:21:22.888]                   if (is.na(NA_character_)) 
[10:21:22.888]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.888]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.888]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.888]                     .init = FALSE)
[10:21:22.888]                 }
[10:21:22.888]             }
[10:21:22.888]         }
[10:21:22.888]     })
[10:21:22.888]     if (TRUE) {
[10:21:22.888]         base::sink(type = "output", split = FALSE)
[10:21:22.888]         if (TRUE) {
[10:21:22.888]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.888]         }
[10:21:22.888]         else {
[10:21:22.888]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.888]         }
[10:21:22.888]         base::close(...future.stdout)
[10:21:22.888]         ...future.stdout <- NULL
[10:21:22.888]     }
[10:21:22.888]     ...future.result$conditions <- ...future.conditions
[10:21:22.888]     ...future.result$finished <- base::Sys.time()
[10:21:22.888]     ...future.result
[10:21:22.888] }
[10:21:22.891] requestCore(): workers = 2
[10:21:22.892] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:22.902] result() for MulticoreFuture ...
[10:21:22.903] result() for MulticoreFuture ...
[10:21:22.903] result() for MulticoreFuture ... done
[10:21:22.904] result() for MulticoreFuture ... done
[10:21:22.904] result() for MulticoreFuture ...
[10:21:22.904] result() for MulticoreFuture ... done
[10:21:22.907] MulticoreFuture started
[10:21:22.907] - Launch lazy future ... done
[10:21:22.907] run() for ‘MulticoreFuture’ ... done
[10:21:22.908] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55e8e6900da0> 
[10:21:22.908] List of future strategies:
[10:21:22.908] 1. sequential:
[10:21:22.908]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:22.908]    - tweaked: FALSE
[10:21:22.908]    - call: NULL
[10:21:22.910] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55e8e74451b0> 
[10:21:22.912] plan(): Setting new future strategy stack:
[10:21:22.913] List of future strategies:
[10:21:22.913] 1. multicore:
[10:21:22.913]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:22.913]    - tweaked: FALSE
[10:21:22.913]    - call: plan(strategy)
[10:21:22.916] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:22.919] resolve() on list environment ...
[10:21:22.919]  recursive: 0
[10:21:22.929]  length: 6
[10:21:22.929]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:22.930] signalConditionsASAP(numeric, pos=1) ...
[10:21:22.930] - nx: 6
[10:21:22.931] - relay: TRUE
[10:21:22.931] - stdout: TRUE
[10:21:22.932] - signal: TRUE
[10:21:22.932] - resignal: FALSE
[10:21:22.932] - force: TRUE
[10:21:22.932] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:22.932] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:22.933]  - until=2
[10:21:22.933]  - relaying element #2
[10:21:22.933] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:22.933] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:22.933] signalConditionsASAP(NULL, pos=1) ... done
[10:21:22.933]  length: 5 (resolved future 1)
[10:21:22.933] Future #2
[10:21:22.934] result() for MulticoreFuture ...
[10:21:22.934] result() for MulticoreFuture ... done
[10:21:22.934] result() for MulticoreFuture ...
[10:21:22.934] result() for MulticoreFuture ... done
[10:21:22.934] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:22.934] - nx: 6
[10:21:22.934] - relay: TRUE
[10:21:22.935] - stdout: TRUE
[10:21:22.935] - signal: TRUE
[10:21:22.935] - resignal: FALSE
[10:21:22.935] - force: TRUE
[10:21:22.935] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:22.935] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:22.935]  - until=2
[10:21:22.935]  - relaying element #2
[10:21:22.936] result() for MulticoreFuture ...
[10:21:22.936] result() for MulticoreFuture ... done
[10:21:22.936] result() for MulticoreFuture ...
[10:21:22.936] result() for MulticoreFuture ... done
[10:21:22.936] result() for MulticoreFuture ...
[10:21:22.936] result() for MulticoreFuture ... done
[10:21:22.936] result() for MulticoreFuture ...
[10:21:22.937] result() for MulticoreFuture ... done
[10:21:22.937] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:22.937] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:22.937] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:22.937]  length: 4 (resolved future 2)
[10:21:22.937] Future #3
[10:21:22.938] result() for MulticoreFuture ...
[10:21:22.938] result() for MulticoreFuture ...
[10:21:22.939] result() for MulticoreFuture ... done
[10:21:22.939] result() for MulticoreFuture ... done
[10:21:22.939] result() for MulticoreFuture ...
[10:21:22.939] result() for MulticoreFuture ... done
[10:21:22.939] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:22.939] - nx: 6
[10:21:22.939] - relay: TRUE
[10:21:22.939] - stdout: TRUE
[10:21:22.940] - signal: TRUE
[10:21:22.940] - resignal: FALSE
[10:21:22.940] - force: TRUE
[10:21:22.940] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:22.940] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:22.940]  - until=3
[10:21:22.940]  - relaying element #3
[10:21:22.940] result() for MulticoreFuture ...
[10:21:22.940] result() for MulticoreFuture ... done
[10:21:22.941] result() for MulticoreFuture ...
[10:21:22.941] result() for MulticoreFuture ... done
[10:21:22.941] result() for MulticoreFuture ...
[10:21:22.941] result() for MulticoreFuture ... done
[10:21:22.941] result() for MulticoreFuture ...
[10:21:22.941] result() for MulticoreFuture ... done
[10:21:22.941] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:22.941] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:22.942] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:22.942]  length: 3 (resolved future 3)
[10:21:22.942] Future #4
[10:21:22.942] result() for MulticoreFuture ...
[10:21:22.943] result() for MulticoreFuture ...
[10:21:22.943] result() for MulticoreFuture ... done
[10:21:22.943] result() for MulticoreFuture ... done
[10:21:22.943] result() for MulticoreFuture ...
[10:21:22.944] result() for MulticoreFuture ... done
[10:21:22.944] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:22.944] - nx: 6
[10:21:22.944] - relay: TRUE
[10:21:22.944] - stdout: TRUE
[10:21:22.944] - signal: TRUE
[10:21:22.945] - resignal: FALSE
[10:21:22.945] - force: TRUE
[10:21:22.945] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:22.945] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:22.945]  - until=4
[10:21:22.945]  - relaying element #4
[10:21:22.946] result() for MulticoreFuture ...
[10:21:22.946] result() for MulticoreFuture ... done
[10:21:22.946] result() for MulticoreFuture ...
[10:21:22.946] result() for MulticoreFuture ... done
[10:21:22.946] result() for MulticoreFuture ...
[10:21:22.946] result() for MulticoreFuture ... done
[10:21:22.947] result() for MulticoreFuture ...
[10:21:22.947] result() for MulticoreFuture ... done
[10:21:22.947] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:22.947] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:22.947] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:22.947]  length: 2 (resolved future 4)
[10:21:22.948] signalConditionsASAP(NULL, pos=5) ...
[10:21:22.948] - nx: 6
[10:21:22.948] - relay: TRUE
[10:21:22.948] - stdout: TRUE
[10:21:22.948] - signal: TRUE
[10:21:22.948] - resignal: FALSE
[10:21:22.948] - force: TRUE
[10:21:22.948] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:22.949] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:22.949]  - until=6
[10:21:22.949]  - relaying element #6
[10:21:22.949] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:22.949] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:22.949] signalConditionsASAP(NULL, pos=5) ... done
[10:21:22.949]  length: 1 (resolved future 5)
[10:21:22.949] signalConditionsASAP(numeric, pos=6) ...
[10:21:22.950] - nx: 6
[10:21:22.950] - relay: TRUE
[10:21:22.950] - stdout: TRUE
[10:21:22.950] - signal: TRUE
[10:21:22.950] - resignal: FALSE
[10:21:22.950] - force: TRUE
[10:21:22.950] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:22.950] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:22.950]  - until=6
[10:21:22.950] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:22.950] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:22.951] signalConditionsASAP(numeric, pos=6) ... done
[10:21:22.951]  length: 0 (resolved future 6)
[10:21:22.951] Relaying remaining futures
[10:21:22.951] signalConditionsASAP(NULL, pos=0) ...
[10:21:22.951] - nx: 6
[10:21:22.951] - relay: TRUE
[10:21:22.951] - stdout: TRUE
[10:21:22.951] - signal: TRUE
[10:21:22.951] - resignal: FALSE
[10:21:22.951] - force: TRUE
[10:21:22.951] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:22.952] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:22.952] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:22.952] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:22.952] signalConditionsASAP(NULL, pos=0) ... done
[10:21:22.952] resolve() on list environment ... DONE
[10:21:22.952] result() for MulticoreFuture ...
[10:21:22.952] result() for MulticoreFuture ... done
[10:21:22.952] result() for MulticoreFuture ...
[10:21:22.953] result() for MulticoreFuture ... done
[10:21:22.953] result() for MulticoreFuture ...
[10:21:22.953] result() for MulticoreFuture ... done
[10:21:22.953] result() for MulticoreFuture ...
[10:21:22.953] result() for MulticoreFuture ... done
[10:21:22.953] result() for MulticoreFuture ...
[10:21:22.953] result() for MulticoreFuture ... done
[10:21:22.953] result() for MulticoreFuture ...
[10:21:22.954] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e7651b00> 
Dimensions: c(1, 6)
[10:21:22.954] getGlobalsAndPackages() ...
[10:21:22.954] Searching for globals...
[10:21:22.955] 
[10:21:22.955] Searching for globals ... DONE
[10:21:22.955] - globals: [0] <none>
[10:21:22.955] getGlobalsAndPackages() ... DONE
[10:21:22.956] run() for ‘Future’ ...
[10:21:22.956] - state: ‘created’
[10:21:22.956] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.958] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.958] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:22.958]   - Field: ‘label’
[10:21:22.958]   - Field: ‘local’
[10:21:22.958]   - Field: ‘owner’
[10:21:22.958]   - Field: ‘envir’
[10:21:22.959]   - Field: ‘workers’
[10:21:22.959]   - Field: ‘packages’
[10:21:22.959]   - Field: ‘gc’
[10:21:22.959]   - Field: ‘job’
[10:21:22.959]   - Field: ‘conditions’
[10:21:22.959]   - Field: ‘expr’
[10:21:22.959]   - Field: ‘uuid’
[10:21:22.959]   - Field: ‘seed’
[10:21:22.959]   - Field: ‘version’
[10:21:22.959]   - Field: ‘result’
[10:21:22.960]   - Field: ‘asynchronous’
[10:21:22.960]   - Field: ‘calls’
[10:21:22.960]   - Field: ‘globals’
[10:21:22.960]   - Field: ‘stdout’
[10:21:22.960]   - Field: ‘earlySignal’
[10:21:22.960]   - Field: ‘lazy’
[10:21:22.960]   - Field: ‘state’
[10:21:22.960] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:22.961] - Launch lazy future ...
[10:21:22.961] Packages needed by the future expression (n = 0): <none>
[10:21:22.961] Packages needed by future strategies (n = 0): <none>
[10:21:22.962] {
[10:21:22.962]     {
[10:21:22.962]         {
[10:21:22.962]             ...future.startTime <- base::Sys.time()
[10:21:22.962]             {
[10:21:22.962]                 {
[10:21:22.962]                   {
[10:21:22.962]                     {
[10:21:22.962]                       base::local({
[10:21:22.962]                         has_future <- base::requireNamespace("future", 
[10:21:22.962]                           quietly = TRUE)
[10:21:22.962]                         if (has_future) {
[10:21:22.962]                           ns <- base::getNamespace("future")
[10:21:22.962]                           version <- ns[[".package"]][["version"]]
[10:21:22.962]                           if (is.null(version)) 
[10:21:22.962]                             version <- utils::packageVersion("future")
[10:21:22.962]                         }
[10:21:22.962]                         else {
[10:21:22.962]                           version <- NULL
[10:21:22.962]                         }
[10:21:22.962]                         if (!has_future || version < "1.8.0") {
[10:21:22.962]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.962]                             "", base::R.version$version.string), 
[10:21:22.962]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.962]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.962]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.962]                               "release", "version")], collapse = " "), 
[10:21:22.962]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.962]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.962]                             info)
[10:21:22.962]                           info <- base::paste(info, collapse = "; ")
[10:21:22.962]                           if (!has_future) {
[10:21:22.962]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.962]                               info)
[10:21:22.962]                           }
[10:21:22.962]                           else {
[10:21:22.962]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.962]                               info, version)
[10:21:22.962]                           }
[10:21:22.962]                           base::stop(msg)
[10:21:22.962]                         }
[10:21:22.962]                       })
[10:21:22.962]                     }
[10:21:22.962]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.962]                     base::options(mc.cores = 1L)
[10:21:22.962]                   }
[10:21:22.962]                   ...future.strategy.old <- future::plan("list")
[10:21:22.962]                   options(future.plan = NULL)
[10:21:22.962]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.962]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.962]                 }
[10:21:22.962]                 ...future.workdir <- getwd()
[10:21:22.962]             }
[10:21:22.962]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.962]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.962]         }
[10:21:22.962]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.962]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.962]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.962]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.962]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.962]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.962]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.962]             base::names(...future.oldOptions))
[10:21:22.962]     }
[10:21:22.962]     if (FALSE) {
[10:21:22.962]     }
[10:21:22.962]     else {
[10:21:22.962]         if (TRUE) {
[10:21:22.962]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.962]                 open = "w")
[10:21:22.962]         }
[10:21:22.962]         else {
[10:21:22.962]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.962]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.962]         }
[10:21:22.962]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.962]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.962]             base::sink(type = "output", split = FALSE)
[10:21:22.962]             base::close(...future.stdout)
[10:21:22.962]         }, add = TRUE)
[10:21:22.962]     }
[10:21:22.962]     ...future.frame <- base::sys.nframe()
[10:21:22.962]     ...future.conditions <- base::list()
[10:21:22.962]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.962]     if (FALSE) {
[10:21:22.962]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.962]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.962]     }
[10:21:22.962]     ...future.result <- base::tryCatch({
[10:21:22.962]         base::withCallingHandlers({
[10:21:22.962]             ...future.value <- base::withVisible(base::local({
[10:21:22.962]                 withCallingHandlers({
[10:21:22.962]                   2
[10:21:22.962]                 }, immediateCondition = function(cond) {
[10:21:22.962]                   save_rds <- function (object, pathname, ...) 
[10:21:22.962]                   {
[10:21:22.962]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:22.962]                     if (file_test("-f", pathname_tmp)) {
[10:21:22.962]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.962]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:22.962]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.962]                         fi_tmp[["mtime"]])
[10:21:22.962]                     }
[10:21:22.962]                     tryCatch({
[10:21:22.962]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:22.962]                     }, error = function(ex) {
[10:21:22.962]                       msg <- conditionMessage(ex)
[10:21:22.962]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.962]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:22.962]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.962]                         fi_tmp[["mtime"]], msg)
[10:21:22.962]                       ex$message <- msg
[10:21:22.962]                       stop(ex)
[10:21:22.962]                     })
[10:21:22.962]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:22.962]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:22.962]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:22.962]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.962]                       fi <- file.info(pathname)
[10:21:22.962]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:22.962]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.962]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:22.962]                         fi[["size"]], fi[["mtime"]])
[10:21:22.962]                       stop(msg)
[10:21:22.962]                     }
[10:21:22.962]                     invisible(pathname)
[10:21:22.962]                   }
[10:21:22.962]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:22.962]                     rootPath = tempdir()) 
[10:21:22.962]                   {
[10:21:22.962]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:22.962]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:22.962]                       tmpdir = path, fileext = ".rds")
[10:21:22.962]                     save_rds(obj, file)
[10:21:22.962]                   }
[10:21:22.962]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:22.962]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.962]                   {
[10:21:22.962]                     inherits <- base::inherits
[10:21:22.962]                     invokeRestart <- base::invokeRestart
[10:21:22.962]                     is.null <- base::is.null
[10:21:22.962]                     muffled <- FALSE
[10:21:22.962]                     if (inherits(cond, "message")) {
[10:21:22.962]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.962]                       if (muffled) 
[10:21:22.962]                         invokeRestart("muffleMessage")
[10:21:22.962]                     }
[10:21:22.962]                     else if (inherits(cond, "warning")) {
[10:21:22.962]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.962]                       if (muffled) 
[10:21:22.962]                         invokeRestart("muffleWarning")
[10:21:22.962]                     }
[10:21:22.962]                     else if (inherits(cond, "condition")) {
[10:21:22.962]                       if (!is.null(pattern)) {
[10:21:22.962]                         computeRestarts <- base::computeRestarts
[10:21:22.962]                         grepl <- base::grepl
[10:21:22.962]                         restarts <- computeRestarts(cond)
[10:21:22.962]                         for (restart in restarts) {
[10:21:22.962]                           name <- restart$name
[10:21:22.962]                           if (is.null(name)) 
[10:21:22.962]                             next
[10:21:22.962]                           if (!grepl(pattern, name)) 
[10:21:22.962]                             next
[10:21:22.962]                           invokeRestart(restart)
[10:21:22.962]                           muffled <- TRUE
[10:21:22.962]                           break
[10:21:22.962]                         }
[10:21:22.962]                       }
[10:21:22.962]                     }
[10:21:22.962]                     invisible(muffled)
[10:21:22.962]                   }
[10:21:22.962]                   muffleCondition(cond)
[10:21:22.962]                 })
[10:21:22.962]             }))
[10:21:22.962]             future::FutureResult(value = ...future.value$value, 
[10:21:22.962]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.962]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.962]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.962]                     ...future.globalenv.names))
[10:21:22.962]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.962]         }, condition = base::local({
[10:21:22.962]             c <- base::c
[10:21:22.962]             inherits <- base::inherits
[10:21:22.962]             invokeRestart <- base::invokeRestart
[10:21:22.962]             length <- base::length
[10:21:22.962]             list <- base::list
[10:21:22.962]             seq.int <- base::seq.int
[10:21:22.962]             signalCondition <- base::signalCondition
[10:21:22.962]             sys.calls <- base::sys.calls
[10:21:22.962]             `[[` <- base::`[[`
[10:21:22.962]             `+` <- base::`+`
[10:21:22.962]             `<<-` <- base::`<<-`
[10:21:22.962]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.962]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.962]                   3L)]
[10:21:22.962]             }
[10:21:22.962]             function(cond) {
[10:21:22.962]                 is_error <- inherits(cond, "error")
[10:21:22.962]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.962]                   NULL)
[10:21:22.962]                 if (is_error) {
[10:21:22.962]                   sessionInformation <- function() {
[10:21:22.962]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.962]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.962]                       search = base::search(), system = base::Sys.info())
[10:21:22.962]                   }
[10:21:22.962]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.962]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.962]                     cond$call), session = sessionInformation(), 
[10:21:22.962]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.962]                   signalCondition(cond)
[10:21:22.962]                 }
[10:21:22.962]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.962]                 "immediateCondition"))) {
[10:21:22.962]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.962]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.962]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.962]                   if (TRUE && !signal) {
[10:21:22.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.962]                     {
[10:21:22.962]                       inherits <- base::inherits
[10:21:22.962]                       invokeRestart <- base::invokeRestart
[10:21:22.962]                       is.null <- base::is.null
[10:21:22.962]                       muffled <- FALSE
[10:21:22.962]                       if (inherits(cond, "message")) {
[10:21:22.962]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.962]                         if (muffled) 
[10:21:22.962]                           invokeRestart("muffleMessage")
[10:21:22.962]                       }
[10:21:22.962]                       else if (inherits(cond, "warning")) {
[10:21:22.962]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.962]                         if (muffled) 
[10:21:22.962]                           invokeRestart("muffleWarning")
[10:21:22.962]                       }
[10:21:22.962]                       else if (inherits(cond, "condition")) {
[10:21:22.962]                         if (!is.null(pattern)) {
[10:21:22.962]                           computeRestarts <- base::computeRestarts
[10:21:22.962]                           grepl <- base::grepl
[10:21:22.962]                           restarts <- computeRestarts(cond)
[10:21:22.962]                           for (restart in restarts) {
[10:21:22.962]                             name <- restart$name
[10:21:22.962]                             if (is.null(name)) 
[10:21:22.962]                               next
[10:21:22.962]                             if (!grepl(pattern, name)) 
[10:21:22.962]                               next
[10:21:22.962]                             invokeRestart(restart)
[10:21:22.962]                             muffled <- TRUE
[10:21:22.962]                             break
[10:21:22.962]                           }
[10:21:22.962]                         }
[10:21:22.962]                       }
[10:21:22.962]                       invisible(muffled)
[10:21:22.962]                     }
[10:21:22.962]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.962]                   }
[10:21:22.962]                 }
[10:21:22.962]                 else {
[10:21:22.962]                   if (TRUE) {
[10:21:22.962]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.962]                     {
[10:21:22.962]                       inherits <- base::inherits
[10:21:22.962]                       invokeRestart <- base::invokeRestart
[10:21:22.962]                       is.null <- base::is.null
[10:21:22.962]                       muffled <- FALSE
[10:21:22.962]                       if (inherits(cond, "message")) {
[10:21:22.962]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.962]                         if (muffled) 
[10:21:22.962]                           invokeRestart("muffleMessage")
[10:21:22.962]                       }
[10:21:22.962]                       else if (inherits(cond, "warning")) {
[10:21:22.962]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.962]                         if (muffled) 
[10:21:22.962]                           invokeRestart("muffleWarning")
[10:21:22.962]                       }
[10:21:22.962]                       else if (inherits(cond, "condition")) {
[10:21:22.962]                         if (!is.null(pattern)) {
[10:21:22.962]                           computeRestarts <- base::computeRestarts
[10:21:22.962]                           grepl <- base::grepl
[10:21:22.962]                           restarts <- computeRestarts(cond)
[10:21:22.962]                           for (restart in restarts) {
[10:21:22.962]                             name <- restart$name
[10:21:22.962]                             if (is.null(name)) 
[10:21:22.962]                               next
[10:21:22.962]                             if (!grepl(pattern, name)) 
[10:21:22.962]                               next
[10:21:22.962]                             invokeRestart(restart)
[10:21:22.962]                             muffled <- TRUE
[10:21:22.962]                             break
[10:21:22.962]                           }
[10:21:22.962]                         }
[10:21:22.962]                       }
[10:21:22.962]                       invisible(muffled)
[10:21:22.962]                     }
[10:21:22.962]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.962]                   }
[10:21:22.962]                 }
[10:21:22.962]             }
[10:21:22.962]         }))
[10:21:22.962]     }, error = function(ex) {
[10:21:22.962]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.962]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.962]                 ...future.rng), started = ...future.startTime, 
[10:21:22.962]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.962]             version = "1.8"), class = "FutureResult")
[10:21:22.962]     }, finally = {
[10:21:22.962]         if (!identical(...future.workdir, getwd())) 
[10:21:22.962]             setwd(...future.workdir)
[10:21:22.962]         {
[10:21:22.962]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.962]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.962]             }
[10:21:22.962]             base::options(...future.oldOptions)
[10:21:22.962]             if (.Platform$OS.type == "windows") {
[10:21:22.962]                 old_names <- names(...future.oldEnvVars)
[10:21:22.962]                 envs <- base::Sys.getenv()
[10:21:22.962]                 names <- names(envs)
[10:21:22.962]                 common <- intersect(names, old_names)
[10:21:22.962]                 added <- setdiff(names, old_names)
[10:21:22.962]                 removed <- setdiff(old_names, names)
[10:21:22.962]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.962]                   envs[common]]
[10:21:22.962]                 NAMES <- toupper(changed)
[10:21:22.962]                 args <- list()
[10:21:22.962]                 for (kk in seq_along(NAMES)) {
[10:21:22.962]                   name <- changed[[kk]]
[10:21:22.962]                   NAME <- NAMES[[kk]]
[10:21:22.962]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.962]                     next
[10:21:22.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.962]                 }
[10:21:22.962]                 NAMES <- toupper(added)
[10:21:22.962]                 for (kk in seq_along(NAMES)) {
[10:21:22.962]                   name <- added[[kk]]
[10:21:22.962]                   NAME <- NAMES[[kk]]
[10:21:22.962]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.962]                     next
[10:21:22.962]                   args[[name]] <- ""
[10:21:22.962]                 }
[10:21:22.962]                 NAMES <- toupper(removed)
[10:21:22.962]                 for (kk in seq_along(NAMES)) {
[10:21:22.962]                   name <- removed[[kk]]
[10:21:22.962]                   NAME <- NAMES[[kk]]
[10:21:22.962]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.962]                     next
[10:21:22.962]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.962]                 }
[10:21:22.962]                 if (length(args) > 0) 
[10:21:22.962]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.962]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.962]             }
[10:21:22.962]             else {
[10:21:22.962]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.962]             }
[10:21:22.962]             {
[10:21:22.962]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.962]                   0L) {
[10:21:22.962]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.962]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.962]                   base::options(opts)
[10:21:22.962]                 }
[10:21:22.962]                 {
[10:21:22.962]                   {
[10:21:22.962]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.962]                     NULL
[10:21:22.962]                   }
[10:21:22.962]                   options(future.plan = NULL)
[10:21:22.962]                   if (is.na(NA_character_)) 
[10:21:22.962]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.962]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.962]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.962]                     .init = FALSE)
[10:21:22.962]                 }
[10:21:22.962]             }
[10:21:22.962]         }
[10:21:22.962]     })
[10:21:22.962]     if (TRUE) {
[10:21:22.962]         base::sink(type = "output", split = FALSE)
[10:21:22.962]         if (TRUE) {
[10:21:22.962]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.962]         }
[10:21:22.962]         else {
[10:21:22.962]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.962]         }
[10:21:22.962]         base::close(...future.stdout)
[10:21:22.962]         ...future.stdout <- NULL
[10:21:22.962]     }
[10:21:22.962]     ...future.result$conditions <- ...future.conditions
[10:21:22.962]     ...future.result$finished <- base::Sys.time()
[10:21:22.962]     ...future.result
[10:21:22.962] }
[10:21:22.964] requestCore(): workers = 2
[10:21:22.966] MulticoreFuture started
[10:21:22.967] - Launch lazy future ... done
[10:21:22.967] run() for ‘MulticoreFuture’ ... done
[10:21:22.967] getGlobalsAndPackages() ...
[10:21:22.968] plan(): Setting new future strategy stack:
[10:21:22.968] Searching for globals...
[10:21:22.968] 
[10:21:22.968] List of future strategies:
[10:21:22.968] 1. sequential:
[10:21:22.968]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:22.968]    - tweaked: FALSE
[10:21:22.968]    - call: NULL
[10:21:22.969] Searching for globals ... DONE
[10:21:22.969] plan(): nbrOfWorkers() = 1
[10:21:22.969] - globals: [0] <none>
[10:21:22.969] getGlobalsAndPackages() ... DONE
[10:21:22.970] run() for ‘Future’ ...
[10:21:22.970] - state: ‘created’
[10:21:22.970] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.971] plan(): Setting new future strategy stack:
[10:21:22.971] List of future strategies:
[10:21:22.971] 1. multicore:
[10:21:22.971]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:22.971]    - tweaked: FALSE
[10:21:22.971]    - call: plan(strategy)
[10:21:22.973] plan(): nbrOfWorkers() = 2
[10:21:22.974] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.974] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:22.974]   - Field: ‘label’
[10:21:22.974]   - Field: ‘local’
[10:21:22.974]   - Field: ‘owner’
[10:21:22.974]   - Field: ‘envir’
[10:21:22.975]   - Field: ‘workers’
[10:21:22.975]   - Field: ‘packages’
[10:21:22.975]   - Field: ‘gc’
[10:21:22.975]   - Field: ‘job’
[10:21:22.975]   - Field: ‘conditions’
[10:21:22.975]   - Field: ‘expr’
[10:21:22.975]   - Field: ‘uuid’
[10:21:22.976]   - Field: ‘seed’
[10:21:22.976]   - Field: ‘version’
[10:21:22.976]   - Field: ‘result’
[10:21:22.976]   - Field: ‘asynchronous’
[10:21:22.976]   - Field: ‘calls’
[10:21:22.976]   - Field: ‘globals’
[10:21:22.976]   - Field: ‘stdout’
[10:21:22.977]   - Field: ‘earlySignal’
[10:21:22.977]   - Field: ‘lazy’
[10:21:22.977]   - Field: ‘state’
[10:21:22.977] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:22.977] - Launch lazy future ...
[10:21:22.978] Packages needed by the future expression (n = 0): <none>
[10:21:22.978] Packages needed by future strategies (n = 0): <none>
[10:21:22.979] {
[10:21:22.979]     {
[10:21:22.979]         {
[10:21:22.979]             ...future.startTime <- base::Sys.time()
[10:21:22.979]             {
[10:21:22.979]                 {
[10:21:22.979]                   {
[10:21:22.979]                     {
[10:21:22.979]                       base::local({
[10:21:22.979]                         has_future <- base::requireNamespace("future", 
[10:21:22.979]                           quietly = TRUE)
[10:21:22.979]                         if (has_future) {
[10:21:22.979]                           ns <- base::getNamespace("future")
[10:21:22.979]                           version <- ns[[".package"]][["version"]]
[10:21:22.979]                           if (is.null(version)) 
[10:21:22.979]                             version <- utils::packageVersion("future")
[10:21:22.979]                         }
[10:21:22.979]                         else {
[10:21:22.979]                           version <- NULL
[10:21:22.979]                         }
[10:21:22.979]                         if (!has_future || version < "1.8.0") {
[10:21:22.979]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.979]                             "", base::R.version$version.string), 
[10:21:22.979]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.979]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.979]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.979]                               "release", "version")], collapse = " "), 
[10:21:22.979]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.979]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.979]                             info)
[10:21:22.979]                           info <- base::paste(info, collapse = "; ")
[10:21:22.979]                           if (!has_future) {
[10:21:22.979]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.979]                               info)
[10:21:22.979]                           }
[10:21:22.979]                           else {
[10:21:22.979]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.979]                               info, version)
[10:21:22.979]                           }
[10:21:22.979]                           base::stop(msg)
[10:21:22.979]                         }
[10:21:22.979]                       })
[10:21:22.979]                     }
[10:21:22.979]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.979]                     base::options(mc.cores = 1L)
[10:21:22.979]                   }
[10:21:22.979]                   ...future.strategy.old <- future::plan("list")
[10:21:22.979]                   options(future.plan = NULL)
[10:21:22.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.979]                 }
[10:21:22.979]                 ...future.workdir <- getwd()
[10:21:22.979]             }
[10:21:22.979]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.979]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.979]         }
[10:21:22.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.979]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.979]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.979]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.979]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.979]             base::names(...future.oldOptions))
[10:21:22.979]     }
[10:21:22.979]     if (FALSE) {
[10:21:22.979]     }
[10:21:22.979]     else {
[10:21:22.979]         if (TRUE) {
[10:21:22.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.979]                 open = "w")
[10:21:22.979]         }
[10:21:22.979]         else {
[10:21:22.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.979]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.979]         }
[10:21:22.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.979]             base::sink(type = "output", split = FALSE)
[10:21:22.979]             base::close(...future.stdout)
[10:21:22.979]         }, add = TRUE)
[10:21:22.979]     }
[10:21:22.979]     ...future.frame <- base::sys.nframe()
[10:21:22.979]     ...future.conditions <- base::list()
[10:21:22.979]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.979]     if (FALSE) {
[10:21:22.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.979]     }
[10:21:22.979]     ...future.result <- base::tryCatch({
[10:21:22.979]         base::withCallingHandlers({
[10:21:22.979]             ...future.value <- base::withVisible(base::local({
[10:21:22.979]                 withCallingHandlers({
[10:21:22.979]                   NULL
[10:21:22.979]                 }, immediateCondition = function(cond) {
[10:21:22.979]                   save_rds <- function (object, pathname, ...) 
[10:21:22.979]                   {
[10:21:22.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:22.979]                     if (file_test("-f", pathname_tmp)) {
[10:21:22.979]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:22.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.979]                         fi_tmp[["mtime"]])
[10:21:22.979]                     }
[10:21:22.979]                     tryCatch({
[10:21:22.979]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:22.979]                     }, error = function(ex) {
[10:21:22.979]                       msg <- conditionMessage(ex)
[10:21:22.979]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:22.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.979]                         fi_tmp[["mtime"]], msg)
[10:21:22.979]                       ex$message <- msg
[10:21:22.979]                       stop(ex)
[10:21:22.979]                     })
[10:21:22.979]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:22.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:22.979]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:22.979]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.979]                       fi <- file.info(pathname)
[10:21:22.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:22.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:22.979]                         fi[["size"]], fi[["mtime"]])
[10:21:22.979]                       stop(msg)
[10:21:22.979]                     }
[10:21:22.979]                     invisible(pathname)
[10:21:22.979]                   }
[10:21:22.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:22.979]                     rootPath = tempdir()) 
[10:21:22.979]                   {
[10:21:22.979]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:22.979]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:22.979]                       tmpdir = path, fileext = ".rds")
[10:21:22.979]                     save_rds(obj, file)
[10:21:22.979]                   }
[10:21:22.979]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:22.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.979]                   {
[10:21:22.979]                     inherits <- base::inherits
[10:21:22.979]                     invokeRestart <- base::invokeRestart
[10:21:22.979]                     is.null <- base::is.null
[10:21:22.979]                     muffled <- FALSE
[10:21:22.979]                     if (inherits(cond, "message")) {
[10:21:22.979]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.979]                       if (muffled) 
[10:21:22.979]                         invokeRestart("muffleMessage")
[10:21:22.979]                     }
[10:21:22.979]                     else if (inherits(cond, "warning")) {
[10:21:22.979]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.979]                       if (muffled) 
[10:21:22.979]                         invokeRestart("muffleWarning")
[10:21:22.979]                     }
[10:21:22.979]                     else if (inherits(cond, "condition")) {
[10:21:22.979]                       if (!is.null(pattern)) {
[10:21:22.979]                         computeRestarts <- base::computeRestarts
[10:21:22.979]                         grepl <- base::grepl
[10:21:22.979]                         restarts <- computeRestarts(cond)
[10:21:22.979]                         for (restart in restarts) {
[10:21:22.979]                           name <- restart$name
[10:21:22.979]                           if (is.null(name)) 
[10:21:22.979]                             next
[10:21:22.979]                           if (!grepl(pattern, name)) 
[10:21:22.979]                             next
[10:21:22.979]                           invokeRestart(restart)
[10:21:22.979]                           muffled <- TRUE
[10:21:22.979]                           break
[10:21:22.979]                         }
[10:21:22.979]                       }
[10:21:22.979]                     }
[10:21:22.979]                     invisible(muffled)
[10:21:22.979]                   }
[10:21:22.979]                   muffleCondition(cond)
[10:21:22.979]                 })
[10:21:22.979]             }))
[10:21:22.979]             future::FutureResult(value = ...future.value$value, 
[10:21:22.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.979]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.979]                     ...future.globalenv.names))
[10:21:22.979]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.979]         }, condition = base::local({
[10:21:22.979]             c <- base::c
[10:21:22.979]             inherits <- base::inherits
[10:21:22.979]             invokeRestart <- base::invokeRestart
[10:21:22.979]             length <- base::length
[10:21:22.979]             list <- base::list
[10:21:22.979]             seq.int <- base::seq.int
[10:21:22.979]             signalCondition <- base::signalCondition
[10:21:22.979]             sys.calls <- base::sys.calls
[10:21:22.979]             `[[` <- base::`[[`
[10:21:22.979]             `+` <- base::`+`
[10:21:22.979]             `<<-` <- base::`<<-`
[10:21:22.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.979]                   3L)]
[10:21:22.979]             }
[10:21:22.979]             function(cond) {
[10:21:22.979]                 is_error <- inherits(cond, "error")
[10:21:22.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.979]                   NULL)
[10:21:22.979]                 if (is_error) {
[10:21:22.979]                   sessionInformation <- function() {
[10:21:22.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.979]                       search = base::search(), system = base::Sys.info())
[10:21:22.979]                   }
[10:21:22.979]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.979]                     cond$call), session = sessionInformation(), 
[10:21:22.979]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.979]                   signalCondition(cond)
[10:21:22.979]                 }
[10:21:22.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.979]                 "immediateCondition"))) {
[10:21:22.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.979]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.979]                   if (TRUE && !signal) {
[10:21:22.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.979]                     {
[10:21:22.979]                       inherits <- base::inherits
[10:21:22.979]                       invokeRestart <- base::invokeRestart
[10:21:22.979]                       is.null <- base::is.null
[10:21:22.979]                       muffled <- FALSE
[10:21:22.979]                       if (inherits(cond, "message")) {
[10:21:22.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.979]                         if (muffled) 
[10:21:22.979]                           invokeRestart("muffleMessage")
[10:21:22.979]                       }
[10:21:22.979]                       else if (inherits(cond, "warning")) {
[10:21:22.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.979]                         if (muffled) 
[10:21:22.979]                           invokeRestart("muffleWarning")
[10:21:22.979]                       }
[10:21:22.979]                       else if (inherits(cond, "condition")) {
[10:21:22.979]                         if (!is.null(pattern)) {
[10:21:22.979]                           computeRestarts <- base::computeRestarts
[10:21:22.979]                           grepl <- base::grepl
[10:21:22.979]                           restarts <- computeRestarts(cond)
[10:21:22.979]                           for (restart in restarts) {
[10:21:22.979]                             name <- restart$name
[10:21:22.979]                             if (is.null(name)) 
[10:21:22.979]                               next
[10:21:22.979]                             if (!grepl(pattern, name)) 
[10:21:22.979]                               next
[10:21:22.979]                             invokeRestart(restart)
[10:21:22.979]                             muffled <- TRUE
[10:21:22.979]                             break
[10:21:22.979]                           }
[10:21:22.979]                         }
[10:21:22.979]                       }
[10:21:22.979]                       invisible(muffled)
[10:21:22.979]                     }
[10:21:22.979]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.979]                   }
[10:21:22.979]                 }
[10:21:22.979]                 else {
[10:21:22.979]                   if (TRUE) {
[10:21:22.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.979]                     {
[10:21:22.979]                       inherits <- base::inherits
[10:21:22.979]                       invokeRestart <- base::invokeRestart
[10:21:22.979]                       is.null <- base::is.null
[10:21:22.979]                       muffled <- FALSE
[10:21:22.979]                       if (inherits(cond, "message")) {
[10:21:22.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.979]                         if (muffled) 
[10:21:22.979]                           invokeRestart("muffleMessage")
[10:21:22.979]                       }
[10:21:22.979]                       else if (inherits(cond, "warning")) {
[10:21:22.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.979]                         if (muffled) 
[10:21:22.979]                           invokeRestart("muffleWarning")
[10:21:22.979]                       }
[10:21:22.979]                       else if (inherits(cond, "condition")) {
[10:21:22.979]                         if (!is.null(pattern)) {
[10:21:22.979]                           computeRestarts <- base::computeRestarts
[10:21:22.979]                           grepl <- base::grepl
[10:21:22.979]                           restarts <- computeRestarts(cond)
[10:21:22.979]                           for (restart in restarts) {
[10:21:22.979]                             name <- restart$name
[10:21:22.979]                             if (is.null(name)) 
[10:21:22.979]                               next
[10:21:22.979]                             if (!grepl(pattern, name)) 
[10:21:22.979]                               next
[10:21:22.979]                             invokeRestart(restart)
[10:21:22.979]                             muffled <- TRUE
[10:21:22.979]                             break
[10:21:22.979]                           }
[10:21:22.979]                         }
[10:21:22.979]                       }
[10:21:22.979]                       invisible(muffled)
[10:21:22.979]                     }
[10:21:22.979]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.979]                   }
[10:21:22.979]                 }
[10:21:22.979]             }
[10:21:22.979]         }))
[10:21:22.979]     }, error = function(ex) {
[10:21:22.979]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.979]                 ...future.rng), started = ...future.startTime, 
[10:21:22.979]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.979]             version = "1.8"), class = "FutureResult")
[10:21:22.979]     }, finally = {
[10:21:22.979]         if (!identical(...future.workdir, getwd())) 
[10:21:22.979]             setwd(...future.workdir)
[10:21:22.979]         {
[10:21:22.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.979]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.979]             }
[10:21:22.979]             base::options(...future.oldOptions)
[10:21:22.979]             if (.Platform$OS.type == "windows") {
[10:21:22.979]                 old_names <- names(...future.oldEnvVars)
[10:21:22.979]                 envs <- base::Sys.getenv()
[10:21:22.979]                 names <- names(envs)
[10:21:22.979]                 common <- intersect(names, old_names)
[10:21:22.979]                 added <- setdiff(names, old_names)
[10:21:22.979]                 removed <- setdiff(old_names, names)
[10:21:22.979]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.979]                   envs[common]]
[10:21:22.979]                 NAMES <- toupper(changed)
[10:21:22.979]                 args <- list()
[10:21:22.979]                 for (kk in seq_along(NAMES)) {
[10:21:22.979]                   name <- changed[[kk]]
[10:21:22.979]                   NAME <- NAMES[[kk]]
[10:21:22.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.979]                     next
[10:21:22.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.979]                 }
[10:21:22.979]                 NAMES <- toupper(added)
[10:21:22.979]                 for (kk in seq_along(NAMES)) {
[10:21:22.979]                   name <- added[[kk]]
[10:21:22.979]                   NAME <- NAMES[[kk]]
[10:21:22.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.979]                     next
[10:21:22.979]                   args[[name]] <- ""
[10:21:22.979]                 }
[10:21:22.979]                 NAMES <- toupper(removed)
[10:21:22.979]                 for (kk in seq_along(NAMES)) {
[10:21:22.979]                   name <- removed[[kk]]
[10:21:22.979]                   NAME <- NAMES[[kk]]
[10:21:22.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.979]                     next
[10:21:22.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.979]                 }
[10:21:22.979]                 if (length(args) > 0) 
[10:21:22.979]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.979]             }
[10:21:22.979]             else {
[10:21:22.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.979]             }
[10:21:22.979]             {
[10:21:22.979]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.979]                   0L) {
[10:21:22.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.979]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.979]                   base::options(opts)
[10:21:22.979]                 }
[10:21:22.979]                 {
[10:21:22.979]                   {
[10:21:22.979]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.979]                     NULL
[10:21:22.979]                   }
[10:21:22.979]                   options(future.plan = NULL)
[10:21:22.979]                   if (is.na(NA_character_)) 
[10:21:22.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.979]                     .init = FALSE)
[10:21:22.979]                 }
[10:21:22.979]             }
[10:21:22.979]         }
[10:21:22.979]     })
[10:21:22.979]     if (TRUE) {
[10:21:22.979]         base::sink(type = "output", split = FALSE)
[10:21:22.979]         if (TRUE) {
[10:21:22.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.979]         }
[10:21:22.979]         else {
[10:21:22.979]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.979]         }
[10:21:22.979]         base::close(...future.stdout)
[10:21:22.979]         ...future.stdout <- NULL
[10:21:22.979]     }
[10:21:22.979]     ...future.result$conditions <- ...future.conditions
[10:21:22.979]     ...future.result$finished <- base::Sys.time()
[10:21:22.979]     ...future.result
[10:21:22.979] }
[10:21:22.982] requestCore(): workers = 2
[10:21:22.985] MulticoreFuture started
[10:21:22.985] - Launch lazy future ... done
[10:21:22.985] run() for ‘MulticoreFuture’ ... done
[10:21:22.986] plan(): Setting new future strategy stack:
[10:21:22.986] getGlobalsAndPackages() ...
[10:21:22.986] Searching for globals...
[10:21:22.986] List of future strategies:
[10:21:22.986] 1. sequential:
[10:21:22.986]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:22.986]    - tweaked: FALSE
[10:21:22.986]    - call: NULL
[10:21:22.987] plan(): nbrOfWorkers() = 1
[10:21:22.988] - globals found: [1] ‘{’
[10:21:22.988] Searching for globals ... DONE
[10:21:22.988] Resolving globals: FALSE
[10:21:22.989] 
[10:21:22.989] 
[10:21:22.989] getGlobalsAndPackages() ... DONE
[10:21:22.989] plan(): Setting new future strategy stack:
[10:21:22.989] run() for ‘Future’ ...
[10:21:22.990] - state: ‘created’
[10:21:22.990] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:22.989] List of future strategies:
[10:21:22.989] 1. multicore:
[10:21:22.989]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:22.989]    - tweaked: FALSE
[10:21:22.989]    - call: plan(strategy)
[10:21:22.992] plan(): nbrOfWorkers() = 2
[10:21:22.993] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:22.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:22.993]   - Field: ‘label’
[10:21:22.993]   - Field: ‘local’
[10:21:22.993]   - Field: ‘owner’
[10:21:22.993]   - Field: ‘envir’
[10:21:22.994]   - Field: ‘workers’
[10:21:22.994]   - Field: ‘packages’
[10:21:22.994]   - Field: ‘gc’
[10:21:22.994]   - Field: ‘job’
[10:21:22.994]   - Field: ‘conditions’
[10:21:22.994]   - Field: ‘expr’
[10:21:22.994]   - Field: ‘uuid’
[10:21:22.994]   - Field: ‘seed’
[10:21:22.995]   - Field: ‘version’
[10:21:22.995]   - Field: ‘result’
[10:21:22.995]   - Field: ‘asynchronous’
[10:21:22.995]   - Field: ‘calls’
[10:21:22.995]   - Field: ‘globals’
[10:21:22.995]   - Field: ‘stdout’
[10:21:22.995]   - Field: ‘earlySignal’
[10:21:22.995]   - Field: ‘lazy’
[10:21:22.996]   - Field: ‘state’
[10:21:22.996] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:22.996] - Launch lazy future ...
[10:21:22.996] Packages needed by the future expression (n = 0): <none>
[10:21:22.996] Packages needed by future strategies (n = 0): <none>
[10:21:22.997] {
[10:21:22.997]     {
[10:21:22.997]         {
[10:21:22.997]             ...future.startTime <- base::Sys.time()
[10:21:22.997]             {
[10:21:22.997]                 {
[10:21:22.997]                   {
[10:21:22.997]                     {
[10:21:22.997]                       base::local({
[10:21:22.997]                         has_future <- base::requireNamespace("future", 
[10:21:22.997]                           quietly = TRUE)
[10:21:22.997]                         if (has_future) {
[10:21:22.997]                           ns <- base::getNamespace("future")
[10:21:22.997]                           version <- ns[[".package"]][["version"]]
[10:21:22.997]                           if (is.null(version)) 
[10:21:22.997]                             version <- utils::packageVersion("future")
[10:21:22.997]                         }
[10:21:22.997]                         else {
[10:21:22.997]                           version <- NULL
[10:21:22.997]                         }
[10:21:22.997]                         if (!has_future || version < "1.8.0") {
[10:21:22.997]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:22.997]                             "", base::R.version$version.string), 
[10:21:22.997]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:22.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:22.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:22.997]                               "release", "version")], collapse = " "), 
[10:21:22.997]                             hostname = base::Sys.info()[["nodename"]])
[10:21:22.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:22.997]                             info)
[10:21:22.997]                           info <- base::paste(info, collapse = "; ")
[10:21:22.997]                           if (!has_future) {
[10:21:22.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:22.997]                               info)
[10:21:22.997]                           }
[10:21:22.997]                           else {
[10:21:22.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:22.997]                               info, version)
[10:21:22.997]                           }
[10:21:22.997]                           base::stop(msg)
[10:21:22.997]                         }
[10:21:22.997]                       })
[10:21:22.997]                     }
[10:21:22.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:22.997]                     base::options(mc.cores = 1L)
[10:21:22.997]                   }
[10:21:22.997]                   ...future.strategy.old <- future::plan("list")
[10:21:22.997]                   options(future.plan = NULL)
[10:21:22.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:22.997]                 }
[10:21:22.997]                 ...future.workdir <- getwd()
[10:21:22.997]             }
[10:21:22.997]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:22.997]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:22.997]         }
[10:21:22.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:22.997]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:22.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:22.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:22.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:22.997]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:22.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:22.997]             base::names(...future.oldOptions))
[10:21:22.997]     }
[10:21:22.997]     if (FALSE) {
[10:21:22.997]     }
[10:21:22.997]     else {
[10:21:22.997]         if (TRUE) {
[10:21:22.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:22.997]                 open = "w")
[10:21:22.997]         }
[10:21:22.997]         else {
[10:21:22.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:22.997]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:22.997]         }
[10:21:22.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:22.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:22.997]             base::sink(type = "output", split = FALSE)
[10:21:22.997]             base::close(...future.stdout)
[10:21:22.997]         }, add = TRUE)
[10:21:22.997]     }
[10:21:22.997]     ...future.frame <- base::sys.nframe()
[10:21:22.997]     ...future.conditions <- base::list()
[10:21:22.997]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:22.997]     if (FALSE) {
[10:21:22.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:22.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:22.997]     }
[10:21:22.997]     ...future.result <- base::tryCatch({
[10:21:22.997]         base::withCallingHandlers({
[10:21:22.997]             ...future.value <- base::withVisible(base::local({
[10:21:22.997]                 withCallingHandlers({
[10:21:22.997]                   {
[10:21:22.997]                     4
[10:21:22.997]                   }
[10:21:22.997]                 }, immediateCondition = function(cond) {
[10:21:22.997]                   save_rds <- function (object, pathname, ...) 
[10:21:22.997]                   {
[10:21:22.997]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:22.997]                     if (file_test("-f", pathname_tmp)) {
[10:21:22.997]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.997]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:22.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.997]                         fi_tmp[["mtime"]])
[10:21:22.997]                     }
[10:21:22.997]                     tryCatch({
[10:21:22.997]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:22.997]                     }, error = function(ex) {
[10:21:22.997]                       msg <- conditionMessage(ex)
[10:21:22.997]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.997]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:22.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.997]                         fi_tmp[["mtime"]], msg)
[10:21:22.997]                       ex$message <- msg
[10:21:22.997]                       stop(ex)
[10:21:22.997]                     })
[10:21:22.997]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:22.997]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:22.997]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:22.997]                       fi_tmp <- file.info(pathname_tmp)
[10:21:22.997]                       fi <- file.info(pathname)
[10:21:22.997]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:22.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:22.997]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:22.997]                         fi[["size"]], fi[["mtime"]])
[10:21:22.997]                       stop(msg)
[10:21:22.997]                     }
[10:21:22.997]                     invisible(pathname)
[10:21:22.997]                   }
[10:21:22.997]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:22.997]                     rootPath = tempdir()) 
[10:21:22.997]                   {
[10:21:22.997]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:22.997]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:22.997]                       tmpdir = path, fileext = ".rds")
[10:21:22.997]                     save_rds(obj, file)
[10:21:22.997]                   }
[10:21:22.997]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:22.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.997]                   {
[10:21:22.997]                     inherits <- base::inherits
[10:21:22.997]                     invokeRestart <- base::invokeRestart
[10:21:22.997]                     is.null <- base::is.null
[10:21:22.997]                     muffled <- FALSE
[10:21:22.997]                     if (inherits(cond, "message")) {
[10:21:22.997]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:22.997]                       if (muffled) 
[10:21:22.997]                         invokeRestart("muffleMessage")
[10:21:22.997]                     }
[10:21:22.997]                     else if (inherits(cond, "warning")) {
[10:21:22.997]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:22.997]                       if (muffled) 
[10:21:22.997]                         invokeRestart("muffleWarning")
[10:21:22.997]                     }
[10:21:22.997]                     else if (inherits(cond, "condition")) {
[10:21:22.997]                       if (!is.null(pattern)) {
[10:21:22.997]                         computeRestarts <- base::computeRestarts
[10:21:22.997]                         grepl <- base::grepl
[10:21:22.997]                         restarts <- computeRestarts(cond)
[10:21:22.997]                         for (restart in restarts) {
[10:21:22.997]                           name <- restart$name
[10:21:22.997]                           if (is.null(name)) 
[10:21:22.997]                             next
[10:21:22.997]                           if (!grepl(pattern, name)) 
[10:21:22.997]                             next
[10:21:22.997]                           invokeRestart(restart)
[10:21:22.997]                           muffled <- TRUE
[10:21:22.997]                           break
[10:21:22.997]                         }
[10:21:22.997]                       }
[10:21:22.997]                     }
[10:21:22.997]                     invisible(muffled)
[10:21:22.997]                   }
[10:21:22.997]                   muffleCondition(cond)
[10:21:22.997]                 })
[10:21:22.997]             }))
[10:21:22.997]             future::FutureResult(value = ...future.value$value, 
[10:21:22.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.997]                   ...future.rng), globalenv = if (FALSE) 
[10:21:22.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:22.997]                     ...future.globalenv.names))
[10:21:22.997]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:22.997]         }, condition = base::local({
[10:21:22.997]             c <- base::c
[10:21:22.997]             inherits <- base::inherits
[10:21:22.997]             invokeRestart <- base::invokeRestart
[10:21:22.997]             length <- base::length
[10:21:22.997]             list <- base::list
[10:21:22.997]             seq.int <- base::seq.int
[10:21:22.997]             signalCondition <- base::signalCondition
[10:21:22.997]             sys.calls <- base::sys.calls
[10:21:22.997]             `[[` <- base::`[[`
[10:21:22.997]             `+` <- base::`+`
[10:21:22.997]             `<<-` <- base::`<<-`
[10:21:22.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:22.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:22.997]                   3L)]
[10:21:22.997]             }
[10:21:22.997]             function(cond) {
[10:21:22.997]                 is_error <- inherits(cond, "error")
[10:21:22.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:22.997]                   NULL)
[10:21:22.997]                 if (is_error) {
[10:21:22.997]                   sessionInformation <- function() {
[10:21:22.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:22.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:22.997]                       search = base::search(), system = base::Sys.info())
[10:21:22.997]                   }
[10:21:22.997]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:22.997]                     cond$call), session = sessionInformation(), 
[10:21:22.997]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:22.997]                   signalCondition(cond)
[10:21:22.997]                 }
[10:21:22.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:22.997]                 "immediateCondition"))) {
[10:21:22.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:22.997]                   ...future.conditions[[length(...future.conditions) + 
[10:21:22.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:22.997]                   if (TRUE && !signal) {
[10:21:22.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.997]                     {
[10:21:22.997]                       inherits <- base::inherits
[10:21:22.997]                       invokeRestart <- base::invokeRestart
[10:21:22.997]                       is.null <- base::is.null
[10:21:22.997]                       muffled <- FALSE
[10:21:22.997]                       if (inherits(cond, "message")) {
[10:21:22.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.997]                         if (muffled) 
[10:21:22.997]                           invokeRestart("muffleMessage")
[10:21:22.997]                       }
[10:21:22.997]                       else if (inherits(cond, "warning")) {
[10:21:22.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.997]                         if (muffled) 
[10:21:22.997]                           invokeRestart("muffleWarning")
[10:21:22.997]                       }
[10:21:22.997]                       else if (inherits(cond, "condition")) {
[10:21:22.997]                         if (!is.null(pattern)) {
[10:21:22.997]                           computeRestarts <- base::computeRestarts
[10:21:22.997]                           grepl <- base::grepl
[10:21:22.997]                           restarts <- computeRestarts(cond)
[10:21:22.997]                           for (restart in restarts) {
[10:21:22.997]                             name <- restart$name
[10:21:22.997]                             if (is.null(name)) 
[10:21:22.997]                               next
[10:21:22.997]                             if (!grepl(pattern, name)) 
[10:21:22.997]                               next
[10:21:22.997]                             invokeRestart(restart)
[10:21:22.997]                             muffled <- TRUE
[10:21:22.997]                             break
[10:21:22.997]                           }
[10:21:22.997]                         }
[10:21:22.997]                       }
[10:21:22.997]                       invisible(muffled)
[10:21:22.997]                     }
[10:21:22.997]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.997]                   }
[10:21:22.997]                 }
[10:21:22.997]                 else {
[10:21:22.997]                   if (TRUE) {
[10:21:22.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:22.997]                     {
[10:21:22.997]                       inherits <- base::inherits
[10:21:22.997]                       invokeRestart <- base::invokeRestart
[10:21:22.997]                       is.null <- base::is.null
[10:21:22.997]                       muffled <- FALSE
[10:21:22.997]                       if (inherits(cond, "message")) {
[10:21:22.997]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:22.997]                         if (muffled) 
[10:21:22.997]                           invokeRestart("muffleMessage")
[10:21:22.997]                       }
[10:21:22.997]                       else if (inherits(cond, "warning")) {
[10:21:22.997]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:22.997]                         if (muffled) 
[10:21:22.997]                           invokeRestart("muffleWarning")
[10:21:22.997]                       }
[10:21:22.997]                       else if (inherits(cond, "condition")) {
[10:21:22.997]                         if (!is.null(pattern)) {
[10:21:22.997]                           computeRestarts <- base::computeRestarts
[10:21:22.997]                           grepl <- base::grepl
[10:21:22.997]                           restarts <- computeRestarts(cond)
[10:21:22.997]                           for (restart in restarts) {
[10:21:22.997]                             name <- restart$name
[10:21:22.997]                             if (is.null(name)) 
[10:21:22.997]                               next
[10:21:22.997]                             if (!grepl(pattern, name)) 
[10:21:22.997]                               next
[10:21:22.997]                             invokeRestart(restart)
[10:21:22.997]                             muffled <- TRUE
[10:21:22.997]                             break
[10:21:22.997]                           }
[10:21:22.997]                         }
[10:21:22.997]                       }
[10:21:22.997]                       invisible(muffled)
[10:21:22.997]                     }
[10:21:22.997]                     muffleCondition(cond, pattern = "^muffle")
[10:21:22.997]                   }
[10:21:22.997]                 }
[10:21:22.997]             }
[10:21:22.997]         }))
[10:21:22.997]     }, error = function(ex) {
[10:21:22.997]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:22.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:22.997]                 ...future.rng), started = ...future.startTime, 
[10:21:22.997]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:22.997]             version = "1.8"), class = "FutureResult")
[10:21:22.997]     }, finally = {
[10:21:22.997]         if (!identical(...future.workdir, getwd())) 
[10:21:22.997]             setwd(...future.workdir)
[10:21:22.997]         {
[10:21:22.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:22.997]                 ...future.oldOptions$nwarnings <- NULL
[10:21:22.997]             }
[10:21:22.997]             base::options(...future.oldOptions)
[10:21:22.997]             if (.Platform$OS.type == "windows") {
[10:21:22.997]                 old_names <- names(...future.oldEnvVars)
[10:21:22.997]                 envs <- base::Sys.getenv()
[10:21:22.997]                 names <- names(envs)
[10:21:22.997]                 common <- intersect(names, old_names)
[10:21:22.997]                 added <- setdiff(names, old_names)
[10:21:22.997]                 removed <- setdiff(old_names, names)
[10:21:22.997]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:22.997]                   envs[common]]
[10:21:22.997]                 NAMES <- toupper(changed)
[10:21:22.997]                 args <- list()
[10:21:22.997]                 for (kk in seq_along(NAMES)) {
[10:21:22.997]                   name <- changed[[kk]]
[10:21:22.997]                   NAME <- NAMES[[kk]]
[10:21:22.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.997]                     next
[10:21:22.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.997]                 }
[10:21:22.997]                 NAMES <- toupper(added)
[10:21:22.997]                 for (kk in seq_along(NAMES)) {
[10:21:22.997]                   name <- added[[kk]]
[10:21:22.997]                   NAME <- NAMES[[kk]]
[10:21:22.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.997]                     next
[10:21:22.997]                   args[[name]] <- ""
[10:21:22.997]                 }
[10:21:22.997]                 NAMES <- toupper(removed)
[10:21:22.997]                 for (kk in seq_along(NAMES)) {
[10:21:22.997]                   name <- removed[[kk]]
[10:21:22.997]                   NAME <- NAMES[[kk]]
[10:21:22.997]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:22.997]                     next
[10:21:22.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:22.997]                 }
[10:21:22.997]                 if (length(args) > 0) 
[10:21:22.997]                   base::do.call(base::Sys.setenv, args = args)
[10:21:22.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:22.997]             }
[10:21:22.997]             else {
[10:21:22.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:22.997]             }
[10:21:22.997]             {
[10:21:22.997]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:22.997]                   0L) {
[10:21:22.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:22.997]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:22.997]                   base::options(opts)
[10:21:22.997]                 }
[10:21:22.997]                 {
[10:21:22.997]                   {
[10:21:22.997]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:22.997]                     NULL
[10:21:22.997]                   }
[10:21:22.997]                   options(future.plan = NULL)
[10:21:22.997]                   if (is.na(NA_character_)) 
[10:21:22.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:22.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:22.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:22.997]                     .init = FALSE)
[10:21:22.997]                 }
[10:21:22.997]             }
[10:21:22.997]         }
[10:21:22.997]     })
[10:21:22.997]     if (TRUE) {
[10:21:22.997]         base::sink(type = "output", split = FALSE)
[10:21:22.997]         if (TRUE) {
[10:21:22.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:22.997]         }
[10:21:22.997]         else {
[10:21:22.997]             ...future.result["stdout"] <- base::list(NULL)
[10:21:22.997]         }
[10:21:22.997]         base::close(...future.stdout)
[10:21:22.997]         ...future.stdout <- NULL
[10:21:22.997]     }
[10:21:22.997]     ...future.result$conditions <- ...future.conditions
[10:21:22.997]     ...future.result$finished <- base::Sys.time()
[10:21:22.997]     ...future.result
[10:21:22.997] }
[10:21:23.001] requestCore(): workers = 2
[10:21:23.001] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:23.012] result() for MulticoreFuture ...
[10:21:23.013] result() for MulticoreFuture ...
[10:21:23.013] result() for MulticoreFuture ... done
[10:21:23.013] result() for MulticoreFuture ... done
[10:21:23.013] result() for MulticoreFuture ...
[10:21:23.013] result() for MulticoreFuture ... done
[10:21:23.016] MulticoreFuture started
[10:21:23.017] - Launch lazy future ... done
[10:21:23.017] run() for ‘MulticoreFuture’ ... done
[10:21:23.017] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55e8e478f588> 
[10:21:23.018] List of future strategies:
[10:21:23.018] 1. sequential:
[10:21:23.018]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.018]    - tweaked: FALSE
[10:21:23.018]    - call: NULL
[10:21:23.019] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55e8e67d7f18> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=[10:21:23.022] plan(): Setting new future strategy stack:
List of 2
  ..$ :[10:21:23.023] List of future strategies:
[10:21:23.023] 1. multicore:
[10:21:23.023]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.023]    - tweaked: FALSE
[10:21:23.023]    - call: plan(strategy)
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:21:23.027] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:23.031] resolve() on list environment ...
[10:21:23.031]  recursive: 0
[10:21:23.032]  length: 6
[10:21:23.033]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:23.033] signalConditionsASAP(numeric, pos=1) ...
[10:21:23.033] - nx: 6
[10:21:23.033] - relay: TRUE
[10:21:23.033] - stdout: TRUE
[10:21:23.033] - signal: TRUE
[10:21:23.033] - resignal: FALSE
[10:21:23.034] - force: TRUE
[10:21:23.034] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.034] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.034]  - until=2
[10:21:23.034]  - relaying element #2
[10:21:23.034] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.034] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.034] signalConditionsASAP(NULL, pos=1) ... done
[10:21:23.035]  length: 5 (resolved future 1)
[10:21:23.035] Future #2
[10:21:23.035] result() for MulticoreFuture ...
[10:21:23.035] result() for MulticoreFuture ... done
[10:21:23.035] result() for MulticoreFuture ...
[10:21:23.035] result() for MulticoreFuture ... done
[10:21:23.035] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:23.036] - nx: 6
[10:21:23.036] - relay: TRUE
[10:21:23.036] - stdout: TRUE
[10:21:23.036] - signal: TRUE
[10:21:23.036] - resignal: FALSE
[10:21:23.036] - force: TRUE
[10:21:23.036] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.036] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.036]  - until=2
[10:21:23.037]  - relaying element #2
[10:21:23.037] result() for MulticoreFuture ...
[10:21:23.037] result() for MulticoreFuture ... done
[10:21:23.037] result() for MulticoreFuture ...
[10:21:23.037] result() for MulticoreFuture ... done
[10:21:23.037] result() for MulticoreFuture ...
[10:21:23.037] result() for MulticoreFuture ... done
[10:21:23.037] result() for MulticoreFuture ...
[10:21:23.038] result() for MulticoreFuture ... done
[10:21:23.038] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.038] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.038] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:23.038]  length: 4 (resolved future 2)
[10:21:23.038] Future #3
[10:21:23.039] result() for MulticoreFuture ...
[10:21:23.039] result() for MulticoreFuture ...
[10:21:23.040] result() for MulticoreFuture ... done
[10:21:23.040] result() for MulticoreFuture ... done
[10:21:23.040] result() for MulticoreFuture ...
[10:21:23.040] result() for MulticoreFuture ... done
[10:21:23.040] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:23.040] - nx: 6
[10:21:23.040] - relay: TRUE
[10:21:23.040] - stdout: TRUE
[10:21:23.041] - signal: TRUE
[10:21:23.041] - resignal: FALSE
[10:21:23.041] - force: TRUE
[10:21:23.041] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.041] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.041]  - until=3
[10:21:23.041]  - relaying element #3
[10:21:23.041] result() for MulticoreFuture ...
[10:21:23.041] result() for MulticoreFuture ... done
[10:21:23.042] result() for MulticoreFuture ...
[10:21:23.042] result() for MulticoreFuture ... done
[10:21:23.042] result() for MulticoreFuture ...
[10:21:23.042] result() for MulticoreFuture ... done
[10:21:23.042] result() for MulticoreFuture ...
[10:21:23.042] result() for MulticoreFuture ... done
[10:21:23.043] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.043] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.043] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:23.043]  length: 3 (resolved future 3)
[10:21:23.043] Future #4
[10:21:23.043] result() for MulticoreFuture ...
[10:21:23.044] result() for MulticoreFuture ...
[10:21:23.044] result() for MulticoreFuture ... done
[10:21:23.044] result() for MulticoreFuture ... done
[10:21:23.045] result() for MulticoreFuture ...
[10:21:23.045] result() for MulticoreFuture ... done
[10:21:23.045] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:23.045] - nx: 6
[10:21:23.045] - relay: TRUE
[10:21:23.045] - stdout: TRUE
[10:21:23.046] - signal: TRUE
[10:21:23.046] - resignal: FALSE
[10:21:23.046] - force: TRUE
[10:21:23.046] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.046] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.046]  - until=4
[10:21:23.047]  - relaying element #4
[10:21:23.047] result() for MulticoreFuture ...
[10:21:23.047] result() for MulticoreFuture ... done
[10:21:23.047] result() for MulticoreFuture ...
[10:21:23.047] result() for MulticoreFuture ... done
[10:21:23.047] result() for MulticoreFuture ...
[10:21:23.048] result() for MulticoreFuture ... done
[10:21:23.048] result() for MulticoreFuture ...
[10:21:23.048] result() for MulticoreFuture ... done
[10:21:23.048] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.048] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.048] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:23.049]  length: 2 (resolved future 4)
[10:21:23.049] signalConditionsASAP(NULL, pos=5) ...
[10:21:23.049] - nx: 6
[10:21:23.049] - relay: TRUE
[10:21:23.049] - stdout: TRUE
[10:21:23.049] - signal: TRUE
[10:21:23.049] - resignal: FALSE
[10:21:23.049] - force: TRUE
[10:21:23.049] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.049] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.050]  - until=6
[10:21:23.050]  - relaying element #6
[10:21:23.050] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:23.050] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.050] signalConditionsASAP(NULL, pos=5) ... done
[10:21:23.050]  length: 1 (resolved future 5)
[10:21:23.050] signalConditionsASAP(numeric, pos=6) ...
[10:21:23.050] - nx: 6
[10:21:23.050] - relay: TRUE
[10:21:23.050] - stdout: TRUE
[10:21:23.051] - signal: TRUE
[10:21:23.051] - resignal: FALSE
[10:21:23.051] - force: TRUE
[10:21:23.051] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:23.051] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.051]  - until=6
[10:21:23.051] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.051] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.051] signalConditionsASAP(numeric, pos=6) ... done
[10:21:23.051]  length: 0 (resolved future 6)
[10:21:23.052] Relaying remaining futures
[10:21:23.052] signalConditionsASAP(NULL, pos=0) ...
[10:21:23.052] - nx: 6
[10:21:23.052] - relay: TRUE
[10:21:23.052] - stdout: TRUE
[10:21:23.052] - signal: TRUE
[10:21:23.052] - resignal: FALSE
[10:21:23.052] - force: TRUE
[10:21:23.052] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.052] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:23.053] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.053] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.053] signalConditionsASAP(NULL, pos=0) ... done
[10:21:23.053] resolve() on list environment ... DONE
[10:21:23.053] result() for MulticoreFuture ...
[10:21:23.053] result() for MulticoreFuture ... done
[10:21:23.053] result() for MulticoreFuture ...
[10:21:23.053] result() for MulticoreFuture ... done
[10:21:23.053] result() for MulticoreFuture ...
[10:21:23.054] result() for MulticoreFuture ... done
[10:21:23.054] result() for MulticoreFuture ...
[10:21:23.054] result() for MulticoreFuture ... done
[10:21:23.054] result() for MulticoreFuture ...
[10:21:23.054] result() for MulticoreFuture ... done
[10:21:23.054] result() for MulticoreFuture ...
[10:21:23.054] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e6a19438> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:21:23.056] getGlobalsAndPackages() ...
[10:21:23.056] Searching for globals...
[10:21:23.057] 
[10:21:23.057] Searching for globals ... DONE
[10:21:23.057] - globals: [0] <none>
[10:21:23.057] getGlobalsAndPackages() ... DONE
[10:21:23.058] run() for ‘Future’ ...
[10:21:23.058] - state: ‘created’
[10:21:23.058] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.060] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.060] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:23.060]   - Field: ‘label’
[10:21:23.061]   - Field: ‘local’
[10:21:23.061]   - Field: ‘owner’
[10:21:23.061]   - Field: ‘envir’
[10:21:23.061]   - Field: ‘workers’
[10:21:23.061]   - Field: ‘packages’
[10:21:23.061]   - Field: ‘gc’
[10:21:23.061]   - Field: ‘job’
[10:21:23.061]   - Field: ‘conditions’
[10:21:23.061]   - Field: ‘expr’
[10:21:23.062]   - Field: ‘uuid’
[10:21:23.062]   - Field: ‘seed’
[10:21:23.062]   - Field: ‘version’
[10:21:23.062]   - Field: ‘result’
[10:21:23.062]   - Field: ‘asynchronous’
[10:21:23.062]   - Field: ‘calls’
[10:21:23.062]   - Field: ‘globals’
[10:21:23.062]   - Field: ‘stdout’
[10:21:23.062]   - Field: ‘earlySignal’
[10:21:23.063]   - Field: ‘lazy’
[10:21:23.066]   - Field: ‘state’
[10:21:23.067] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:23.067] - Launch lazy future ...
[10:21:23.067] Packages needed by the future expression (n = 0): <none>
[10:21:23.068] Packages needed by future strategies (n = 0): <none>
[10:21:23.068] {
[10:21:23.068]     {
[10:21:23.068]         {
[10:21:23.068]             ...future.startTime <- base::Sys.time()
[10:21:23.068]             {
[10:21:23.068]                 {
[10:21:23.068]                   {
[10:21:23.068]                     {
[10:21:23.068]                       base::local({
[10:21:23.068]                         has_future <- base::requireNamespace("future", 
[10:21:23.068]                           quietly = TRUE)
[10:21:23.068]                         if (has_future) {
[10:21:23.068]                           ns <- base::getNamespace("future")
[10:21:23.068]                           version <- ns[[".package"]][["version"]]
[10:21:23.068]                           if (is.null(version)) 
[10:21:23.068]                             version <- utils::packageVersion("future")
[10:21:23.068]                         }
[10:21:23.068]                         else {
[10:21:23.068]                           version <- NULL
[10:21:23.068]                         }
[10:21:23.068]                         if (!has_future || version < "1.8.0") {
[10:21:23.068]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.068]                             "", base::R.version$version.string), 
[10:21:23.068]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.068]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.068]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.068]                               "release", "version")], collapse = " "), 
[10:21:23.068]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.068]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.068]                             info)
[10:21:23.068]                           info <- base::paste(info, collapse = "; ")
[10:21:23.068]                           if (!has_future) {
[10:21:23.068]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.068]                               info)
[10:21:23.068]                           }
[10:21:23.068]                           else {
[10:21:23.068]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.068]                               info, version)
[10:21:23.068]                           }
[10:21:23.068]                           base::stop(msg)
[10:21:23.068]                         }
[10:21:23.068]                       })
[10:21:23.068]                     }
[10:21:23.068]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.068]                     base::options(mc.cores = 1L)
[10:21:23.068]                   }
[10:21:23.068]                   ...future.strategy.old <- future::plan("list")
[10:21:23.068]                   options(future.plan = NULL)
[10:21:23.068]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.068]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.068]                 }
[10:21:23.068]                 ...future.workdir <- getwd()
[10:21:23.068]             }
[10:21:23.068]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.068]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.068]         }
[10:21:23.068]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.068]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.068]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.068]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.068]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.068]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.068]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.068]             base::names(...future.oldOptions))
[10:21:23.068]     }
[10:21:23.068]     if (FALSE) {
[10:21:23.068]     }
[10:21:23.068]     else {
[10:21:23.068]         if (TRUE) {
[10:21:23.068]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.068]                 open = "w")
[10:21:23.068]         }
[10:21:23.068]         else {
[10:21:23.068]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.068]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.068]         }
[10:21:23.068]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.068]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.068]             base::sink(type = "output", split = FALSE)
[10:21:23.068]             base::close(...future.stdout)
[10:21:23.068]         }, add = TRUE)
[10:21:23.068]     }
[10:21:23.068]     ...future.frame <- base::sys.nframe()
[10:21:23.068]     ...future.conditions <- base::list()
[10:21:23.068]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.068]     if (FALSE) {
[10:21:23.068]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.068]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.068]     }
[10:21:23.068]     ...future.result <- base::tryCatch({
[10:21:23.068]         base::withCallingHandlers({
[10:21:23.068]             ...future.value <- base::withVisible(base::local({
[10:21:23.068]                 withCallingHandlers({
[10:21:23.068]                   2
[10:21:23.068]                 }, immediateCondition = function(cond) {
[10:21:23.068]                   save_rds <- function (object, pathname, ...) 
[10:21:23.068]                   {
[10:21:23.068]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:23.068]                     if (file_test("-f", pathname_tmp)) {
[10:21:23.068]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.068]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:23.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.068]                         fi_tmp[["mtime"]])
[10:21:23.068]                     }
[10:21:23.068]                     tryCatch({
[10:21:23.068]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:23.068]                     }, error = function(ex) {
[10:21:23.068]                       msg <- conditionMessage(ex)
[10:21:23.068]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.068]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:23.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.068]                         fi_tmp[["mtime"]], msg)
[10:21:23.068]                       ex$message <- msg
[10:21:23.068]                       stop(ex)
[10:21:23.068]                     })
[10:21:23.068]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:23.068]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:23.068]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:23.068]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.068]                       fi <- file.info(pathname)
[10:21:23.068]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:23.068]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.068]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:23.068]                         fi[["size"]], fi[["mtime"]])
[10:21:23.068]                       stop(msg)
[10:21:23.068]                     }
[10:21:23.068]                     invisible(pathname)
[10:21:23.068]                   }
[10:21:23.068]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:23.068]                     rootPath = tempdir()) 
[10:21:23.068]                   {
[10:21:23.068]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:23.068]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:23.068]                       tmpdir = path, fileext = ".rds")
[10:21:23.068]                     save_rds(obj, file)
[10:21:23.068]                   }
[10:21:23.068]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:23.068]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.068]                   {
[10:21:23.068]                     inherits <- base::inherits
[10:21:23.068]                     invokeRestart <- base::invokeRestart
[10:21:23.068]                     is.null <- base::is.null
[10:21:23.068]                     muffled <- FALSE
[10:21:23.068]                     if (inherits(cond, "message")) {
[10:21:23.068]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.068]                       if (muffled) 
[10:21:23.068]                         invokeRestart("muffleMessage")
[10:21:23.068]                     }
[10:21:23.068]                     else if (inherits(cond, "warning")) {
[10:21:23.068]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.068]                       if (muffled) 
[10:21:23.068]                         invokeRestart("muffleWarning")
[10:21:23.068]                     }
[10:21:23.068]                     else if (inherits(cond, "condition")) {
[10:21:23.068]                       if (!is.null(pattern)) {
[10:21:23.068]                         computeRestarts <- base::computeRestarts
[10:21:23.068]                         grepl <- base::grepl
[10:21:23.068]                         restarts <- computeRestarts(cond)
[10:21:23.068]                         for (restart in restarts) {
[10:21:23.068]                           name <- restart$name
[10:21:23.068]                           if (is.null(name)) 
[10:21:23.068]                             next
[10:21:23.068]                           if (!grepl(pattern, name)) 
[10:21:23.068]                             next
[10:21:23.068]                           invokeRestart(restart)
[10:21:23.068]                           muffled <- TRUE
[10:21:23.068]                           break
[10:21:23.068]                         }
[10:21:23.068]                       }
[10:21:23.068]                     }
[10:21:23.068]                     invisible(muffled)
[10:21:23.068]                   }
[10:21:23.068]                   muffleCondition(cond)
[10:21:23.068]                 })
[10:21:23.068]             }))
[10:21:23.068]             future::FutureResult(value = ...future.value$value, 
[10:21:23.068]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.068]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.068]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.068]                     ...future.globalenv.names))
[10:21:23.068]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.068]         }, condition = base::local({
[10:21:23.068]             c <- base::c
[10:21:23.068]             inherits <- base::inherits
[10:21:23.068]             invokeRestart <- base::invokeRestart
[10:21:23.068]             length <- base::length
[10:21:23.068]             list <- base::list
[10:21:23.068]             seq.int <- base::seq.int
[10:21:23.068]             signalCondition <- base::signalCondition
[10:21:23.068]             sys.calls <- base::sys.calls
[10:21:23.068]             `[[` <- base::`[[`
[10:21:23.068]             `+` <- base::`+`
[10:21:23.068]             `<<-` <- base::`<<-`
[10:21:23.068]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.068]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.068]                   3L)]
[10:21:23.068]             }
[10:21:23.068]             function(cond) {
[10:21:23.068]                 is_error <- inherits(cond, "error")
[10:21:23.068]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.068]                   NULL)
[10:21:23.068]                 if (is_error) {
[10:21:23.068]                   sessionInformation <- function() {
[10:21:23.068]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.068]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.068]                       search = base::search(), system = base::Sys.info())
[10:21:23.068]                   }
[10:21:23.068]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.068]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.068]                     cond$call), session = sessionInformation(), 
[10:21:23.068]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.068]                   signalCondition(cond)
[10:21:23.068]                 }
[10:21:23.068]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.068]                 "immediateCondition"))) {
[10:21:23.068]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.068]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.068]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.068]                   if (TRUE && !signal) {
[10:21:23.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.068]                     {
[10:21:23.068]                       inherits <- base::inherits
[10:21:23.068]                       invokeRestart <- base::invokeRestart
[10:21:23.068]                       is.null <- base::is.null
[10:21:23.068]                       muffled <- FALSE
[10:21:23.068]                       if (inherits(cond, "message")) {
[10:21:23.068]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.068]                         if (muffled) 
[10:21:23.068]                           invokeRestart("muffleMessage")
[10:21:23.068]                       }
[10:21:23.068]                       else if (inherits(cond, "warning")) {
[10:21:23.068]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.068]                         if (muffled) 
[10:21:23.068]                           invokeRestart("muffleWarning")
[10:21:23.068]                       }
[10:21:23.068]                       else if (inherits(cond, "condition")) {
[10:21:23.068]                         if (!is.null(pattern)) {
[10:21:23.068]                           computeRestarts <- base::computeRestarts
[10:21:23.068]                           grepl <- base::grepl
[10:21:23.068]                           restarts <- computeRestarts(cond)
[10:21:23.068]                           for (restart in restarts) {
[10:21:23.068]                             name <- restart$name
[10:21:23.068]                             if (is.null(name)) 
[10:21:23.068]                               next
[10:21:23.068]                             if (!grepl(pattern, name)) 
[10:21:23.068]                               next
[10:21:23.068]                             invokeRestart(restart)
[10:21:23.068]                             muffled <- TRUE
[10:21:23.068]                             break
[10:21:23.068]                           }
[10:21:23.068]                         }
[10:21:23.068]                       }
[10:21:23.068]                       invisible(muffled)
[10:21:23.068]                     }
[10:21:23.068]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.068]                   }
[10:21:23.068]                 }
[10:21:23.068]                 else {
[10:21:23.068]                   if (TRUE) {
[10:21:23.068]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.068]                     {
[10:21:23.068]                       inherits <- base::inherits
[10:21:23.068]                       invokeRestart <- base::invokeRestart
[10:21:23.068]                       is.null <- base::is.null
[10:21:23.068]                       muffled <- FALSE
[10:21:23.068]                       if (inherits(cond, "message")) {
[10:21:23.068]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.068]                         if (muffled) 
[10:21:23.068]                           invokeRestart("muffleMessage")
[10:21:23.068]                       }
[10:21:23.068]                       else if (inherits(cond, "warning")) {
[10:21:23.068]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.068]                         if (muffled) 
[10:21:23.068]                           invokeRestart("muffleWarning")
[10:21:23.068]                       }
[10:21:23.068]                       else if (inherits(cond, "condition")) {
[10:21:23.068]                         if (!is.null(pattern)) {
[10:21:23.068]                           computeRestarts <- base::computeRestarts
[10:21:23.068]                           grepl <- base::grepl
[10:21:23.068]                           restarts <- computeRestarts(cond)
[10:21:23.068]                           for (restart in restarts) {
[10:21:23.068]                             name <- restart$name
[10:21:23.068]                             if (is.null(name)) 
[10:21:23.068]                               next
[10:21:23.068]                             if (!grepl(pattern, name)) 
[10:21:23.068]                               next
[10:21:23.068]                             invokeRestart(restart)
[10:21:23.068]                             muffled <- TRUE
[10:21:23.068]                             break
[10:21:23.068]                           }
[10:21:23.068]                         }
[10:21:23.068]                       }
[10:21:23.068]                       invisible(muffled)
[10:21:23.068]                     }
[10:21:23.068]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.068]                   }
[10:21:23.068]                 }
[10:21:23.068]             }
[10:21:23.068]         }))
[10:21:23.068]     }, error = function(ex) {
[10:21:23.068]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.068]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.068]                 ...future.rng), started = ...future.startTime, 
[10:21:23.068]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.068]             version = "1.8"), class = "FutureResult")
[10:21:23.068]     }, finally = {
[10:21:23.068]         if (!identical(...future.workdir, getwd())) 
[10:21:23.068]             setwd(...future.workdir)
[10:21:23.068]         {
[10:21:23.068]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.068]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.068]             }
[10:21:23.068]             base::options(...future.oldOptions)
[10:21:23.068]             if (.Platform$OS.type == "windows") {
[10:21:23.068]                 old_names <- names(...future.oldEnvVars)
[10:21:23.068]                 envs <- base::Sys.getenv()
[10:21:23.068]                 names <- names(envs)
[10:21:23.068]                 common <- intersect(names, old_names)
[10:21:23.068]                 added <- setdiff(names, old_names)
[10:21:23.068]                 removed <- setdiff(old_names, names)
[10:21:23.068]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.068]                   envs[common]]
[10:21:23.068]                 NAMES <- toupper(changed)
[10:21:23.068]                 args <- list()
[10:21:23.068]                 for (kk in seq_along(NAMES)) {
[10:21:23.068]                   name <- changed[[kk]]
[10:21:23.068]                   NAME <- NAMES[[kk]]
[10:21:23.068]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.068]                     next
[10:21:23.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.068]                 }
[10:21:23.068]                 NAMES <- toupper(added)
[10:21:23.068]                 for (kk in seq_along(NAMES)) {
[10:21:23.068]                   name <- added[[kk]]
[10:21:23.068]                   NAME <- NAMES[[kk]]
[10:21:23.068]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.068]                     next
[10:21:23.068]                   args[[name]] <- ""
[10:21:23.068]                 }
[10:21:23.068]                 NAMES <- toupper(removed)
[10:21:23.068]                 for (kk in seq_along(NAMES)) {
[10:21:23.068]                   name <- removed[[kk]]
[10:21:23.068]                   NAME <- NAMES[[kk]]
[10:21:23.068]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.068]                     next
[10:21:23.068]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.068]                 }
[10:21:23.068]                 if (length(args) > 0) 
[10:21:23.068]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.068]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.068]             }
[10:21:23.068]             else {
[10:21:23.068]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.068]             }
[10:21:23.068]             {
[10:21:23.068]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.068]                   0L) {
[10:21:23.068]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.068]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.068]                   base::options(opts)
[10:21:23.068]                 }
[10:21:23.068]                 {
[10:21:23.068]                   {
[10:21:23.068]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.068]                     NULL
[10:21:23.068]                   }
[10:21:23.068]                   options(future.plan = NULL)
[10:21:23.068]                   if (is.na(NA_character_)) 
[10:21:23.068]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.068]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.068]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.068]                     .init = FALSE)
[10:21:23.068]                 }
[10:21:23.068]             }
[10:21:23.068]         }
[10:21:23.068]     })
[10:21:23.068]     if (TRUE) {
[10:21:23.068]         base::sink(type = "output", split = FALSE)
[10:21:23.068]         if (TRUE) {
[10:21:23.068]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.068]         }
[10:21:23.068]         else {
[10:21:23.068]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.068]         }
[10:21:23.068]         base::close(...future.stdout)
[10:21:23.068]         ...future.stdout <- NULL
[10:21:23.068]     }
[10:21:23.068]     ...future.result$conditions <- ...future.conditions
[10:21:23.068]     ...future.result$finished <- base::Sys.time()
[10:21:23.068]     ...future.result
[10:21:23.068] }
[10:21:23.071] requestCore(): workers = 2
[10:21:23.073] MulticoreFuture started
[10:21:23.074] - Launch lazy future ... done
[10:21:23.074] run() for ‘MulticoreFuture’ ... done
[10:21:23.074] getGlobalsAndPackages() ...
[10:21:23.075] plan(): Setting new future strategy stack:
[10:21:23.075] Searching for globals...
[10:21:23.076] 
[10:21:23.075] List of future strategies:
[10:21:23.075] 1. sequential:
[10:21:23.075]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.075]    - tweaked: FALSE
[10:21:23.075]    - call: NULL
[10:21:23.076] Searching for globals ... DONE
[10:21:23.076] plan(): nbrOfWorkers() = 1
[10:21:23.076] - globals: [0] <none>
[10:21:23.076] getGlobalsAndPackages() ... DONE
[10:21:23.077] run() for ‘Future’ ...
[10:21:23.077] - state: ‘created’
[10:21:23.077] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.078] plan(): Setting new future strategy stack:
[10:21:23.078] List of future strategies:
[10:21:23.078] 1. multicore:
[10:21:23.078]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.078]    - tweaked: FALSE
[10:21:23.078]    - call: plan(strategy)
[10:21:23.081] plan(): nbrOfWorkers() = 2
[10:21:23.081] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.081] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:23.081]   - Field: ‘label’
[10:21:23.081]   - Field: ‘local’
[10:21:23.081]   - Field: ‘owner’
[10:21:23.081]   - Field: ‘envir’
[10:21:23.082]   - Field: ‘workers’
[10:21:23.082]   - Field: ‘packages’
[10:21:23.082]   - Field: ‘gc’
[10:21:23.082]   - Field: ‘job’
[10:21:23.082]   - Field: ‘conditions’
[10:21:23.082]   - Field: ‘expr’
[10:21:23.082]   - Field: ‘uuid’
[10:21:23.083]   - Field: ‘seed’
[10:21:23.083]   - Field: ‘version’
[10:21:23.083]   - Field: ‘result’
[10:21:23.083]   - Field: ‘asynchronous’
[10:21:23.083]   - Field: ‘calls’
[10:21:23.083]   - Field: ‘globals’
[10:21:23.084]   - Field: ‘stdout’
[10:21:23.084]   - Field: ‘earlySignal’
[10:21:23.084]   - Field: ‘lazy’
[10:21:23.084]   - Field: ‘state’
[10:21:23.084] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:23.084] - Launch lazy future ...
[10:21:23.085] Packages needed by the future expression (n = 0): <none>
[10:21:23.085] Packages needed by future strategies (n = 0): <none>
[10:21:23.086] {
[10:21:23.086]     {
[10:21:23.086]         {
[10:21:23.086]             ...future.startTime <- base::Sys.time()
[10:21:23.086]             {
[10:21:23.086]                 {
[10:21:23.086]                   {
[10:21:23.086]                     {
[10:21:23.086]                       base::local({
[10:21:23.086]                         has_future <- base::requireNamespace("future", 
[10:21:23.086]                           quietly = TRUE)
[10:21:23.086]                         if (has_future) {
[10:21:23.086]                           ns <- base::getNamespace("future")
[10:21:23.086]                           version <- ns[[".package"]][["version"]]
[10:21:23.086]                           if (is.null(version)) 
[10:21:23.086]                             version <- utils::packageVersion("future")
[10:21:23.086]                         }
[10:21:23.086]                         else {
[10:21:23.086]                           version <- NULL
[10:21:23.086]                         }
[10:21:23.086]                         if (!has_future || version < "1.8.0") {
[10:21:23.086]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.086]                             "", base::R.version$version.string), 
[10:21:23.086]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.086]                               "release", "version")], collapse = " "), 
[10:21:23.086]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.086]                             info)
[10:21:23.086]                           info <- base::paste(info, collapse = "; ")
[10:21:23.086]                           if (!has_future) {
[10:21:23.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.086]                               info)
[10:21:23.086]                           }
[10:21:23.086]                           else {
[10:21:23.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.086]                               info, version)
[10:21:23.086]                           }
[10:21:23.086]                           base::stop(msg)
[10:21:23.086]                         }
[10:21:23.086]                       })
[10:21:23.086]                     }
[10:21:23.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.086]                     base::options(mc.cores = 1L)
[10:21:23.086]                   }
[10:21:23.086]                   ...future.strategy.old <- future::plan("list")
[10:21:23.086]                   options(future.plan = NULL)
[10:21:23.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.086]                 }
[10:21:23.086]                 ...future.workdir <- getwd()
[10:21:23.086]             }
[10:21:23.086]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.086]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.086]         }
[10:21:23.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.086]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.086]             base::names(...future.oldOptions))
[10:21:23.086]     }
[10:21:23.086]     if (FALSE) {
[10:21:23.086]     }
[10:21:23.086]     else {
[10:21:23.086]         if (TRUE) {
[10:21:23.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.086]                 open = "w")
[10:21:23.086]         }
[10:21:23.086]         else {
[10:21:23.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.086]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.086]         }
[10:21:23.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.086]             base::sink(type = "output", split = FALSE)
[10:21:23.086]             base::close(...future.stdout)
[10:21:23.086]         }, add = TRUE)
[10:21:23.086]     }
[10:21:23.086]     ...future.frame <- base::sys.nframe()
[10:21:23.086]     ...future.conditions <- base::list()
[10:21:23.086]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.086]     if (FALSE) {
[10:21:23.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.086]     }
[10:21:23.086]     ...future.result <- base::tryCatch({
[10:21:23.086]         base::withCallingHandlers({
[10:21:23.086]             ...future.value <- base::withVisible(base::local({
[10:21:23.086]                 withCallingHandlers({
[10:21:23.086]                   NULL
[10:21:23.086]                 }, immediateCondition = function(cond) {
[10:21:23.086]                   save_rds <- function (object, pathname, ...) 
[10:21:23.086]                   {
[10:21:23.086]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:23.086]                     if (file_test("-f", pathname_tmp)) {
[10:21:23.086]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.086]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:23.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.086]                         fi_tmp[["mtime"]])
[10:21:23.086]                     }
[10:21:23.086]                     tryCatch({
[10:21:23.086]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:23.086]                     }, error = function(ex) {
[10:21:23.086]                       msg <- conditionMessage(ex)
[10:21:23.086]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.086]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:23.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.086]                         fi_tmp[["mtime"]], msg)
[10:21:23.086]                       ex$message <- msg
[10:21:23.086]                       stop(ex)
[10:21:23.086]                     })
[10:21:23.086]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:23.086]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:23.086]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:23.086]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.086]                       fi <- file.info(pathname)
[10:21:23.086]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:23.086]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.086]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:23.086]                         fi[["size"]], fi[["mtime"]])
[10:21:23.086]                       stop(msg)
[10:21:23.086]                     }
[10:21:23.086]                     invisible(pathname)
[10:21:23.086]                   }
[10:21:23.086]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:23.086]                     rootPath = tempdir()) 
[10:21:23.086]                   {
[10:21:23.086]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:23.086]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:23.086]                       tmpdir = path, fileext = ".rds")
[10:21:23.086]                     save_rds(obj, file)
[10:21:23.086]                   }
[10:21:23.086]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:23.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.086]                   {
[10:21:23.086]                     inherits <- base::inherits
[10:21:23.086]                     invokeRestart <- base::invokeRestart
[10:21:23.086]                     is.null <- base::is.null
[10:21:23.086]                     muffled <- FALSE
[10:21:23.086]                     if (inherits(cond, "message")) {
[10:21:23.086]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.086]                       if (muffled) 
[10:21:23.086]                         invokeRestart("muffleMessage")
[10:21:23.086]                     }
[10:21:23.086]                     else if (inherits(cond, "warning")) {
[10:21:23.086]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.086]                       if (muffled) 
[10:21:23.086]                         invokeRestart("muffleWarning")
[10:21:23.086]                     }
[10:21:23.086]                     else if (inherits(cond, "condition")) {
[10:21:23.086]                       if (!is.null(pattern)) {
[10:21:23.086]                         computeRestarts <- base::computeRestarts
[10:21:23.086]                         grepl <- base::grepl
[10:21:23.086]                         restarts <- computeRestarts(cond)
[10:21:23.086]                         for (restart in restarts) {
[10:21:23.086]                           name <- restart$name
[10:21:23.086]                           if (is.null(name)) 
[10:21:23.086]                             next
[10:21:23.086]                           if (!grepl(pattern, name)) 
[10:21:23.086]                             next
[10:21:23.086]                           invokeRestart(restart)
[10:21:23.086]                           muffled <- TRUE
[10:21:23.086]                           break
[10:21:23.086]                         }
[10:21:23.086]                       }
[10:21:23.086]                     }
[10:21:23.086]                     invisible(muffled)
[10:21:23.086]                   }
[10:21:23.086]                   muffleCondition(cond)
[10:21:23.086]                 })
[10:21:23.086]             }))
[10:21:23.086]             future::FutureResult(value = ...future.value$value, 
[10:21:23.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.086]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.086]                     ...future.globalenv.names))
[10:21:23.086]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.086]         }, condition = base::local({
[10:21:23.086]             c <- base::c
[10:21:23.086]             inherits <- base::inherits
[10:21:23.086]             invokeRestart <- base::invokeRestart
[10:21:23.086]             length <- base::length
[10:21:23.086]             list <- base::list
[10:21:23.086]             seq.int <- base::seq.int
[10:21:23.086]             signalCondition <- base::signalCondition
[10:21:23.086]             sys.calls <- base::sys.calls
[10:21:23.086]             `[[` <- base::`[[`
[10:21:23.086]             `+` <- base::`+`
[10:21:23.086]             `<<-` <- base::`<<-`
[10:21:23.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.086]                   3L)]
[10:21:23.086]             }
[10:21:23.086]             function(cond) {
[10:21:23.086]                 is_error <- inherits(cond, "error")
[10:21:23.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.086]                   NULL)
[10:21:23.086]                 if (is_error) {
[10:21:23.086]                   sessionInformation <- function() {
[10:21:23.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.086]                       search = base::search(), system = base::Sys.info())
[10:21:23.086]                   }
[10:21:23.086]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.086]                     cond$call), session = sessionInformation(), 
[10:21:23.086]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.086]                   signalCondition(cond)
[10:21:23.086]                 }
[10:21:23.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.086]                 "immediateCondition"))) {
[10:21:23.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.086]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.086]                   if (TRUE && !signal) {
[10:21:23.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.086]                     {
[10:21:23.086]                       inherits <- base::inherits
[10:21:23.086]                       invokeRestart <- base::invokeRestart
[10:21:23.086]                       is.null <- base::is.null
[10:21:23.086]                       muffled <- FALSE
[10:21:23.086]                       if (inherits(cond, "message")) {
[10:21:23.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.086]                         if (muffled) 
[10:21:23.086]                           invokeRestart("muffleMessage")
[10:21:23.086]                       }
[10:21:23.086]                       else if (inherits(cond, "warning")) {
[10:21:23.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.086]                         if (muffled) 
[10:21:23.086]                           invokeRestart("muffleWarning")
[10:21:23.086]                       }
[10:21:23.086]                       else if (inherits(cond, "condition")) {
[10:21:23.086]                         if (!is.null(pattern)) {
[10:21:23.086]                           computeRestarts <- base::computeRestarts
[10:21:23.086]                           grepl <- base::grepl
[10:21:23.086]                           restarts <- computeRestarts(cond)
[10:21:23.086]                           for (restart in restarts) {
[10:21:23.086]                             name <- restart$name
[10:21:23.086]                             if (is.null(name)) 
[10:21:23.086]                               next
[10:21:23.086]                             if (!grepl(pattern, name)) 
[10:21:23.086]                               next
[10:21:23.086]                             invokeRestart(restart)
[10:21:23.086]                             muffled <- TRUE
[10:21:23.086]                             break
[10:21:23.086]                           }
[10:21:23.086]                         }
[10:21:23.086]                       }
[10:21:23.086]                       invisible(muffled)
[10:21:23.086]                     }
[10:21:23.086]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.086]                   }
[10:21:23.086]                 }
[10:21:23.086]                 else {
[10:21:23.086]                   if (TRUE) {
[10:21:23.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.086]                     {
[10:21:23.086]                       inherits <- base::inherits
[10:21:23.086]                       invokeRestart <- base::invokeRestart
[10:21:23.086]                       is.null <- base::is.null
[10:21:23.086]                       muffled <- FALSE
[10:21:23.086]                       if (inherits(cond, "message")) {
[10:21:23.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.086]                         if (muffled) 
[10:21:23.086]                           invokeRestart("muffleMessage")
[10:21:23.086]                       }
[10:21:23.086]                       else if (inherits(cond, "warning")) {
[10:21:23.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.086]                         if (muffled) 
[10:21:23.086]                           invokeRestart("muffleWarning")
[10:21:23.086]                       }
[10:21:23.086]                       else if (inherits(cond, "condition")) {
[10:21:23.086]                         if (!is.null(pattern)) {
[10:21:23.086]                           computeRestarts <- base::computeRestarts
[10:21:23.086]                           grepl <- base::grepl
[10:21:23.086]                           restarts <- computeRestarts(cond)
[10:21:23.086]                           for (restart in restarts) {
[10:21:23.086]                             name <- restart$name
[10:21:23.086]                             if (is.null(name)) 
[10:21:23.086]                               next
[10:21:23.086]                             if (!grepl(pattern, name)) 
[10:21:23.086]                               next
[10:21:23.086]                             invokeRestart(restart)
[10:21:23.086]                             muffled <- TRUE
[10:21:23.086]                             break
[10:21:23.086]                           }
[10:21:23.086]                         }
[10:21:23.086]                       }
[10:21:23.086]                       invisible(muffled)
[10:21:23.086]                     }
[10:21:23.086]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.086]                   }
[10:21:23.086]                 }
[10:21:23.086]             }
[10:21:23.086]         }))
[10:21:23.086]     }, error = function(ex) {
[10:21:23.086]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.086]                 ...future.rng), started = ...future.startTime, 
[10:21:23.086]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.086]             version = "1.8"), class = "FutureResult")
[10:21:23.086]     }, finally = {
[10:21:23.086]         if (!identical(...future.workdir, getwd())) 
[10:21:23.086]             setwd(...future.workdir)
[10:21:23.086]         {
[10:21:23.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.086]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.086]             }
[10:21:23.086]             base::options(...future.oldOptions)
[10:21:23.086]             if (.Platform$OS.type == "windows") {
[10:21:23.086]                 old_names <- names(...future.oldEnvVars)
[10:21:23.086]                 envs <- base::Sys.getenv()
[10:21:23.086]                 names <- names(envs)
[10:21:23.086]                 common <- intersect(names, old_names)
[10:21:23.086]                 added <- setdiff(names, old_names)
[10:21:23.086]                 removed <- setdiff(old_names, names)
[10:21:23.086]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.086]                   envs[common]]
[10:21:23.086]                 NAMES <- toupper(changed)
[10:21:23.086]                 args <- list()
[10:21:23.086]                 for (kk in seq_along(NAMES)) {
[10:21:23.086]                   name <- changed[[kk]]
[10:21:23.086]                   NAME <- NAMES[[kk]]
[10:21:23.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.086]                     next
[10:21:23.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.086]                 }
[10:21:23.086]                 NAMES <- toupper(added)
[10:21:23.086]                 for (kk in seq_along(NAMES)) {
[10:21:23.086]                   name <- added[[kk]]
[10:21:23.086]                   NAME <- NAMES[[kk]]
[10:21:23.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.086]                     next
[10:21:23.086]                   args[[name]] <- ""
[10:21:23.086]                 }
[10:21:23.086]                 NAMES <- toupper(removed)
[10:21:23.086]                 for (kk in seq_along(NAMES)) {
[10:21:23.086]                   name <- removed[[kk]]
[10:21:23.086]                   NAME <- NAMES[[kk]]
[10:21:23.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.086]                     next
[10:21:23.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.086]                 }
[10:21:23.086]                 if (length(args) > 0) 
[10:21:23.086]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.086]             }
[10:21:23.086]             else {
[10:21:23.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.086]             }
[10:21:23.086]             {
[10:21:23.086]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.086]                   0L) {
[10:21:23.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.086]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.086]                   base::options(opts)
[10:21:23.086]                 }
[10:21:23.086]                 {
[10:21:23.086]                   {
[10:21:23.086]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.086]                     NULL
[10:21:23.086]                   }
[10:21:23.086]                   options(future.plan = NULL)
[10:21:23.086]                   if (is.na(NA_character_)) 
[10:21:23.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.086]                     .init = FALSE)
[10:21:23.086]                 }
[10:21:23.086]             }
[10:21:23.086]         }
[10:21:23.086]     })
[10:21:23.086]     if (TRUE) {
[10:21:23.086]         base::sink(type = "output", split = FALSE)
[10:21:23.086]         if (TRUE) {
[10:21:23.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.086]         }
[10:21:23.086]         else {
[10:21:23.086]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.086]         }
[10:21:23.086]         base::close(...future.stdout)
[10:21:23.086]         ...future.stdout <- NULL
[10:21:23.086]     }
[10:21:23.086]     ...future.result$conditions <- ...future.conditions
[10:21:23.086]     ...future.result$finished <- base::Sys.time()
[10:21:23.086]     ...future.result
[10:21:23.086] }
[10:21:23.089] requestCore(): workers = 2
[10:21:23.092] MulticoreFuture started
[10:21:23.092] - Launch lazy future ... done
[10:21:23.093] run() for ‘MulticoreFuture’ ... done
[10:21:23.093] plan(): Setting new future strategy stack:
[10:21:23.093] getGlobalsAndPackages() ...
[10:21:23.094] Searching for globals...
[10:21:23.093] List of future strategies:
[10:21:23.093] 1. sequential:
[10:21:23.093]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.093]    - tweaked: FALSE
[10:21:23.093]    - call: NULL
[10:21:23.094] plan(): nbrOfWorkers() = 1
[10:21:23.095] - globals found: [1] ‘{’
[10:21:23.095] Searching for globals ... DONE
[10:21:23.095] Resolving globals: FALSE
[10:21:23.096] 
[10:21:23.096] 
[10:21:23.096] getGlobalsAndPackages() ... DONE
[10:21:23.097] plan(): Setting new future strategy stack:
[10:21:23.097] run() for ‘Future’ ...
[10:21:23.097] - state: ‘created’
[10:21:23.097] List of future strategies:
[10:21:23.097] 1. multicore:
[10:21:23.097]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.097]    - tweaked: FALSE
[10:21:23.097]    - call: plan(strategy)
[10:21:23.097] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.100] plan(): nbrOfWorkers() = 2
[10:21:23.100] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.100] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:23.101]   - Field: ‘label’
[10:21:23.101]   - Field: ‘local’
[10:21:23.101]   - Field: ‘owner’
[10:21:23.101]   - Field: ‘envir’
[10:21:23.101]   - Field: ‘workers’
[10:21:23.101]   - Field: ‘packages’
[10:21:23.101]   - Field: ‘gc’
[10:21:23.102]   - Field: ‘job’
[10:21:23.102]   - Field: ‘conditions’
[10:21:23.102]   - Field: ‘expr’
[10:21:23.102]   - Field: ‘uuid’
[10:21:23.102]   - Field: ‘seed’
[10:21:23.102]   - Field: ‘version’
[10:21:23.102]   - Field: ‘result’
[10:21:23.103]   - Field: ‘asynchronous’
[10:21:23.103]   - Field: ‘calls’
[10:21:23.103]   - Field: ‘globals’
[10:21:23.103]   - Field: ‘stdout’
[10:21:23.103]   - Field: ‘earlySignal’
[10:21:23.103]   - Field: ‘lazy’
[10:21:23.103]   - Field: ‘state’
[10:21:23.104] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:23.104] - Launch lazy future ...
[10:21:23.104] Packages needed by the future expression (n = 0): <none>
[10:21:23.104] Packages needed by future strategies (n = 0): <none>
[10:21:23.105] {
[10:21:23.105]     {
[10:21:23.105]         {
[10:21:23.105]             ...future.startTime <- base::Sys.time()
[10:21:23.105]             {
[10:21:23.105]                 {
[10:21:23.105]                   {
[10:21:23.105]                     {
[10:21:23.105]                       base::local({
[10:21:23.105]                         has_future <- base::requireNamespace("future", 
[10:21:23.105]                           quietly = TRUE)
[10:21:23.105]                         if (has_future) {
[10:21:23.105]                           ns <- base::getNamespace("future")
[10:21:23.105]                           version <- ns[[".package"]][["version"]]
[10:21:23.105]                           if (is.null(version)) 
[10:21:23.105]                             version <- utils::packageVersion("future")
[10:21:23.105]                         }
[10:21:23.105]                         else {
[10:21:23.105]                           version <- NULL
[10:21:23.105]                         }
[10:21:23.105]                         if (!has_future || version < "1.8.0") {
[10:21:23.105]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.105]                             "", base::R.version$version.string), 
[10:21:23.105]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.105]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.105]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.105]                               "release", "version")], collapse = " "), 
[10:21:23.105]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.105]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.105]                             info)
[10:21:23.105]                           info <- base::paste(info, collapse = "; ")
[10:21:23.105]                           if (!has_future) {
[10:21:23.105]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.105]                               info)
[10:21:23.105]                           }
[10:21:23.105]                           else {
[10:21:23.105]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.105]                               info, version)
[10:21:23.105]                           }
[10:21:23.105]                           base::stop(msg)
[10:21:23.105]                         }
[10:21:23.105]                       })
[10:21:23.105]                     }
[10:21:23.105]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.105]                     base::options(mc.cores = 1L)
[10:21:23.105]                   }
[10:21:23.105]                   ...future.strategy.old <- future::plan("list")
[10:21:23.105]                   options(future.plan = NULL)
[10:21:23.105]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.105]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.105]                 }
[10:21:23.105]                 ...future.workdir <- getwd()
[10:21:23.105]             }
[10:21:23.105]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.105]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.105]         }
[10:21:23.105]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.105]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.105]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.105]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.105]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.105]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.105]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.105]             base::names(...future.oldOptions))
[10:21:23.105]     }
[10:21:23.105]     if (FALSE) {
[10:21:23.105]     }
[10:21:23.105]     else {
[10:21:23.105]         if (TRUE) {
[10:21:23.105]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.105]                 open = "w")
[10:21:23.105]         }
[10:21:23.105]         else {
[10:21:23.105]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.105]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.105]         }
[10:21:23.105]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.105]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.105]             base::sink(type = "output", split = FALSE)
[10:21:23.105]             base::close(...future.stdout)
[10:21:23.105]         }, add = TRUE)
[10:21:23.105]     }
[10:21:23.105]     ...future.frame <- base::sys.nframe()
[10:21:23.105]     ...future.conditions <- base::list()
[10:21:23.105]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.105]     if (FALSE) {
[10:21:23.105]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.105]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.105]     }
[10:21:23.105]     ...future.result <- base::tryCatch({
[10:21:23.105]         base::withCallingHandlers({
[10:21:23.105]             ...future.value <- base::withVisible(base::local({
[10:21:23.105]                 withCallingHandlers({
[10:21:23.105]                   {
[10:21:23.105]                     4
[10:21:23.105]                   }
[10:21:23.105]                 }, immediateCondition = function(cond) {
[10:21:23.105]                   save_rds <- function (object, pathname, ...) 
[10:21:23.105]                   {
[10:21:23.105]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:23.105]                     if (file_test("-f", pathname_tmp)) {
[10:21:23.105]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.105]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:23.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.105]                         fi_tmp[["mtime"]])
[10:21:23.105]                     }
[10:21:23.105]                     tryCatch({
[10:21:23.105]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:23.105]                     }, error = function(ex) {
[10:21:23.105]                       msg <- conditionMessage(ex)
[10:21:23.105]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.105]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:23.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.105]                         fi_tmp[["mtime"]], msg)
[10:21:23.105]                       ex$message <- msg
[10:21:23.105]                       stop(ex)
[10:21:23.105]                     })
[10:21:23.105]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:23.105]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:23.105]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:23.105]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.105]                       fi <- file.info(pathname)
[10:21:23.105]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:23.105]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.105]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:23.105]                         fi[["size"]], fi[["mtime"]])
[10:21:23.105]                       stop(msg)
[10:21:23.105]                     }
[10:21:23.105]                     invisible(pathname)
[10:21:23.105]                   }
[10:21:23.105]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:23.105]                     rootPath = tempdir()) 
[10:21:23.105]                   {
[10:21:23.105]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:23.105]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:23.105]                       tmpdir = path, fileext = ".rds")
[10:21:23.105]                     save_rds(obj, file)
[10:21:23.105]                   }
[10:21:23.105]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:23.105]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.105]                   {
[10:21:23.105]                     inherits <- base::inherits
[10:21:23.105]                     invokeRestart <- base::invokeRestart
[10:21:23.105]                     is.null <- base::is.null
[10:21:23.105]                     muffled <- FALSE
[10:21:23.105]                     if (inherits(cond, "message")) {
[10:21:23.105]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.105]                       if (muffled) 
[10:21:23.105]                         invokeRestart("muffleMessage")
[10:21:23.105]                     }
[10:21:23.105]                     else if (inherits(cond, "warning")) {
[10:21:23.105]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.105]                       if (muffled) 
[10:21:23.105]                         invokeRestart("muffleWarning")
[10:21:23.105]                     }
[10:21:23.105]                     else if (inherits(cond, "condition")) {
[10:21:23.105]                       if (!is.null(pattern)) {
[10:21:23.105]                         computeRestarts <- base::computeRestarts
[10:21:23.105]                         grepl <- base::grepl
[10:21:23.105]                         restarts <- computeRestarts(cond)
[10:21:23.105]                         for (restart in restarts) {
[10:21:23.105]                           name <- restart$name
[10:21:23.105]                           if (is.null(name)) 
[10:21:23.105]                             next
[10:21:23.105]                           if (!grepl(pattern, name)) 
[10:21:23.105]                             next
[10:21:23.105]                           invokeRestart(restart)
[10:21:23.105]                           muffled <- TRUE
[10:21:23.105]                           break
[10:21:23.105]                         }
[10:21:23.105]                       }
[10:21:23.105]                     }
[10:21:23.105]                     invisible(muffled)
[10:21:23.105]                   }
[10:21:23.105]                   muffleCondition(cond)
[10:21:23.105]                 })
[10:21:23.105]             }))
[10:21:23.105]             future::FutureResult(value = ...future.value$value, 
[10:21:23.105]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.105]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.105]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.105]                     ...future.globalenv.names))
[10:21:23.105]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.105]         }, condition = base::local({
[10:21:23.105]             c <- base::c
[10:21:23.105]             inherits <- base::inherits
[10:21:23.105]             invokeRestart <- base::invokeRestart
[10:21:23.105]             length <- base::length
[10:21:23.105]             list <- base::list
[10:21:23.105]             seq.int <- base::seq.int
[10:21:23.105]             signalCondition <- base::signalCondition
[10:21:23.105]             sys.calls <- base::sys.calls
[10:21:23.105]             `[[` <- base::`[[`
[10:21:23.105]             `+` <- base::`+`
[10:21:23.105]             `<<-` <- base::`<<-`
[10:21:23.105]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.105]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.105]                   3L)]
[10:21:23.105]             }
[10:21:23.105]             function(cond) {
[10:21:23.105]                 is_error <- inherits(cond, "error")
[10:21:23.105]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.105]                   NULL)
[10:21:23.105]                 if (is_error) {
[10:21:23.105]                   sessionInformation <- function() {
[10:21:23.105]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.105]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.105]                       search = base::search(), system = base::Sys.info())
[10:21:23.105]                   }
[10:21:23.105]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.105]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.105]                     cond$call), session = sessionInformation(), 
[10:21:23.105]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.105]                   signalCondition(cond)
[10:21:23.105]                 }
[10:21:23.105]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.105]                 "immediateCondition"))) {
[10:21:23.105]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.105]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.105]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.105]                   if (TRUE && !signal) {
[10:21:23.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.105]                     {
[10:21:23.105]                       inherits <- base::inherits
[10:21:23.105]                       invokeRestart <- base::invokeRestart
[10:21:23.105]                       is.null <- base::is.null
[10:21:23.105]                       muffled <- FALSE
[10:21:23.105]                       if (inherits(cond, "message")) {
[10:21:23.105]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.105]                         if (muffled) 
[10:21:23.105]                           invokeRestart("muffleMessage")
[10:21:23.105]                       }
[10:21:23.105]                       else if (inherits(cond, "warning")) {
[10:21:23.105]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.105]                         if (muffled) 
[10:21:23.105]                           invokeRestart("muffleWarning")
[10:21:23.105]                       }
[10:21:23.105]                       else if (inherits(cond, "condition")) {
[10:21:23.105]                         if (!is.null(pattern)) {
[10:21:23.105]                           computeRestarts <- base::computeRestarts
[10:21:23.105]                           grepl <- base::grepl
[10:21:23.105]                           restarts <- computeRestarts(cond)
[10:21:23.105]                           for (restart in restarts) {
[10:21:23.105]                             name <- restart$name
[10:21:23.105]                             if (is.null(name)) 
[10:21:23.105]                               next
[10:21:23.105]                             if (!grepl(pattern, name)) 
[10:21:23.105]                               next
[10:21:23.105]                             invokeRestart(restart)
[10:21:23.105]                             muffled <- TRUE
[10:21:23.105]                             break
[10:21:23.105]                           }
[10:21:23.105]                         }
[10:21:23.105]                       }
[10:21:23.105]                       invisible(muffled)
[10:21:23.105]                     }
[10:21:23.105]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.105]                   }
[10:21:23.105]                 }
[10:21:23.105]                 else {
[10:21:23.105]                   if (TRUE) {
[10:21:23.105]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.105]                     {
[10:21:23.105]                       inherits <- base::inherits
[10:21:23.105]                       invokeRestart <- base::invokeRestart
[10:21:23.105]                       is.null <- base::is.null
[10:21:23.105]                       muffled <- FALSE
[10:21:23.105]                       if (inherits(cond, "message")) {
[10:21:23.105]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.105]                         if (muffled) 
[10:21:23.105]                           invokeRestart("muffleMessage")
[10:21:23.105]                       }
[10:21:23.105]                       else if (inherits(cond, "warning")) {
[10:21:23.105]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.105]                         if (muffled) 
[10:21:23.105]                           invokeRestart("muffleWarning")
[10:21:23.105]                       }
[10:21:23.105]                       else if (inherits(cond, "condition")) {
[10:21:23.105]                         if (!is.null(pattern)) {
[10:21:23.105]                           computeRestarts <- base::computeRestarts
[10:21:23.105]                           grepl <- base::grepl
[10:21:23.105]                           restarts <- computeRestarts(cond)
[10:21:23.105]                           for (restart in restarts) {
[10:21:23.105]                             name <- restart$name
[10:21:23.105]                             if (is.null(name)) 
[10:21:23.105]                               next
[10:21:23.105]                             if (!grepl(pattern, name)) 
[10:21:23.105]                               next
[10:21:23.105]                             invokeRestart(restart)
[10:21:23.105]                             muffled <- TRUE
[10:21:23.105]                             break
[10:21:23.105]                           }
[10:21:23.105]                         }
[10:21:23.105]                       }
[10:21:23.105]                       invisible(muffled)
[10:21:23.105]                     }
[10:21:23.105]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.105]                   }
[10:21:23.105]                 }
[10:21:23.105]             }
[10:21:23.105]         }))
[10:21:23.105]     }, error = function(ex) {
[10:21:23.105]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.105]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.105]                 ...future.rng), started = ...future.startTime, 
[10:21:23.105]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.105]             version = "1.8"), class = "FutureResult")
[10:21:23.105]     }, finally = {
[10:21:23.105]         if (!identical(...future.workdir, getwd())) 
[10:21:23.105]             setwd(...future.workdir)
[10:21:23.105]         {
[10:21:23.105]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.105]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.105]             }
[10:21:23.105]             base::options(...future.oldOptions)
[10:21:23.105]             if (.Platform$OS.type == "windows") {
[10:21:23.105]                 old_names <- names(...future.oldEnvVars)
[10:21:23.105]                 envs <- base::Sys.getenv()
[10:21:23.105]                 names <- names(envs)
[10:21:23.105]                 common <- intersect(names, old_names)
[10:21:23.105]                 added <- setdiff(names, old_names)
[10:21:23.105]                 removed <- setdiff(old_names, names)
[10:21:23.105]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.105]                   envs[common]]
[10:21:23.105]                 NAMES <- toupper(changed)
[10:21:23.105]                 args <- list()
[10:21:23.105]                 for (kk in seq_along(NAMES)) {
[10:21:23.105]                   name <- changed[[kk]]
[10:21:23.105]                   NAME <- NAMES[[kk]]
[10:21:23.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.105]                     next
[10:21:23.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.105]                 }
[10:21:23.105]                 NAMES <- toupper(added)
[10:21:23.105]                 for (kk in seq_along(NAMES)) {
[10:21:23.105]                   name <- added[[kk]]
[10:21:23.105]                   NAME <- NAMES[[kk]]
[10:21:23.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.105]                     next
[10:21:23.105]                   args[[name]] <- ""
[10:21:23.105]                 }
[10:21:23.105]                 NAMES <- toupper(removed)
[10:21:23.105]                 for (kk in seq_along(NAMES)) {
[10:21:23.105]                   name <- removed[[kk]]
[10:21:23.105]                   NAME <- NAMES[[kk]]
[10:21:23.105]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.105]                     next
[10:21:23.105]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.105]                 }
[10:21:23.105]                 if (length(args) > 0) 
[10:21:23.105]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.105]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.105]             }
[10:21:23.105]             else {
[10:21:23.105]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.105]             }
[10:21:23.105]             {
[10:21:23.105]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.105]                   0L) {
[10:21:23.105]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.105]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.105]                   base::options(opts)
[10:21:23.105]                 }
[10:21:23.105]                 {
[10:21:23.105]                   {
[10:21:23.105]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.105]                     NULL
[10:21:23.105]                   }
[10:21:23.105]                   options(future.plan = NULL)
[10:21:23.105]                   if (is.na(NA_character_)) 
[10:21:23.105]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.105]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.105]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.105]                     .init = FALSE)
[10:21:23.105]                 }
[10:21:23.105]             }
[10:21:23.105]         }
[10:21:23.105]     })
[10:21:23.105]     if (TRUE) {
[10:21:23.105]         base::sink(type = "output", split = FALSE)
[10:21:23.105]         if (TRUE) {
[10:21:23.105]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.105]         }
[10:21:23.105]         else {
[10:21:23.105]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.105]         }
[10:21:23.105]         base::close(...future.stdout)
[10:21:23.105]         ...future.stdout <- NULL
[10:21:23.105]     }
[10:21:23.105]     ...future.result$conditions <- ...future.conditions
[10:21:23.105]     ...future.result$finished <- base::Sys.time()
[10:21:23.105]     ...future.result
[10:21:23.105] }
[10:21:23.109] requestCore(): workers = 2
[10:21:23.109] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:23.120] result() for MulticoreFuture ...
[10:21:23.121] result() for MulticoreFuture ...
[10:21:23.121] result() for MulticoreFuture ... done
[10:21:23.121] result() for MulticoreFuture ... done
[10:21:23.121] result() for MulticoreFuture ...
[10:21:23.121] result() for MulticoreFuture ... done
[10:21:23.125] MulticoreFuture started
[10:21:23.125] - Launch lazy future ... done
[10:21:23.125] run() for ‘MulticoreFuture’ ... done
[10:21:23.126] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55e8e7481310> 
[10:21:23.126] List of future strategies:
[10:21:23.126] 1. sequential:
[10:21:23.126]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.126]    - tweaked: FALSE
[10:21:23.126]    - call: NULL
[10:21:23.128] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55e8e34a9740> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=[10:21:23.131] plan(): Setting new future strategy stack:
List of 2
  ..$ :[10:21:23.131] List of future strategies:
[10:21:23.131] 1. multicore:
[10:21:23.131]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.131]    - tweaked: FALSE
[10:21:23.131]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:21:23.136] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:23.141] resolve() on list environment ...
[10:21:23.141]  recursive: 0
[10:21:23.142]  length: 6
[10:21:23.143]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:23.143] signalConditionsASAP(numeric, pos=1) ...
[10:21:23.143] - nx: 6
[10:21:23.143] - relay: TRUE
[10:21:23.143] - stdout: TRUE
[10:21:23.143] - signal: TRUE
[10:21:23.143] - resignal: FALSE
[10:21:23.144] - force: TRUE
[10:21:23.144] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.144] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.144]  - until=2
[10:21:23.144]  - relaying element #2
[10:21:23.144] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.145] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.145] signalConditionsASAP(NULL, pos=1) ... done
[10:21:23.145]  length: 5 (resolved future 1)
[10:21:23.145] Future #2
[10:21:23.145] result() for MulticoreFuture ...
[10:21:23.145] result() for MulticoreFuture ... done
[10:21:23.145] result() for MulticoreFuture ...
[10:21:23.146] result() for MulticoreFuture ... done
[10:21:23.146] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:23.146] - nx: 6
[10:21:23.146] - relay: TRUE
[10:21:23.146] - stdout: TRUE
[10:21:23.146] - signal: TRUE
[10:21:23.146] - resignal: FALSE
[10:21:23.146] - force: TRUE
[10:21:23.146] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.147] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.147]  - until=2
[10:21:23.147]  - relaying element #2
[10:21:23.147] result() for MulticoreFuture ...
[10:21:23.147] result() for MulticoreFuture ... done
[10:21:23.147] result() for MulticoreFuture ...
[10:21:23.147] result() for MulticoreFuture ... done
[10:21:23.148] result() for MulticoreFuture ...
[10:21:23.148] result() for MulticoreFuture ... done
[10:21:23.148] result() for MulticoreFuture ...
[10:21:23.148] result() for MulticoreFuture ... done
[10:21:23.148] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.148] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.148] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:23.148]  length: 4 (resolved future 2)
[10:21:23.149] Future #3
[10:21:23.149] result() for MulticoreFuture ...
[10:21:23.150] result() for MulticoreFuture ...
[10:21:23.150] result() for MulticoreFuture ... done
[10:21:23.150] result() for MulticoreFuture ... done
[10:21:23.150] result() for MulticoreFuture ...
[10:21:23.150] result() for MulticoreFuture ... done
[10:21:23.150] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:23.151] - nx: 6
[10:21:23.151] - relay: TRUE
[10:21:23.151] - stdout: TRUE
[10:21:23.151] - signal: TRUE
[10:21:23.151] - resignal: FALSE
[10:21:23.151] - force: TRUE
[10:21:23.151] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.151] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.151]  - until=3
[10:21:23.152]  - relaying element #3
[10:21:23.152] result() for MulticoreFuture ...
[10:21:23.152] result() for MulticoreFuture ... done
[10:21:23.152] result() for MulticoreFuture ...
[10:21:23.152] result() for MulticoreFuture ... done
[10:21:23.152] result() for MulticoreFuture ...
[10:21:23.152] result() for MulticoreFuture ... done
[10:21:23.153] result() for MulticoreFuture ...
[10:21:23.153] result() for MulticoreFuture ... done
[10:21:23.153] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.153] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.153] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:23.153]  length: 3 (resolved future 3)
[10:21:23.153] Future #4
[10:21:23.154] result() for MulticoreFuture ...
[10:21:23.154] result() for MulticoreFuture ...
[10:21:23.155] result() for MulticoreFuture ... done
[10:21:23.155] result() for MulticoreFuture ... done
[10:21:23.155] result() for MulticoreFuture ...
[10:21:23.155] result() for MulticoreFuture ... done
[10:21:23.155] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:23.156] - nx: 6
[10:21:23.156] - relay: TRUE
[10:21:23.156] - stdout: TRUE
[10:21:23.156] - signal: TRUE
[10:21:23.156] - resignal: FALSE
[10:21:23.156] - force: TRUE
[10:21:23.156] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.157] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.157]  - until=4
[10:21:23.157]  - relaying element #4
[10:21:23.157] result() for MulticoreFuture ...
[10:21:23.157] result() for MulticoreFuture ... done
[10:21:23.158] result() for MulticoreFuture ...
[10:21:23.158] result() for MulticoreFuture ... done
[10:21:23.158] result() for MulticoreFuture ...
[10:21:23.158] result() for MulticoreFuture ... done
[10:21:23.158] result() for MulticoreFuture ...
[10:21:23.158] result() for MulticoreFuture ... done
[10:21:23.158] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.159] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.159] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:23.159]  length: 2 (resolved future 4)
[10:21:23.159] signalConditionsASAP(NULL, pos=5) ...
[10:21:23.159] - nx: 6
[10:21:23.159] - relay: TRUE
[10:21:23.159] - stdout: TRUE
[10:21:23.160] - signal: TRUE
[10:21:23.160] - resignal: FALSE
[10:21:23.160] - force: TRUE
[10:21:23.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.160] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.160]  - until=6
[10:21:23.160]  - relaying element #6
[10:21:23.160] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:23.160] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.160] signalConditionsASAP(NULL, pos=5) ... done
[10:21:23.161]  length: 1 (resolved future 5)
[10:21:23.161] signalConditionsASAP(numeric, pos=6) ...
[10:21:23.161] - nx: 6
[10:21:23.161] - relay: TRUE
[10:21:23.161] - stdout: TRUE
[10:21:23.161] - signal: TRUE
[10:21:23.161] - resignal: FALSE
[10:21:23.161] - force: TRUE
[10:21:23.161] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:23.161] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.161]  - until=6
[10:21:23.162] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.162] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.162] signalConditionsASAP(numeric, pos=6) ... done
[10:21:23.162]  length: 0 (resolved future 6)
[10:21:23.162] Relaying remaining futures
[10:21:23.162] signalConditionsASAP(NULL, pos=0) ...
[10:21:23.162] - nx: 6
[10:21:23.162] - relay: TRUE
[10:21:23.162] - stdout: TRUE
[10:21:23.162] - signal: TRUE
[10:21:23.163] - resignal: FALSE
[10:21:23.163] - force: TRUE
[10:21:23.163] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.163] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:23.163] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.163] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.163] signalConditionsASAP(NULL, pos=0) ... done
[10:21:23.163] resolve() on list environment ... DONE
[10:21:23.163] result() for MulticoreFuture ...
[10:21:23.164] result() for MulticoreFuture ... done
[10:21:23.164] result() for MulticoreFuture ...
[10:21:23.164] result() for MulticoreFuture ... done
[10:21:23.164] result() for MulticoreFuture ...
[10:21:23.164] result() for MulticoreFuture ... done
[10:21:23.164] result() for MulticoreFuture ...
[10:21:23.164] result() for MulticoreFuture ... done
[10:21:23.165] result() for MulticoreFuture ...
[10:21:23.165] result() for MulticoreFuture ... done
[10:21:23.165] result() for MulticoreFuture ...
[10:21:23.165] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e3767520> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:21:23.167] getGlobalsAndPackages() ...
[10:21:23.167] Searching for globals...
[10:21:23.167] 
[10:21:23.167] Searching for globals ... DONE
[10:21:23.168] - globals: [0] <none>
[10:21:23.168] getGlobalsAndPackages() ... DONE
[10:21:23.168] run() for ‘Future’ ...
[10:21:23.168] - state: ‘created’
[10:21:23.168] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.171] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.171] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:23.171]   - Field: ‘label’
[10:21:23.171]   - Field: ‘local’
[10:21:23.171]   - Field: ‘owner’
[10:21:23.171]   - Field: ‘envir’
[10:21:23.171]   - Field: ‘workers’
[10:21:23.171]   - Field: ‘packages’
[10:21:23.171]   - Field: ‘gc’
[10:21:23.172]   - Field: ‘job’
[10:21:23.172]   - Field: ‘conditions’
[10:21:23.172]   - Field: ‘expr’
[10:21:23.172]   - Field: ‘uuid’
[10:21:23.172]   - Field: ‘seed’
[10:21:23.172]   - Field: ‘version’
[10:21:23.172]   - Field: ‘result’
[10:21:23.172]   - Field: ‘asynchronous’
[10:21:23.172]   - Field: ‘calls’
[10:21:23.172]   - Field: ‘globals’
[10:21:23.173]   - Field: ‘stdout’
[10:21:23.173]   - Field: ‘earlySignal’
[10:21:23.173]   - Field: ‘lazy’
[10:21:23.173]   - Field: ‘state’
[10:21:23.173] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:23.173] - Launch lazy future ...
[10:21:23.173] Packages needed by the future expression (n = 0): <none>
[10:21:23.174] Packages needed by future strategies (n = 0): <none>
[10:21:23.174] {
[10:21:23.174]     {
[10:21:23.174]         {
[10:21:23.174]             ...future.startTime <- base::Sys.time()
[10:21:23.174]             {
[10:21:23.174]                 {
[10:21:23.174]                   {
[10:21:23.174]                     {
[10:21:23.174]                       base::local({
[10:21:23.174]                         has_future <- base::requireNamespace("future", 
[10:21:23.174]                           quietly = TRUE)
[10:21:23.174]                         if (has_future) {
[10:21:23.174]                           ns <- base::getNamespace("future")
[10:21:23.174]                           version <- ns[[".package"]][["version"]]
[10:21:23.174]                           if (is.null(version)) 
[10:21:23.174]                             version <- utils::packageVersion("future")
[10:21:23.174]                         }
[10:21:23.174]                         else {
[10:21:23.174]                           version <- NULL
[10:21:23.174]                         }
[10:21:23.174]                         if (!has_future || version < "1.8.0") {
[10:21:23.174]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.174]                             "", base::R.version$version.string), 
[10:21:23.174]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.174]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.174]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.174]                               "release", "version")], collapse = " "), 
[10:21:23.174]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.174]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.174]                             info)
[10:21:23.174]                           info <- base::paste(info, collapse = "; ")
[10:21:23.174]                           if (!has_future) {
[10:21:23.174]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.174]                               info)
[10:21:23.174]                           }
[10:21:23.174]                           else {
[10:21:23.174]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.174]                               info, version)
[10:21:23.174]                           }
[10:21:23.174]                           base::stop(msg)
[10:21:23.174]                         }
[10:21:23.174]                       })
[10:21:23.174]                     }
[10:21:23.174]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.174]                     base::options(mc.cores = 1L)
[10:21:23.174]                   }
[10:21:23.174]                   ...future.strategy.old <- future::plan("list")
[10:21:23.174]                   options(future.plan = NULL)
[10:21:23.174]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.174]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.174]                 }
[10:21:23.174]                 ...future.workdir <- getwd()
[10:21:23.174]             }
[10:21:23.174]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.174]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.174]         }
[10:21:23.174]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.174]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.174]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.174]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.174]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.174]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.174]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.174]             base::names(...future.oldOptions))
[10:21:23.174]     }
[10:21:23.174]     if (FALSE) {
[10:21:23.174]     }
[10:21:23.174]     else {
[10:21:23.174]         if (TRUE) {
[10:21:23.174]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.174]                 open = "w")
[10:21:23.174]         }
[10:21:23.174]         else {
[10:21:23.174]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.174]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.174]         }
[10:21:23.174]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.174]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.174]             base::sink(type = "output", split = FALSE)
[10:21:23.174]             base::close(...future.stdout)
[10:21:23.174]         }, add = TRUE)
[10:21:23.174]     }
[10:21:23.174]     ...future.frame <- base::sys.nframe()
[10:21:23.174]     ...future.conditions <- base::list()
[10:21:23.174]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.174]     if (FALSE) {
[10:21:23.174]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.174]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.174]     }
[10:21:23.174]     ...future.result <- base::tryCatch({
[10:21:23.174]         base::withCallingHandlers({
[10:21:23.174]             ...future.value <- base::withVisible(base::local({
[10:21:23.174]                 withCallingHandlers({
[10:21:23.174]                   2
[10:21:23.174]                 }, immediateCondition = function(cond) {
[10:21:23.174]                   save_rds <- function (object, pathname, ...) 
[10:21:23.174]                   {
[10:21:23.174]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:23.174]                     if (file_test("-f", pathname_tmp)) {
[10:21:23.174]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.174]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:23.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.174]                         fi_tmp[["mtime"]])
[10:21:23.174]                     }
[10:21:23.174]                     tryCatch({
[10:21:23.174]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:23.174]                     }, error = function(ex) {
[10:21:23.174]                       msg <- conditionMessage(ex)
[10:21:23.174]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.174]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:23.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.174]                         fi_tmp[["mtime"]], msg)
[10:21:23.174]                       ex$message <- msg
[10:21:23.174]                       stop(ex)
[10:21:23.174]                     })
[10:21:23.174]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:23.174]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:23.174]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:23.174]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.174]                       fi <- file.info(pathname)
[10:21:23.174]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:23.174]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.174]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:23.174]                         fi[["size"]], fi[["mtime"]])
[10:21:23.174]                       stop(msg)
[10:21:23.174]                     }
[10:21:23.174]                     invisible(pathname)
[10:21:23.174]                   }
[10:21:23.174]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:23.174]                     rootPath = tempdir()) 
[10:21:23.174]                   {
[10:21:23.174]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:23.174]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:23.174]                       tmpdir = path, fileext = ".rds")
[10:21:23.174]                     save_rds(obj, file)
[10:21:23.174]                   }
[10:21:23.174]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:23.174]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.174]                   {
[10:21:23.174]                     inherits <- base::inherits
[10:21:23.174]                     invokeRestart <- base::invokeRestart
[10:21:23.174]                     is.null <- base::is.null
[10:21:23.174]                     muffled <- FALSE
[10:21:23.174]                     if (inherits(cond, "message")) {
[10:21:23.174]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.174]                       if (muffled) 
[10:21:23.174]                         invokeRestart("muffleMessage")
[10:21:23.174]                     }
[10:21:23.174]                     else if (inherits(cond, "warning")) {
[10:21:23.174]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.174]                       if (muffled) 
[10:21:23.174]                         invokeRestart("muffleWarning")
[10:21:23.174]                     }
[10:21:23.174]                     else if (inherits(cond, "condition")) {
[10:21:23.174]                       if (!is.null(pattern)) {
[10:21:23.174]                         computeRestarts <- base::computeRestarts
[10:21:23.174]                         grepl <- base::grepl
[10:21:23.174]                         restarts <- computeRestarts(cond)
[10:21:23.174]                         for (restart in restarts) {
[10:21:23.174]                           name <- restart$name
[10:21:23.174]                           if (is.null(name)) 
[10:21:23.174]                             next
[10:21:23.174]                           if (!grepl(pattern, name)) 
[10:21:23.174]                             next
[10:21:23.174]                           invokeRestart(restart)
[10:21:23.174]                           muffled <- TRUE
[10:21:23.174]                           break
[10:21:23.174]                         }
[10:21:23.174]                       }
[10:21:23.174]                     }
[10:21:23.174]                     invisible(muffled)
[10:21:23.174]                   }
[10:21:23.174]                   muffleCondition(cond)
[10:21:23.174]                 })
[10:21:23.174]             }))
[10:21:23.174]             future::FutureResult(value = ...future.value$value, 
[10:21:23.174]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.174]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.174]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.174]                     ...future.globalenv.names))
[10:21:23.174]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.174]         }, condition = base::local({
[10:21:23.174]             c <- base::c
[10:21:23.174]             inherits <- base::inherits
[10:21:23.174]             invokeRestart <- base::invokeRestart
[10:21:23.174]             length <- base::length
[10:21:23.174]             list <- base::list
[10:21:23.174]             seq.int <- base::seq.int
[10:21:23.174]             signalCondition <- base::signalCondition
[10:21:23.174]             sys.calls <- base::sys.calls
[10:21:23.174]             `[[` <- base::`[[`
[10:21:23.174]             `+` <- base::`+`
[10:21:23.174]             `<<-` <- base::`<<-`
[10:21:23.174]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.174]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.174]                   3L)]
[10:21:23.174]             }
[10:21:23.174]             function(cond) {
[10:21:23.174]                 is_error <- inherits(cond, "error")
[10:21:23.174]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.174]                   NULL)
[10:21:23.174]                 if (is_error) {
[10:21:23.174]                   sessionInformation <- function() {
[10:21:23.174]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.174]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.174]                       search = base::search(), system = base::Sys.info())
[10:21:23.174]                   }
[10:21:23.174]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.174]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.174]                     cond$call), session = sessionInformation(), 
[10:21:23.174]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.174]                   signalCondition(cond)
[10:21:23.174]                 }
[10:21:23.174]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.174]                 "immediateCondition"))) {
[10:21:23.174]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.174]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.174]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.174]                   if (TRUE && !signal) {
[10:21:23.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.174]                     {
[10:21:23.174]                       inherits <- base::inherits
[10:21:23.174]                       invokeRestart <- base::invokeRestart
[10:21:23.174]                       is.null <- base::is.null
[10:21:23.174]                       muffled <- FALSE
[10:21:23.174]                       if (inherits(cond, "message")) {
[10:21:23.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.174]                         if (muffled) 
[10:21:23.174]                           invokeRestart("muffleMessage")
[10:21:23.174]                       }
[10:21:23.174]                       else if (inherits(cond, "warning")) {
[10:21:23.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.174]                         if (muffled) 
[10:21:23.174]                           invokeRestart("muffleWarning")
[10:21:23.174]                       }
[10:21:23.174]                       else if (inherits(cond, "condition")) {
[10:21:23.174]                         if (!is.null(pattern)) {
[10:21:23.174]                           computeRestarts <- base::computeRestarts
[10:21:23.174]                           grepl <- base::grepl
[10:21:23.174]                           restarts <- computeRestarts(cond)
[10:21:23.174]                           for (restart in restarts) {
[10:21:23.174]                             name <- restart$name
[10:21:23.174]                             if (is.null(name)) 
[10:21:23.174]                               next
[10:21:23.174]                             if (!grepl(pattern, name)) 
[10:21:23.174]                               next
[10:21:23.174]                             invokeRestart(restart)
[10:21:23.174]                             muffled <- TRUE
[10:21:23.174]                             break
[10:21:23.174]                           }
[10:21:23.174]                         }
[10:21:23.174]                       }
[10:21:23.174]                       invisible(muffled)
[10:21:23.174]                     }
[10:21:23.174]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.174]                   }
[10:21:23.174]                 }
[10:21:23.174]                 else {
[10:21:23.174]                   if (TRUE) {
[10:21:23.174]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.174]                     {
[10:21:23.174]                       inherits <- base::inherits
[10:21:23.174]                       invokeRestart <- base::invokeRestart
[10:21:23.174]                       is.null <- base::is.null
[10:21:23.174]                       muffled <- FALSE
[10:21:23.174]                       if (inherits(cond, "message")) {
[10:21:23.174]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.174]                         if (muffled) 
[10:21:23.174]                           invokeRestart("muffleMessage")
[10:21:23.174]                       }
[10:21:23.174]                       else if (inherits(cond, "warning")) {
[10:21:23.174]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.174]                         if (muffled) 
[10:21:23.174]                           invokeRestart("muffleWarning")
[10:21:23.174]                       }
[10:21:23.174]                       else if (inherits(cond, "condition")) {
[10:21:23.174]                         if (!is.null(pattern)) {
[10:21:23.174]                           computeRestarts <- base::computeRestarts
[10:21:23.174]                           grepl <- base::grepl
[10:21:23.174]                           restarts <- computeRestarts(cond)
[10:21:23.174]                           for (restart in restarts) {
[10:21:23.174]                             name <- restart$name
[10:21:23.174]                             if (is.null(name)) 
[10:21:23.174]                               next
[10:21:23.174]                             if (!grepl(pattern, name)) 
[10:21:23.174]                               next
[10:21:23.174]                             invokeRestart(restart)
[10:21:23.174]                             muffled <- TRUE
[10:21:23.174]                             break
[10:21:23.174]                           }
[10:21:23.174]                         }
[10:21:23.174]                       }
[10:21:23.174]                       invisible(muffled)
[10:21:23.174]                     }
[10:21:23.174]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.174]                   }
[10:21:23.174]                 }
[10:21:23.174]             }
[10:21:23.174]         }))
[10:21:23.174]     }, error = function(ex) {
[10:21:23.174]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.174]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.174]                 ...future.rng), started = ...future.startTime, 
[10:21:23.174]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.174]             version = "1.8"), class = "FutureResult")
[10:21:23.174]     }, finally = {
[10:21:23.174]         if (!identical(...future.workdir, getwd())) 
[10:21:23.174]             setwd(...future.workdir)
[10:21:23.174]         {
[10:21:23.174]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.174]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.174]             }
[10:21:23.174]             base::options(...future.oldOptions)
[10:21:23.174]             if (.Platform$OS.type == "windows") {
[10:21:23.174]                 old_names <- names(...future.oldEnvVars)
[10:21:23.174]                 envs <- base::Sys.getenv()
[10:21:23.174]                 names <- names(envs)
[10:21:23.174]                 common <- intersect(names, old_names)
[10:21:23.174]                 added <- setdiff(names, old_names)
[10:21:23.174]                 removed <- setdiff(old_names, names)
[10:21:23.174]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.174]                   envs[common]]
[10:21:23.174]                 NAMES <- toupper(changed)
[10:21:23.174]                 args <- list()
[10:21:23.174]                 for (kk in seq_along(NAMES)) {
[10:21:23.174]                   name <- changed[[kk]]
[10:21:23.174]                   NAME <- NAMES[[kk]]
[10:21:23.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.174]                     next
[10:21:23.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.174]                 }
[10:21:23.174]                 NAMES <- toupper(added)
[10:21:23.174]                 for (kk in seq_along(NAMES)) {
[10:21:23.174]                   name <- added[[kk]]
[10:21:23.174]                   NAME <- NAMES[[kk]]
[10:21:23.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.174]                     next
[10:21:23.174]                   args[[name]] <- ""
[10:21:23.174]                 }
[10:21:23.174]                 NAMES <- toupper(removed)
[10:21:23.174]                 for (kk in seq_along(NAMES)) {
[10:21:23.174]                   name <- removed[[kk]]
[10:21:23.174]                   NAME <- NAMES[[kk]]
[10:21:23.174]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.174]                     next
[10:21:23.174]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.174]                 }
[10:21:23.174]                 if (length(args) > 0) 
[10:21:23.174]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.174]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.174]             }
[10:21:23.174]             else {
[10:21:23.174]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.174]             }
[10:21:23.174]             {
[10:21:23.174]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.174]                   0L) {
[10:21:23.174]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.174]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.174]                   base::options(opts)
[10:21:23.174]                 }
[10:21:23.174]                 {
[10:21:23.174]                   {
[10:21:23.174]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.174]                     NULL
[10:21:23.174]                   }
[10:21:23.174]                   options(future.plan = NULL)
[10:21:23.174]                   if (is.na(NA_character_)) 
[10:21:23.174]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.174]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.174]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.174]                     .init = FALSE)
[10:21:23.174]                 }
[10:21:23.174]             }
[10:21:23.174]         }
[10:21:23.174]     })
[10:21:23.174]     if (TRUE) {
[10:21:23.174]         base::sink(type = "output", split = FALSE)
[10:21:23.174]         if (TRUE) {
[10:21:23.174]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.174]         }
[10:21:23.174]         else {
[10:21:23.174]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.174]         }
[10:21:23.174]         base::close(...future.stdout)
[10:21:23.174]         ...future.stdout <- NULL
[10:21:23.174]     }
[10:21:23.174]     ...future.result$conditions <- ...future.conditions
[10:21:23.174]     ...future.result$finished <- base::Sys.time()
[10:21:23.174]     ...future.result
[10:21:23.174] }
[10:21:23.177] requestCore(): workers = 2
[10:21:23.179] MulticoreFuture started
[10:21:23.179] - Launch lazy future ... done
[10:21:23.180] run() for ‘MulticoreFuture’ ... done
[10:21:23.180] getGlobalsAndPackages() ...
[10:21:23.180] Searching for globals...
[10:21:23.180] plan(): Setting new future strategy stack:
[10:21:23.181] 
[10:21:23.181] Searching for globals ... DONE
[10:21:23.180] List of future strategies:
[10:21:23.180] 1. sequential:
[10:21:23.180]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.180]    - tweaked: FALSE
[10:21:23.180]    - call: NULL
[10:21:23.181] - globals: [0] <none>
[10:21:23.181] plan(): nbrOfWorkers() = 1
[10:21:23.181] getGlobalsAndPackages() ... DONE
[10:21:23.182] run() for ‘Future’ ...
[10:21:23.182] - state: ‘created’
[10:21:23.182] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.183] plan(): Setting new future strategy stack:
[10:21:23.183] List of future strategies:
[10:21:23.183] 1. multicore:
[10:21:23.183]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.183]    - tweaked: FALSE
[10:21:23.183]    - call: plan(strategy)
[10:21:23.186] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.186] plan(): nbrOfWorkers() = 2
[10:21:23.186] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:23.186]   - Field: ‘label’
[10:21:23.186]   - Field: ‘local’
[10:21:23.186]   - Field: ‘owner’
[10:21:23.186]   - Field: ‘envir’
[10:21:23.186]   - Field: ‘workers’
[10:21:23.186]   - Field: ‘packages’
[10:21:23.187]   - Field: ‘gc’
[10:21:23.187]   - Field: ‘job’
[10:21:23.187]   - Field: ‘conditions’
[10:21:23.187]   - Field: ‘expr’
[10:21:23.187]   - Field: ‘uuid’
[10:21:23.187]   - Field: ‘seed’
[10:21:23.187]   - Field: ‘version’
[10:21:23.187]   - Field: ‘result’
[10:21:23.188]   - Field: ‘asynchronous’
[10:21:23.188]   - Field: ‘calls’
[10:21:23.188]   - Field: ‘globals’
[10:21:23.188]   - Field: ‘stdout’
[10:21:23.188]   - Field: ‘earlySignal’
[10:21:23.188]   - Field: ‘lazy’
[10:21:23.188]   - Field: ‘state’
[10:21:23.188] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:23.189] - Launch lazy future ...
[10:21:23.189] Packages needed by the future expression (n = 0): <none>
[10:21:23.189] Packages needed by future strategies (n = 0): <none>
[10:21:23.190] {
[10:21:23.190]     {
[10:21:23.190]         {
[10:21:23.190]             ...future.startTime <- base::Sys.time()
[10:21:23.190]             {
[10:21:23.190]                 {
[10:21:23.190]                   {
[10:21:23.190]                     {
[10:21:23.190]                       base::local({
[10:21:23.190]                         has_future <- base::requireNamespace("future", 
[10:21:23.190]                           quietly = TRUE)
[10:21:23.190]                         if (has_future) {
[10:21:23.190]                           ns <- base::getNamespace("future")
[10:21:23.190]                           version <- ns[[".package"]][["version"]]
[10:21:23.190]                           if (is.null(version)) 
[10:21:23.190]                             version <- utils::packageVersion("future")
[10:21:23.190]                         }
[10:21:23.190]                         else {
[10:21:23.190]                           version <- NULL
[10:21:23.190]                         }
[10:21:23.190]                         if (!has_future || version < "1.8.0") {
[10:21:23.190]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.190]                             "", base::R.version$version.string), 
[10:21:23.190]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.190]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.190]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.190]                               "release", "version")], collapse = " "), 
[10:21:23.190]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.190]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.190]                             info)
[10:21:23.190]                           info <- base::paste(info, collapse = "; ")
[10:21:23.190]                           if (!has_future) {
[10:21:23.190]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.190]                               info)
[10:21:23.190]                           }
[10:21:23.190]                           else {
[10:21:23.190]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.190]                               info, version)
[10:21:23.190]                           }
[10:21:23.190]                           base::stop(msg)
[10:21:23.190]                         }
[10:21:23.190]                       })
[10:21:23.190]                     }
[10:21:23.190]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.190]                     base::options(mc.cores = 1L)
[10:21:23.190]                   }
[10:21:23.190]                   ...future.strategy.old <- future::plan("list")
[10:21:23.190]                   options(future.plan = NULL)
[10:21:23.190]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.190]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.190]                 }
[10:21:23.190]                 ...future.workdir <- getwd()
[10:21:23.190]             }
[10:21:23.190]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.190]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.190]         }
[10:21:23.190]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.190]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.190]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.190]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.190]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.190]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.190]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.190]             base::names(...future.oldOptions))
[10:21:23.190]     }
[10:21:23.190]     if (FALSE) {
[10:21:23.190]     }
[10:21:23.190]     else {
[10:21:23.190]         if (TRUE) {
[10:21:23.190]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.190]                 open = "w")
[10:21:23.190]         }
[10:21:23.190]         else {
[10:21:23.190]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.190]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.190]         }
[10:21:23.190]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.190]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.190]             base::sink(type = "output", split = FALSE)
[10:21:23.190]             base::close(...future.stdout)
[10:21:23.190]         }, add = TRUE)
[10:21:23.190]     }
[10:21:23.190]     ...future.frame <- base::sys.nframe()
[10:21:23.190]     ...future.conditions <- base::list()
[10:21:23.190]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.190]     if (FALSE) {
[10:21:23.190]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.190]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.190]     }
[10:21:23.190]     ...future.result <- base::tryCatch({
[10:21:23.190]         base::withCallingHandlers({
[10:21:23.190]             ...future.value <- base::withVisible(base::local({
[10:21:23.190]                 withCallingHandlers({
[10:21:23.190]                   NULL
[10:21:23.190]                 }, immediateCondition = function(cond) {
[10:21:23.190]                   save_rds <- function (object, pathname, ...) 
[10:21:23.190]                   {
[10:21:23.190]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:23.190]                     if (file_test("-f", pathname_tmp)) {
[10:21:23.190]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.190]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:23.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.190]                         fi_tmp[["mtime"]])
[10:21:23.190]                     }
[10:21:23.190]                     tryCatch({
[10:21:23.190]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:23.190]                     }, error = function(ex) {
[10:21:23.190]                       msg <- conditionMessage(ex)
[10:21:23.190]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.190]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:23.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.190]                         fi_tmp[["mtime"]], msg)
[10:21:23.190]                       ex$message <- msg
[10:21:23.190]                       stop(ex)
[10:21:23.190]                     })
[10:21:23.190]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:23.190]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:23.190]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:23.190]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.190]                       fi <- file.info(pathname)
[10:21:23.190]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:23.190]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.190]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:23.190]                         fi[["size"]], fi[["mtime"]])
[10:21:23.190]                       stop(msg)
[10:21:23.190]                     }
[10:21:23.190]                     invisible(pathname)
[10:21:23.190]                   }
[10:21:23.190]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:23.190]                     rootPath = tempdir()) 
[10:21:23.190]                   {
[10:21:23.190]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:23.190]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:23.190]                       tmpdir = path, fileext = ".rds")
[10:21:23.190]                     save_rds(obj, file)
[10:21:23.190]                   }
[10:21:23.190]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:23.190]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.190]                   {
[10:21:23.190]                     inherits <- base::inherits
[10:21:23.190]                     invokeRestart <- base::invokeRestart
[10:21:23.190]                     is.null <- base::is.null
[10:21:23.190]                     muffled <- FALSE
[10:21:23.190]                     if (inherits(cond, "message")) {
[10:21:23.190]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.190]                       if (muffled) 
[10:21:23.190]                         invokeRestart("muffleMessage")
[10:21:23.190]                     }
[10:21:23.190]                     else if (inherits(cond, "warning")) {
[10:21:23.190]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.190]                       if (muffled) 
[10:21:23.190]                         invokeRestart("muffleWarning")
[10:21:23.190]                     }
[10:21:23.190]                     else if (inherits(cond, "condition")) {
[10:21:23.190]                       if (!is.null(pattern)) {
[10:21:23.190]                         computeRestarts <- base::computeRestarts
[10:21:23.190]                         grepl <- base::grepl
[10:21:23.190]                         restarts <- computeRestarts(cond)
[10:21:23.190]                         for (restart in restarts) {
[10:21:23.190]                           name <- restart$name
[10:21:23.190]                           if (is.null(name)) 
[10:21:23.190]                             next
[10:21:23.190]                           if (!grepl(pattern, name)) 
[10:21:23.190]                             next
[10:21:23.190]                           invokeRestart(restart)
[10:21:23.190]                           muffled <- TRUE
[10:21:23.190]                           break
[10:21:23.190]                         }
[10:21:23.190]                       }
[10:21:23.190]                     }
[10:21:23.190]                     invisible(muffled)
[10:21:23.190]                   }
[10:21:23.190]                   muffleCondition(cond)
[10:21:23.190]                 })
[10:21:23.190]             }))
[10:21:23.190]             future::FutureResult(value = ...future.value$value, 
[10:21:23.190]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.190]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.190]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.190]                     ...future.globalenv.names))
[10:21:23.190]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.190]         }, condition = base::local({
[10:21:23.190]             c <- base::c
[10:21:23.190]             inherits <- base::inherits
[10:21:23.190]             invokeRestart <- base::invokeRestart
[10:21:23.190]             length <- base::length
[10:21:23.190]             list <- base::list
[10:21:23.190]             seq.int <- base::seq.int
[10:21:23.190]             signalCondition <- base::signalCondition
[10:21:23.190]             sys.calls <- base::sys.calls
[10:21:23.190]             `[[` <- base::`[[`
[10:21:23.190]             `+` <- base::`+`
[10:21:23.190]             `<<-` <- base::`<<-`
[10:21:23.190]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.190]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.190]                   3L)]
[10:21:23.190]             }
[10:21:23.190]             function(cond) {
[10:21:23.190]                 is_error <- inherits(cond, "error")
[10:21:23.190]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.190]                   NULL)
[10:21:23.190]                 if (is_error) {
[10:21:23.190]                   sessionInformation <- function() {
[10:21:23.190]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.190]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.190]                       search = base::search(), system = base::Sys.info())
[10:21:23.190]                   }
[10:21:23.190]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.190]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.190]                     cond$call), session = sessionInformation(), 
[10:21:23.190]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.190]                   signalCondition(cond)
[10:21:23.190]                 }
[10:21:23.190]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.190]                 "immediateCondition"))) {
[10:21:23.190]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.190]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.190]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.190]                   if (TRUE && !signal) {
[10:21:23.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.190]                     {
[10:21:23.190]                       inherits <- base::inherits
[10:21:23.190]                       invokeRestart <- base::invokeRestart
[10:21:23.190]                       is.null <- base::is.null
[10:21:23.190]                       muffled <- FALSE
[10:21:23.190]                       if (inherits(cond, "message")) {
[10:21:23.190]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.190]                         if (muffled) 
[10:21:23.190]                           invokeRestart("muffleMessage")
[10:21:23.190]                       }
[10:21:23.190]                       else if (inherits(cond, "warning")) {
[10:21:23.190]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.190]                         if (muffled) 
[10:21:23.190]                           invokeRestart("muffleWarning")
[10:21:23.190]                       }
[10:21:23.190]                       else if (inherits(cond, "condition")) {
[10:21:23.190]                         if (!is.null(pattern)) {
[10:21:23.190]                           computeRestarts <- base::computeRestarts
[10:21:23.190]                           grepl <- base::grepl
[10:21:23.190]                           restarts <- computeRestarts(cond)
[10:21:23.190]                           for (restart in restarts) {
[10:21:23.190]                             name <- restart$name
[10:21:23.190]                             if (is.null(name)) 
[10:21:23.190]                               next
[10:21:23.190]                             if (!grepl(pattern, name)) 
[10:21:23.190]                               next
[10:21:23.190]                             invokeRestart(restart)
[10:21:23.190]                             muffled <- TRUE
[10:21:23.190]                             break
[10:21:23.190]                           }
[10:21:23.190]                         }
[10:21:23.190]                       }
[10:21:23.190]                       invisible(muffled)
[10:21:23.190]                     }
[10:21:23.190]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.190]                   }
[10:21:23.190]                 }
[10:21:23.190]                 else {
[10:21:23.190]                   if (TRUE) {
[10:21:23.190]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.190]                     {
[10:21:23.190]                       inherits <- base::inherits
[10:21:23.190]                       invokeRestart <- base::invokeRestart
[10:21:23.190]                       is.null <- base::is.null
[10:21:23.190]                       muffled <- FALSE
[10:21:23.190]                       if (inherits(cond, "message")) {
[10:21:23.190]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.190]                         if (muffled) 
[10:21:23.190]                           invokeRestart("muffleMessage")
[10:21:23.190]                       }
[10:21:23.190]                       else if (inherits(cond, "warning")) {
[10:21:23.190]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.190]                         if (muffled) 
[10:21:23.190]                           invokeRestart("muffleWarning")
[10:21:23.190]                       }
[10:21:23.190]                       else if (inherits(cond, "condition")) {
[10:21:23.190]                         if (!is.null(pattern)) {
[10:21:23.190]                           computeRestarts <- base::computeRestarts
[10:21:23.190]                           grepl <- base::grepl
[10:21:23.190]                           restarts <- computeRestarts(cond)
[10:21:23.190]                           for (restart in restarts) {
[10:21:23.190]                             name <- restart$name
[10:21:23.190]                             if (is.null(name)) 
[10:21:23.190]                               next
[10:21:23.190]                             if (!grepl(pattern, name)) 
[10:21:23.190]                               next
[10:21:23.190]                             invokeRestart(restart)
[10:21:23.190]                             muffled <- TRUE
[10:21:23.190]                             break
[10:21:23.190]                           }
[10:21:23.190]                         }
[10:21:23.190]                       }
[10:21:23.190]                       invisible(muffled)
[10:21:23.190]                     }
[10:21:23.190]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.190]                   }
[10:21:23.190]                 }
[10:21:23.190]             }
[10:21:23.190]         }))
[10:21:23.190]     }, error = function(ex) {
[10:21:23.190]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.190]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.190]                 ...future.rng), started = ...future.startTime, 
[10:21:23.190]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.190]             version = "1.8"), class = "FutureResult")
[10:21:23.190]     }, finally = {
[10:21:23.190]         if (!identical(...future.workdir, getwd())) 
[10:21:23.190]             setwd(...future.workdir)
[10:21:23.190]         {
[10:21:23.190]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.190]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.190]             }
[10:21:23.190]             base::options(...future.oldOptions)
[10:21:23.190]             if (.Platform$OS.type == "windows") {
[10:21:23.190]                 old_names <- names(...future.oldEnvVars)
[10:21:23.190]                 envs <- base::Sys.getenv()
[10:21:23.190]                 names <- names(envs)
[10:21:23.190]                 common <- intersect(names, old_names)
[10:21:23.190]                 added <- setdiff(names, old_names)
[10:21:23.190]                 removed <- setdiff(old_names, names)
[10:21:23.190]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.190]                   envs[common]]
[10:21:23.190]                 NAMES <- toupper(changed)
[10:21:23.190]                 args <- list()
[10:21:23.190]                 for (kk in seq_along(NAMES)) {
[10:21:23.190]                   name <- changed[[kk]]
[10:21:23.190]                   NAME <- NAMES[[kk]]
[10:21:23.190]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.190]                     next
[10:21:23.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.190]                 }
[10:21:23.190]                 NAMES <- toupper(added)
[10:21:23.190]                 for (kk in seq_along(NAMES)) {
[10:21:23.190]                   name <- added[[kk]]
[10:21:23.190]                   NAME <- NAMES[[kk]]
[10:21:23.190]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.190]                     next
[10:21:23.190]                   args[[name]] <- ""
[10:21:23.190]                 }
[10:21:23.190]                 NAMES <- toupper(removed)
[10:21:23.190]                 for (kk in seq_along(NAMES)) {
[10:21:23.190]                   name <- removed[[kk]]
[10:21:23.190]                   NAME <- NAMES[[kk]]
[10:21:23.190]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.190]                     next
[10:21:23.190]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.190]                 }
[10:21:23.190]                 if (length(args) > 0) 
[10:21:23.190]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.190]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.190]             }
[10:21:23.190]             else {
[10:21:23.190]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.190]             }
[10:21:23.190]             {
[10:21:23.190]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.190]                   0L) {
[10:21:23.190]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.190]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.190]                   base::options(opts)
[10:21:23.190]                 }
[10:21:23.190]                 {
[10:21:23.190]                   {
[10:21:23.190]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.190]                     NULL
[10:21:23.190]                   }
[10:21:23.190]                   options(future.plan = NULL)
[10:21:23.190]                   if (is.na(NA_character_)) 
[10:21:23.190]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.190]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.190]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.190]                     .init = FALSE)
[10:21:23.190]                 }
[10:21:23.190]             }
[10:21:23.190]         }
[10:21:23.190]     })
[10:21:23.190]     if (TRUE) {
[10:21:23.190]         base::sink(type = "output", split = FALSE)
[10:21:23.190]         if (TRUE) {
[10:21:23.190]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.190]         }
[10:21:23.190]         else {
[10:21:23.190]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.190]         }
[10:21:23.190]         base::close(...future.stdout)
[10:21:23.190]         ...future.stdout <- NULL
[10:21:23.190]     }
[10:21:23.190]     ...future.result$conditions <- ...future.conditions
[10:21:23.190]     ...future.result$finished <- base::Sys.time()
[10:21:23.190]     ...future.result
[10:21:23.190] }
[10:21:23.193] requestCore(): workers = 2
[10:21:23.196] MulticoreFuture started
[10:21:23.196] - Launch lazy future ... done
[10:21:23.197] run() for ‘MulticoreFuture’ ... done
[10:21:23.197] plan(): Setting new future strategy stack:
[10:21:23.197] getGlobalsAndPackages() ...
[10:21:23.198] Searching for globals...
[10:21:23.197] List of future strategies:
[10:21:23.197] 1. sequential:
[10:21:23.197]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.197]    - tweaked: FALSE
[10:21:23.197]    - call: NULL
[10:21:23.198] plan(): nbrOfWorkers() = 1
[10:21:23.199] - globals found: [1] ‘{’
[10:21:23.199] Searching for globals ... DONE
[10:21:23.199] Resolving globals: FALSE
[10:21:23.200] 
[10:21:23.200] 
[10:21:23.200] getGlobalsAndPackages() ... DONE
[10:21:23.200] plan(): Setting new future strategy stack:
[10:21:23.200] run() for ‘Future’ ...
[10:21:23.201] - state: ‘created’
[10:21:23.201] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.200] List of future strategies:
[10:21:23.200] 1. multicore:
[10:21:23.200]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.200]    - tweaked: FALSE
[10:21:23.200]    - call: plan(strategy)
[10:21:23.203] plan(): nbrOfWorkers() = 2
[10:21:23.204] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.204] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:23.204]   - Field: ‘label’
[10:21:23.204]   - Field: ‘local’
[10:21:23.204]   - Field: ‘owner’
[10:21:23.204]   - Field: ‘envir’
[10:21:23.205]   - Field: ‘workers’
[10:21:23.205]   - Field: ‘packages’
[10:21:23.205]   - Field: ‘gc’
[10:21:23.205]   - Field: ‘job’
[10:21:23.205]   - Field: ‘conditions’
[10:21:23.205]   - Field: ‘expr’
[10:21:23.205]   - Field: ‘uuid’
[10:21:23.206]   - Field: ‘seed’
[10:21:23.206]   - Field: ‘version’
[10:21:23.206]   - Field: ‘result’
[10:21:23.206]   - Field: ‘asynchronous’
[10:21:23.206]   - Field: ‘calls’
[10:21:23.206]   - Field: ‘globals’
[10:21:23.206]   - Field: ‘stdout’
[10:21:23.206]   - Field: ‘earlySignal’
[10:21:23.206]   - Field: ‘lazy’
[10:21:23.207]   - Field: ‘state’
[10:21:23.207] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:23.207] - Launch lazy future ...
[10:21:23.207] Packages needed by the future expression (n = 0): <none>
[10:21:23.208] Packages needed by future strategies (n = 0): <none>
[10:21:23.208] {
[10:21:23.208]     {
[10:21:23.208]         {
[10:21:23.208]             ...future.startTime <- base::Sys.time()
[10:21:23.208]             {
[10:21:23.208]                 {
[10:21:23.208]                   {
[10:21:23.208]                     {
[10:21:23.208]                       base::local({
[10:21:23.208]                         has_future <- base::requireNamespace("future", 
[10:21:23.208]                           quietly = TRUE)
[10:21:23.208]                         if (has_future) {
[10:21:23.208]                           ns <- base::getNamespace("future")
[10:21:23.208]                           version <- ns[[".package"]][["version"]]
[10:21:23.208]                           if (is.null(version)) 
[10:21:23.208]                             version <- utils::packageVersion("future")
[10:21:23.208]                         }
[10:21:23.208]                         else {
[10:21:23.208]                           version <- NULL
[10:21:23.208]                         }
[10:21:23.208]                         if (!has_future || version < "1.8.0") {
[10:21:23.208]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.208]                             "", base::R.version$version.string), 
[10:21:23.208]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.208]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.208]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.208]                               "release", "version")], collapse = " "), 
[10:21:23.208]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.208]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.208]                             info)
[10:21:23.208]                           info <- base::paste(info, collapse = "; ")
[10:21:23.208]                           if (!has_future) {
[10:21:23.208]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.208]                               info)
[10:21:23.208]                           }
[10:21:23.208]                           else {
[10:21:23.208]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.208]                               info, version)
[10:21:23.208]                           }
[10:21:23.208]                           base::stop(msg)
[10:21:23.208]                         }
[10:21:23.208]                       })
[10:21:23.208]                     }
[10:21:23.208]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.208]                     base::options(mc.cores = 1L)
[10:21:23.208]                   }
[10:21:23.208]                   ...future.strategy.old <- future::plan("list")
[10:21:23.208]                   options(future.plan = NULL)
[10:21:23.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.208]                 }
[10:21:23.208]                 ...future.workdir <- getwd()
[10:21:23.208]             }
[10:21:23.208]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.208]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.208]         }
[10:21:23.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.208]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.208]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.208]             base::names(...future.oldOptions))
[10:21:23.208]     }
[10:21:23.208]     if (FALSE) {
[10:21:23.208]     }
[10:21:23.208]     else {
[10:21:23.208]         if (TRUE) {
[10:21:23.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.208]                 open = "w")
[10:21:23.208]         }
[10:21:23.208]         else {
[10:21:23.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.208]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.208]         }
[10:21:23.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.208]             base::sink(type = "output", split = FALSE)
[10:21:23.208]             base::close(...future.stdout)
[10:21:23.208]         }, add = TRUE)
[10:21:23.208]     }
[10:21:23.208]     ...future.frame <- base::sys.nframe()
[10:21:23.208]     ...future.conditions <- base::list()
[10:21:23.208]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.208]     if (FALSE) {
[10:21:23.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.208]     }
[10:21:23.208]     ...future.result <- base::tryCatch({
[10:21:23.208]         base::withCallingHandlers({
[10:21:23.208]             ...future.value <- base::withVisible(base::local({
[10:21:23.208]                 withCallingHandlers({
[10:21:23.208]                   {
[10:21:23.208]                     4
[10:21:23.208]                   }
[10:21:23.208]                 }, immediateCondition = function(cond) {
[10:21:23.208]                   save_rds <- function (object, pathname, ...) 
[10:21:23.208]                   {
[10:21:23.208]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:23.208]                     if (file_test("-f", pathname_tmp)) {
[10:21:23.208]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.208]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:23.208]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.208]                         fi_tmp[["mtime"]])
[10:21:23.208]                     }
[10:21:23.208]                     tryCatch({
[10:21:23.208]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:23.208]                     }, error = function(ex) {
[10:21:23.208]                       msg <- conditionMessage(ex)
[10:21:23.208]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.208]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:23.208]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.208]                         fi_tmp[["mtime"]], msg)
[10:21:23.208]                       ex$message <- msg
[10:21:23.208]                       stop(ex)
[10:21:23.208]                     })
[10:21:23.208]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:23.208]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:23.208]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:23.208]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.208]                       fi <- file.info(pathname)
[10:21:23.208]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:23.208]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.208]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:23.208]                         fi[["size"]], fi[["mtime"]])
[10:21:23.208]                       stop(msg)
[10:21:23.208]                     }
[10:21:23.208]                     invisible(pathname)
[10:21:23.208]                   }
[10:21:23.208]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:23.208]                     rootPath = tempdir()) 
[10:21:23.208]                   {
[10:21:23.208]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:23.208]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:23.208]                       tmpdir = path, fileext = ".rds")
[10:21:23.208]                     save_rds(obj, file)
[10:21:23.208]                   }
[10:21:23.208]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:23.208]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.208]                   {
[10:21:23.208]                     inherits <- base::inherits
[10:21:23.208]                     invokeRestart <- base::invokeRestart
[10:21:23.208]                     is.null <- base::is.null
[10:21:23.208]                     muffled <- FALSE
[10:21:23.208]                     if (inherits(cond, "message")) {
[10:21:23.208]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.208]                       if (muffled) 
[10:21:23.208]                         invokeRestart("muffleMessage")
[10:21:23.208]                     }
[10:21:23.208]                     else if (inherits(cond, "warning")) {
[10:21:23.208]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.208]                       if (muffled) 
[10:21:23.208]                         invokeRestart("muffleWarning")
[10:21:23.208]                     }
[10:21:23.208]                     else if (inherits(cond, "condition")) {
[10:21:23.208]                       if (!is.null(pattern)) {
[10:21:23.208]                         computeRestarts <- base::computeRestarts
[10:21:23.208]                         grepl <- base::grepl
[10:21:23.208]                         restarts <- computeRestarts(cond)
[10:21:23.208]                         for (restart in restarts) {
[10:21:23.208]                           name <- restart$name
[10:21:23.208]                           if (is.null(name)) 
[10:21:23.208]                             next
[10:21:23.208]                           if (!grepl(pattern, name)) 
[10:21:23.208]                             next
[10:21:23.208]                           invokeRestart(restart)
[10:21:23.208]                           muffled <- TRUE
[10:21:23.208]                           break
[10:21:23.208]                         }
[10:21:23.208]                       }
[10:21:23.208]                     }
[10:21:23.208]                     invisible(muffled)
[10:21:23.208]                   }
[10:21:23.208]                   muffleCondition(cond)
[10:21:23.208]                 })
[10:21:23.208]             }))
[10:21:23.208]             future::FutureResult(value = ...future.value$value, 
[10:21:23.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.208]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.208]                     ...future.globalenv.names))
[10:21:23.208]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.208]         }, condition = base::local({
[10:21:23.208]             c <- base::c
[10:21:23.208]             inherits <- base::inherits
[10:21:23.208]             invokeRestart <- base::invokeRestart
[10:21:23.208]             length <- base::length
[10:21:23.208]             list <- base::list
[10:21:23.208]             seq.int <- base::seq.int
[10:21:23.208]             signalCondition <- base::signalCondition
[10:21:23.208]             sys.calls <- base::sys.calls
[10:21:23.208]             `[[` <- base::`[[`
[10:21:23.208]             `+` <- base::`+`
[10:21:23.208]             `<<-` <- base::`<<-`
[10:21:23.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.208]                   3L)]
[10:21:23.208]             }
[10:21:23.208]             function(cond) {
[10:21:23.208]                 is_error <- inherits(cond, "error")
[10:21:23.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.208]                   NULL)
[10:21:23.208]                 if (is_error) {
[10:21:23.208]                   sessionInformation <- function() {
[10:21:23.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.208]                       search = base::search(), system = base::Sys.info())
[10:21:23.208]                   }
[10:21:23.208]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.208]                     cond$call), session = sessionInformation(), 
[10:21:23.208]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.208]                   signalCondition(cond)
[10:21:23.208]                 }
[10:21:23.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.208]                 "immediateCondition"))) {
[10:21:23.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.208]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.208]                   if (TRUE && !signal) {
[10:21:23.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.208]                     {
[10:21:23.208]                       inherits <- base::inherits
[10:21:23.208]                       invokeRestart <- base::invokeRestart
[10:21:23.208]                       is.null <- base::is.null
[10:21:23.208]                       muffled <- FALSE
[10:21:23.208]                       if (inherits(cond, "message")) {
[10:21:23.208]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.208]                         if (muffled) 
[10:21:23.208]                           invokeRestart("muffleMessage")
[10:21:23.208]                       }
[10:21:23.208]                       else if (inherits(cond, "warning")) {
[10:21:23.208]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.208]                         if (muffled) 
[10:21:23.208]                           invokeRestart("muffleWarning")
[10:21:23.208]                       }
[10:21:23.208]                       else if (inherits(cond, "condition")) {
[10:21:23.208]                         if (!is.null(pattern)) {
[10:21:23.208]                           computeRestarts <- base::computeRestarts
[10:21:23.208]                           grepl <- base::grepl
[10:21:23.208]                           restarts <- computeRestarts(cond)
[10:21:23.208]                           for (restart in restarts) {
[10:21:23.208]                             name <- restart$name
[10:21:23.208]                             if (is.null(name)) 
[10:21:23.208]                               next
[10:21:23.208]                             if (!grepl(pattern, name)) 
[10:21:23.208]                               next
[10:21:23.208]                             invokeRestart(restart)
[10:21:23.208]                             muffled <- TRUE
[10:21:23.208]                             break
[10:21:23.208]                           }
[10:21:23.208]                         }
[10:21:23.208]                       }
[10:21:23.208]                       invisible(muffled)
[10:21:23.208]                     }
[10:21:23.208]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.208]                   }
[10:21:23.208]                 }
[10:21:23.208]                 else {
[10:21:23.208]                   if (TRUE) {
[10:21:23.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.208]                     {
[10:21:23.208]                       inherits <- base::inherits
[10:21:23.208]                       invokeRestart <- base::invokeRestart
[10:21:23.208]                       is.null <- base::is.null
[10:21:23.208]                       muffled <- FALSE
[10:21:23.208]                       if (inherits(cond, "message")) {
[10:21:23.208]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.208]                         if (muffled) 
[10:21:23.208]                           invokeRestart("muffleMessage")
[10:21:23.208]                       }
[10:21:23.208]                       else if (inherits(cond, "warning")) {
[10:21:23.208]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.208]                         if (muffled) 
[10:21:23.208]                           invokeRestart("muffleWarning")
[10:21:23.208]                       }
[10:21:23.208]                       else if (inherits(cond, "condition")) {
[10:21:23.208]                         if (!is.null(pattern)) {
[10:21:23.208]                           computeRestarts <- base::computeRestarts
[10:21:23.208]                           grepl <- base::grepl
[10:21:23.208]                           restarts <- computeRestarts(cond)
[10:21:23.208]                           for (restart in restarts) {
[10:21:23.208]                             name <- restart$name
[10:21:23.208]                             if (is.null(name)) 
[10:21:23.208]                               next
[10:21:23.208]                             if (!grepl(pattern, name)) 
[10:21:23.208]                               next
[10:21:23.208]                             invokeRestart(restart)
[10:21:23.208]                             muffled <- TRUE
[10:21:23.208]                             break
[10:21:23.208]                           }
[10:21:23.208]                         }
[10:21:23.208]                       }
[10:21:23.208]                       invisible(muffled)
[10:21:23.208]                     }
[10:21:23.208]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.208]                   }
[10:21:23.208]                 }
[10:21:23.208]             }
[10:21:23.208]         }))
[10:21:23.208]     }, error = function(ex) {
[10:21:23.208]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.208]                 ...future.rng), started = ...future.startTime, 
[10:21:23.208]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.208]             version = "1.8"), class = "FutureResult")
[10:21:23.208]     }, finally = {
[10:21:23.208]         if (!identical(...future.workdir, getwd())) 
[10:21:23.208]             setwd(...future.workdir)
[10:21:23.208]         {
[10:21:23.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.208]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.208]             }
[10:21:23.208]             base::options(...future.oldOptions)
[10:21:23.208]             if (.Platform$OS.type == "windows") {
[10:21:23.208]                 old_names <- names(...future.oldEnvVars)
[10:21:23.208]                 envs <- base::Sys.getenv()
[10:21:23.208]                 names <- names(envs)
[10:21:23.208]                 common <- intersect(names, old_names)
[10:21:23.208]                 added <- setdiff(names, old_names)
[10:21:23.208]                 removed <- setdiff(old_names, names)
[10:21:23.208]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.208]                   envs[common]]
[10:21:23.208]                 NAMES <- toupper(changed)
[10:21:23.208]                 args <- list()
[10:21:23.208]                 for (kk in seq_along(NAMES)) {
[10:21:23.208]                   name <- changed[[kk]]
[10:21:23.208]                   NAME <- NAMES[[kk]]
[10:21:23.208]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.208]                     next
[10:21:23.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.208]                 }
[10:21:23.208]                 NAMES <- toupper(added)
[10:21:23.208]                 for (kk in seq_along(NAMES)) {
[10:21:23.208]                   name <- added[[kk]]
[10:21:23.208]                   NAME <- NAMES[[kk]]
[10:21:23.208]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.208]                     next
[10:21:23.208]                   args[[name]] <- ""
[10:21:23.208]                 }
[10:21:23.208]                 NAMES <- toupper(removed)
[10:21:23.208]                 for (kk in seq_along(NAMES)) {
[10:21:23.208]                   name <- removed[[kk]]
[10:21:23.208]                   NAME <- NAMES[[kk]]
[10:21:23.208]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.208]                     next
[10:21:23.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.208]                 }
[10:21:23.208]                 if (length(args) > 0) 
[10:21:23.208]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.208]             }
[10:21:23.208]             else {
[10:21:23.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.208]             }
[10:21:23.208]             {
[10:21:23.208]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.208]                   0L) {
[10:21:23.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.208]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.208]                   base::options(opts)
[10:21:23.208]                 }
[10:21:23.208]                 {
[10:21:23.208]                   {
[10:21:23.208]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.208]                     NULL
[10:21:23.208]                   }
[10:21:23.208]                   options(future.plan = NULL)
[10:21:23.208]                   if (is.na(NA_character_)) 
[10:21:23.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.208]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.208]                     .init = FALSE)
[10:21:23.208]                 }
[10:21:23.208]             }
[10:21:23.208]         }
[10:21:23.208]     })
[10:21:23.208]     if (TRUE) {
[10:21:23.208]         base::sink(type = "output", split = FALSE)
[10:21:23.208]         if (TRUE) {
[10:21:23.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.208]         }
[10:21:23.208]         else {
[10:21:23.208]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.208]         }
[10:21:23.208]         base::close(...future.stdout)
[10:21:23.208]         ...future.stdout <- NULL
[10:21:23.208]     }
[10:21:23.208]     ...future.result$conditions <- ...future.conditions
[10:21:23.208]     ...future.result$finished <- base::Sys.time()
[10:21:23.208]     ...future.result
[10:21:23.208] }
[10:21:23.211] requestCore(): workers = 2
[10:21:23.212] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:23.222] result() for MulticoreFuture ...
[10:21:23.223] result() for MulticoreFuture ...
[10:21:23.223] result() for MulticoreFuture ... done
[10:21:23.224] result() for MulticoreFuture ... done
[10:21:23.224] result() for MulticoreFuture ...
[10:21:23.224] result() for MulticoreFuture ... done
[10:21:23.227] MulticoreFuture started
[10:21:23.227] - Launch lazy future ... done
[10:21:23.227] run() for ‘MulticoreFuture’ ... done
[10:21:23.228] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55e8e6969878> 
[10:21:23.228] List of future strategies:
[10:21:23.228] 1. sequential:
[10:21:23.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.228]    - tweaked: FALSE
[10:21:23.228]    - call: NULL
[10:21:23.230] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55e8e74c4c90> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=[10:21:23.233] plan(): Setting new future strategy stack:
List of 3
  ..$ :[10:21:23.233] List of future strategies:
[10:21:23.233] 1. multicore:
[10:21:23.233]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.233]    - tweaked: FALSE
[10:21:23.233]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:21:23.238] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:23.252] resolve() on list environment ...
[10:21:23.252]  recursive: 0
[10:21:23.254]  length: 6
[10:21:23.254]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:23.254] signalConditionsASAP(numeric, pos=1) ...
[10:21:23.254] - nx: 6
[10:21:23.254] - relay: TRUE
[10:21:23.254] - stdout: TRUE
[10:21:23.254] - signal: TRUE
[10:21:23.254] - resignal: FALSE
[10:21:23.255] - force: TRUE
[10:21:23.255] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.255] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.255]  - until=2
[10:21:23.255]  - relaying element #2
[10:21:23.255] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.255] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.255] signalConditionsASAP(NULL, pos=1) ... done
[10:21:23.256]  length: 5 (resolved future 1)
[10:21:23.256] Future #2
[10:21:23.256] result() for MulticoreFuture ...
[10:21:23.256] result() for MulticoreFuture ... done
[10:21:23.256] result() for MulticoreFuture ...
[10:21:23.256] result() for MulticoreFuture ... done
[10:21:23.256] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:23.256] - nx: 6
[10:21:23.257] - relay: TRUE
[10:21:23.257] - stdout: TRUE
[10:21:23.257] - signal: TRUE
[10:21:23.257] - resignal: FALSE
[10:21:23.257] - force: TRUE
[10:21:23.257] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.257] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.257]  - until=2
[10:21:23.257]  - relaying element #2
[10:21:23.258] result() for MulticoreFuture ...
[10:21:23.258] result() for MulticoreFuture ... done
[10:21:23.258] result() for MulticoreFuture ...
[10:21:23.258] result() for MulticoreFuture ... done
[10:21:23.258] result() for MulticoreFuture ...
[10:21:23.258] result() for MulticoreFuture ... done
[10:21:23.258] result() for MulticoreFuture ...
[10:21:23.258] result() for MulticoreFuture ... done
[10:21:23.259] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.259] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.259] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:23.259]  length: 4 (resolved future 2)
[10:21:23.259] Future #3
[10:21:23.259] result() for MulticoreFuture ...
[10:21:23.260] result() for MulticoreFuture ...
[10:21:23.260] result() for MulticoreFuture ... done
[10:21:23.260] result() for MulticoreFuture ... done
[10:21:23.261] result() for MulticoreFuture ...
[10:21:23.261] result() for MulticoreFuture ... done
[10:21:23.261] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:23.261] - nx: 6
[10:21:23.261] - relay: TRUE
[10:21:23.261] - stdout: TRUE
[10:21:23.261] - signal: TRUE
[10:21:23.261] - resignal: FALSE
[10:21:23.262] - force: TRUE
[10:21:23.262] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.262] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.262]  - until=3
[10:21:23.262]  - relaying element #3
[10:21:23.262] result() for MulticoreFuture ...
[10:21:23.262] result() for MulticoreFuture ... done
[10:21:23.262] result() for MulticoreFuture ...
[10:21:23.262] result() for MulticoreFuture ... done
[10:21:23.263] result() for MulticoreFuture ...
[10:21:23.263] result() for MulticoreFuture ... done
[10:21:23.263] result() for MulticoreFuture ...
[10:21:23.263] result() for MulticoreFuture ... done
[10:21:23.263] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.263] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.263] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:23.264]  length: 3 (resolved future 3)
[10:21:23.264] Future #4
[10:21:23.264] result() for MulticoreFuture ...
[10:21:23.265] result() for MulticoreFuture ...
[10:21:23.265] result() for MulticoreFuture ... done
[10:21:23.265] result() for MulticoreFuture ... done
[10:21:23.265] result() for MulticoreFuture ...
[10:21:23.265] result() for MulticoreFuture ... done
[10:21:23.266] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:23.266] - nx: 6
[10:21:23.266] - relay: TRUE
[10:21:23.266] - stdout: TRUE
[10:21:23.266] - signal: TRUE
[10:21:23.266] - resignal: FALSE
[10:21:23.266] - force: TRUE
[10:21:23.267] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.267] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.267]  - until=4
[10:21:23.267]  - relaying element #4
[10:21:23.267] result() for MulticoreFuture ...
[10:21:23.267] result() for MulticoreFuture ... done
[10:21:23.268] result() for MulticoreFuture ...
[10:21:23.268] result() for MulticoreFuture ... done
[10:21:23.268] result() for MulticoreFuture ...
[10:21:23.268] result() for MulticoreFuture ... done
[10:21:23.268] result() for MulticoreFuture ...
[10:21:23.268] result() for MulticoreFuture ... done
[10:21:23.269] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.269] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.269] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:23.269]  length: 2 (resolved future 4)
[10:21:23.269] signalConditionsASAP(NULL, pos=5) ...
[10:21:23.269] - nx: 6
[10:21:23.269] - relay: TRUE
[10:21:23.270] - stdout: TRUE
[10:21:23.270] - signal: TRUE
[10:21:23.270] - resignal: FALSE
[10:21:23.270] - force: TRUE
[10:21:23.270] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.270] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.270]  - until=6
[10:21:23.271]  - relaying element #6
[10:21:23.271] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:23.271] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.271] signalConditionsASAP(NULL, pos=5) ... done
[10:21:23.271]  length: 1 (resolved future 5)
[10:21:23.271] signalConditionsASAP(numeric, pos=6) ...
[10:21:23.271] - nx: 6
[10:21:23.271] - relay: TRUE
[10:21:23.271] - stdout: TRUE
[10:21:23.272] - signal: TRUE
[10:21:23.272] - resignal: FALSE
[10:21:23.272] - force: TRUE
[10:21:23.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:23.272] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.272]  - until=6
[10:21:23.272] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.272] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.272] signalConditionsASAP(numeric, pos=6) ... done
[10:21:23.273]  length: 0 (resolved future 6)
[10:21:23.273] Relaying remaining futures
[10:21:23.273] signalConditionsASAP(NULL, pos=0) ...
[10:21:23.273] - nx: 6
[10:21:23.273] - relay: TRUE
[10:21:23.273] - stdout: TRUE
[10:21:23.273] - signal: TRUE
[10:21:23.273] - resignal: FALSE
[10:21:23.273] - force: TRUE
[10:21:23.273] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.273] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:23.274] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.274] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.274] signalConditionsASAP(NULL, pos=0) ... done
[10:21:23.274] resolve() on list environment ... DONE
[10:21:23.274] result() for MulticoreFuture ...
[10:21:23.274] result() for MulticoreFuture ... done
[10:21:23.274] result() for MulticoreFuture ...
[10:21:23.274] result() for MulticoreFuture ... done
[10:21:23.275] result() for MulticoreFuture ...
[10:21:23.275] result() for MulticoreFuture ... done
[10:21:23.275] result() for MulticoreFuture ...
[10:21:23.275] result() for MulticoreFuture ... done
[10:21:23.275] result() for MulticoreFuture ...
[10:21:23.275] result() for MulticoreFuture ... done
[10:21:23.275] result() for MulticoreFuture ...
[10:21:23.275] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e59c7880> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:21:23.278] getGlobalsAndPackages() ...
[10:21:23.278] Searching for globals...
[10:21:23.279] 
[10:21:23.279] Searching for globals ... DONE
[10:21:23.279] - globals: [0] <none>
[10:21:23.279] getGlobalsAndPackages() ... DONE
[10:21:23.279] run() for ‘Future’ ...
[10:21:23.279] - state: ‘created’
[10:21:23.280] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.282] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.282] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:23.282]   - Field: ‘label’
[10:21:23.282]   - Field: ‘local’
[10:21:23.282]   - Field: ‘owner’
[10:21:23.282]   - Field: ‘envir’
[10:21:23.282]   - Field: ‘workers’
[10:21:23.283]   - Field: ‘packages’
[10:21:23.283]   - Field: ‘gc’
[10:21:23.283]   - Field: ‘job’
[10:21:23.283]   - Field: ‘conditions’
[10:21:23.283]   - Field: ‘expr’
[10:21:23.283]   - Field: ‘uuid’
[10:21:23.283]   - Field: ‘seed’
[10:21:23.283]   - Field: ‘version’
[10:21:23.283]   - Field: ‘result’
[10:21:23.284]   - Field: ‘asynchronous’
[10:21:23.284]   - Field: ‘calls’
[10:21:23.284]   - Field: ‘globals’
[10:21:23.284]   - Field: ‘stdout’
[10:21:23.284]   - Field: ‘earlySignal’
[10:21:23.284]   - Field: ‘lazy’
[10:21:23.284]   - Field: ‘state’
[10:21:23.284] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:23.284] - Launch lazy future ...
[10:21:23.285] Packages needed by the future expression (n = 0): <none>
[10:21:23.285] Packages needed by future strategies (n = 0): <none>
[10:21:23.285] {
[10:21:23.285]     {
[10:21:23.285]         {
[10:21:23.285]             ...future.startTime <- base::Sys.time()
[10:21:23.285]             {
[10:21:23.285]                 {
[10:21:23.285]                   {
[10:21:23.285]                     {
[10:21:23.285]                       base::local({
[10:21:23.285]                         has_future <- base::requireNamespace("future", 
[10:21:23.285]                           quietly = TRUE)
[10:21:23.285]                         if (has_future) {
[10:21:23.285]                           ns <- base::getNamespace("future")
[10:21:23.285]                           version <- ns[[".package"]][["version"]]
[10:21:23.285]                           if (is.null(version)) 
[10:21:23.285]                             version <- utils::packageVersion("future")
[10:21:23.285]                         }
[10:21:23.285]                         else {
[10:21:23.285]                           version <- NULL
[10:21:23.285]                         }
[10:21:23.285]                         if (!has_future || version < "1.8.0") {
[10:21:23.285]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.285]                             "", base::R.version$version.string), 
[10:21:23.285]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.285]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.285]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.285]                               "release", "version")], collapse = " "), 
[10:21:23.285]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.285]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.285]                             info)
[10:21:23.285]                           info <- base::paste(info, collapse = "; ")
[10:21:23.285]                           if (!has_future) {
[10:21:23.285]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.285]                               info)
[10:21:23.285]                           }
[10:21:23.285]                           else {
[10:21:23.285]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.285]                               info, version)
[10:21:23.285]                           }
[10:21:23.285]                           base::stop(msg)
[10:21:23.285]                         }
[10:21:23.285]                       })
[10:21:23.285]                     }
[10:21:23.285]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.285]                     base::options(mc.cores = 1L)
[10:21:23.285]                   }
[10:21:23.285]                   ...future.strategy.old <- future::plan("list")
[10:21:23.285]                   options(future.plan = NULL)
[10:21:23.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.285]                 }
[10:21:23.285]                 ...future.workdir <- getwd()
[10:21:23.285]             }
[10:21:23.285]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.285]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.285]         }
[10:21:23.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.285]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.285]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.285]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.285]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.285]             base::names(...future.oldOptions))
[10:21:23.285]     }
[10:21:23.285]     if (FALSE) {
[10:21:23.285]     }
[10:21:23.285]     else {
[10:21:23.285]         if (TRUE) {
[10:21:23.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.285]                 open = "w")
[10:21:23.285]         }
[10:21:23.285]         else {
[10:21:23.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.285]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.285]         }
[10:21:23.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.285]             base::sink(type = "output", split = FALSE)
[10:21:23.285]             base::close(...future.stdout)
[10:21:23.285]         }, add = TRUE)
[10:21:23.285]     }
[10:21:23.285]     ...future.frame <- base::sys.nframe()
[10:21:23.285]     ...future.conditions <- base::list()
[10:21:23.285]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.285]     if (FALSE) {
[10:21:23.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.285]     }
[10:21:23.285]     ...future.result <- base::tryCatch({
[10:21:23.285]         base::withCallingHandlers({
[10:21:23.285]             ...future.value <- base::withVisible(base::local({
[10:21:23.285]                 withCallingHandlers({
[10:21:23.285]                   2
[10:21:23.285]                 }, immediateCondition = function(cond) {
[10:21:23.285]                   save_rds <- function (object, pathname, ...) 
[10:21:23.285]                   {
[10:21:23.285]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:23.285]                     if (file_test("-f", pathname_tmp)) {
[10:21:23.285]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.285]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:23.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.285]                         fi_tmp[["mtime"]])
[10:21:23.285]                     }
[10:21:23.285]                     tryCatch({
[10:21:23.285]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:23.285]                     }, error = function(ex) {
[10:21:23.285]                       msg <- conditionMessage(ex)
[10:21:23.285]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.285]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:23.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.285]                         fi_tmp[["mtime"]], msg)
[10:21:23.285]                       ex$message <- msg
[10:21:23.285]                       stop(ex)
[10:21:23.285]                     })
[10:21:23.285]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:23.285]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:23.285]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:23.285]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.285]                       fi <- file.info(pathname)
[10:21:23.285]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:23.285]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.285]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:23.285]                         fi[["size"]], fi[["mtime"]])
[10:21:23.285]                       stop(msg)
[10:21:23.285]                     }
[10:21:23.285]                     invisible(pathname)
[10:21:23.285]                   }
[10:21:23.285]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:23.285]                     rootPath = tempdir()) 
[10:21:23.285]                   {
[10:21:23.285]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:23.285]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:23.285]                       tmpdir = path, fileext = ".rds")
[10:21:23.285]                     save_rds(obj, file)
[10:21:23.285]                   }
[10:21:23.285]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:23.285]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.285]                   {
[10:21:23.285]                     inherits <- base::inherits
[10:21:23.285]                     invokeRestart <- base::invokeRestart
[10:21:23.285]                     is.null <- base::is.null
[10:21:23.285]                     muffled <- FALSE
[10:21:23.285]                     if (inherits(cond, "message")) {
[10:21:23.285]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.285]                       if (muffled) 
[10:21:23.285]                         invokeRestart("muffleMessage")
[10:21:23.285]                     }
[10:21:23.285]                     else if (inherits(cond, "warning")) {
[10:21:23.285]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.285]                       if (muffled) 
[10:21:23.285]                         invokeRestart("muffleWarning")
[10:21:23.285]                     }
[10:21:23.285]                     else if (inherits(cond, "condition")) {
[10:21:23.285]                       if (!is.null(pattern)) {
[10:21:23.285]                         computeRestarts <- base::computeRestarts
[10:21:23.285]                         grepl <- base::grepl
[10:21:23.285]                         restarts <- computeRestarts(cond)
[10:21:23.285]                         for (restart in restarts) {
[10:21:23.285]                           name <- restart$name
[10:21:23.285]                           if (is.null(name)) 
[10:21:23.285]                             next
[10:21:23.285]                           if (!grepl(pattern, name)) 
[10:21:23.285]                             next
[10:21:23.285]                           invokeRestart(restart)
[10:21:23.285]                           muffled <- TRUE
[10:21:23.285]                           break
[10:21:23.285]                         }
[10:21:23.285]                       }
[10:21:23.285]                     }
[10:21:23.285]                     invisible(muffled)
[10:21:23.285]                   }
[10:21:23.285]                   muffleCondition(cond)
[10:21:23.285]                 })
[10:21:23.285]             }))
[10:21:23.285]             future::FutureResult(value = ...future.value$value, 
[10:21:23.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.285]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.285]                     ...future.globalenv.names))
[10:21:23.285]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.285]         }, condition = base::local({
[10:21:23.285]             c <- base::c
[10:21:23.285]             inherits <- base::inherits
[10:21:23.285]             invokeRestart <- base::invokeRestart
[10:21:23.285]             length <- base::length
[10:21:23.285]             list <- base::list
[10:21:23.285]             seq.int <- base::seq.int
[10:21:23.285]             signalCondition <- base::signalCondition
[10:21:23.285]             sys.calls <- base::sys.calls
[10:21:23.285]             `[[` <- base::`[[`
[10:21:23.285]             `+` <- base::`+`
[10:21:23.285]             `<<-` <- base::`<<-`
[10:21:23.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.285]                   3L)]
[10:21:23.285]             }
[10:21:23.285]             function(cond) {
[10:21:23.285]                 is_error <- inherits(cond, "error")
[10:21:23.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.285]                   NULL)
[10:21:23.285]                 if (is_error) {
[10:21:23.285]                   sessionInformation <- function() {
[10:21:23.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.285]                       search = base::search(), system = base::Sys.info())
[10:21:23.285]                   }
[10:21:23.285]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.285]                     cond$call), session = sessionInformation(), 
[10:21:23.285]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.285]                   signalCondition(cond)
[10:21:23.285]                 }
[10:21:23.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.285]                 "immediateCondition"))) {
[10:21:23.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.285]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.285]                   if (TRUE && !signal) {
[10:21:23.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.285]                     {
[10:21:23.285]                       inherits <- base::inherits
[10:21:23.285]                       invokeRestart <- base::invokeRestart
[10:21:23.285]                       is.null <- base::is.null
[10:21:23.285]                       muffled <- FALSE
[10:21:23.285]                       if (inherits(cond, "message")) {
[10:21:23.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.285]                         if (muffled) 
[10:21:23.285]                           invokeRestart("muffleMessage")
[10:21:23.285]                       }
[10:21:23.285]                       else if (inherits(cond, "warning")) {
[10:21:23.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.285]                         if (muffled) 
[10:21:23.285]                           invokeRestart("muffleWarning")
[10:21:23.285]                       }
[10:21:23.285]                       else if (inherits(cond, "condition")) {
[10:21:23.285]                         if (!is.null(pattern)) {
[10:21:23.285]                           computeRestarts <- base::computeRestarts
[10:21:23.285]                           grepl <- base::grepl
[10:21:23.285]                           restarts <- computeRestarts(cond)
[10:21:23.285]                           for (restart in restarts) {
[10:21:23.285]                             name <- restart$name
[10:21:23.285]                             if (is.null(name)) 
[10:21:23.285]                               next
[10:21:23.285]                             if (!grepl(pattern, name)) 
[10:21:23.285]                               next
[10:21:23.285]                             invokeRestart(restart)
[10:21:23.285]                             muffled <- TRUE
[10:21:23.285]                             break
[10:21:23.285]                           }
[10:21:23.285]                         }
[10:21:23.285]                       }
[10:21:23.285]                       invisible(muffled)
[10:21:23.285]                     }
[10:21:23.285]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.285]                   }
[10:21:23.285]                 }
[10:21:23.285]                 else {
[10:21:23.285]                   if (TRUE) {
[10:21:23.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.285]                     {
[10:21:23.285]                       inherits <- base::inherits
[10:21:23.285]                       invokeRestart <- base::invokeRestart
[10:21:23.285]                       is.null <- base::is.null
[10:21:23.285]                       muffled <- FALSE
[10:21:23.285]                       if (inherits(cond, "message")) {
[10:21:23.285]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.285]                         if (muffled) 
[10:21:23.285]                           invokeRestart("muffleMessage")
[10:21:23.285]                       }
[10:21:23.285]                       else if (inherits(cond, "warning")) {
[10:21:23.285]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.285]                         if (muffled) 
[10:21:23.285]                           invokeRestart("muffleWarning")
[10:21:23.285]                       }
[10:21:23.285]                       else if (inherits(cond, "condition")) {
[10:21:23.285]                         if (!is.null(pattern)) {
[10:21:23.285]                           computeRestarts <- base::computeRestarts
[10:21:23.285]                           grepl <- base::grepl
[10:21:23.285]                           restarts <- computeRestarts(cond)
[10:21:23.285]                           for (restart in restarts) {
[10:21:23.285]                             name <- restart$name
[10:21:23.285]                             if (is.null(name)) 
[10:21:23.285]                               next
[10:21:23.285]                             if (!grepl(pattern, name)) 
[10:21:23.285]                               next
[10:21:23.285]                             invokeRestart(restart)
[10:21:23.285]                             muffled <- TRUE
[10:21:23.285]                             break
[10:21:23.285]                           }
[10:21:23.285]                         }
[10:21:23.285]                       }
[10:21:23.285]                       invisible(muffled)
[10:21:23.285]                     }
[10:21:23.285]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.285]                   }
[10:21:23.285]                 }
[10:21:23.285]             }
[10:21:23.285]         }))
[10:21:23.285]     }, error = function(ex) {
[10:21:23.285]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.285]                 ...future.rng), started = ...future.startTime, 
[10:21:23.285]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.285]             version = "1.8"), class = "FutureResult")
[10:21:23.285]     }, finally = {
[10:21:23.285]         if (!identical(...future.workdir, getwd())) 
[10:21:23.285]             setwd(...future.workdir)
[10:21:23.285]         {
[10:21:23.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.285]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.285]             }
[10:21:23.285]             base::options(...future.oldOptions)
[10:21:23.285]             if (.Platform$OS.type == "windows") {
[10:21:23.285]                 old_names <- names(...future.oldEnvVars)
[10:21:23.285]                 envs <- base::Sys.getenv()
[10:21:23.285]                 names <- names(envs)
[10:21:23.285]                 common <- intersect(names, old_names)
[10:21:23.285]                 added <- setdiff(names, old_names)
[10:21:23.285]                 removed <- setdiff(old_names, names)
[10:21:23.285]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.285]                   envs[common]]
[10:21:23.285]                 NAMES <- toupper(changed)
[10:21:23.285]                 args <- list()
[10:21:23.285]                 for (kk in seq_along(NAMES)) {
[10:21:23.285]                   name <- changed[[kk]]
[10:21:23.285]                   NAME <- NAMES[[kk]]
[10:21:23.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.285]                     next
[10:21:23.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.285]                 }
[10:21:23.285]                 NAMES <- toupper(added)
[10:21:23.285]                 for (kk in seq_along(NAMES)) {
[10:21:23.285]                   name <- added[[kk]]
[10:21:23.285]                   NAME <- NAMES[[kk]]
[10:21:23.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.285]                     next
[10:21:23.285]                   args[[name]] <- ""
[10:21:23.285]                 }
[10:21:23.285]                 NAMES <- toupper(removed)
[10:21:23.285]                 for (kk in seq_along(NAMES)) {
[10:21:23.285]                   name <- removed[[kk]]
[10:21:23.285]                   NAME <- NAMES[[kk]]
[10:21:23.285]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.285]                     next
[10:21:23.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.285]                 }
[10:21:23.285]                 if (length(args) > 0) 
[10:21:23.285]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.285]             }
[10:21:23.285]             else {
[10:21:23.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.285]             }
[10:21:23.285]             {
[10:21:23.285]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.285]                   0L) {
[10:21:23.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.285]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.285]                   base::options(opts)
[10:21:23.285]                 }
[10:21:23.285]                 {
[10:21:23.285]                   {
[10:21:23.285]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.285]                     NULL
[10:21:23.285]                   }
[10:21:23.285]                   options(future.plan = NULL)
[10:21:23.285]                   if (is.na(NA_character_)) 
[10:21:23.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.285]                     .init = FALSE)
[10:21:23.285]                 }
[10:21:23.285]             }
[10:21:23.285]         }
[10:21:23.285]     })
[10:21:23.285]     if (TRUE) {
[10:21:23.285]         base::sink(type = "output", split = FALSE)
[10:21:23.285]         if (TRUE) {
[10:21:23.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.285]         }
[10:21:23.285]         else {
[10:21:23.285]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.285]         }
[10:21:23.285]         base::close(...future.stdout)
[10:21:23.285]         ...future.stdout <- NULL
[10:21:23.285]     }
[10:21:23.285]     ...future.result$conditions <- ...future.conditions
[10:21:23.285]     ...future.result$finished <- base::Sys.time()
[10:21:23.285]     ...future.result
[10:21:23.285] }
[10:21:23.288] requestCore(): workers = 2
[10:21:23.290] MulticoreFuture started
[10:21:23.291] - Launch lazy future ... done
[10:21:23.291] run() for ‘MulticoreFuture’ ... done
[10:21:23.291] getGlobalsAndPackages() ...
[10:21:23.291] Searching for globals...
[10:21:23.291] plan(): Setting new future strategy stack:
[10:21:23.292] 
[10:21:23.292] Searching for globals ... DONE
[10:21:23.292] List of future strategies:
[10:21:23.292] 1. sequential:
[10:21:23.292]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.292]    - tweaked: FALSE
[10:21:23.292]    - call: NULL
[10:21:23.292] - globals: [0] <none>
[10:21:23.293] plan(): nbrOfWorkers() = 1
[10:21:23.293] getGlobalsAndPackages() ... DONE
[10:21:23.293] run() for ‘Future’ ...
[10:21:23.293] - state: ‘created’
[10:21:23.293] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.295] plan(): Setting new future strategy stack:
[10:21:23.295] List of future strategies:
[10:21:23.295] 1. multicore:
[10:21:23.295]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.295]    - tweaked: FALSE
[10:21:23.295]    - call: plan(strategy)
[10:21:23.297] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.297] plan(): nbrOfWorkers() = 2
[10:21:23.297] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:23.297]   - Field: ‘label’
[10:21:23.297]   - Field: ‘local’
[10:21:23.298]   - Field: ‘owner’
[10:21:23.298]   - Field: ‘envir’
[10:21:23.298]   - Field: ‘workers’
[10:21:23.298]   - Field: ‘packages’
[10:21:23.298]   - Field: ‘gc’
[10:21:23.298]   - Field: ‘job’
[10:21:23.298]   - Field: ‘conditions’
[10:21:23.299]   - Field: ‘expr’
[10:21:23.299]   - Field: ‘uuid’
[10:21:23.299]   - Field: ‘seed’
[10:21:23.299]   - Field: ‘version’
[10:21:23.299]   - Field: ‘result’
[10:21:23.299]   - Field: ‘asynchronous’
[10:21:23.299]   - Field: ‘calls’
[10:21:23.299]   - Field: ‘globals’
[10:21:23.300]   - Field: ‘stdout’
[10:21:23.300]   - Field: ‘earlySignal’
[10:21:23.300]   - Field: ‘lazy’
[10:21:23.300]   - Field: ‘state’
[10:21:23.300] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:23.300] - Launch lazy future ...
[10:21:23.301] Packages needed by the future expression (n = 0): <none>
[10:21:23.301] Packages needed by future strategies (n = 0): <none>
[10:21:23.302] {
[10:21:23.302]     {
[10:21:23.302]         {
[10:21:23.302]             ...future.startTime <- base::Sys.time()
[10:21:23.302]             {
[10:21:23.302]                 {
[10:21:23.302]                   {
[10:21:23.302]                     {
[10:21:23.302]                       base::local({
[10:21:23.302]                         has_future <- base::requireNamespace("future", 
[10:21:23.302]                           quietly = TRUE)
[10:21:23.302]                         if (has_future) {
[10:21:23.302]                           ns <- base::getNamespace("future")
[10:21:23.302]                           version <- ns[[".package"]][["version"]]
[10:21:23.302]                           if (is.null(version)) 
[10:21:23.302]                             version <- utils::packageVersion("future")
[10:21:23.302]                         }
[10:21:23.302]                         else {
[10:21:23.302]                           version <- NULL
[10:21:23.302]                         }
[10:21:23.302]                         if (!has_future || version < "1.8.0") {
[10:21:23.302]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.302]                             "", base::R.version$version.string), 
[10:21:23.302]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.302]                               "release", "version")], collapse = " "), 
[10:21:23.302]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.302]                             info)
[10:21:23.302]                           info <- base::paste(info, collapse = "; ")
[10:21:23.302]                           if (!has_future) {
[10:21:23.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.302]                               info)
[10:21:23.302]                           }
[10:21:23.302]                           else {
[10:21:23.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.302]                               info, version)
[10:21:23.302]                           }
[10:21:23.302]                           base::stop(msg)
[10:21:23.302]                         }
[10:21:23.302]                       })
[10:21:23.302]                     }
[10:21:23.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.302]                     base::options(mc.cores = 1L)
[10:21:23.302]                   }
[10:21:23.302]                   ...future.strategy.old <- future::plan("list")
[10:21:23.302]                   options(future.plan = NULL)
[10:21:23.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.302]                 }
[10:21:23.302]                 ...future.workdir <- getwd()
[10:21:23.302]             }
[10:21:23.302]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.302]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.302]         }
[10:21:23.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.302]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.302]             base::names(...future.oldOptions))
[10:21:23.302]     }
[10:21:23.302]     if (FALSE) {
[10:21:23.302]     }
[10:21:23.302]     else {
[10:21:23.302]         if (TRUE) {
[10:21:23.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.302]                 open = "w")
[10:21:23.302]         }
[10:21:23.302]         else {
[10:21:23.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.302]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.302]         }
[10:21:23.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.302]             base::sink(type = "output", split = FALSE)
[10:21:23.302]             base::close(...future.stdout)
[10:21:23.302]         }, add = TRUE)
[10:21:23.302]     }
[10:21:23.302]     ...future.frame <- base::sys.nframe()
[10:21:23.302]     ...future.conditions <- base::list()
[10:21:23.302]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.302]     if (FALSE) {
[10:21:23.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.302]     }
[10:21:23.302]     ...future.result <- base::tryCatch({
[10:21:23.302]         base::withCallingHandlers({
[10:21:23.302]             ...future.value <- base::withVisible(base::local({
[10:21:23.302]                 withCallingHandlers({
[10:21:23.302]                   NULL
[10:21:23.302]                 }, immediateCondition = function(cond) {
[10:21:23.302]                   save_rds <- function (object, pathname, ...) 
[10:21:23.302]                   {
[10:21:23.302]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:23.302]                     if (file_test("-f", pathname_tmp)) {
[10:21:23.302]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.302]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:23.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.302]                         fi_tmp[["mtime"]])
[10:21:23.302]                     }
[10:21:23.302]                     tryCatch({
[10:21:23.302]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:23.302]                     }, error = function(ex) {
[10:21:23.302]                       msg <- conditionMessage(ex)
[10:21:23.302]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.302]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:23.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.302]                         fi_tmp[["mtime"]], msg)
[10:21:23.302]                       ex$message <- msg
[10:21:23.302]                       stop(ex)
[10:21:23.302]                     })
[10:21:23.302]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:23.302]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:23.302]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:23.302]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.302]                       fi <- file.info(pathname)
[10:21:23.302]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:23.302]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.302]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:23.302]                         fi[["size"]], fi[["mtime"]])
[10:21:23.302]                       stop(msg)
[10:21:23.302]                     }
[10:21:23.302]                     invisible(pathname)
[10:21:23.302]                   }
[10:21:23.302]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:23.302]                     rootPath = tempdir()) 
[10:21:23.302]                   {
[10:21:23.302]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:23.302]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:23.302]                       tmpdir = path, fileext = ".rds")
[10:21:23.302]                     save_rds(obj, file)
[10:21:23.302]                   }
[10:21:23.302]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:23.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.302]                   {
[10:21:23.302]                     inherits <- base::inherits
[10:21:23.302]                     invokeRestart <- base::invokeRestart
[10:21:23.302]                     is.null <- base::is.null
[10:21:23.302]                     muffled <- FALSE
[10:21:23.302]                     if (inherits(cond, "message")) {
[10:21:23.302]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.302]                       if (muffled) 
[10:21:23.302]                         invokeRestart("muffleMessage")
[10:21:23.302]                     }
[10:21:23.302]                     else if (inherits(cond, "warning")) {
[10:21:23.302]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.302]                       if (muffled) 
[10:21:23.302]                         invokeRestart("muffleWarning")
[10:21:23.302]                     }
[10:21:23.302]                     else if (inherits(cond, "condition")) {
[10:21:23.302]                       if (!is.null(pattern)) {
[10:21:23.302]                         computeRestarts <- base::computeRestarts
[10:21:23.302]                         grepl <- base::grepl
[10:21:23.302]                         restarts <- computeRestarts(cond)
[10:21:23.302]                         for (restart in restarts) {
[10:21:23.302]                           name <- restart$name
[10:21:23.302]                           if (is.null(name)) 
[10:21:23.302]                             next
[10:21:23.302]                           if (!grepl(pattern, name)) 
[10:21:23.302]                             next
[10:21:23.302]                           invokeRestart(restart)
[10:21:23.302]                           muffled <- TRUE
[10:21:23.302]                           break
[10:21:23.302]                         }
[10:21:23.302]                       }
[10:21:23.302]                     }
[10:21:23.302]                     invisible(muffled)
[10:21:23.302]                   }
[10:21:23.302]                   muffleCondition(cond)
[10:21:23.302]                 })
[10:21:23.302]             }))
[10:21:23.302]             future::FutureResult(value = ...future.value$value, 
[10:21:23.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.302]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.302]                     ...future.globalenv.names))
[10:21:23.302]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.302]         }, condition = base::local({
[10:21:23.302]             c <- base::c
[10:21:23.302]             inherits <- base::inherits
[10:21:23.302]             invokeRestart <- base::invokeRestart
[10:21:23.302]             length <- base::length
[10:21:23.302]             list <- base::list
[10:21:23.302]             seq.int <- base::seq.int
[10:21:23.302]             signalCondition <- base::signalCondition
[10:21:23.302]             sys.calls <- base::sys.calls
[10:21:23.302]             `[[` <- base::`[[`
[10:21:23.302]             `+` <- base::`+`
[10:21:23.302]             `<<-` <- base::`<<-`
[10:21:23.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.302]                   3L)]
[10:21:23.302]             }
[10:21:23.302]             function(cond) {
[10:21:23.302]                 is_error <- inherits(cond, "error")
[10:21:23.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.302]                   NULL)
[10:21:23.302]                 if (is_error) {
[10:21:23.302]                   sessionInformation <- function() {
[10:21:23.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.302]                       search = base::search(), system = base::Sys.info())
[10:21:23.302]                   }
[10:21:23.302]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.302]                     cond$call), session = sessionInformation(), 
[10:21:23.302]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.302]                   signalCondition(cond)
[10:21:23.302]                 }
[10:21:23.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.302]                 "immediateCondition"))) {
[10:21:23.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.302]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.302]                   if (TRUE && !signal) {
[10:21:23.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.302]                     {
[10:21:23.302]                       inherits <- base::inherits
[10:21:23.302]                       invokeRestart <- base::invokeRestart
[10:21:23.302]                       is.null <- base::is.null
[10:21:23.302]                       muffled <- FALSE
[10:21:23.302]                       if (inherits(cond, "message")) {
[10:21:23.302]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.302]                         if (muffled) 
[10:21:23.302]                           invokeRestart("muffleMessage")
[10:21:23.302]                       }
[10:21:23.302]                       else if (inherits(cond, "warning")) {
[10:21:23.302]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.302]                         if (muffled) 
[10:21:23.302]                           invokeRestart("muffleWarning")
[10:21:23.302]                       }
[10:21:23.302]                       else if (inherits(cond, "condition")) {
[10:21:23.302]                         if (!is.null(pattern)) {
[10:21:23.302]                           computeRestarts <- base::computeRestarts
[10:21:23.302]                           grepl <- base::grepl
[10:21:23.302]                           restarts <- computeRestarts(cond)
[10:21:23.302]                           for (restart in restarts) {
[10:21:23.302]                             name <- restart$name
[10:21:23.302]                             if (is.null(name)) 
[10:21:23.302]                               next
[10:21:23.302]                             if (!grepl(pattern, name)) 
[10:21:23.302]                               next
[10:21:23.302]                             invokeRestart(restart)
[10:21:23.302]                             muffled <- TRUE
[10:21:23.302]                             break
[10:21:23.302]                           }
[10:21:23.302]                         }
[10:21:23.302]                       }
[10:21:23.302]                       invisible(muffled)
[10:21:23.302]                     }
[10:21:23.302]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.302]                   }
[10:21:23.302]                 }
[10:21:23.302]                 else {
[10:21:23.302]                   if (TRUE) {
[10:21:23.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.302]                     {
[10:21:23.302]                       inherits <- base::inherits
[10:21:23.302]                       invokeRestart <- base::invokeRestart
[10:21:23.302]                       is.null <- base::is.null
[10:21:23.302]                       muffled <- FALSE
[10:21:23.302]                       if (inherits(cond, "message")) {
[10:21:23.302]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.302]                         if (muffled) 
[10:21:23.302]                           invokeRestart("muffleMessage")
[10:21:23.302]                       }
[10:21:23.302]                       else if (inherits(cond, "warning")) {
[10:21:23.302]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.302]                         if (muffled) 
[10:21:23.302]                           invokeRestart("muffleWarning")
[10:21:23.302]                       }
[10:21:23.302]                       else if (inherits(cond, "condition")) {
[10:21:23.302]                         if (!is.null(pattern)) {
[10:21:23.302]                           computeRestarts <- base::computeRestarts
[10:21:23.302]                           grepl <- base::grepl
[10:21:23.302]                           restarts <- computeRestarts(cond)
[10:21:23.302]                           for (restart in restarts) {
[10:21:23.302]                             name <- restart$name
[10:21:23.302]                             if (is.null(name)) 
[10:21:23.302]                               next
[10:21:23.302]                             if (!grepl(pattern, name)) 
[10:21:23.302]                               next
[10:21:23.302]                             invokeRestart(restart)
[10:21:23.302]                             muffled <- TRUE
[10:21:23.302]                             break
[10:21:23.302]                           }
[10:21:23.302]                         }
[10:21:23.302]                       }
[10:21:23.302]                       invisible(muffled)
[10:21:23.302]                     }
[10:21:23.302]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.302]                   }
[10:21:23.302]                 }
[10:21:23.302]             }
[10:21:23.302]         }))
[10:21:23.302]     }, error = function(ex) {
[10:21:23.302]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.302]                 ...future.rng), started = ...future.startTime, 
[10:21:23.302]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.302]             version = "1.8"), class = "FutureResult")
[10:21:23.302]     }, finally = {
[10:21:23.302]         if (!identical(...future.workdir, getwd())) 
[10:21:23.302]             setwd(...future.workdir)
[10:21:23.302]         {
[10:21:23.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.302]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.302]             }
[10:21:23.302]             base::options(...future.oldOptions)
[10:21:23.302]             if (.Platform$OS.type == "windows") {
[10:21:23.302]                 old_names <- names(...future.oldEnvVars)
[10:21:23.302]                 envs <- base::Sys.getenv()
[10:21:23.302]                 names <- names(envs)
[10:21:23.302]                 common <- intersect(names, old_names)
[10:21:23.302]                 added <- setdiff(names, old_names)
[10:21:23.302]                 removed <- setdiff(old_names, names)
[10:21:23.302]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.302]                   envs[common]]
[10:21:23.302]                 NAMES <- toupper(changed)
[10:21:23.302]                 args <- list()
[10:21:23.302]                 for (kk in seq_along(NAMES)) {
[10:21:23.302]                   name <- changed[[kk]]
[10:21:23.302]                   NAME <- NAMES[[kk]]
[10:21:23.302]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.302]                     next
[10:21:23.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.302]                 }
[10:21:23.302]                 NAMES <- toupper(added)
[10:21:23.302]                 for (kk in seq_along(NAMES)) {
[10:21:23.302]                   name <- added[[kk]]
[10:21:23.302]                   NAME <- NAMES[[kk]]
[10:21:23.302]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.302]                     next
[10:21:23.302]                   args[[name]] <- ""
[10:21:23.302]                 }
[10:21:23.302]                 NAMES <- toupper(removed)
[10:21:23.302]                 for (kk in seq_along(NAMES)) {
[10:21:23.302]                   name <- removed[[kk]]
[10:21:23.302]                   NAME <- NAMES[[kk]]
[10:21:23.302]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.302]                     next
[10:21:23.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.302]                 }
[10:21:23.302]                 if (length(args) > 0) 
[10:21:23.302]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.302]             }
[10:21:23.302]             else {
[10:21:23.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.302]             }
[10:21:23.302]             {
[10:21:23.302]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.302]                   0L) {
[10:21:23.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.302]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.302]                   base::options(opts)
[10:21:23.302]                 }
[10:21:23.302]                 {
[10:21:23.302]                   {
[10:21:23.302]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.302]                     NULL
[10:21:23.302]                   }
[10:21:23.302]                   options(future.plan = NULL)
[10:21:23.302]                   if (is.na(NA_character_)) 
[10:21:23.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.302]                     .init = FALSE)
[10:21:23.302]                 }
[10:21:23.302]             }
[10:21:23.302]         }
[10:21:23.302]     })
[10:21:23.302]     if (TRUE) {
[10:21:23.302]         base::sink(type = "output", split = FALSE)
[10:21:23.302]         if (TRUE) {
[10:21:23.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.302]         }
[10:21:23.302]         else {
[10:21:23.302]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.302]         }
[10:21:23.302]         base::close(...future.stdout)
[10:21:23.302]         ...future.stdout <- NULL
[10:21:23.302]     }
[10:21:23.302]     ...future.result$conditions <- ...future.conditions
[10:21:23.302]     ...future.result$finished <- base::Sys.time()
[10:21:23.302]     ...future.result
[10:21:23.302] }
[10:21:23.305] requestCore(): workers = 2
[10:21:23.309] MulticoreFuture started
[10:21:23.309] - Launch lazy future ... done
[10:21:23.309] run() for ‘MulticoreFuture’ ... done
[10:21:23.310] plan(): Setting new future strategy stack:
[10:21:23.310] getGlobalsAndPackages() ...
[10:21:23.310] Searching for globals...
[10:21:23.310] List of future strategies:
[10:21:23.310] 1. sequential:
[10:21:23.310]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.310]    - tweaked: FALSE
[10:21:23.310]    - call: NULL
[10:21:23.311] plan(): nbrOfWorkers() = 1
[10:21:23.312] - globals found: [1] ‘{’
[10:21:23.312] Searching for globals ... DONE
[10:21:23.312] Resolving globals: FALSE
[10:21:23.313] 
[10:21:23.313] 
[10:21:23.313] getGlobalsAndPackages() ... DONE
[10:21:23.313] run() for ‘Future’ ...
[10:21:23.313] - state: ‘created’
[10:21:23.313] plan(): Setting new future strategy stack:
[10:21:23.314] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.314] List of future strategies:
[10:21:23.314] 1. multicore:
[10:21:23.314]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.314]    - tweaked: FALSE
[10:21:23.314]    - call: plan(strategy)
[10:21:23.316] plan(): nbrOfWorkers() = 2
[10:21:23.317] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.317] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:23.317]   - Field: ‘label’
[10:21:23.317]   - Field: ‘local’
[10:21:23.317]   - Field: ‘owner’
[10:21:23.318]   - Field: ‘envir’
[10:21:23.318]   - Field: ‘workers’
[10:21:23.318]   - Field: ‘packages’
[10:21:23.318]   - Field: ‘gc’
[10:21:23.318]   - Field: ‘job’
[10:21:23.318]   - Field: ‘conditions’
[10:21:23.318]   - Field: ‘expr’
[10:21:23.318]   - Field: ‘uuid’
[10:21:23.319]   - Field: ‘seed’
[10:21:23.319]   - Field: ‘version’
[10:21:23.319]   - Field: ‘result’
[10:21:23.319]   - Field: ‘asynchronous’
[10:21:23.319]   - Field: ‘calls’
[10:21:23.319]   - Field: ‘globals’
[10:21:23.319]   - Field: ‘stdout’
[10:21:23.319]   - Field: ‘earlySignal’
[10:21:23.320]   - Field: ‘lazy’
[10:21:23.320]   - Field: ‘state’
[10:21:23.320] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:23.320] - Launch lazy future ...
[10:21:23.320] Packages needed by the future expression (n = 0): <none>
[10:21:23.321] Packages needed by future strategies (n = 0): <none>
[10:21:23.321] {
[10:21:23.321]     {
[10:21:23.321]         {
[10:21:23.321]             ...future.startTime <- base::Sys.time()
[10:21:23.321]             {
[10:21:23.321]                 {
[10:21:23.321]                   {
[10:21:23.321]                     {
[10:21:23.321]                       base::local({
[10:21:23.321]                         has_future <- base::requireNamespace("future", 
[10:21:23.321]                           quietly = TRUE)
[10:21:23.321]                         if (has_future) {
[10:21:23.321]                           ns <- base::getNamespace("future")
[10:21:23.321]                           version <- ns[[".package"]][["version"]]
[10:21:23.321]                           if (is.null(version)) 
[10:21:23.321]                             version <- utils::packageVersion("future")
[10:21:23.321]                         }
[10:21:23.321]                         else {
[10:21:23.321]                           version <- NULL
[10:21:23.321]                         }
[10:21:23.321]                         if (!has_future || version < "1.8.0") {
[10:21:23.321]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.321]                             "", base::R.version$version.string), 
[10:21:23.321]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.321]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.321]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.321]                               "release", "version")], collapse = " "), 
[10:21:23.321]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.321]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.321]                             info)
[10:21:23.321]                           info <- base::paste(info, collapse = "; ")
[10:21:23.321]                           if (!has_future) {
[10:21:23.321]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.321]                               info)
[10:21:23.321]                           }
[10:21:23.321]                           else {
[10:21:23.321]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.321]                               info, version)
[10:21:23.321]                           }
[10:21:23.321]                           base::stop(msg)
[10:21:23.321]                         }
[10:21:23.321]                       })
[10:21:23.321]                     }
[10:21:23.321]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.321]                     base::options(mc.cores = 1L)
[10:21:23.321]                   }
[10:21:23.321]                   ...future.strategy.old <- future::plan("list")
[10:21:23.321]                   options(future.plan = NULL)
[10:21:23.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.321]                 }
[10:21:23.321]                 ...future.workdir <- getwd()
[10:21:23.321]             }
[10:21:23.321]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.321]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.321]         }
[10:21:23.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.321]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.321]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.321]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.321]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.321]             base::names(...future.oldOptions))
[10:21:23.321]     }
[10:21:23.321]     if (FALSE) {
[10:21:23.321]     }
[10:21:23.321]     else {
[10:21:23.321]         if (TRUE) {
[10:21:23.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.321]                 open = "w")
[10:21:23.321]         }
[10:21:23.321]         else {
[10:21:23.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.321]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.321]         }
[10:21:23.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.321]             base::sink(type = "output", split = FALSE)
[10:21:23.321]             base::close(...future.stdout)
[10:21:23.321]         }, add = TRUE)
[10:21:23.321]     }
[10:21:23.321]     ...future.frame <- base::sys.nframe()
[10:21:23.321]     ...future.conditions <- base::list()
[10:21:23.321]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.321]     if (FALSE) {
[10:21:23.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.321]     }
[10:21:23.321]     ...future.result <- base::tryCatch({
[10:21:23.321]         base::withCallingHandlers({
[10:21:23.321]             ...future.value <- base::withVisible(base::local({
[10:21:23.321]                 withCallingHandlers({
[10:21:23.321]                   {
[10:21:23.321]                     4
[10:21:23.321]                   }
[10:21:23.321]                 }, immediateCondition = function(cond) {
[10:21:23.321]                   save_rds <- function (object, pathname, ...) 
[10:21:23.321]                   {
[10:21:23.321]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:23.321]                     if (file_test("-f", pathname_tmp)) {
[10:21:23.321]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.321]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:23.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.321]                         fi_tmp[["mtime"]])
[10:21:23.321]                     }
[10:21:23.321]                     tryCatch({
[10:21:23.321]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:23.321]                     }, error = function(ex) {
[10:21:23.321]                       msg <- conditionMessage(ex)
[10:21:23.321]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.321]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:23.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.321]                         fi_tmp[["mtime"]], msg)
[10:21:23.321]                       ex$message <- msg
[10:21:23.321]                       stop(ex)
[10:21:23.321]                     })
[10:21:23.321]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:23.321]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:23.321]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:23.321]                       fi_tmp <- file.info(pathname_tmp)
[10:21:23.321]                       fi <- file.info(pathname)
[10:21:23.321]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:23.321]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:23.321]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:23.321]                         fi[["size"]], fi[["mtime"]])
[10:21:23.321]                       stop(msg)
[10:21:23.321]                     }
[10:21:23.321]                     invisible(pathname)
[10:21:23.321]                   }
[10:21:23.321]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:23.321]                     rootPath = tempdir()) 
[10:21:23.321]                   {
[10:21:23.321]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:23.321]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:23.321]                       tmpdir = path, fileext = ".rds")
[10:21:23.321]                     save_rds(obj, file)
[10:21:23.321]                   }
[10:21:23.321]                   saveImmediateCondition(cond, path = "/tmp/Rtmprp8kuR/.future/immediateConditions")
[10:21:23.321]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.321]                   {
[10:21:23.321]                     inherits <- base::inherits
[10:21:23.321]                     invokeRestart <- base::invokeRestart
[10:21:23.321]                     is.null <- base::is.null
[10:21:23.321]                     muffled <- FALSE
[10:21:23.321]                     if (inherits(cond, "message")) {
[10:21:23.321]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.321]                       if (muffled) 
[10:21:23.321]                         invokeRestart("muffleMessage")
[10:21:23.321]                     }
[10:21:23.321]                     else if (inherits(cond, "warning")) {
[10:21:23.321]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.321]                       if (muffled) 
[10:21:23.321]                         invokeRestart("muffleWarning")
[10:21:23.321]                     }
[10:21:23.321]                     else if (inherits(cond, "condition")) {
[10:21:23.321]                       if (!is.null(pattern)) {
[10:21:23.321]                         computeRestarts <- base::computeRestarts
[10:21:23.321]                         grepl <- base::grepl
[10:21:23.321]                         restarts <- computeRestarts(cond)
[10:21:23.321]                         for (restart in restarts) {
[10:21:23.321]                           name <- restart$name
[10:21:23.321]                           if (is.null(name)) 
[10:21:23.321]                             next
[10:21:23.321]                           if (!grepl(pattern, name)) 
[10:21:23.321]                             next
[10:21:23.321]                           invokeRestart(restart)
[10:21:23.321]                           muffled <- TRUE
[10:21:23.321]                           break
[10:21:23.321]                         }
[10:21:23.321]                       }
[10:21:23.321]                     }
[10:21:23.321]                     invisible(muffled)
[10:21:23.321]                   }
[10:21:23.321]                   muffleCondition(cond)
[10:21:23.321]                 })
[10:21:23.321]             }))
[10:21:23.321]             future::FutureResult(value = ...future.value$value, 
[10:21:23.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.321]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.321]                     ...future.globalenv.names))
[10:21:23.321]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.321]         }, condition = base::local({
[10:21:23.321]             c <- base::c
[10:21:23.321]             inherits <- base::inherits
[10:21:23.321]             invokeRestart <- base::invokeRestart
[10:21:23.321]             length <- base::length
[10:21:23.321]             list <- base::list
[10:21:23.321]             seq.int <- base::seq.int
[10:21:23.321]             signalCondition <- base::signalCondition
[10:21:23.321]             sys.calls <- base::sys.calls
[10:21:23.321]             `[[` <- base::`[[`
[10:21:23.321]             `+` <- base::`+`
[10:21:23.321]             `<<-` <- base::`<<-`
[10:21:23.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.321]                   3L)]
[10:21:23.321]             }
[10:21:23.321]             function(cond) {
[10:21:23.321]                 is_error <- inherits(cond, "error")
[10:21:23.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.321]                   NULL)
[10:21:23.321]                 if (is_error) {
[10:21:23.321]                   sessionInformation <- function() {
[10:21:23.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.321]                       search = base::search(), system = base::Sys.info())
[10:21:23.321]                   }
[10:21:23.321]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.321]                     cond$call), session = sessionInformation(), 
[10:21:23.321]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.321]                   signalCondition(cond)
[10:21:23.321]                 }
[10:21:23.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.321]                 "immediateCondition"))) {
[10:21:23.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.321]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.321]                   if (TRUE && !signal) {
[10:21:23.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.321]                     {
[10:21:23.321]                       inherits <- base::inherits
[10:21:23.321]                       invokeRestart <- base::invokeRestart
[10:21:23.321]                       is.null <- base::is.null
[10:21:23.321]                       muffled <- FALSE
[10:21:23.321]                       if (inherits(cond, "message")) {
[10:21:23.321]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.321]                         if (muffled) 
[10:21:23.321]                           invokeRestart("muffleMessage")
[10:21:23.321]                       }
[10:21:23.321]                       else if (inherits(cond, "warning")) {
[10:21:23.321]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.321]                         if (muffled) 
[10:21:23.321]                           invokeRestart("muffleWarning")
[10:21:23.321]                       }
[10:21:23.321]                       else if (inherits(cond, "condition")) {
[10:21:23.321]                         if (!is.null(pattern)) {
[10:21:23.321]                           computeRestarts <- base::computeRestarts
[10:21:23.321]                           grepl <- base::grepl
[10:21:23.321]                           restarts <- computeRestarts(cond)
[10:21:23.321]                           for (restart in restarts) {
[10:21:23.321]                             name <- restart$name
[10:21:23.321]                             if (is.null(name)) 
[10:21:23.321]                               next
[10:21:23.321]                             if (!grepl(pattern, name)) 
[10:21:23.321]                               next
[10:21:23.321]                             invokeRestart(restart)
[10:21:23.321]                             muffled <- TRUE
[10:21:23.321]                             break
[10:21:23.321]                           }
[10:21:23.321]                         }
[10:21:23.321]                       }
[10:21:23.321]                       invisible(muffled)
[10:21:23.321]                     }
[10:21:23.321]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.321]                   }
[10:21:23.321]                 }
[10:21:23.321]                 else {
[10:21:23.321]                   if (TRUE) {
[10:21:23.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.321]                     {
[10:21:23.321]                       inherits <- base::inherits
[10:21:23.321]                       invokeRestart <- base::invokeRestart
[10:21:23.321]                       is.null <- base::is.null
[10:21:23.321]                       muffled <- FALSE
[10:21:23.321]                       if (inherits(cond, "message")) {
[10:21:23.321]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.321]                         if (muffled) 
[10:21:23.321]                           invokeRestart("muffleMessage")
[10:21:23.321]                       }
[10:21:23.321]                       else if (inherits(cond, "warning")) {
[10:21:23.321]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.321]                         if (muffled) 
[10:21:23.321]                           invokeRestart("muffleWarning")
[10:21:23.321]                       }
[10:21:23.321]                       else if (inherits(cond, "condition")) {
[10:21:23.321]                         if (!is.null(pattern)) {
[10:21:23.321]                           computeRestarts <- base::computeRestarts
[10:21:23.321]                           grepl <- base::grepl
[10:21:23.321]                           restarts <- computeRestarts(cond)
[10:21:23.321]                           for (restart in restarts) {
[10:21:23.321]                             name <- restart$name
[10:21:23.321]                             if (is.null(name)) 
[10:21:23.321]                               next
[10:21:23.321]                             if (!grepl(pattern, name)) 
[10:21:23.321]                               next
[10:21:23.321]                             invokeRestart(restart)
[10:21:23.321]                             muffled <- TRUE
[10:21:23.321]                             break
[10:21:23.321]                           }
[10:21:23.321]                         }
[10:21:23.321]                       }
[10:21:23.321]                       invisible(muffled)
[10:21:23.321]                     }
[10:21:23.321]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.321]                   }
[10:21:23.321]                 }
[10:21:23.321]             }
[10:21:23.321]         }))
[10:21:23.321]     }, error = function(ex) {
[10:21:23.321]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.321]                 ...future.rng), started = ...future.startTime, 
[10:21:23.321]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.321]             version = "1.8"), class = "FutureResult")
[10:21:23.321]     }, finally = {
[10:21:23.321]         if (!identical(...future.workdir, getwd())) 
[10:21:23.321]             setwd(...future.workdir)
[10:21:23.321]         {
[10:21:23.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.321]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.321]             }
[10:21:23.321]             base::options(...future.oldOptions)
[10:21:23.321]             if (.Platform$OS.type == "windows") {
[10:21:23.321]                 old_names <- names(...future.oldEnvVars)
[10:21:23.321]                 envs <- base::Sys.getenv()
[10:21:23.321]                 names <- names(envs)
[10:21:23.321]                 common <- intersect(names, old_names)
[10:21:23.321]                 added <- setdiff(names, old_names)
[10:21:23.321]                 removed <- setdiff(old_names, names)
[10:21:23.321]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.321]                   envs[common]]
[10:21:23.321]                 NAMES <- toupper(changed)
[10:21:23.321]                 args <- list()
[10:21:23.321]                 for (kk in seq_along(NAMES)) {
[10:21:23.321]                   name <- changed[[kk]]
[10:21:23.321]                   NAME <- NAMES[[kk]]
[10:21:23.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.321]                     next
[10:21:23.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.321]                 }
[10:21:23.321]                 NAMES <- toupper(added)
[10:21:23.321]                 for (kk in seq_along(NAMES)) {
[10:21:23.321]                   name <- added[[kk]]
[10:21:23.321]                   NAME <- NAMES[[kk]]
[10:21:23.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.321]                     next
[10:21:23.321]                   args[[name]] <- ""
[10:21:23.321]                 }
[10:21:23.321]                 NAMES <- toupper(removed)
[10:21:23.321]                 for (kk in seq_along(NAMES)) {
[10:21:23.321]                   name <- removed[[kk]]
[10:21:23.321]                   NAME <- NAMES[[kk]]
[10:21:23.321]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.321]                     next
[10:21:23.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.321]                 }
[10:21:23.321]                 if (length(args) > 0) 
[10:21:23.321]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.321]             }
[10:21:23.321]             else {
[10:21:23.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.321]             }
[10:21:23.321]             {
[10:21:23.321]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.321]                   0L) {
[10:21:23.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.321]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.321]                   base::options(opts)
[10:21:23.321]                 }
[10:21:23.321]                 {
[10:21:23.321]                   {
[10:21:23.321]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.321]                     NULL
[10:21:23.321]                   }
[10:21:23.321]                   options(future.plan = NULL)
[10:21:23.321]                   if (is.na(NA_character_)) 
[10:21:23.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.321]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.321]                     .init = FALSE)
[10:21:23.321]                 }
[10:21:23.321]             }
[10:21:23.321]         }
[10:21:23.321]     })
[10:21:23.321]     if (TRUE) {
[10:21:23.321]         base::sink(type = "output", split = FALSE)
[10:21:23.321]         if (TRUE) {
[10:21:23.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.321]         }
[10:21:23.321]         else {
[10:21:23.321]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.321]         }
[10:21:23.321]         base::close(...future.stdout)
[10:21:23.321]         ...future.stdout <- NULL
[10:21:23.321]     }
[10:21:23.321]     ...future.result$conditions <- ...future.conditions
[10:21:23.321]     ...future.result$finished <- base::Sys.time()
[10:21:23.321]     ...future.result
[10:21:23.321] }
[10:21:23.325] requestCore(): workers = 2
[10:21:23.325] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:23.336] result() for MulticoreFuture ...
[10:21:23.337] result() for MulticoreFuture ...
[10:21:23.337] result() for MulticoreFuture ... done
[10:21:23.338] result() for MulticoreFuture ... done
[10:21:23.338] result() for MulticoreFuture ...
[10:21:23.338] result() for MulticoreFuture ... done
[10:21:23.341] MulticoreFuture started
[10:21:23.342] - Launch lazy future ... done
[10:21:23.342] run() for ‘MulticoreFuture’ ... done
[10:21:23.342] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55e8e37f10e0> 
[10:21:23.343] List of future strategies:
[10:21:23.343] 1. sequential:
[10:21:23.343]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:23.343]    - tweaked: FALSE
[10:21:23.343]    - call: NULL
[10:21:23.344] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55e8e6a461d8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[10:21:23.347] plan(): Setting new future strategy stack:
List of 4
  ..$ : chr [1:2] "a" "b"
[10:21:23.348] List of future strategies:
[10:21:23.348] 1. multicore:
[10:21:23.348]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:23.348]    - tweaked: FALSE
[10:21:23.348]    - call: plan(s  ..trategy)
$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:21:23.353] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:23.357] resolve() on list environment ...
[10:21:23.357]  recursive: 0
[10:21:23.359]  length: 6
[10:21:23.359]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:23.359] signalConditionsASAP(numeric, pos=1) ...
[10:21:23.359] - nx: 6
[10:21:23.359] - relay: TRUE
[10:21:23.359] - stdout: TRUE
[10:21:23.360] - signal: TRUE
[10:21:23.360] - resignal: FALSE
[10:21:23.360] - force: TRUE
[10:21:23.360] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.360] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.360]  - until=2
[10:21:23.360]  - relaying element #2
[10:21:23.360] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.361] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.361] signalConditionsASAP(NULL, pos=1) ... done
[10:21:23.361]  length: 5 (resolved future 1)
[10:21:23.361] Future #2
[10:21:23.361] result() for MulticoreFuture ...
[10:21:23.361] result() for MulticoreFuture ... done
[10:21:23.361] result() for MulticoreFuture ...
[10:21:23.362] result() for MulticoreFuture ... done
[10:21:23.362] signalConditionsASAP(MulticoreFuture, pos=2) ...
[10:21:23.362] - nx: 6
[10:21:23.362] - relay: TRUE
[10:21:23.362] - stdout: TRUE
[10:21:23.362] - signal: TRUE
[10:21:23.362] - resignal: FALSE
[10:21:23.362] - force: TRUE
[10:21:23.363] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.363] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.363]  - until=2
[10:21:23.363]  - relaying element #2
[10:21:23.363] result() for MulticoreFuture ...
[10:21:23.363] result() for MulticoreFuture ... done
[10:21:23.363] result() for MulticoreFuture ...
[10:21:23.364] result() for MulticoreFuture ... done
[10:21:23.364] result() for MulticoreFuture ...
[10:21:23.364] result() for MulticoreFuture ... done
[10:21:23.364] result() for MulticoreFuture ...
[10:21:23.364] result() for MulticoreFuture ... done
[10:21:23.364] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.364] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.364] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[10:21:23.365]  length: 4 (resolved future 2)
[10:21:23.365] Future #3
[10:21:23.365] result() for MulticoreFuture ...
[10:21:23.366] result() for MulticoreFuture ...
[10:21:23.366] result() for MulticoreFuture ... done
[10:21:23.366] result() for MulticoreFuture ... done
[10:21:23.366] result() for MulticoreFuture ...
[10:21:23.367] result() for MulticoreFuture ... done
[10:21:23.367] signalConditionsASAP(MulticoreFuture, pos=3) ...
[10:21:23.367] - nx: 6
[10:21:23.367] - relay: TRUE
[10:21:23.367] - stdout: TRUE
[10:21:23.367] - signal: TRUE
[10:21:23.367] - resignal: FALSE
[10:21:23.367] - force: TRUE
[10:21:23.368] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.368] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.368]  - until=3
[10:21:23.368]  - relaying element #3
[10:21:23.368] result() for MulticoreFuture ...
[10:21:23.368] result() for MulticoreFuture ... done
[10:21:23.368] result() for MulticoreFuture ...
[10:21:23.369] result() for MulticoreFuture ... done
[10:21:23.369] result() for MulticoreFuture ...
[10:21:23.369] result() for MulticoreFuture ... done
[10:21:23.369] result() for MulticoreFuture ...
[10:21:23.369] result() for MulticoreFuture ... done
[10:21:23.369] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.369] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.369] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[10:21:23.370]  length: 3 (resolved future 3)
[10:21:23.370] Future #4
[10:21:23.370] result() for MulticoreFuture ...
[10:21:23.371] result() for MulticoreFuture ...
[10:21:23.371] result() for MulticoreFuture ... done
[10:21:23.371] result() for MulticoreFuture ... done
[10:21:23.371] result() for MulticoreFuture ...
[10:21:23.371] result() for MulticoreFuture ... done
[10:21:23.372] signalConditionsASAP(MulticoreFuture, pos=4) ...
[10:21:23.372] - nx: 6
[10:21:23.372] - relay: TRUE
[10:21:23.372] - stdout: TRUE
[10:21:23.372] - signal: TRUE
[10:21:23.372] - resignal: FALSE
[10:21:23.373] - force: TRUE
[10:21:23.373] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.373] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.373]  - until=4
[10:21:23.373]  - relaying element #4
[10:21:23.373] result() for MulticoreFuture ...
[10:21:23.374] result() for MulticoreFuture ... done
[10:21:23.374] result() for MulticoreFuture ...
[10:21:23.374] result() for MulticoreFuture ... done
[10:21:23.374] result() for MulticoreFuture ...
[10:21:23.374] result() for MulticoreFuture ... done
[10:21:23.374] result() for MulticoreFuture ...
[10:21:23.375] result() for MulticoreFuture ... done
[10:21:23.375] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.375] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.375] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[10:21:23.375]  length: 2 (resolved future 4)
[10:21:23.375] signalConditionsASAP(NULL, pos=5) ...
[10:21:23.375] - nx: 6
[10:21:23.376] - relay: TRUE
[10:21:23.376] - stdout: TRUE
[10:21:23.376] - signal: TRUE
[10:21:23.376] - resignal: FALSE
[10:21:23.376] - force: TRUE
[10:21:23.376] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.376] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.376]  - until=6
[10:21:23.376]  - relaying element #6
[10:21:23.377] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:23.377] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.377] signalConditionsASAP(NULL, pos=5) ... done
[10:21:23.377]  length: 1 (resolved future 5)
[10:21:23.377] signalConditionsASAP(numeric, pos=6) ...
[10:21:23.377] - nx: 6
[10:21:23.377] - relay: TRUE
[10:21:23.377] - stdout: TRUE
[10:21:23.377] - signal: TRUE
[10:21:23.377] - resignal: FALSE
[10:21:23.378] - force: TRUE
[10:21:23.378] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[10:21:23.378] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.378]  - until=6
[10:21:23.378] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.378] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.378] signalConditionsASAP(numeric, pos=6) ... done
[10:21:23.378]  length: 0 (resolved future 6)
[10:21:23.378] Relaying remaining futures
[10:21:23.378] signalConditionsASAP(NULL, pos=0) ...
[10:21:23.378] - nx: 6
[10:21:23.379] - relay: TRUE
[10:21:23.379] - stdout: TRUE
[10:21:23.379] - signal: TRUE
[10:21:23.379] - resignal: FALSE
[10:21:23.379] - force: TRUE
[10:21:23.379] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.379] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:23.379] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.379] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.380] signalConditionsASAP(NULL, pos=0) ... done
[10:21:23.380] resolve() on list environment ... DONE
[10:21:23.380] result() for MulticoreFuture ...
[10:21:23.383] result() for MulticoreFuture ... done
[10:21:23.384] result() for MulticoreFuture ...
[10:21:23.384] result() for MulticoreFuture ... done
[10:21:23.384] result() for MulticoreFuture ...
[10:21:23.385] result() for MulticoreFuture ... done
[10:21:23.385] result() for MulticoreFuture ...
[10:21:23.385] result() for MulticoreFuture ... done
[10:21:23.385] result() for MulticoreFuture ...
[10:21:23.385] result() for MulticoreFuture ... done
[10:21:23.386] result() for MulticoreFuture ...
[10:21:23.386] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e6cffb08> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[10:21:23.388] plan(): Setting new future strategy stack:
[10:21:23.388] List of future strategies:
[10:21:23.388] 1. multisession:
[10:21:23.388]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:23.388]    - tweaked: FALSE
[10:21:23.388]    - call: plan(strategy)
[10:21:23.389] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:23.389] multisession:
[10:21:23.389] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:23.389] - tweaked: FALSE
[10:21:23.389] - call: plan(strategy)
[10:21:23.391] getGlobalsAndPackages() ...
[10:21:23.391] Not searching for globals
[10:21:23.391] - globals: [0] <none>
[10:21:23.391] getGlobalsAndPackages() ... DONE
[10:21:23.645] Packages needed by the future expression (n = 0): <none>
[10:21:23.645] Packages needed by future strategies (n = 0): <none>
[10:21:23.645] {
[10:21:23.645]     {
[10:21:23.645]         {
[10:21:23.645]             ...future.startTime <- base::Sys.time()
[10:21:23.645]             {
[10:21:23.645]                 {
[10:21:23.645]                   {
[10:21:23.645]                     {
[10:21:23.645]                       base::local({
[10:21:23.645]                         has_future <- base::requireNamespace("future", 
[10:21:23.645]                           quietly = TRUE)
[10:21:23.645]                         if (has_future) {
[10:21:23.645]                           ns <- base::getNamespace("future")
[10:21:23.645]                           version <- ns[[".package"]][["version"]]
[10:21:23.645]                           if (is.null(version)) 
[10:21:23.645]                             version <- utils::packageVersion("future")
[10:21:23.645]                         }
[10:21:23.645]                         else {
[10:21:23.645]                           version <- NULL
[10:21:23.645]                         }
[10:21:23.645]                         if (!has_future || version < "1.8.0") {
[10:21:23.645]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.645]                             "", base::R.version$version.string), 
[10:21:23.645]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.645]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.645]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.645]                               "release", "version")], collapse = " "), 
[10:21:23.645]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.645]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.645]                             info)
[10:21:23.645]                           info <- base::paste(info, collapse = "; ")
[10:21:23.645]                           if (!has_future) {
[10:21:23.645]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.645]                               info)
[10:21:23.645]                           }
[10:21:23.645]                           else {
[10:21:23.645]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.645]                               info, version)
[10:21:23.645]                           }
[10:21:23.645]                           base::stop(msg)
[10:21:23.645]                         }
[10:21:23.645]                       })
[10:21:23.645]                     }
[10:21:23.645]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.645]                     base::options(mc.cores = 1L)
[10:21:23.645]                   }
[10:21:23.645]                   ...future.strategy.old <- future::plan("list")
[10:21:23.645]                   options(future.plan = NULL)
[10:21:23.645]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.645]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.645]                 }
[10:21:23.645]                 ...future.workdir <- getwd()
[10:21:23.645]             }
[10:21:23.645]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.645]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.645]         }
[10:21:23.645]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.645]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.645]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.645]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.645]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.645]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.645]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.645]             base::names(...future.oldOptions))
[10:21:23.645]     }
[10:21:23.645]     if (FALSE) {
[10:21:23.645]     }
[10:21:23.645]     else {
[10:21:23.645]         if (TRUE) {
[10:21:23.645]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.645]                 open = "w")
[10:21:23.645]         }
[10:21:23.645]         else {
[10:21:23.645]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.645]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.645]         }
[10:21:23.645]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.645]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.645]             base::sink(type = "output", split = FALSE)
[10:21:23.645]             base::close(...future.stdout)
[10:21:23.645]         }, add = TRUE)
[10:21:23.645]     }
[10:21:23.645]     ...future.frame <- base::sys.nframe()
[10:21:23.645]     ...future.conditions <- base::list()
[10:21:23.645]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.645]     if (FALSE) {
[10:21:23.645]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.645]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.645]     }
[10:21:23.645]     ...future.result <- base::tryCatch({
[10:21:23.645]         base::withCallingHandlers({
[10:21:23.645]             ...future.value <- base::withVisible(base::local({
[10:21:23.645]                 ...future.makeSendCondition <- base::local({
[10:21:23.645]                   sendCondition <- NULL
[10:21:23.645]                   function(frame = 1L) {
[10:21:23.645]                     if (is.function(sendCondition)) 
[10:21:23.645]                       return(sendCondition)
[10:21:23.645]                     ns <- getNamespace("parallel")
[10:21:23.645]                     if (exists("sendData", mode = "function", 
[10:21:23.645]                       envir = ns)) {
[10:21:23.645]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:23.645]                         envir = ns)
[10:21:23.645]                       envir <- sys.frame(frame)
[10:21:23.645]                       master <- NULL
[10:21:23.645]                       while (!identical(envir, .GlobalEnv) && 
[10:21:23.645]                         !identical(envir, emptyenv())) {
[10:21:23.645]                         if (exists("master", mode = "list", envir = envir, 
[10:21:23.645]                           inherits = FALSE)) {
[10:21:23.645]                           master <- get("master", mode = "list", 
[10:21:23.645]                             envir = envir, inherits = FALSE)
[10:21:23.645]                           if (inherits(master, c("SOCKnode", 
[10:21:23.645]                             "SOCK0node"))) {
[10:21:23.645]                             sendCondition <<- function(cond) {
[10:21:23.645]                               data <- list(type = "VALUE", value = cond, 
[10:21:23.645]                                 success = TRUE)
[10:21:23.645]                               parallel_sendData(master, data)
[10:21:23.645]                             }
[10:21:23.645]                             return(sendCondition)
[10:21:23.645]                           }
[10:21:23.645]                         }
[10:21:23.645]                         frame <- frame + 1L
[10:21:23.645]                         envir <- sys.frame(frame)
[10:21:23.645]                       }
[10:21:23.645]                     }
[10:21:23.645]                     sendCondition <<- function(cond) NULL
[10:21:23.645]                   }
[10:21:23.645]                 })
[10:21:23.645]                 withCallingHandlers({
[10:21:23.645]                   NA
[10:21:23.645]                 }, immediateCondition = function(cond) {
[10:21:23.645]                   sendCondition <- ...future.makeSendCondition()
[10:21:23.645]                   sendCondition(cond)
[10:21:23.645]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.645]                   {
[10:21:23.645]                     inherits <- base::inherits
[10:21:23.645]                     invokeRestart <- base::invokeRestart
[10:21:23.645]                     is.null <- base::is.null
[10:21:23.645]                     muffled <- FALSE
[10:21:23.645]                     if (inherits(cond, "message")) {
[10:21:23.645]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.645]                       if (muffled) 
[10:21:23.645]                         invokeRestart("muffleMessage")
[10:21:23.645]                     }
[10:21:23.645]                     else if (inherits(cond, "warning")) {
[10:21:23.645]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.645]                       if (muffled) 
[10:21:23.645]                         invokeRestart("muffleWarning")
[10:21:23.645]                     }
[10:21:23.645]                     else if (inherits(cond, "condition")) {
[10:21:23.645]                       if (!is.null(pattern)) {
[10:21:23.645]                         computeRestarts <- base::computeRestarts
[10:21:23.645]                         grepl <- base::grepl
[10:21:23.645]                         restarts <- computeRestarts(cond)
[10:21:23.645]                         for (restart in restarts) {
[10:21:23.645]                           name <- restart$name
[10:21:23.645]                           if (is.null(name)) 
[10:21:23.645]                             next
[10:21:23.645]                           if (!grepl(pattern, name)) 
[10:21:23.645]                             next
[10:21:23.645]                           invokeRestart(restart)
[10:21:23.645]                           muffled <- TRUE
[10:21:23.645]                           break
[10:21:23.645]                         }
[10:21:23.645]                       }
[10:21:23.645]                     }
[10:21:23.645]                     invisible(muffled)
[10:21:23.645]                   }
[10:21:23.645]                   muffleCondition(cond)
[10:21:23.645]                 })
[10:21:23.645]             }))
[10:21:23.645]             future::FutureResult(value = ...future.value$value, 
[10:21:23.645]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.645]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.645]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.645]                     ...future.globalenv.names))
[10:21:23.645]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.645]         }, condition = base::local({
[10:21:23.645]             c <- base::c
[10:21:23.645]             inherits <- base::inherits
[10:21:23.645]             invokeRestart <- base::invokeRestart
[10:21:23.645]             length <- base::length
[10:21:23.645]             list <- base::list
[10:21:23.645]             seq.int <- base::seq.int
[10:21:23.645]             signalCondition <- base::signalCondition
[10:21:23.645]             sys.calls <- base::sys.calls
[10:21:23.645]             `[[` <- base::`[[`
[10:21:23.645]             `+` <- base::`+`
[10:21:23.645]             `<<-` <- base::`<<-`
[10:21:23.645]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.645]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.645]                   3L)]
[10:21:23.645]             }
[10:21:23.645]             function(cond) {
[10:21:23.645]                 is_error <- inherits(cond, "error")
[10:21:23.645]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.645]                   NULL)
[10:21:23.645]                 if (is_error) {
[10:21:23.645]                   sessionInformation <- function() {
[10:21:23.645]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.645]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.645]                       search = base::search(), system = base::Sys.info())
[10:21:23.645]                   }
[10:21:23.645]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.645]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.645]                     cond$call), session = sessionInformation(), 
[10:21:23.645]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.645]                   signalCondition(cond)
[10:21:23.645]                 }
[10:21:23.645]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.645]                 "immediateCondition"))) {
[10:21:23.645]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.645]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.645]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.645]                   if (TRUE && !signal) {
[10:21:23.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.645]                     {
[10:21:23.645]                       inherits <- base::inherits
[10:21:23.645]                       invokeRestart <- base::invokeRestart
[10:21:23.645]                       is.null <- base::is.null
[10:21:23.645]                       muffled <- FALSE
[10:21:23.645]                       if (inherits(cond, "message")) {
[10:21:23.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.645]                         if (muffled) 
[10:21:23.645]                           invokeRestart("muffleMessage")
[10:21:23.645]                       }
[10:21:23.645]                       else if (inherits(cond, "warning")) {
[10:21:23.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.645]                         if (muffled) 
[10:21:23.645]                           invokeRestart("muffleWarning")
[10:21:23.645]                       }
[10:21:23.645]                       else if (inherits(cond, "condition")) {
[10:21:23.645]                         if (!is.null(pattern)) {
[10:21:23.645]                           computeRestarts <- base::computeRestarts
[10:21:23.645]                           grepl <- base::grepl
[10:21:23.645]                           restarts <- computeRestarts(cond)
[10:21:23.645]                           for (restart in restarts) {
[10:21:23.645]                             name <- restart$name
[10:21:23.645]                             if (is.null(name)) 
[10:21:23.645]                               next
[10:21:23.645]                             if (!grepl(pattern, name)) 
[10:21:23.645]                               next
[10:21:23.645]                             invokeRestart(restart)
[10:21:23.645]                             muffled <- TRUE
[10:21:23.645]                             break
[10:21:23.645]                           }
[10:21:23.645]                         }
[10:21:23.645]                       }
[10:21:23.645]                       invisible(muffled)
[10:21:23.645]                     }
[10:21:23.645]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.645]                   }
[10:21:23.645]                 }
[10:21:23.645]                 else {
[10:21:23.645]                   if (TRUE) {
[10:21:23.645]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.645]                     {
[10:21:23.645]                       inherits <- base::inherits
[10:21:23.645]                       invokeRestart <- base::invokeRestart
[10:21:23.645]                       is.null <- base::is.null
[10:21:23.645]                       muffled <- FALSE
[10:21:23.645]                       if (inherits(cond, "message")) {
[10:21:23.645]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.645]                         if (muffled) 
[10:21:23.645]                           invokeRestart("muffleMessage")
[10:21:23.645]                       }
[10:21:23.645]                       else if (inherits(cond, "warning")) {
[10:21:23.645]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.645]                         if (muffled) 
[10:21:23.645]                           invokeRestart("muffleWarning")
[10:21:23.645]                       }
[10:21:23.645]                       else if (inherits(cond, "condition")) {
[10:21:23.645]                         if (!is.null(pattern)) {
[10:21:23.645]                           computeRestarts <- base::computeRestarts
[10:21:23.645]                           grepl <- base::grepl
[10:21:23.645]                           restarts <- computeRestarts(cond)
[10:21:23.645]                           for (restart in restarts) {
[10:21:23.645]                             name <- restart$name
[10:21:23.645]                             if (is.null(name)) 
[10:21:23.645]                               next
[10:21:23.645]                             if (!grepl(pattern, name)) 
[10:21:23.645]                               next
[10:21:23.645]                             invokeRestart(restart)
[10:21:23.645]                             muffled <- TRUE
[10:21:23.645]                             break
[10:21:23.645]                           }
[10:21:23.645]                         }
[10:21:23.645]                       }
[10:21:23.645]                       invisible(muffled)
[10:21:23.645]                     }
[10:21:23.645]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.645]                   }
[10:21:23.645]                 }
[10:21:23.645]             }
[10:21:23.645]         }))
[10:21:23.645]     }, error = function(ex) {
[10:21:23.645]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.645]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.645]                 ...future.rng), started = ...future.startTime, 
[10:21:23.645]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.645]             version = "1.8"), class = "FutureResult")
[10:21:23.645]     }, finally = {
[10:21:23.645]         if (!identical(...future.workdir, getwd())) 
[10:21:23.645]             setwd(...future.workdir)
[10:21:23.645]         {
[10:21:23.645]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.645]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.645]             }
[10:21:23.645]             base::options(...future.oldOptions)
[10:21:23.645]             if (.Platform$OS.type == "windows") {
[10:21:23.645]                 old_names <- names(...future.oldEnvVars)
[10:21:23.645]                 envs <- base::Sys.getenv()
[10:21:23.645]                 names <- names(envs)
[10:21:23.645]                 common <- intersect(names, old_names)
[10:21:23.645]                 added <- setdiff(names, old_names)
[10:21:23.645]                 removed <- setdiff(old_names, names)
[10:21:23.645]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.645]                   envs[common]]
[10:21:23.645]                 NAMES <- toupper(changed)
[10:21:23.645]                 args <- list()
[10:21:23.645]                 for (kk in seq_along(NAMES)) {
[10:21:23.645]                   name <- changed[[kk]]
[10:21:23.645]                   NAME <- NAMES[[kk]]
[10:21:23.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.645]                     next
[10:21:23.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.645]                 }
[10:21:23.645]                 NAMES <- toupper(added)
[10:21:23.645]                 for (kk in seq_along(NAMES)) {
[10:21:23.645]                   name <- added[[kk]]
[10:21:23.645]                   NAME <- NAMES[[kk]]
[10:21:23.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.645]                     next
[10:21:23.645]                   args[[name]] <- ""
[10:21:23.645]                 }
[10:21:23.645]                 NAMES <- toupper(removed)
[10:21:23.645]                 for (kk in seq_along(NAMES)) {
[10:21:23.645]                   name <- removed[[kk]]
[10:21:23.645]                   NAME <- NAMES[[kk]]
[10:21:23.645]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.645]                     next
[10:21:23.645]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.645]                 }
[10:21:23.645]                 if (length(args) > 0) 
[10:21:23.645]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.645]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.645]             }
[10:21:23.645]             else {
[10:21:23.645]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.645]             }
[10:21:23.645]             {
[10:21:23.645]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.645]                   0L) {
[10:21:23.645]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.645]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.645]                   base::options(opts)
[10:21:23.645]                 }
[10:21:23.645]                 {
[10:21:23.645]                   {
[10:21:23.645]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.645]                     NULL
[10:21:23.645]                   }
[10:21:23.645]                   options(future.plan = NULL)
[10:21:23.645]                   if (is.na(NA_character_)) 
[10:21:23.645]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.645]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.645]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.645]                     .init = FALSE)
[10:21:23.645]                 }
[10:21:23.645]             }
[10:21:23.645]         }
[10:21:23.645]     })
[10:21:23.645]     if (TRUE) {
[10:21:23.645]         base::sink(type = "output", split = FALSE)
[10:21:23.645]         if (TRUE) {
[10:21:23.645]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.645]         }
[10:21:23.645]         else {
[10:21:23.645]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.645]         }
[10:21:23.645]         base::close(...future.stdout)
[10:21:23.645]         ...future.stdout <- NULL
[10:21:23.645]     }
[10:21:23.645]     ...future.result$conditions <- ...future.conditions
[10:21:23.645]     ...future.result$finished <- base::Sys.time()
[10:21:23.645]     ...future.result
[10:21:23.645] }
[10:21:23.697] MultisessionFuture started
[10:21:23.697] result() for ClusterFuture ...
[10:21:23.698] receiveMessageFromWorker() for ClusterFuture ...
[10:21:23.698] - Validating connection of MultisessionFuture
[10:21:23.728] - received message: FutureResult
[10:21:23.728] - Received FutureResult
[10:21:23.728] - Erased future from FutureRegistry
[10:21:23.728] result() for ClusterFuture ...
[10:21:23.728] - result already collected: FutureResult
[10:21:23.728] result() for ClusterFuture ... done
[10:21:23.729] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:23.729] result() for ClusterFuture ... done
[10:21:23.729] result() for ClusterFuture ...
[10:21:23.729] - result already collected: FutureResult
[10:21:23.729] result() for ClusterFuture ... done
[10:21:23.729] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:23.731] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[10:21:23.731] getGlobalsAndPackages() ...
[10:21:23.731] Searching for globals...
[10:21:23.732] 
[10:21:23.732] Searching for globals ... DONE
[10:21:23.732] - globals: [0] <none>
[10:21:23.732] getGlobalsAndPackages() ... DONE
[10:21:23.732] run() for ‘Future’ ...
[10:21:23.732] - state: ‘created’
[10:21:23.733] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.747] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:23.748]   - Field: ‘node’
[10:21:23.748]   - Field: ‘label’
[10:21:23.748]   - Field: ‘local’
[10:21:23.748]   - Field: ‘owner’
[10:21:23.748]   - Field: ‘envir’
[10:21:23.748]   - Field: ‘workers’
[10:21:23.748]   - Field: ‘packages’
[10:21:23.748]   - Field: ‘gc’
[10:21:23.749]   - Field: ‘conditions’
[10:21:23.749]   - Field: ‘persistent’
[10:21:23.749]   - Field: ‘expr’
[10:21:23.749]   - Field: ‘uuid’
[10:21:23.749]   - Field: ‘seed’
[10:21:23.749]   - Field: ‘version’
[10:21:23.749]   - Field: ‘result’
[10:21:23.749]   - Field: ‘asynchronous’
[10:21:23.749]   - Field: ‘calls’
[10:21:23.750]   - Field: ‘globals’
[10:21:23.750]   - Field: ‘stdout’
[10:21:23.750]   - Field: ‘earlySignal’
[10:21:23.750]   - Field: ‘lazy’
[10:21:23.750]   - Field: ‘state’
[10:21:23.750] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:23.750] - Launch lazy future ...
[10:21:23.751] Packages needed by the future expression (n = 0): <none>
[10:21:23.751] Packages needed by future strategies (n = 0): <none>
[10:21:23.751] {
[10:21:23.751]     {
[10:21:23.751]         {
[10:21:23.751]             ...future.startTime <- base::Sys.time()
[10:21:23.751]             {
[10:21:23.751]                 {
[10:21:23.751]                   {
[10:21:23.751]                     {
[10:21:23.751]                       base::local({
[10:21:23.751]                         has_future <- base::requireNamespace("future", 
[10:21:23.751]                           quietly = TRUE)
[10:21:23.751]                         if (has_future) {
[10:21:23.751]                           ns <- base::getNamespace("future")
[10:21:23.751]                           version <- ns[[".package"]][["version"]]
[10:21:23.751]                           if (is.null(version)) 
[10:21:23.751]                             version <- utils::packageVersion("future")
[10:21:23.751]                         }
[10:21:23.751]                         else {
[10:21:23.751]                           version <- NULL
[10:21:23.751]                         }
[10:21:23.751]                         if (!has_future || version < "1.8.0") {
[10:21:23.751]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.751]                             "", base::R.version$version.string), 
[10:21:23.751]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.751]                               "release", "version")], collapse = " "), 
[10:21:23.751]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.751]                             info)
[10:21:23.751]                           info <- base::paste(info, collapse = "; ")
[10:21:23.751]                           if (!has_future) {
[10:21:23.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.751]                               info)
[10:21:23.751]                           }
[10:21:23.751]                           else {
[10:21:23.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.751]                               info, version)
[10:21:23.751]                           }
[10:21:23.751]                           base::stop(msg)
[10:21:23.751]                         }
[10:21:23.751]                       })
[10:21:23.751]                     }
[10:21:23.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.751]                     base::options(mc.cores = 1L)
[10:21:23.751]                   }
[10:21:23.751]                   ...future.strategy.old <- future::plan("list")
[10:21:23.751]                   options(future.plan = NULL)
[10:21:23.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.751]                 }
[10:21:23.751]                 ...future.workdir <- getwd()
[10:21:23.751]             }
[10:21:23.751]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.751]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.751]         }
[10:21:23.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.751]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.751]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.751]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.751]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.751]             base::names(...future.oldOptions))
[10:21:23.751]     }
[10:21:23.751]     if (FALSE) {
[10:21:23.751]     }
[10:21:23.751]     else {
[10:21:23.751]         if (TRUE) {
[10:21:23.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.751]                 open = "w")
[10:21:23.751]         }
[10:21:23.751]         else {
[10:21:23.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.751]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.751]         }
[10:21:23.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.751]             base::sink(type = "output", split = FALSE)
[10:21:23.751]             base::close(...future.stdout)
[10:21:23.751]         }, add = TRUE)
[10:21:23.751]     }
[10:21:23.751]     ...future.frame <- base::sys.nframe()
[10:21:23.751]     ...future.conditions <- base::list()
[10:21:23.751]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.751]     if (FALSE) {
[10:21:23.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.751]     }
[10:21:23.751]     ...future.result <- base::tryCatch({
[10:21:23.751]         base::withCallingHandlers({
[10:21:23.751]             ...future.value <- base::withVisible(base::local({
[10:21:23.751]                 ...future.makeSendCondition <- base::local({
[10:21:23.751]                   sendCondition <- NULL
[10:21:23.751]                   function(frame = 1L) {
[10:21:23.751]                     if (is.function(sendCondition)) 
[10:21:23.751]                       return(sendCondition)
[10:21:23.751]                     ns <- getNamespace("parallel")
[10:21:23.751]                     if (exists("sendData", mode = "function", 
[10:21:23.751]                       envir = ns)) {
[10:21:23.751]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:23.751]                         envir = ns)
[10:21:23.751]                       envir <- sys.frame(frame)
[10:21:23.751]                       master <- NULL
[10:21:23.751]                       while (!identical(envir, .GlobalEnv) && 
[10:21:23.751]                         !identical(envir, emptyenv())) {
[10:21:23.751]                         if (exists("master", mode = "list", envir = envir, 
[10:21:23.751]                           inherits = FALSE)) {
[10:21:23.751]                           master <- get("master", mode = "list", 
[10:21:23.751]                             envir = envir, inherits = FALSE)
[10:21:23.751]                           if (inherits(master, c("SOCKnode", 
[10:21:23.751]                             "SOCK0node"))) {
[10:21:23.751]                             sendCondition <<- function(cond) {
[10:21:23.751]                               data <- list(type = "VALUE", value = cond, 
[10:21:23.751]                                 success = TRUE)
[10:21:23.751]                               parallel_sendData(master, data)
[10:21:23.751]                             }
[10:21:23.751]                             return(sendCondition)
[10:21:23.751]                           }
[10:21:23.751]                         }
[10:21:23.751]                         frame <- frame + 1L
[10:21:23.751]                         envir <- sys.frame(frame)
[10:21:23.751]                       }
[10:21:23.751]                     }
[10:21:23.751]                     sendCondition <<- function(cond) NULL
[10:21:23.751]                   }
[10:21:23.751]                 })
[10:21:23.751]                 withCallingHandlers({
[10:21:23.751]                   2
[10:21:23.751]                 }, immediateCondition = function(cond) {
[10:21:23.751]                   sendCondition <- ...future.makeSendCondition()
[10:21:23.751]                   sendCondition(cond)
[10:21:23.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.751]                   {
[10:21:23.751]                     inherits <- base::inherits
[10:21:23.751]                     invokeRestart <- base::invokeRestart
[10:21:23.751]                     is.null <- base::is.null
[10:21:23.751]                     muffled <- FALSE
[10:21:23.751]                     if (inherits(cond, "message")) {
[10:21:23.751]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.751]                       if (muffled) 
[10:21:23.751]                         invokeRestart("muffleMessage")
[10:21:23.751]                     }
[10:21:23.751]                     else if (inherits(cond, "warning")) {
[10:21:23.751]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.751]                       if (muffled) 
[10:21:23.751]                         invokeRestart("muffleWarning")
[10:21:23.751]                     }
[10:21:23.751]                     else if (inherits(cond, "condition")) {
[10:21:23.751]                       if (!is.null(pattern)) {
[10:21:23.751]                         computeRestarts <- base::computeRestarts
[10:21:23.751]                         grepl <- base::grepl
[10:21:23.751]                         restarts <- computeRestarts(cond)
[10:21:23.751]                         for (restart in restarts) {
[10:21:23.751]                           name <- restart$name
[10:21:23.751]                           if (is.null(name)) 
[10:21:23.751]                             next
[10:21:23.751]                           if (!grepl(pattern, name)) 
[10:21:23.751]                             next
[10:21:23.751]                           invokeRestart(restart)
[10:21:23.751]                           muffled <- TRUE
[10:21:23.751]                           break
[10:21:23.751]                         }
[10:21:23.751]                       }
[10:21:23.751]                     }
[10:21:23.751]                     invisible(muffled)
[10:21:23.751]                   }
[10:21:23.751]                   muffleCondition(cond)
[10:21:23.751]                 })
[10:21:23.751]             }))
[10:21:23.751]             future::FutureResult(value = ...future.value$value, 
[10:21:23.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.751]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.751]                     ...future.globalenv.names))
[10:21:23.751]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.751]         }, condition = base::local({
[10:21:23.751]             c <- base::c
[10:21:23.751]             inherits <- base::inherits
[10:21:23.751]             invokeRestart <- base::invokeRestart
[10:21:23.751]             length <- base::length
[10:21:23.751]             list <- base::list
[10:21:23.751]             seq.int <- base::seq.int
[10:21:23.751]             signalCondition <- base::signalCondition
[10:21:23.751]             sys.calls <- base::sys.calls
[10:21:23.751]             `[[` <- base::`[[`
[10:21:23.751]             `+` <- base::`+`
[10:21:23.751]             `<<-` <- base::`<<-`
[10:21:23.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.751]                   3L)]
[10:21:23.751]             }
[10:21:23.751]             function(cond) {
[10:21:23.751]                 is_error <- inherits(cond, "error")
[10:21:23.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.751]                   NULL)
[10:21:23.751]                 if (is_error) {
[10:21:23.751]                   sessionInformation <- function() {
[10:21:23.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.751]                       search = base::search(), system = base::Sys.info())
[10:21:23.751]                   }
[10:21:23.751]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.751]                     cond$call), session = sessionInformation(), 
[10:21:23.751]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.751]                   signalCondition(cond)
[10:21:23.751]                 }
[10:21:23.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.751]                 "immediateCondition"))) {
[10:21:23.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.751]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.751]                   if (TRUE && !signal) {
[10:21:23.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.751]                     {
[10:21:23.751]                       inherits <- base::inherits
[10:21:23.751]                       invokeRestart <- base::invokeRestart
[10:21:23.751]                       is.null <- base::is.null
[10:21:23.751]                       muffled <- FALSE
[10:21:23.751]                       if (inherits(cond, "message")) {
[10:21:23.751]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.751]                         if (muffled) 
[10:21:23.751]                           invokeRestart("muffleMessage")
[10:21:23.751]                       }
[10:21:23.751]                       else if (inherits(cond, "warning")) {
[10:21:23.751]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.751]                         if (muffled) 
[10:21:23.751]                           invokeRestart("muffleWarning")
[10:21:23.751]                       }
[10:21:23.751]                       else if (inherits(cond, "condition")) {
[10:21:23.751]                         if (!is.null(pattern)) {
[10:21:23.751]                           computeRestarts <- base::computeRestarts
[10:21:23.751]                           grepl <- base::grepl
[10:21:23.751]                           restarts <- computeRestarts(cond)
[10:21:23.751]                           for (restart in restarts) {
[10:21:23.751]                             name <- restart$name
[10:21:23.751]                             if (is.null(name)) 
[10:21:23.751]                               next
[10:21:23.751]                             if (!grepl(pattern, name)) 
[10:21:23.751]                               next
[10:21:23.751]                             invokeRestart(restart)
[10:21:23.751]                             muffled <- TRUE
[10:21:23.751]                             break
[10:21:23.751]                           }
[10:21:23.751]                         }
[10:21:23.751]                       }
[10:21:23.751]                       invisible(muffled)
[10:21:23.751]                     }
[10:21:23.751]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.751]                   }
[10:21:23.751]                 }
[10:21:23.751]                 else {
[10:21:23.751]                   if (TRUE) {
[10:21:23.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.751]                     {
[10:21:23.751]                       inherits <- base::inherits
[10:21:23.751]                       invokeRestart <- base::invokeRestart
[10:21:23.751]                       is.null <- base::is.null
[10:21:23.751]                       muffled <- FALSE
[10:21:23.751]                       if (inherits(cond, "message")) {
[10:21:23.751]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.751]                         if (muffled) 
[10:21:23.751]                           invokeRestart("muffleMessage")
[10:21:23.751]                       }
[10:21:23.751]                       else if (inherits(cond, "warning")) {
[10:21:23.751]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.751]                         if (muffled) 
[10:21:23.751]                           invokeRestart("muffleWarning")
[10:21:23.751]                       }
[10:21:23.751]                       else if (inherits(cond, "condition")) {
[10:21:23.751]                         if (!is.null(pattern)) {
[10:21:23.751]                           computeRestarts <- base::computeRestarts
[10:21:23.751]                           grepl <- base::grepl
[10:21:23.751]                           restarts <- computeRestarts(cond)
[10:21:23.751]                           for (restart in restarts) {
[10:21:23.751]                             name <- restart$name
[10:21:23.751]                             if (is.null(name)) 
[10:21:23.751]                               next
[10:21:23.751]                             if (!grepl(pattern, name)) 
[10:21:23.751]                               next
[10:21:23.751]                             invokeRestart(restart)
[10:21:23.751]                             muffled <- TRUE
[10:21:23.751]                             break
[10:21:23.751]                           }
[10:21:23.751]                         }
[10:21:23.751]                       }
[10:21:23.751]                       invisible(muffled)
[10:21:23.751]                     }
[10:21:23.751]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.751]                   }
[10:21:23.751]                 }
[10:21:23.751]             }
[10:21:23.751]         }))
[10:21:23.751]     }, error = function(ex) {
[10:21:23.751]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.751]                 ...future.rng), started = ...future.startTime, 
[10:21:23.751]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.751]             version = "1.8"), class = "FutureResult")
[10:21:23.751]     }, finally = {
[10:21:23.751]         if (!identical(...future.workdir, getwd())) 
[10:21:23.751]             setwd(...future.workdir)
[10:21:23.751]         {
[10:21:23.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.751]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.751]             }
[10:21:23.751]             base::options(...future.oldOptions)
[10:21:23.751]             if (.Platform$OS.type == "windows") {
[10:21:23.751]                 old_names <- names(...future.oldEnvVars)
[10:21:23.751]                 envs <- base::Sys.getenv()
[10:21:23.751]                 names <- names(envs)
[10:21:23.751]                 common <- intersect(names, old_names)
[10:21:23.751]                 added <- setdiff(names, old_names)
[10:21:23.751]                 removed <- setdiff(old_names, names)
[10:21:23.751]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.751]                   envs[common]]
[10:21:23.751]                 NAMES <- toupper(changed)
[10:21:23.751]                 args <- list()
[10:21:23.751]                 for (kk in seq_along(NAMES)) {
[10:21:23.751]                   name <- changed[[kk]]
[10:21:23.751]                   NAME <- NAMES[[kk]]
[10:21:23.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.751]                     next
[10:21:23.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.751]                 }
[10:21:23.751]                 NAMES <- toupper(added)
[10:21:23.751]                 for (kk in seq_along(NAMES)) {
[10:21:23.751]                   name <- added[[kk]]
[10:21:23.751]                   NAME <- NAMES[[kk]]
[10:21:23.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.751]                     next
[10:21:23.751]                   args[[name]] <- ""
[10:21:23.751]                 }
[10:21:23.751]                 NAMES <- toupper(removed)
[10:21:23.751]                 for (kk in seq_along(NAMES)) {
[10:21:23.751]                   name <- removed[[kk]]
[10:21:23.751]                   NAME <- NAMES[[kk]]
[10:21:23.751]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.751]                     next
[10:21:23.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.751]                 }
[10:21:23.751]                 if (length(args) > 0) 
[10:21:23.751]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.751]             }
[10:21:23.751]             else {
[10:21:23.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.751]             }
[10:21:23.751]             {
[10:21:23.751]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.751]                   0L) {
[10:21:23.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.751]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.751]                   base::options(opts)
[10:21:23.751]                 }
[10:21:23.751]                 {
[10:21:23.751]                   {
[10:21:23.751]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.751]                     NULL
[10:21:23.751]                   }
[10:21:23.751]                   options(future.plan = NULL)
[10:21:23.751]                   if (is.na(NA_character_)) 
[10:21:23.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.751]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.751]                     .init = FALSE)
[10:21:23.751]                 }
[10:21:23.751]             }
[10:21:23.751]         }
[10:21:23.751]     })
[10:21:23.751]     if (TRUE) {
[10:21:23.751]         base::sink(type = "output", split = FALSE)
[10:21:23.751]         if (TRUE) {
[10:21:23.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.751]         }
[10:21:23.751]         else {
[10:21:23.751]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.751]         }
[10:21:23.751]         base::close(...future.stdout)
[10:21:23.751]         ...future.stdout <- NULL
[10:21:23.751]     }
[10:21:23.751]     ...future.result$conditions <- ...future.conditions
[10:21:23.751]     ...future.result$finished <- base::Sys.time()
[10:21:23.751]     ...future.result
[10:21:23.751] }
[10:21:23.754] MultisessionFuture started
[10:21:23.755] - Launch lazy future ... done
[10:21:23.755] run() for ‘MultisessionFuture’ ... done
[10:21:23.755] getGlobalsAndPackages() ...
[10:21:23.755] Searching for globals...
[10:21:23.755] 
[10:21:23.755] Searching for globals ... DONE
[10:21:23.756] - globals: [0] <none>
[10:21:23.756] getGlobalsAndPackages() ... DONE
[10:21:23.756] run() for ‘Future’ ...
[10:21:23.756] - state: ‘created’
[10:21:23.756] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.771] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:23.772]   - Field: ‘node’
[10:21:23.772]   - Field: ‘label’
[10:21:23.772]   - Field: ‘local’
[10:21:23.772]   - Field: ‘owner’
[10:21:23.772]   - Field: ‘envir’
[10:21:23.772]   - Field: ‘workers’
[10:21:23.772]   - Field: ‘packages’
[10:21:23.772]   - Field: ‘gc’
[10:21:23.773]   - Field: ‘conditions’
[10:21:23.773]   - Field: ‘persistent’
[10:21:23.773]   - Field: ‘expr’
[10:21:23.773]   - Field: ‘uuid’
[10:21:23.773]   - Field: ‘seed’
[10:21:23.773]   - Field: ‘version’
[10:21:23.773]   - Field: ‘result’
[10:21:23.773]   - Field: ‘asynchronous’
[10:21:23.773]   - Field: ‘calls’
[10:21:23.773]   - Field: ‘globals’
[10:21:23.774]   - Field: ‘stdout’
[10:21:23.774]   - Field: ‘earlySignal’
[10:21:23.774]   - Field: ‘lazy’
[10:21:23.774]   - Field: ‘state’
[10:21:23.774] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:23.774] - Launch lazy future ...
[10:21:23.774] Packages needed by the future expression (n = 0): <none>
[10:21:23.774] Packages needed by future strategies (n = 0): <none>
[10:21:23.775] {
[10:21:23.775]     {
[10:21:23.775]         {
[10:21:23.775]             ...future.startTime <- base::Sys.time()
[10:21:23.775]             {
[10:21:23.775]                 {
[10:21:23.775]                   {
[10:21:23.775]                     {
[10:21:23.775]                       base::local({
[10:21:23.775]                         has_future <- base::requireNamespace("future", 
[10:21:23.775]                           quietly = TRUE)
[10:21:23.775]                         if (has_future) {
[10:21:23.775]                           ns <- base::getNamespace("future")
[10:21:23.775]                           version <- ns[[".package"]][["version"]]
[10:21:23.775]                           if (is.null(version)) 
[10:21:23.775]                             version <- utils::packageVersion("future")
[10:21:23.775]                         }
[10:21:23.775]                         else {
[10:21:23.775]                           version <- NULL
[10:21:23.775]                         }
[10:21:23.775]                         if (!has_future || version < "1.8.0") {
[10:21:23.775]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.775]                             "", base::R.version$version.string), 
[10:21:23.775]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.775]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.775]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.775]                               "release", "version")], collapse = " "), 
[10:21:23.775]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.775]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.775]                             info)
[10:21:23.775]                           info <- base::paste(info, collapse = "; ")
[10:21:23.775]                           if (!has_future) {
[10:21:23.775]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.775]                               info)
[10:21:23.775]                           }
[10:21:23.775]                           else {
[10:21:23.775]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.775]                               info, version)
[10:21:23.775]                           }
[10:21:23.775]                           base::stop(msg)
[10:21:23.775]                         }
[10:21:23.775]                       })
[10:21:23.775]                     }
[10:21:23.775]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.775]                     base::options(mc.cores = 1L)
[10:21:23.775]                   }
[10:21:23.775]                   ...future.strategy.old <- future::plan("list")
[10:21:23.775]                   options(future.plan = NULL)
[10:21:23.775]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.775]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.775]                 }
[10:21:23.775]                 ...future.workdir <- getwd()
[10:21:23.775]             }
[10:21:23.775]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.775]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.775]         }
[10:21:23.775]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.775]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.775]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.775]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.775]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.775]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.775]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.775]             base::names(...future.oldOptions))
[10:21:23.775]     }
[10:21:23.775]     if (FALSE) {
[10:21:23.775]     }
[10:21:23.775]     else {
[10:21:23.775]         if (TRUE) {
[10:21:23.775]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.775]                 open = "w")
[10:21:23.775]         }
[10:21:23.775]         else {
[10:21:23.775]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.775]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.775]         }
[10:21:23.775]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.775]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.775]             base::sink(type = "output", split = FALSE)
[10:21:23.775]             base::close(...future.stdout)
[10:21:23.775]         }, add = TRUE)
[10:21:23.775]     }
[10:21:23.775]     ...future.frame <- base::sys.nframe()
[10:21:23.775]     ...future.conditions <- base::list()
[10:21:23.775]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.775]     if (FALSE) {
[10:21:23.775]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.775]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.775]     }
[10:21:23.775]     ...future.result <- base::tryCatch({
[10:21:23.775]         base::withCallingHandlers({
[10:21:23.775]             ...future.value <- base::withVisible(base::local({
[10:21:23.775]                 ...future.makeSendCondition <- base::local({
[10:21:23.775]                   sendCondition <- NULL
[10:21:23.775]                   function(frame = 1L) {
[10:21:23.775]                     if (is.function(sendCondition)) 
[10:21:23.775]                       return(sendCondition)
[10:21:23.775]                     ns <- getNamespace("parallel")
[10:21:23.775]                     if (exists("sendData", mode = "function", 
[10:21:23.775]                       envir = ns)) {
[10:21:23.775]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:23.775]                         envir = ns)
[10:21:23.775]                       envir <- sys.frame(frame)
[10:21:23.775]                       master <- NULL
[10:21:23.775]                       while (!identical(envir, .GlobalEnv) && 
[10:21:23.775]                         !identical(envir, emptyenv())) {
[10:21:23.775]                         if (exists("master", mode = "list", envir = envir, 
[10:21:23.775]                           inherits = FALSE)) {
[10:21:23.775]                           master <- get("master", mode = "list", 
[10:21:23.775]                             envir = envir, inherits = FALSE)
[10:21:23.775]                           if (inherits(master, c("SOCKnode", 
[10:21:23.775]                             "SOCK0node"))) {
[10:21:23.775]                             sendCondition <<- function(cond) {
[10:21:23.775]                               data <- list(type = "VALUE", value = cond, 
[10:21:23.775]                                 success = TRUE)
[10:21:23.775]                               parallel_sendData(master, data)
[10:21:23.775]                             }
[10:21:23.775]                             return(sendCondition)
[10:21:23.775]                           }
[10:21:23.775]                         }
[10:21:23.775]                         frame <- frame + 1L
[10:21:23.775]                         envir <- sys.frame(frame)
[10:21:23.775]                       }
[10:21:23.775]                     }
[10:21:23.775]                     sendCondition <<- function(cond) NULL
[10:21:23.775]                   }
[10:21:23.775]                 })
[10:21:23.775]                 withCallingHandlers({
[10:21:23.775]                   NULL
[10:21:23.775]                 }, immediateCondition = function(cond) {
[10:21:23.775]                   sendCondition <- ...future.makeSendCondition()
[10:21:23.775]                   sendCondition(cond)
[10:21:23.775]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.775]                   {
[10:21:23.775]                     inherits <- base::inherits
[10:21:23.775]                     invokeRestart <- base::invokeRestart
[10:21:23.775]                     is.null <- base::is.null
[10:21:23.775]                     muffled <- FALSE
[10:21:23.775]                     if (inherits(cond, "message")) {
[10:21:23.775]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.775]                       if (muffled) 
[10:21:23.775]                         invokeRestart("muffleMessage")
[10:21:23.775]                     }
[10:21:23.775]                     else if (inherits(cond, "warning")) {
[10:21:23.775]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.775]                       if (muffled) 
[10:21:23.775]                         invokeRestart("muffleWarning")
[10:21:23.775]                     }
[10:21:23.775]                     else if (inherits(cond, "condition")) {
[10:21:23.775]                       if (!is.null(pattern)) {
[10:21:23.775]                         computeRestarts <- base::computeRestarts
[10:21:23.775]                         grepl <- base::grepl
[10:21:23.775]                         restarts <- computeRestarts(cond)
[10:21:23.775]                         for (restart in restarts) {
[10:21:23.775]                           name <- restart$name
[10:21:23.775]                           if (is.null(name)) 
[10:21:23.775]                             next
[10:21:23.775]                           if (!grepl(pattern, name)) 
[10:21:23.775]                             next
[10:21:23.775]                           invokeRestart(restart)
[10:21:23.775]                           muffled <- TRUE
[10:21:23.775]                           break
[10:21:23.775]                         }
[10:21:23.775]                       }
[10:21:23.775]                     }
[10:21:23.775]                     invisible(muffled)
[10:21:23.775]                   }
[10:21:23.775]                   muffleCondition(cond)
[10:21:23.775]                 })
[10:21:23.775]             }))
[10:21:23.775]             future::FutureResult(value = ...future.value$value, 
[10:21:23.775]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.775]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.775]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.775]                     ...future.globalenv.names))
[10:21:23.775]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.775]         }, condition = base::local({
[10:21:23.775]             c <- base::c
[10:21:23.775]             inherits <- base::inherits
[10:21:23.775]             invokeRestart <- base::invokeRestart
[10:21:23.775]             length <- base::length
[10:21:23.775]             list <- base::list
[10:21:23.775]             seq.int <- base::seq.int
[10:21:23.775]             signalCondition <- base::signalCondition
[10:21:23.775]             sys.calls <- base::sys.calls
[10:21:23.775]             `[[` <- base::`[[`
[10:21:23.775]             `+` <- base::`+`
[10:21:23.775]             `<<-` <- base::`<<-`
[10:21:23.775]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.775]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.775]                   3L)]
[10:21:23.775]             }
[10:21:23.775]             function(cond) {
[10:21:23.775]                 is_error <- inherits(cond, "error")
[10:21:23.775]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.775]                   NULL)
[10:21:23.775]                 if (is_error) {
[10:21:23.775]                   sessionInformation <- function() {
[10:21:23.775]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.775]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.775]                       search = base::search(), system = base::Sys.info())
[10:21:23.775]                   }
[10:21:23.775]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.775]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.775]                     cond$call), session = sessionInformation(), 
[10:21:23.775]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.775]                   signalCondition(cond)
[10:21:23.775]                 }
[10:21:23.775]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.775]                 "immediateCondition"))) {
[10:21:23.775]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.775]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.775]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.775]                   if (TRUE && !signal) {
[10:21:23.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.775]                     {
[10:21:23.775]                       inherits <- base::inherits
[10:21:23.775]                       invokeRestart <- base::invokeRestart
[10:21:23.775]                       is.null <- base::is.null
[10:21:23.775]                       muffled <- FALSE
[10:21:23.775]                       if (inherits(cond, "message")) {
[10:21:23.775]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.775]                         if (muffled) 
[10:21:23.775]                           invokeRestart("muffleMessage")
[10:21:23.775]                       }
[10:21:23.775]                       else if (inherits(cond, "warning")) {
[10:21:23.775]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.775]                         if (muffled) 
[10:21:23.775]                           invokeRestart("muffleWarning")
[10:21:23.775]                       }
[10:21:23.775]                       else if (inherits(cond, "condition")) {
[10:21:23.775]                         if (!is.null(pattern)) {
[10:21:23.775]                           computeRestarts <- base::computeRestarts
[10:21:23.775]                           grepl <- base::grepl
[10:21:23.775]                           restarts <- computeRestarts(cond)
[10:21:23.775]                           for (restart in restarts) {
[10:21:23.775]                             name <- restart$name
[10:21:23.775]                             if (is.null(name)) 
[10:21:23.775]                               next
[10:21:23.775]                             if (!grepl(pattern, name)) 
[10:21:23.775]                               next
[10:21:23.775]                             invokeRestart(restart)
[10:21:23.775]                             muffled <- TRUE
[10:21:23.775]                             break
[10:21:23.775]                           }
[10:21:23.775]                         }
[10:21:23.775]                       }
[10:21:23.775]                       invisible(muffled)
[10:21:23.775]                     }
[10:21:23.775]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.775]                   }
[10:21:23.775]                 }
[10:21:23.775]                 else {
[10:21:23.775]                   if (TRUE) {
[10:21:23.775]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.775]                     {
[10:21:23.775]                       inherits <- base::inherits
[10:21:23.775]                       invokeRestart <- base::invokeRestart
[10:21:23.775]                       is.null <- base::is.null
[10:21:23.775]                       muffled <- FALSE
[10:21:23.775]                       if (inherits(cond, "message")) {
[10:21:23.775]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.775]                         if (muffled) 
[10:21:23.775]                           invokeRestart("muffleMessage")
[10:21:23.775]                       }
[10:21:23.775]                       else if (inherits(cond, "warning")) {
[10:21:23.775]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.775]                         if (muffled) 
[10:21:23.775]                           invokeRestart("muffleWarning")
[10:21:23.775]                       }
[10:21:23.775]                       else if (inherits(cond, "condition")) {
[10:21:23.775]                         if (!is.null(pattern)) {
[10:21:23.775]                           computeRestarts <- base::computeRestarts
[10:21:23.775]                           grepl <- base::grepl
[10:21:23.775]                           restarts <- computeRestarts(cond)
[10:21:23.775]                           for (restart in restarts) {
[10:21:23.775]                             name <- restart$name
[10:21:23.775]                             if (is.null(name)) 
[10:21:23.775]                               next
[10:21:23.775]                             if (!grepl(pattern, name)) 
[10:21:23.775]                               next
[10:21:23.775]                             invokeRestart(restart)
[10:21:23.775]                             muffled <- TRUE
[10:21:23.775]                             break
[10:21:23.775]                           }
[10:21:23.775]                         }
[10:21:23.775]                       }
[10:21:23.775]                       invisible(muffled)
[10:21:23.775]                     }
[10:21:23.775]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.775]                   }
[10:21:23.775]                 }
[10:21:23.775]             }
[10:21:23.775]         }))
[10:21:23.775]     }, error = function(ex) {
[10:21:23.775]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.775]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.775]                 ...future.rng), started = ...future.startTime, 
[10:21:23.775]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.775]             version = "1.8"), class = "FutureResult")
[10:21:23.775]     }, finally = {
[10:21:23.775]         if (!identical(...future.workdir, getwd())) 
[10:21:23.775]             setwd(...future.workdir)
[10:21:23.775]         {
[10:21:23.775]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.775]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.775]             }
[10:21:23.775]             base::options(...future.oldOptions)
[10:21:23.775]             if (.Platform$OS.type == "windows") {
[10:21:23.775]                 old_names <- names(...future.oldEnvVars)
[10:21:23.775]                 envs <- base::Sys.getenv()
[10:21:23.775]                 names <- names(envs)
[10:21:23.775]                 common <- intersect(names, old_names)
[10:21:23.775]                 added <- setdiff(names, old_names)
[10:21:23.775]                 removed <- setdiff(old_names, names)
[10:21:23.775]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.775]                   envs[common]]
[10:21:23.775]                 NAMES <- toupper(changed)
[10:21:23.775]                 args <- list()
[10:21:23.775]                 for (kk in seq_along(NAMES)) {
[10:21:23.775]                   name <- changed[[kk]]
[10:21:23.775]                   NAME <- NAMES[[kk]]
[10:21:23.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.775]                     next
[10:21:23.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.775]                 }
[10:21:23.775]                 NAMES <- toupper(added)
[10:21:23.775]                 for (kk in seq_along(NAMES)) {
[10:21:23.775]                   name <- added[[kk]]
[10:21:23.775]                   NAME <- NAMES[[kk]]
[10:21:23.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.775]                     next
[10:21:23.775]                   args[[name]] <- ""
[10:21:23.775]                 }
[10:21:23.775]                 NAMES <- toupper(removed)
[10:21:23.775]                 for (kk in seq_along(NAMES)) {
[10:21:23.775]                   name <- removed[[kk]]
[10:21:23.775]                   NAME <- NAMES[[kk]]
[10:21:23.775]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.775]                     next
[10:21:23.775]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.775]                 }
[10:21:23.775]                 if (length(args) > 0) 
[10:21:23.775]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.775]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.775]             }
[10:21:23.775]             else {
[10:21:23.775]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.775]             }
[10:21:23.775]             {
[10:21:23.775]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.775]                   0L) {
[10:21:23.775]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.775]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.775]                   base::options(opts)
[10:21:23.775]                 }
[10:21:23.775]                 {
[10:21:23.775]                   {
[10:21:23.775]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.775]                     NULL
[10:21:23.775]                   }
[10:21:23.775]                   options(future.plan = NULL)
[10:21:23.775]                   if (is.na(NA_character_)) 
[10:21:23.775]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.775]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.775]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.775]                     .init = FALSE)
[10:21:23.775]                 }
[10:21:23.775]             }
[10:21:23.775]         }
[10:21:23.775]     })
[10:21:23.775]     if (TRUE) {
[10:21:23.775]         base::sink(type = "output", split = FALSE)
[10:21:23.775]         if (TRUE) {
[10:21:23.775]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.775]         }
[10:21:23.775]         else {
[10:21:23.775]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.775]         }
[10:21:23.775]         base::close(...future.stdout)
[10:21:23.775]         ...future.stdout <- NULL
[10:21:23.775]     }
[10:21:23.775]     ...future.result$conditions <- ...future.conditions
[10:21:23.775]     ...future.result$finished <- base::Sys.time()
[10:21:23.775]     ...future.result
[10:21:23.775] }
[10:21:23.827] MultisessionFuture started
[10:21:23.827] - Launch lazy future ... done
[10:21:23.827] run() for ‘MultisessionFuture’ ... done
[10:21:23.828] getGlobalsAndPackages() ...
[10:21:23.828] Searching for globals...
[10:21:23.830] - globals found: [1] ‘{’
[10:21:23.830] Searching for globals ... DONE
[10:21:23.830] Resolving globals: FALSE
[10:21:23.830] 
[10:21:23.831] 
[10:21:23.831] getGlobalsAndPackages() ... DONE
[10:21:23.831] run() for ‘Future’ ...
[10:21:23.831] - state: ‘created’
[10:21:23.832] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.848] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.848] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:23.848]   - Field: ‘node’
[10:21:23.848]   - Field: ‘label’
[10:21:23.849]   - Field: ‘local’
[10:21:23.849]   - Field: ‘owner’
[10:21:23.849]   - Field: ‘envir’
[10:21:23.849]   - Field: ‘workers’
[10:21:23.849]   - Field: ‘packages’
[10:21:23.849]   - Field: ‘gc’
[10:21:23.849]   - Field: ‘conditions’
[10:21:23.849]   - Field: ‘persistent’
[10:21:23.849]   - Field: ‘expr’
[10:21:23.849]   - Field: ‘uuid’
[10:21:23.850]   - Field: ‘seed’
[10:21:23.850]   - Field: ‘version’
[10:21:23.850]   - Field: ‘result’
[10:21:23.850]   - Field: ‘asynchronous’
[10:21:23.850]   - Field: ‘calls’
[10:21:23.850]   - Field: ‘globals’
[10:21:23.850]   - Field: ‘stdout’
[10:21:23.850]   - Field: ‘earlySignal’
[10:21:23.850]   - Field: ‘lazy’
[10:21:23.850]   - Field: ‘state’
[10:21:23.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:23.851] - Launch lazy future ...
[10:21:23.851] Packages needed by the future expression (n = 0): <none>
[10:21:23.851] Packages needed by future strategies (n = 0): <none>
[10:21:23.852] {
[10:21:23.852]     {
[10:21:23.852]         {
[10:21:23.852]             ...future.startTime <- base::Sys.time()
[10:21:23.852]             {
[10:21:23.852]                 {
[10:21:23.852]                   {
[10:21:23.852]                     {
[10:21:23.852]                       base::local({
[10:21:23.852]                         has_future <- base::requireNamespace("future", 
[10:21:23.852]                           quietly = TRUE)
[10:21:23.852]                         if (has_future) {
[10:21:23.852]                           ns <- base::getNamespace("future")
[10:21:23.852]                           version <- ns[[".package"]][["version"]]
[10:21:23.852]                           if (is.null(version)) 
[10:21:23.852]                             version <- utils::packageVersion("future")
[10:21:23.852]                         }
[10:21:23.852]                         else {
[10:21:23.852]                           version <- NULL
[10:21:23.852]                         }
[10:21:23.852]                         if (!has_future || version < "1.8.0") {
[10:21:23.852]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.852]                             "", base::R.version$version.string), 
[10:21:23.852]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.852]                               "release", "version")], collapse = " "), 
[10:21:23.852]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.852]                             info)
[10:21:23.852]                           info <- base::paste(info, collapse = "; ")
[10:21:23.852]                           if (!has_future) {
[10:21:23.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.852]                               info)
[10:21:23.852]                           }
[10:21:23.852]                           else {
[10:21:23.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.852]                               info, version)
[10:21:23.852]                           }
[10:21:23.852]                           base::stop(msg)
[10:21:23.852]                         }
[10:21:23.852]                       })
[10:21:23.852]                     }
[10:21:23.852]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.852]                     base::options(mc.cores = 1L)
[10:21:23.852]                   }
[10:21:23.852]                   ...future.strategy.old <- future::plan("list")
[10:21:23.852]                   options(future.plan = NULL)
[10:21:23.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.852]                 }
[10:21:23.852]                 ...future.workdir <- getwd()
[10:21:23.852]             }
[10:21:23.852]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.852]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.852]         }
[10:21:23.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.852]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.852]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.852]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.852]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.852]             base::names(...future.oldOptions))
[10:21:23.852]     }
[10:21:23.852]     if (FALSE) {
[10:21:23.852]     }
[10:21:23.852]     else {
[10:21:23.852]         if (TRUE) {
[10:21:23.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.852]                 open = "w")
[10:21:23.852]         }
[10:21:23.852]         else {
[10:21:23.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.852]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.852]         }
[10:21:23.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.852]             base::sink(type = "output", split = FALSE)
[10:21:23.852]             base::close(...future.stdout)
[10:21:23.852]         }, add = TRUE)
[10:21:23.852]     }
[10:21:23.852]     ...future.frame <- base::sys.nframe()
[10:21:23.852]     ...future.conditions <- base::list()
[10:21:23.852]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.852]     if (FALSE) {
[10:21:23.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.852]     }
[10:21:23.852]     ...future.result <- base::tryCatch({
[10:21:23.852]         base::withCallingHandlers({
[10:21:23.852]             ...future.value <- base::withVisible(base::local({
[10:21:23.852]                 ...future.makeSendCondition <- base::local({
[10:21:23.852]                   sendCondition <- NULL
[10:21:23.852]                   function(frame = 1L) {
[10:21:23.852]                     if (is.function(sendCondition)) 
[10:21:23.852]                       return(sendCondition)
[10:21:23.852]                     ns <- getNamespace("parallel")
[10:21:23.852]                     if (exists("sendData", mode = "function", 
[10:21:23.852]                       envir = ns)) {
[10:21:23.852]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:23.852]                         envir = ns)
[10:21:23.852]                       envir <- sys.frame(frame)
[10:21:23.852]                       master <- NULL
[10:21:23.852]                       while (!identical(envir, .GlobalEnv) && 
[10:21:23.852]                         !identical(envir, emptyenv())) {
[10:21:23.852]                         if (exists("master", mode = "list", envir = envir, 
[10:21:23.852]                           inherits = FALSE)) {
[10:21:23.852]                           master <- get("master", mode = "list", 
[10:21:23.852]                             envir = envir, inherits = FALSE)
[10:21:23.852]                           if (inherits(master, c("SOCKnode", 
[10:21:23.852]                             "SOCK0node"))) {
[10:21:23.852]                             sendCondition <<- function(cond) {
[10:21:23.852]                               data <- list(type = "VALUE", value = cond, 
[10:21:23.852]                                 success = TRUE)
[10:21:23.852]                               parallel_sendData(master, data)
[10:21:23.852]                             }
[10:21:23.852]                             return(sendCondition)
[10:21:23.852]                           }
[10:21:23.852]                         }
[10:21:23.852]                         frame <- frame + 1L
[10:21:23.852]                         envir <- sys.frame(frame)
[10:21:23.852]                       }
[10:21:23.852]                     }
[10:21:23.852]                     sendCondition <<- function(cond) NULL
[10:21:23.852]                   }
[10:21:23.852]                 })
[10:21:23.852]                 withCallingHandlers({
[10:21:23.852]                   {
[10:21:23.852]                     4
[10:21:23.852]                   }
[10:21:23.852]                 }, immediateCondition = function(cond) {
[10:21:23.852]                   sendCondition <- ...future.makeSendCondition()
[10:21:23.852]                   sendCondition(cond)
[10:21:23.852]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.852]                   {
[10:21:23.852]                     inherits <- base::inherits
[10:21:23.852]                     invokeRestart <- base::invokeRestart
[10:21:23.852]                     is.null <- base::is.null
[10:21:23.852]                     muffled <- FALSE
[10:21:23.852]                     if (inherits(cond, "message")) {
[10:21:23.852]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.852]                       if (muffled) 
[10:21:23.852]                         invokeRestart("muffleMessage")
[10:21:23.852]                     }
[10:21:23.852]                     else if (inherits(cond, "warning")) {
[10:21:23.852]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.852]                       if (muffled) 
[10:21:23.852]                         invokeRestart("muffleWarning")
[10:21:23.852]                     }
[10:21:23.852]                     else if (inherits(cond, "condition")) {
[10:21:23.852]                       if (!is.null(pattern)) {
[10:21:23.852]                         computeRestarts <- base::computeRestarts
[10:21:23.852]                         grepl <- base::grepl
[10:21:23.852]                         restarts <- computeRestarts(cond)
[10:21:23.852]                         for (restart in restarts) {
[10:21:23.852]                           name <- restart$name
[10:21:23.852]                           if (is.null(name)) 
[10:21:23.852]                             next
[10:21:23.852]                           if (!grepl(pattern, name)) 
[10:21:23.852]                             next
[10:21:23.852]                           invokeRestart(restart)
[10:21:23.852]                           muffled <- TRUE
[10:21:23.852]                           break
[10:21:23.852]                         }
[10:21:23.852]                       }
[10:21:23.852]                     }
[10:21:23.852]                     invisible(muffled)
[10:21:23.852]                   }
[10:21:23.852]                   muffleCondition(cond)
[10:21:23.852]                 })
[10:21:23.852]             }))
[10:21:23.852]             future::FutureResult(value = ...future.value$value, 
[10:21:23.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.852]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.852]                     ...future.globalenv.names))
[10:21:23.852]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.852]         }, condition = base::local({
[10:21:23.852]             c <- base::c
[10:21:23.852]             inherits <- base::inherits
[10:21:23.852]             invokeRestart <- base::invokeRestart
[10:21:23.852]             length <- base::length
[10:21:23.852]             list <- base::list
[10:21:23.852]             seq.int <- base::seq.int
[10:21:23.852]             signalCondition <- base::signalCondition
[10:21:23.852]             sys.calls <- base::sys.calls
[10:21:23.852]             `[[` <- base::`[[`
[10:21:23.852]             `+` <- base::`+`
[10:21:23.852]             `<<-` <- base::`<<-`
[10:21:23.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.852]                   3L)]
[10:21:23.852]             }
[10:21:23.852]             function(cond) {
[10:21:23.852]                 is_error <- inherits(cond, "error")
[10:21:23.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.852]                   NULL)
[10:21:23.852]                 if (is_error) {
[10:21:23.852]                   sessionInformation <- function() {
[10:21:23.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.852]                       search = base::search(), system = base::Sys.info())
[10:21:23.852]                   }
[10:21:23.852]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.852]                     cond$call), session = sessionInformation(), 
[10:21:23.852]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.852]                   signalCondition(cond)
[10:21:23.852]                 }
[10:21:23.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.852]                 "immediateCondition"))) {
[10:21:23.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.852]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.852]                   if (TRUE && !signal) {
[10:21:23.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.852]                     {
[10:21:23.852]                       inherits <- base::inherits
[10:21:23.852]                       invokeRestart <- base::invokeRestart
[10:21:23.852]                       is.null <- base::is.null
[10:21:23.852]                       muffled <- FALSE
[10:21:23.852]                       if (inherits(cond, "message")) {
[10:21:23.852]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.852]                         if (muffled) 
[10:21:23.852]                           invokeRestart("muffleMessage")
[10:21:23.852]                       }
[10:21:23.852]                       else if (inherits(cond, "warning")) {
[10:21:23.852]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.852]                         if (muffled) 
[10:21:23.852]                           invokeRestart("muffleWarning")
[10:21:23.852]                       }
[10:21:23.852]                       else if (inherits(cond, "condition")) {
[10:21:23.852]                         if (!is.null(pattern)) {
[10:21:23.852]                           computeRestarts <- base::computeRestarts
[10:21:23.852]                           grepl <- base::grepl
[10:21:23.852]                           restarts <- computeRestarts(cond)
[10:21:23.852]                           for (restart in restarts) {
[10:21:23.852]                             name <- restart$name
[10:21:23.852]                             if (is.null(name)) 
[10:21:23.852]                               next
[10:21:23.852]                             if (!grepl(pattern, name)) 
[10:21:23.852]                               next
[10:21:23.852]                             invokeRestart(restart)
[10:21:23.852]                             muffled <- TRUE
[10:21:23.852]                             break
[10:21:23.852]                           }
[10:21:23.852]                         }
[10:21:23.852]                       }
[10:21:23.852]                       invisible(muffled)
[10:21:23.852]                     }
[10:21:23.852]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.852]                   }
[10:21:23.852]                 }
[10:21:23.852]                 else {
[10:21:23.852]                   if (TRUE) {
[10:21:23.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.852]                     {
[10:21:23.852]                       inherits <- base::inherits
[10:21:23.852]                       invokeRestart <- base::invokeRestart
[10:21:23.852]                       is.null <- base::is.null
[10:21:23.852]                       muffled <- FALSE
[10:21:23.852]                       if (inherits(cond, "message")) {
[10:21:23.852]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.852]                         if (muffled) 
[10:21:23.852]                           invokeRestart("muffleMessage")
[10:21:23.852]                       }
[10:21:23.852]                       else if (inherits(cond, "warning")) {
[10:21:23.852]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.852]                         if (muffled) 
[10:21:23.852]                           invokeRestart("muffleWarning")
[10:21:23.852]                       }
[10:21:23.852]                       else if (inherits(cond, "condition")) {
[10:21:23.852]                         if (!is.null(pattern)) {
[10:21:23.852]                           computeRestarts <- base::computeRestarts
[10:21:23.852]                           grepl <- base::grepl
[10:21:23.852]                           restarts <- computeRestarts(cond)
[10:21:23.852]                           for (restart in restarts) {
[10:21:23.852]                             name <- restart$name
[10:21:23.852]                             if (is.null(name)) 
[10:21:23.852]                               next
[10:21:23.852]                             if (!grepl(pattern, name)) 
[10:21:23.852]                               next
[10:21:23.852]                             invokeRestart(restart)
[10:21:23.852]                             muffled <- TRUE
[10:21:23.852]                             break
[10:21:23.852]                           }
[10:21:23.852]                         }
[10:21:23.852]                       }
[10:21:23.852]                       invisible(muffled)
[10:21:23.852]                     }
[10:21:23.852]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.852]                   }
[10:21:23.852]                 }
[10:21:23.852]             }
[10:21:23.852]         }))
[10:21:23.852]     }, error = function(ex) {
[10:21:23.852]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.852]                 ...future.rng), started = ...future.startTime, 
[10:21:23.852]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.852]             version = "1.8"), class = "FutureResult")
[10:21:23.852]     }, finally = {
[10:21:23.852]         if (!identical(...future.workdir, getwd())) 
[10:21:23.852]             setwd(...future.workdir)
[10:21:23.852]         {
[10:21:23.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.852]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.852]             }
[10:21:23.852]             base::options(...future.oldOptions)
[10:21:23.852]             if (.Platform$OS.type == "windows") {
[10:21:23.852]                 old_names <- names(...future.oldEnvVars)
[10:21:23.852]                 envs <- base::Sys.getenv()
[10:21:23.852]                 names <- names(envs)
[10:21:23.852]                 common <- intersect(names, old_names)
[10:21:23.852]                 added <- setdiff(names, old_names)
[10:21:23.852]                 removed <- setdiff(old_names, names)
[10:21:23.852]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.852]                   envs[common]]
[10:21:23.852]                 NAMES <- toupper(changed)
[10:21:23.852]                 args <- list()
[10:21:23.852]                 for (kk in seq_along(NAMES)) {
[10:21:23.852]                   name <- changed[[kk]]
[10:21:23.852]                   NAME <- NAMES[[kk]]
[10:21:23.852]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.852]                     next
[10:21:23.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.852]                 }
[10:21:23.852]                 NAMES <- toupper(added)
[10:21:23.852]                 for (kk in seq_along(NAMES)) {
[10:21:23.852]                   name <- added[[kk]]
[10:21:23.852]                   NAME <- NAMES[[kk]]
[10:21:23.852]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.852]                     next
[10:21:23.852]                   args[[name]] <- ""
[10:21:23.852]                 }
[10:21:23.852]                 NAMES <- toupper(removed)
[10:21:23.852]                 for (kk in seq_along(NAMES)) {
[10:21:23.852]                   name <- removed[[kk]]
[10:21:23.852]                   NAME <- NAMES[[kk]]
[10:21:23.852]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.852]                     next
[10:21:23.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.852]                 }
[10:21:23.852]                 if (length(args) > 0) 
[10:21:23.852]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.852]             }
[10:21:23.852]             else {
[10:21:23.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.852]             }
[10:21:23.852]             {
[10:21:23.852]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.852]                   0L) {
[10:21:23.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.852]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.852]                   base::options(opts)
[10:21:23.852]                 }
[10:21:23.852]                 {
[10:21:23.852]                   {
[10:21:23.852]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.852]                     NULL
[10:21:23.852]                   }
[10:21:23.852]                   options(future.plan = NULL)
[10:21:23.852]                   if (is.na(NA_character_)) 
[10:21:23.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.852]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.852]                     .init = FALSE)
[10:21:23.852]                 }
[10:21:23.852]             }
[10:21:23.852]         }
[10:21:23.852]     })
[10:21:23.852]     if (TRUE) {
[10:21:23.852]         base::sink(type = "output", split = FALSE)
[10:21:23.852]         if (TRUE) {
[10:21:23.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.852]         }
[10:21:23.852]         else {
[10:21:23.852]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.852]         }
[10:21:23.852]         base::close(...future.stdout)
[10:21:23.852]         ...future.stdout <- NULL
[10:21:23.852]     }
[10:21:23.852]     ...future.result$conditions <- ...future.conditions
[10:21:23.852]     ...future.result$finished <- base::Sys.time()
[10:21:23.852]     ...future.result
[10:21:23.852] }
[10:21:23.854] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:23.865] receiveMessageFromWorker() for ClusterFuture ...
[10:21:23.865] - Validating connection of MultisessionFuture
[10:21:23.865] - received message: FutureResult
[10:21:23.865] - Received FutureResult
[10:21:23.865] - Erased future from FutureRegistry
[10:21:23.865] result() for ClusterFuture ...
[10:21:23.866] - result already collected: FutureResult
[10:21:23.866] result() for ClusterFuture ... done
[10:21:23.866] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:23.866] result() for ClusterFuture ...
[10:21:23.866] - result already collected: FutureResult
[10:21:23.866] result() for ClusterFuture ... done
[10:21:23.866] result() for ClusterFuture ...
[10:21:23.866] - result already collected: FutureResult
[10:21:23.866] result() for ClusterFuture ... done
[10:21:23.868] MultisessionFuture started
[10:21:23.868] - Launch lazy future ... done
[10:21:23.868] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e4d47290> 
Classes 'listenv', 'environment' <environment: 0x55e8e68d2f28> 
[10:21:23.872] receiveMessageFromWorker() for ClusterFuture ...
[10:21:23.872] - Validating connection of MultisessionFuture
[10:21:23.873] - received message: FutureResult
[10:21:23.873] - Received FutureResult
[10:21:23.873] - Erased future from FutureRegistry
[10:21:23.873] result() for ClusterFuture ...
[10:21:23.873] - result already collected: FutureResult
[10:21:23.873] result() for ClusterFuture ... done
[10:21:23.873] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:23.885] resolve() on list environment ...
[10:21:23.885]  recursive: 0
[10:21:23.886]  length: 6
[10:21:23.886]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:23.887] signalConditionsASAP(numeric, pos=1) ...
[10:21:23.887] - nx: 6
[10:21:23.887] - relay: TRUE
[10:21:23.887] - stdout: TRUE
[10:21:23.887] - signal: TRUE
[10:21:23.887] - resignal: FALSE
[10:21:23.887] - force: TRUE
[10:21:23.887] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.887] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.887]  - until=2
[10:21:23.887]  - relaying element #2
[10:21:23.887] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.887] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.888] signalConditionsASAP(NULL, pos=1) ... done
[10:21:23.888]  length: 5 (resolved future 1)
[10:21:23.888] Future #2
[10:21:23.888] result() for ClusterFuture ...
[10:21:23.888] - result already collected: FutureResult
[10:21:23.888] result() for ClusterFuture ... done
[10:21:23.888] result() for ClusterFuture ...
[10:21:23.888] - result already collected: FutureResult
[10:21:23.888] result() for ClusterFuture ... done
[10:21:23.888] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:23.888] - nx: 6
[10:21:23.889] - relay: TRUE
[10:21:23.889] - stdout: TRUE
[10:21:23.889] - signal: TRUE
[10:21:23.889] - resignal: FALSE
[10:21:23.889] - force: TRUE
[10:21:23.889] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.889] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:23.889]  - until=2
[10:21:23.889]  - relaying element #2
[10:21:23.889] result() for ClusterFuture ...
[10:21:23.889] - result already collected: FutureResult
[10:21:23.889] result() for ClusterFuture ... done
[10:21:23.890] result() for ClusterFuture ...
[10:21:23.890] - result already collected: FutureResult
[10:21:23.890] result() for ClusterFuture ... done
[10:21:23.890] result() for ClusterFuture ...
[10:21:23.890] - result already collected: FutureResult
[10:21:23.890] result() for ClusterFuture ... done
[10:21:23.890] result() for ClusterFuture ...
[10:21:23.890] - result already collected: FutureResult
[10:21:23.890] result() for ClusterFuture ... done
[10:21:23.890] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.890] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.890] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:23.891]  length: 4 (resolved future 2)
[10:21:23.891] Future #3
[10:21:23.891] result() for ClusterFuture ...
[10:21:23.891] - result already collected: FutureResult
[10:21:23.891] result() for ClusterFuture ... done
[10:21:23.891] result() for ClusterFuture ...
[10:21:23.891] - result already collected: FutureResult
[10:21:23.891] result() for ClusterFuture ... done
[10:21:23.891] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:23.891] - nx: 6
[10:21:23.891] - relay: TRUE
[10:21:23.891] - stdout: TRUE
[10:21:23.892] - signal: TRUE
[10:21:23.892] - resignal: FALSE
[10:21:23.892] - force: TRUE
[10:21:23.892] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.892] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:23.892]  - until=3
[10:21:23.892]  - relaying element #3
[10:21:23.892] result() for ClusterFuture ...
[10:21:23.892] - result already collected: FutureResult
[10:21:23.892] result() for ClusterFuture ... done
[10:21:23.892] result() for ClusterFuture ...
[10:21:23.892] - result already collected: FutureResult
[10:21:23.893] result() for ClusterFuture ... done
[10:21:23.893] result() for ClusterFuture ...
[10:21:23.893] - result already collected: FutureResult
[10:21:23.893] result() for ClusterFuture ... done
[10:21:23.893] result() for ClusterFuture ...
[10:21:23.893] - result already collected: FutureResult
[10:21:23.893] result() for ClusterFuture ... done
[10:21:23.893] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.893] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.893] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:23.893]  length: 3 (resolved future 3)
[10:21:23.904] signalConditionsASAP(NULL, pos=5) ...
[10:21:23.904] - nx: 6
[10:21:23.904] - relay: TRUE
[10:21:23.904] - stdout: TRUE
[10:21:23.904] - signal: TRUE
[10:21:23.904] - resignal: FALSE
[10:21:23.904] - force: TRUE
[10:21:23.905] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.905] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.905]  - until=6
[10:21:23.905]  - relaying element #4
[10:21:23.905]  - relaying element #6
[10:21:23.905] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:23.905] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.905] signalConditionsASAP(NULL, pos=5) ... done
[10:21:23.905]  length: 2 (resolved future 5)
[10:21:23.905] signalConditionsASAP(numeric, pos=6) ...
[10:21:23.905] - nx: 6
[10:21:23.906] - relay: TRUE
[10:21:23.906] - stdout: TRUE
[10:21:23.906] - signal: TRUE
[10:21:23.906] - resignal: FALSE
[10:21:23.906] - force: TRUE
[10:21:23.906] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:23.906] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.906]  - until=6
[10:21:23.906]  - relaying element #4
[10:21:23.906] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:23.906] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.906] signalConditionsASAP(NULL, pos=6) ... done
[10:21:23.906]  length: 1 (resolved future 6)
[10:21:23.917] receiveMessageFromWorker() for ClusterFuture ...
[10:21:23.917] - Validating connection of MultisessionFuture
[10:21:23.918] - received message: FutureResult
[10:21:23.918] - Received FutureResult
[10:21:23.918] - Erased future from FutureRegistry
[10:21:23.918] result() for ClusterFuture ...
[10:21:23.918] - result already collected: FutureResult
[10:21:23.918] result() for ClusterFuture ... done
[10:21:23.918] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:23.918] Future #4
[10:21:23.918] result() for ClusterFuture ...
[10:21:23.918] - result already collected: FutureResult
[10:21:23.919] result() for ClusterFuture ... done
[10:21:23.919] result() for ClusterFuture ...
[10:21:23.919] - result already collected: FutureResult
[10:21:23.919] result() for ClusterFuture ... done
[10:21:23.919] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:23.919] - nx: 6
[10:21:23.919] - relay: TRUE
[10:21:23.919] - stdout: TRUE
[10:21:23.919] - signal: TRUE
[10:21:23.919] - resignal: FALSE
[10:21:23.919] - force: TRUE
[10:21:23.919] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:23.920] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:23.920]  - until=6
[10:21:23.920]  - relaying element #4
[10:21:23.920] result() for ClusterFuture ...
[10:21:23.920] - result already collected: FutureResult
[10:21:23.920] result() for ClusterFuture ... done
[10:21:23.920] result() for ClusterFuture ...
[10:21:23.920] - result already collected: FutureResult
[10:21:23.920] result() for ClusterFuture ... done
[10:21:23.920] result() for ClusterFuture ...
[10:21:23.920] - result already collected: FutureResult
[10:21:23.921] result() for ClusterFuture ... done
[10:21:23.921] result() for ClusterFuture ...
[10:21:23.921] - result already collected: FutureResult
[10:21:23.921] result() for ClusterFuture ... done
[10:21:23.921] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.921] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.921] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:23.921]  length: 0 (resolved future 4)
[10:21:23.921] Relaying remaining futures
[10:21:23.921] signalConditionsASAP(NULL, pos=0) ...
[10:21:23.921] - nx: 6
[10:21:23.921] - relay: TRUE
[10:21:23.922] - stdout: TRUE
[10:21:23.922] - signal: TRUE
[10:21:23.922] - resignal: FALSE
[10:21:23.922] - force: TRUE
[10:21:23.922] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.922] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:23.922] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:23.922] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:23.922] signalConditionsASAP(NULL, pos=0) ... done
[10:21:23.922] resolve() on list environment ... DONE
[10:21:23.922] result() for ClusterFuture ...
[10:21:23.922] - result already collected: FutureResult
[10:21:23.923] result() for ClusterFuture ... done
[10:21:23.923] result() for ClusterFuture ...
[10:21:23.923] - result already collected: FutureResult
[10:21:23.923] result() for ClusterFuture ... done
[10:21:23.923] result() for ClusterFuture ...
[10:21:23.923] - result already collected: FutureResult
[10:21:23.923] result() for ClusterFuture ... done
[10:21:23.923] result() for ClusterFuture ...
[10:21:23.923] - result already collected: FutureResult
[10:21:23.923] result() for ClusterFuture ... done
[10:21:23.924] result() for ClusterFuture ...
[10:21:23.924] - result already collected: FutureResult
[10:21:23.924] result() for ClusterFuture ... done
[10:21:23.924] result() for ClusterFuture ...
[10:21:23.924] - result already collected: FutureResult
[10:21:23.924] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e6ab88c0> 
Dimensions: c(1, 6)
[10:21:23.924] getGlobalsAndPackages() ...
[10:21:23.927] Searching for globals...
[10:21:23.928] 
[10:21:23.928] Searching for globals ... DONE
[10:21:23.928] - globals: [0] <none>
[10:21:23.928] getGlobalsAndPackages() ... DONE
[10:21:23.928] run() for ‘Future’ ...
[10:21:23.928] - state: ‘created’
[10:21:23.928] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.942] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.942] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:23.942]   - Field: ‘node’
[10:21:23.943]   - Field: ‘label’
[10:21:23.943]   - Field: ‘local’
[10:21:23.943]   - Field: ‘owner’
[10:21:23.943]   - Field: ‘envir’
[10:21:23.943]   - Field: ‘workers’
[10:21:23.943]   - Field: ‘packages’
[10:21:23.943]   - Field: ‘gc’
[10:21:23.943]   - Field: ‘conditions’
[10:21:23.943]   - Field: ‘persistent’
[10:21:23.943]   - Field: ‘expr’
[10:21:23.943]   - Field: ‘uuid’
[10:21:23.944]   - Field: ‘seed’
[10:21:23.944]   - Field: ‘version’
[10:21:23.944]   - Field: ‘result’
[10:21:23.944]   - Field: ‘asynchronous’
[10:21:23.944]   - Field: ‘calls’
[10:21:23.944]   - Field: ‘globals’
[10:21:23.944]   - Field: ‘stdout’
[10:21:23.944]   - Field: ‘earlySignal’
[10:21:23.944]   - Field: ‘lazy’
[10:21:23.944]   - Field: ‘state’
[10:21:23.944] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:23.944] - Launch lazy future ...
[10:21:23.945] Packages needed by the future expression (n = 0): <none>
[10:21:23.945] Packages needed by future strategies (n = 0): <none>
[10:21:23.945] {
[10:21:23.945]     {
[10:21:23.945]         {
[10:21:23.945]             ...future.startTime <- base::Sys.time()
[10:21:23.945]             {
[10:21:23.945]                 {
[10:21:23.945]                   {
[10:21:23.945]                     {
[10:21:23.945]                       base::local({
[10:21:23.945]                         has_future <- base::requireNamespace("future", 
[10:21:23.945]                           quietly = TRUE)
[10:21:23.945]                         if (has_future) {
[10:21:23.945]                           ns <- base::getNamespace("future")
[10:21:23.945]                           version <- ns[[".package"]][["version"]]
[10:21:23.945]                           if (is.null(version)) 
[10:21:23.945]                             version <- utils::packageVersion("future")
[10:21:23.945]                         }
[10:21:23.945]                         else {
[10:21:23.945]                           version <- NULL
[10:21:23.945]                         }
[10:21:23.945]                         if (!has_future || version < "1.8.0") {
[10:21:23.945]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.945]                             "", base::R.version$version.string), 
[10:21:23.945]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.945]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.945]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.945]                               "release", "version")], collapse = " "), 
[10:21:23.945]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.945]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.945]                             info)
[10:21:23.945]                           info <- base::paste(info, collapse = "; ")
[10:21:23.945]                           if (!has_future) {
[10:21:23.945]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.945]                               info)
[10:21:23.945]                           }
[10:21:23.945]                           else {
[10:21:23.945]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.945]                               info, version)
[10:21:23.945]                           }
[10:21:23.945]                           base::stop(msg)
[10:21:23.945]                         }
[10:21:23.945]                       })
[10:21:23.945]                     }
[10:21:23.945]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.945]                     base::options(mc.cores = 1L)
[10:21:23.945]                   }
[10:21:23.945]                   ...future.strategy.old <- future::plan("list")
[10:21:23.945]                   options(future.plan = NULL)
[10:21:23.945]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.945]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.945]                 }
[10:21:23.945]                 ...future.workdir <- getwd()
[10:21:23.945]             }
[10:21:23.945]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.945]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.945]         }
[10:21:23.945]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.945]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.945]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.945]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.945]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.945]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.945]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.945]             base::names(...future.oldOptions))
[10:21:23.945]     }
[10:21:23.945]     if (FALSE) {
[10:21:23.945]     }
[10:21:23.945]     else {
[10:21:23.945]         if (TRUE) {
[10:21:23.945]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.945]                 open = "w")
[10:21:23.945]         }
[10:21:23.945]         else {
[10:21:23.945]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.945]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.945]         }
[10:21:23.945]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.945]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.945]             base::sink(type = "output", split = FALSE)
[10:21:23.945]             base::close(...future.stdout)
[10:21:23.945]         }, add = TRUE)
[10:21:23.945]     }
[10:21:23.945]     ...future.frame <- base::sys.nframe()
[10:21:23.945]     ...future.conditions <- base::list()
[10:21:23.945]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.945]     if (FALSE) {
[10:21:23.945]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.945]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.945]     }
[10:21:23.945]     ...future.result <- base::tryCatch({
[10:21:23.945]         base::withCallingHandlers({
[10:21:23.945]             ...future.value <- base::withVisible(base::local({
[10:21:23.945]                 ...future.makeSendCondition <- base::local({
[10:21:23.945]                   sendCondition <- NULL
[10:21:23.945]                   function(frame = 1L) {
[10:21:23.945]                     if (is.function(sendCondition)) 
[10:21:23.945]                       return(sendCondition)
[10:21:23.945]                     ns <- getNamespace("parallel")
[10:21:23.945]                     if (exists("sendData", mode = "function", 
[10:21:23.945]                       envir = ns)) {
[10:21:23.945]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:23.945]                         envir = ns)
[10:21:23.945]                       envir <- sys.frame(frame)
[10:21:23.945]                       master <- NULL
[10:21:23.945]                       while (!identical(envir, .GlobalEnv) && 
[10:21:23.945]                         !identical(envir, emptyenv())) {
[10:21:23.945]                         if (exists("master", mode = "list", envir = envir, 
[10:21:23.945]                           inherits = FALSE)) {
[10:21:23.945]                           master <- get("master", mode = "list", 
[10:21:23.945]                             envir = envir, inherits = FALSE)
[10:21:23.945]                           if (inherits(master, c("SOCKnode", 
[10:21:23.945]                             "SOCK0node"))) {
[10:21:23.945]                             sendCondition <<- function(cond) {
[10:21:23.945]                               data <- list(type = "VALUE", value = cond, 
[10:21:23.945]                                 success = TRUE)
[10:21:23.945]                               parallel_sendData(master, data)
[10:21:23.945]                             }
[10:21:23.945]                             return(sendCondition)
[10:21:23.945]                           }
[10:21:23.945]                         }
[10:21:23.945]                         frame <- frame + 1L
[10:21:23.945]                         envir <- sys.frame(frame)
[10:21:23.945]                       }
[10:21:23.945]                     }
[10:21:23.945]                     sendCondition <<- function(cond) NULL
[10:21:23.945]                   }
[10:21:23.945]                 })
[10:21:23.945]                 withCallingHandlers({
[10:21:23.945]                   2
[10:21:23.945]                 }, immediateCondition = function(cond) {
[10:21:23.945]                   sendCondition <- ...future.makeSendCondition()
[10:21:23.945]                   sendCondition(cond)
[10:21:23.945]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.945]                   {
[10:21:23.945]                     inherits <- base::inherits
[10:21:23.945]                     invokeRestart <- base::invokeRestart
[10:21:23.945]                     is.null <- base::is.null
[10:21:23.945]                     muffled <- FALSE
[10:21:23.945]                     if (inherits(cond, "message")) {
[10:21:23.945]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.945]                       if (muffled) 
[10:21:23.945]                         invokeRestart("muffleMessage")
[10:21:23.945]                     }
[10:21:23.945]                     else if (inherits(cond, "warning")) {
[10:21:23.945]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.945]                       if (muffled) 
[10:21:23.945]                         invokeRestart("muffleWarning")
[10:21:23.945]                     }
[10:21:23.945]                     else if (inherits(cond, "condition")) {
[10:21:23.945]                       if (!is.null(pattern)) {
[10:21:23.945]                         computeRestarts <- base::computeRestarts
[10:21:23.945]                         grepl <- base::grepl
[10:21:23.945]                         restarts <- computeRestarts(cond)
[10:21:23.945]                         for (restart in restarts) {
[10:21:23.945]                           name <- restart$name
[10:21:23.945]                           if (is.null(name)) 
[10:21:23.945]                             next
[10:21:23.945]                           if (!grepl(pattern, name)) 
[10:21:23.945]                             next
[10:21:23.945]                           invokeRestart(restart)
[10:21:23.945]                           muffled <- TRUE
[10:21:23.945]                           break
[10:21:23.945]                         }
[10:21:23.945]                       }
[10:21:23.945]                     }
[10:21:23.945]                     invisible(muffled)
[10:21:23.945]                   }
[10:21:23.945]                   muffleCondition(cond)
[10:21:23.945]                 })
[10:21:23.945]             }))
[10:21:23.945]             future::FutureResult(value = ...future.value$value, 
[10:21:23.945]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.945]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.945]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.945]                     ...future.globalenv.names))
[10:21:23.945]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.945]         }, condition = base::local({
[10:21:23.945]             c <- base::c
[10:21:23.945]             inherits <- base::inherits
[10:21:23.945]             invokeRestart <- base::invokeRestart
[10:21:23.945]             length <- base::length
[10:21:23.945]             list <- base::list
[10:21:23.945]             seq.int <- base::seq.int
[10:21:23.945]             signalCondition <- base::signalCondition
[10:21:23.945]             sys.calls <- base::sys.calls
[10:21:23.945]             `[[` <- base::`[[`
[10:21:23.945]             `+` <- base::`+`
[10:21:23.945]             `<<-` <- base::`<<-`
[10:21:23.945]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.945]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.945]                   3L)]
[10:21:23.945]             }
[10:21:23.945]             function(cond) {
[10:21:23.945]                 is_error <- inherits(cond, "error")
[10:21:23.945]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.945]                   NULL)
[10:21:23.945]                 if (is_error) {
[10:21:23.945]                   sessionInformation <- function() {
[10:21:23.945]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.945]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.945]                       search = base::search(), system = base::Sys.info())
[10:21:23.945]                   }
[10:21:23.945]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.945]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.945]                     cond$call), session = sessionInformation(), 
[10:21:23.945]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.945]                   signalCondition(cond)
[10:21:23.945]                 }
[10:21:23.945]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.945]                 "immediateCondition"))) {
[10:21:23.945]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.945]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.945]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.945]                   if (TRUE && !signal) {
[10:21:23.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.945]                     {
[10:21:23.945]                       inherits <- base::inherits
[10:21:23.945]                       invokeRestart <- base::invokeRestart
[10:21:23.945]                       is.null <- base::is.null
[10:21:23.945]                       muffled <- FALSE
[10:21:23.945]                       if (inherits(cond, "message")) {
[10:21:23.945]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.945]                         if (muffled) 
[10:21:23.945]                           invokeRestart("muffleMessage")
[10:21:23.945]                       }
[10:21:23.945]                       else if (inherits(cond, "warning")) {
[10:21:23.945]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.945]                         if (muffled) 
[10:21:23.945]                           invokeRestart("muffleWarning")
[10:21:23.945]                       }
[10:21:23.945]                       else if (inherits(cond, "condition")) {
[10:21:23.945]                         if (!is.null(pattern)) {
[10:21:23.945]                           computeRestarts <- base::computeRestarts
[10:21:23.945]                           grepl <- base::grepl
[10:21:23.945]                           restarts <- computeRestarts(cond)
[10:21:23.945]                           for (restart in restarts) {
[10:21:23.945]                             name <- restart$name
[10:21:23.945]                             if (is.null(name)) 
[10:21:23.945]                               next
[10:21:23.945]                             if (!grepl(pattern, name)) 
[10:21:23.945]                               next
[10:21:23.945]                             invokeRestart(restart)
[10:21:23.945]                             muffled <- TRUE
[10:21:23.945]                             break
[10:21:23.945]                           }
[10:21:23.945]                         }
[10:21:23.945]                       }
[10:21:23.945]                       invisible(muffled)
[10:21:23.945]                     }
[10:21:23.945]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.945]                   }
[10:21:23.945]                 }
[10:21:23.945]                 else {
[10:21:23.945]                   if (TRUE) {
[10:21:23.945]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.945]                     {
[10:21:23.945]                       inherits <- base::inherits
[10:21:23.945]                       invokeRestart <- base::invokeRestart
[10:21:23.945]                       is.null <- base::is.null
[10:21:23.945]                       muffled <- FALSE
[10:21:23.945]                       if (inherits(cond, "message")) {
[10:21:23.945]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.945]                         if (muffled) 
[10:21:23.945]                           invokeRestart("muffleMessage")
[10:21:23.945]                       }
[10:21:23.945]                       else if (inherits(cond, "warning")) {
[10:21:23.945]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.945]                         if (muffled) 
[10:21:23.945]                           invokeRestart("muffleWarning")
[10:21:23.945]                       }
[10:21:23.945]                       else if (inherits(cond, "condition")) {
[10:21:23.945]                         if (!is.null(pattern)) {
[10:21:23.945]                           computeRestarts <- base::computeRestarts
[10:21:23.945]                           grepl <- base::grepl
[10:21:23.945]                           restarts <- computeRestarts(cond)
[10:21:23.945]                           for (restart in restarts) {
[10:21:23.945]                             name <- restart$name
[10:21:23.945]                             if (is.null(name)) 
[10:21:23.945]                               next
[10:21:23.945]                             if (!grepl(pattern, name)) 
[10:21:23.945]                               next
[10:21:23.945]                             invokeRestart(restart)
[10:21:23.945]                             muffled <- TRUE
[10:21:23.945]                             break
[10:21:23.945]                           }
[10:21:23.945]                         }
[10:21:23.945]                       }
[10:21:23.945]                       invisible(muffled)
[10:21:23.945]                     }
[10:21:23.945]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.945]                   }
[10:21:23.945]                 }
[10:21:23.945]             }
[10:21:23.945]         }))
[10:21:23.945]     }, error = function(ex) {
[10:21:23.945]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.945]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.945]                 ...future.rng), started = ...future.startTime, 
[10:21:23.945]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.945]             version = "1.8"), class = "FutureResult")
[10:21:23.945]     }, finally = {
[10:21:23.945]         if (!identical(...future.workdir, getwd())) 
[10:21:23.945]             setwd(...future.workdir)
[10:21:23.945]         {
[10:21:23.945]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.945]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.945]             }
[10:21:23.945]             base::options(...future.oldOptions)
[10:21:23.945]             if (.Platform$OS.type == "windows") {
[10:21:23.945]                 old_names <- names(...future.oldEnvVars)
[10:21:23.945]                 envs <- base::Sys.getenv()
[10:21:23.945]                 names <- names(envs)
[10:21:23.945]                 common <- intersect(names, old_names)
[10:21:23.945]                 added <- setdiff(names, old_names)
[10:21:23.945]                 removed <- setdiff(old_names, names)
[10:21:23.945]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.945]                   envs[common]]
[10:21:23.945]                 NAMES <- toupper(changed)
[10:21:23.945]                 args <- list()
[10:21:23.945]                 for (kk in seq_along(NAMES)) {
[10:21:23.945]                   name <- changed[[kk]]
[10:21:23.945]                   NAME <- NAMES[[kk]]
[10:21:23.945]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.945]                     next
[10:21:23.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.945]                 }
[10:21:23.945]                 NAMES <- toupper(added)
[10:21:23.945]                 for (kk in seq_along(NAMES)) {
[10:21:23.945]                   name <- added[[kk]]
[10:21:23.945]                   NAME <- NAMES[[kk]]
[10:21:23.945]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.945]                     next
[10:21:23.945]                   args[[name]] <- ""
[10:21:23.945]                 }
[10:21:23.945]                 NAMES <- toupper(removed)
[10:21:23.945]                 for (kk in seq_along(NAMES)) {
[10:21:23.945]                   name <- removed[[kk]]
[10:21:23.945]                   NAME <- NAMES[[kk]]
[10:21:23.945]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.945]                     next
[10:21:23.945]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.945]                 }
[10:21:23.945]                 if (length(args) > 0) 
[10:21:23.945]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.945]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.945]             }
[10:21:23.945]             else {
[10:21:23.945]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.945]             }
[10:21:23.945]             {
[10:21:23.945]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.945]                   0L) {
[10:21:23.945]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.945]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.945]                   base::options(opts)
[10:21:23.945]                 }
[10:21:23.945]                 {
[10:21:23.945]                   {
[10:21:23.945]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.945]                     NULL
[10:21:23.945]                   }
[10:21:23.945]                   options(future.plan = NULL)
[10:21:23.945]                   if (is.na(NA_character_)) 
[10:21:23.945]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.945]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.945]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.945]                     .init = FALSE)
[10:21:23.945]                 }
[10:21:23.945]             }
[10:21:23.945]         }
[10:21:23.945]     })
[10:21:23.945]     if (TRUE) {
[10:21:23.945]         base::sink(type = "output", split = FALSE)
[10:21:23.945]         if (TRUE) {
[10:21:23.945]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.945]         }
[10:21:23.945]         else {
[10:21:23.945]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.945]         }
[10:21:23.945]         base::close(...future.stdout)
[10:21:23.945]         ...future.stdout <- NULL
[10:21:23.945]     }
[10:21:23.945]     ...future.result$conditions <- ...future.conditions
[10:21:23.945]     ...future.result$finished <- base::Sys.time()
[10:21:23.945]     ...future.result
[10:21:23.945] }
[10:21:23.948] MultisessionFuture started
[10:21:23.948] - Launch lazy future ... done
[10:21:23.948] run() for ‘MultisessionFuture’ ... done
[10:21:23.949] getGlobalsAndPackages() ...
[10:21:23.949] Searching for globals...
[10:21:23.949] 
[10:21:23.949] Searching for globals ... DONE
[10:21:23.949] - globals: [0] <none>
[10:21:23.949] getGlobalsAndPackages() ... DONE
[10:21:23.949] run() for ‘Future’ ...
[10:21:23.950] - state: ‘created’
[10:21:23.950] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.964] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:23.965]   - Field: ‘node’
[10:21:23.965]   - Field: ‘label’
[10:21:23.965]   - Field: ‘local’
[10:21:23.965]   - Field: ‘owner’
[10:21:23.965]   - Field: ‘envir’
[10:21:23.965]   - Field: ‘workers’
[10:21:23.965]   - Field: ‘packages’
[10:21:23.965]   - Field: ‘gc’
[10:21:23.965]   - Field: ‘conditions’
[10:21:23.966]   - Field: ‘persistent’
[10:21:23.966]   - Field: ‘expr’
[10:21:23.966]   - Field: ‘uuid’
[10:21:23.966]   - Field: ‘seed’
[10:21:23.966]   - Field: ‘version’
[10:21:23.966]   - Field: ‘result’
[10:21:23.966]   - Field: ‘asynchronous’
[10:21:23.966]   - Field: ‘calls’
[10:21:23.966]   - Field: ‘globals’
[10:21:23.966]   - Field: ‘stdout’
[10:21:23.966]   - Field: ‘earlySignal’
[10:21:23.966]   - Field: ‘lazy’
[10:21:23.966]   - Field: ‘state’
[10:21:23.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:23.967] - Launch lazy future ...
[10:21:23.967] Packages needed by the future expression (n = 0): <none>
[10:21:23.967] Packages needed by future strategies (n = 0): <none>
[10:21:23.967] {
[10:21:23.967]     {
[10:21:23.967]         {
[10:21:23.967]             ...future.startTime <- base::Sys.time()
[10:21:23.967]             {
[10:21:23.967]                 {
[10:21:23.967]                   {
[10:21:23.967]                     {
[10:21:23.967]                       base::local({
[10:21:23.967]                         has_future <- base::requireNamespace("future", 
[10:21:23.967]                           quietly = TRUE)
[10:21:23.967]                         if (has_future) {
[10:21:23.967]                           ns <- base::getNamespace("future")
[10:21:23.967]                           version <- ns[[".package"]][["version"]]
[10:21:23.967]                           if (is.null(version)) 
[10:21:23.967]                             version <- utils::packageVersion("future")
[10:21:23.967]                         }
[10:21:23.967]                         else {
[10:21:23.967]                           version <- NULL
[10:21:23.967]                         }
[10:21:23.967]                         if (!has_future || version < "1.8.0") {
[10:21:23.967]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.967]                             "", base::R.version$version.string), 
[10:21:23.967]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.967]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.967]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.967]                               "release", "version")], collapse = " "), 
[10:21:23.967]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.967]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.967]                             info)
[10:21:23.967]                           info <- base::paste(info, collapse = "; ")
[10:21:23.967]                           if (!has_future) {
[10:21:23.967]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.967]                               info)
[10:21:23.967]                           }
[10:21:23.967]                           else {
[10:21:23.967]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.967]                               info, version)
[10:21:23.967]                           }
[10:21:23.967]                           base::stop(msg)
[10:21:23.967]                         }
[10:21:23.967]                       })
[10:21:23.967]                     }
[10:21:23.967]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.967]                     base::options(mc.cores = 1L)
[10:21:23.967]                   }
[10:21:23.967]                   ...future.strategy.old <- future::plan("list")
[10:21:23.967]                   options(future.plan = NULL)
[10:21:23.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.967]                 }
[10:21:23.967]                 ...future.workdir <- getwd()
[10:21:23.967]             }
[10:21:23.967]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.967]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.967]         }
[10:21:23.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.967]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.967]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.967]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.967]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.967]             base::names(...future.oldOptions))
[10:21:23.967]     }
[10:21:23.967]     if (FALSE) {
[10:21:23.967]     }
[10:21:23.967]     else {
[10:21:23.967]         if (TRUE) {
[10:21:23.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.967]                 open = "w")
[10:21:23.967]         }
[10:21:23.967]         else {
[10:21:23.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.967]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.967]         }
[10:21:23.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.967]             base::sink(type = "output", split = FALSE)
[10:21:23.967]             base::close(...future.stdout)
[10:21:23.967]         }, add = TRUE)
[10:21:23.967]     }
[10:21:23.967]     ...future.frame <- base::sys.nframe()
[10:21:23.967]     ...future.conditions <- base::list()
[10:21:23.967]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.967]     if (FALSE) {
[10:21:23.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.967]     }
[10:21:23.967]     ...future.result <- base::tryCatch({
[10:21:23.967]         base::withCallingHandlers({
[10:21:23.967]             ...future.value <- base::withVisible(base::local({
[10:21:23.967]                 ...future.makeSendCondition <- base::local({
[10:21:23.967]                   sendCondition <- NULL
[10:21:23.967]                   function(frame = 1L) {
[10:21:23.967]                     if (is.function(sendCondition)) 
[10:21:23.967]                       return(sendCondition)
[10:21:23.967]                     ns <- getNamespace("parallel")
[10:21:23.967]                     if (exists("sendData", mode = "function", 
[10:21:23.967]                       envir = ns)) {
[10:21:23.967]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:23.967]                         envir = ns)
[10:21:23.967]                       envir <- sys.frame(frame)
[10:21:23.967]                       master <- NULL
[10:21:23.967]                       while (!identical(envir, .GlobalEnv) && 
[10:21:23.967]                         !identical(envir, emptyenv())) {
[10:21:23.967]                         if (exists("master", mode = "list", envir = envir, 
[10:21:23.967]                           inherits = FALSE)) {
[10:21:23.967]                           master <- get("master", mode = "list", 
[10:21:23.967]                             envir = envir, inherits = FALSE)
[10:21:23.967]                           if (inherits(master, c("SOCKnode", 
[10:21:23.967]                             "SOCK0node"))) {
[10:21:23.967]                             sendCondition <<- function(cond) {
[10:21:23.967]                               data <- list(type = "VALUE", value = cond, 
[10:21:23.967]                                 success = TRUE)
[10:21:23.967]                               parallel_sendData(master, data)
[10:21:23.967]                             }
[10:21:23.967]                             return(sendCondition)
[10:21:23.967]                           }
[10:21:23.967]                         }
[10:21:23.967]                         frame <- frame + 1L
[10:21:23.967]                         envir <- sys.frame(frame)
[10:21:23.967]                       }
[10:21:23.967]                     }
[10:21:23.967]                     sendCondition <<- function(cond) NULL
[10:21:23.967]                   }
[10:21:23.967]                 })
[10:21:23.967]                 withCallingHandlers({
[10:21:23.967]                   NULL
[10:21:23.967]                 }, immediateCondition = function(cond) {
[10:21:23.967]                   sendCondition <- ...future.makeSendCondition()
[10:21:23.967]                   sendCondition(cond)
[10:21:23.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.967]                   {
[10:21:23.967]                     inherits <- base::inherits
[10:21:23.967]                     invokeRestart <- base::invokeRestart
[10:21:23.967]                     is.null <- base::is.null
[10:21:23.967]                     muffled <- FALSE
[10:21:23.967]                     if (inherits(cond, "message")) {
[10:21:23.967]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.967]                       if (muffled) 
[10:21:23.967]                         invokeRestart("muffleMessage")
[10:21:23.967]                     }
[10:21:23.967]                     else if (inherits(cond, "warning")) {
[10:21:23.967]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.967]                       if (muffled) 
[10:21:23.967]                         invokeRestart("muffleWarning")
[10:21:23.967]                     }
[10:21:23.967]                     else if (inherits(cond, "condition")) {
[10:21:23.967]                       if (!is.null(pattern)) {
[10:21:23.967]                         computeRestarts <- base::computeRestarts
[10:21:23.967]                         grepl <- base::grepl
[10:21:23.967]                         restarts <- computeRestarts(cond)
[10:21:23.967]                         for (restart in restarts) {
[10:21:23.967]                           name <- restart$name
[10:21:23.967]                           if (is.null(name)) 
[10:21:23.967]                             next
[10:21:23.967]                           if (!grepl(pattern, name)) 
[10:21:23.967]                             next
[10:21:23.967]                           invokeRestart(restart)
[10:21:23.967]                           muffled <- TRUE
[10:21:23.967]                           break
[10:21:23.967]                         }
[10:21:23.967]                       }
[10:21:23.967]                     }
[10:21:23.967]                     invisible(muffled)
[10:21:23.967]                   }
[10:21:23.967]                   muffleCondition(cond)
[10:21:23.967]                 })
[10:21:23.967]             }))
[10:21:23.967]             future::FutureResult(value = ...future.value$value, 
[10:21:23.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.967]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.967]                     ...future.globalenv.names))
[10:21:23.967]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.967]         }, condition = base::local({
[10:21:23.967]             c <- base::c
[10:21:23.967]             inherits <- base::inherits
[10:21:23.967]             invokeRestart <- base::invokeRestart
[10:21:23.967]             length <- base::length
[10:21:23.967]             list <- base::list
[10:21:23.967]             seq.int <- base::seq.int
[10:21:23.967]             signalCondition <- base::signalCondition
[10:21:23.967]             sys.calls <- base::sys.calls
[10:21:23.967]             `[[` <- base::`[[`
[10:21:23.967]             `+` <- base::`+`
[10:21:23.967]             `<<-` <- base::`<<-`
[10:21:23.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.967]                   3L)]
[10:21:23.967]             }
[10:21:23.967]             function(cond) {
[10:21:23.967]                 is_error <- inherits(cond, "error")
[10:21:23.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.967]                   NULL)
[10:21:23.967]                 if (is_error) {
[10:21:23.967]                   sessionInformation <- function() {
[10:21:23.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.967]                       search = base::search(), system = base::Sys.info())
[10:21:23.967]                   }
[10:21:23.967]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.967]                     cond$call), session = sessionInformation(), 
[10:21:23.967]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.967]                   signalCondition(cond)
[10:21:23.967]                 }
[10:21:23.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.967]                 "immediateCondition"))) {
[10:21:23.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.967]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.967]                   if (TRUE && !signal) {
[10:21:23.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.967]                     {
[10:21:23.967]                       inherits <- base::inherits
[10:21:23.967]                       invokeRestart <- base::invokeRestart
[10:21:23.967]                       is.null <- base::is.null
[10:21:23.967]                       muffled <- FALSE
[10:21:23.967]                       if (inherits(cond, "message")) {
[10:21:23.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.967]                         if (muffled) 
[10:21:23.967]                           invokeRestart("muffleMessage")
[10:21:23.967]                       }
[10:21:23.967]                       else if (inherits(cond, "warning")) {
[10:21:23.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.967]                         if (muffled) 
[10:21:23.967]                           invokeRestart("muffleWarning")
[10:21:23.967]                       }
[10:21:23.967]                       else if (inherits(cond, "condition")) {
[10:21:23.967]                         if (!is.null(pattern)) {
[10:21:23.967]                           computeRestarts <- base::computeRestarts
[10:21:23.967]                           grepl <- base::grepl
[10:21:23.967]                           restarts <- computeRestarts(cond)
[10:21:23.967]                           for (restart in restarts) {
[10:21:23.967]                             name <- restart$name
[10:21:23.967]                             if (is.null(name)) 
[10:21:23.967]                               next
[10:21:23.967]                             if (!grepl(pattern, name)) 
[10:21:23.967]                               next
[10:21:23.967]                             invokeRestart(restart)
[10:21:23.967]                             muffled <- TRUE
[10:21:23.967]                             break
[10:21:23.967]                           }
[10:21:23.967]                         }
[10:21:23.967]                       }
[10:21:23.967]                       invisible(muffled)
[10:21:23.967]                     }
[10:21:23.967]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.967]                   }
[10:21:23.967]                 }
[10:21:23.967]                 else {
[10:21:23.967]                   if (TRUE) {
[10:21:23.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.967]                     {
[10:21:23.967]                       inherits <- base::inherits
[10:21:23.967]                       invokeRestart <- base::invokeRestart
[10:21:23.967]                       is.null <- base::is.null
[10:21:23.967]                       muffled <- FALSE
[10:21:23.967]                       if (inherits(cond, "message")) {
[10:21:23.967]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.967]                         if (muffled) 
[10:21:23.967]                           invokeRestart("muffleMessage")
[10:21:23.967]                       }
[10:21:23.967]                       else if (inherits(cond, "warning")) {
[10:21:23.967]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.967]                         if (muffled) 
[10:21:23.967]                           invokeRestart("muffleWarning")
[10:21:23.967]                       }
[10:21:23.967]                       else if (inherits(cond, "condition")) {
[10:21:23.967]                         if (!is.null(pattern)) {
[10:21:23.967]                           computeRestarts <- base::computeRestarts
[10:21:23.967]                           grepl <- base::grepl
[10:21:23.967]                           restarts <- computeRestarts(cond)
[10:21:23.967]                           for (restart in restarts) {
[10:21:23.967]                             name <- restart$name
[10:21:23.967]                             if (is.null(name)) 
[10:21:23.967]                               next
[10:21:23.967]                             if (!grepl(pattern, name)) 
[10:21:23.967]                               next
[10:21:23.967]                             invokeRestart(restart)
[10:21:23.967]                             muffled <- TRUE
[10:21:23.967]                             break
[10:21:23.967]                           }
[10:21:23.967]                         }
[10:21:23.967]                       }
[10:21:23.967]                       invisible(muffled)
[10:21:23.967]                     }
[10:21:23.967]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.967]                   }
[10:21:23.967]                 }
[10:21:23.967]             }
[10:21:23.967]         }))
[10:21:23.967]     }, error = function(ex) {
[10:21:23.967]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.967]                 ...future.rng), started = ...future.startTime, 
[10:21:23.967]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.967]             version = "1.8"), class = "FutureResult")
[10:21:23.967]     }, finally = {
[10:21:23.967]         if (!identical(...future.workdir, getwd())) 
[10:21:23.967]             setwd(...future.workdir)
[10:21:23.967]         {
[10:21:23.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.967]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.967]             }
[10:21:23.967]             base::options(...future.oldOptions)
[10:21:23.967]             if (.Platform$OS.type == "windows") {
[10:21:23.967]                 old_names <- names(...future.oldEnvVars)
[10:21:23.967]                 envs <- base::Sys.getenv()
[10:21:23.967]                 names <- names(envs)
[10:21:23.967]                 common <- intersect(names, old_names)
[10:21:23.967]                 added <- setdiff(names, old_names)
[10:21:23.967]                 removed <- setdiff(old_names, names)
[10:21:23.967]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.967]                   envs[common]]
[10:21:23.967]                 NAMES <- toupper(changed)
[10:21:23.967]                 args <- list()
[10:21:23.967]                 for (kk in seq_along(NAMES)) {
[10:21:23.967]                   name <- changed[[kk]]
[10:21:23.967]                   NAME <- NAMES[[kk]]
[10:21:23.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.967]                     next
[10:21:23.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.967]                 }
[10:21:23.967]                 NAMES <- toupper(added)
[10:21:23.967]                 for (kk in seq_along(NAMES)) {
[10:21:23.967]                   name <- added[[kk]]
[10:21:23.967]                   NAME <- NAMES[[kk]]
[10:21:23.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.967]                     next
[10:21:23.967]                   args[[name]] <- ""
[10:21:23.967]                 }
[10:21:23.967]                 NAMES <- toupper(removed)
[10:21:23.967]                 for (kk in seq_along(NAMES)) {
[10:21:23.967]                   name <- removed[[kk]]
[10:21:23.967]                   NAME <- NAMES[[kk]]
[10:21:23.967]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.967]                     next
[10:21:23.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.967]                 }
[10:21:23.967]                 if (length(args) > 0) 
[10:21:23.967]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.967]             }
[10:21:23.967]             else {
[10:21:23.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.967]             }
[10:21:23.967]             {
[10:21:23.967]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.967]                   0L) {
[10:21:23.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.967]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.967]                   base::options(opts)
[10:21:23.967]                 }
[10:21:23.967]                 {
[10:21:23.967]                   {
[10:21:23.967]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.967]                     NULL
[10:21:23.967]                   }
[10:21:23.967]                   options(future.plan = NULL)
[10:21:23.967]                   if (is.na(NA_character_)) 
[10:21:23.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.967]                     .init = FALSE)
[10:21:23.967]                 }
[10:21:23.967]             }
[10:21:23.967]         }
[10:21:23.967]     })
[10:21:23.967]     if (TRUE) {
[10:21:23.967]         base::sink(type = "output", split = FALSE)
[10:21:23.967]         if (TRUE) {
[10:21:23.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.967]         }
[10:21:23.967]         else {
[10:21:23.967]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.967]         }
[10:21:23.967]         base::close(...future.stdout)
[10:21:23.967]         ...future.stdout <- NULL
[10:21:23.967]     }
[10:21:23.967]     ...future.result$conditions <- ...future.conditions
[10:21:23.967]     ...future.result$finished <- base::Sys.time()
[10:21:23.967]     ...future.result
[10:21:23.967] }
[10:21:23.970] MultisessionFuture started
[10:21:23.970] - Launch lazy future ... done
[10:21:23.971] run() for ‘MultisessionFuture’ ... done
[10:21:23.971] getGlobalsAndPackages() ...
[10:21:23.971] Searching for globals...
[10:21:23.972] - globals found: [1] ‘{’
[10:21:23.972] Searching for globals ... DONE
[10:21:23.972] Resolving globals: FALSE
[10:21:23.972] 
[10:21:23.972] 
[10:21:23.972] getGlobalsAndPackages() ... DONE
[10:21:23.972] run() for ‘Future’ ...
[10:21:23.973] - state: ‘created’
[10:21:23.973] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:23.987] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:23.987] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:23.987]   - Field: ‘node’
[10:21:23.987]   - Field: ‘label’
[10:21:23.987]   - Field: ‘local’
[10:21:23.987]   - Field: ‘owner’
[10:21:23.988]   - Field: ‘envir’
[10:21:23.988]   - Field: ‘workers’
[10:21:23.988]   - Field: ‘packages’
[10:21:23.988]   - Field: ‘gc’
[10:21:23.988]   - Field: ‘conditions’
[10:21:23.988]   - Field: ‘persistent’
[10:21:23.988]   - Field: ‘expr’
[10:21:23.988]   - Field: ‘uuid’
[10:21:23.988]   - Field: ‘seed’
[10:21:23.989]   - Field: ‘version’
[10:21:23.989]   - Field: ‘result’
[10:21:23.989]   - Field: ‘asynchronous’
[10:21:23.989]   - Field: ‘calls’
[10:21:23.989]   - Field: ‘globals’
[10:21:23.989]   - Field: ‘stdout’
[10:21:23.989]   - Field: ‘earlySignal’
[10:21:23.990]   - Field: ‘lazy’
[10:21:23.990]   - Field: ‘state’
[10:21:23.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:23.990] - Launch lazy future ...
[10:21:23.990] Packages needed by the future expression (n = 0): <none>
[10:21:23.991] Packages needed by future strategies (n = 0): <none>
[10:21:23.991] {
[10:21:23.991]     {
[10:21:23.991]         {
[10:21:23.991]             ...future.startTime <- base::Sys.time()
[10:21:23.991]             {
[10:21:23.991]                 {
[10:21:23.991]                   {
[10:21:23.991]                     {
[10:21:23.991]                       base::local({
[10:21:23.991]                         has_future <- base::requireNamespace("future", 
[10:21:23.991]                           quietly = TRUE)
[10:21:23.991]                         if (has_future) {
[10:21:23.991]                           ns <- base::getNamespace("future")
[10:21:23.991]                           version <- ns[[".package"]][["version"]]
[10:21:23.991]                           if (is.null(version)) 
[10:21:23.991]                             version <- utils::packageVersion("future")
[10:21:23.991]                         }
[10:21:23.991]                         else {
[10:21:23.991]                           version <- NULL
[10:21:23.991]                         }
[10:21:23.991]                         if (!has_future || version < "1.8.0") {
[10:21:23.991]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:23.991]                             "", base::R.version$version.string), 
[10:21:23.991]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:23.991]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:23.991]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:23.991]                               "release", "version")], collapse = " "), 
[10:21:23.991]                             hostname = base::Sys.info()[["nodename"]])
[10:21:23.991]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:23.991]                             info)
[10:21:23.991]                           info <- base::paste(info, collapse = "; ")
[10:21:23.991]                           if (!has_future) {
[10:21:23.991]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:23.991]                               info)
[10:21:23.991]                           }
[10:21:23.991]                           else {
[10:21:23.991]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:23.991]                               info, version)
[10:21:23.991]                           }
[10:21:23.991]                           base::stop(msg)
[10:21:23.991]                         }
[10:21:23.991]                       })
[10:21:23.991]                     }
[10:21:23.991]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:23.991]                     base::options(mc.cores = 1L)
[10:21:23.991]                   }
[10:21:23.991]                   ...future.strategy.old <- future::plan("list")
[10:21:23.991]                   options(future.plan = NULL)
[10:21:23.991]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.991]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:23.991]                 }
[10:21:23.991]                 ...future.workdir <- getwd()
[10:21:23.991]             }
[10:21:23.991]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:23.991]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:23.991]         }
[10:21:23.991]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:23.991]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:23.991]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:23.991]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:23.991]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:23.991]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:23.991]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:23.991]             base::names(...future.oldOptions))
[10:21:23.991]     }
[10:21:23.991]     if (FALSE) {
[10:21:23.991]     }
[10:21:23.991]     else {
[10:21:23.991]         if (TRUE) {
[10:21:23.991]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:23.991]                 open = "w")
[10:21:23.991]         }
[10:21:23.991]         else {
[10:21:23.991]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:23.991]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:23.991]         }
[10:21:23.991]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:23.991]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:23.991]             base::sink(type = "output", split = FALSE)
[10:21:23.991]             base::close(...future.stdout)
[10:21:23.991]         }, add = TRUE)
[10:21:23.991]     }
[10:21:23.991]     ...future.frame <- base::sys.nframe()
[10:21:23.991]     ...future.conditions <- base::list()
[10:21:23.991]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:23.991]     if (FALSE) {
[10:21:23.991]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:23.991]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:23.991]     }
[10:21:23.991]     ...future.result <- base::tryCatch({
[10:21:23.991]         base::withCallingHandlers({
[10:21:23.991]             ...future.value <- base::withVisible(base::local({
[10:21:23.991]                 ...future.makeSendCondition <- base::local({
[10:21:23.991]                   sendCondition <- NULL
[10:21:23.991]                   function(frame = 1L) {
[10:21:23.991]                     if (is.function(sendCondition)) 
[10:21:23.991]                       return(sendCondition)
[10:21:23.991]                     ns <- getNamespace("parallel")
[10:21:23.991]                     if (exists("sendData", mode = "function", 
[10:21:23.991]                       envir = ns)) {
[10:21:23.991]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:23.991]                         envir = ns)
[10:21:23.991]                       envir <- sys.frame(frame)
[10:21:23.991]                       master <- NULL
[10:21:23.991]                       while (!identical(envir, .GlobalEnv) && 
[10:21:23.991]                         !identical(envir, emptyenv())) {
[10:21:23.991]                         if (exists("master", mode = "list", envir = envir, 
[10:21:23.991]                           inherits = FALSE)) {
[10:21:23.991]                           master <- get("master", mode = "list", 
[10:21:23.991]                             envir = envir, inherits = FALSE)
[10:21:23.991]                           if (inherits(master, c("SOCKnode", 
[10:21:23.991]                             "SOCK0node"))) {
[10:21:23.991]                             sendCondition <<- function(cond) {
[10:21:23.991]                               data <- list(type = "VALUE", value = cond, 
[10:21:23.991]                                 success = TRUE)
[10:21:23.991]                               parallel_sendData(master, data)
[10:21:23.991]                             }
[10:21:23.991]                             return(sendCondition)
[10:21:23.991]                           }
[10:21:23.991]                         }
[10:21:23.991]                         frame <- frame + 1L
[10:21:23.991]                         envir <- sys.frame(frame)
[10:21:23.991]                       }
[10:21:23.991]                     }
[10:21:23.991]                     sendCondition <<- function(cond) NULL
[10:21:23.991]                   }
[10:21:23.991]                 })
[10:21:23.991]                 withCallingHandlers({
[10:21:23.991]                   {
[10:21:23.991]                     4
[10:21:23.991]                   }
[10:21:23.991]                 }, immediateCondition = function(cond) {
[10:21:23.991]                   sendCondition <- ...future.makeSendCondition()
[10:21:23.991]                   sendCondition(cond)
[10:21:23.991]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.991]                   {
[10:21:23.991]                     inherits <- base::inherits
[10:21:23.991]                     invokeRestart <- base::invokeRestart
[10:21:23.991]                     is.null <- base::is.null
[10:21:23.991]                     muffled <- FALSE
[10:21:23.991]                     if (inherits(cond, "message")) {
[10:21:23.991]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:23.991]                       if (muffled) 
[10:21:23.991]                         invokeRestart("muffleMessage")
[10:21:23.991]                     }
[10:21:23.991]                     else if (inherits(cond, "warning")) {
[10:21:23.991]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:23.991]                       if (muffled) 
[10:21:23.991]                         invokeRestart("muffleWarning")
[10:21:23.991]                     }
[10:21:23.991]                     else if (inherits(cond, "condition")) {
[10:21:23.991]                       if (!is.null(pattern)) {
[10:21:23.991]                         computeRestarts <- base::computeRestarts
[10:21:23.991]                         grepl <- base::grepl
[10:21:23.991]                         restarts <- computeRestarts(cond)
[10:21:23.991]                         for (restart in restarts) {
[10:21:23.991]                           name <- restart$name
[10:21:23.991]                           if (is.null(name)) 
[10:21:23.991]                             next
[10:21:23.991]                           if (!grepl(pattern, name)) 
[10:21:23.991]                             next
[10:21:23.991]                           invokeRestart(restart)
[10:21:23.991]                           muffled <- TRUE
[10:21:23.991]                           break
[10:21:23.991]                         }
[10:21:23.991]                       }
[10:21:23.991]                     }
[10:21:23.991]                     invisible(muffled)
[10:21:23.991]                   }
[10:21:23.991]                   muffleCondition(cond)
[10:21:23.991]                 })
[10:21:23.991]             }))
[10:21:23.991]             future::FutureResult(value = ...future.value$value, 
[10:21:23.991]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.991]                   ...future.rng), globalenv = if (FALSE) 
[10:21:23.991]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:23.991]                     ...future.globalenv.names))
[10:21:23.991]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:23.991]         }, condition = base::local({
[10:21:23.991]             c <- base::c
[10:21:23.991]             inherits <- base::inherits
[10:21:23.991]             invokeRestart <- base::invokeRestart
[10:21:23.991]             length <- base::length
[10:21:23.991]             list <- base::list
[10:21:23.991]             seq.int <- base::seq.int
[10:21:23.991]             signalCondition <- base::signalCondition
[10:21:23.991]             sys.calls <- base::sys.calls
[10:21:23.991]             `[[` <- base::`[[`
[10:21:23.991]             `+` <- base::`+`
[10:21:23.991]             `<<-` <- base::`<<-`
[10:21:23.991]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:23.991]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:23.991]                   3L)]
[10:21:23.991]             }
[10:21:23.991]             function(cond) {
[10:21:23.991]                 is_error <- inherits(cond, "error")
[10:21:23.991]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:23.991]                   NULL)
[10:21:23.991]                 if (is_error) {
[10:21:23.991]                   sessionInformation <- function() {
[10:21:23.991]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:23.991]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:23.991]                       search = base::search(), system = base::Sys.info())
[10:21:23.991]                   }
[10:21:23.991]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.991]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:23.991]                     cond$call), session = sessionInformation(), 
[10:21:23.991]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:23.991]                   signalCondition(cond)
[10:21:23.991]                 }
[10:21:23.991]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:23.991]                 "immediateCondition"))) {
[10:21:23.991]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:23.991]                   ...future.conditions[[length(...future.conditions) + 
[10:21:23.991]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:23.991]                   if (TRUE && !signal) {
[10:21:23.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.991]                     {
[10:21:23.991]                       inherits <- base::inherits
[10:21:23.991]                       invokeRestart <- base::invokeRestart
[10:21:23.991]                       is.null <- base::is.null
[10:21:23.991]                       muffled <- FALSE
[10:21:23.991]                       if (inherits(cond, "message")) {
[10:21:23.991]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.991]                         if (muffled) 
[10:21:23.991]                           invokeRestart("muffleMessage")
[10:21:23.991]                       }
[10:21:23.991]                       else if (inherits(cond, "warning")) {
[10:21:23.991]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.991]                         if (muffled) 
[10:21:23.991]                           invokeRestart("muffleWarning")
[10:21:23.991]                       }
[10:21:23.991]                       else if (inherits(cond, "condition")) {
[10:21:23.991]                         if (!is.null(pattern)) {
[10:21:23.991]                           computeRestarts <- base::computeRestarts
[10:21:23.991]                           grepl <- base::grepl
[10:21:23.991]                           restarts <- computeRestarts(cond)
[10:21:23.991]                           for (restart in restarts) {
[10:21:23.991]                             name <- restart$name
[10:21:23.991]                             if (is.null(name)) 
[10:21:23.991]                               next
[10:21:23.991]                             if (!grepl(pattern, name)) 
[10:21:23.991]                               next
[10:21:23.991]                             invokeRestart(restart)
[10:21:23.991]                             muffled <- TRUE
[10:21:23.991]                             break
[10:21:23.991]                           }
[10:21:23.991]                         }
[10:21:23.991]                       }
[10:21:23.991]                       invisible(muffled)
[10:21:23.991]                     }
[10:21:23.991]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.991]                   }
[10:21:23.991]                 }
[10:21:23.991]                 else {
[10:21:23.991]                   if (TRUE) {
[10:21:23.991]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:23.991]                     {
[10:21:23.991]                       inherits <- base::inherits
[10:21:23.991]                       invokeRestart <- base::invokeRestart
[10:21:23.991]                       is.null <- base::is.null
[10:21:23.991]                       muffled <- FALSE
[10:21:23.991]                       if (inherits(cond, "message")) {
[10:21:23.991]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:23.991]                         if (muffled) 
[10:21:23.991]                           invokeRestart("muffleMessage")
[10:21:23.991]                       }
[10:21:23.991]                       else if (inherits(cond, "warning")) {
[10:21:23.991]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:23.991]                         if (muffled) 
[10:21:23.991]                           invokeRestart("muffleWarning")
[10:21:23.991]                       }
[10:21:23.991]                       else if (inherits(cond, "condition")) {
[10:21:23.991]                         if (!is.null(pattern)) {
[10:21:23.991]                           computeRestarts <- base::computeRestarts
[10:21:23.991]                           grepl <- base::grepl
[10:21:23.991]                           restarts <- computeRestarts(cond)
[10:21:23.991]                           for (restart in restarts) {
[10:21:23.991]                             name <- restart$name
[10:21:23.991]                             if (is.null(name)) 
[10:21:23.991]                               next
[10:21:23.991]                             if (!grepl(pattern, name)) 
[10:21:23.991]                               next
[10:21:23.991]                             invokeRestart(restart)
[10:21:23.991]                             muffled <- TRUE
[10:21:23.991]                             break
[10:21:23.991]                           }
[10:21:23.991]                         }
[10:21:23.991]                       }
[10:21:23.991]                       invisible(muffled)
[10:21:23.991]                     }
[10:21:23.991]                     muffleCondition(cond, pattern = "^muffle")
[10:21:23.991]                   }
[10:21:23.991]                 }
[10:21:23.991]             }
[10:21:23.991]         }))
[10:21:23.991]     }, error = function(ex) {
[10:21:23.991]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:23.991]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:23.991]                 ...future.rng), started = ...future.startTime, 
[10:21:23.991]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:23.991]             version = "1.8"), class = "FutureResult")
[10:21:23.991]     }, finally = {
[10:21:23.991]         if (!identical(...future.workdir, getwd())) 
[10:21:23.991]             setwd(...future.workdir)
[10:21:23.991]         {
[10:21:23.991]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:23.991]                 ...future.oldOptions$nwarnings <- NULL
[10:21:23.991]             }
[10:21:23.991]             base::options(...future.oldOptions)
[10:21:23.991]             if (.Platform$OS.type == "windows") {
[10:21:23.991]                 old_names <- names(...future.oldEnvVars)
[10:21:23.991]                 envs <- base::Sys.getenv()
[10:21:23.991]                 names <- names(envs)
[10:21:23.991]                 common <- intersect(names, old_names)
[10:21:23.991]                 added <- setdiff(names, old_names)
[10:21:23.991]                 removed <- setdiff(old_names, names)
[10:21:23.991]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:23.991]                   envs[common]]
[10:21:23.991]                 NAMES <- toupper(changed)
[10:21:23.991]                 args <- list()
[10:21:23.991]                 for (kk in seq_along(NAMES)) {
[10:21:23.991]                   name <- changed[[kk]]
[10:21:23.991]                   NAME <- NAMES[[kk]]
[10:21:23.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.991]                     next
[10:21:23.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.991]                 }
[10:21:23.991]                 NAMES <- toupper(added)
[10:21:23.991]                 for (kk in seq_along(NAMES)) {
[10:21:23.991]                   name <- added[[kk]]
[10:21:23.991]                   NAME <- NAMES[[kk]]
[10:21:23.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.991]                     next
[10:21:23.991]                   args[[name]] <- ""
[10:21:23.991]                 }
[10:21:23.991]                 NAMES <- toupper(removed)
[10:21:23.991]                 for (kk in seq_along(NAMES)) {
[10:21:23.991]                   name <- removed[[kk]]
[10:21:23.991]                   NAME <- NAMES[[kk]]
[10:21:23.991]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:23.991]                     next
[10:21:23.991]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:23.991]                 }
[10:21:23.991]                 if (length(args) > 0) 
[10:21:23.991]                   base::do.call(base::Sys.setenv, args = args)
[10:21:23.991]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:23.991]             }
[10:21:23.991]             else {
[10:21:23.991]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:23.991]             }
[10:21:23.991]             {
[10:21:23.991]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:23.991]                   0L) {
[10:21:23.991]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:23.991]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:23.991]                   base::options(opts)
[10:21:23.991]                 }
[10:21:23.991]                 {
[10:21:23.991]                   {
[10:21:23.991]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:23.991]                     NULL
[10:21:23.991]                   }
[10:21:23.991]                   options(future.plan = NULL)
[10:21:23.991]                   if (is.na(NA_character_)) 
[10:21:23.991]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:23.991]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:23.991]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:23.991]                     .init = FALSE)
[10:21:23.991]                 }
[10:21:23.991]             }
[10:21:23.991]         }
[10:21:23.991]     })
[10:21:23.991]     if (TRUE) {
[10:21:23.991]         base::sink(type = "output", split = FALSE)
[10:21:23.991]         if (TRUE) {
[10:21:23.991]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:23.991]         }
[10:21:23.991]         else {
[10:21:23.991]             ...future.result["stdout"] <- base::list(NULL)
[10:21:23.991]         }
[10:21:23.991]         base::close(...future.stdout)
[10:21:23.991]         ...future.stdout <- NULL
[10:21:23.991]     }
[10:21:23.991]     ...future.result$conditions <- ...future.conditions
[10:21:23.991]     ...future.result$finished <- base::Sys.time()
[10:21:23.991]     ...future.result
[10:21:23.991] }
[10:21:23.993] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:24.004] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.004] - Validating connection of MultisessionFuture
[10:21:24.004] - received message: FutureResult
[10:21:24.004] - Received FutureResult
[10:21:24.004] - Erased future from FutureRegistry
[10:21:24.005] result() for ClusterFuture ...
[10:21:24.005] - result already collected: FutureResult
[10:21:24.005] result() for ClusterFuture ... done
[10:21:24.005] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:24.005] result() for ClusterFuture ...
[10:21:24.005] - result already collected: FutureResult
[10:21:24.005] result() for ClusterFuture ... done
[10:21:24.005] result() for ClusterFuture ...
[10:21:24.005] - result already collected: FutureResult
[10:21:24.005] result() for ClusterFuture ... done
[10:21:24.006] MultisessionFuture started
[10:21:24.006] - Launch lazy future ... done
[10:21:24.006] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e767fef0> 
Classes 'listenv', 'environment' <environment: 0x55e8e62c36b8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[10:21:24.013] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.013] - Validating connection of MultisessionFuture
[10:21:24.013] - received message: FutureResult
[10:21:24.013] - Received FutureResult
[10:21:24.014] - Erased future from FutureRegistry
[10:21:24.014] result() for ClusterFuture ...
[10:21:24.014] - result already collected: FutureResult
[10:21:24.014] result() for ClusterFuture ... done
[10:21:24.014] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:24.027] resolve() on list environment ...
[10:21:24.027]  recursive: 0
[10:21:24.028]  length: 6
[10:21:24.028]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:24.028] signalConditionsASAP(numeric, pos=1) ...
[10:21:24.028] - nx: 6
[10:21:24.028] - relay: TRUE
[10:21:24.028] - stdout: TRUE
[10:21:24.028] - signal: TRUE
[10:21:24.028] - resignal: FALSE
[10:21:24.028] - force: TRUE
[10:21:24.028] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.028] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.029]  - until=2
[10:21:24.029]  - relaying element #2
[10:21:24.029] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.029] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.029] signalConditionsASAP(NULL, pos=1) ... done
[10:21:24.029]  length: 5 (resolved future 1)
[10:21:24.029] Future #2
[10:21:24.029] result() for ClusterFuture ...
[10:21:24.029] - result already collected: FutureResult
[10:21:24.029] result() for ClusterFuture ... done
[10:21:24.029] result() for ClusterFuture ...
[10:21:24.030] - result already collected: FutureResult
[10:21:24.030] result() for ClusterFuture ... done
[10:21:24.030] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:24.030] - nx: 6
[10:21:24.030] - relay: TRUE
[10:21:24.030] - stdout: TRUE
[10:21:24.030] - signal: TRUE
[10:21:24.030] - resignal: FALSE
[10:21:24.030] - force: TRUE
[10:21:24.030] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.030] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.030]  - until=2
[10:21:24.031]  - relaying element #2
[10:21:24.031] result() for ClusterFuture ...
[10:21:24.031] - result already collected: FutureResult
[10:21:24.031] result() for ClusterFuture ... done
[10:21:24.031] result() for ClusterFuture ...
[10:21:24.031] - result already collected: FutureResult
[10:21:24.031] result() for ClusterFuture ... done
[10:21:24.031] result() for ClusterFuture ...
[10:21:24.031] - result already collected: FutureResult
[10:21:24.031] result() for ClusterFuture ... done
[10:21:24.031] result() for ClusterFuture ...
[10:21:24.031] - result already collected: FutureResult
[10:21:24.032] result() for ClusterFuture ... done
[10:21:24.032] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.032] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.032] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:24.032]  length: 4 (resolved future 2)
[10:21:24.032] Future #3
[10:21:24.032] result() for ClusterFuture ...
[10:21:24.032] - result already collected: FutureResult
[10:21:24.032] result() for ClusterFuture ... done
[10:21:24.032] result() for ClusterFuture ...
[10:21:24.032] - result already collected: FutureResult
[10:21:24.032] result() for ClusterFuture ... done
[10:21:24.033] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:24.033] - nx: 6
[10:21:24.033] - relay: TRUE
[10:21:24.033] - stdout: TRUE
[10:21:24.033] - signal: TRUE
[10:21:24.033] - resignal: FALSE
[10:21:24.033] - force: TRUE
[10:21:24.033] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.033] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.033]  - until=3
[10:21:24.033]  - relaying element #3
[10:21:24.033] result() for ClusterFuture ...
[10:21:24.034] - result already collected: FutureResult
[10:21:24.034] result() for ClusterFuture ... done
[10:21:24.034] result() for ClusterFuture ...
[10:21:24.034] - result already collected: FutureResult
[10:21:24.034] result() for ClusterFuture ... done
[10:21:24.034] result() for ClusterFuture ...
[10:21:24.034] - result already collected: FutureResult
[10:21:24.034] result() for ClusterFuture ... done
[10:21:24.034] result() for ClusterFuture ...
[10:21:24.034] - result already collected: FutureResult
[10:21:24.034] result() for ClusterFuture ... done
[10:21:24.034] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.034] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.035] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:24.035]  length: 3 (resolved future 3)
[10:21:24.045] signalConditionsASAP(NULL, pos=5) ...
[10:21:24.045] - nx: 6
[10:21:24.045] - relay: TRUE
[10:21:24.046] - stdout: TRUE
[10:21:24.046] - signal: TRUE
[10:21:24.046] - resignal: FALSE
[10:21:24.046] - force: TRUE
[10:21:24.046] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.046] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.046]  - until=6
[10:21:24.046]  - relaying element #4
[10:21:24.046]  - relaying element #6
[10:21:24.047] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:24.047] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.047] signalConditionsASAP(NULL, pos=5) ... done
[10:21:24.047]  length: 2 (resolved future 5)
[10:21:24.047] signalConditionsASAP(numeric, pos=6) ...
[10:21:24.047] - nx: 6
[10:21:24.048] - relay: TRUE
[10:21:24.048] - stdout: TRUE
[10:21:24.048] - signal: TRUE
[10:21:24.048] - resignal: FALSE
[10:21:24.048] - force: TRUE
[10:21:24.048] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:24.048] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.048]  - until=6
[10:21:24.048]  - relaying element #4
[10:21:24.048] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:24.048] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.049] signalConditionsASAP(NULL, pos=6) ... done
[10:21:24.049]  length: 1 (resolved future 6)
[10:21:24.059] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.059] - Validating connection of MultisessionFuture
[10:21:24.060] - received message: FutureResult
[10:21:24.060] - Received FutureResult
[10:21:24.060] - Erased future from FutureRegistry
[10:21:24.060] result() for ClusterFuture ...
[10:21:24.060] - result already collected: FutureResult
[10:21:24.060] result() for ClusterFuture ... done
[10:21:24.060] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:24.060] Future #4
[10:21:24.060] result() for ClusterFuture ...
[10:21:24.061] - result already collected: FutureResult
[10:21:24.061] result() for ClusterFuture ... done
[10:21:24.061] result() for ClusterFuture ...
[10:21:24.061] - result already collected: FutureResult
[10:21:24.061] result() for ClusterFuture ... done
[10:21:24.061] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:24.061] - nx: 6
[10:21:24.061] - relay: TRUE
[10:21:24.061] - stdout: TRUE
[10:21:24.061] - signal: TRUE
[10:21:24.061] - resignal: FALSE
[10:21:24.061] - force: TRUE
[10:21:24.061] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:24.062] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.062]  - until=6
[10:21:24.062]  - relaying element #4
[10:21:24.062] result() for ClusterFuture ...
[10:21:24.062] - result already collected: FutureResult
[10:21:24.062] result() for ClusterFuture ... done
[10:21:24.062] result() for ClusterFuture ...
[10:21:24.062] - result already collected: FutureResult
[10:21:24.062] result() for ClusterFuture ... done
[10:21:24.062] result() for ClusterFuture ...
[10:21:24.062] - result already collected: FutureResult
[10:21:24.063] result() for ClusterFuture ... done
[10:21:24.063] result() for ClusterFuture ...
[10:21:24.063] - result already collected: FutureResult
[10:21:24.063] result() for ClusterFuture ... done
[10:21:24.063] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.063] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:24.063] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:24.063]  length: 0 (resolved future 4)
[10:21:24.063] Relaying remaining futures
[10:21:24.063] signalConditionsASAP(NULL, pos=0) ...
[10:21:24.063] - nx: 6
[10:21:24.063] - relay: TRUE
[10:21:24.064] - stdout: TRUE
[10:21:24.064] - signal: TRUE
[10:21:24.064] - resignal: FALSE
[10:21:24.064] - force: TRUE
[10:21:24.064] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.064] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:24.064] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.064] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:24.064] signalConditionsASAP(NULL, pos=0) ... done
[10:21:24.064] resolve() on list environment ... DONE
[10:21:24.064] result() for ClusterFuture ...
[10:21:24.064] - result already collected: FutureResult
[10:21:24.065] result() for ClusterFuture ... done
[10:21:24.065] result() for ClusterFuture ...
[10:21:24.065] - result already collected: FutureResult
[10:21:24.065] result() for ClusterFuture ... done
[10:21:24.065] result() for ClusterFuture ...
[10:21:24.065] - result already collected: FutureResult
[10:21:24.065] result() for ClusterFuture ... done
[10:21:24.065] result() for ClusterFuture ...
[10:21:24.065] - result already collected: FutureResult
[10:21:24.065] result() for ClusterFuture ... done
[10:21:24.066] result() for ClusterFuture ...
[10:21:24.066] - result already collected: FutureResult
[10:21:24.066] result() for ClusterFuture ... done
[10:21:24.066] result() for ClusterFuture ...
[10:21:24.066] - result already collected: FutureResult
[10:21:24.066] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e6591a30> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[10:21:24.068] getGlobalsAndPackages() ...
[10:21:24.068] Searching for globals...
[10:21:24.068] 
[10:21:24.068] Searching for globals ... DONE
[10:21:24.068] - globals: [0] <none>
[10:21:24.068] getGlobalsAndPackages() ... DONE
[10:21:24.069] run() for ‘Future’ ...
[10:21:24.069] - state: ‘created’
[10:21:24.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:24.083] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:24.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:24.083]   - Field: ‘node’
[10:21:24.083]   - Field: ‘label’
[10:21:24.083]   - Field: ‘local’
[10:21:24.083]   - Field: ‘owner’
[10:21:24.083]   - Field: ‘envir’
[10:21:24.084]   - Field: ‘workers’
[10:21:24.084]   - Field: ‘packages’
[10:21:24.084]   - Field: ‘gc’
[10:21:24.084]   - Field: ‘conditions’
[10:21:24.084]   - Field: ‘persistent’
[10:21:24.084]   - Field: ‘expr’
[10:21:24.084]   - Field: ‘uuid’
[10:21:24.084]   - Field: ‘seed’
[10:21:24.084]   - Field: ‘version’
[10:21:24.084]   - Field: ‘result’
[10:21:24.084]   - Field: ‘asynchronous’
[10:21:24.085]   - Field: ‘calls’
[10:21:24.085]   - Field: ‘globals’
[10:21:24.085]   - Field: ‘stdout’
[10:21:24.085]   - Field: ‘earlySignal’
[10:21:24.085]   - Field: ‘lazy’
[10:21:24.085]   - Field: ‘state’
[10:21:24.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:24.085] - Launch lazy future ...
[10:21:24.085] Packages needed by the future expression (n = 0): <none>
[10:21:24.086] Packages needed by future strategies (n = 0): <none>
[10:21:24.086] {
[10:21:24.086]     {
[10:21:24.086]         {
[10:21:24.086]             ...future.startTime <- base::Sys.time()
[10:21:24.086]             {
[10:21:24.086]                 {
[10:21:24.086]                   {
[10:21:24.086]                     {
[10:21:24.086]                       base::local({
[10:21:24.086]                         has_future <- base::requireNamespace("future", 
[10:21:24.086]                           quietly = TRUE)
[10:21:24.086]                         if (has_future) {
[10:21:24.086]                           ns <- base::getNamespace("future")
[10:21:24.086]                           version <- ns[[".package"]][["version"]]
[10:21:24.086]                           if (is.null(version)) 
[10:21:24.086]                             version <- utils::packageVersion("future")
[10:21:24.086]                         }
[10:21:24.086]                         else {
[10:21:24.086]                           version <- NULL
[10:21:24.086]                         }
[10:21:24.086]                         if (!has_future || version < "1.8.0") {
[10:21:24.086]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:24.086]                             "", base::R.version$version.string), 
[10:21:24.086]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:24.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:24.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:24.086]                               "release", "version")], collapse = " "), 
[10:21:24.086]                             hostname = base::Sys.info()[["nodename"]])
[10:21:24.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:24.086]                             info)
[10:21:24.086]                           info <- base::paste(info, collapse = "; ")
[10:21:24.086]                           if (!has_future) {
[10:21:24.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:24.086]                               info)
[10:21:24.086]                           }
[10:21:24.086]                           else {
[10:21:24.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:24.086]                               info, version)
[10:21:24.086]                           }
[10:21:24.086]                           base::stop(msg)
[10:21:24.086]                         }
[10:21:24.086]                       })
[10:21:24.086]                     }
[10:21:24.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:24.086]                     base::options(mc.cores = 1L)
[10:21:24.086]                   }
[10:21:24.086]                   ...future.strategy.old <- future::plan("list")
[10:21:24.086]                   options(future.plan = NULL)
[10:21:24.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:24.086]                 }
[10:21:24.086]                 ...future.workdir <- getwd()
[10:21:24.086]             }
[10:21:24.086]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:24.086]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:24.086]         }
[10:21:24.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:24.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:24.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:24.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:24.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:24.086]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:24.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:24.086]             base::names(...future.oldOptions))
[10:21:24.086]     }
[10:21:24.086]     if (FALSE) {
[10:21:24.086]     }
[10:21:24.086]     else {
[10:21:24.086]         if (TRUE) {
[10:21:24.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:24.086]                 open = "w")
[10:21:24.086]         }
[10:21:24.086]         else {
[10:21:24.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:24.086]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:24.086]         }
[10:21:24.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:24.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:24.086]             base::sink(type = "output", split = FALSE)
[10:21:24.086]             base::close(...future.stdout)
[10:21:24.086]         }, add = TRUE)
[10:21:24.086]     }
[10:21:24.086]     ...future.frame <- base::sys.nframe()
[10:21:24.086]     ...future.conditions <- base::list()
[10:21:24.086]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:24.086]     if (FALSE) {
[10:21:24.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:24.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:24.086]     }
[10:21:24.086]     ...future.result <- base::tryCatch({
[10:21:24.086]         base::withCallingHandlers({
[10:21:24.086]             ...future.value <- base::withVisible(base::local({
[10:21:24.086]                 ...future.makeSendCondition <- base::local({
[10:21:24.086]                   sendCondition <- NULL
[10:21:24.086]                   function(frame = 1L) {
[10:21:24.086]                     if (is.function(sendCondition)) 
[10:21:24.086]                       return(sendCondition)
[10:21:24.086]                     ns <- getNamespace("parallel")
[10:21:24.086]                     if (exists("sendData", mode = "function", 
[10:21:24.086]                       envir = ns)) {
[10:21:24.086]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:24.086]                         envir = ns)
[10:21:24.086]                       envir <- sys.frame(frame)
[10:21:24.086]                       master <- NULL
[10:21:24.086]                       while (!identical(envir, .GlobalEnv) && 
[10:21:24.086]                         !identical(envir, emptyenv())) {
[10:21:24.086]                         if (exists("master", mode = "list", envir = envir, 
[10:21:24.086]                           inherits = FALSE)) {
[10:21:24.086]                           master <- get("master", mode = "list", 
[10:21:24.086]                             envir = envir, inherits = FALSE)
[10:21:24.086]                           if (inherits(master, c("SOCKnode", 
[10:21:24.086]                             "SOCK0node"))) {
[10:21:24.086]                             sendCondition <<- function(cond) {
[10:21:24.086]                               data <- list(type = "VALUE", value = cond, 
[10:21:24.086]                                 success = TRUE)
[10:21:24.086]                               parallel_sendData(master, data)
[10:21:24.086]                             }
[10:21:24.086]                             return(sendCondition)
[10:21:24.086]                           }
[10:21:24.086]                         }
[10:21:24.086]                         frame <- frame + 1L
[10:21:24.086]                         envir <- sys.frame(frame)
[10:21:24.086]                       }
[10:21:24.086]                     }
[10:21:24.086]                     sendCondition <<- function(cond) NULL
[10:21:24.086]                   }
[10:21:24.086]                 })
[10:21:24.086]                 withCallingHandlers({
[10:21:24.086]                   2
[10:21:24.086]                 }, immediateCondition = function(cond) {
[10:21:24.086]                   sendCondition <- ...future.makeSendCondition()
[10:21:24.086]                   sendCondition(cond)
[10:21:24.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.086]                   {
[10:21:24.086]                     inherits <- base::inherits
[10:21:24.086]                     invokeRestart <- base::invokeRestart
[10:21:24.086]                     is.null <- base::is.null
[10:21:24.086]                     muffled <- FALSE
[10:21:24.086]                     if (inherits(cond, "message")) {
[10:21:24.086]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:24.086]                       if (muffled) 
[10:21:24.086]                         invokeRestart("muffleMessage")
[10:21:24.086]                     }
[10:21:24.086]                     else if (inherits(cond, "warning")) {
[10:21:24.086]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:24.086]                       if (muffled) 
[10:21:24.086]                         invokeRestart("muffleWarning")
[10:21:24.086]                     }
[10:21:24.086]                     else if (inherits(cond, "condition")) {
[10:21:24.086]                       if (!is.null(pattern)) {
[10:21:24.086]                         computeRestarts <- base::computeRestarts
[10:21:24.086]                         grepl <- base::grepl
[10:21:24.086]                         restarts <- computeRestarts(cond)
[10:21:24.086]                         for (restart in restarts) {
[10:21:24.086]                           name <- restart$name
[10:21:24.086]                           if (is.null(name)) 
[10:21:24.086]                             next
[10:21:24.086]                           if (!grepl(pattern, name)) 
[10:21:24.086]                             next
[10:21:24.086]                           invokeRestart(restart)
[10:21:24.086]                           muffled <- TRUE
[10:21:24.086]                           break
[10:21:24.086]                         }
[10:21:24.086]                       }
[10:21:24.086]                     }
[10:21:24.086]                     invisible(muffled)
[10:21:24.086]                   }
[10:21:24.086]                   muffleCondition(cond)
[10:21:24.086]                 })
[10:21:24.086]             }))
[10:21:24.086]             future::FutureResult(value = ...future.value$value, 
[10:21:24.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.086]                   ...future.rng), globalenv = if (FALSE) 
[10:21:24.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:24.086]                     ...future.globalenv.names))
[10:21:24.086]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:24.086]         }, condition = base::local({
[10:21:24.086]             c <- base::c
[10:21:24.086]             inherits <- base::inherits
[10:21:24.086]             invokeRestart <- base::invokeRestart
[10:21:24.086]             length <- base::length
[10:21:24.086]             list <- base::list
[10:21:24.086]             seq.int <- base::seq.int
[10:21:24.086]             signalCondition <- base::signalCondition
[10:21:24.086]             sys.calls <- base::sys.calls
[10:21:24.086]             `[[` <- base::`[[`
[10:21:24.086]             `+` <- base::`+`
[10:21:24.086]             `<<-` <- base::`<<-`
[10:21:24.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:24.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:24.086]                   3L)]
[10:21:24.086]             }
[10:21:24.086]             function(cond) {
[10:21:24.086]                 is_error <- inherits(cond, "error")
[10:21:24.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:24.086]                   NULL)
[10:21:24.086]                 if (is_error) {
[10:21:24.086]                   sessionInformation <- function() {
[10:21:24.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:24.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:24.086]                       search = base::search(), system = base::Sys.info())
[10:21:24.086]                   }
[10:21:24.086]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:24.086]                     cond$call), session = sessionInformation(), 
[10:21:24.086]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:24.086]                   signalCondition(cond)
[10:21:24.086]                 }
[10:21:24.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:24.086]                 "immediateCondition"))) {
[10:21:24.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:24.086]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:24.086]                   if (TRUE && !signal) {
[10:21:24.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.086]                     {
[10:21:24.086]                       inherits <- base::inherits
[10:21:24.086]                       invokeRestart <- base::invokeRestart
[10:21:24.086]                       is.null <- base::is.null
[10:21:24.086]                       muffled <- FALSE
[10:21:24.086]                       if (inherits(cond, "message")) {
[10:21:24.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.086]                         if (muffled) 
[10:21:24.086]                           invokeRestart("muffleMessage")
[10:21:24.086]                       }
[10:21:24.086]                       else if (inherits(cond, "warning")) {
[10:21:24.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.086]                         if (muffled) 
[10:21:24.086]                           invokeRestart("muffleWarning")
[10:21:24.086]                       }
[10:21:24.086]                       else if (inherits(cond, "condition")) {
[10:21:24.086]                         if (!is.null(pattern)) {
[10:21:24.086]                           computeRestarts <- base::computeRestarts
[10:21:24.086]                           grepl <- base::grepl
[10:21:24.086]                           restarts <- computeRestarts(cond)
[10:21:24.086]                           for (restart in restarts) {
[10:21:24.086]                             name <- restart$name
[10:21:24.086]                             if (is.null(name)) 
[10:21:24.086]                               next
[10:21:24.086]                             if (!grepl(pattern, name)) 
[10:21:24.086]                               next
[10:21:24.086]                             invokeRestart(restart)
[10:21:24.086]                             muffled <- TRUE
[10:21:24.086]                             break
[10:21:24.086]                           }
[10:21:24.086]                         }
[10:21:24.086]                       }
[10:21:24.086]                       invisible(muffled)
[10:21:24.086]                     }
[10:21:24.086]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.086]                   }
[10:21:24.086]                 }
[10:21:24.086]                 else {
[10:21:24.086]                   if (TRUE) {
[10:21:24.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.086]                     {
[10:21:24.086]                       inherits <- base::inherits
[10:21:24.086]                       invokeRestart <- base::invokeRestart
[10:21:24.086]                       is.null <- base::is.null
[10:21:24.086]                       muffled <- FALSE
[10:21:24.086]                       if (inherits(cond, "message")) {
[10:21:24.086]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.086]                         if (muffled) 
[10:21:24.086]                           invokeRestart("muffleMessage")
[10:21:24.086]                       }
[10:21:24.086]                       else if (inherits(cond, "warning")) {
[10:21:24.086]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.086]                         if (muffled) 
[10:21:24.086]                           invokeRestart("muffleWarning")
[10:21:24.086]                       }
[10:21:24.086]                       else if (inherits(cond, "condition")) {
[10:21:24.086]                         if (!is.null(pattern)) {
[10:21:24.086]                           computeRestarts <- base::computeRestarts
[10:21:24.086]                           grepl <- base::grepl
[10:21:24.086]                           restarts <- computeRestarts(cond)
[10:21:24.086]                           for (restart in restarts) {
[10:21:24.086]                             name <- restart$name
[10:21:24.086]                             if (is.null(name)) 
[10:21:24.086]                               next
[10:21:24.086]                             if (!grepl(pattern, name)) 
[10:21:24.086]                               next
[10:21:24.086]                             invokeRestart(restart)
[10:21:24.086]                             muffled <- TRUE
[10:21:24.086]                             break
[10:21:24.086]                           }
[10:21:24.086]                         }
[10:21:24.086]                       }
[10:21:24.086]                       invisible(muffled)
[10:21:24.086]                     }
[10:21:24.086]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.086]                   }
[10:21:24.086]                 }
[10:21:24.086]             }
[10:21:24.086]         }))
[10:21:24.086]     }, error = function(ex) {
[10:21:24.086]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:24.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.086]                 ...future.rng), started = ...future.startTime, 
[10:21:24.086]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:24.086]             version = "1.8"), class = "FutureResult")
[10:21:24.086]     }, finally = {
[10:21:24.086]         if (!identical(...future.workdir, getwd())) 
[10:21:24.086]             setwd(...future.workdir)
[10:21:24.086]         {
[10:21:24.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:24.086]                 ...future.oldOptions$nwarnings <- NULL
[10:21:24.086]             }
[10:21:24.086]             base::options(...future.oldOptions)
[10:21:24.086]             if (.Platform$OS.type == "windows") {
[10:21:24.086]                 old_names <- names(...future.oldEnvVars)
[10:21:24.086]                 envs <- base::Sys.getenv()
[10:21:24.086]                 names <- names(envs)
[10:21:24.086]                 common <- intersect(names, old_names)
[10:21:24.086]                 added <- setdiff(names, old_names)
[10:21:24.086]                 removed <- setdiff(old_names, names)
[10:21:24.086]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:24.086]                   envs[common]]
[10:21:24.086]                 NAMES <- toupper(changed)
[10:21:24.086]                 args <- list()
[10:21:24.086]                 for (kk in seq_along(NAMES)) {
[10:21:24.086]                   name <- changed[[kk]]
[10:21:24.086]                   NAME <- NAMES[[kk]]
[10:21:24.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.086]                     next
[10:21:24.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.086]                 }
[10:21:24.086]                 NAMES <- toupper(added)
[10:21:24.086]                 for (kk in seq_along(NAMES)) {
[10:21:24.086]                   name <- added[[kk]]
[10:21:24.086]                   NAME <- NAMES[[kk]]
[10:21:24.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.086]                     next
[10:21:24.086]                   args[[name]] <- ""
[10:21:24.086]                 }
[10:21:24.086]                 NAMES <- toupper(removed)
[10:21:24.086]                 for (kk in seq_along(NAMES)) {
[10:21:24.086]                   name <- removed[[kk]]
[10:21:24.086]                   NAME <- NAMES[[kk]]
[10:21:24.086]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.086]                     next
[10:21:24.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.086]                 }
[10:21:24.086]                 if (length(args) > 0) 
[10:21:24.086]                   base::do.call(base::Sys.setenv, args = args)
[10:21:24.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:24.086]             }
[10:21:24.086]             else {
[10:21:24.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:24.086]             }
[10:21:24.086]             {
[10:21:24.086]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:24.086]                   0L) {
[10:21:24.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:24.086]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:24.086]                   base::options(opts)
[10:21:24.086]                 }
[10:21:24.086]                 {
[10:21:24.086]                   {
[10:21:24.086]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:24.086]                     NULL
[10:21:24.086]                   }
[10:21:24.086]                   options(future.plan = NULL)
[10:21:24.086]                   if (is.na(NA_character_)) 
[10:21:24.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:24.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:24.086]                     .init = FALSE)
[10:21:24.086]                 }
[10:21:24.086]             }
[10:21:24.086]         }
[10:21:24.086]     })
[10:21:24.086]     if (TRUE) {
[10:21:24.086]         base::sink(type = "output", split = FALSE)
[10:21:24.086]         if (TRUE) {
[10:21:24.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:24.086]         }
[10:21:24.086]         else {
[10:21:24.086]             ...future.result["stdout"] <- base::list(NULL)
[10:21:24.086]         }
[10:21:24.086]         base::close(...future.stdout)
[10:21:24.086]         ...future.stdout <- NULL
[10:21:24.086]     }
[10:21:24.086]     ...future.result$conditions <- ...future.conditions
[10:21:24.086]     ...future.result$finished <- base::Sys.time()
[10:21:24.086]     ...future.result
[10:21:24.086] }
[10:21:24.089] MultisessionFuture started
[10:21:24.089] - Launch lazy future ... done
[10:21:24.089] run() for ‘MultisessionFuture’ ... done
[10:21:24.089] getGlobalsAndPackages() ...
[10:21:24.089] Searching for globals...
[10:21:24.090] 
[10:21:24.090] Searching for globals ... DONE
[10:21:24.090] - globals: [0] <none>
[10:21:24.090] getGlobalsAndPackages() ... DONE
[10:21:24.090] run() for ‘Future’ ...
[10:21:24.090] - state: ‘created’
[10:21:24.090] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:24.113] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:24.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:24.113]   - Field: ‘node’
[10:21:24.113]   - Field: ‘label’
[10:21:24.113]   - Field: ‘local’
[10:21:24.113]   - Field: ‘owner’
[10:21:24.113]   - Field: ‘envir’
[10:21:24.113]   - Field: ‘workers’
[10:21:24.114]   - Field: ‘packages’
[10:21:24.114]   - Field: ‘gc’
[10:21:24.114]   - Field: ‘conditions’
[10:21:24.114]   - Field: ‘persistent’
[10:21:24.114]   - Field: ‘expr’
[10:21:24.114]   - Field: ‘uuid’
[10:21:24.114]   - Field: ‘seed’
[10:21:24.114]   - Field: ‘version’
[10:21:24.114]   - Field: ‘result’
[10:21:24.114]   - Field: ‘asynchronous’
[10:21:24.114]   - Field: ‘calls’
[10:21:24.115]   - Field: ‘globals’
[10:21:24.115]   - Field: ‘stdout’
[10:21:24.115]   - Field: ‘earlySignal’
[10:21:24.115]   - Field: ‘lazy’
[10:21:24.115]   - Field: ‘state’
[10:21:24.115] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:24.115] - Launch lazy future ...
[10:21:24.115] Packages needed by the future expression (n = 0): <none>
[10:21:24.115] Packages needed by future strategies (n = 0): <none>
[10:21:24.116] {
[10:21:24.116]     {
[10:21:24.116]         {
[10:21:24.116]             ...future.startTime <- base::Sys.time()
[10:21:24.116]             {
[10:21:24.116]                 {
[10:21:24.116]                   {
[10:21:24.116]                     {
[10:21:24.116]                       base::local({
[10:21:24.116]                         has_future <- base::requireNamespace("future", 
[10:21:24.116]                           quietly = TRUE)
[10:21:24.116]                         if (has_future) {
[10:21:24.116]                           ns <- base::getNamespace("future")
[10:21:24.116]                           version <- ns[[".package"]][["version"]]
[10:21:24.116]                           if (is.null(version)) 
[10:21:24.116]                             version <- utils::packageVersion("future")
[10:21:24.116]                         }
[10:21:24.116]                         else {
[10:21:24.116]                           version <- NULL
[10:21:24.116]                         }
[10:21:24.116]                         if (!has_future || version < "1.8.0") {
[10:21:24.116]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:24.116]                             "", base::R.version$version.string), 
[10:21:24.116]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:24.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:24.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:24.116]                               "release", "version")], collapse = " "), 
[10:21:24.116]                             hostname = base::Sys.info()[["nodename"]])
[10:21:24.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:24.116]                             info)
[10:21:24.116]                           info <- base::paste(info, collapse = "; ")
[10:21:24.116]                           if (!has_future) {
[10:21:24.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:24.116]                               info)
[10:21:24.116]                           }
[10:21:24.116]                           else {
[10:21:24.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:24.116]                               info, version)
[10:21:24.116]                           }
[10:21:24.116]                           base::stop(msg)
[10:21:24.116]                         }
[10:21:24.116]                       })
[10:21:24.116]                     }
[10:21:24.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:24.116]                     base::options(mc.cores = 1L)
[10:21:24.116]                   }
[10:21:24.116]                   ...future.strategy.old <- future::plan("list")
[10:21:24.116]                   options(future.plan = NULL)
[10:21:24.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:24.116]                 }
[10:21:24.116]                 ...future.workdir <- getwd()
[10:21:24.116]             }
[10:21:24.116]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:24.116]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:24.116]         }
[10:21:24.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:24.116]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:24.116]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:24.116]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:24.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:24.116]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:24.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:24.116]             base::names(...future.oldOptions))
[10:21:24.116]     }
[10:21:24.116]     if (FALSE) {
[10:21:24.116]     }
[10:21:24.116]     else {
[10:21:24.116]         if (TRUE) {
[10:21:24.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:24.116]                 open = "w")
[10:21:24.116]         }
[10:21:24.116]         else {
[10:21:24.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:24.116]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:24.116]         }
[10:21:24.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:24.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:24.116]             base::sink(type = "output", split = FALSE)
[10:21:24.116]             base::close(...future.stdout)
[10:21:24.116]         }, add = TRUE)
[10:21:24.116]     }
[10:21:24.116]     ...future.frame <- base::sys.nframe()
[10:21:24.116]     ...future.conditions <- base::list()
[10:21:24.116]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:24.116]     if (FALSE) {
[10:21:24.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:24.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:24.116]     }
[10:21:24.116]     ...future.result <- base::tryCatch({
[10:21:24.116]         base::withCallingHandlers({
[10:21:24.116]             ...future.value <- base::withVisible(base::local({
[10:21:24.116]                 ...future.makeSendCondition <- base::local({
[10:21:24.116]                   sendCondition <- NULL
[10:21:24.116]                   function(frame = 1L) {
[10:21:24.116]                     if (is.function(sendCondition)) 
[10:21:24.116]                       return(sendCondition)
[10:21:24.116]                     ns <- getNamespace("parallel")
[10:21:24.116]                     if (exists("sendData", mode = "function", 
[10:21:24.116]                       envir = ns)) {
[10:21:24.116]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:24.116]                         envir = ns)
[10:21:24.116]                       envir <- sys.frame(frame)
[10:21:24.116]                       master <- NULL
[10:21:24.116]                       while (!identical(envir, .GlobalEnv) && 
[10:21:24.116]                         !identical(envir, emptyenv())) {
[10:21:24.116]                         if (exists("master", mode = "list", envir = envir, 
[10:21:24.116]                           inherits = FALSE)) {
[10:21:24.116]                           master <- get("master", mode = "list", 
[10:21:24.116]                             envir = envir, inherits = FALSE)
[10:21:24.116]                           if (inherits(master, c("SOCKnode", 
[10:21:24.116]                             "SOCK0node"))) {
[10:21:24.116]                             sendCondition <<- function(cond) {
[10:21:24.116]                               data <- list(type = "VALUE", value = cond, 
[10:21:24.116]                                 success = TRUE)
[10:21:24.116]                               parallel_sendData(master, data)
[10:21:24.116]                             }
[10:21:24.116]                             return(sendCondition)
[10:21:24.116]                           }
[10:21:24.116]                         }
[10:21:24.116]                         frame <- frame + 1L
[10:21:24.116]                         envir <- sys.frame(frame)
[10:21:24.116]                       }
[10:21:24.116]                     }
[10:21:24.116]                     sendCondition <<- function(cond) NULL
[10:21:24.116]                   }
[10:21:24.116]                 })
[10:21:24.116]                 withCallingHandlers({
[10:21:24.116]                   NULL
[10:21:24.116]                 }, immediateCondition = function(cond) {
[10:21:24.116]                   sendCondition <- ...future.makeSendCondition()
[10:21:24.116]                   sendCondition(cond)
[10:21:24.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.116]                   {
[10:21:24.116]                     inherits <- base::inherits
[10:21:24.116]                     invokeRestart <- base::invokeRestart
[10:21:24.116]                     is.null <- base::is.null
[10:21:24.116]                     muffled <- FALSE
[10:21:24.116]                     if (inherits(cond, "message")) {
[10:21:24.116]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:24.116]                       if (muffled) 
[10:21:24.116]                         invokeRestart("muffleMessage")
[10:21:24.116]                     }
[10:21:24.116]                     else if (inherits(cond, "warning")) {
[10:21:24.116]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:24.116]                       if (muffled) 
[10:21:24.116]                         invokeRestart("muffleWarning")
[10:21:24.116]                     }
[10:21:24.116]                     else if (inherits(cond, "condition")) {
[10:21:24.116]                       if (!is.null(pattern)) {
[10:21:24.116]                         computeRestarts <- base::computeRestarts
[10:21:24.116]                         grepl <- base::grepl
[10:21:24.116]                         restarts <- computeRestarts(cond)
[10:21:24.116]                         for (restart in restarts) {
[10:21:24.116]                           name <- restart$name
[10:21:24.116]                           if (is.null(name)) 
[10:21:24.116]                             next
[10:21:24.116]                           if (!grepl(pattern, name)) 
[10:21:24.116]                             next
[10:21:24.116]                           invokeRestart(restart)
[10:21:24.116]                           muffled <- TRUE
[10:21:24.116]                           break
[10:21:24.116]                         }
[10:21:24.116]                       }
[10:21:24.116]                     }
[10:21:24.116]                     invisible(muffled)
[10:21:24.116]                   }
[10:21:24.116]                   muffleCondition(cond)
[10:21:24.116]                 })
[10:21:24.116]             }))
[10:21:24.116]             future::FutureResult(value = ...future.value$value, 
[10:21:24.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.116]                   ...future.rng), globalenv = if (FALSE) 
[10:21:24.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:24.116]                     ...future.globalenv.names))
[10:21:24.116]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:24.116]         }, condition = base::local({
[10:21:24.116]             c <- base::c
[10:21:24.116]             inherits <- base::inherits
[10:21:24.116]             invokeRestart <- base::invokeRestart
[10:21:24.116]             length <- base::length
[10:21:24.116]             list <- base::list
[10:21:24.116]             seq.int <- base::seq.int
[10:21:24.116]             signalCondition <- base::signalCondition
[10:21:24.116]             sys.calls <- base::sys.calls
[10:21:24.116]             `[[` <- base::`[[`
[10:21:24.116]             `+` <- base::`+`
[10:21:24.116]             `<<-` <- base::`<<-`
[10:21:24.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:24.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:24.116]                   3L)]
[10:21:24.116]             }
[10:21:24.116]             function(cond) {
[10:21:24.116]                 is_error <- inherits(cond, "error")
[10:21:24.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:24.116]                   NULL)
[10:21:24.116]                 if (is_error) {
[10:21:24.116]                   sessionInformation <- function() {
[10:21:24.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:24.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:24.116]                       search = base::search(), system = base::Sys.info())
[10:21:24.116]                   }
[10:21:24.116]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:24.116]                     cond$call), session = sessionInformation(), 
[10:21:24.116]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:24.116]                   signalCondition(cond)
[10:21:24.116]                 }
[10:21:24.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:24.116]                 "immediateCondition"))) {
[10:21:24.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:24.116]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:24.116]                   if (TRUE && !signal) {
[10:21:24.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.116]                     {
[10:21:24.116]                       inherits <- base::inherits
[10:21:24.116]                       invokeRestart <- base::invokeRestart
[10:21:24.116]                       is.null <- base::is.null
[10:21:24.116]                       muffled <- FALSE
[10:21:24.116]                       if (inherits(cond, "message")) {
[10:21:24.116]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.116]                         if (muffled) 
[10:21:24.116]                           invokeRestart("muffleMessage")
[10:21:24.116]                       }
[10:21:24.116]                       else if (inherits(cond, "warning")) {
[10:21:24.116]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.116]                         if (muffled) 
[10:21:24.116]                           invokeRestart("muffleWarning")
[10:21:24.116]                       }
[10:21:24.116]                       else if (inherits(cond, "condition")) {
[10:21:24.116]                         if (!is.null(pattern)) {
[10:21:24.116]                           computeRestarts <- base::computeRestarts
[10:21:24.116]                           grepl <- base::grepl
[10:21:24.116]                           restarts <- computeRestarts(cond)
[10:21:24.116]                           for (restart in restarts) {
[10:21:24.116]                             name <- restart$name
[10:21:24.116]                             if (is.null(name)) 
[10:21:24.116]                               next
[10:21:24.116]                             if (!grepl(pattern, name)) 
[10:21:24.116]                               next
[10:21:24.116]                             invokeRestart(restart)
[10:21:24.116]                             muffled <- TRUE
[10:21:24.116]                             break
[10:21:24.116]                           }
[10:21:24.116]                         }
[10:21:24.116]                       }
[10:21:24.116]                       invisible(muffled)
[10:21:24.116]                     }
[10:21:24.116]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.116]                   }
[10:21:24.116]                 }
[10:21:24.116]                 else {
[10:21:24.116]                   if (TRUE) {
[10:21:24.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.116]                     {
[10:21:24.116]                       inherits <- base::inherits
[10:21:24.116]                       invokeRestart <- base::invokeRestart
[10:21:24.116]                       is.null <- base::is.null
[10:21:24.116]                       muffled <- FALSE
[10:21:24.116]                       if (inherits(cond, "message")) {
[10:21:24.116]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.116]                         if (muffled) 
[10:21:24.116]                           invokeRestart("muffleMessage")
[10:21:24.116]                       }
[10:21:24.116]                       else if (inherits(cond, "warning")) {
[10:21:24.116]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.116]                         if (muffled) 
[10:21:24.116]                           invokeRestart("muffleWarning")
[10:21:24.116]                       }
[10:21:24.116]                       else if (inherits(cond, "condition")) {
[10:21:24.116]                         if (!is.null(pattern)) {
[10:21:24.116]                           computeRestarts <- base::computeRestarts
[10:21:24.116]                           grepl <- base::grepl
[10:21:24.116]                           restarts <- computeRestarts(cond)
[10:21:24.116]                           for (restart in restarts) {
[10:21:24.116]                             name <- restart$name
[10:21:24.116]                             if (is.null(name)) 
[10:21:24.116]                               next
[10:21:24.116]                             if (!grepl(pattern, name)) 
[10:21:24.116]                               next
[10:21:24.116]                             invokeRestart(restart)
[10:21:24.116]                             muffled <- TRUE
[10:21:24.116]                             break
[10:21:24.116]                           }
[10:21:24.116]                         }
[10:21:24.116]                       }
[10:21:24.116]                       invisible(muffled)
[10:21:24.116]                     }
[10:21:24.116]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.116]                   }
[10:21:24.116]                 }
[10:21:24.116]             }
[10:21:24.116]         }))
[10:21:24.116]     }, error = function(ex) {
[10:21:24.116]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:24.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.116]                 ...future.rng), started = ...future.startTime, 
[10:21:24.116]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:24.116]             version = "1.8"), class = "FutureResult")
[10:21:24.116]     }, finally = {
[10:21:24.116]         if (!identical(...future.workdir, getwd())) 
[10:21:24.116]             setwd(...future.workdir)
[10:21:24.116]         {
[10:21:24.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:24.116]                 ...future.oldOptions$nwarnings <- NULL
[10:21:24.116]             }
[10:21:24.116]             base::options(...future.oldOptions)
[10:21:24.116]             if (.Platform$OS.type == "windows") {
[10:21:24.116]                 old_names <- names(...future.oldEnvVars)
[10:21:24.116]                 envs <- base::Sys.getenv()
[10:21:24.116]                 names <- names(envs)
[10:21:24.116]                 common <- intersect(names, old_names)
[10:21:24.116]                 added <- setdiff(names, old_names)
[10:21:24.116]                 removed <- setdiff(old_names, names)
[10:21:24.116]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:24.116]                   envs[common]]
[10:21:24.116]                 NAMES <- toupper(changed)
[10:21:24.116]                 args <- list()
[10:21:24.116]                 for (kk in seq_along(NAMES)) {
[10:21:24.116]                   name <- changed[[kk]]
[10:21:24.116]                   NAME <- NAMES[[kk]]
[10:21:24.116]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.116]                     next
[10:21:24.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.116]                 }
[10:21:24.116]                 NAMES <- toupper(added)
[10:21:24.116]                 for (kk in seq_along(NAMES)) {
[10:21:24.116]                   name <- added[[kk]]
[10:21:24.116]                   NAME <- NAMES[[kk]]
[10:21:24.116]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.116]                     next
[10:21:24.116]                   args[[name]] <- ""
[10:21:24.116]                 }
[10:21:24.116]                 NAMES <- toupper(removed)
[10:21:24.116]                 for (kk in seq_along(NAMES)) {
[10:21:24.116]                   name <- removed[[kk]]
[10:21:24.116]                   NAME <- NAMES[[kk]]
[10:21:24.116]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.116]                     next
[10:21:24.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.116]                 }
[10:21:24.116]                 if (length(args) > 0) 
[10:21:24.116]                   base::do.call(base::Sys.setenv, args = args)
[10:21:24.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:24.116]             }
[10:21:24.116]             else {
[10:21:24.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:24.116]             }
[10:21:24.116]             {
[10:21:24.116]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:24.116]                   0L) {
[10:21:24.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:24.116]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:24.116]                   base::options(opts)
[10:21:24.116]                 }
[10:21:24.116]                 {
[10:21:24.116]                   {
[10:21:24.116]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:24.116]                     NULL
[10:21:24.116]                   }
[10:21:24.116]                   options(future.plan = NULL)
[10:21:24.116]                   if (is.na(NA_character_)) 
[10:21:24.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:24.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:24.116]                     .init = FALSE)
[10:21:24.116]                 }
[10:21:24.116]             }
[10:21:24.116]         }
[10:21:24.116]     })
[10:21:24.116]     if (TRUE) {
[10:21:24.116]         base::sink(type = "output", split = FALSE)
[10:21:24.116]         if (TRUE) {
[10:21:24.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:24.116]         }
[10:21:24.116]         else {
[10:21:24.116]             ...future.result["stdout"] <- base::list(NULL)
[10:21:24.116]         }
[10:21:24.116]         base::close(...future.stdout)
[10:21:24.116]         ...future.stdout <- NULL
[10:21:24.116]     }
[10:21:24.116]     ...future.result$conditions <- ...future.conditions
[10:21:24.116]     ...future.result$finished <- base::Sys.time()
[10:21:24.116]     ...future.result
[10:21:24.116] }
[10:21:24.119] MultisessionFuture started
[10:21:24.119] - Launch lazy future ... done
[10:21:24.119] run() for ‘MultisessionFuture’ ... done
[10:21:24.120] getGlobalsAndPackages() ...
[10:21:24.120] Searching for globals...
[10:21:24.121] - globals found: [1] ‘{’
[10:21:24.121] Searching for globals ... DONE
[10:21:24.121] Resolving globals: FALSE
[10:21:24.121] 
[10:21:24.122] 
[10:21:24.122] getGlobalsAndPackages() ... DONE
[10:21:24.122] run() for ‘Future’ ...
[10:21:24.122] - state: ‘created’
[10:21:24.122] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:24.137] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:24.137] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:24.137]   - Field: ‘node’
[10:21:24.137]   - Field: ‘label’
[10:21:24.137]   - Field: ‘local’
[10:21:24.137]   - Field: ‘owner’
[10:21:24.137]   - Field: ‘envir’
[10:21:24.137]   - Field: ‘workers’
[10:21:24.137]   - Field: ‘packages’
[10:21:24.137]   - Field: ‘gc’
[10:21:24.138]   - Field: ‘conditions’
[10:21:24.138]   - Field: ‘persistent’
[10:21:24.138]   - Field: ‘expr’
[10:21:24.138]   - Field: ‘uuid’
[10:21:24.138]   - Field: ‘seed’
[10:21:24.138]   - Field: ‘version’
[10:21:24.138]   - Field: ‘result’
[10:21:24.138]   - Field: ‘asynchronous’
[10:21:24.138]   - Field: ‘calls’
[10:21:24.138]   - Field: ‘globals’
[10:21:24.138]   - Field: ‘stdout’
[10:21:24.138]   - Field: ‘earlySignal’
[10:21:24.139]   - Field: ‘lazy’
[10:21:24.139]   - Field: ‘state’
[10:21:24.139] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:24.139] - Launch lazy future ...
[10:21:24.139] Packages needed by the future expression (n = 0): <none>
[10:21:24.139] Packages needed by future strategies (n = 0): <none>
[10:21:24.140] {
[10:21:24.140]     {
[10:21:24.140]         {
[10:21:24.140]             ...future.startTime <- base::Sys.time()
[10:21:24.140]             {
[10:21:24.140]                 {
[10:21:24.140]                   {
[10:21:24.140]                     {
[10:21:24.140]                       base::local({
[10:21:24.140]                         has_future <- base::requireNamespace("future", 
[10:21:24.140]                           quietly = TRUE)
[10:21:24.140]                         if (has_future) {
[10:21:24.140]                           ns <- base::getNamespace("future")
[10:21:24.140]                           version <- ns[[".package"]][["version"]]
[10:21:24.140]                           if (is.null(version)) 
[10:21:24.140]                             version <- utils::packageVersion("future")
[10:21:24.140]                         }
[10:21:24.140]                         else {
[10:21:24.140]                           version <- NULL
[10:21:24.140]                         }
[10:21:24.140]                         if (!has_future || version < "1.8.0") {
[10:21:24.140]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:24.140]                             "", base::R.version$version.string), 
[10:21:24.140]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:24.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:24.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:24.140]                               "release", "version")], collapse = " "), 
[10:21:24.140]                             hostname = base::Sys.info()[["nodename"]])
[10:21:24.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:24.140]                             info)
[10:21:24.140]                           info <- base::paste(info, collapse = "; ")
[10:21:24.140]                           if (!has_future) {
[10:21:24.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:24.140]                               info)
[10:21:24.140]                           }
[10:21:24.140]                           else {
[10:21:24.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:24.140]                               info, version)
[10:21:24.140]                           }
[10:21:24.140]                           base::stop(msg)
[10:21:24.140]                         }
[10:21:24.140]                       })
[10:21:24.140]                     }
[10:21:24.140]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:24.140]                     base::options(mc.cores = 1L)
[10:21:24.140]                   }
[10:21:24.140]                   ...future.strategy.old <- future::plan("list")
[10:21:24.140]                   options(future.plan = NULL)
[10:21:24.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:24.140]                 }
[10:21:24.140]                 ...future.workdir <- getwd()
[10:21:24.140]             }
[10:21:24.140]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:24.140]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:24.140]         }
[10:21:24.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:24.140]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:24.140]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:24.140]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:24.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:24.140]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:24.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:24.140]             base::names(...future.oldOptions))
[10:21:24.140]     }
[10:21:24.140]     if (FALSE) {
[10:21:24.140]     }
[10:21:24.140]     else {
[10:21:24.140]         if (TRUE) {
[10:21:24.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:24.140]                 open = "w")
[10:21:24.140]         }
[10:21:24.140]         else {
[10:21:24.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:24.140]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:24.140]         }
[10:21:24.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:24.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:24.140]             base::sink(type = "output", split = FALSE)
[10:21:24.140]             base::close(...future.stdout)
[10:21:24.140]         }, add = TRUE)
[10:21:24.140]     }
[10:21:24.140]     ...future.frame <- base::sys.nframe()
[10:21:24.140]     ...future.conditions <- base::list()
[10:21:24.140]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:24.140]     if (FALSE) {
[10:21:24.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:24.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:24.140]     }
[10:21:24.140]     ...future.result <- base::tryCatch({
[10:21:24.140]         base::withCallingHandlers({
[10:21:24.140]             ...future.value <- base::withVisible(base::local({
[10:21:24.140]                 ...future.makeSendCondition <- base::local({
[10:21:24.140]                   sendCondition <- NULL
[10:21:24.140]                   function(frame = 1L) {
[10:21:24.140]                     if (is.function(sendCondition)) 
[10:21:24.140]                       return(sendCondition)
[10:21:24.140]                     ns <- getNamespace("parallel")
[10:21:24.140]                     if (exists("sendData", mode = "function", 
[10:21:24.140]                       envir = ns)) {
[10:21:24.140]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:24.140]                         envir = ns)
[10:21:24.140]                       envir <- sys.frame(frame)
[10:21:24.140]                       master <- NULL
[10:21:24.140]                       while (!identical(envir, .GlobalEnv) && 
[10:21:24.140]                         !identical(envir, emptyenv())) {
[10:21:24.140]                         if (exists("master", mode = "list", envir = envir, 
[10:21:24.140]                           inherits = FALSE)) {
[10:21:24.140]                           master <- get("master", mode = "list", 
[10:21:24.140]                             envir = envir, inherits = FALSE)
[10:21:24.140]                           if (inherits(master, c("SOCKnode", 
[10:21:24.140]                             "SOCK0node"))) {
[10:21:24.140]                             sendCondition <<- function(cond) {
[10:21:24.140]                               data <- list(type = "VALUE", value = cond, 
[10:21:24.140]                                 success = TRUE)
[10:21:24.140]                               parallel_sendData(master, data)
[10:21:24.140]                             }
[10:21:24.140]                             return(sendCondition)
[10:21:24.140]                           }
[10:21:24.140]                         }
[10:21:24.140]                         frame <- frame + 1L
[10:21:24.140]                         envir <- sys.frame(frame)
[10:21:24.140]                       }
[10:21:24.140]                     }
[10:21:24.140]                     sendCondition <<- function(cond) NULL
[10:21:24.140]                   }
[10:21:24.140]                 })
[10:21:24.140]                 withCallingHandlers({
[10:21:24.140]                   {
[10:21:24.140]                     4
[10:21:24.140]                   }
[10:21:24.140]                 }, immediateCondition = function(cond) {
[10:21:24.140]                   sendCondition <- ...future.makeSendCondition()
[10:21:24.140]                   sendCondition(cond)
[10:21:24.140]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.140]                   {
[10:21:24.140]                     inherits <- base::inherits
[10:21:24.140]                     invokeRestart <- base::invokeRestart
[10:21:24.140]                     is.null <- base::is.null
[10:21:24.140]                     muffled <- FALSE
[10:21:24.140]                     if (inherits(cond, "message")) {
[10:21:24.140]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:24.140]                       if (muffled) 
[10:21:24.140]                         invokeRestart("muffleMessage")
[10:21:24.140]                     }
[10:21:24.140]                     else if (inherits(cond, "warning")) {
[10:21:24.140]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:24.140]                       if (muffled) 
[10:21:24.140]                         invokeRestart("muffleWarning")
[10:21:24.140]                     }
[10:21:24.140]                     else if (inherits(cond, "condition")) {
[10:21:24.140]                       if (!is.null(pattern)) {
[10:21:24.140]                         computeRestarts <- base::computeRestarts
[10:21:24.140]                         grepl <- base::grepl
[10:21:24.140]                         restarts <- computeRestarts(cond)
[10:21:24.140]                         for (restart in restarts) {
[10:21:24.140]                           name <- restart$name
[10:21:24.140]                           if (is.null(name)) 
[10:21:24.140]                             next
[10:21:24.140]                           if (!grepl(pattern, name)) 
[10:21:24.140]                             next
[10:21:24.140]                           invokeRestart(restart)
[10:21:24.140]                           muffled <- TRUE
[10:21:24.140]                           break
[10:21:24.140]                         }
[10:21:24.140]                       }
[10:21:24.140]                     }
[10:21:24.140]                     invisible(muffled)
[10:21:24.140]                   }
[10:21:24.140]                   muffleCondition(cond)
[10:21:24.140]                 })
[10:21:24.140]             }))
[10:21:24.140]             future::FutureResult(value = ...future.value$value, 
[10:21:24.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.140]                   ...future.rng), globalenv = if (FALSE) 
[10:21:24.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:24.140]                     ...future.globalenv.names))
[10:21:24.140]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:24.140]         }, condition = base::local({
[10:21:24.140]             c <- base::c
[10:21:24.140]             inherits <- base::inherits
[10:21:24.140]             invokeRestart <- base::invokeRestart
[10:21:24.140]             length <- base::length
[10:21:24.140]             list <- base::list
[10:21:24.140]             seq.int <- base::seq.int
[10:21:24.140]             signalCondition <- base::signalCondition
[10:21:24.140]             sys.calls <- base::sys.calls
[10:21:24.140]             `[[` <- base::`[[`
[10:21:24.140]             `+` <- base::`+`
[10:21:24.140]             `<<-` <- base::`<<-`
[10:21:24.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:24.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:24.140]                   3L)]
[10:21:24.140]             }
[10:21:24.140]             function(cond) {
[10:21:24.140]                 is_error <- inherits(cond, "error")
[10:21:24.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:24.140]                   NULL)
[10:21:24.140]                 if (is_error) {
[10:21:24.140]                   sessionInformation <- function() {
[10:21:24.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:24.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:24.140]                       search = base::search(), system = base::Sys.info())
[10:21:24.140]                   }
[10:21:24.140]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:24.140]                     cond$call), session = sessionInformation(), 
[10:21:24.140]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:24.140]                   signalCondition(cond)
[10:21:24.140]                 }
[10:21:24.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:24.140]                 "immediateCondition"))) {
[10:21:24.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:24.140]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:24.140]                   if (TRUE && !signal) {
[10:21:24.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.140]                     {
[10:21:24.140]                       inherits <- base::inherits
[10:21:24.140]                       invokeRestart <- base::invokeRestart
[10:21:24.140]                       is.null <- base::is.null
[10:21:24.140]                       muffled <- FALSE
[10:21:24.140]                       if (inherits(cond, "message")) {
[10:21:24.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.140]                         if (muffled) 
[10:21:24.140]                           invokeRestart("muffleMessage")
[10:21:24.140]                       }
[10:21:24.140]                       else if (inherits(cond, "warning")) {
[10:21:24.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.140]                         if (muffled) 
[10:21:24.140]                           invokeRestart("muffleWarning")
[10:21:24.140]                       }
[10:21:24.140]                       else if (inherits(cond, "condition")) {
[10:21:24.140]                         if (!is.null(pattern)) {
[10:21:24.140]                           computeRestarts <- base::computeRestarts
[10:21:24.140]                           grepl <- base::grepl
[10:21:24.140]                           restarts <- computeRestarts(cond)
[10:21:24.140]                           for (restart in restarts) {
[10:21:24.140]                             name <- restart$name
[10:21:24.140]                             if (is.null(name)) 
[10:21:24.140]                               next
[10:21:24.140]                             if (!grepl(pattern, name)) 
[10:21:24.140]                               next
[10:21:24.140]                             invokeRestart(restart)
[10:21:24.140]                             muffled <- TRUE
[10:21:24.140]                             break
[10:21:24.140]                           }
[10:21:24.140]                         }
[10:21:24.140]                       }
[10:21:24.140]                       invisible(muffled)
[10:21:24.140]                     }
[10:21:24.140]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.140]                   }
[10:21:24.140]                 }
[10:21:24.140]                 else {
[10:21:24.140]                   if (TRUE) {
[10:21:24.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.140]                     {
[10:21:24.140]                       inherits <- base::inherits
[10:21:24.140]                       invokeRestart <- base::invokeRestart
[10:21:24.140]                       is.null <- base::is.null
[10:21:24.140]                       muffled <- FALSE
[10:21:24.140]                       if (inherits(cond, "message")) {
[10:21:24.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.140]                         if (muffled) 
[10:21:24.140]                           invokeRestart("muffleMessage")
[10:21:24.140]                       }
[10:21:24.140]                       else if (inherits(cond, "warning")) {
[10:21:24.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.140]                         if (muffled) 
[10:21:24.140]                           invokeRestart("muffleWarning")
[10:21:24.140]                       }
[10:21:24.140]                       else if (inherits(cond, "condition")) {
[10:21:24.140]                         if (!is.null(pattern)) {
[10:21:24.140]                           computeRestarts <- base::computeRestarts
[10:21:24.140]                           grepl <- base::grepl
[10:21:24.140]                           restarts <- computeRestarts(cond)
[10:21:24.140]                           for (restart in restarts) {
[10:21:24.140]                             name <- restart$name
[10:21:24.140]                             if (is.null(name)) 
[10:21:24.140]                               next
[10:21:24.140]                             if (!grepl(pattern, name)) 
[10:21:24.140]                               next
[10:21:24.140]                             invokeRestart(restart)
[10:21:24.140]                             muffled <- TRUE
[10:21:24.140]                             break
[10:21:24.140]                           }
[10:21:24.140]                         }
[10:21:24.140]                       }
[10:21:24.140]                       invisible(muffled)
[10:21:24.140]                     }
[10:21:24.140]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.140]                   }
[10:21:24.140]                 }
[10:21:24.140]             }
[10:21:24.140]         }))
[10:21:24.140]     }, error = function(ex) {
[10:21:24.140]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:24.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.140]                 ...future.rng), started = ...future.startTime, 
[10:21:24.140]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:24.140]             version = "1.8"), class = "FutureResult")
[10:21:24.140]     }, finally = {
[10:21:24.140]         if (!identical(...future.workdir, getwd())) 
[10:21:24.140]             setwd(...future.workdir)
[10:21:24.140]         {
[10:21:24.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:24.140]                 ...future.oldOptions$nwarnings <- NULL
[10:21:24.140]             }
[10:21:24.140]             base::options(...future.oldOptions)
[10:21:24.140]             if (.Platform$OS.type == "windows") {
[10:21:24.140]                 old_names <- names(...future.oldEnvVars)
[10:21:24.140]                 envs <- base::Sys.getenv()
[10:21:24.140]                 names <- names(envs)
[10:21:24.140]                 common <- intersect(names, old_names)
[10:21:24.140]                 added <- setdiff(names, old_names)
[10:21:24.140]                 removed <- setdiff(old_names, names)
[10:21:24.140]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:24.140]                   envs[common]]
[10:21:24.140]                 NAMES <- toupper(changed)
[10:21:24.140]                 args <- list()
[10:21:24.140]                 for (kk in seq_along(NAMES)) {
[10:21:24.140]                   name <- changed[[kk]]
[10:21:24.140]                   NAME <- NAMES[[kk]]
[10:21:24.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.140]                     next
[10:21:24.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.140]                 }
[10:21:24.140]                 NAMES <- toupper(added)
[10:21:24.140]                 for (kk in seq_along(NAMES)) {
[10:21:24.140]                   name <- added[[kk]]
[10:21:24.140]                   NAME <- NAMES[[kk]]
[10:21:24.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.140]                     next
[10:21:24.140]                   args[[name]] <- ""
[10:21:24.140]                 }
[10:21:24.140]                 NAMES <- toupper(removed)
[10:21:24.140]                 for (kk in seq_along(NAMES)) {
[10:21:24.140]                   name <- removed[[kk]]
[10:21:24.140]                   NAME <- NAMES[[kk]]
[10:21:24.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.140]                     next
[10:21:24.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.140]                 }
[10:21:24.140]                 if (length(args) > 0) 
[10:21:24.140]                   base::do.call(base::Sys.setenv, args = args)
[10:21:24.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:24.140]             }
[10:21:24.140]             else {
[10:21:24.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:24.140]             }
[10:21:24.140]             {
[10:21:24.140]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:24.140]                   0L) {
[10:21:24.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:24.140]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:24.140]                   base::options(opts)
[10:21:24.140]                 }
[10:21:24.140]                 {
[10:21:24.140]                   {
[10:21:24.140]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:24.140]                     NULL
[10:21:24.140]                   }
[10:21:24.140]                   options(future.plan = NULL)
[10:21:24.140]                   if (is.na(NA_character_)) 
[10:21:24.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:24.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:24.140]                     .init = FALSE)
[10:21:24.140]                 }
[10:21:24.140]             }
[10:21:24.140]         }
[10:21:24.140]     })
[10:21:24.140]     if (TRUE) {
[10:21:24.140]         base::sink(type = "output", split = FALSE)
[10:21:24.140]         if (TRUE) {
[10:21:24.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:24.140]         }
[10:21:24.140]         else {
[10:21:24.140]             ...future.result["stdout"] <- base::list(NULL)
[10:21:24.140]         }
[10:21:24.140]         base::close(...future.stdout)
[10:21:24.140]         ...future.stdout <- NULL
[10:21:24.140]     }
[10:21:24.140]     ...future.result$conditions <- ...future.conditions
[10:21:24.140]     ...future.result$finished <- base::Sys.time()
[10:21:24.140]     ...future.result
[10:21:24.140] }
[10:21:24.142] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:24.152] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.153] - Validating connection of MultisessionFuture
[10:21:24.153] - received message: FutureResult
[10:21:24.153] - Received FutureResult
[10:21:24.153] - Erased future from FutureRegistry
[10:21:24.153] result() for ClusterFuture ...
[10:21:24.153] - result already collected: FutureResult
[10:21:24.153] result() for ClusterFuture ... done
[10:21:24.153] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:24.154] result() for ClusterFuture ...
[10:21:24.154] - result already collected: FutureResult
[10:21:24.154] result() for ClusterFuture ... done
[10:21:24.154] result() for ClusterFuture ...
[10:21:24.154] - result already collected: FutureResult
[10:21:24.154] result() for ClusterFuture ... done
[10:21:24.155] MultisessionFuture started
[10:21:24.155] - Launch lazy future ... done
[10:21:24.155] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e6fe09e8> 
Classes 'listenv', 'environment' <environment: 0x55e8e4a780a0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[10:21:24.161] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.161] - Validating connection of MultisessionFuture
[10:21:24.161] - received message: FutureResult
[10:21:24.161] - Received FutureResult
[10:21:24.161] - Erased future from FutureRegistry
[10:21:24.161] result() for ClusterFuture ...
[10:21:24.162] - result already collected: FutureResult
[10:21:24.162] result() for ClusterFuture ... done
[10:21:24.162] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:24.175] resolve() on list environment ...
[10:21:24.175]  recursive: 0
[10:21:24.176]  length: 6
[10:21:24.176]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:24.176] signalConditionsASAP(numeric, pos=1) ...
[10:21:24.176] - nx: 6
[10:21:24.176] - relay: TRUE
[10:21:24.176] - stdout: TRUE
[10:21:24.176] - signal: TRUE
[10:21:24.176] - resignal: FALSE
[10:21:24.176] - force: TRUE
[10:21:24.176] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.177] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.177]  - until=2
[10:21:24.177]  - relaying element #2
[10:21:24.177] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.177] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.177] signalConditionsASAP(NULL, pos=1) ... done
[10:21:24.177]  length: 5 (resolved future 1)
[10:21:24.177] Future #2
[10:21:24.177] result() for ClusterFuture ...
[10:21:24.177] - result already collected: FutureResult
[10:21:24.177] result() for ClusterFuture ... done
[10:21:24.178] result() for ClusterFuture ...
[10:21:24.178] - result already collected: FutureResult
[10:21:24.178] result() for ClusterFuture ... done
[10:21:24.178] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:24.178] - nx: 6
[10:21:24.178] - relay: TRUE
[10:21:24.178] - stdout: TRUE
[10:21:24.178] - signal: TRUE
[10:21:24.178] - resignal: FALSE
[10:21:24.178] - force: TRUE
[10:21:24.178] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.178] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.178]  - until=2
[10:21:24.179]  - relaying element #2
[10:21:24.179] result() for ClusterFuture ...
[10:21:24.179] - result already collected: FutureResult
[10:21:24.179] result() for ClusterFuture ... done
[10:21:24.179] result() for ClusterFuture ...
[10:21:24.179] - result already collected: FutureResult
[10:21:24.179] result() for ClusterFuture ... done
[10:21:24.179] result() for ClusterFuture ...
[10:21:24.179] - result already collected: FutureResult
[10:21:24.179] result() for ClusterFuture ... done
[10:21:24.179] result() for ClusterFuture ...
[10:21:24.180] - result already collected: FutureResult
[10:21:24.180] result() for ClusterFuture ... done
[10:21:24.180] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.180] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.180] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:24.180]  length: 4 (resolved future 2)
[10:21:24.180] Future #3
[10:21:24.180] result() for ClusterFuture ...
[10:21:24.180] - result already collected: FutureResult
[10:21:24.180] result() for ClusterFuture ... done
[10:21:24.180] result() for ClusterFuture ...
[10:21:24.181] - result already collected: FutureResult
[10:21:24.181] result() for ClusterFuture ... done
[10:21:24.181] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:24.181] - nx: 6
[10:21:24.181] - relay: TRUE
[10:21:24.181] - stdout: TRUE
[10:21:24.181] - signal: TRUE
[10:21:24.181] - resignal: FALSE
[10:21:24.181] - force: TRUE
[10:21:24.181] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.181] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.181]  - until=3
[10:21:24.181]  - relaying element #3
[10:21:24.182] result() for ClusterFuture ...
[10:21:24.182] - result already collected: FutureResult
[10:21:24.182] result() for ClusterFuture ... done
[10:21:24.182] result() for ClusterFuture ...
[10:21:24.182] - result already collected: FutureResult
[10:21:24.182] result() for ClusterFuture ... done
[10:21:24.182] result() for ClusterFuture ...
[10:21:24.182] - result already collected: FutureResult
[10:21:24.182] result() for ClusterFuture ... done
[10:21:24.182] result() for ClusterFuture ...
[10:21:24.182] - result already collected: FutureResult
[10:21:24.182] result() for ClusterFuture ... done
[10:21:24.183] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.183] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.183] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:24.183]  length: 3 (resolved future 3)
[10:21:24.193] signalConditionsASAP(NULL, pos=5) ...
[10:21:24.194] - nx: 6
[10:21:24.194] - relay: TRUE
[10:21:24.194] - stdout: TRUE
[10:21:24.194] - signal: TRUE
[10:21:24.194] - resignal: FALSE
[10:21:24.194] - force: TRUE
[10:21:24.194] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.194] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.194]  - until=6
[10:21:24.194]  - relaying element #4
[10:21:24.194]  - relaying element #6
[10:21:24.195] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:24.195] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.195] signalConditionsASAP(NULL, pos=5) ... done
[10:21:24.195]  length: 2 (resolved future 5)
[10:21:24.195] signalConditionsASAP(numeric, pos=6) ...
[10:21:24.195] - nx: 6
[10:21:24.195] - relay: TRUE
[10:21:24.195] - stdout: TRUE
[10:21:24.195] - signal: TRUE
[10:21:24.195] - resignal: FALSE
[10:21:24.195] - force: TRUE
[10:21:24.196] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:24.196] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.196]  - until=6
[10:21:24.196]  - relaying element #4
[10:21:24.196] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:24.196] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.196] signalConditionsASAP(NULL, pos=6) ... done
[10:21:24.196]  length: 1 (resolved future 6)
[10:21:24.207] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.207] - Validating connection of MultisessionFuture
[10:21:24.207] - received message: FutureResult
[10:21:24.207] - Received FutureResult
[10:21:24.207] - Erased future from FutureRegistry
[10:21:24.208] result() for ClusterFuture ...
[10:21:24.208] - result already collected: FutureResult
[10:21:24.208] result() for ClusterFuture ... done
[10:21:24.208] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:24.208] Future #4
[10:21:24.208] result() for ClusterFuture ...
[10:21:24.208] - result already collected: FutureResult
[10:21:24.208] result() for ClusterFuture ... done
[10:21:24.208] result() for ClusterFuture ...
[10:21:24.208] - result already collected: FutureResult
[10:21:24.208] result() for ClusterFuture ... done
[10:21:24.208] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:24.209] - nx: 6
[10:21:24.209] - relay: TRUE
[10:21:24.209] - stdout: TRUE
[10:21:24.209] - signal: TRUE
[10:21:24.209] - resignal: FALSE
[10:21:24.209] - force: TRUE
[10:21:24.209] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:24.209] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.209]  - until=6
[10:21:24.209]  - relaying element #4
[10:21:24.209] result() for ClusterFuture ...
[10:21:24.209] - result already collected: FutureResult
[10:21:24.209] result() for ClusterFuture ... done
[10:21:24.210] result() for ClusterFuture ...
[10:21:24.210] - result already collected: FutureResult
[10:21:24.210] result() for ClusterFuture ... done
[10:21:24.210] result() for ClusterFuture ...
[10:21:24.210] - result already collected: FutureResult
[10:21:24.210] result() for ClusterFuture ... done
[10:21:24.210] result() for ClusterFuture ...
[10:21:24.210] - result already collected: FutureResult
[10:21:24.210] result() for ClusterFuture ... done
[10:21:24.210] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.210] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:24.211] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:24.211]  length: 0 (resolved future 4)
[10:21:24.211] Relaying remaining futures
[10:21:24.211] signalConditionsASAP(NULL, pos=0) ...
[10:21:24.211] - nx: 6
[10:21:24.211] - relay: TRUE
[10:21:24.211] - stdout: TRUE
[10:21:24.211] - signal: TRUE
[10:21:24.211] - resignal: FALSE
[10:21:24.211] - force: TRUE
[10:21:24.211] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.211] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:24.212] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.212] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:24.212] signalConditionsASAP(NULL, pos=0) ... done
[10:21:24.212] resolve() on list environment ... DONE
[10:21:24.212] result() for ClusterFuture ...
[10:21:24.212] - result already collected: FutureResult
[10:21:24.212] result() for ClusterFuture ... done
[10:21:24.212] result() for ClusterFuture ...
[10:21:24.212] - result already collected: FutureResult
[10:21:24.212] result() for ClusterFuture ... done
[10:21:24.212] result() for ClusterFuture ...
[10:21:24.213] - result already collected: FutureResult
[10:21:24.213] result() for ClusterFuture ... done
[10:21:24.213] result() for ClusterFuture ...
[10:21:24.213] - result already collected: FutureResult
[10:21:24.213] result() for ClusterFuture ... done
[10:21:24.213] result() for ClusterFuture ...
[10:21:24.213] - result already collected: FutureResult
[10:21:24.213] result() for ClusterFuture ... done
[10:21:24.213] result() for ClusterFuture ...
[10:21:24.213] - result already collected: FutureResult
[10:21:24.213] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e3675448> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[10:21:24.215] getGlobalsAndPackages() ...
[10:21:24.215] Searching for globals...
[10:21:24.215] 
[10:21:24.216] Searching for globals ... DONE
[10:21:24.216] - globals: [0] <none>
[10:21:24.216] getGlobalsAndPackages() ... DONE
[10:21:24.216] run() for ‘Future’ ...
[10:21:24.216] - state: ‘created’
[10:21:24.216] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:24.230] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:24.230] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:24.230]   - Field: ‘node’
[10:21:24.230]   - Field: ‘label’
[10:21:24.231]   - Field: ‘local’
[10:21:24.231]   - Field: ‘owner’
[10:21:24.231]   - Field: ‘envir’
[10:21:24.231]   - Field: ‘workers’
[10:21:24.231]   - Field: ‘packages’
[10:21:24.231]   - Field: ‘gc’
[10:21:24.231]   - Field: ‘conditions’
[10:21:24.231]   - Field: ‘persistent’
[10:21:24.231]   - Field: ‘expr’
[10:21:24.231]   - Field: ‘uuid’
[10:21:24.231]   - Field: ‘seed’
[10:21:24.231]   - Field: ‘version’
[10:21:24.232]   - Field: ‘result’
[10:21:24.232]   - Field: ‘asynchronous’
[10:21:24.232]   - Field: ‘calls’
[10:21:24.232]   - Field: ‘globals’
[10:21:24.232]   - Field: ‘stdout’
[10:21:24.232]   - Field: ‘earlySignal’
[10:21:24.232]   - Field: ‘lazy’
[10:21:24.232]   - Field: ‘state’
[10:21:24.232] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:24.232] - Launch lazy future ...
[10:21:24.233] Packages needed by the future expression (n = 0): <none>
[10:21:24.233] Packages needed by future strategies (n = 0): <none>
[10:21:24.233] {
[10:21:24.233]     {
[10:21:24.233]         {
[10:21:24.233]             ...future.startTime <- base::Sys.time()
[10:21:24.233]             {
[10:21:24.233]                 {
[10:21:24.233]                   {
[10:21:24.233]                     {
[10:21:24.233]                       base::local({
[10:21:24.233]                         has_future <- base::requireNamespace("future", 
[10:21:24.233]                           quietly = TRUE)
[10:21:24.233]                         if (has_future) {
[10:21:24.233]                           ns <- base::getNamespace("future")
[10:21:24.233]                           version <- ns[[".package"]][["version"]]
[10:21:24.233]                           if (is.null(version)) 
[10:21:24.233]                             version <- utils::packageVersion("future")
[10:21:24.233]                         }
[10:21:24.233]                         else {
[10:21:24.233]                           version <- NULL
[10:21:24.233]                         }
[10:21:24.233]                         if (!has_future || version < "1.8.0") {
[10:21:24.233]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:24.233]                             "", base::R.version$version.string), 
[10:21:24.233]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:24.233]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:24.233]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:24.233]                               "release", "version")], collapse = " "), 
[10:21:24.233]                             hostname = base::Sys.info()[["nodename"]])
[10:21:24.233]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:24.233]                             info)
[10:21:24.233]                           info <- base::paste(info, collapse = "; ")
[10:21:24.233]                           if (!has_future) {
[10:21:24.233]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:24.233]                               info)
[10:21:24.233]                           }
[10:21:24.233]                           else {
[10:21:24.233]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:24.233]                               info, version)
[10:21:24.233]                           }
[10:21:24.233]                           base::stop(msg)
[10:21:24.233]                         }
[10:21:24.233]                       })
[10:21:24.233]                     }
[10:21:24.233]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:24.233]                     base::options(mc.cores = 1L)
[10:21:24.233]                   }
[10:21:24.233]                   ...future.strategy.old <- future::plan("list")
[10:21:24.233]                   options(future.plan = NULL)
[10:21:24.233]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.233]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:24.233]                 }
[10:21:24.233]                 ...future.workdir <- getwd()
[10:21:24.233]             }
[10:21:24.233]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:24.233]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:24.233]         }
[10:21:24.233]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:24.233]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:24.233]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:24.233]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:24.233]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:24.233]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:24.233]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:24.233]             base::names(...future.oldOptions))
[10:21:24.233]     }
[10:21:24.233]     if (FALSE) {
[10:21:24.233]     }
[10:21:24.233]     else {
[10:21:24.233]         if (TRUE) {
[10:21:24.233]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:24.233]                 open = "w")
[10:21:24.233]         }
[10:21:24.233]         else {
[10:21:24.233]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:24.233]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:24.233]         }
[10:21:24.233]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:24.233]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:24.233]             base::sink(type = "output", split = FALSE)
[10:21:24.233]             base::close(...future.stdout)
[10:21:24.233]         }, add = TRUE)
[10:21:24.233]     }
[10:21:24.233]     ...future.frame <- base::sys.nframe()
[10:21:24.233]     ...future.conditions <- base::list()
[10:21:24.233]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:24.233]     if (FALSE) {
[10:21:24.233]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:24.233]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:24.233]     }
[10:21:24.233]     ...future.result <- base::tryCatch({
[10:21:24.233]         base::withCallingHandlers({
[10:21:24.233]             ...future.value <- base::withVisible(base::local({
[10:21:24.233]                 ...future.makeSendCondition <- base::local({
[10:21:24.233]                   sendCondition <- NULL
[10:21:24.233]                   function(frame = 1L) {
[10:21:24.233]                     if (is.function(sendCondition)) 
[10:21:24.233]                       return(sendCondition)
[10:21:24.233]                     ns <- getNamespace("parallel")
[10:21:24.233]                     if (exists("sendData", mode = "function", 
[10:21:24.233]                       envir = ns)) {
[10:21:24.233]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:24.233]                         envir = ns)
[10:21:24.233]                       envir <- sys.frame(frame)
[10:21:24.233]                       master <- NULL
[10:21:24.233]                       while (!identical(envir, .GlobalEnv) && 
[10:21:24.233]                         !identical(envir, emptyenv())) {
[10:21:24.233]                         if (exists("master", mode = "list", envir = envir, 
[10:21:24.233]                           inherits = FALSE)) {
[10:21:24.233]                           master <- get("master", mode = "list", 
[10:21:24.233]                             envir = envir, inherits = FALSE)
[10:21:24.233]                           if (inherits(master, c("SOCKnode", 
[10:21:24.233]                             "SOCK0node"))) {
[10:21:24.233]                             sendCondition <<- function(cond) {
[10:21:24.233]                               data <- list(type = "VALUE", value = cond, 
[10:21:24.233]                                 success = TRUE)
[10:21:24.233]                               parallel_sendData(master, data)
[10:21:24.233]                             }
[10:21:24.233]                             return(sendCondition)
[10:21:24.233]                           }
[10:21:24.233]                         }
[10:21:24.233]                         frame <- frame + 1L
[10:21:24.233]                         envir <- sys.frame(frame)
[10:21:24.233]                       }
[10:21:24.233]                     }
[10:21:24.233]                     sendCondition <<- function(cond) NULL
[10:21:24.233]                   }
[10:21:24.233]                 })
[10:21:24.233]                 withCallingHandlers({
[10:21:24.233]                   2
[10:21:24.233]                 }, immediateCondition = function(cond) {
[10:21:24.233]                   sendCondition <- ...future.makeSendCondition()
[10:21:24.233]                   sendCondition(cond)
[10:21:24.233]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.233]                   {
[10:21:24.233]                     inherits <- base::inherits
[10:21:24.233]                     invokeRestart <- base::invokeRestart
[10:21:24.233]                     is.null <- base::is.null
[10:21:24.233]                     muffled <- FALSE
[10:21:24.233]                     if (inherits(cond, "message")) {
[10:21:24.233]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:24.233]                       if (muffled) 
[10:21:24.233]                         invokeRestart("muffleMessage")
[10:21:24.233]                     }
[10:21:24.233]                     else if (inherits(cond, "warning")) {
[10:21:24.233]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:24.233]                       if (muffled) 
[10:21:24.233]                         invokeRestart("muffleWarning")
[10:21:24.233]                     }
[10:21:24.233]                     else if (inherits(cond, "condition")) {
[10:21:24.233]                       if (!is.null(pattern)) {
[10:21:24.233]                         computeRestarts <- base::computeRestarts
[10:21:24.233]                         grepl <- base::grepl
[10:21:24.233]                         restarts <- computeRestarts(cond)
[10:21:24.233]                         for (restart in restarts) {
[10:21:24.233]                           name <- restart$name
[10:21:24.233]                           if (is.null(name)) 
[10:21:24.233]                             next
[10:21:24.233]                           if (!grepl(pattern, name)) 
[10:21:24.233]                             next
[10:21:24.233]                           invokeRestart(restart)
[10:21:24.233]                           muffled <- TRUE
[10:21:24.233]                           break
[10:21:24.233]                         }
[10:21:24.233]                       }
[10:21:24.233]                     }
[10:21:24.233]                     invisible(muffled)
[10:21:24.233]                   }
[10:21:24.233]                   muffleCondition(cond)
[10:21:24.233]                 })
[10:21:24.233]             }))
[10:21:24.233]             future::FutureResult(value = ...future.value$value, 
[10:21:24.233]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.233]                   ...future.rng), globalenv = if (FALSE) 
[10:21:24.233]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:24.233]                     ...future.globalenv.names))
[10:21:24.233]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:24.233]         }, condition = base::local({
[10:21:24.233]             c <- base::c
[10:21:24.233]             inherits <- base::inherits
[10:21:24.233]             invokeRestart <- base::invokeRestart
[10:21:24.233]             length <- base::length
[10:21:24.233]             list <- base::list
[10:21:24.233]             seq.int <- base::seq.int
[10:21:24.233]             signalCondition <- base::signalCondition
[10:21:24.233]             sys.calls <- base::sys.calls
[10:21:24.233]             `[[` <- base::`[[`
[10:21:24.233]             `+` <- base::`+`
[10:21:24.233]             `<<-` <- base::`<<-`
[10:21:24.233]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:24.233]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:24.233]                   3L)]
[10:21:24.233]             }
[10:21:24.233]             function(cond) {
[10:21:24.233]                 is_error <- inherits(cond, "error")
[10:21:24.233]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:24.233]                   NULL)
[10:21:24.233]                 if (is_error) {
[10:21:24.233]                   sessionInformation <- function() {
[10:21:24.233]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:24.233]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:24.233]                       search = base::search(), system = base::Sys.info())
[10:21:24.233]                   }
[10:21:24.233]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.233]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:24.233]                     cond$call), session = sessionInformation(), 
[10:21:24.233]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:24.233]                   signalCondition(cond)
[10:21:24.233]                 }
[10:21:24.233]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:24.233]                 "immediateCondition"))) {
[10:21:24.233]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:24.233]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.233]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:24.233]                   if (TRUE && !signal) {
[10:21:24.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.233]                     {
[10:21:24.233]                       inherits <- base::inherits
[10:21:24.233]                       invokeRestart <- base::invokeRestart
[10:21:24.233]                       is.null <- base::is.null
[10:21:24.233]                       muffled <- FALSE
[10:21:24.233]                       if (inherits(cond, "message")) {
[10:21:24.233]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.233]                         if (muffled) 
[10:21:24.233]                           invokeRestart("muffleMessage")
[10:21:24.233]                       }
[10:21:24.233]                       else if (inherits(cond, "warning")) {
[10:21:24.233]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.233]                         if (muffled) 
[10:21:24.233]                           invokeRestart("muffleWarning")
[10:21:24.233]                       }
[10:21:24.233]                       else if (inherits(cond, "condition")) {
[10:21:24.233]                         if (!is.null(pattern)) {
[10:21:24.233]                           computeRestarts <- base::computeRestarts
[10:21:24.233]                           grepl <- base::grepl
[10:21:24.233]                           restarts <- computeRestarts(cond)
[10:21:24.233]                           for (restart in restarts) {
[10:21:24.233]                             name <- restart$name
[10:21:24.233]                             if (is.null(name)) 
[10:21:24.233]                               next
[10:21:24.233]                             if (!grepl(pattern, name)) 
[10:21:24.233]                               next
[10:21:24.233]                             invokeRestart(restart)
[10:21:24.233]                             muffled <- TRUE
[10:21:24.233]                             break
[10:21:24.233]                           }
[10:21:24.233]                         }
[10:21:24.233]                       }
[10:21:24.233]                       invisible(muffled)
[10:21:24.233]                     }
[10:21:24.233]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.233]                   }
[10:21:24.233]                 }
[10:21:24.233]                 else {
[10:21:24.233]                   if (TRUE) {
[10:21:24.233]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.233]                     {
[10:21:24.233]                       inherits <- base::inherits
[10:21:24.233]                       invokeRestart <- base::invokeRestart
[10:21:24.233]                       is.null <- base::is.null
[10:21:24.233]                       muffled <- FALSE
[10:21:24.233]                       if (inherits(cond, "message")) {
[10:21:24.233]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.233]                         if (muffled) 
[10:21:24.233]                           invokeRestart("muffleMessage")
[10:21:24.233]                       }
[10:21:24.233]                       else if (inherits(cond, "warning")) {
[10:21:24.233]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.233]                         if (muffled) 
[10:21:24.233]                           invokeRestart("muffleWarning")
[10:21:24.233]                       }
[10:21:24.233]                       else if (inherits(cond, "condition")) {
[10:21:24.233]                         if (!is.null(pattern)) {
[10:21:24.233]                           computeRestarts <- base::computeRestarts
[10:21:24.233]                           grepl <- base::grepl
[10:21:24.233]                           restarts <- computeRestarts(cond)
[10:21:24.233]                           for (restart in restarts) {
[10:21:24.233]                             name <- restart$name
[10:21:24.233]                             if (is.null(name)) 
[10:21:24.233]                               next
[10:21:24.233]                             if (!grepl(pattern, name)) 
[10:21:24.233]                               next
[10:21:24.233]                             invokeRestart(restart)
[10:21:24.233]                             muffled <- TRUE
[10:21:24.233]                             break
[10:21:24.233]                           }
[10:21:24.233]                         }
[10:21:24.233]                       }
[10:21:24.233]                       invisible(muffled)
[10:21:24.233]                     }
[10:21:24.233]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.233]                   }
[10:21:24.233]                 }
[10:21:24.233]             }
[10:21:24.233]         }))
[10:21:24.233]     }, error = function(ex) {
[10:21:24.233]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:24.233]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.233]                 ...future.rng), started = ...future.startTime, 
[10:21:24.233]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:24.233]             version = "1.8"), class = "FutureResult")
[10:21:24.233]     }, finally = {
[10:21:24.233]         if (!identical(...future.workdir, getwd())) 
[10:21:24.233]             setwd(...future.workdir)
[10:21:24.233]         {
[10:21:24.233]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:24.233]                 ...future.oldOptions$nwarnings <- NULL
[10:21:24.233]             }
[10:21:24.233]             base::options(...future.oldOptions)
[10:21:24.233]             if (.Platform$OS.type == "windows") {
[10:21:24.233]                 old_names <- names(...future.oldEnvVars)
[10:21:24.233]                 envs <- base::Sys.getenv()
[10:21:24.233]                 names <- names(envs)
[10:21:24.233]                 common <- intersect(names, old_names)
[10:21:24.233]                 added <- setdiff(names, old_names)
[10:21:24.233]                 removed <- setdiff(old_names, names)
[10:21:24.233]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:24.233]                   envs[common]]
[10:21:24.233]                 NAMES <- toupper(changed)
[10:21:24.233]                 args <- list()
[10:21:24.233]                 for (kk in seq_along(NAMES)) {
[10:21:24.233]                   name <- changed[[kk]]
[10:21:24.233]                   NAME <- NAMES[[kk]]
[10:21:24.233]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.233]                     next
[10:21:24.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.233]                 }
[10:21:24.233]                 NAMES <- toupper(added)
[10:21:24.233]                 for (kk in seq_along(NAMES)) {
[10:21:24.233]                   name <- added[[kk]]
[10:21:24.233]                   NAME <- NAMES[[kk]]
[10:21:24.233]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.233]                     next
[10:21:24.233]                   args[[name]] <- ""
[10:21:24.233]                 }
[10:21:24.233]                 NAMES <- toupper(removed)
[10:21:24.233]                 for (kk in seq_along(NAMES)) {
[10:21:24.233]                   name <- removed[[kk]]
[10:21:24.233]                   NAME <- NAMES[[kk]]
[10:21:24.233]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.233]                     next
[10:21:24.233]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.233]                 }
[10:21:24.233]                 if (length(args) > 0) 
[10:21:24.233]                   base::do.call(base::Sys.setenv, args = args)
[10:21:24.233]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:24.233]             }
[10:21:24.233]             else {
[10:21:24.233]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:24.233]             }
[10:21:24.233]             {
[10:21:24.233]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:24.233]                   0L) {
[10:21:24.233]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:24.233]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:24.233]                   base::options(opts)
[10:21:24.233]                 }
[10:21:24.233]                 {
[10:21:24.233]                   {
[10:21:24.233]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:24.233]                     NULL
[10:21:24.233]                   }
[10:21:24.233]                   options(future.plan = NULL)
[10:21:24.233]                   if (is.na(NA_character_)) 
[10:21:24.233]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.233]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:24.233]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:24.233]                     .init = FALSE)
[10:21:24.233]                 }
[10:21:24.233]             }
[10:21:24.233]         }
[10:21:24.233]     })
[10:21:24.233]     if (TRUE) {
[10:21:24.233]         base::sink(type = "output", split = FALSE)
[10:21:24.233]         if (TRUE) {
[10:21:24.233]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:24.233]         }
[10:21:24.233]         else {
[10:21:24.233]             ...future.result["stdout"] <- base::list(NULL)
[10:21:24.233]         }
[10:21:24.233]         base::close(...future.stdout)
[10:21:24.233]         ...future.stdout <- NULL
[10:21:24.233]     }
[10:21:24.233]     ...future.result$conditions <- ...future.conditions
[10:21:24.233]     ...future.result$finished <- base::Sys.time()
[10:21:24.233]     ...future.result
[10:21:24.233] }
[10:21:24.236] MultisessionFuture started
[10:21:24.236] - Launch lazy future ... done
[10:21:24.236] run() for ‘MultisessionFuture’ ... done
[10:21:24.236] getGlobalsAndPackages() ...
[10:21:24.237] Searching for globals...
[10:21:24.237] 
[10:21:24.237] Searching for globals ... DONE
[10:21:24.237] - globals: [0] <none>
[10:21:24.237] getGlobalsAndPackages() ... DONE
[10:21:24.237] run() for ‘Future’ ...
[10:21:24.237] - state: ‘created’
[10:21:24.238] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:24.251] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:24.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:24.251]   - Field: ‘node’
[10:21:24.251]   - Field: ‘label’
[10:21:24.251]   - Field: ‘local’
[10:21:24.252]   - Field: ‘owner’
[10:21:24.252]   - Field: ‘envir’
[10:21:24.252]   - Field: ‘workers’
[10:21:24.252]   - Field: ‘packages’
[10:21:24.252]   - Field: ‘gc’
[10:21:24.252]   - Field: ‘conditions’
[10:21:24.252]   - Field: ‘persistent’
[10:21:24.252]   - Field: ‘expr’
[10:21:24.252]   - Field: ‘uuid’
[10:21:24.252]   - Field: ‘seed’
[10:21:24.252]   - Field: ‘version’
[10:21:24.252]   - Field: ‘result’
[10:21:24.253]   - Field: ‘asynchronous’
[10:21:24.253]   - Field: ‘calls’
[10:21:24.253]   - Field: ‘globals’
[10:21:24.253]   - Field: ‘stdout’
[10:21:24.253]   - Field: ‘earlySignal’
[10:21:24.253]   - Field: ‘lazy’
[10:21:24.253]   - Field: ‘state’
[10:21:24.253] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:24.253] - Launch lazy future ...
[10:21:24.253] Packages needed by the future expression (n = 0): <none>
[10:21:24.254] Packages needed by future strategies (n = 0): <none>
[10:21:24.254] {
[10:21:24.254]     {
[10:21:24.254]         {
[10:21:24.254]             ...future.startTime <- base::Sys.time()
[10:21:24.254]             {
[10:21:24.254]                 {
[10:21:24.254]                   {
[10:21:24.254]                     {
[10:21:24.254]                       base::local({
[10:21:24.254]                         has_future <- base::requireNamespace("future", 
[10:21:24.254]                           quietly = TRUE)
[10:21:24.254]                         if (has_future) {
[10:21:24.254]                           ns <- base::getNamespace("future")
[10:21:24.254]                           version <- ns[[".package"]][["version"]]
[10:21:24.254]                           if (is.null(version)) 
[10:21:24.254]                             version <- utils::packageVersion("future")
[10:21:24.254]                         }
[10:21:24.254]                         else {
[10:21:24.254]                           version <- NULL
[10:21:24.254]                         }
[10:21:24.254]                         if (!has_future || version < "1.8.0") {
[10:21:24.254]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:24.254]                             "", base::R.version$version.string), 
[10:21:24.254]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:24.254]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:24.254]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:24.254]                               "release", "version")], collapse = " "), 
[10:21:24.254]                             hostname = base::Sys.info()[["nodename"]])
[10:21:24.254]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:24.254]                             info)
[10:21:24.254]                           info <- base::paste(info, collapse = "; ")
[10:21:24.254]                           if (!has_future) {
[10:21:24.254]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:24.254]                               info)
[10:21:24.254]                           }
[10:21:24.254]                           else {
[10:21:24.254]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:24.254]                               info, version)
[10:21:24.254]                           }
[10:21:24.254]                           base::stop(msg)
[10:21:24.254]                         }
[10:21:24.254]                       })
[10:21:24.254]                     }
[10:21:24.254]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:24.254]                     base::options(mc.cores = 1L)
[10:21:24.254]                   }
[10:21:24.254]                   ...future.strategy.old <- future::plan("list")
[10:21:24.254]                   options(future.plan = NULL)
[10:21:24.254]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.254]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:24.254]                 }
[10:21:24.254]                 ...future.workdir <- getwd()
[10:21:24.254]             }
[10:21:24.254]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:24.254]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:24.254]         }
[10:21:24.254]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:24.254]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:24.254]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:24.254]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:24.254]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:24.254]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:24.254]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:24.254]             base::names(...future.oldOptions))
[10:21:24.254]     }
[10:21:24.254]     if (FALSE) {
[10:21:24.254]     }
[10:21:24.254]     else {
[10:21:24.254]         if (TRUE) {
[10:21:24.254]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:24.254]                 open = "w")
[10:21:24.254]         }
[10:21:24.254]         else {
[10:21:24.254]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:24.254]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:24.254]         }
[10:21:24.254]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:24.254]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:24.254]             base::sink(type = "output", split = FALSE)
[10:21:24.254]             base::close(...future.stdout)
[10:21:24.254]         }, add = TRUE)
[10:21:24.254]     }
[10:21:24.254]     ...future.frame <- base::sys.nframe()
[10:21:24.254]     ...future.conditions <- base::list()
[10:21:24.254]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:24.254]     if (FALSE) {
[10:21:24.254]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:24.254]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:24.254]     }
[10:21:24.254]     ...future.result <- base::tryCatch({
[10:21:24.254]         base::withCallingHandlers({
[10:21:24.254]             ...future.value <- base::withVisible(base::local({
[10:21:24.254]                 ...future.makeSendCondition <- base::local({
[10:21:24.254]                   sendCondition <- NULL
[10:21:24.254]                   function(frame = 1L) {
[10:21:24.254]                     if (is.function(sendCondition)) 
[10:21:24.254]                       return(sendCondition)
[10:21:24.254]                     ns <- getNamespace("parallel")
[10:21:24.254]                     if (exists("sendData", mode = "function", 
[10:21:24.254]                       envir = ns)) {
[10:21:24.254]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:24.254]                         envir = ns)
[10:21:24.254]                       envir <- sys.frame(frame)
[10:21:24.254]                       master <- NULL
[10:21:24.254]                       while (!identical(envir, .GlobalEnv) && 
[10:21:24.254]                         !identical(envir, emptyenv())) {
[10:21:24.254]                         if (exists("master", mode = "list", envir = envir, 
[10:21:24.254]                           inherits = FALSE)) {
[10:21:24.254]                           master <- get("master", mode = "list", 
[10:21:24.254]                             envir = envir, inherits = FALSE)
[10:21:24.254]                           if (inherits(master, c("SOCKnode", 
[10:21:24.254]                             "SOCK0node"))) {
[10:21:24.254]                             sendCondition <<- function(cond) {
[10:21:24.254]                               data <- list(type = "VALUE", value = cond, 
[10:21:24.254]                                 success = TRUE)
[10:21:24.254]                               parallel_sendData(master, data)
[10:21:24.254]                             }
[10:21:24.254]                             return(sendCondition)
[10:21:24.254]                           }
[10:21:24.254]                         }
[10:21:24.254]                         frame <- frame + 1L
[10:21:24.254]                         envir <- sys.frame(frame)
[10:21:24.254]                       }
[10:21:24.254]                     }
[10:21:24.254]                     sendCondition <<- function(cond) NULL
[10:21:24.254]                   }
[10:21:24.254]                 })
[10:21:24.254]                 withCallingHandlers({
[10:21:24.254]                   NULL
[10:21:24.254]                 }, immediateCondition = function(cond) {
[10:21:24.254]                   sendCondition <- ...future.makeSendCondition()
[10:21:24.254]                   sendCondition(cond)
[10:21:24.254]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.254]                   {
[10:21:24.254]                     inherits <- base::inherits
[10:21:24.254]                     invokeRestart <- base::invokeRestart
[10:21:24.254]                     is.null <- base::is.null
[10:21:24.254]                     muffled <- FALSE
[10:21:24.254]                     if (inherits(cond, "message")) {
[10:21:24.254]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:24.254]                       if (muffled) 
[10:21:24.254]                         invokeRestart("muffleMessage")
[10:21:24.254]                     }
[10:21:24.254]                     else if (inherits(cond, "warning")) {
[10:21:24.254]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:24.254]                       if (muffled) 
[10:21:24.254]                         invokeRestart("muffleWarning")
[10:21:24.254]                     }
[10:21:24.254]                     else if (inherits(cond, "condition")) {
[10:21:24.254]                       if (!is.null(pattern)) {
[10:21:24.254]                         computeRestarts <- base::computeRestarts
[10:21:24.254]                         grepl <- base::grepl
[10:21:24.254]                         restarts <- computeRestarts(cond)
[10:21:24.254]                         for (restart in restarts) {
[10:21:24.254]                           name <- restart$name
[10:21:24.254]                           if (is.null(name)) 
[10:21:24.254]                             next
[10:21:24.254]                           if (!grepl(pattern, name)) 
[10:21:24.254]                             next
[10:21:24.254]                           invokeRestart(restart)
[10:21:24.254]                           muffled <- TRUE
[10:21:24.254]                           break
[10:21:24.254]                         }
[10:21:24.254]                       }
[10:21:24.254]                     }
[10:21:24.254]                     invisible(muffled)
[10:21:24.254]                   }
[10:21:24.254]                   muffleCondition(cond)
[10:21:24.254]                 })
[10:21:24.254]             }))
[10:21:24.254]             future::FutureResult(value = ...future.value$value, 
[10:21:24.254]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.254]                   ...future.rng), globalenv = if (FALSE) 
[10:21:24.254]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:24.254]                     ...future.globalenv.names))
[10:21:24.254]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:24.254]         }, condition = base::local({
[10:21:24.254]             c <- base::c
[10:21:24.254]             inherits <- base::inherits
[10:21:24.254]             invokeRestart <- base::invokeRestart
[10:21:24.254]             length <- base::length
[10:21:24.254]             list <- base::list
[10:21:24.254]             seq.int <- base::seq.int
[10:21:24.254]             signalCondition <- base::signalCondition
[10:21:24.254]             sys.calls <- base::sys.calls
[10:21:24.254]             `[[` <- base::`[[`
[10:21:24.254]             `+` <- base::`+`
[10:21:24.254]             `<<-` <- base::`<<-`
[10:21:24.254]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:24.254]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:24.254]                   3L)]
[10:21:24.254]             }
[10:21:24.254]             function(cond) {
[10:21:24.254]                 is_error <- inherits(cond, "error")
[10:21:24.254]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:24.254]                   NULL)
[10:21:24.254]                 if (is_error) {
[10:21:24.254]                   sessionInformation <- function() {
[10:21:24.254]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:24.254]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:24.254]                       search = base::search(), system = base::Sys.info())
[10:21:24.254]                   }
[10:21:24.254]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.254]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:24.254]                     cond$call), session = sessionInformation(), 
[10:21:24.254]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:24.254]                   signalCondition(cond)
[10:21:24.254]                 }
[10:21:24.254]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:24.254]                 "immediateCondition"))) {
[10:21:24.254]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:24.254]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.254]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:24.254]                   if (TRUE && !signal) {
[10:21:24.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.254]                     {
[10:21:24.254]                       inherits <- base::inherits
[10:21:24.254]                       invokeRestart <- base::invokeRestart
[10:21:24.254]                       is.null <- base::is.null
[10:21:24.254]                       muffled <- FALSE
[10:21:24.254]                       if (inherits(cond, "message")) {
[10:21:24.254]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.254]                         if (muffled) 
[10:21:24.254]                           invokeRestart("muffleMessage")
[10:21:24.254]                       }
[10:21:24.254]                       else if (inherits(cond, "warning")) {
[10:21:24.254]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.254]                         if (muffled) 
[10:21:24.254]                           invokeRestart("muffleWarning")
[10:21:24.254]                       }
[10:21:24.254]                       else if (inherits(cond, "condition")) {
[10:21:24.254]                         if (!is.null(pattern)) {
[10:21:24.254]                           computeRestarts <- base::computeRestarts
[10:21:24.254]                           grepl <- base::grepl
[10:21:24.254]                           restarts <- computeRestarts(cond)
[10:21:24.254]                           for (restart in restarts) {
[10:21:24.254]                             name <- restart$name
[10:21:24.254]                             if (is.null(name)) 
[10:21:24.254]                               next
[10:21:24.254]                             if (!grepl(pattern, name)) 
[10:21:24.254]                               next
[10:21:24.254]                             invokeRestart(restart)
[10:21:24.254]                             muffled <- TRUE
[10:21:24.254]                             break
[10:21:24.254]                           }
[10:21:24.254]                         }
[10:21:24.254]                       }
[10:21:24.254]                       invisible(muffled)
[10:21:24.254]                     }
[10:21:24.254]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.254]                   }
[10:21:24.254]                 }
[10:21:24.254]                 else {
[10:21:24.254]                   if (TRUE) {
[10:21:24.254]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.254]                     {
[10:21:24.254]                       inherits <- base::inherits
[10:21:24.254]                       invokeRestart <- base::invokeRestart
[10:21:24.254]                       is.null <- base::is.null
[10:21:24.254]                       muffled <- FALSE
[10:21:24.254]                       if (inherits(cond, "message")) {
[10:21:24.254]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.254]                         if (muffled) 
[10:21:24.254]                           invokeRestart("muffleMessage")
[10:21:24.254]                       }
[10:21:24.254]                       else if (inherits(cond, "warning")) {
[10:21:24.254]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.254]                         if (muffled) 
[10:21:24.254]                           invokeRestart("muffleWarning")
[10:21:24.254]                       }
[10:21:24.254]                       else if (inherits(cond, "condition")) {
[10:21:24.254]                         if (!is.null(pattern)) {
[10:21:24.254]                           computeRestarts <- base::computeRestarts
[10:21:24.254]                           grepl <- base::grepl
[10:21:24.254]                           restarts <- computeRestarts(cond)
[10:21:24.254]                           for (restart in restarts) {
[10:21:24.254]                             name <- restart$name
[10:21:24.254]                             if (is.null(name)) 
[10:21:24.254]                               next
[10:21:24.254]                             if (!grepl(pattern, name)) 
[10:21:24.254]                               next
[10:21:24.254]                             invokeRestart(restart)
[10:21:24.254]                             muffled <- TRUE
[10:21:24.254]                             break
[10:21:24.254]                           }
[10:21:24.254]                         }
[10:21:24.254]                       }
[10:21:24.254]                       invisible(muffled)
[10:21:24.254]                     }
[10:21:24.254]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.254]                   }
[10:21:24.254]                 }
[10:21:24.254]             }
[10:21:24.254]         }))
[10:21:24.254]     }, error = function(ex) {
[10:21:24.254]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:24.254]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.254]                 ...future.rng), started = ...future.startTime, 
[10:21:24.254]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:24.254]             version = "1.8"), class = "FutureResult")
[10:21:24.254]     }, finally = {
[10:21:24.254]         if (!identical(...future.workdir, getwd())) 
[10:21:24.254]             setwd(...future.workdir)
[10:21:24.254]         {
[10:21:24.254]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:24.254]                 ...future.oldOptions$nwarnings <- NULL
[10:21:24.254]             }
[10:21:24.254]             base::options(...future.oldOptions)
[10:21:24.254]             if (.Platform$OS.type == "windows") {
[10:21:24.254]                 old_names <- names(...future.oldEnvVars)
[10:21:24.254]                 envs <- base::Sys.getenv()
[10:21:24.254]                 names <- names(envs)
[10:21:24.254]                 common <- intersect(names, old_names)
[10:21:24.254]                 added <- setdiff(names, old_names)
[10:21:24.254]                 removed <- setdiff(old_names, names)
[10:21:24.254]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:24.254]                   envs[common]]
[10:21:24.254]                 NAMES <- toupper(changed)
[10:21:24.254]                 args <- list()
[10:21:24.254]                 for (kk in seq_along(NAMES)) {
[10:21:24.254]                   name <- changed[[kk]]
[10:21:24.254]                   NAME <- NAMES[[kk]]
[10:21:24.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.254]                     next
[10:21:24.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.254]                 }
[10:21:24.254]                 NAMES <- toupper(added)
[10:21:24.254]                 for (kk in seq_along(NAMES)) {
[10:21:24.254]                   name <- added[[kk]]
[10:21:24.254]                   NAME <- NAMES[[kk]]
[10:21:24.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.254]                     next
[10:21:24.254]                   args[[name]] <- ""
[10:21:24.254]                 }
[10:21:24.254]                 NAMES <- toupper(removed)
[10:21:24.254]                 for (kk in seq_along(NAMES)) {
[10:21:24.254]                   name <- removed[[kk]]
[10:21:24.254]                   NAME <- NAMES[[kk]]
[10:21:24.254]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.254]                     next
[10:21:24.254]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.254]                 }
[10:21:24.254]                 if (length(args) > 0) 
[10:21:24.254]                   base::do.call(base::Sys.setenv, args = args)
[10:21:24.254]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:24.254]             }
[10:21:24.254]             else {
[10:21:24.254]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:24.254]             }
[10:21:24.254]             {
[10:21:24.254]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:24.254]                   0L) {
[10:21:24.254]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:24.254]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:24.254]                   base::options(opts)
[10:21:24.254]                 }
[10:21:24.254]                 {
[10:21:24.254]                   {
[10:21:24.254]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:24.254]                     NULL
[10:21:24.254]                   }
[10:21:24.254]                   options(future.plan = NULL)
[10:21:24.254]                   if (is.na(NA_character_)) 
[10:21:24.254]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.254]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:24.254]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:24.254]                     .init = FALSE)
[10:21:24.254]                 }
[10:21:24.254]             }
[10:21:24.254]         }
[10:21:24.254]     })
[10:21:24.254]     if (TRUE) {
[10:21:24.254]         base::sink(type = "output", split = FALSE)
[10:21:24.254]         if (TRUE) {
[10:21:24.254]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:24.254]         }
[10:21:24.254]         else {
[10:21:24.254]             ...future.result["stdout"] <- base::list(NULL)
[10:21:24.254]         }
[10:21:24.254]         base::close(...future.stdout)
[10:21:24.254]         ...future.stdout <- NULL
[10:21:24.254]     }
[10:21:24.254]     ...future.result$conditions <- ...future.conditions
[10:21:24.254]     ...future.result$finished <- base::Sys.time()
[10:21:24.254]     ...future.result
[10:21:24.254] }
[10:21:24.257] MultisessionFuture started
[10:21:24.257] - Launch lazy future ... done
[10:21:24.257] run() for ‘MultisessionFuture’ ... done
[10:21:24.258] getGlobalsAndPackages() ...
[10:21:24.258] Searching for globals...
[10:21:24.258] - globals found: [1] ‘{’
[10:21:24.258] Searching for globals ... DONE
[10:21:24.258] Resolving globals: FALSE
[10:21:24.259] 
[10:21:24.259] 
[10:21:24.259] getGlobalsAndPackages() ... DONE
[10:21:24.259] run() for ‘Future’ ...
[10:21:24.259] - state: ‘created’
[10:21:24.259] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:24.273] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:24.273] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:24.273]   - Field: ‘node’
[10:21:24.274]   - Field: ‘label’
[10:21:24.277]   - Field: ‘local’
[10:21:24.277]   - Field: ‘owner’
[10:21:24.277]   - Field: ‘envir’
[10:21:24.277]   - Field: ‘workers’
[10:21:24.277]   - Field: ‘packages’
[10:21:24.277]   - Field: ‘gc’
[10:21:24.277]   - Field: ‘conditions’
[10:21:24.277]   - Field: ‘persistent’
[10:21:24.278]   - Field: ‘expr’
[10:21:24.278]   - Field: ‘uuid’
[10:21:24.278]   - Field: ‘seed’
[10:21:24.278]   - Field: ‘version’
[10:21:24.278]   - Field: ‘result’
[10:21:24.278]   - Field: ‘asynchronous’
[10:21:24.278]   - Field: ‘calls’
[10:21:24.278]   - Field: ‘globals’
[10:21:24.278]   - Field: ‘stdout’
[10:21:24.278]   - Field: ‘earlySignal’
[10:21:24.278]   - Field: ‘lazy’
[10:21:24.278]   - Field: ‘state’
[10:21:24.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:24.279] - Launch lazy future ...
[10:21:24.279] Packages needed by the future expression (n = 0): <none>
[10:21:24.279] Packages needed by future strategies (n = 0): <none>
[10:21:24.279] {
[10:21:24.279]     {
[10:21:24.279]         {
[10:21:24.279]             ...future.startTime <- base::Sys.time()
[10:21:24.279]             {
[10:21:24.279]                 {
[10:21:24.279]                   {
[10:21:24.279]                     {
[10:21:24.279]                       base::local({
[10:21:24.279]                         has_future <- base::requireNamespace("future", 
[10:21:24.279]                           quietly = TRUE)
[10:21:24.279]                         if (has_future) {
[10:21:24.279]                           ns <- base::getNamespace("future")
[10:21:24.279]                           version <- ns[[".package"]][["version"]]
[10:21:24.279]                           if (is.null(version)) 
[10:21:24.279]                             version <- utils::packageVersion("future")
[10:21:24.279]                         }
[10:21:24.279]                         else {
[10:21:24.279]                           version <- NULL
[10:21:24.279]                         }
[10:21:24.279]                         if (!has_future || version < "1.8.0") {
[10:21:24.279]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:24.279]                             "", base::R.version$version.string), 
[10:21:24.279]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:24.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:24.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:24.279]                               "release", "version")], collapse = " "), 
[10:21:24.279]                             hostname = base::Sys.info()[["nodename"]])
[10:21:24.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:24.279]                             info)
[10:21:24.279]                           info <- base::paste(info, collapse = "; ")
[10:21:24.279]                           if (!has_future) {
[10:21:24.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:24.279]                               info)
[10:21:24.279]                           }
[10:21:24.279]                           else {
[10:21:24.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:24.279]                               info, version)
[10:21:24.279]                           }
[10:21:24.279]                           base::stop(msg)
[10:21:24.279]                         }
[10:21:24.279]                       })
[10:21:24.279]                     }
[10:21:24.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:24.279]                     base::options(mc.cores = 1L)
[10:21:24.279]                   }
[10:21:24.279]                   ...future.strategy.old <- future::plan("list")
[10:21:24.279]                   options(future.plan = NULL)
[10:21:24.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:24.279]                 }
[10:21:24.279]                 ...future.workdir <- getwd()
[10:21:24.279]             }
[10:21:24.279]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:24.279]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:24.279]         }
[10:21:24.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:24.279]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:24.279]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:24.279]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:24.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:24.279]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:24.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:24.279]             base::names(...future.oldOptions))
[10:21:24.279]     }
[10:21:24.279]     if (FALSE) {
[10:21:24.279]     }
[10:21:24.279]     else {
[10:21:24.279]         if (TRUE) {
[10:21:24.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:24.279]                 open = "w")
[10:21:24.279]         }
[10:21:24.279]         else {
[10:21:24.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:24.279]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:24.279]         }
[10:21:24.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:24.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:24.279]             base::sink(type = "output", split = FALSE)
[10:21:24.279]             base::close(...future.stdout)
[10:21:24.279]         }, add = TRUE)
[10:21:24.279]     }
[10:21:24.279]     ...future.frame <- base::sys.nframe()
[10:21:24.279]     ...future.conditions <- base::list()
[10:21:24.279]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:24.279]     if (FALSE) {
[10:21:24.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:24.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:24.279]     }
[10:21:24.279]     ...future.result <- base::tryCatch({
[10:21:24.279]         base::withCallingHandlers({
[10:21:24.279]             ...future.value <- base::withVisible(base::local({
[10:21:24.279]                 ...future.makeSendCondition <- base::local({
[10:21:24.279]                   sendCondition <- NULL
[10:21:24.279]                   function(frame = 1L) {
[10:21:24.279]                     if (is.function(sendCondition)) 
[10:21:24.279]                       return(sendCondition)
[10:21:24.279]                     ns <- getNamespace("parallel")
[10:21:24.279]                     if (exists("sendData", mode = "function", 
[10:21:24.279]                       envir = ns)) {
[10:21:24.279]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:24.279]                         envir = ns)
[10:21:24.279]                       envir <- sys.frame(frame)
[10:21:24.279]                       master <- NULL
[10:21:24.279]                       while (!identical(envir, .GlobalEnv) && 
[10:21:24.279]                         !identical(envir, emptyenv())) {
[10:21:24.279]                         if (exists("master", mode = "list", envir = envir, 
[10:21:24.279]                           inherits = FALSE)) {
[10:21:24.279]                           master <- get("master", mode = "list", 
[10:21:24.279]                             envir = envir, inherits = FALSE)
[10:21:24.279]                           if (inherits(master, c("SOCKnode", 
[10:21:24.279]                             "SOCK0node"))) {
[10:21:24.279]                             sendCondition <<- function(cond) {
[10:21:24.279]                               data <- list(type = "VALUE", value = cond, 
[10:21:24.279]                                 success = TRUE)
[10:21:24.279]                               parallel_sendData(master, data)
[10:21:24.279]                             }
[10:21:24.279]                             return(sendCondition)
[10:21:24.279]                           }
[10:21:24.279]                         }
[10:21:24.279]                         frame <- frame + 1L
[10:21:24.279]                         envir <- sys.frame(frame)
[10:21:24.279]                       }
[10:21:24.279]                     }
[10:21:24.279]                     sendCondition <<- function(cond) NULL
[10:21:24.279]                   }
[10:21:24.279]                 })
[10:21:24.279]                 withCallingHandlers({
[10:21:24.279]                   {
[10:21:24.279]                     4
[10:21:24.279]                   }
[10:21:24.279]                 }, immediateCondition = function(cond) {
[10:21:24.279]                   sendCondition <- ...future.makeSendCondition()
[10:21:24.279]                   sendCondition(cond)
[10:21:24.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.279]                   {
[10:21:24.279]                     inherits <- base::inherits
[10:21:24.279]                     invokeRestart <- base::invokeRestart
[10:21:24.279]                     is.null <- base::is.null
[10:21:24.279]                     muffled <- FALSE
[10:21:24.279]                     if (inherits(cond, "message")) {
[10:21:24.279]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:24.279]                       if (muffled) 
[10:21:24.279]                         invokeRestart("muffleMessage")
[10:21:24.279]                     }
[10:21:24.279]                     else if (inherits(cond, "warning")) {
[10:21:24.279]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:24.279]                       if (muffled) 
[10:21:24.279]                         invokeRestart("muffleWarning")
[10:21:24.279]                     }
[10:21:24.279]                     else if (inherits(cond, "condition")) {
[10:21:24.279]                       if (!is.null(pattern)) {
[10:21:24.279]                         computeRestarts <- base::computeRestarts
[10:21:24.279]                         grepl <- base::grepl
[10:21:24.279]                         restarts <- computeRestarts(cond)
[10:21:24.279]                         for (restart in restarts) {
[10:21:24.279]                           name <- restart$name
[10:21:24.279]                           if (is.null(name)) 
[10:21:24.279]                             next
[10:21:24.279]                           if (!grepl(pattern, name)) 
[10:21:24.279]                             next
[10:21:24.279]                           invokeRestart(restart)
[10:21:24.279]                           muffled <- TRUE
[10:21:24.279]                           break
[10:21:24.279]                         }
[10:21:24.279]                       }
[10:21:24.279]                     }
[10:21:24.279]                     invisible(muffled)
[10:21:24.279]                   }
[10:21:24.279]                   muffleCondition(cond)
[10:21:24.279]                 })
[10:21:24.279]             }))
[10:21:24.279]             future::FutureResult(value = ...future.value$value, 
[10:21:24.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.279]                   ...future.rng), globalenv = if (FALSE) 
[10:21:24.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:24.279]                     ...future.globalenv.names))
[10:21:24.279]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:24.279]         }, condition = base::local({
[10:21:24.279]             c <- base::c
[10:21:24.279]             inherits <- base::inherits
[10:21:24.279]             invokeRestart <- base::invokeRestart
[10:21:24.279]             length <- base::length
[10:21:24.279]             list <- base::list
[10:21:24.279]             seq.int <- base::seq.int
[10:21:24.279]             signalCondition <- base::signalCondition
[10:21:24.279]             sys.calls <- base::sys.calls
[10:21:24.279]             `[[` <- base::`[[`
[10:21:24.279]             `+` <- base::`+`
[10:21:24.279]             `<<-` <- base::`<<-`
[10:21:24.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:24.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:24.279]                   3L)]
[10:21:24.279]             }
[10:21:24.279]             function(cond) {
[10:21:24.279]                 is_error <- inherits(cond, "error")
[10:21:24.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:24.279]                   NULL)
[10:21:24.279]                 if (is_error) {
[10:21:24.279]                   sessionInformation <- function() {
[10:21:24.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:24.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:24.279]                       search = base::search(), system = base::Sys.info())
[10:21:24.279]                   }
[10:21:24.279]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:24.279]                     cond$call), session = sessionInformation(), 
[10:21:24.279]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:24.279]                   signalCondition(cond)
[10:21:24.279]                 }
[10:21:24.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:24.279]                 "immediateCondition"))) {
[10:21:24.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:24.279]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:24.279]                   if (TRUE && !signal) {
[10:21:24.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.279]                     {
[10:21:24.279]                       inherits <- base::inherits
[10:21:24.279]                       invokeRestart <- base::invokeRestart
[10:21:24.279]                       is.null <- base::is.null
[10:21:24.279]                       muffled <- FALSE
[10:21:24.279]                       if (inherits(cond, "message")) {
[10:21:24.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.279]                         if (muffled) 
[10:21:24.279]                           invokeRestart("muffleMessage")
[10:21:24.279]                       }
[10:21:24.279]                       else if (inherits(cond, "warning")) {
[10:21:24.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.279]                         if (muffled) 
[10:21:24.279]                           invokeRestart("muffleWarning")
[10:21:24.279]                       }
[10:21:24.279]                       else if (inherits(cond, "condition")) {
[10:21:24.279]                         if (!is.null(pattern)) {
[10:21:24.279]                           computeRestarts <- base::computeRestarts
[10:21:24.279]                           grepl <- base::grepl
[10:21:24.279]                           restarts <- computeRestarts(cond)
[10:21:24.279]                           for (restart in restarts) {
[10:21:24.279]                             name <- restart$name
[10:21:24.279]                             if (is.null(name)) 
[10:21:24.279]                               next
[10:21:24.279]                             if (!grepl(pattern, name)) 
[10:21:24.279]                               next
[10:21:24.279]                             invokeRestart(restart)
[10:21:24.279]                             muffled <- TRUE
[10:21:24.279]                             break
[10:21:24.279]                           }
[10:21:24.279]                         }
[10:21:24.279]                       }
[10:21:24.279]                       invisible(muffled)
[10:21:24.279]                     }
[10:21:24.279]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.279]                   }
[10:21:24.279]                 }
[10:21:24.279]                 else {
[10:21:24.279]                   if (TRUE) {
[10:21:24.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.279]                     {
[10:21:24.279]                       inherits <- base::inherits
[10:21:24.279]                       invokeRestart <- base::invokeRestart
[10:21:24.279]                       is.null <- base::is.null
[10:21:24.279]                       muffled <- FALSE
[10:21:24.279]                       if (inherits(cond, "message")) {
[10:21:24.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.279]                         if (muffled) 
[10:21:24.279]                           invokeRestart("muffleMessage")
[10:21:24.279]                       }
[10:21:24.279]                       else if (inherits(cond, "warning")) {
[10:21:24.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.279]                         if (muffled) 
[10:21:24.279]                           invokeRestart("muffleWarning")
[10:21:24.279]                       }
[10:21:24.279]                       else if (inherits(cond, "condition")) {
[10:21:24.279]                         if (!is.null(pattern)) {
[10:21:24.279]                           computeRestarts <- base::computeRestarts
[10:21:24.279]                           grepl <- base::grepl
[10:21:24.279]                           restarts <- computeRestarts(cond)
[10:21:24.279]                           for (restart in restarts) {
[10:21:24.279]                             name <- restart$name
[10:21:24.279]                             if (is.null(name)) 
[10:21:24.279]                               next
[10:21:24.279]                             if (!grepl(pattern, name)) 
[10:21:24.279]                               next
[10:21:24.279]                             invokeRestart(restart)
[10:21:24.279]                             muffled <- TRUE
[10:21:24.279]                             break
[10:21:24.279]                           }
[10:21:24.279]                         }
[10:21:24.279]                       }
[10:21:24.279]                       invisible(muffled)
[10:21:24.279]                     }
[10:21:24.279]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.279]                   }
[10:21:24.279]                 }
[10:21:24.279]             }
[10:21:24.279]         }))
[10:21:24.279]     }, error = function(ex) {
[10:21:24.279]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:24.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.279]                 ...future.rng), started = ...future.startTime, 
[10:21:24.279]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:24.279]             version = "1.8"), class = "FutureResult")
[10:21:24.279]     }, finally = {
[10:21:24.279]         if (!identical(...future.workdir, getwd())) 
[10:21:24.279]             setwd(...future.workdir)
[10:21:24.279]         {
[10:21:24.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:24.279]                 ...future.oldOptions$nwarnings <- NULL
[10:21:24.279]             }
[10:21:24.279]             base::options(...future.oldOptions)
[10:21:24.279]             if (.Platform$OS.type == "windows") {
[10:21:24.279]                 old_names <- names(...future.oldEnvVars)
[10:21:24.279]                 envs <- base::Sys.getenv()
[10:21:24.279]                 names <- names(envs)
[10:21:24.279]                 common <- intersect(names, old_names)
[10:21:24.279]                 added <- setdiff(names, old_names)
[10:21:24.279]                 removed <- setdiff(old_names, names)
[10:21:24.279]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:24.279]                   envs[common]]
[10:21:24.279]                 NAMES <- toupper(changed)
[10:21:24.279]                 args <- list()
[10:21:24.279]                 for (kk in seq_along(NAMES)) {
[10:21:24.279]                   name <- changed[[kk]]
[10:21:24.279]                   NAME <- NAMES[[kk]]
[10:21:24.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.279]                     next
[10:21:24.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.279]                 }
[10:21:24.279]                 NAMES <- toupper(added)
[10:21:24.279]                 for (kk in seq_along(NAMES)) {
[10:21:24.279]                   name <- added[[kk]]
[10:21:24.279]                   NAME <- NAMES[[kk]]
[10:21:24.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.279]                     next
[10:21:24.279]                   args[[name]] <- ""
[10:21:24.279]                 }
[10:21:24.279]                 NAMES <- toupper(removed)
[10:21:24.279]                 for (kk in seq_along(NAMES)) {
[10:21:24.279]                   name <- removed[[kk]]
[10:21:24.279]                   NAME <- NAMES[[kk]]
[10:21:24.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.279]                     next
[10:21:24.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.279]                 }
[10:21:24.279]                 if (length(args) > 0) 
[10:21:24.279]                   base::do.call(base::Sys.setenv, args = args)
[10:21:24.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:24.279]             }
[10:21:24.279]             else {
[10:21:24.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:24.279]             }
[10:21:24.279]             {
[10:21:24.279]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:24.279]                   0L) {
[10:21:24.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:24.279]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:24.279]                   base::options(opts)
[10:21:24.279]                 }
[10:21:24.279]                 {
[10:21:24.279]                   {
[10:21:24.279]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:24.279]                     NULL
[10:21:24.279]                   }
[10:21:24.279]                   options(future.plan = NULL)
[10:21:24.279]                   if (is.na(NA_character_)) 
[10:21:24.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:24.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:24.279]                     .init = FALSE)
[10:21:24.279]                 }
[10:21:24.279]             }
[10:21:24.279]         }
[10:21:24.279]     })
[10:21:24.279]     if (TRUE) {
[10:21:24.279]         base::sink(type = "output", split = FALSE)
[10:21:24.279]         if (TRUE) {
[10:21:24.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:24.279]         }
[10:21:24.279]         else {
[10:21:24.279]             ...future.result["stdout"] <- base::list(NULL)
[10:21:24.279]         }
[10:21:24.279]         base::close(...future.stdout)
[10:21:24.279]         ...future.stdout <- NULL
[10:21:24.279]     }
[10:21:24.279]     ...future.result$conditions <- ...future.conditions
[10:21:24.279]     ...future.result$finished <- base::Sys.time()
[10:21:24.279]     ...future.result
[10:21:24.279] }
[10:21:24.282] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:24.292] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.292] - Validating connection of MultisessionFuture
[10:21:24.292] - received message: FutureResult
[10:21:24.293] - Received FutureResult
[10:21:24.293] - Erased future from FutureRegistry
[10:21:24.293] result() for ClusterFuture ...
[10:21:24.293] - result already collected: FutureResult
[10:21:24.293] result() for ClusterFuture ... done
[10:21:24.293] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:24.293] result() for ClusterFuture ...
[10:21:24.293] - result already collected: FutureResult
[10:21:24.293] result() for ClusterFuture ... done
[10:21:24.293] result() for ClusterFuture ...
[10:21:24.293] - result already collected: FutureResult
[10:21:24.294] result() for ClusterFuture ... done
[10:21:24.294] MultisessionFuture started
[10:21:24.295] - Launch lazy future ... done
[10:21:24.295] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e6ad2d68> 
Classes 'listenv', 'environment' <environment: 0x55e8e53f4410> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:21:24.300] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.300] - Validating connection of MultisessionFuture
[10:21:24.300] - received message: FutureResult
[10:21:24.300] - Received FutureResult
[10:21:24.300] - Erased future from FutureRegistry
[10:21:24.300] result() for ClusterFuture ...
[10:21:24.300] - result already collected: FutureResult
[10:21:24.301] result() for ClusterFuture ... done
[10:21:24.301] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:24.313] resolve() on list environment ...
[10:21:24.314]  recursive: 0
[10:21:24.314]  length: 6
[10:21:24.315]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:24.315] signalConditionsASAP(numeric, pos=1) ...
[10:21:24.315] - nx: 6
[10:21:24.315] - relay: TRUE
[10:21:24.315] - stdout: TRUE
[10:21:24.315] - signal: TRUE
[10:21:24.315] - resignal: FALSE
[10:21:24.315] - force: TRUE
[10:21:24.315] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.315] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.315]  - until=2
[10:21:24.316]  - relaying element #2
[10:21:24.316] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.316] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.316] signalConditionsASAP(NULL, pos=1) ... done
[10:21:24.316]  length: 5 (resolved future 1)
[10:21:24.316] Future #2
[10:21:24.316] result() for ClusterFuture ...
[10:21:24.316] - result already collected: FutureResult
[10:21:24.316] result() for ClusterFuture ... done
[10:21:24.316] result() for ClusterFuture ...
[10:21:24.316] - result already collected: FutureResult
[10:21:24.316] result() for ClusterFuture ... done
[10:21:24.317] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:24.317] - nx: 6
[10:21:24.317] - relay: TRUE
[10:21:24.317] - stdout: TRUE
[10:21:24.317] - signal: TRUE
[10:21:24.317] - resignal: FALSE
[10:21:24.317] - force: TRUE
[10:21:24.317] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.317] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.317]  - until=2
[10:21:24.317]  - relaying element #2
[10:21:24.317] result() for ClusterFuture ...
[10:21:24.318] - result already collected: FutureResult
[10:21:24.318] result() for ClusterFuture ... done
[10:21:24.318] result() for ClusterFuture ...
[10:21:24.318] - result already collected: FutureResult
[10:21:24.318] result() for ClusterFuture ... done
[10:21:24.318] result() for ClusterFuture ...
[10:21:24.318] - result already collected: FutureResult
[10:21:24.318] result() for ClusterFuture ... done
[10:21:24.318] result() for ClusterFuture ...
[10:21:24.318] - result already collected: FutureResult
[10:21:24.318] result() for ClusterFuture ... done
[10:21:24.318] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.318] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.319] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:24.319]  length: 4 (resolved future 2)
[10:21:24.319] Future #3
[10:21:24.319] result() for ClusterFuture ...
[10:21:24.319] - result already collected: FutureResult
[10:21:24.319] result() for ClusterFuture ... done
[10:21:24.319] result() for ClusterFuture ...
[10:21:24.319] - result already collected: FutureResult
[10:21:24.319] result() for ClusterFuture ... done
[10:21:24.319] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:24.320] - nx: 6
[10:21:24.320] - relay: TRUE
[10:21:24.320] - stdout: TRUE
[10:21:24.320] - signal: TRUE
[10:21:24.320] - resignal: FALSE
[10:21:24.320] - force: TRUE
[10:21:24.320] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.320] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.320]  - until=3
[10:21:24.320]  - relaying element #3
[10:21:24.320] result() for ClusterFuture ...
[10:21:24.320] - result already collected: FutureResult
[10:21:24.320] result() for ClusterFuture ... done
[10:21:24.321] result() for ClusterFuture ...
[10:21:24.321] - result already collected: FutureResult
[10:21:24.321] result() for ClusterFuture ... done
[10:21:24.321] result() for ClusterFuture ...
[10:21:24.321] - result already collected: FutureResult
[10:21:24.321] result() for ClusterFuture ... done
[10:21:24.321] result() for ClusterFuture ...
[10:21:24.321] - result already collected: FutureResult
[10:21:24.321] result() for ClusterFuture ... done
[10:21:24.321] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.321] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.322] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:24.322]  length: 3 (resolved future 3)
[10:21:24.332] signalConditionsASAP(NULL, pos=5) ...
[10:21:24.332] - nx: 6
[10:21:24.332] - relay: TRUE
[10:21:24.332] - stdout: TRUE
[10:21:24.333] - signal: TRUE
[10:21:24.333] - resignal: FALSE
[10:21:24.333] - force: TRUE
[10:21:24.333] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.333] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.333]  - until=6
[10:21:24.333]  - relaying element #4
[10:21:24.333]  - relaying element #6
[10:21:24.333] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:24.333] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.333] signalConditionsASAP(NULL, pos=5) ... done
[10:21:24.333]  length: 2 (resolved future 5)
[10:21:24.334] signalConditionsASAP(numeric, pos=6) ...
[10:21:24.334] - nx: 6
[10:21:24.334] - relay: TRUE
[10:21:24.334] - stdout: TRUE
[10:21:24.334] - signal: TRUE
[10:21:24.334] - resignal: FALSE
[10:21:24.334] - force: TRUE
[10:21:24.334] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:24.334] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.334]  - until=6
[10:21:24.334]  - relaying element #4
[10:21:24.334] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:24.334] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.335] signalConditionsASAP(NULL, pos=6) ... done
[10:21:24.335]  length: 1 (resolved future 6)
[10:21:24.345] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.346] - Validating connection of MultisessionFuture
[10:21:24.346] - received message: FutureResult
[10:21:24.346] - Received FutureResult
[10:21:24.346] - Erased future from FutureRegistry
[10:21:24.346] result() for ClusterFuture ...
[10:21:24.346] - result already collected: FutureResult
[10:21:24.346] result() for ClusterFuture ... done
[10:21:24.346] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:24.346] Future #4
[10:21:24.346] result() for ClusterFuture ...
[10:21:24.347] - result already collected: FutureResult
[10:21:24.347] result() for ClusterFuture ... done
[10:21:24.347] result() for ClusterFuture ...
[10:21:24.347] - result already collected: FutureResult
[10:21:24.347] result() for ClusterFuture ... done
[10:21:24.347] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:24.347] - nx: 6
[10:21:24.347] - relay: TRUE
[10:21:24.347] - stdout: TRUE
[10:21:24.347] - signal: TRUE
[10:21:24.347] - resignal: FALSE
[10:21:24.348] - force: TRUE
[10:21:24.348] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:24.348] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.348]  - until=6
[10:21:24.348]  - relaying element #4
[10:21:24.348] result() for ClusterFuture ...
[10:21:24.348] - result already collected: FutureResult
[10:21:24.348] result() for ClusterFuture ... done
[10:21:24.348] result() for ClusterFuture ...
[10:21:24.348] - result already collected: FutureResult
[10:21:24.349] result() for ClusterFuture ... done
[10:21:24.349] result() for ClusterFuture ...
[10:21:24.349] - result already collected: FutureResult
[10:21:24.349] result() for ClusterFuture ... done
[10:21:24.349] result() for ClusterFuture ...
[10:21:24.349] - result already collected: FutureResult
[10:21:24.349] result() for ClusterFuture ... done
[10:21:24.349] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.350] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:24.350] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:24.350]  length: 0 (resolved future 4)
[10:21:24.350] Relaying remaining futures
[10:21:24.350] signalConditionsASAP(NULL, pos=0) ...
[10:21:24.350] - nx: 6
[10:21:24.350] - relay: TRUE
[10:21:24.350] - stdout: TRUE
[10:21:24.351] - signal: TRUE
[10:21:24.351] - resignal: FALSE
[10:21:24.351] - force: TRUE
[10:21:24.351] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.351] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:24.351] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.351] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:24.351] signalConditionsASAP(NULL, pos=0) ... done
[10:21:24.351] resolve() on list environment ... DONE
[10:21:24.352] result() for ClusterFuture ...
[10:21:24.352] - result already collected: FutureResult
[10:21:24.352] result() for ClusterFuture ... done
[10:21:24.352] result() for ClusterFuture ...
[10:21:24.352] - result already collected: FutureResult
[10:21:24.352] result() for ClusterFuture ... done
[10:21:24.352] result() for ClusterFuture ...
[10:21:24.352] - result already collected: FutureResult
[10:21:24.352] result() for ClusterFuture ... done
[10:21:24.352] result() for ClusterFuture ...
[10:21:24.352] - result already collected: FutureResult
[10:21:24.353] result() for ClusterFuture ... done
[10:21:24.353] result() for ClusterFuture ...
[10:21:24.353] - result already collected: FutureResult
[10:21:24.353] result() for ClusterFuture ... done
[10:21:24.353] result() for ClusterFuture ...
[10:21:24.353] - result already collected: FutureResult
[10:21:24.353] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e4d53d10> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[10:21:24.355] getGlobalsAndPackages() ...
[10:21:24.355] Searching for globals...
[10:21:24.356] 
[10:21:24.356] Searching for globals ... DONE
[10:21:24.356] - globals: [0] <none>
[10:21:24.356] getGlobalsAndPackages() ... DONE
[10:21:24.356] run() for ‘Future’ ...
[10:21:24.356] - state: ‘created’
[10:21:24.356] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:24.370] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:24.370] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:24.371]   - Field: ‘node’
[10:21:24.371]   - Field: ‘label’
[10:21:24.371]   - Field: ‘local’
[10:21:24.371]   - Field: ‘owner’
[10:21:24.371]   - Field: ‘envir’
[10:21:24.371]   - Field: ‘workers’
[10:21:24.371]   - Field: ‘packages’
[10:21:24.371]   - Field: ‘gc’
[10:21:24.371]   - Field: ‘conditions’
[10:21:24.371]   - Field: ‘persistent’
[10:21:24.371]   - Field: ‘expr’
[10:21:24.372]   - Field: ‘uuid’
[10:21:24.372]   - Field: ‘seed’
[10:21:24.372]   - Field: ‘version’
[10:21:24.372]   - Field: ‘result’
[10:21:24.372]   - Field: ‘asynchronous’
[10:21:24.372]   - Field: ‘calls’
[10:21:24.372]   - Field: ‘globals’
[10:21:24.372]   - Field: ‘stdout’
[10:21:24.372]   - Field: ‘earlySignal’
[10:21:24.372]   - Field: ‘lazy’
[10:21:24.372]   - Field: ‘state’
[10:21:24.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:24.373] - Launch lazy future ...
[10:21:24.373] Packages needed by the future expression (n = 0): <none>
[10:21:24.373] Packages needed by future strategies (n = 0): <none>
[10:21:24.373] {
[10:21:24.373]     {
[10:21:24.373]         {
[10:21:24.373]             ...future.startTime <- base::Sys.time()
[10:21:24.373]             {
[10:21:24.373]                 {
[10:21:24.373]                   {
[10:21:24.373]                     {
[10:21:24.373]                       base::local({
[10:21:24.373]                         has_future <- base::requireNamespace("future", 
[10:21:24.373]                           quietly = TRUE)
[10:21:24.373]                         if (has_future) {
[10:21:24.373]                           ns <- base::getNamespace("future")
[10:21:24.373]                           version <- ns[[".package"]][["version"]]
[10:21:24.373]                           if (is.null(version)) 
[10:21:24.373]                             version <- utils::packageVersion("future")
[10:21:24.373]                         }
[10:21:24.373]                         else {
[10:21:24.373]                           version <- NULL
[10:21:24.373]                         }
[10:21:24.373]                         if (!has_future || version < "1.8.0") {
[10:21:24.373]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:24.373]                             "", base::R.version$version.string), 
[10:21:24.373]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:24.373]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:24.373]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:24.373]                               "release", "version")], collapse = " "), 
[10:21:24.373]                             hostname = base::Sys.info()[["nodename"]])
[10:21:24.373]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:24.373]                             info)
[10:21:24.373]                           info <- base::paste(info, collapse = "; ")
[10:21:24.373]                           if (!has_future) {
[10:21:24.373]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:24.373]                               info)
[10:21:24.373]                           }
[10:21:24.373]                           else {
[10:21:24.373]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:24.373]                               info, version)
[10:21:24.373]                           }
[10:21:24.373]                           base::stop(msg)
[10:21:24.373]                         }
[10:21:24.373]                       })
[10:21:24.373]                     }
[10:21:24.373]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:24.373]                     base::options(mc.cores = 1L)
[10:21:24.373]                   }
[10:21:24.373]                   ...future.strategy.old <- future::plan("list")
[10:21:24.373]                   options(future.plan = NULL)
[10:21:24.373]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.373]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:24.373]                 }
[10:21:24.373]                 ...future.workdir <- getwd()
[10:21:24.373]             }
[10:21:24.373]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:24.373]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:24.373]         }
[10:21:24.373]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:24.373]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:24.373]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:24.373]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:24.373]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:24.373]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:24.373]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:24.373]             base::names(...future.oldOptions))
[10:21:24.373]     }
[10:21:24.373]     if (FALSE) {
[10:21:24.373]     }
[10:21:24.373]     else {
[10:21:24.373]         if (TRUE) {
[10:21:24.373]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:24.373]                 open = "w")
[10:21:24.373]         }
[10:21:24.373]         else {
[10:21:24.373]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:24.373]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:24.373]         }
[10:21:24.373]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:24.373]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:24.373]             base::sink(type = "output", split = FALSE)
[10:21:24.373]             base::close(...future.stdout)
[10:21:24.373]         }, add = TRUE)
[10:21:24.373]     }
[10:21:24.373]     ...future.frame <- base::sys.nframe()
[10:21:24.373]     ...future.conditions <- base::list()
[10:21:24.373]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:24.373]     if (FALSE) {
[10:21:24.373]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:24.373]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:24.373]     }
[10:21:24.373]     ...future.result <- base::tryCatch({
[10:21:24.373]         base::withCallingHandlers({
[10:21:24.373]             ...future.value <- base::withVisible(base::local({
[10:21:24.373]                 ...future.makeSendCondition <- base::local({
[10:21:24.373]                   sendCondition <- NULL
[10:21:24.373]                   function(frame = 1L) {
[10:21:24.373]                     if (is.function(sendCondition)) 
[10:21:24.373]                       return(sendCondition)
[10:21:24.373]                     ns <- getNamespace("parallel")
[10:21:24.373]                     if (exists("sendData", mode = "function", 
[10:21:24.373]                       envir = ns)) {
[10:21:24.373]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:24.373]                         envir = ns)
[10:21:24.373]                       envir <- sys.frame(frame)
[10:21:24.373]                       master <- NULL
[10:21:24.373]                       while (!identical(envir, .GlobalEnv) && 
[10:21:24.373]                         !identical(envir, emptyenv())) {
[10:21:24.373]                         if (exists("master", mode = "list", envir = envir, 
[10:21:24.373]                           inherits = FALSE)) {
[10:21:24.373]                           master <- get("master", mode = "list", 
[10:21:24.373]                             envir = envir, inherits = FALSE)
[10:21:24.373]                           if (inherits(master, c("SOCKnode", 
[10:21:24.373]                             "SOCK0node"))) {
[10:21:24.373]                             sendCondition <<- function(cond) {
[10:21:24.373]                               data <- list(type = "VALUE", value = cond, 
[10:21:24.373]                                 success = TRUE)
[10:21:24.373]                               parallel_sendData(master, data)
[10:21:24.373]                             }
[10:21:24.373]                             return(sendCondition)
[10:21:24.373]                           }
[10:21:24.373]                         }
[10:21:24.373]                         frame <- frame + 1L
[10:21:24.373]                         envir <- sys.frame(frame)
[10:21:24.373]                       }
[10:21:24.373]                     }
[10:21:24.373]                     sendCondition <<- function(cond) NULL
[10:21:24.373]                   }
[10:21:24.373]                 })
[10:21:24.373]                 withCallingHandlers({
[10:21:24.373]                   2
[10:21:24.373]                 }, immediateCondition = function(cond) {
[10:21:24.373]                   sendCondition <- ...future.makeSendCondition()
[10:21:24.373]                   sendCondition(cond)
[10:21:24.373]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.373]                   {
[10:21:24.373]                     inherits <- base::inherits
[10:21:24.373]                     invokeRestart <- base::invokeRestart
[10:21:24.373]                     is.null <- base::is.null
[10:21:24.373]                     muffled <- FALSE
[10:21:24.373]                     if (inherits(cond, "message")) {
[10:21:24.373]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:24.373]                       if (muffled) 
[10:21:24.373]                         invokeRestart("muffleMessage")
[10:21:24.373]                     }
[10:21:24.373]                     else if (inherits(cond, "warning")) {
[10:21:24.373]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:24.373]                       if (muffled) 
[10:21:24.373]                         invokeRestart("muffleWarning")
[10:21:24.373]                     }
[10:21:24.373]                     else if (inherits(cond, "condition")) {
[10:21:24.373]                       if (!is.null(pattern)) {
[10:21:24.373]                         computeRestarts <- base::computeRestarts
[10:21:24.373]                         grepl <- base::grepl
[10:21:24.373]                         restarts <- computeRestarts(cond)
[10:21:24.373]                         for (restart in restarts) {
[10:21:24.373]                           name <- restart$name
[10:21:24.373]                           if (is.null(name)) 
[10:21:24.373]                             next
[10:21:24.373]                           if (!grepl(pattern, name)) 
[10:21:24.373]                             next
[10:21:24.373]                           invokeRestart(restart)
[10:21:24.373]                           muffled <- TRUE
[10:21:24.373]                           break
[10:21:24.373]                         }
[10:21:24.373]                       }
[10:21:24.373]                     }
[10:21:24.373]                     invisible(muffled)
[10:21:24.373]                   }
[10:21:24.373]                   muffleCondition(cond)
[10:21:24.373]                 })
[10:21:24.373]             }))
[10:21:24.373]             future::FutureResult(value = ...future.value$value, 
[10:21:24.373]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.373]                   ...future.rng), globalenv = if (FALSE) 
[10:21:24.373]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:24.373]                     ...future.globalenv.names))
[10:21:24.373]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:24.373]         }, condition = base::local({
[10:21:24.373]             c <- base::c
[10:21:24.373]             inherits <- base::inherits
[10:21:24.373]             invokeRestart <- base::invokeRestart
[10:21:24.373]             length <- base::length
[10:21:24.373]             list <- base::list
[10:21:24.373]             seq.int <- base::seq.int
[10:21:24.373]             signalCondition <- base::signalCondition
[10:21:24.373]             sys.calls <- base::sys.calls
[10:21:24.373]             `[[` <- base::`[[`
[10:21:24.373]             `+` <- base::`+`
[10:21:24.373]             `<<-` <- base::`<<-`
[10:21:24.373]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:24.373]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:24.373]                   3L)]
[10:21:24.373]             }
[10:21:24.373]             function(cond) {
[10:21:24.373]                 is_error <- inherits(cond, "error")
[10:21:24.373]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:24.373]                   NULL)
[10:21:24.373]                 if (is_error) {
[10:21:24.373]                   sessionInformation <- function() {
[10:21:24.373]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:24.373]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:24.373]                       search = base::search(), system = base::Sys.info())
[10:21:24.373]                   }
[10:21:24.373]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.373]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:24.373]                     cond$call), session = sessionInformation(), 
[10:21:24.373]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:24.373]                   signalCondition(cond)
[10:21:24.373]                 }
[10:21:24.373]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:24.373]                 "immediateCondition"))) {
[10:21:24.373]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:24.373]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.373]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:24.373]                   if (TRUE && !signal) {
[10:21:24.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.373]                     {
[10:21:24.373]                       inherits <- base::inherits
[10:21:24.373]                       invokeRestart <- base::invokeRestart
[10:21:24.373]                       is.null <- base::is.null
[10:21:24.373]                       muffled <- FALSE
[10:21:24.373]                       if (inherits(cond, "message")) {
[10:21:24.373]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.373]                         if (muffled) 
[10:21:24.373]                           invokeRestart("muffleMessage")
[10:21:24.373]                       }
[10:21:24.373]                       else if (inherits(cond, "warning")) {
[10:21:24.373]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.373]                         if (muffled) 
[10:21:24.373]                           invokeRestart("muffleWarning")
[10:21:24.373]                       }
[10:21:24.373]                       else if (inherits(cond, "condition")) {
[10:21:24.373]                         if (!is.null(pattern)) {
[10:21:24.373]                           computeRestarts <- base::computeRestarts
[10:21:24.373]                           grepl <- base::grepl
[10:21:24.373]                           restarts <- computeRestarts(cond)
[10:21:24.373]                           for (restart in restarts) {
[10:21:24.373]                             name <- restart$name
[10:21:24.373]                             if (is.null(name)) 
[10:21:24.373]                               next
[10:21:24.373]                             if (!grepl(pattern, name)) 
[10:21:24.373]                               next
[10:21:24.373]                             invokeRestart(restart)
[10:21:24.373]                             muffled <- TRUE
[10:21:24.373]                             break
[10:21:24.373]                           }
[10:21:24.373]                         }
[10:21:24.373]                       }
[10:21:24.373]                       invisible(muffled)
[10:21:24.373]                     }
[10:21:24.373]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.373]                   }
[10:21:24.373]                 }
[10:21:24.373]                 else {
[10:21:24.373]                   if (TRUE) {
[10:21:24.373]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.373]                     {
[10:21:24.373]                       inherits <- base::inherits
[10:21:24.373]                       invokeRestart <- base::invokeRestart
[10:21:24.373]                       is.null <- base::is.null
[10:21:24.373]                       muffled <- FALSE
[10:21:24.373]                       if (inherits(cond, "message")) {
[10:21:24.373]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.373]                         if (muffled) 
[10:21:24.373]                           invokeRestart("muffleMessage")
[10:21:24.373]                       }
[10:21:24.373]                       else if (inherits(cond, "warning")) {
[10:21:24.373]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.373]                         if (muffled) 
[10:21:24.373]                           invokeRestart("muffleWarning")
[10:21:24.373]                       }
[10:21:24.373]                       else if (inherits(cond, "condition")) {
[10:21:24.373]                         if (!is.null(pattern)) {
[10:21:24.373]                           computeRestarts <- base::computeRestarts
[10:21:24.373]                           grepl <- base::grepl
[10:21:24.373]                           restarts <- computeRestarts(cond)
[10:21:24.373]                           for (restart in restarts) {
[10:21:24.373]                             name <- restart$name
[10:21:24.373]                             if (is.null(name)) 
[10:21:24.373]                               next
[10:21:24.373]                             if (!grepl(pattern, name)) 
[10:21:24.373]                               next
[10:21:24.373]                             invokeRestart(restart)
[10:21:24.373]                             muffled <- TRUE
[10:21:24.373]                             break
[10:21:24.373]                           }
[10:21:24.373]                         }
[10:21:24.373]                       }
[10:21:24.373]                       invisible(muffled)
[10:21:24.373]                     }
[10:21:24.373]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.373]                   }
[10:21:24.373]                 }
[10:21:24.373]             }
[10:21:24.373]         }))
[10:21:24.373]     }, error = function(ex) {
[10:21:24.373]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:24.373]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.373]                 ...future.rng), started = ...future.startTime, 
[10:21:24.373]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:24.373]             version = "1.8"), class = "FutureResult")
[10:21:24.373]     }, finally = {
[10:21:24.373]         if (!identical(...future.workdir, getwd())) 
[10:21:24.373]             setwd(...future.workdir)
[10:21:24.373]         {
[10:21:24.373]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:24.373]                 ...future.oldOptions$nwarnings <- NULL
[10:21:24.373]             }
[10:21:24.373]             base::options(...future.oldOptions)
[10:21:24.373]             if (.Platform$OS.type == "windows") {
[10:21:24.373]                 old_names <- names(...future.oldEnvVars)
[10:21:24.373]                 envs <- base::Sys.getenv()
[10:21:24.373]                 names <- names(envs)
[10:21:24.373]                 common <- intersect(names, old_names)
[10:21:24.373]                 added <- setdiff(names, old_names)
[10:21:24.373]                 removed <- setdiff(old_names, names)
[10:21:24.373]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:24.373]                   envs[common]]
[10:21:24.373]                 NAMES <- toupper(changed)
[10:21:24.373]                 args <- list()
[10:21:24.373]                 for (kk in seq_along(NAMES)) {
[10:21:24.373]                   name <- changed[[kk]]
[10:21:24.373]                   NAME <- NAMES[[kk]]
[10:21:24.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.373]                     next
[10:21:24.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.373]                 }
[10:21:24.373]                 NAMES <- toupper(added)
[10:21:24.373]                 for (kk in seq_along(NAMES)) {
[10:21:24.373]                   name <- added[[kk]]
[10:21:24.373]                   NAME <- NAMES[[kk]]
[10:21:24.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.373]                     next
[10:21:24.373]                   args[[name]] <- ""
[10:21:24.373]                 }
[10:21:24.373]                 NAMES <- toupper(removed)
[10:21:24.373]                 for (kk in seq_along(NAMES)) {
[10:21:24.373]                   name <- removed[[kk]]
[10:21:24.373]                   NAME <- NAMES[[kk]]
[10:21:24.373]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.373]                     next
[10:21:24.373]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.373]                 }
[10:21:24.373]                 if (length(args) > 0) 
[10:21:24.373]                   base::do.call(base::Sys.setenv, args = args)
[10:21:24.373]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:24.373]             }
[10:21:24.373]             else {
[10:21:24.373]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:24.373]             }
[10:21:24.373]             {
[10:21:24.373]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:24.373]                   0L) {
[10:21:24.373]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:24.373]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:24.373]                   base::options(opts)
[10:21:24.373]                 }
[10:21:24.373]                 {
[10:21:24.373]                   {
[10:21:24.373]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:24.373]                     NULL
[10:21:24.373]                   }
[10:21:24.373]                   options(future.plan = NULL)
[10:21:24.373]                   if (is.na(NA_character_)) 
[10:21:24.373]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.373]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:24.373]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:24.373]                     .init = FALSE)
[10:21:24.373]                 }
[10:21:24.373]             }
[10:21:24.373]         }
[10:21:24.373]     })
[10:21:24.373]     if (TRUE) {
[10:21:24.373]         base::sink(type = "output", split = FALSE)
[10:21:24.373]         if (TRUE) {
[10:21:24.373]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:24.373]         }
[10:21:24.373]         else {
[10:21:24.373]             ...future.result["stdout"] <- base::list(NULL)
[10:21:24.373]         }
[10:21:24.373]         base::close(...future.stdout)
[10:21:24.373]         ...future.stdout <- NULL
[10:21:24.373]     }
[10:21:24.373]     ...future.result$conditions <- ...future.conditions
[10:21:24.373]     ...future.result$finished <- base::Sys.time()
[10:21:24.373]     ...future.result
[10:21:24.373] }
[10:21:24.376] MultisessionFuture started
[10:21:24.377] - Launch lazy future ... done
[10:21:24.377] run() for ‘MultisessionFuture’ ... done
[10:21:24.377] getGlobalsAndPackages() ...
[10:21:24.377] Searching for globals...
[10:21:24.377] 
[10:21:24.377] Searching for globals ... DONE
[10:21:24.377] - globals: [0] <none>
[10:21:24.378] getGlobalsAndPackages() ... DONE
[10:21:24.378] run() for ‘Future’ ...
[10:21:24.378] - state: ‘created’
[10:21:24.378] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:24.392] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:24.392] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:24.392]   - Field: ‘node’
[10:21:24.392]   - Field: ‘label’
[10:21:24.392]   - Field: ‘local’
[10:21:24.392]   - Field: ‘owner’
[10:21:24.392]   - Field: ‘envir’
[10:21:24.393]   - Field: ‘workers’
[10:21:24.393]   - Field: ‘packages’
[10:21:24.393]   - Field: ‘gc’
[10:21:24.393]   - Field: ‘conditions’
[10:21:24.393]   - Field: ‘persistent’
[10:21:24.393]   - Field: ‘expr’
[10:21:24.393]   - Field: ‘uuid’
[10:21:24.393]   - Field: ‘seed’
[10:21:24.393]   - Field: ‘version’
[10:21:24.393]   - Field: ‘result’
[10:21:24.393]   - Field: ‘asynchronous’
[10:21:24.393]   - Field: ‘calls’
[10:21:24.394]   - Field: ‘globals’
[10:21:24.394]   - Field: ‘stdout’
[10:21:24.394]   - Field: ‘earlySignal’
[10:21:24.394]   - Field: ‘lazy’
[10:21:24.394]   - Field: ‘state’
[10:21:24.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:24.394] - Launch lazy future ...
[10:21:24.394] Packages needed by the future expression (n = 0): <none>
[10:21:24.394] Packages needed by future strategies (n = 0): <none>
[10:21:24.395] {
[10:21:24.395]     {
[10:21:24.395]         {
[10:21:24.395]             ...future.startTime <- base::Sys.time()
[10:21:24.395]             {
[10:21:24.395]                 {
[10:21:24.395]                   {
[10:21:24.395]                     {
[10:21:24.395]                       base::local({
[10:21:24.395]                         has_future <- base::requireNamespace("future", 
[10:21:24.395]                           quietly = TRUE)
[10:21:24.395]                         if (has_future) {
[10:21:24.395]                           ns <- base::getNamespace("future")
[10:21:24.395]                           version <- ns[[".package"]][["version"]]
[10:21:24.395]                           if (is.null(version)) 
[10:21:24.395]                             version <- utils::packageVersion("future")
[10:21:24.395]                         }
[10:21:24.395]                         else {
[10:21:24.395]                           version <- NULL
[10:21:24.395]                         }
[10:21:24.395]                         if (!has_future || version < "1.8.0") {
[10:21:24.395]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:24.395]                             "", base::R.version$version.string), 
[10:21:24.395]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:24.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:24.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:24.395]                               "release", "version")], collapse = " "), 
[10:21:24.395]                             hostname = base::Sys.info()[["nodename"]])
[10:21:24.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:24.395]                             info)
[10:21:24.395]                           info <- base::paste(info, collapse = "; ")
[10:21:24.395]                           if (!has_future) {
[10:21:24.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:24.395]                               info)
[10:21:24.395]                           }
[10:21:24.395]                           else {
[10:21:24.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:24.395]                               info, version)
[10:21:24.395]                           }
[10:21:24.395]                           base::stop(msg)
[10:21:24.395]                         }
[10:21:24.395]                       })
[10:21:24.395]                     }
[10:21:24.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:24.395]                     base::options(mc.cores = 1L)
[10:21:24.395]                   }
[10:21:24.395]                   ...future.strategy.old <- future::plan("list")
[10:21:24.395]                   options(future.plan = NULL)
[10:21:24.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:24.395]                 }
[10:21:24.395]                 ...future.workdir <- getwd()
[10:21:24.395]             }
[10:21:24.395]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:24.395]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:24.395]         }
[10:21:24.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:24.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:24.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:24.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:24.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:24.395]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:24.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:24.395]             base::names(...future.oldOptions))
[10:21:24.395]     }
[10:21:24.395]     if (FALSE) {
[10:21:24.395]     }
[10:21:24.395]     else {
[10:21:24.395]         if (TRUE) {
[10:21:24.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:24.395]                 open = "w")
[10:21:24.395]         }
[10:21:24.395]         else {
[10:21:24.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:24.395]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:24.395]         }
[10:21:24.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:24.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:24.395]             base::sink(type = "output", split = FALSE)
[10:21:24.395]             base::close(...future.stdout)
[10:21:24.395]         }, add = TRUE)
[10:21:24.395]     }
[10:21:24.395]     ...future.frame <- base::sys.nframe()
[10:21:24.395]     ...future.conditions <- base::list()
[10:21:24.395]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:24.395]     if (FALSE) {
[10:21:24.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:24.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:24.395]     }
[10:21:24.395]     ...future.result <- base::tryCatch({
[10:21:24.395]         base::withCallingHandlers({
[10:21:24.395]             ...future.value <- base::withVisible(base::local({
[10:21:24.395]                 ...future.makeSendCondition <- base::local({
[10:21:24.395]                   sendCondition <- NULL
[10:21:24.395]                   function(frame = 1L) {
[10:21:24.395]                     if (is.function(sendCondition)) 
[10:21:24.395]                       return(sendCondition)
[10:21:24.395]                     ns <- getNamespace("parallel")
[10:21:24.395]                     if (exists("sendData", mode = "function", 
[10:21:24.395]                       envir = ns)) {
[10:21:24.395]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:24.395]                         envir = ns)
[10:21:24.395]                       envir <- sys.frame(frame)
[10:21:24.395]                       master <- NULL
[10:21:24.395]                       while (!identical(envir, .GlobalEnv) && 
[10:21:24.395]                         !identical(envir, emptyenv())) {
[10:21:24.395]                         if (exists("master", mode = "list", envir = envir, 
[10:21:24.395]                           inherits = FALSE)) {
[10:21:24.395]                           master <- get("master", mode = "list", 
[10:21:24.395]                             envir = envir, inherits = FALSE)
[10:21:24.395]                           if (inherits(master, c("SOCKnode", 
[10:21:24.395]                             "SOCK0node"))) {
[10:21:24.395]                             sendCondition <<- function(cond) {
[10:21:24.395]                               data <- list(type = "VALUE", value = cond, 
[10:21:24.395]                                 success = TRUE)
[10:21:24.395]                               parallel_sendData(master, data)
[10:21:24.395]                             }
[10:21:24.395]                             return(sendCondition)
[10:21:24.395]                           }
[10:21:24.395]                         }
[10:21:24.395]                         frame <- frame + 1L
[10:21:24.395]                         envir <- sys.frame(frame)
[10:21:24.395]                       }
[10:21:24.395]                     }
[10:21:24.395]                     sendCondition <<- function(cond) NULL
[10:21:24.395]                   }
[10:21:24.395]                 })
[10:21:24.395]                 withCallingHandlers({
[10:21:24.395]                   NULL
[10:21:24.395]                 }, immediateCondition = function(cond) {
[10:21:24.395]                   sendCondition <- ...future.makeSendCondition()
[10:21:24.395]                   sendCondition(cond)
[10:21:24.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.395]                   {
[10:21:24.395]                     inherits <- base::inherits
[10:21:24.395]                     invokeRestart <- base::invokeRestart
[10:21:24.395]                     is.null <- base::is.null
[10:21:24.395]                     muffled <- FALSE
[10:21:24.395]                     if (inherits(cond, "message")) {
[10:21:24.395]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:24.395]                       if (muffled) 
[10:21:24.395]                         invokeRestart("muffleMessage")
[10:21:24.395]                     }
[10:21:24.395]                     else if (inherits(cond, "warning")) {
[10:21:24.395]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:24.395]                       if (muffled) 
[10:21:24.395]                         invokeRestart("muffleWarning")
[10:21:24.395]                     }
[10:21:24.395]                     else if (inherits(cond, "condition")) {
[10:21:24.395]                       if (!is.null(pattern)) {
[10:21:24.395]                         computeRestarts <- base::computeRestarts
[10:21:24.395]                         grepl <- base::grepl
[10:21:24.395]                         restarts <- computeRestarts(cond)
[10:21:24.395]                         for (restart in restarts) {
[10:21:24.395]                           name <- restart$name
[10:21:24.395]                           if (is.null(name)) 
[10:21:24.395]                             next
[10:21:24.395]                           if (!grepl(pattern, name)) 
[10:21:24.395]                             next
[10:21:24.395]                           invokeRestart(restart)
[10:21:24.395]                           muffled <- TRUE
[10:21:24.395]                           break
[10:21:24.395]                         }
[10:21:24.395]                       }
[10:21:24.395]                     }
[10:21:24.395]                     invisible(muffled)
[10:21:24.395]                   }
[10:21:24.395]                   muffleCondition(cond)
[10:21:24.395]                 })
[10:21:24.395]             }))
[10:21:24.395]             future::FutureResult(value = ...future.value$value, 
[10:21:24.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.395]                   ...future.rng), globalenv = if (FALSE) 
[10:21:24.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:24.395]                     ...future.globalenv.names))
[10:21:24.395]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:24.395]         }, condition = base::local({
[10:21:24.395]             c <- base::c
[10:21:24.395]             inherits <- base::inherits
[10:21:24.395]             invokeRestart <- base::invokeRestart
[10:21:24.395]             length <- base::length
[10:21:24.395]             list <- base::list
[10:21:24.395]             seq.int <- base::seq.int
[10:21:24.395]             signalCondition <- base::signalCondition
[10:21:24.395]             sys.calls <- base::sys.calls
[10:21:24.395]             `[[` <- base::`[[`
[10:21:24.395]             `+` <- base::`+`
[10:21:24.395]             `<<-` <- base::`<<-`
[10:21:24.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:24.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:24.395]                   3L)]
[10:21:24.395]             }
[10:21:24.395]             function(cond) {
[10:21:24.395]                 is_error <- inherits(cond, "error")
[10:21:24.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:24.395]                   NULL)
[10:21:24.395]                 if (is_error) {
[10:21:24.395]                   sessionInformation <- function() {
[10:21:24.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:24.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:24.395]                       search = base::search(), system = base::Sys.info())
[10:21:24.395]                   }
[10:21:24.395]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:24.395]                     cond$call), session = sessionInformation(), 
[10:21:24.395]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:24.395]                   signalCondition(cond)
[10:21:24.395]                 }
[10:21:24.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:24.395]                 "immediateCondition"))) {
[10:21:24.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:24.395]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:24.395]                   if (TRUE && !signal) {
[10:21:24.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.395]                     {
[10:21:24.395]                       inherits <- base::inherits
[10:21:24.395]                       invokeRestart <- base::invokeRestart
[10:21:24.395]                       is.null <- base::is.null
[10:21:24.395]                       muffled <- FALSE
[10:21:24.395]                       if (inherits(cond, "message")) {
[10:21:24.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.395]                         if (muffled) 
[10:21:24.395]                           invokeRestart("muffleMessage")
[10:21:24.395]                       }
[10:21:24.395]                       else if (inherits(cond, "warning")) {
[10:21:24.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.395]                         if (muffled) 
[10:21:24.395]                           invokeRestart("muffleWarning")
[10:21:24.395]                       }
[10:21:24.395]                       else if (inherits(cond, "condition")) {
[10:21:24.395]                         if (!is.null(pattern)) {
[10:21:24.395]                           computeRestarts <- base::computeRestarts
[10:21:24.395]                           grepl <- base::grepl
[10:21:24.395]                           restarts <- computeRestarts(cond)
[10:21:24.395]                           for (restart in restarts) {
[10:21:24.395]                             name <- restart$name
[10:21:24.395]                             if (is.null(name)) 
[10:21:24.395]                               next
[10:21:24.395]                             if (!grepl(pattern, name)) 
[10:21:24.395]                               next
[10:21:24.395]                             invokeRestart(restart)
[10:21:24.395]                             muffled <- TRUE
[10:21:24.395]                             break
[10:21:24.395]                           }
[10:21:24.395]                         }
[10:21:24.395]                       }
[10:21:24.395]                       invisible(muffled)
[10:21:24.395]                     }
[10:21:24.395]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.395]                   }
[10:21:24.395]                 }
[10:21:24.395]                 else {
[10:21:24.395]                   if (TRUE) {
[10:21:24.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.395]                     {
[10:21:24.395]                       inherits <- base::inherits
[10:21:24.395]                       invokeRestart <- base::invokeRestart
[10:21:24.395]                       is.null <- base::is.null
[10:21:24.395]                       muffled <- FALSE
[10:21:24.395]                       if (inherits(cond, "message")) {
[10:21:24.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.395]                         if (muffled) 
[10:21:24.395]                           invokeRestart("muffleMessage")
[10:21:24.395]                       }
[10:21:24.395]                       else if (inherits(cond, "warning")) {
[10:21:24.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.395]                         if (muffled) 
[10:21:24.395]                           invokeRestart("muffleWarning")
[10:21:24.395]                       }
[10:21:24.395]                       else if (inherits(cond, "condition")) {
[10:21:24.395]                         if (!is.null(pattern)) {
[10:21:24.395]                           computeRestarts <- base::computeRestarts
[10:21:24.395]                           grepl <- base::grepl
[10:21:24.395]                           restarts <- computeRestarts(cond)
[10:21:24.395]                           for (restart in restarts) {
[10:21:24.395]                             name <- restart$name
[10:21:24.395]                             if (is.null(name)) 
[10:21:24.395]                               next
[10:21:24.395]                             if (!grepl(pattern, name)) 
[10:21:24.395]                               next
[10:21:24.395]                             invokeRestart(restart)
[10:21:24.395]                             muffled <- TRUE
[10:21:24.395]                             break
[10:21:24.395]                           }
[10:21:24.395]                         }
[10:21:24.395]                       }
[10:21:24.395]                       invisible(muffled)
[10:21:24.395]                     }
[10:21:24.395]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.395]                   }
[10:21:24.395]                 }
[10:21:24.395]             }
[10:21:24.395]         }))
[10:21:24.395]     }, error = function(ex) {
[10:21:24.395]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:24.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.395]                 ...future.rng), started = ...future.startTime, 
[10:21:24.395]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:24.395]             version = "1.8"), class = "FutureResult")
[10:21:24.395]     }, finally = {
[10:21:24.395]         if (!identical(...future.workdir, getwd())) 
[10:21:24.395]             setwd(...future.workdir)
[10:21:24.395]         {
[10:21:24.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:24.395]                 ...future.oldOptions$nwarnings <- NULL
[10:21:24.395]             }
[10:21:24.395]             base::options(...future.oldOptions)
[10:21:24.395]             if (.Platform$OS.type == "windows") {
[10:21:24.395]                 old_names <- names(...future.oldEnvVars)
[10:21:24.395]                 envs <- base::Sys.getenv()
[10:21:24.395]                 names <- names(envs)
[10:21:24.395]                 common <- intersect(names, old_names)
[10:21:24.395]                 added <- setdiff(names, old_names)
[10:21:24.395]                 removed <- setdiff(old_names, names)
[10:21:24.395]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:24.395]                   envs[common]]
[10:21:24.395]                 NAMES <- toupper(changed)
[10:21:24.395]                 args <- list()
[10:21:24.395]                 for (kk in seq_along(NAMES)) {
[10:21:24.395]                   name <- changed[[kk]]
[10:21:24.395]                   NAME <- NAMES[[kk]]
[10:21:24.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.395]                     next
[10:21:24.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.395]                 }
[10:21:24.395]                 NAMES <- toupper(added)
[10:21:24.395]                 for (kk in seq_along(NAMES)) {
[10:21:24.395]                   name <- added[[kk]]
[10:21:24.395]                   NAME <- NAMES[[kk]]
[10:21:24.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.395]                     next
[10:21:24.395]                   args[[name]] <- ""
[10:21:24.395]                 }
[10:21:24.395]                 NAMES <- toupper(removed)
[10:21:24.395]                 for (kk in seq_along(NAMES)) {
[10:21:24.395]                   name <- removed[[kk]]
[10:21:24.395]                   NAME <- NAMES[[kk]]
[10:21:24.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.395]                     next
[10:21:24.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.395]                 }
[10:21:24.395]                 if (length(args) > 0) 
[10:21:24.395]                   base::do.call(base::Sys.setenv, args = args)
[10:21:24.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:24.395]             }
[10:21:24.395]             else {
[10:21:24.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:24.395]             }
[10:21:24.395]             {
[10:21:24.395]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:24.395]                   0L) {
[10:21:24.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:24.395]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:24.395]                   base::options(opts)
[10:21:24.395]                 }
[10:21:24.395]                 {
[10:21:24.395]                   {
[10:21:24.395]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:24.395]                     NULL
[10:21:24.395]                   }
[10:21:24.395]                   options(future.plan = NULL)
[10:21:24.395]                   if (is.na(NA_character_)) 
[10:21:24.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:24.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:24.395]                     .init = FALSE)
[10:21:24.395]                 }
[10:21:24.395]             }
[10:21:24.395]         }
[10:21:24.395]     })
[10:21:24.395]     if (TRUE) {
[10:21:24.395]         base::sink(type = "output", split = FALSE)
[10:21:24.395]         if (TRUE) {
[10:21:24.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:24.395]         }
[10:21:24.395]         else {
[10:21:24.395]             ...future.result["stdout"] <- base::list(NULL)
[10:21:24.395]         }
[10:21:24.395]         base::close(...future.stdout)
[10:21:24.395]         ...future.stdout <- NULL
[10:21:24.395]     }
[10:21:24.395]     ...future.result$conditions <- ...future.conditions
[10:21:24.395]     ...future.result$finished <- base::Sys.time()
[10:21:24.395]     ...future.result
[10:21:24.395] }
[10:21:24.398] MultisessionFuture started
[10:21:24.398] - Launch lazy future ... done
[10:21:24.398] run() for ‘MultisessionFuture’ ... done
[10:21:24.398] getGlobalsAndPackages() ...
[10:21:24.399] Searching for globals...
[10:21:24.399] - globals found: [1] ‘{’
[10:21:24.399] Searching for globals ... DONE
[10:21:24.399] Resolving globals: FALSE
[10:21:24.400] 
[10:21:24.400] 
[10:21:24.400] getGlobalsAndPackages() ... DONE
[10:21:24.400] run() for ‘Future’ ...
[10:21:24.400] - state: ‘created’
[10:21:24.400] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:24.414] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:24.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:24.414]   - Field: ‘node’
[10:21:24.414]   - Field: ‘label’
[10:21:24.414]   - Field: ‘local’
[10:21:24.415]   - Field: ‘owner’
[10:21:24.415]   - Field: ‘envir’
[10:21:24.415]   - Field: ‘workers’
[10:21:24.415]   - Field: ‘packages’
[10:21:24.415]   - Field: ‘gc’
[10:21:24.415]   - Field: ‘conditions’
[10:21:24.415]   - Field: ‘persistent’
[10:21:24.415]   - Field: ‘expr’
[10:21:24.415]   - Field: ‘uuid’
[10:21:24.415]   - Field: ‘seed’
[10:21:24.415]   - Field: ‘version’
[10:21:24.416]   - Field: ‘result’
[10:21:24.416]   - Field: ‘asynchronous’
[10:21:24.416]   - Field: ‘calls’
[10:21:24.416]   - Field: ‘globals’
[10:21:24.416]   - Field: ‘stdout’
[10:21:24.416]   - Field: ‘earlySignal’
[10:21:24.416]   - Field: ‘lazy’
[10:21:24.416]   - Field: ‘state’
[10:21:24.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:24.416] - Launch lazy future ...
[10:21:24.417] Packages needed by the future expression (n = 0): <none>
[10:21:24.417] Packages needed by future strategies (n = 0): <none>
[10:21:24.417] {
[10:21:24.417]     {
[10:21:24.417]         {
[10:21:24.417]             ...future.startTime <- base::Sys.time()
[10:21:24.417]             {
[10:21:24.417]                 {
[10:21:24.417]                   {
[10:21:24.417]                     {
[10:21:24.417]                       base::local({
[10:21:24.417]                         has_future <- base::requireNamespace("future", 
[10:21:24.417]                           quietly = TRUE)
[10:21:24.417]                         if (has_future) {
[10:21:24.417]                           ns <- base::getNamespace("future")
[10:21:24.417]                           version <- ns[[".package"]][["version"]]
[10:21:24.417]                           if (is.null(version)) 
[10:21:24.417]                             version <- utils::packageVersion("future")
[10:21:24.417]                         }
[10:21:24.417]                         else {
[10:21:24.417]                           version <- NULL
[10:21:24.417]                         }
[10:21:24.417]                         if (!has_future || version < "1.8.0") {
[10:21:24.417]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:24.417]                             "", base::R.version$version.string), 
[10:21:24.417]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:24.417]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:24.417]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:24.417]                               "release", "version")], collapse = " "), 
[10:21:24.417]                             hostname = base::Sys.info()[["nodename"]])
[10:21:24.417]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:24.417]                             info)
[10:21:24.417]                           info <- base::paste(info, collapse = "; ")
[10:21:24.417]                           if (!has_future) {
[10:21:24.417]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:24.417]                               info)
[10:21:24.417]                           }
[10:21:24.417]                           else {
[10:21:24.417]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:24.417]                               info, version)
[10:21:24.417]                           }
[10:21:24.417]                           base::stop(msg)
[10:21:24.417]                         }
[10:21:24.417]                       })
[10:21:24.417]                     }
[10:21:24.417]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:24.417]                     base::options(mc.cores = 1L)
[10:21:24.417]                   }
[10:21:24.417]                   ...future.strategy.old <- future::plan("list")
[10:21:24.417]                   options(future.plan = NULL)
[10:21:24.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:24.417]                 }
[10:21:24.417]                 ...future.workdir <- getwd()
[10:21:24.417]             }
[10:21:24.417]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:24.417]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:24.417]         }
[10:21:24.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:24.417]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[10:21:24.417]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:24.417]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:24.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:24.417]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:24.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:24.417]             base::names(...future.oldOptions))
[10:21:24.417]     }
[10:21:24.417]     if (FALSE) {
[10:21:24.417]     }
[10:21:24.417]     else {
[10:21:24.417]         if (TRUE) {
[10:21:24.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:24.417]                 open = "w")
[10:21:24.417]         }
[10:21:24.417]         else {
[10:21:24.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:24.417]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:24.417]         }
[10:21:24.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:24.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:24.417]             base::sink(type = "output", split = FALSE)
[10:21:24.417]             base::close(...future.stdout)
[10:21:24.417]         }, add = TRUE)
[10:21:24.417]     }
[10:21:24.417]     ...future.frame <- base::sys.nframe()
[10:21:24.417]     ...future.conditions <- base::list()
[10:21:24.417]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:24.417]     if (FALSE) {
[10:21:24.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:24.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:24.417]     }
[10:21:24.417]     ...future.result <- base::tryCatch({
[10:21:24.417]         base::withCallingHandlers({
[10:21:24.417]             ...future.value <- base::withVisible(base::local({
[10:21:24.417]                 ...future.makeSendCondition <- base::local({
[10:21:24.417]                   sendCondition <- NULL
[10:21:24.417]                   function(frame = 1L) {
[10:21:24.417]                     if (is.function(sendCondition)) 
[10:21:24.417]                       return(sendCondition)
[10:21:24.417]                     ns <- getNamespace("parallel")
[10:21:24.417]                     if (exists("sendData", mode = "function", 
[10:21:24.417]                       envir = ns)) {
[10:21:24.417]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:24.417]                         envir = ns)
[10:21:24.417]                       envir <- sys.frame(frame)
[10:21:24.417]                       master <- NULL
[10:21:24.417]                       while (!identical(envir, .GlobalEnv) && 
[10:21:24.417]                         !identical(envir, emptyenv())) {
[10:21:24.417]                         if (exists("master", mode = "list", envir = envir, 
[10:21:24.417]                           inherits = FALSE)) {
[10:21:24.417]                           master <- get("master", mode = "list", 
[10:21:24.417]                             envir = envir, inherits = FALSE)
[10:21:24.417]                           if (inherits(master, c("SOCKnode", 
[10:21:24.417]                             "SOCK0node"))) {
[10:21:24.417]                             sendCondition <<- function(cond) {
[10:21:24.417]                               data <- list(type = "VALUE", value = cond, 
[10:21:24.417]                                 success = TRUE)
[10:21:24.417]                               parallel_sendData(master, data)
[10:21:24.417]                             }
[10:21:24.417]                             return(sendCondition)
[10:21:24.417]                           }
[10:21:24.417]                         }
[10:21:24.417]                         frame <- frame + 1L
[10:21:24.417]                         envir <- sys.frame(frame)
[10:21:24.417]                       }
[10:21:24.417]                     }
[10:21:24.417]                     sendCondition <<- function(cond) NULL
[10:21:24.417]                   }
[10:21:24.417]                 })
[10:21:24.417]                 withCallingHandlers({
[10:21:24.417]                   {
[10:21:24.417]                     4
[10:21:24.417]                   }
[10:21:24.417]                 }, immediateCondition = function(cond) {
[10:21:24.417]                   sendCondition <- ...future.makeSendCondition()
[10:21:24.417]                   sendCondition(cond)
[10:21:24.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.417]                   {
[10:21:24.417]                     inherits <- base::inherits
[10:21:24.417]                     invokeRestart <- base::invokeRestart
[10:21:24.417]                     is.null <- base::is.null
[10:21:24.417]                     muffled <- FALSE
[10:21:24.417]                     if (inherits(cond, "message")) {
[10:21:24.417]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:24.417]                       if (muffled) 
[10:21:24.417]                         invokeRestart("muffleMessage")
[10:21:24.417]                     }
[10:21:24.417]                     else if (inherits(cond, "warning")) {
[10:21:24.417]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:24.417]                       if (muffled) 
[10:21:24.417]                         invokeRestart("muffleWarning")
[10:21:24.417]                     }
[10:21:24.417]                     else if (inherits(cond, "condition")) {
[10:21:24.417]                       if (!is.null(pattern)) {
[10:21:24.417]                         computeRestarts <- base::computeRestarts
[10:21:24.417]                         grepl <- base::grepl
[10:21:24.417]                         restarts <- computeRestarts(cond)
[10:21:24.417]                         for (restart in restarts) {
[10:21:24.417]                           name <- restart$name
[10:21:24.417]                           if (is.null(name)) 
[10:21:24.417]                             next
[10:21:24.417]                           if (!grepl(pattern, name)) 
[10:21:24.417]                             next
[10:21:24.417]                           invokeRestart(restart)
[10:21:24.417]                           muffled <- TRUE
[10:21:24.417]                           break
[10:21:24.417]                         }
[10:21:24.417]                       }
[10:21:24.417]                     }
[10:21:24.417]                     invisible(muffled)
[10:21:24.417]                   }
[10:21:24.417]                   muffleCondition(cond)
[10:21:24.417]                 })
[10:21:24.417]             }))
[10:21:24.417]             future::FutureResult(value = ...future.value$value, 
[10:21:24.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.417]                   ...future.rng), globalenv = if (FALSE) 
[10:21:24.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:24.417]                     ...future.globalenv.names))
[10:21:24.417]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:24.417]         }, condition = base::local({
[10:21:24.417]             c <- base::c
[10:21:24.417]             inherits <- base::inherits
[10:21:24.417]             invokeRestart <- base::invokeRestart
[10:21:24.417]             length <- base::length
[10:21:24.417]             list <- base::list
[10:21:24.417]             seq.int <- base::seq.int
[10:21:24.417]             signalCondition <- base::signalCondition
[10:21:24.417]             sys.calls <- base::sys.calls
[10:21:24.417]             `[[` <- base::`[[`
[10:21:24.417]             `+` <- base::`+`
[10:21:24.417]             `<<-` <- base::`<<-`
[10:21:24.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:24.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:24.417]                   3L)]
[10:21:24.417]             }
[10:21:24.417]             function(cond) {
[10:21:24.417]                 is_error <- inherits(cond, "error")
[10:21:24.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:24.417]                   NULL)
[10:21:24.417]                 if (is_error) {
[10:21:24.417]                   sessionInformation <- function() {
[10:21:24.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:24.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:24.417]                       search = base::search(), system = base::Sys.info())
[10:21:24.417]                   }
[10:21:24.417]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:24.417]                     cond$call), session = sessionInformation(), 
[10:21:24.417]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:24.417]                   signalCondition(cond)
[10:21:24.417]                 }
[10:21:24.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:24.417]                 "immediateCondition"))) {
[10:21:24.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:24.417]                   ...future.conditions[[length(...future.conditions) + 
[10:21:24.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:24.417]                   if (TRUE && !signal) {
[10:21:24.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.417]                     {
[10:21:24.417]                       inherits <- base::inherits
[10:21:24.417]                       invokeRestart <- base::invokeRestart
[10:21:24.417]                       is.null <- base::is.null
[10:21:24.417]                       muffled <- FALSE
[10:21:24.417]                       if (inherits(cond, "message")) {
[10:21:24.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.417]                         if (muffled) 
[10:21:24.417]                           invokeRestart("muffleMessage")
[10:21:24.417]                       }
[10:21:24.417]                       else if (inherits(cond, "warning")) {
[10:21:24.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.417]                         if (muffled) 
[10:21:24.417]                           invokeRestart("muffleWarning")
[10:21:24.417]                       }
[10:21:24.417]                       else if (inherits(cond, "condition")) {
[10:21:24.417]                         if (!is.null(pattern)) {
[10:21:24.417]                           computeRestarts <- base::computeRestarts
[10:21:24.417]                           grepl <- base::grepl
[10:21:24.417]                           restarts <- computeRestarts(cond)
[10:21:24.417]                           for (restart in restarts) {
[10:21:24.417]                             name <- restart$name
[10:21:24.417]                             if (is.null(name)) 
[10:21:24.417]                               next
[10:21:24.417]                             if (!grepl(pattern, name)) 
[10:21:24.417]                               next
[10:21:24.417]                             invokeRestart(restart)
[10:21:24.417]                             muffled <- TRUE
[10:21:24.417]                             break
[10:21:24.417]                           }
[10:21:24.417]                         }
[10:21:24.417]                       }
[10:21:24.417]                       invisible(muffled)
[10:21:24.417]                     }
[10:21:24.417]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.417]                   }
[10:21:24.417]                 }
[10:21:24.417]                 else {
[10:21:24.417]                   if (TRUE) {
[10:21:24.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:24.417]                     {
[10:21:24.417]                       inherits <- base::inherits
[10:21:24.417]                       invokeRestart <- base::invokeRestart
[10:21:24.417]                       is.null <- base::is.null
[10:21:24.417]                       muffled <- FALSE
[10:21:24.417]                       if (inherits(cond, "message")) {
[10:21:24.417]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:24.417]                         if (muffled) 
[10:21:24.417]                           invokeRestart("muffleMessage")
[10:21:24.417]                       }
[10:21:24.417]                       else if (inherits(cond, "warning")) {
[10:21:24.417]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:24.417]                         if (muffled) 
[10:21:24.417]                           invokeRestart("muffleWarning")
[10:21:24.417]                       }
[10:21:24.417]                       else if (inherits(cond, "condition")) {
[10:21:24.417]                         if (!is.null(pattern)) {
[10:21:24.417]                           computeRestarts <- base::computeRestarts
[10:21:24.417]                           grepl <- base::grepl
[10:21:24.417]                           restarts <- computeRestarts(cond)
[10:21:24.417]                           for (restart in restarts) {
[10:21:24.417]                             name <- restart$name
[10:21:24.417]                             if (is.null(name)) 
[10:21:24.417]                               next
[10:21:24.417]                             if (!grepl(pattern, name)) 
[10:21:24.417]                               next
[10:21:24.417]                             invokeRestart(restart)
[10:21:24.417]                             muffled <- TRUE
[10:21:24.417]                             break
[10:21:24.417]                           }
[10:21:24.417]                         }
[10:21:24.417]                       }
[10:21:24.417]                       invisible(muffled)
[10:21:24.417]                     }
[10:21:24.417]                     muffleCondition(cond, pattern = "^muffle")
[10:21:24.417]                   }
[10:21:24.417]                 }
[10:21:24.417]             }
[10:21:24.417]         }))
[10:21:24.417]     }, error = function(ex) {
[10:21:24.417]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:24.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:24.417]                 ...future.rng), started = ...future.startTime, 
[10:21:24.417]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:24.417]             version = "1.8"), class = "FutureResult")
[10:21:24.417]     }, finally = {
[10:21:24.417]         if (!identical(...future.workdir, getwd())) 
[10:21:24.417]             setwd(...future.workdir)
[10:21:24.417]         {
[10:21:24.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:24.417]                 ...future.oldOptions$nwarnings <- NULL
[10:21:24.417]             }
[10:21:24.417]             base::options(...future.oldOptions)
[10:21:24.417]             if (.Platform$OS.type == "windows") {
[10:21:24.417]                 old_names <- names(...future.oldEnvVars)
[10:21:24.417]                 envs <- base::Sys.getenv()
[10:21:24.417]                 names <- names(envs)
[10:21:24.417]                 common <- intersect(names, old_names)
[10:21:24.417]                 added <- setdiff(names, old_names)
[10:21:24.417]                 removed <- setdiff(old_names, names)
[10:21:24.417]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:24.417]                   envs[common]]
[10:21:24.417]                 NAMES <- toupper(changed)
[10:21:24.417]                 args <- list()
[10:21:24.417]                 for (kk in seq_along(NAMES)) {
[10:21:24.417]                   name <- changed[[kk]]
[10:21:24.417]                   NAME <- NAMES[[kk]]
[10:21:24.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.417]                     next
[10:21:24.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.417]                 }
[10:21:24.417]                 NAMES <- toupper(added)
[10:21:24.417]                 for (kk in seq_along(NAMES)) {
[10:21:24.417]                   name <- added[[kk]]
[10:21:24.417]                   NAME <- NAMES[[kk]]
[10:21:24.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.417]                     next
[10:21:24.417]                   args[[name]] <- ""
[10:21:24.417]                 }
[10:21:24.417]                 NAMES <- toupper(removed)
[10:21:24.417]                 for (kk in seq_along(NAMES)) {
[10:21:24.417]                   name <- removed[[kk]]
[10:21:24.417]                   NAME <- NAMES[[kk]]
[10:21:24.417]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:24.417]                     next
[10:21:24.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:24.417]                 }
[10:21:24.417]                 if (length(args) > 0) 
[10:21:24.417]                   base::do.call(base::Sys.setenv, args = args)
[10:21:24.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:24.417]             }
[10:21:24.417]             else {
[10:21:24.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:24.417]             }
[10:21:24.417]             {
[10:21:24.417]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:24.417]                   0L) {
[10:21:24.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:24.417]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:24.417]                   base::options(opts)
[10:21:24.417]                 }
[10:21:24.417]                 {
[10:21:24.417]                   {
[10:21:24.417]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:24.417]                     NULL
[10:21:24.417]                   }
[10:21:24.417]                   options(future.plan = NULL)
[10:21:24.417]                   if (is.na(NA_character_)) 
[10:21:24.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:24.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:24.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:24.417]                     .init = FALSE)
[10:21:24.417]                 }
[10:21:24.417]             }
[10:21:24.417]         }
[10:21:24.417]     })
[10:21:24.417]     if (TRUE) {
[10:21:24.417]         base::sink(type = "output", split = FALSE)
[10:21:24.417]         if (TRUE) {
[10:21:24.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:24.417]         }
[10:21:24.417]         else {
[10:21:24.417]             ...future.result["stdout"] <- base::list(NULL)
[10:21:24.417]         }
[10:21:24.417]         base::close(...future.stdout)
[10:21:24.417]         ...future.stdout <- NULL
[10:21:24.417]     }
[10:21:24.417]     ...future.result$conditions <- ...future.conditions
[10:21:24.417]     ...future.result$finished <- base::Sys.time()
[10:21:24.417]     ...future.result
[10:21:24.417] }
[10:21:24.419] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:24.430] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.430] - Validating connection of MultisessionFuture
[10:21:24.430] - received message: FutureResult
[10:21:24.431] - Received FutureResult
[10:21:24.431] - Erased future from FutureRegistry
[10:21:24.431] result() for ClusterFuture ...
[10:21:24.431] - result already collected: FutureResult
[10:21:24.431] result() for ClusterFuture ... done
[10:21:24.431] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:24.431] result() for ClusterFuture ...
[10:21:24.431] - result already collected: FutureResult
[10:21:24.431] result() for ClusterFuture ... done
[10:21:24.431] result() for ClusterFuture ...
[10:21:24.431] - result already collected: FutureResult
[10:21:24.432] result() for ClusterFuture ... done
[10:21:24.432] MultisessionFuture started
[10:21:24.433] - Launch lazy future ... done
[10:21:24.433] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55e8e6700fc8> 
Classes 'listenv', 'environment' <environment: 0x55e8e749dc88> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[10:21:24.441] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.441] - Validating connection of MultisessionFuture
[10:21:24.441] - received message: FutureResult
[10:21:24.441] - Received FutureResult
[10:21:24.442] - Erased future from FutureRegistry
[10:21:24.442] result() for ClusterFuture ...
[10:21:24.442] - result already collected: FutureResult
[10:21:24.442] result() for ClusterFuture ... done
[10:21:24.442] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[10:21:24.455] resolve() on list environment ...
[10:21:24.455]  recursive: 0
[10:21:24.456]  length: 6
[10:21:24.456]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[10:21:24.456] signalConditionsASAP(numeric, pos=1) ...
[10:21:24.456] - nx: 6
[10:21:24.456] - relay: TRUE
[10:21:24.456] - stdout: TRUE
[10:21:24.456] - signal: TRUE
[10:21:24.457] - resignal: FALSE
[10:21:24.457] - force: TRUE
[10:21:24.457] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.457] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.457]  - until=2
[10:21:24.457]  - relaying element #2
[10:21:24.457] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.457] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.457] signalConditionsASAP(NULL, pos=1) ... done
[10:21:24.457]  length: 5 (resolved future 1)
[10:21:24.457] Future #2
[10:21:24.458] result() for ClusterFuture ...
[10:21:24.458] - result already collected: FutureResult
[10:21:24.458] result() for ClusterFuture ... done
[10:21:24.458] result() for ClusterFuture ...
[10:21:24.458] - result already collected: FutureResult
[10:21:24.458] result() for ClusterFuture ... done
[10:21:24.458] signalConditionsASAP(MultisessionFuture, pos=2) ...
[10:21:24.458] - nx: 6
[10:21:24.458] - relay: TRUE
[10:21:24.458] - stdout: TRUE
[10:21:24.458] - signal: TRUE
[10:21:24.458] - resignal: FALSE
[10:21:24.458] - force: TRUE
[10:21:24.459] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.459] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[10:21:24.459]  - until=2
[10:21:24.459]  - relaying element #2
[10:21:24.459] result() for ClusterFuture ...
[10:21:24.459] - result already collected: FutureResult
[10:21:24.459] result() for ClusterFuture ... done
[10:21:24.459] result() for ClusterFuture ...
[10:21:24.459] - result already collected: FutureResult
[10:21:24.459] result() for ClusterFuture ... done
[10:21:24.459] result() for ClusterFuture ...
[10:21:24.459] - result already collected: FutureResult
[10:21:24.460] result() for ClusterFuture ... done
[10:21:24.460] result() for ClusterFuture ...
[10:21:24.460] - result already collected: FutureResult
[10:21:24.460] result() for ClusterFuture ... done
[10:21:24.460] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.460] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.460] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[10:21:24.460]  length: 4 (resolved future 2)
[10:21:24.460] Future #3
[10:21:24.460] result() for ClusterFuture ...
[10:21:24.460] - result already collected: FutureResult
[10:21:24.460] result() for ClusterFuture ... done
[10:21:24.461] result() for ClusterFuture ...
[10:21:24.461] - result already collected: FutureResult
[10:21:24.461] result() for ClusterFuture ... done
[10:21:24.461] signalConditionsASAP(MultisessionFuture, pos=3) ...
[10:21:24.461] - nx: 6
[10:21:24.461] - relay: TRUE
[10:21:24.461] - stdout: TRUE
[10:21:24.461] - signal: TRUE
[10:21:24.461] - resignal: FALSE
[10:21:24.461] - force: TRUE
[10:21:24.461] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.461] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[10:21:24.461]  - until=3
[10:21:24.462]  - relaying element #3
[10:21:24.462] result() for ClusterFuture ...
[10:21:24.462] - result already collected: FutureResult
[10:21:24.462] result() for ClusterFuture ... done
[10:21:24.462] result() for ClusterFuture ...
[10:21:24.462] - result already collected: FutureResult
[10:21:24.462] result() for ClusterFuture ... done
[10:21:24.462] result() for ClusterFuture ...
[10:21:24.462] - result already collected: FutureResult
[10:21:24.462] result() for ClusterFuture ... done
[10:21:24.462] result() for ClusterFuture ...
[10:21:24.462] - result already collected: FutureResult
[10:21:24.463] result() for ClusterFuture ... done
[10:21:24.463] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.463] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.463] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[10:21:24.463]  length: 3 (resolved future 3)
[10:21:24.473] signalConditionsASAP(NULL, pos=5) ...
[10:21:24.474] - nx: 6
[10:21:24.474] - relay: TRUE
[10:21:24.474] - stdout: TRUE
[10:21:24.474] - signal: TRUE
[10:21:24.474] - resignal: FALSE
[10:21:24.474] - force: TRUE
[10:21:24.474] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.474] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.474]  - until=6
[10:21:24.474]  - relaying element #4
[10:21:24.474]  - relaying element #6
[10:21:24.474] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:24.474] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.475] signalConditionsASAP(NULL, pos=5) ... done
[10:21:24.475]  length: 2 (resolved future 5)
[10:21:24.475] signalConditionsASAP(numeric, pos=6) ...
[10:21:24.475] - nx: 6
[10:21:24.475] - relay: TRUE
[10:21:24.475] - stdout: TRUE
[10:21:24.475] - signal: TRUE
[10:21:24.475] - resignal: FALSE
[10:21:24.475] - force: TRUE
[10:21:24.475] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[10:21:24.475] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.475]  - until=6
[10:21:24.476]  - relaying element #4
[10:21:24.476] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:24.476] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.476] signalConditionsASAP(NULL, pos=6) ... done
[10:21:24.476]  length: 1 (resolved future 6)
[10:21:24.487] receiveMessageFromWorker() for ClusterFuture ...
[10:21:24.487] - Validating connection of MultisessionFuture
[10:21:24.487] - received message: FutureResult
[10:21:24.487] - Received FutureResult
[10:21:24.487] - Erased future from FutureRegistry
[10:21:24.487] result() for ClusterFuture ...
[10:21:24.487] - result already collected: FutureResult
[10:21:24.487] result() for ClusterFuture ... done
[10:21:24.487] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:24.488] Future #4
[10:21:24.488] result() for ClusterFuture ...
[10:21:24.488] - result already collected: FutureResult
[10:21:24.488] result() for ClusterFuture ... done
[10:21:24.488] result() for ClusterFuture ...
[10:21:24.488] - result already collected: FutureResult
[10:21:24.488] result() for ClusterFuture ... done
[10:21:24.488] signalConditionsASAP(MultisessionFuture, pos=4) ...
[10:21:24.488] - nx: 6
[10:21:24.488] - relay: TRUE
[10:21:24.488] - stdout: TRUE
[10:21:24.488] - signal: TRUE
[10:21:24.489] - resignal: FALSE
[10:21:24.489] - force: TRUE
[10:21:24.489] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[10:21:24.489] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[10:21:24.489]  - until=6
[10:21:24.489]  - relaying element #4
[10:21:24.489] result() for ClusterFuture ...
[10:21:24.489] - result already collected: FutureResult
[10:21:24.489] result() for ClusterFuture ... done
[10:21:24.489] result() for ClusterFuture ...
[10:21:24.489] - result already collected: FutureResult
[10:21:24.489] result() for ClusterFuture ... done
[10:21:24.490] result() for ClusterFuture ...
[10:21:24.490] - result already collected: FutureResult
[10:21:24.490] result() for ClusterFuture ... done
[10:21:24.490] result() for ClusterFuture ...
[10:21:24.490] - result already collected: FutureResult
[10:21:24.490] result() for ClusterFuture ... done
[10:21:24.490] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.490] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:24.490] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[10:21:24.490]  length: 0 (resolved future 4)
[10:21:24.490] Relaying remaining futures
[10:21:24.491] signalConditionsASAP(NULL, pos=0) ...
[10:21:24.491] - nx: 6
[10:21:24.491] - relay: TRUE
[10:21:24.491] - stdout: TRUE
[10:21:24.491] - signal: TRUE
[10:21:24.491] - resignal: FALSE
[10:21:24.491] - force: TRUE
[10:21:24.491] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.491] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[10:21:24.491] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[10:21:24.491] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[10:21:24.491] signalConditionsASAP(NULL, pos=0) ... done
[10:21:24.492] resolve() on list environment ... DONE
[10:21:24.492] result() for ClusterFuture ...
[10:21:24.492] - result already collected: FutureResult
[10:21:24.492] result() for ClusterFuture ... done
[10:21:24.492] result() for ClusterFuture ...
[10:21:24.492] - result already collected: FutureResult
[10:21:24.492] result() for ClusterFuture ... done
[10:21:24.492] result() for ClusterFuture ...
[10:21:24.492] - result already collected: FutureResult
[10:21:24.492] result() for ClusterFuture ... done
[10:21:24.492] result() for ClusterFuture ...
[10:21:24.493] - result already collected: FutureResult
[10:21:24.493] result() for ClusterFuture ... done
[10:21:24.493] result() for ClusterFuture ...
[10:21:24.493] - result already collected: FutureResult
[10:21:24.493] result() for ClusterFuture ... done
[10:21:24.493] result() for ClusterFuture ...
[10:21:24.493] - result already collected: FutureResult
[10:21:24.493] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55e8e5476510> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[10:21:24.496] plan(): Setting new future strategy stack:
[10:21:24.496] List of future strategies:
[10:21:24.496] 1. FutureStrategy:
[10:21:24.496]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:24.496]    - tweaked: FALSE
[10:21:24.496]    - call: future::plan(oplan)
[10:21:24.497] plan(): nbrOfWorkers() = 1
> 
