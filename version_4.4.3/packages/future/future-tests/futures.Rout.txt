
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:27:50.067] plan(): Setting new future strategy stack:
[08:27:50.068] List of future strategies:
[08:27:50.068] 1. sequential:
[08:27:50.068]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.068]    - tweaked: FALSE
[08:27:50.068]    - call: future::plan("sequential")
[08:27:50.082] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[08:27:50.140] plan(): Setting new future strategy stack:
[08:27:50.140] List of future strategies:
[08:27:50.140] 1. sequential:
[08:27:50.140]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.140]    - tweaked: FALSE
[08:27:50.140]    - call: plan(strategy)
[08:27:50.152] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[08:27:50.153] getGlobalsAndPackages() ...
[08:27:50.153] Searching for globals...
[08:27:50.155] 
[08:27:50.155] Searching for globals ... DONE
[08:27:50.155] - globals: [0] <none>
[08:27:50.155] getGlobalsAndPackages() ... DONE
[08:27:50.156] run() for ‘Future’ ...
[08:27:50.156] - state: ‘created’
[08:27:50.156] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.156] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.157] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.157]   - Field: ‘label’
[08:27:50.157]   - Field: ‘local’
[08:27:50.157]   - Field: ‘owner’
[08:27:50.157]   - Field: ‘envir’
[08:27:50.157]   - Field: ‘packages’
[08:27:50.157]   - Field: ‘gc’
[08:27:50.157]   - Field: ‘conditions’
[08:27:50.157]   - Field: ‘expr’
[08:27:50.157]   - Field: ‘uuid’
[08:27:50.157]   - Field: ‘seed’
[08:27:50.158]   - Field: ‘version’
[08:27:50.158]   - Field: ‘result’
[08:27:50.158]   - Field: ‘asynchronous’
[08:27:50.158]   - Field: ‘calls’
[08:27:50.158]   - Field: ‘globals’
[08:27:50.158]   - Field: ‘stdout’
[08:27:50.158]   - Field: ‘earlySignal’
[08:27:50.158]   - Field: ‘lazy’
[08:27:50.158]   - Field: ‘state’
[08:27:50.158] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.158] - Launch lazy future ...
[08:27:50.159] Packages needed by the future expression (n = 0): <none>
[08:27:50.159] Packages needed by future strategies (n = 0): <none>
[08:27:50.160] {
[08:27:50.160]     {
[08:27:50.160]         {
[08:27:50.160]             ...future.startTime <- base::Sys.time()
[08:27:50.160]             {
[08:27:50.160]                 {
[08:27:50.160]                   {
[08:27:50.160]                     base::local({
[08:27:50.160]                       has_future <- base::requireNamespace("future", 
[08:27:50.160]                         quietly = TRUE)
[08:27:50.160]                       if (has_future) {
[08:27:50.160]                         ns <- base::getNamespace("future")
[08:27:50.160]                         version <- ns[[".package"]][["version"]]
[08:27:50.160]                         if (is.null(version)) 
[08:27:50.160]                           version <- utils::packageVersion("future")
[08:27:50.160]                       }
[08:27:50.160]                       else {
[08:27:50.160]                         version <- NULL
[08:27:50.160]                       }
[08:27:50.160]                       if (!has_future || version < "1.8.0") {
[08:27:50.160]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.160]                           "", base::R.version$version.string), 
[08:27:50.160]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.160]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.160]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.160]                             "release", "version")], collapse = " "), 
[08:27:50.160]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.160]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.160]                           info)
[08:27:50.160]                         info <- base::paste(info, collapse = "; ")
[08:27:50.160]                         if (!has_future) {
[08:27:50.160]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.160]                             info)
[08:27:50.160]                         }
[08:27:50.160]                         else {
[08:27:50.160]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.160]                             info, version)
[08:27:50.160]                         }
[08:27:50.160]                         base::stop(msg)
[08:27:50.160]                       }
[08:27:50.160]                     })
[08:27:50.160]                   }
[08:27:50.160]                   ...future.strategy.old <- future::plan("list")
[08:27:50.160]                   options(future.plan = NULL)
[08:27:50.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.160]                 }
[08:27:50.160]                 ...future.workdir <- getwd()
[08:27:50.160]             }
[08:27:50.160]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.160]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.160]         }
[08:27:50.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.160]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.160]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.160]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.160]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.160]             base::names(...future.oldOptions))
[08:27:50.160]     }
[08:27:50.160]     if (FALSE) {
[08:27:50.160]     }
[08:27:50.160]     else {
[08:27:50.160]         if (TRUE) {
[08:27:50.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.160]                 open = "w")
[08:27:50.160]         }
[08:27:50.160]         else {
[08:27:50.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.160]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.160]         }
[08:27:50.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.160]             base::sink(type = "output", split = FALSE)
[08:27:50.160]             base::close(...future.stdout)
[08:27:50.160]         }, add = TRUE)
[08:27:50.160]     }
[08:27:50.160]     ...future.frame <- base::sys.nframe()
[08:27:50.160]     ...future.conditions <- base::list()
[08:27:50.160]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.160]     if (FALSE) {
[08:27:50.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.160]     }
[08:27:50.160]     ...future.result <- base::tryCatch({
[08:27:50.160]         base::withCallingHandlers({
[08:27:50.160]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.160]             future::FutureResult(value = ...future.value$value, 
[08:27:50.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.160]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.160]                     ...future.globalenv.names))
[08:27:50.160]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.160]         }, condition = base::local({
[08:27:50.160]             c <- base::c
[08:27:50.160]             inherits <- base::inherits
[08:27:50.160]             invokeRestart <- base::invokeRestart
[08:27:50.160]             length <- base::length
[08:27:50.160]             list <- base::list
[08:27:50.160]             seq.int <- base::seq.int
[08:27:50.160]             signalCondition <- base::signalCondition
[08:27:50.160]             sys.calls <- base::sys.calls
[08:27:50.160]             `[[` <- base::`[[`
[08:27:50.160]             `+` <- base::`+`
[08:27:50.160]             `<<-` <- base::`<<-`
[08:27:50.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.160]                   3L)]
[08:27:50.160]             }
[08:27:50.160]             function(cond) {
[08:27:50.160]                 is_error <- inherits(cond, "error")
[08:27:50.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.160]                   NULL)
[08:27:50.160]                 if (is_error) {
[08:27:50.160]                   sessionInformation <- function() {
[08:27:50.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.160]                       search = base::search(), system = base::Sys.info())
[08:27:50.160]                   }
[08:27:50.160]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.160]                     cond$call), session = sessionInformation(), 
[08:27:50.160]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.160]                   signalCondition(cond)
[08:27:50.160]                 }
[08:27:50.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.160]                 "immediateCondition"))) {
[08:27:50.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.160]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.160]                   if (TRUE && !signal) {
[08:27:50.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.160]                     {
[08:27:50.160]                       inherits <- base::inherits
[08:27:50.160]                       invokeRestart <- base::invokeRestart
[08:27:50.160]                       is.null <- base::is.null
[08:27:50.160]                       muffled <- FALSE
[08:27:50.160]                       if (inherits(cond, "message")) {
[08:27:50.160]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.160]                         if (muffled) 
[08:27:50.160]                           invokeRestart("muffleMessage")
[08:27:50.160]                       }
[08:27:50.160]                       else if (inherits(cond, "warning")) {
[08:27:50.160]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.160]                         if (muffled) 
[08:27:50.160]                           invokeRestart("muffleWarning")
[08:27:50.160]                       }
[08:27:50.160]                       else if (inherits(cond, "condition")) {
[08:27:50.160]                         if (!is.null(pattern)) {
[08:27:50.160]                           computeRestarts <- base::computeRestarts
[08:27:50.160]                           grepl <- base::grepl
[08:27:50.160]                           restarts <- computeRestarts(cond)
[08:27:50.160]                           for (restart in restarts) {
[08:27:50.160]                             name <- restart$name
[08:27:50.160]                             if (is.null(name)) 
[08:27:50.160]                               next
[08:27:50.160]                             if (!grepl(pattern, name)) 
[08:27:50.160]                               next
[08:27:50.160]                             invokeRestart(restart)
[08:27:50.160]                             muffled <- TRUE
[08:27:50.160]                             break
[08:27:50.160]                           }
[08:27:50.160]                         }
[08:27:50.160]                       }
[08:27:50.160]                       invisible(muffled)
[08:27:50.160]                     }
[08:27:50.160]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.160]                   }
[08:27:50.160]                 }
[08:27:50.160]                 else {
[08:27:50.160]                   if (TRUE) {
[08:27:50.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.160]                     {
[08:27:50.160]                       inherits <- base::inherits
[08:27:50.160]                       invokeRestart <- base::invokeRestart
[08:27:50.160]                       is.null <- base::is.null
[08:27:50.160]                       muffled <- FALSE
[08:27:50.160]                       if (inherits(cond, "message")) {
[08:27:50.160]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.160]                         if (muffled) 
[08:27:50.160]                           invokeRestart("muffleMessage")
[08:27:50.160]                       }
[08:27:50.160]                       else if (inherits(cond, "warning")) {
[08:27:50.160]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.160]                         if (muffled) 
[08:27:50.160]                           invokeRestart("muffleWarning")
[08:27:50.160]                       }
[08:27:50.160]                       else if (inherits(cond, "condition")) {
[08:27:50.160]                         if (!is.null(pattern)) {
[08:27:50.160]                           computeRestarts <- base::computeRestarts
[08:27:50.160]                           grepl <- base::grepl
[08:27:50.160]                           restarts <- computeRestarts(cond)
[08:27:50.160]                           for (restart in restarts) {
[08:27:50.160]                             name <- restart$name
[08:27:50.160]                             if (is.null(name)) 
[08:27:50.160]                               next
[08:27:50.160]                             if (!grepl(pattern, name)) 
[08:27:50.160]                               next
[08:27:50.160]                             invokeRestart(restart)
[08:27:50.160]                             muffled <- TRUE
[08:27:50.160]                             break
[08:27:50.160]                           }
[08:27:50.160]                         }
[08:27:50.160]                       }
[08:27:50.160]                       invisible(muffled)
[08:27:50.160]                     }
[08:27:50.160]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.160]                   }
[08:27:50.160]                 }
[08:27:50.160]             }
[08:27:50.160]         }))
[08:27:50.160]     }, error = function(ex) {
[08:27:50.160]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.160]                 ...future.rng), started = ...future.startTime, 
[08:27:50.160]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.160]             version = "1.8"), class = "FutureResult")
[08:27:50.160]     }, finally = {
[08:27:50.160]         if (!identical(...future.workdir, getwd())) 
[08:27:50.160]             setwd(...future.workdir)
[08:27:50.160]         {
[08:27:50.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.160]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.160]             }
[08:27:50.160]             base::options(...future.oldOptions)
[08:27:50.160]             if (.Platform$OS.type == "windows") {
[08:27:50.160]                 old_names <- names(...future.oldEnvVars)
[08:27:50.160]                 envs <- base::Sys.getenv()
[08:27:50.160]                 names <- names(envs)
[08:27:50.160]                 common <- intersect(names, old_names)
[08:27:50.160]                 added <- setdiff(names, old_names)
[08:27:50.160]                 removed <- setdiff(old_names, names)
[08:27:50.160]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.160]                   envs[common]]
[08:27:50.160]                 NAMES <- toupper(changed)
[08:27:50.160]                 args <- list()
[08:27:50.160]                 for (kk in seq_along(NAMES)) {
[08:27:50.160]                   name <- changed[[kk]]
[08:27:50.160]                   NAME <- NAMES[[kk]]
[08:27:50.160]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.160]                     next
[08:27:50.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.160]                 }
[08:27:50.160]                 NAMES <- toupper(added)
[08:27:50.160]                 for (kk in seq_along(NAMES)) {
[08:27:50.160]                   name <- added[[kk]]
[08:27:50.160]                   NAME <- NAMES[[kk]]
[08:27:50.160]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.160]                     next
[08:27:50.160]                   args[[name]] <- ""
[08:27:50.160]                 }
[08:27:50.160]                 NAMES <- toupper(removed)
[08:27:50.160]                 for (kk in seq_along(NAMES)) {
[08:27:50.160]                   name <- removed[[kk]]
[08:27:50.160]                   NAME <- NAMES[[kk]]
[08:27:50.160]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.160]                     next
[08:27:50.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.160]                 }
[08:27:50.160]                 if (length(args) > 0) 
[08:27:50.160]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.160]             }
[08:27:50.160]             else {
[08:27:50.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.160]             }
[08:27:50.160]             {
[08:27:50.160]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.160]                   0L) {
[08:27:50.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.160]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.160]                   base::options(opts)
[08:27:50.160]                 }
[08:27:50.160]                 {
[08:27:50.160]                   {
[08:27:50.160]                     NULL
[08:27:50.160]                     RNGkind("Mersenne-Twister")
[08:27:50.160]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.160]                       inherits = FALSE)
[08:27:50.160]                   }
[08:27:50.160]                   options(future.plan = NULL)
[08:27:50.160]                   if (is.na(NA_character_)) 
[08:27:50.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.160]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.160]                     .init = FALSE)
[08:27:50.160]                 }
[08:27:50.160]             }
[08:27:50.160]         }
[08:27:50.160]     })
[08:27:50.160]     if (TRUE) {
[08:27:50.160]         base::sink(type = "output", split = FALSE)
[08:27:50.160]         if (TRUE) {
[08:27:50.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.160]         }
[08:27:50.160]         else {
[08:27:50.160]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.160]         }
[08:27:50.160]         base::close(...future.stdout)
[08:27:50.160]         ...future.stdout <- NULL
[08:27:50.160]     }
[08:27:50.160]     ...future.result$conditions <- ...future.conditions
[08:27:50.160]     ...future.result$finished <- base::Sys.time()
[08:27:50.160]     ...future.result
[08:27:50.160] }
[08:27:50.162] plan(): Setting new future strategy stack:
[08:27:50.162] List of future strategies:
[08:27:50.162] 1. sequential:
[08:27:50.162]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.162]    - tweaked: FALSE
[08:27:50.162]    - call: NULL
[08:27:50.162] plan(): nbrOfWorkers() = 1
[08:27:50.163] plan(): Setting new future strategy stack:
[08:27:50.163] List of future strategies:
[08:27:50.163] 1. sequential:
[08:27:50.163]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.163]    - tweaked: FALSE
[08:27:50.163]    - call: plan(strategy)
[08:27:50.164] plan(): nbrOfWorkers() = 1
[08:27:50.164] SequentialFuture started (and completed)
[08:27:50.164] - Launch lazy future ... done
[08:27:50.165] run() for ‘SequentialFuture’ ... done
[08:27:50.165] getGlobalsAndPackages() ...
[08:27:50.165] Searching for globals...
[08:27:50.165] 
[08:27:50.165] Searching for globals ... DONE
[08:27:50.165] - globals: [0] <none>
[08:27:50.165] getGlobalsAndPackages() ... DONE
[08:27:50.166] run() for ‘Future’ ...
[08:27:50.166] - state: ‘created’
[08:27:50.166] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.166] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.166] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.166]   - Field: ‘label’
[08:27:50.166]   - Field: ‘local’
[08:27:50.166]   - Field: ‘owner’
[08:27:50.166]   - Field: ‘envir’
[08:27:50.167]   - Field: ‘packages’
[08:27:50.167]   - Field: ‘gc’
[08:27:50.167]   - Field: ‘conditions’
[08:27:50.167]   - Field: ‘expr’
[08:27:50.167]   - Field: ‘uuid’
[08:27:50.167]   - Field: ‘seed’
[08:27:50.167]   - Field: ‘version’
[08:27:50.167]   - Field: ‘result’
[08:27:50.167]   - Field: ‘asynchronous’
[08:27:50.167]   - Field: ‘calls’
[08:27:50.167]   - Field: ‘globals’
[08:27:50.167]   - Field: ‘stdout’
[08:27:50.168]   - Field: ‘earlySignal’
[08:27:50.168]   - Field: ‘lazy’
[08:27:50.168]   - Field: ‘state’
[08:27:50.168] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.168] - Launch lazy future ...
[08:27:50.168] Packages needed by the future expression (n = 0): <none>
[08:27:50.168] Packages needed by future strategies (n = 0): <none>
[08:27:50.169] {
[08:27:50.169]     {
[08:27:50.169]         {
[08:27:50.169]             ...future.startTime <- base::Sys.time()
[08:27:50.169]             {
[08:27:50.169]                 {
[08:27:50.169]                   {
[08:27:50.169]                     base::local({
[08:27:50.169]                       has_future <- base::requireNamespace("future", 
[08:27:50.169]                         quietly = TRUE)
[08:27:50.169]                       if (has_future) {
[08:27:50.169]                         ns <- base::getNamespace("future")
[08:27:50.169]                         version <- ns[[".package"]][["version"]]
[08:27:50.169]                         if (is.null(version)) 
[08:27:50.169]                           version <- utils::packageVersion("future")
[08:27:50.169]                       }
[08:27:50.169]                       else {
[08:27:50.169]                         version <- NULL
[08:27:50.169]                       }
[08:27:50.169]                       if (!has_future || version < "1.8.0") {
[08:27:50.169]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.169]                           "", base::R.version$version.string), 
[08:27:50.169]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.169]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.169]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.169]                             "release", "version")], collapse = " "), 
[08:27:50.169]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.169]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.169]                           info)
[08:27:50.169]                         info <- base::paste(info, collapse = "; ")
[08:27:50.169]                         if (!has_future) {
[08:27:50.169]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.169]                             info)
[08:27:50.169]                         }
[08:27:50.169]                         else {
[08:27:50.169]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.169]                             info, version)
[08:27:50.169]                         }
[08:27:50.169]                         base::stop(msg)
[08:27:50.169]                       }
[08:27:50.169]                     })
[08:27:50.169]                   }
[08:27:50.169]                   ...future.strategy.old <- future::plan("list")
[08:27:50.169]                   options(future.plan = NULL)
[08:27:50.169]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.169]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.169]                 }
[08:27:50.169]                 ...future.workdir <- getwd()
[08:27:50.169]             }
[08:27:50.169]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.169]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.169]         }
[08:27:50.169]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.169]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.169]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.169]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.169]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.169]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.169]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.169]             base::names(...future.oldOptions))
[08:27:50.169]     }
[08:27:50.169]     if (FALSE) {
[08:27:50.169]     }
[08:27:50.169]     else {
[08:27:50.169]         if (TRUE) {
[08:27:50.169]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.169]                 open = "w")
[08:27:50.169]         }
[08:27:50.169]         else {
[08:27:50.169]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.169]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.169]         }
[08:27:50.169]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.169]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.169]             base::sink(type = "output", split = FALSE)
[08:27:50.169]             base::close(...future.stdout)
[08:27:50.169]         }, add = TRUE)
[08:27:50.169]     }
[08:27:50.169]     ...future.frame <- base::sys.nframe()
[08:27:50.169]     ...future.conditions <- base::list()
[08:27:50.169]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.169]     if (FALSE) {
[08:27:50.169]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.169]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.169]     }
[08:27:50.169]     ...future.result <- base::tryCatch({
[08:27:50.169]         base::withCallingHandlers({
[08:27:50.169]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.169]             future::FutureResult(value = ...future.value$value, 
[08:27:50.169]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.169]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.169]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.169]                     ...future.globalenv.names))
[08:27:50.169]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.169]         }, condition = base::local({
[08:27:50.169]             c <- base::c
[08:27:50.169]             inherits <- base::inherits
[08:27:50.169]             invokeRestart <- base::invokeRestart
[08:27:50.169]             length <- base::length
[08:27:50.169]             list <- base::list
[08:27:50.169]             seq.int <- base::seq.int
[08:27:50.169]             signalCondition <- base::signalCondition
[08:27:50.169]             sys.calls <- base::sys.calls
[08:27:50.169]             `[[` <- base::`[[`
[08:27:50.169]             `+` <- base::`+`
[08:27:50.169]             `<<-` <- base::`<<-`
[08:27:50.169]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.169]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.169]                   3L)]
[08:27:50.169]             }
[08:27:50.169]             function(cond) {
[08:27:50.169]                 is_error <- inherits(cond, "error")
[08:27:50.169]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.169]                   NULL)
[08:27:50.169]                 if (is_error) {
[08:27:50.169]                   sessionInformation <- function() {
[08:27:50.169]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.169]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.169]                       search = base::search(), system = base::Sys.info())
[08:27:50.169]                   }
[08:27:50.169]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.169]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.169]                     cond$call), session = sessionInformation(), 
[08:27:50.169]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.169]                   signalCondition(cond)
[08:27:50.169]                 }
[08:27:50.169]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.169]                 "immediateCondition"))) {
[08:27:50.169]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.169]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.169]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.169]                   if (TRUE && !signal) {
[08:27:50.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.169]                     {
[08:27:50.169]                       inherits <- base::inherits
[08:27:50.169]                       invokeRestart <- base::invokeRestart
[08:27:50.169]                       is.null <- base::is.null
[08:27:50.169]                       muffled <- FALSE
[08:27:50.169]                       if (inherits(cond, "message")) {
[08:27:50.169]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.169]                         if (muffled) 
[08:27:50.169]                           invokeRestart("muffleMessage")
[08:27:50.169]                       }
[08:27:50.169]                       else if (inherits(cond, "warning")) {
[08:27:50.169]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.169]                         if (muffled) 
[08:27:50.169]                           invokeRestart("muffleWarning")
[08:27:50.169]                       }
[08:27:50.169]                       else if (inherits(cond, "condition")) {
[08:27:50.169]                         if (!is.null(pattern)) {
[08:27:50.169]                           computeRestarts <- base::computeRestarts
[08:27:50.169]                           grepl <- base::grepl
[08:27:50.169]                           restarts <- computeRestarts(cond)
[08:27:50.169]                           for (restart in restarts) {
[08:27:50.169]                             name <- restart$name
[08:27:50.169]                             if (is.null(name)) 
[08:27:50.169]                               next
[08:27:50.169]                             if (!grepl(pattern, name)) 
[08:27:50.169]                               next
[08:27:50.169]                             invokeRestart(restart)
[08:27:50.169]                             muffled <- TRUE
[08:27:50.169]                             break
[08:27:50.169]                           }
[08:27:50.169]                         }
[08:27:50.169]                       }
[08:27:50.169]                       invisible(muffled)
[08:27:50.169]                     }
[08:27:50.169]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.169]                   }
[08:27:50.169]                 }
[08:27:50.169]                 else {
[08:27:50.169]                   if (TRUE) {
[08:27:50.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.169]                     {
[08:27:50.169]                       inherits <- base::inherits
[08:27:50.169]                       invokeRestart <- base::invokeRestart
[08:27:50.169]                       is.null <- base::is.null
[08:27:50.169]                       muffled <- FALSE
[08:27:50.169]                       if (inherits(cond, "message")) {
[08:27:50.169]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.169]                         if (muffled) 
[08:27:50.169]                           invokeRestart("muffleMessage")
[08:27:50.169]                       }
[08:27:50.169]                       else if (inherits(cond, "warning")) {
[08:27:50.169]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.169]                         if (muffled) 
[08:27:50.169]                           invokeRestart("muffleWarning")
[08:27:50.169]                       }
[08:27:50.169]                       else if (inherits(cond, "condition")) {
[08:27:50.169]                         if (!is.null(pattern)) {
[08:27:50.169]                           computeRestarts <- base::computeRestarts
[08:27:50.169]                           grepl <- base::grepl
[08:27:50.169]                           restarts <- computeRestarts(cond)
[08:27:50.169]                           for (restart in restarts) {
[08:27:50.169]                             name <- restart$name
[08:27:50.169]                             if (is.null(name)) 
[08:27:50.169]                               next
[08:27:50.169]                             if (!grepl(pattern, name)) 
[08:27:50.169]                               next
[08:27:50.169]                             invokeRestart(restart)
[08:27:50.169]                             muffled <- TRUE
[08:27:50.169]                             break
[08:27:50.169]                           }
[08:27:50.169]                         }
[08:27:50.169]                       }
[08:27:50.169]                       invisible(muffled)
[08:27:50.169]                     }
[08:27:50.169]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.169]                   }
[08:27:50.169]                 }
[08:27:50.169]             }
[08:27:50.169]         }))
[08:27:50.169]     }, error = function(ex) {
[08:27:50.169]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.169]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.169]                 ...future.rng), started = ...future.startTime, 
[08:27:50.169]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.169]             version = "1.8"), class = "FutureResult")
[08:27:50.169]     }, finally = {
[08:27:50.169]         if (!identical(...future.workdir, getwd())) 
[08:27:50.169]             setwd(...future.workdir)
[08:27:50.169]         {
[08:27:50.169]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.169]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.169]             }
[08:27:50.169]             base::options(...future.oldOptions)
[08:27:50.169]             if (.Platform$OS.type == "windows") {
[08:27:50.169]                 old_names <- names(...future.oldEnvVars)
[08:27:50.169]                 envs <- base::Sys.getenv()
[08:27:50.169]                 names <- names(envs)
[08:27:50.169]                 common <- intersect(names, old_names)
[08:27:50.169]                 added <- setdiff(names, old_names)
[08:27:50.169]                 removed <- setdiff(old_names, names)
[08:27:50.169]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.169]                   envs[common]]
[08:27:50.169]                 NAMES <- toupper(changed)
[08:27:50.169]                 args <- list()
[08:27:50.169]                 for (kk in seq_along(NAMES)) {
[08:27:50.169]                   name <- changed[[kk]]
[08:27:50.169]                   NAME <- NAMES[[kk]]
[08:27:50.169]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.169]                     next
[08:27:50.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.169]                 }
[08:27:50.169]                 NAMES <- toupper(added)
[08:27:50.169]                 for (kk in seq_along(NAMES)) {
[08:27:50.169]                   name <- added[[kk]]
[08:27:50.169]                   NAME <- NAMES[[kk]]
[08:27:50.169]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.169]                     next
[08:27:50.169]                   args[[name]] <- ""
[08:27:50.169]                 }
[08:27:50.169]                 NAMES <- toupper(removed)
[08:27:50.169]                 for (kk in seq_along(NAMES)) {
[08:27:50.169]                   name <- removed[[kk]]
[08:27:50.169]                   NAME <- NAMES[[kk]]
[08:27:50.169]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.169]                     next
[08:27:50.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.169]                 }
[08:27:50.169]                 if (length(args) > 0) 
[08:27:50.169]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.169]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.169]             }
[08:27:50.169]             else {
[08:27:50.169]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.169]             }
[08:27:50.169]             {
[08:27:50.169]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.169]                   0L) {
[08:27:50.169]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.169]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.169]                   base::options(opts)
[08:27:50.169]                 }
[08:27:50.169]                 {
[08:27:50.169]                   {
[08:27:50.169]                     NULL
[08:27:50.169]                     RNGkind("Mersenne-Twister")
[08:27:50.169]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.169]                       inherits = FALSE)
[08:27:50.169]                   }
[08:27:50.169]                   options(future.plan = NULL)
[08:27:50.169]                   if (is.na(NA_character_)) 
[08:27:50.169]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.169]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.169]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.169]                     .init = FALSE)
[08:27:50.169]                 }
[08:27:50.169]             }
[08:27:50.169]         }
[08:27:50.169]     })
[08:27:50.169]     if (TRUE) {
[08:27:50.169]         base::sink(type = "output", split = FALSE)
[08:27:50.169]         if (TRUE) {
[08:27:50.169]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.169]         }
[08:27:50.169]         else {
[08:27:50.169]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.169]         }
[08:27:50.169]         base::close(...future.stdout)
[08:27:50.169]         ...future.stdout <- NULL
[08:27:50.169]     }
[08:27:50.169]     ...future.result$conditions <- ...future.conditions
[08:27:50.169]     ...future.result$finished <- base::Sys.time()
[08:27:50.169]     ...future.result
[08:27:50.169] }
[08:27:50.170] plan(): Setting new future strategy stack:
[08:27:50.170] List of future strategies:
[08:27:50.170] 1. sequential:
[08:27:50.170]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.170]    - tweaked: FALSE
[08:27:50.170]    - call: NULL
[08:27:50.171] plan(): nbrOfWorkers() = 1
[08:27:50.172] plan(): Setting new future strategy stack:
[08:27:50.172] List of future strategies:
[08:27:50.172] 1. sequential:
[08:27:50.172]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.172]    - tweaked: FALSE
[08:27:50.172]    - call: plan(strategy)
[08:27:50.172] plan(): nbrOfWorkers() = 1
[08:27:50.172] SequentialFuture started (and completed)
[08:27:50.172] - Launch lazy future ... done
[08:27:50.172] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d85f562490> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d8609c4f20> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d85f562490> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d8609c4f20> 
 $  : NULL
 $  : NULL
 $  : num 6
[08:27:50.178] resolved() for ‘SequentialFuture’ ...
[08:27:50.178] - state: ‘finished’
[08:27:50.178] - run: TRUE
[08:27:50.178] - result: ‘FutureResult’
[08:27:50.178] resolved() for ‘SequentialFuture’ ... done
[08:27:50.178] resolved() for ‘SequentialFuture’ ...
[08:27:50.178] - state: ‘finished’
[08:27:50.178] - run: TRUE
[08:27:50.179] - result: ‘FutureResult’
[08:27:50.179] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:50.180] resolve() on list ...
[08:27:50.180]  recursive: 0
[08:27:50.180]  length: 6
[08:27:50.180]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:50.180] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.180] - nx: 6
[08:27:50.180] - relay: TRUE
[08:27:50.180] - stdout: TRUE
[08:27:50.180] - signal: TRUE
[08:27:50.180] - resignal: FALSE
[08:27:50.181] - force: TRUE
[08:27:50.181] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.181] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.181]  - until=2
[08:27:50.181]  - relaying element #2
[08:27:50.181] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.181] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.181] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.181]  length: 5 (resolved future 1)
[08:27:50.181] resolved() for ‘SequentialFuture’ ...
[08:27:50.181] - state: ‘finished’
[08:27:50.181] - run: TRUE
[08:27:50.182] - result: ‘FutureResult’
[08:27:50.182] resolved() for ‘SequentialFuture’ ... done
[08:27:50.182] Future #2
[08:27:50.182] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.182] - nx: 6
[08:27:50.182] - relay: TRUE
[08:27:50.182] - stdout: TRUE
[08:27:50.182] - signal: TRUE
[08:27:50.182] - resignal: FALSE
[08:27:50.183] - force: TRUE
[08:27:50.185] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.185] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.185]  - until=2
[08:27:50.185]  - relaying element #2
[08:27:50.185] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.185] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.186] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.186]  length: 4 (resolved future 2)
[08:27:50.186] resolved() for ‘SequentialFuture’ ...
[08:27:50.186] - state: ‘finished’
[08:27:50.186] - run: TRUE
[08:27:50.186] - result: ‘FutureResult’
[08:27:50.186] resolved() for ‘SequentialFuture’ ... done
[08:27:50.186] Future #3
[08:27:50.187] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.187] - nx: 6
[08:27:50.187] - relay: TRUE
[08:27:50.187] - stdout: TRUE
[08:27:50.187] - signal: TRUE
[08:27:50.187] - resignal: FALSE
[08:27:50.187] - force: TRUE
[08:27:50.187] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.187] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.187]  - until=3
[08:27:50.187]  - relaying element #3
[08:27:50.187] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.188] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.188] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.188]  length: 3 (resolved future 3)
[08:27:50.188] signalConditionsASAP(NULL, pos=4) ...
[08:27:50.188] - nx: 6
[08:27:50.188] - relay: TRUE
[08:27:50.188] - stdout: TRUE
[08:27:50.188] - signal: TRUE
[08:27:50.188] - resignal: FALSE
[08:27:50.188] - force: TRUE
[08:27:50.188] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.188] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.189]  - until=5
[08:27:50.189]  - relaying element #5
[08:27:50.189] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.189] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.189] signalConditionsASAP(NULL, pos=4) ... done
[08:27:50.189]  length: 2 (resolved future 4)
[08:27:50.189] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.189] - nx: 6
[08:27:50.189] - relay: TRUE
[08:27:50.189] - stdout: TRUE
[08:27:50.189] - signal: TRUE
[08:27:50.189] - resignal: FALSE
[08:27:50.190] - force: TRUE
[08:27:50.190] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.190] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.190]  - until=6
[08:27:50.190]  - relaying element #6
[08:27:50.190] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.190] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.190] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.190]  length: 1 (resolved future 5)
[08:27:50.190] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.190] - nx: 6
[08:27:50.190] - relay: TRUE
[08:27:50.190] - stdout: TRUE
[08:27:50.191] - signal: TRUE
[08:27:50.191] - resignal: FALSE
[08:27:50.191] - force: TRUE
[08:27:50.191] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.191] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.191]  - until=6
[08:27:50.191] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.191] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.191] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.191]  length: 0 (resolved future 6)
[08:27:50.191] Relaying remaining futures
[08:27:50.191] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.192] - nx: 6
[08:27:50.192] - relay: TRUE
[08:27:50.192] - stdout: TRUE
[08:27:50.192] - signal: TRUE
[08:27:50.192] - resignal: FALSE
[08:27:50.192] - force: TRUE
[08:27:50.192] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.192] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:50.192] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.192] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.192] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.192] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[08:27:50.194] getGlobalsAndPackages() ...
[08:27:50.195] Searching for globals...
[08:27:50.195] 
[08:27:50.195] Searching for globals ... DONE
[08:27:50.195] - globals: [0] <none>
[08:27:50.195] getGlobalsAndPackages() ... DONE
[08:27:50.195] run() for ‘Future’ ...
[08:27:50.195] - state: ‘created’
[08:27:50.196] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.196] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.196] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.196]   - Field: ‘label’
[08:27:50.196]   - Field: ‘local’
[08:27:50.196]   - Field: ‘owner’
[08:27:50.196]   - Field: ‘envir’
[08:27:50.196]   - Field: ‘packages’
[08:27:50.196]   - Field: ‘gc’
[08:27:50.197]   - Field: ‘conditions’
[08:27:50.197]   - Field: ‘expr’
[08:27:50.197]   - Field: ‘uuid’
[08:27:50.197]   - Field: ‘seed’
[08:27:50.197]   - Field: ‘version’
[08:27:50.197]   - Field: ‘result’
[08:27:50.197]   - Field: ‘asynchronous’
[08:27:50.197]   - Field: ‘calls’
[08:27:50.197]   - Field: ‘globals’
[08:27:50.197]   - Field: ‘stdout’
[08:27:50.197]   - Field: ‘earlySignal’
[08:27:50.197]   - Field: ‘lazy’
[08:27:50.198]   - Field: ‘state’
[08:27:50.198] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.198] - Launch lazy future ...
[08:27:50.198] Packages needed by the future expression (n = 0): <none>
[08:27:50.198] Packages needed by future strategies (n = 0): <none>
[08:27:50.198] {
[08:27:50.198]     {
[08:27:50.198]         {
[08:27:50.198]             ...future.startTime <- base::Sys.time()
[08:27:50.198]             {
[08:27:50.198]                 {
[08:27:50.198]                   {
[08:27:50.198]                     base::local({
[08:27:50.198]                       has_future <- base::requireNamespace("future", 
[08:27:50.198]                         quietly = TRUE)
[08:27:50.198]                       if (has_future) {
[08:27:50.198]                         ns <- base::getNamespace("future")
[08:27:50.198]                         version <- ns[[".package"]][["version"]]
[08:27:50.198]                         if (is.null(version)) 
[08:27:50.198]                           version <- utils::packageVersion("future")
[08:27:50.198]                       }
[08:27:50.198]                       else {
[08:27:50.198]                         version <- NULL
[08:27:50.198]                       }
[08:27:50.198]                       if (!has_future || version < "1.8.0") {
[08:27:50.198]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.198]                           "", base::R.version$version.string), 
[08:27:50.198]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.198]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.198]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.198]                             "release", "version")], collapse = " "), 
[08:27:50.198]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.198]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.198]                           info)
[08:27:50.198]                         info <- base::paste(info, collapse = "; ")
[08:27:50.198]                         if (!has_future) {
[08:27:50.198]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.198]                             info)
[08:27:50.198]                         }
[08:27:50.198]                         else {
[08:27:50.198]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.198]                             info, version)
[08:27:50.198]                         }
[08:27:50.198]                         base::stop(msg)
[08:27:50.198]                       }
[08:27:50.198]                     })
[08:27:50.198]                   }
[08:27:50.198]                   ...future.strategy.old <- future::plan("list")
[08:27:50.198]                   options(future.plan = NULL)
[08:27:50.198]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.198]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.198]                 }
[08:27:50.198]                 ...future.workdir <- getwd()
[08:27:50.198]             }
[08:27:50.198]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.198]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.198]         }
[08:27:50.198]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.198]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.198]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.198]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.198]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.198]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.198]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.198]             base::names(...future.oldOptions))
[08:27:50.198]     }
[08:27:50.198]     if (FALSE) {
[08:27:50.198]     }
[08:27:50.198]     else {
[08:27:50.198]         if (TRUE) {
[08:27:50.198]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.198]                 open = "w")
[08:27:50.198]         }
[08:27:50.198]         else {
[08:27:50.198]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.198]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.198]         }
[08:27:50.198]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.198]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.198]             base::sink(type = "output", split = FALSE)
[08:27:50.198]             base::close(...future.stdout)
[08:27:50.198]         }, add = TRUE)
[08:27:50.198]     }
[08:27:50.198]     ...future.frame <- base::sys.nframe()
[08:27:50.198]     ...future.conditions <- base::list()
[08:27:50.198]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.198]     if (FALSE) {
[08:27:50.198]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.198]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.198]     }
[08:27:50.198]     ...future.result <- base::tryCatch({
[08:27:50.198]         base::withCallingHandlers({
[08:27:50.198]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.198]             future::FutureResult(value = ...future.value$value, 
[08:27:50.198]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.198]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.198]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.198]                     ...future.globalenv.names))
[08:27:50.198]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.198]         }, condition = base::local({
[08:27:50.198]             c <- base::c
[08:27:50.198]             inherits <- base::inherits
[08:27:50.198]             invokeRestart <- base::invokeRestart
[08:27:50.198]             length <- base::length
[08:27:50.198]             list <- base::list
[08:27:50.198]             seq.int <- base::seq.int
[08:27:50.198]             signalCondition <- base::signalCondition
[08:27:50.198]             sys.calls <- base::sys.calls
[08:27:50.198]             `[[` <- base::`[[`
[08:27:50.198]             `+` <- base::`+`
[08:27:50.198]             `<<-` <- base::`<<-`
[08:27:50.198]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.198]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.198]                   3L)]
[08:27:50.198]             }
[08:27:50.198]             function(cond) {
[08:27:50.198]                 is_error <- inherits(cond, "error")
[08:27:50.198]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.198]                   NULL)
[08:27:50.198]                 if (is_error) {
[08:27:50.198]                   sessionInformation <- function() {
[08:27:50.198]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.198]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.198]                       search = base::search(), system = base::Sys.info())
[08:27:50.198]                   }
[08:27:50.198]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.198]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.198]                     cond$call), session = sessionInformation(), 
[08:27:50.198]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.198]                   signalCondition(cond)
[08:27:50.198]                 }
[08:27:50.198]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.198]                 "immediateCondition"))) {
[08:27:50.198]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.198]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.198]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.198]                   if (TRUE && !signal) {
[08:27:50.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.198]                     {
[08:27:50.198]                       inherits <- base::inherits
[08:27:50.198]                       invokeRestart <- base::invokeRestart
[08:27:50.198]                       is.null <- base::is.null
[08:27:50.198]                       muffled <- FALSE
[08:27:50.198]                       if (inherits(cond, "message")) {
[08:27:50.198]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.198]                         if (muffled) 
[08:27:50.198]                           invokeRestart("muffleMessage")
[08:27:50.198]                       }
[08:27:50.198]                       else if (inherits(cond, "warning")) {
[08:27:50.198]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.198]                         if (muffled) 
[08:27:50.198]                           invokeRestart("muffleWarning")
[08:27:50.198]                       }
[08:27:50.198]                       else if (inherits(cond, "condition")) {
[08:27:50.198]                         if (!is.null(pattern)) {
[08:27:50.198]                           computeRestarts <- base::computeRestarts
[08:27:50.198]                           grepl <- base::grepl
[08:27:50.198]                           restarts <- computeRestarts(cond)
[08:27:50.198]                           for (restart in restarts) {
[08:27:50.198]                             name <- restart$name
[08:27:50.198]                             if (is.null(name)) 
[08:27:50.198]                               next
[08:27:50.198]                             if (!grepl(pattern, name)) 
[08:27:50.198]                               next
[08:27:50.198]                             invokeRestart(restart)
[08:27:50.198]                             muffled <- TRUE
[08:27:50.198]                             break
[08:27:50.198]                           }
[08:27:50.198]                         }
[08:27:50.198]                       }
[08:27:50.198]                       invisible(muffled)
[08:27:50.198]                     }
[08:27:50.198]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.198]                   }
[08:27:50.198]                 }
[08:27:50.198]                 else {
[08:27:50.198]                   if (TRUE) {
[08:27:50.198]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.198]                     {
[08:27:50.198]                       inherits <- base::inherits
[08:27:50.198]                       invokeRestart <- base::invokeRestart
[08:27:50.198]                       is.null <- base::is.null
[08:27:50.198]                       muffled <- FALSE
[08:27:50.198]                       if (inherits(cond, "message")) {
[08:27:50.198]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.198]                         if (muffled) 
[08:27:50.198]                           invokeRestart("muffleMessage")
[08:27:50.198]                       }
[08:27:50.198]                       else if (inherits(cond, "warning")) {
[08:27:50.198]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.198]                         if (muffled) 
[08:27:50.198]                           invokeRestart("muffleWarning")
[08:27:50.198]                       }
[08:27:50.198]                       else if (inherits(cond, "condition")) {
[08:27:50.198]                         if (!is.null(pattern)) {
[08:27:50.198]                           computeRestarts <- base::computeRestarts
[08:27:50.198]                           grepl <- base::grepl
[08:27:50.198]                           restarts <- computeRestarts(cond)
[08:27:50.198]                           for (restart in restarts) {
[08:27:50.198]                             name <- restart$name
[08:27:50.198]                             if (is.null(name)) 
[08:27:50.198]                               next
[08:27:50.198]                             if (!grepl(pattern, name)) 
[08:27:50.198]                               next
[08:27:50.198]                             invokeRestart(restart)
[08:27:50.198]                             muffled <- TRUE
[08:27:50.198]                             break
[08:27:50.198]                           }
[08:27:50.198]                         }
[08:27:50.198]                       }
[08:27:50.198]                       invisible(muffled)
[08:27:50.198]                     }
[08:27:50.198]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.198]                   }
[08:27:50.198]                 }
[08:27:50.198]             }
[08:27:50.198]         }))
[08:27:50.198]     }, error = function(ex) {
[08:27:50.198]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.198]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.198]                 ...future.rng), started = ...future.startTime, 
[08:27:50.198]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.198]             version = "1.8"), class = "FutureResult")
[08:27:50.198]     }, finally = {
[08:27:50.198]         if (!identical(...future.workdir, getwd())) 
[08:27:50.198]             setwd(...future.workdir)
[08:27:50.198]         {
[08:27:50.198]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.198]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.198]             }
[08:27:50.198]             base::options(...future.oldOptions)
[08:27:50.198]             if (.Platform$OS.type == "windows") {
[08:27:50.198]                 old_names <- names(...future.oldEnvVars)
[08:27:50.198]                 envs <- base::Sys.getenv()
[08:27:50.198]                 names <- names(envs)
[08:27:50.198]                 common <- intersect(names, old_names)
[08:27:50.198]                 added <- setdiff(names, old_names)
[08:27:50.198]                 removed <- setdiff(old_names, names)
[08:27:50.198]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.198]                   envs[common]]
[08:27:50.198]                 NAMES <- toupper(changed)
[08:27:50.198]                 args <- list()
[08:27:50.198]                 for (kk in seq_along(NAMES)) {
[08:27:50.198]                   name <- changed[[kk]]
[08:27:50.198]                   NAME <- NAMES[[kk]]
[08:27:50.198]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.198]                     next
[08:27:50.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.198]                 }
[08:27:50.198]                 NAMES <- toupper(added)
[08:27:50.198]                 for (kk in seq_along(NAMES)) {
[08:27:50.198]                   name <- added[[kk]]
[08:27:50.198]                   NAME <- NAMES[[kk]]
[08:27:50.198]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.198]                     next
[08:27:50.198]                   args[[name]] <- ""
[08:27:50.198]                 }
[08:27:50.198]                 NAMES <- toupper(removed)
[08:27:50.198]                 for (kk in seq_along(NAMES)) {
[08:27:50.198]                   name <- removed[[kk]]
[08:27:50.198]                   NAME <- NAMES[[kk]]
[08:27:50.198]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.198]                     next
[08:27:50.198]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.198]                 }
[08:27:50.198]                 if (length(args) > 0) 
[08:27:50.198]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.198]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.198]             }
[08:27:50.198]             else {
[08:27:50.198]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.198]             }
[08:27:50.198]             {
[08:27:50.198]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.198]                   0L) {
[08:27:50.198]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.198]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.198]                   base::options(opts)
[08:27:50.198]                 }
[08:27:50.198]                 {
[08:27:50.198]                   {
[08:27:50.198]                     NULL
[08:27:50.198]                     RNGkind("Mersenne-Twister")
[08:27:50.198]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.198]                       inherits = FALSE)
[08:27:50.198]                   }
[08:27:50.198]                   options(future.plan = NULL)
[08:27:50.198]                   if (is.na(NA_character_)) 
[08:27:50.198]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.198]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.198]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.198]                     .init = FALSE)
[08:27:50.198]                 }
[08:27:50.198]             }
[08:27:50.198]         }
[08:27:50.198]     })
[08:27:50.198]     if (TRUE) {
[08:27:50.198]         base::sink(type = "output", split = FALSE)
[08:27:50.198]         if (TRUE) {
[08:27:50.198]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.198]         }
[08:27:50.198]         else {
[08:27:50.198]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.198]         }
[08:27:50.198]         base::close(...future.stdout)
[08:27:50.198]         ...future.stdout <- NULL
[08:27:50.198]     }
[08:27:50.198]     ...future.result$conditions <- ...future.conditions
[08:27:50.198]     ...future.result$finished <- base::Sys.time()
[08:27:50.198]     ...future.result
[08:27:50.198] }
[08:27:50.200] plan(): Setting new future strategy stack:
[08:27:50.200] List of future strategies:
[08:27:50.200] 1. sequential:
[08:27:50.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.200]    - tweaked: FALSE
[08:27:50.200]    - call: NULL
[08:27:50.201] plan(): nbrOfWorkers() = 1
[08:27:50.201] plan(): Setting new future strategy stack:
[08:27:50.202] List of future strategies:
[08:27:50.202] 1. sequential:
[08:27:50.202]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.202]    - tweaked: FALSE
[08:27:50.202]    - call: plan(strategy)
[08:27:50.202] plan(): nbrOfWorkers() = 1
[08:27:50.202] SequentialFuture started (and completed)
[08:27:50.202] - Launch lazy future ... done
[08:27:50.202] run() for ‘SequentialFuture’ ... done
[08:27:50.202] getGlobalsAndPackages() ...
[08:27:50.203] Searching for globals...
[08:27:50.203] 
[08:27:50.203] Searching for globals ... DONE
[08:27:50.203] - globals: [0] <none>
[08:27:50.203] getGlobalsAndPackages() ... DONE
[08:27:50.203] run() for ‘Future’ ...
[08:27:50.203] - state: ‘created’
[08:27:50.204] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.204] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.204] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.204]   - Field: ‘label’
[08:27:50.204]   - Field: ‘local’
[08:27:50.204]   - Field: ‘owner’
[08:27:50.204]   - Field: ‘envir’
[08:27:50.204]   - Field: ‘packages’
[08:27:50.204]   - Field: ‘gc’
[08:27:50.204]   - Field: ‘conditions’
[08:27:50.205]   - Field: ‘expr’
[08:27:50.205]   - Field: ‘uuid’
[08:27:50.205]   - Field: ‘seed’
[08:27:50.205]   - Field: ‘version’
[08:27:50.205]   - Field: ‘result’
[08:27:50.205]   - Field: ‘asynchronous’
[08:27:50.205]   - Field: ‘calls’
[08:27:50.205]   - Field: ‘globals’
[08:27:50.205]   - Field: ‘stdout’
[08:27:50.205]   - Field: ‘earlySignal’
[08:27:50.205]   - Field: ‘lazy’
[08:27:50.205]   - Field: ‘state’
[08:27:50.206] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.206] - Launch lazy future ...
[08:27:50.206] Packages needed by the future expression (n = 0): <none>
[08:27:50.206] Packages needed by future strategies (n = 0): <none>
[08:27:50.206] {
[08:27:50.206]     {
[08:27:50.206]         {
[08:27:50.206]             ...future.startTime <- base::Sys.time()
[08:27:50.206]             {
[08:27:50.206]                 {
[08:27:50.206]                   {
[08:27:50.206]                     base::local({
[08:27:50.206]                       has_future <- base::requireNamespace("future", 
[08:27:50.206]                         quietly = TRUE)
[08:27:50.206]                       if (has_future) {
[08:27:50.206]                         ns <- base::getNamespace("future")
[08:27:50.206]                         version <- ns[[".package"]][["version"]]
[08:27:50.206]                         if (is.null(version)) 
[08:27:50.206]                           version <- utils::packageVersion("future")
[08:27:50.206]                       }
[08:27:50.206]                       else {
[08:27:50.206]                         version <- NULL
[08:27:50.206]                       }
[08:27:50.206]                       if (!has_future || version < "1.8.0") {
[08:27:50.206]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.206]                           "", base::R.version$version.string), 
[08:27:50.206]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.206]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.206]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.206]                             "release", "version")], collapse = " "), 
[08:27:50.206]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.206]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.206]                           info)
[08:27:50.206]                         info <- base::paste(info, collapse = "; ")
[08:27:50.206]                         if (!has_future) {
[08:27:50.206]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.206]                             info)
[08:27:50.206]                         }
[08:27:50.206]                         else {
[08:27:50.206]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.206]                             info, version)
[08:27:50.206]                         }
[08:27:50.206]                         base::stop(msg)
[08:27:50.206]                       }
[08:27:50.206]                     })
[08:27:50.206]                   }
[08:27:50.206]                   ...future.strategy.old <- future::plan("list")
[08:27:50.206]                   options(future.plan = NULL)
[08:27:50.206]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.206]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.206]                 }
[08:27:50.206]                 ...future.workdir <- getwd()
[08:27:50.206]             }
[08:27:50.206]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.206]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.206]         }
[08:27:50.206]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.206]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.206]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.206]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.206]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.206]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.206]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.206]             base::names(...future.oldOptions))
[08:27:50.206]     }
[08:27:50.206]     if (FALSE) {
[08:27:50.206]     }
[08:27:50.206]     else {
[08:27:50.206]         if (TRUE) {
[08:27:50.206]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.206]                 open = "w")
[08:27:50.206]         }
[08:27:50.206]         else {
[08:27:50.206]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.206]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.206]         }
[08:27:50.206]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.206]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.206]             base::sink(type = "output", split = FALSE)
[08:27:50.206]             base::close(...future.stdout)
[08:27:50.206]         }, add = TRUE)
[08:27:50.206]     }
[08:27:50.206]     ...future.frame <- base::sys.nframe()
[08:27:50.206]     ...future.conditions <- base::list()
[08:27:50.206]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.206]     if (FALSE) {
[08:27:50.206]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.206]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.206]     }
[08:27:50.206]     ...future.result <- base::tryCatch({
[08:27:50.206]         base::withCallingHandlers({
[08:27:50.206]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.206]             future::FutureResult(value = ...future.value$value, 
[08:27:50.206]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.206]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.206]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.206]                     ...future.globalenv.names))
[08:27:50.206]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.206]         }, condition = base::local({
[08:27:50.206]             c <- base::c
[08:27:50.206]             inherits <- base::inherits
[08:27:50.206]             invokeRestart <- base::invokeRestart
[08:27:50.206]             length <- base::length
[08:27:50.206]             list <- base::list
[08:27:50.206]             seq.int <- base::seq.int
[08:27:50.206]             signalCondition <- base::signalCondition
[08:27:50.206]             sys.calls <- base::sys.calls
[08:27:50.206]             `[[` <- base::`[[`
[08:27:50.206]             `+` <- base::`+`
[08:27:50.206]             `<<-` <- base::`<<-`
[08:27:50.206]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.206]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.206]                   3L)]
[08:27:50.206]             }
[08:27:50.206]             function(cond) {
[08:27:50.206]                 is_error <- inherits(cond, "error")
[08:27:50.206]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.206]                   NULL)
[08:27:50.206]                 if (is_error) {
[08:27:50.206]                   sessionInformation <- function() {
[08:27:50.206]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.206]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.206]                       search = base::search(), system = base::Sys.info())
[08:27:50.206]                   }
[08:27:50.206]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.206]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.206]                     cond$call), session = sessionInformation(), 
[08:27:50.206]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.206]                   signalCondition(cond)
[08:27:50.206]                 }
[08:27:50.206]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.206]                 "immediateCondition"))) {
[08:27:50.206]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.206]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.206]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.206]                   if (TRUE && !signal) {
[08:27:50.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.206]                     {
[08:27:50.206]                       inherits <- base::inherits
[08:27:50.206]                       invokeRestart <- base::invokeRestart
[08:27:50.206]                       is.null <- base::is.null
[08:27:50.206]                       muffled <- FALSE
[08:27:50.206]                       if (inherits(cond, "message")) {
[08:27:50.206]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.206]                         if (muffled) 
[08:27:50.206]                           invokeRestart("muffleMessage")
[08:27:50.206]                       }
[08:27:50.206]                       else if (inherits(cond, "warning")) {
[08:27:50.206]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.206]                         if (muffled) 
[08:27:50.206]                           invokeRestart("muffleWarning")
[08:27:50.206]                       }
[08:27:50.206]                       else if (inherits(cond, "condition")) {
[08:27:50.206]                         if (!is.null(pattern)) {
[08:27:50.206]                           computeRestarts <- base::computeRestarts
[08:27:50.206]                           grepl <- base::grepl
[08:27:50.206]                           restarts <- computeRestarts(cond)
[08:27:50.206]                           for (restart in restarts) {
[08:27:50.206]                             name <- restart$name
[08:27:50.206]                             if (is.null(name)) 
[08:27:50.206]                               next
[08:27:50.206]                             if (!grepl(pattern, name)) 
[08:27:50.206]                               next
[08:27:50.206]                             invokeRestart(restart)
[08:27:50.206]                             muffled <- TRUE
[08:27:50.206]                             break
[08:27:50.206]                           }
[08:27:50.206]                         }
[08:27:50.206]                       }
[08:27:50.206]                       invisible(muffled)
[08:27:50.206]                     }
[08:27:50.206]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.206]                   }
[08:27:50.206]                 }
[08:27:50.206]                 else {
[08:27:50.206]                   if (TRUE) {
[08:27:50.206]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.206]                     {
[08:27:50.206]                       inherits <- base::inherits
[08:27:50.206]                       invokeRestart <- base::invokeRestart
[08:27:50.206]                       is.null <- base::is.null
[08:27:50.206]                       muffled <- FALSE
[08:27:50.206]                       if (inherits(cond, "message")) {
[08:27:50.206]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.206]                         if (muffled) 
[08:27:50.206]                           invokeRestart("muffleMessage")
[08:27:50.206]                       }
[08:27:50.206]                       else if (inherits(cond, "warning")) {
[08:27:50.206]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.206]                         if (muffled) 
[08:27:50.206]                           invokeRestart("muffleWarning")
[08:27:50.206]                       }
[08:27:50.206]                       else if (inherits(cond, "condition")) {
[08:27:50.206]                         if (!is.null(pattern)) {
[08:27:50.206]                           computeRestarts <- base::computeRestarts
[08:27:50.206]                           grepl <- base::grepl
[08:27:50.206]                           restarts <- computeRestarts(cond)
[08:27:50.206]                           for (restart in restarts) {
[08:27:50.206]                             name <- restart$name
[08:27:50.206]                             if (is.null(name)) 
[08:27:50.206]                               next
[08:27:50.206]                             if (!grepl(pattern, name)) 
[08:27:50.206]                               next
[08:27:50.206]                             invokeRestart(restart)
[08:27:50.206]                             muffled <- TRUE
[08:27:50.206]                             break
[08:27:50.206]                           }
[08:27:50.206]                         }
[08:27:50.206]                       }
[08:27:50.206]                       invisible(muffled)
[08:27:50.206]                     }
[08:27:50.206]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.206]                   }
[08:27:50.206]                 }
[08:27:50.206]             }
[08:27:50.206]         }))
[08:27:50.206]     }, error = function(ex) {
[08:27:50.206]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.206]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.206]                 ...future.rng), started = ...future.startTime, 
[08:27:50.206]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.206]             version = "1.8"), class = "FutureResult")
[08:27:50.206]     }, finally = {
[08:27:50.206]         if (!identical(...future.workdir, getwd())) 
[08:27:50.206]             setwd(...future.workdir)
[08:27:50.206]         {
[08:27:50.206]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.206]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.206]             }
[08:27:50.206]             base::options(...future.oldOptions)
[08:27:50.206]             if (.Platform$OS.type == "windows") {
[08:27:50.206]                 old_names <- names(...future.oldEnvVars)
[08:27:50.206]                 envs <- base::Sys.getenv()
[08:27:50.206]                 names <- names(envs)
[08:27:50.206]                 common <- intersect(names, old_names)
[08:27:50.206]                 added <- setdiff(names, old_names)
[08:27:50.206]                 removed <- setdiff(old_names, names)
[08:27:50.206]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.206]                   envs[common]]
[08:27:50.206]                 NAMES <- toupper(changed)
[08:27:50.206]                 args <- list()
[08:27:50.206]                 for (kk in seq_along(NAMES)) {
[08:27:50.206]                   name <- changed[[kk]]
[08:27:50.206]                   NAME <- NAMES[[kk]]
[08:27:50.206]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.206]                     next
[08:27:50.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.206]                 }
[08:27:50.206]                 NAMES <- toupper(added)
[08:27:50.206]                 for (kk in seq_along(NAMES)) {
[08:27:50.206]                   name <- added[[kk]]
[08:27:50.206]                   NAME <- NAMES[[kk]]
[08:27:50.206]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.206]                     next
[08:27:50.206]                   args[[name]] <- ""
[08:27:50.206]                 }
[08:27:50.206]                 NAMES <- toupper(removed)
[08:27:50.206]                 for (kk in seq_along(NAMES)) {
[08:27:50.206]                   name <- removed[[kk]]
[08:27:50.206]                   NAME <- NAMES[[kk]]
[08:27:50.206]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.206]                     next
[08:27:50.206]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.206]                 }
[08:27:50.206]                 if (length(args) > 0) 
[08:27:50.206]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.206]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.206]             }
[08:27:50.206]             else {
[08:27:50.206]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.206]             }
[08:27:50.206]             {
[08:27:50.206]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.206]                   0L) {
[08:27:50.206]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.206]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.206]                   base::options(opts)
[08:27:50.206]                 }
[08:27:50.206]                 {
[08:27:50.206]                   {
[08:27:50.206]                     NULL
[08:27:50.206]                     RNGkind("Mersenne-Twister")
[08:27:50.206]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.206]                       inherits = FALSE)
[08:27:50.206]                   }
[08:27:50.206]                   options(future.plan = NULL)
[08:27:50.206]                   if (is.na(NA_character_)) 
[08:27:50.206]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.206]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.206]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.206]                     .init = FALSE)
[08:27:50.206]                 }
[08:27:50.206]             }
[08:27:50.206]         }
[08:27:50.206]     })
[08:27:50.206]     if (TRUE) {
[08:27:50.206]         base::sink(type = "output", split = FALSE)
[08:27:50.206]         if (TRUE) {
[08:27:50.206]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.206]         }
[08:27:50.206]         else {
[08:27:50.206]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.206]         }
[08:27:50.206]         base::close(...future.stdout)
[08:27:50.206]         ...future.stdout <- NULL
[08:27:50.206]     }
[08:27:50.206]     ...future.result$conditions <- ...future.conditions
[08:27:50.206]     ...future.result$finished <- base::Sys.time()
[08:27:50.206]     ...future.result
[08:27:50.206] }
[08:27:50.208] plan(): Setting new future strategy stack:
[08:27:50.208] List of future strategies:
[08:27:50.208] 1. sequential:
[08:27:50.208]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.208]    - tweaked: FALSE
[08:27:50.208]    - call: NULL
[08:27:50.209] plan(): nbrOfWorkers() = 1
[08:27:50.209] plan(): Setting new future strategy stack:
[08:27:50.209] List of future strategies:
[08:27:50.209] 1. sequential:
[08:27:50.209]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.209]    - tweaked: FALSE
[08:27:50.209]    - call: plan(strategy)
[08:27:50.210] plan(): nbrOfWorkers() = 1
[08:27:50.210] SequentialFuture started (and completed)
[08:27:50.210] - Launch lazy future ... done
[08:27:50.210] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860917b60> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860d1b6c8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860917b60> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860d1b6c8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[08:27:50.217] resolved() for ‘SequentialFuture’ ...
[08:27:50.217] - state: ‘finished’
[08:27:50.217] - run: TRUE
[08:27:50.217] - result: ‘FutureResult’
[08:27:50.217] resolved() for ‘SequentialFuture’ ... done
[08:27:50.217] resolved() for ‘SequentialFuture’ ...
[08:27:50.217] - state: ‘finished’
[08:27:50.217] - run: TRUE
[08:27:50.217] - result: ‘FutureResult’
[08:27:50.217] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:50.219] resolve() on list ...
[08:27:50.219]  recursive: 0
[08:27:50.219]  length: 6
[08:27:50.219]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:50.220] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.220] - nx: 6
[08:27:50.220] - relay: TRUE
[08:27:50.220] - stdout: TRUE
[08:27:50.220] - signal: TRUE
[08:27:50.220] - resignal: FALSE
[08:27:50.220] - force: TRUE
[08:27:50.220] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.220] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.220]  - until=2
[08:27:50.220]  - relaying element #2
[08:27:50.220] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.221] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.221] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.221]  length: 5 (resolved future 1)
[08:27:50.221] resolved() for ‘SequentialFuture’ ...
[08:27:50.221] - state: ‘finished’
[08:27:50.221] - run: TRUE
[08:27:50.221] - result: ‘FutureResult’
[08:27:50.221] resolved() for ‘SequentialFuture’ ... done
[08:27:50.221] Future #2
[08:27:50.221] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.221] - nx: 6
[08:27:50.222] - relay: TRUE
[08:27:50.222] - stdout: TRUE
[08:27:50.222] - signal: TRUE
[08:27:50.222] - resignal: FALSE
[08:27:50.222] - force: TRUE
[08:27:50.222] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.222] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.222]  - until=2
[08:27:50.222]  - relaying element #2
[08:27:50.222] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.222] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.223] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.223]  length: 4 (resolved future 2)
[08:27:50.223] resolved() for ‘SequentialFuture’ ...
[08:27:50.223] - state: ‘finished’
[08:27:50.223] - run: TRUE
[08:27:50.223] - result: ‘FutureResult’
[08:27:50.223] resolved() for ‘SequentialFuture’ ... done
[08:27:50.223] Future #3
[08:27:50.223] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.223] - nx: 6
[08:27:50.223] - relay: TRUE
[08:27:50.224] - stdout: TRUE
[08:27:50.224] - signal: TRUE
[08:27:50.224] - resignal: FALSE
[08:27:50.224] - force: TRUE
[08:27:50.224] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.224] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.224]  - until=3
[08:27:50.224]  - relaying element #3
[08:27:50.224] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.224] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.224] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.225]  length: 3 (resolved future 3)
[08:27:50.225] signalConditionsASAP(NULL, pos=4) ...
[08:27:50.225] - nx: 6
[08:27:50.225] - relay: TRUE
[08:27:50.225] - stdout: TRUE
[08:27:50.225] - signal: TRUE
[08:27:50.225] - resignal: FALSE
[08:27:50.225] - force: TRUE
[08:27:50.225] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.225] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.225]  - until=5
[08:27:50.225]  - relaying element #5
[08:27:50.225] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.226] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.226] signalConditionsASAP(NULL, pos=4) ... done
[08:27:50.226]  length: 2 (resolved future 4)
[08:27:50.226] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.226] - nx: 6
[08:27:50.226] - relay: TRUE
[08:27:50.226] - stdout: TRUE
[08:27:50.226] - signal: TRUE
[08:27:50.226] - resignal: FALSE
[08:27:50.226] - force: TRUE
[08:27:50.226] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.226] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.227]  - until=6
[08:27:50.227]  - relaying element #6
[08:27:50.227] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.227] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.227] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.227]  length: 1 (resolved future 5)
[08:27:50.227] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.227] - nx: 6
[08:27:50.227] - relay: TRUE
[08:27:50.227] - stdout: TRUE
[08:27:50.227] - signal: TRUE
[08:27:50.227] - resignal: FALSE
[08:27:50.227] - force: TRUE
[08:27:50.228] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.228] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.228]  - until=6
[08:27:50.228] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.228] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.228] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.228]  length: 0 (resolved future 6)
[08:27:50.228] Relaying remaining futures
[08:27:50.228] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.228] - nx: 6
[08:27:50.228] - relay: TRUE
[08:27:50.228] - stdout: TRUE
[08:27:50.228] - signal: TRUE
[08:27:50.229] - resignal: FALSE
[08:27:50.229] - force: TRUE
[08:27:50.229] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.229] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:50.229] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.229] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.229] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.229] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[08:27:50.232] getGlobalsAndPackages() ...
[08:27:50.232] Searching for globals...
[08:27:50.233] 
[08:27:50.233] Searching for globals ... DONE
[08:27:50.233] - globals: [0] <none>
[08:27:50.233] getGlobalsAndPackages() ... DONE
[08:27:50.233] run() for ‘Future’ ...
[08:27:50.233] - state: ‘created’
[08:27:50.233] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.234] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.234] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.234]   - Field: ‘label’
[08:27:50.234]   - Field: ‘local’
[08:27:50.234]   - Field: ‘owner’
[08:27:50.234]   - Field: ‘envir’
[08:27:50.234]   - Field: ‘packages’
[08:27:50.234]   - Field: ‘gc’
[08:27:50.234]   - Field: ‘conditions’
[08:27:50.234]   - Field: ‘expr’
[08:27:50.234]   - Field: ‘uuid’
[08:27:50.235]   - Field: ‘seed’
[08:27:50.235]   - Field: ‘version’
[08:27:50.235]   - Field: ‘result’
[08:27:50.235]   - Field: ‘asynchronous’
[08:27:50.235]   - Field: ‘calls’
[08:27:50.235]   - Field: ‘globals’
[08:27:50.235]   - Field: ‘stdout’
[08:27:50.235]   - Field: ‘earlySignal’
[08:27:50.235]   - Field: ‘lazy’
[08:27:50.235]   - Field: ‘state’
[08:27:50.235] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.236] - Launch lazy future ...
[08:27:50.236] Packages needed by the future expression (n = 0): <none>
[08:27:50.236] Packages needed by future strategies (n = 0): <none>
[08:27:50.236] {
[08:27:50.236]     {
[08:27:50.236]         {
[08:27:50.236]             ...future.startTime <- base::Sys.time()
[08:27:50.236]             {
[08:27:50.236]                 {
[08:27:50.236]                   {
[08:27:50.236]                     base::local({
[08:27:50.236]                       has_future <- base::requireNamespace("future", 
[08:27:50.236]                         quietly = TRUE)
[08:27:50.236]                       if (has_future) {
[08:27:50.236]                         ns <- base::getNamespace("future")
[08:27:50.236]                         version <- ns[[".package"]][["version"]]
[08:27:50.236]                         if (is.null(version)) 
[08:27:50.236]                           version <- utils::packageVersion("future")
[08:27:50.236]                       }
[08:27:50.236]                       else {
[08:27:50.236]                         version <- NULL
[08:27:50.236]                       }
[08:27:50.236]                       if (!has_future || version < "1.8.0") {
[08:27:50.236]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.236]                           "", base::R.version$version.string), 
[08:27:50.236]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.236]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.236]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.236]                             "release", "version")], collapse = " "), 
[08:27:50.236]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.236]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.236]                           info)
[08:27:50.236]                         info <- base::paste(info, collapse = "; ")
[08:27:50.236]                         if (!has_future) {
[08:27:50.236]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.236]                             info)
[08:27:50.236]                         }
[08:27:50.236]                         else {
[08:27:50.236]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.236]                             info, version)
[08:27:50.236]                         }
[08:27:50.236]                         base::stop(msg)
[08:27:50.236]                       }
[08:27:50.236]                     })
[08:27:50.236]                   }
[08:27:50.236]                   ...future.strategy.old <- future::plan("list")
[08:27:50.236]                   options(future.plan = NULL)
[08:27:50.236]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.236]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.236]                 }
[08:27:50.236]                 ...future.workdir <- getwd()
[08:27:50.236]             }
[08:27:50.236]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.236]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.236]         }
[08:27:50.236]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.236]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.236]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.236]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.236]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.236]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.236]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.236]             base::names(...future.oldOptions))
[08:27:50.236]     }
[08:27:50.236]     if (FALSE) {
[08:27:50.236]     }
[08:27:50.236]     else {
[08:27:50.236]         if (TRUE) {
[08:27:50.236]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.236]                 open = "w")
[08:27:50.236]         }
[08:27:50.236]         else {
[08:27:50.236]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.236]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.236]         }
[08:27:50.236]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.236]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.236]             base::sink(type = "output", split = FALSE)
[08:27:50.236]             base::close(...future.stdout)
[08:27:50.236]         }, add = TRUE)
[08:27:50.236]     }
[08:27:50.236]     ...future.frame <- base::sys.nframe()
[08:27:50.236]     ...future.conditions <- base::list()
[08:27:50.236]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.236]     if (FALSE) {
[08:27:50.236]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.236]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.236]     }
[08:27:50.236]     ...future.result <- base::tryCatch({
[08:27:50.236]         base::withCallingHandlers({
[08:27:50.236]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.236]             future::FutureResult(value = ...future.value$value, 
[08:27:50.236]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.236]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.236]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.236]                     ...future.globalenv.names))
[08:27:50.236]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.236]         }, condition = base::local({
[08:27:50.236]             c <- base::c
[08:27:50.236]             inherits <- base::inherits
[08:27:50.236]             invokeRestart <- base::invokeRestart
[08:27:50.236]             length <- base::length
[08:27:50.236]             list <- base::list
[08:27:50.236]             seq.int <- base::seq.int
[08:27:50.236]             signalCondition <- base::signalCondition
[08:27:50.236]             sys.calls <- base::sys.calls
[08:27:50.236]             `[[` <- base::`[[`
[08:27:50.236]             `+` <- base::`+`
[08:27:50.236]             `<<-` <- base::`<<-`
[08:27:50.236]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.236]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.236]                   3L)]
[08:27:50.236]             }
[08:27:50.236]             function(cond) {
[08:27:50.236]                 is_error <- inherits(cond, "error")
[08:27:50.236]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.236]                   NULL)
[08:27:50.236]                 if (is_error) {
[08:27:50.236]                   sessionInformation <- function() {
[08:27:50.236]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.236]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.236]                       search = base::search(), system = base::Sys.info())
[08:27:50.236]                   }
[08:27:50.236]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.236]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.236]                     cond$call), session = sessionInformation(), 
[08:27:50.236]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.236]                   signalCondition(cond)
[08:27:50.236]                 }
[08:27:50.236]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.236]                 "immediateCondition"))) {
[08:27:50.236]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.236]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.236]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.236]                   if (TRUE && !signal) {
[08:27:50.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.236]                     {
[08:27:50.236]                       inherits <- base::inherits
[08:27:50.236]                       invokeRestart <- base::invokeRestart
[08:27:50.236]                       is.null <- base::is.null
[08:27:50.236]                       muffled <- FALSE
[08:27:50.236]                       if (inherits(cond, "message")) {
[08:27:50.236]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.236]                         if (muffled) 
[08:27:50.236]                           invokeRestart("muffleMessage")
[08:27:50.236]                       }
[08:27:50.236]                       else if (inherits(cond, "warning")) {
[08:27:50.236]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.236]                         if (muffled) 
[08:27:50.236]                           invokeRestart("muffleWarning")
[08:27:50.236]                       }
[08:27:50.236]                       else if (inherits(cond, "condition")) {
[08:27:50.236]                         if (!is.null(pattern)) {
[08:27:50.236]                           computeRestarts <- base::computeRestarts
[08:27:50.236]                           grepl <- base::grepl
[08:27:50.236]                           restarts <- computeRestarts(cond)
[08:27:50.236]                           for (restart in restarts) {
[08:27:50.236]                             name <- restart$name
[08:27:50.236]                             if (is.null(name)) 
[08:27:50.236]                               next
[08:27:50.236]                             if (!grepl(pattern, name)) 
[08:27:50.236]                               next
[08:27:50.236]                             invokeRestart(restart)
[08:27:50.236]                             muffled <- TRUE
[08:27:50.236]                             break
[08:27:50.236]                           }
[08:27:50.236]                         }
[08:27:50.236]                       }
[08:27:50.236]                       invisible(muffled)
[08:27:50.236]                     }
[08:27:50.236]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.236]                   }
[08:27:50.236]                 }
[08:27:50.236]                 else {
[08:27:50.236]                   if (TRUE) {
[08:27:50.236]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.236]                     {
[08:27:50.236]                       inherits <- base::inherits
[08:27:50.236]                       invokeRestart <- base::invokeRestart
[08:27:50.236]                       is.null <- base::is.null
[08:27:50.236]                       muffled <- FALSE
[08:27:50.236]                       if (inherits(cond, "message")) {
[08:27:50.236]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.236]                         if (muffled) 
[08:27:50.236]                           invokeRestart("muffleMessage")
[08:27:50.236]                       }
[08:27:50.236]                       else if (inherits(cond, "warning")) {
[08:27:50.236]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.236]                         if (muffled) 
[08:27:50.236]                           invokeRestart("muffleWarning")
[08:27:50.236]                       }
[08:27:50.236]                       else if (inherits(cond, "condition")) {
[08:27:50.236]                         if (!is.null(pattern)) {
[08:27:50.236]                           computeRestarts <- base::computeRestarts
[08:27:50.236]                           grepl <- base::grepl
[08:27:50.236]                           restarts <- computeRestarts(cond)
[08:27:50.236]                           for (restart in restarts) {
[08:27:50.236]                             name <- restart$name
[08:27:50.236]                             if (is.null(name)) 
[08:27:50.236]                               next
[08:27:50.236]                             if (!grepl(pattern, name)) 
[08:27:50.236]                               next
[08:27:50.236]                             invokeRestart(restart)
[08:27:50.236]                             muffled <- TRUE
[08:27:50.236]                             break
[08:27:50.236]                           }
[08:27:50.236]                         }
[08:27:50.236]                       }
[08:27:50.236]                       invisible(muffled)
[08:27:50.236]                     }
[08:27:50.236]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.236]                   }
[08:27:50.236]                 }
[08:27:50.236]             }
[08:27:50.236]         }))
[08:27:50.236]     }, error = function(ex) {
[08:27:50.236]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.236]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.236]                 ...future.rng), started = ...future.startTime, 
[08:27:50.236]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.236]             version = "1.8"), class = "FutureResult")
[08:27:50.236]     }, finally = {
[08:27:50.236]         if (!identical(...future.workdir, getwd())) 
[08:27:50.236]             setwd(...future.workdir)
[08:27:50.236]         {
[08:27:50.236]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.236]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.236]             }
[08:27:50.236]             base::options(...future.oldOptions)
[08:27:50.236]             if (.Platform$OS.type == "windows") {
[08:27:50.236]                 old_names <- names(...future.oldEnvVars)
[08:27:50.236]                 envs <- base::Sys.getenv()
[08:27:50.236]                 names <- names(envs)
[08:27:50.236]                 common <- intersect(names, old_names)
[08:27:50.236]                 added <- setdiff(names, old_names)
[08:27:50.236]                 removed <- setdiff(old_names, names)
[08:27:50.236]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.236]                   envs[common]]
[08:27:50.236]                 NAMES <- toupper(changed)
[08:27:50.236]                 args <- list()
[08:27:50.236]                 for (kk in seq_along(NAMES)) {
[08:27:50.236]                   name <- changed[[kk]]
[08:27:50.236]                   NAME <- NAMES[[kk]]
[08:27:50.236]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.236]                     next
[08:27:50.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.236]                 }
[08:27:50.236]                 NAMES <- toupper(added)
[08:27:50.236]                 for (kk in seq_along(NAMES)) {
[08:27:50.236]                   name <- added[[kk]]
[08:27:50.236]                   NAME <- NAMES[[kk]]
[08:27:50.236]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.236]                     next
[08:27:50.236]                   args[[name]] <- ""
[08:27:50.236]                 }
[08:27:50.236]                 NAMES <- toupper(removed)
[08:27:50.236]                 for (kk in seq_along(NAMES)) {
[08:27:50.236]                   name <- removed[[kk]]
[08:27:50.236]                   NAME <- NAMES[[kk]]
[08:27:50.236]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.236]                     next
[08:27:50.236]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.236]                 }
[08:27:50.236]                 if (length(args) > 0) 
[08:27:50.236]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.236]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.236]             }
[08:27:50.236]             else {
[08:27:50.236]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.236]             }
[08:27:50.236]             {
[08:27:50.236]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.236]                   0L) {
[08:27:50.236]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.236]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.236]                   base::options(opts)
[08:27:50.236]                 }
[08:27:50.236]                 {
[08:27:50.236]                   {
[08:27:50.236]                     NULL
[08:27:50.236]                     RNGkind("Mersenne-Twister")
[08:27:50.236]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.236]                       inherits = FALSE)
[08:27:50.236]                   }
[08:27:50.236]                   options(future.plan = NULL)
[08:27:50.236]                   if (is.na(NA_character_)) 
[08:27:50.236]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.236]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.236]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.236]                     .init = FALSE)
[08:27:50.236]                 }
[08:27:50.236]             }
[08:27:50.236]         }
[08:27:50.236]     })
[08:27:50.236]     if (TRUE) {
[08:27:50.236]         base::sink(type = "output", split = FALSE)
[08:27:50.236]         if (TRUE) {
[08:27:50.236]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.236]         }
[08:27:50.236]         else {
[08:27:50.236]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.236]         }
[08:27:50.236]         base::close(...future.stdout)
[08:27:50.236]         ...future.stdout <- NULL
[08:27:50.236]     }
[08:27:50.236]     ...future.result$conditions <- ...future.conditions
[08:27:50.236]     ...future.result$finished <- base::Sys.time()
[08:27:50.236]     ...future.result
[08:27:50.236] }
[08:27:50.238] plan(): Setting new future strategy stack:
[08:27:50.238] List of future strategies:
[08:27:50.238] 1. sequential:
[08:27:50.238]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.238]    - tweaked: FALSE
[08:27:50.238]    - call: NULL
[08:27:50.239] plan(): nbrOfWorkers() = 1
[08:27:50.239] plan(): Setting new future strategy stack:
[08:27:50.239] List of future strategies:
[08:27:50.239] 1. sequential:
[08:27:50.239]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.239]    - tweaked: FALSE
[08:27:50.239]    - call: plan(strategy)
[08:27:50.240] plan(): nbrOfWorkers() = 1
[08:27:50.240] SequentialFuture started (and completed)
[08:27:50.240] - Launch lazy future ... done
[08:27:50.240] run() for ‘SequentialFuture’ ... done
[08:27:50.240] getGlobalsAndPackages() ...
[08:27:50.240] Searching for globals...
[08:27:50.242] 
[08:27:50.242] Searching for globals ... DONE
[08:27:50.242] - globals: [0] <none>
[08:27:50.243] getGlobalsAndPackages() ... DONE
[08:27:50.243] run() for ‘Future’ ...
[08:27:50.243] - state: ‘created’
[08:27:50.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.243] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.243] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.243]   - Field: ‘label’
[08:27:50.244]   - Field: ‘local’
[08:27:50.244]   - Field: ‘owner’
[08:27:50.244]   - Field: ‘envir’
[08:27:50.244]   - Field: ‘packages’
[08:27:50.244]   - Field: ‘gc’
[08:27:50.244]   - Field: ‘conditions’
[08:27:50.244]   - Field: ‘expr’
[08:27:50.244]   - Field: ‘uuid’
[08:27:50.244]   - Field: ‘seed’
[08:27:50.244]   - Field: ‘version’
[08:27:50.244]   - Field: ‘result’
[08:27:50.244]   - Field: ‘asynchronous’
[08:27:50.245]   - Field: ‘calls’
[08:27:50.245]   - Field: ‘globals’
[08:27:50.245]   - Field: ‘stdout’
[08:27:50.245]   - Field: ‘earlySignal’
[08:27:50.245]   - Field: ‘lazy’
[08:27:50.245]   - Field: ‘state’
[08:27:50.245] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.245] - Launch lazy future ...
[08:27:50.245] Packages needed by the future expression (n = 0): <none>
[08:27:50.245] Packages needed by future strategies (n = 0): <none>
[08:27:50.246] {
[08:27:50.246]     {
[08:27:50.246]         {
[08:27:50.246]             ...future.startTime <- base::Sys.time()
[08:27:50.246]             {
[08:27:50.246]                 {
[08:27:50.246]                   {
[08:27:50.246]                     base::local({
[08:27:50.246]                       has_future <- base::requireNamespace("future", 
[08:27:50.246]                         quietly = TRUE)
[08:27:50.246]                       if (has_future) {
[08:27:50.246]                         ns <- base::getNamespace("future")
[08:27:50.246]                         version <- ns[[".package"]][["version"]]
[08:27:50.246]                         if (is.null(version)) 
[08:27:50.246]                           version <- utils::packageVersion("future")
[08:27:50.246]                       }
[08:27:50.246]                       else {
[08:27:50.246]                         version <- NULL
[08:27:50.246]                       }
[08:27:50.246]                       if (!has_future || version < "1.8.0") {
[08:27:50.246]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.246]                           "", base::R.version$version.string), 
[08:27:50.246]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.246]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.246]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.246]                             "release", "version")], collapse = " "), 
[08:27:50.246]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.246]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.246]                           info)
[08:27:50.246]                         info <- base::paste(info, collapse = "; ")
[08:27:50.246]                         if (!has_future) {
[08:27:50.246]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.246]                             info)
[08:27:50.246]                         }
[08:27:50.246]                         else {
[08:27:50.246]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.246]                             info, version)
[08:27:50.246]                         }
[08:27:50.246]                         base::stop(msg)
[08:27:50.246]                       }
[08:27:50.246]                     })
[08:27:50.246]                   }
[08:27:50.246]                   ...future.strategy.old <- future::plan("list")
[08:27:50.246]                   options(future.plan = NULL)
[08:27:50.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.246]                 }
[08:27:50.246]                 ...future.workdir <- getwd()
[08:27:50.246]             }
[08:27:50.246]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.246]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.246]         }
[08:27:50.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.246]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.246]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.246]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.246]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.246]             base::names(...future.oldOptions))
[08:27:50.246]     }
[08:27:50.246]     if (FALSE) {
[08:27:50.246]     }
[08:27:50.246]     else {
[08:27:50.246]         if (TRUE) {
[08:27:50.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.246]                 open = "w")
[08:27:50.246]         }
[08:27:50.246]         else {
[08:27:50.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.246]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.246]         }
[08:27:50.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.246]             base::sink(type = "output", split = FALSE)
[08:27:50.246]             base::close(...future.stdout)
[08:27:50.246]         }, add = TRUE)
[08:27:50.246]     }
[08:27:50.246]     ...future.frame <- base::sys.nframe()
[08:27:50.246]     ...future.conditions <- base::list()
[08:27:50.246]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.246]     if (FALSE) {
[08:27:50.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.246]     }
[08:27:50.246]     ...future.result <- base::tryCatch({
[08:27:50.246]         base::withCallingHandlers({
[08:27:50.246]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.246]             future::FutureResult(value = ...future.value$value, 
[08:27:50.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.246]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.246]                     ...future.globalenv.names))
[08:27:50.246]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.246]         }, condition = base::local({
[08:27:50.246]             c <- base::c
[08:27:50.246]             inherits <- base::inherits
[08:27:50.246]             invokeRestart <- base::invokeRestart
[08:27:50.246]             length <- base::length
[08:27:50.246]             list <- base::list
[08:27:50.246]             seq.int <- base::seq.int
[08:27:50.246]             signalCondition <- base::signalCondition
[08:27:50.246]             sys.calls <- base::sys.calls
[08:27:50.246]             `[[` <- base::`[[`
[08:27:50.246]             `+` <- base::`+`
[08:27:50.246]             `<<-` <- base::`<<-`
[08:27:50.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.246]                   3L)]
[08:27:50.246]             }
[08:27:50.246]             function(cond) {
[08:27:50.246]                 is_error <- inherits(cond, "error")
[08:27:50.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.246]                   NULL)
[08:27:50.246]                 if (is_error) {
[08:27:50.246]                   sessionInformation <- function() {
[08:27:50.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.246]                       search = base::search(), system = base::Sys.info())
[08:27:50.246]                   }
[08:27:50.246]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.246]                     cond$call), session = sessionInformation(), 
[08:27:50.246]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.246]                   signalCondition(cond)
[08:27:50.246]                 }
[08:27:50.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.246]                 "immediateCondition"))) {
[08:27:50.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.246]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.246]                   if (TRUE && !signal) {
[08:27:50.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.246]                     {
[08:27:50.246]                       inherits <- base::inherits
[08:27:50.246]                       invokeRestart <- base::invokeRestart
[08:27:50.246]                       is.null <- base::is.null
[08:27:50.246]                       muffled <- FALSE
[08:27:50.246]                       if (inherits(cond, "message")) {
[08:27:50.246]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.246]                         if (muffled) 
[08:27:50.246]                           invokeRestart("muffleMessage")
[08:27:50.246]                       }
[08:27:50.246]                       else if (inherits(cond, "warning")) {
[08:27:50.246]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.246]                         if (muffled) 
[08:27:50.246]                           invokeRestart("muffleWarning")
[08:27:50.246]                       }
[08:27:50.246]                       else if (inherits(cond, "condition")) {
[08:27:50.246]                         if (!is.null(pattern)) {
[08:27:50.246]                           computeRestarts <- base::computeRestarts
[08:27:50.246]                           grepl <- base::grepl
[08:27:50.246]                           restarts <- computeRestarts(cond)
[08:27:50.246]                           for (restart in restarts) {
[08:27:50.246]                             name <- restart$name
[08:27:50.246]                             if (is.null(name)) 
[08:27:50.246]                               next
[08:27:50.246]                             if (!grepl(pattern, name)) 
[08:27:50.246]                               next
[08:27:50.246]                             invokeRestart(restart)
[08:27:50.246]                             muffled <- TRUE
[08:27:50.246]                             break
[08:27:50.246]                           }
[08:27:50.246]                         }
[08:27:50.246]                       }
[08:27:50.246]                       invisible(muffled)
[08:27:50.246]                     }
[08:27:50.246]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.246]                   }
[08:27:50.246]                 }
[08:27:50.246]                 else {
[08:27:50.246]                   if (TRUE) {
[08:27:50.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.246]                     {
[08:27:50.246]                       inherits <- base::inherits
[08:27:50.246]                       invokeRestart <- base::invokeRestart
[08:27:50.246]                       is.null <- base::is.null
[08:27:50.246]                       muffled <- FALSE
[08:27:50.246]                       if (inherits(cond, "message")) {
[08:27:50.246]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.246]                         if (muffled) 
[08:27:50.246]                           invokeRestart("muffleMessage")
[08:27:50.246]                       }
[08:27:50.246]                       else if (inherits(cond, "warning")) {
[08:27:50.246]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.246]                         if (muffled) 
[08:27:50.246]                           invokeRestart("muffleWarning")
[08:27:50.246]                       }
[08:27:50.246]                       else if (inherits(cond, "condition")) {
[08:27:50.246]                         if (!is.null(pattern)) {
[08:27:50.246]                           computeRestarts <- base::computeRestarts
[08:27:50.246]                           grepl <- base::grepl
[08:27:50.246]                           restarts <- computeRestarts(cond)
[08:27:50.246]                           for (restart in restarts) {
[08:27:50.246]                             name <- restart$name
[08:27:50.246]                             if (is.null(name)) 
[08:27:50.246]                               next
[08:27:50.246]                             if (!grepl(pattern, name)) 
[08:27:50.246]                               next
[08:27:50.246]                             invokeRestart(restart)
[08:27:50.246]                             muffled <- TRUE
[08:27:50.246]                             break
[08:27:50.246]                           }
[08:27:50.246]                         }
[08:27:50.246]                       }
[08:27:50.246]                       invisible(muffled)
[08:27:50.246]                     }
[08:27:50.246]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.246]                   }
[08:27:50.246]                 }
[08:27:50.246]             }
[08:27:50.246]         }))
[08:27:50.246]     }, error = function(ex) {
[08:27:50.246]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.246]                 ...future.rng), started = ...future.startTime, 
[08:27:50.246]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.246]             version = "1.8"), class = "FutureResult")
[08:27:50.246]     }, finally = {
[08:27:50.246]         if (!identical(...future.workdir, getwd())) 
[08:27:50.246]             setwd(...future.workdir)
[08:27:50.246]         {
[08:27:50.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.246]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.246]             }
[08:27:50.246]             base::options(...future.oldOptions)
[08:27:50.246]             if (.Platform$OS.type == "windows") {
[08:27:50.246]                 old_names <- names(...future.oldEnvVars)
[08:27:50.246]                 envs <- base::Sys.getenv()
[08:27:50.246]                 names <- names(envs)
[08:27:50.246]                 common <- intersect(names, old_names)
[08:27:50.246]                 added <- setdiff(names, old_names)
[08:27:50.246]                 removed <- setdiff(old_names, names)
[08:27:50.246]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.246]                   envs[common]]
[08:27:50.246]                 NAMES <- toupper(changed)
[08:27:50.246]                 args <- list()
[08:27:50.246]                 for (kk in seq_along(NAMES)) {
[08:27:50.246]                   name <- changed[[kk]]
[08:27:50.246]                   NAME <- NAMES[[kk]]
[08:27:50.246]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.246]                     next
[08:27:50.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.246]                 }
[08:27:50.246]                 NAMES <- toupper(added)
[08:27:50.246]                 for (kk in seq_along(NAMES)) {
[08:27:50.246]                   name <- added[[kk]]
[08:27:50.246]                   NAME <- NAMES[[kk]]
[08:27:50.246]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.246]                     next
[08:27:50.246]                   args[[name]] <- ""
[08:27:50.246]                 }
[08:27:50.246]                 NAMES <- toupper(removed)
[08:27:50.246]                 for (kk in seq_along(NAMES)) {
[08:27:50.246]                   name <- removed[[kk]]
[08:27:50.246]                   NAME <- NAMES[[kk]]
[08:27:50.246]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.246]                     next
[08:27:50.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.246]                 }
[08:27:50.246]                 if (length(args) > 0) 
[08:27:50.246]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.246]             }
[08:27:50.246]             else {
[08:27:50.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.246]             }
[08:27:50.246]             {
[08:27:50.246]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.246]                   0L) {
[08:27:50.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.246]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.246]                   base::options(opts)
[08:27:50.246]                 }
[08:27:50.246]                 {
[08:27:50.246]                   {
[08:27:50.246]                     NULL
[08:27:50.246]                     RNGkind("Mersenne-Twister")
[08:27:50.246]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.246]                       inherits = FALSE)
[08:27:50.246]                   }
[08:27:50.246]                   options(future.plan = NULL)
[08:27:50.246]                   if (is.na(NA_character_)) 
[08:27:50.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.246]                     .init = FALSE)
[08:27:50.246]                 }
[08:27:50.246]             }
[08:27:50.246]         }
[08:27:50.246]     })
[08:27:50.246]     if (TRUE) {
[08:27:50.246]         base::sink(type = "output", split = FALSE)
[08:27:50.246]         if (TRUE) {
[08:27:50.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.246]         }
[08:27:50.246]         else {
[08:27:50.246]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.246]         }
[08:27:50.246]         base::close(...future.stdout)
[08:27:50.246]         ...future.stdout <- NULL
[08:27:50.246]     }
[08:27:50.246]     ...future.result$conditions <- ...future.conditions
[08:27:50.246]     ...future.result$finished <- base::Sys.time()
[08:27:50.246]     ...future.result
[08:27:50.246] }
[08:27:50.248] plan(): Setting new future strategy stack:
[08:27:50.248] List of future strategies:
[08:27:50.248] 1. sequential:
[08:27:50.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.248]    - tweaked: FALSE
[08:27:50.248]    - call: NULL
[08:27:50.248] plan(): nbrOfWorkers() = 1
[08:27:50.249] plan(): Setting new future strategy stack:
[08:27:50.249] List of future strategies:
[08:27:50.249] 1. sequential:
[08:27:50.249]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.249]    - tweaked: FALSE
[08:27:50.249]    - call: plan(strategy)
[08:27:50.249] plan(): nbrOfWorkers() = 1
[08:27:50.250] SequentialFuture started (and completed)
[08:27:50.250] - Launch lazy future ... done
[08:27:50.250] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860edb050> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d8600b1600> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860edb050> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d8600b1600> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[08:27:50.254] resolved() for ‘SequentialFuture’ ...
[08:27:50.254] - state: ‘finished’
[08:27:50.254] - run: TRUE
[08:27:50.255] - result: ‘FutureResult’
[08:27:50.255] resolved() for ‘SequentialFuture’ ... done
[08:27:50.255] resolved() for ‘SequentialFuture’ ...
[08:27:50.255] - state: ‘finished’
[08:27:50.255] - run: TRUE
[08:27:50.255] - result: ‘FutureResult’
[08:27:50.255] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:50.257] resolve() on list ...
[08:27:50.257]  recursive: 0
[08:27:50.257]  length: 6
[08:27:50.257]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:50.257] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.257] - nx: 6
[08:27:50.257] - relay: TRUE
[08:27:50.257] - stdout: TRUE
[08:27:50.257] - signal: TRUE
[08:27:50.257] - resignal: FALSE
[08:27:50.257] - force: TRUE
[08:27:50.257] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.258] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.258]  - until=2
[08:27:50.258]  - relaying element #2
[08:27:50.258] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.258] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.258] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.258]  length: 5 (resolved future 1)
[08:27:50.258] resolved() for ‘SequentialFuture’ ...
[08:27:50.258] - state: ‘finished’
[08:27:50.258] - run: TRUE
[08:27:50.258] - result: ‘FutureResult’
[08:27:50.259] resolved() for ‘SequentialFuture’ ... done
[08:27:50.259] Future #2
[08:27:50.259] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.259] - nx: 6
[08:27:50.259] - relay: TRUE
[08:27:50.259] - stdout: TRUE
[08:27:50.259] - signal: TRUE
[08:27:50.259] - resignal: FALSE
[08:27:50.259] - force: TRUE
[08:27:50.259] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.259] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.259]  - until=2
[08:27:50.260]  - relaying element #2
[08:27:50.260] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.260] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.260] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.260]  length: 4 (resolved future 2)
[08:27:50.260] resolved() for ‘SequentialFuture’ ...
[08:27:50.260] - state: ‘finished’
[08:27:50.260] - run: TRUE
[08:27:50.260] - result: ‘FutureResult’
[08:27:50.260] resolved() for ‘SequentialFuture’ ... done
[08:27:50.261] Future #3
[08:27:50.261] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.261] - nx: 6
[08:27:50.261] - relay: TRUE
[08:27:50.261] - stdout: TRUE
[08:27:50.261] - signal: TRUE
[08:27:50.261] - resignal: FALSE
[08:27:50.261] - force: TRUE
[08:27:50.261] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.261] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.261]  - until=3
[08:27:50.261]  - relaying element #3
[08:27:50.262] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.262] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.262] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.262]  length: 3 (resolved future 3)
[08:27:50.262] signalConditionsASAP(NULL, pos=4) ...
[08:27:50.262] - nx: 6
[08:27:50.262] - relay: TRUE
[08:27:50.262] - stdout: TRUE
[08:27:50.262] - signal: TRUE
[08:27:50.262] - resignal: FALSE
[08:27:50.262] - force: TRUE
[08:27:50.262] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.263] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.263]  - until=5
[08:27:50.263]  - relaying element #5
[08:27:50.263] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.263] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.263] signalConditionsASAP(NULL, pos=4) ... done
[08:27:50.263]  length: 2 (resolved future 4)
[08:27:50.263] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.263] - nx: 6
[08:27:50.263] - relay: TRUE
[08:27:50.263] - stdout: TRUE
[08:27:50.263] - signal: TRUE
[08:27:50.264] - resignal: FALSE
[08:27:50.264] - force: TRUE
[08:27:50.264] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.264] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.264]  - until=6
[08:27:50.264]  - relaying element #6
[08:27:50.264] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.264] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.264] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.264]  length: 1 (resolved future 5)
[08:27:50.264] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.264] - nx: 6
[08:27:50.264] - relay: TRUE
[08:27:50.265] - stdout: TRUE
[08:27:50.265] - signal: TRUE
[08:27:50.265] - resignal: FALSE
[08:27:50.265] - force: TRUE
[08:27:50.265] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.265] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.265]  - until=6
[08:27:50.265] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.265] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.265] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.265]  length: 0 (resolved future 6)
[08:27:50.265] Relaying remaining futures
[08:27:50.266] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.266] - nx: 6
[08:27:50.266] - relay: TRUE
[08:27:50.266] - stdout: TRUE
[08:27:50.266] - signal: TRUE
[08:27:50.266] - resignal: FALSE
[08:27:50.266] - force: TRUE
[08:27:50.266] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.266] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:50.266] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.266] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.266] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.266] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[08:27:50.271] getGlobalsAndPackages() ...
[08:27:50.271] Searching for globals...
[08:27:50.272] 
[08:27:50.272] Searching for globals ... DONE
[08:27:50.272] - globals: [0] <none>
[08:27:50.272] getGlobalsAndPackages() ... DONE
[08:27:50.272] run() for ‘Future’ ...
[08:27:50.272] - state: ‘created’
[08:27:50.272] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.273] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.273] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.273]   - Field: ‘label’
[08:27:50.273]   - Field: ‘local’
[08:27:50.273]   - Field: ‘owner’
[08:27:50.273]   - Field: ‘envir’
[08:27:50.273]   - Field: ‘packages’
[08:27:50.273]   - Field: ‘gc’
[08:27:50.273]   - Field: ‘conditions’
[08:27:50.274]   - Field: ‘expr’
[08:27:50.274]   - Field: ‘uuid’
[08:27:50.274]   - Field: ‘seed’
[08:27:50.274]   - Field: ‘version’
[08:27:50.274]   - Field: ‘result’
[08:27:50.274]   - Field: ‘asynchronous’
[08:27:50.274]   - Field: ‘calls’
[08:27:50.274]   - Field: ‘globals’
[08:27:50.274]   - Field: ‘stdout’
[08:27:50.274]   - Field: ‘earlySignal’
[08:27:50.274]   - Field: ‘lazy’
[08:27:50.274]   - Field: ‘state’
[08:27:50.275] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.275] - Launch lazy future ...
[08:27:50.275] Packages needed by the future expression (n = 0): <none>
[08:27:50.275] Packages needed by future strategies (n = 0): <none>
[08:27:50.275] {
[08:27:50.275]     {
[08:27:50.275]         {
[08:27:50.275]             ...future.startTime <- base::Sys.time()
[08:27:50.275]             {
[08:27:50.275]                 {
[08:27:50.275]                   {
[08:27:50.275]                     base::local({
[08:27:50.275]                       has_future <- base::requireNamespace("future", 
[08:27:50.275]                         quietly = TRUE)
[08:27:50.275]                       if (has_future) {
[08:27:50.275]                         ns <- base::getNamespace("future")
[08:27:50.275]                         version <- ns[[".package"]][["version"]]
[08:27:50.275]                         if (is.null(version)) 
[08:27:50.275]                           version <- utils::packageVersion("future")
[08:27:50.275]                       }
[08:27:50.275]                       else {
[08:27:50.275]                         version <- NULL
[08:27:50.275]                       }
[08:27:50.275]                       if (!has_future || version < "1.8.0") {
[08:27:50.275]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.275]                           "", base::R.version$version.string), 
[08:27:50.275]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.275]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.275]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.275]                             "release", "version")], collapse = " "), 
[08:27:50.275]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.275]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.275]                           info)
[08:27:50.275]                         info <- base::paste(info, collapse = "; ")
[08:27:50.275]                         if (!has_future) {
[08:27:50.275]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.275]                             info)
[08:27:50.275]                         }
[08:27:50.275]                         else {
[08:27:50.275]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.275]                             info, version)
[08:27:50.275]                         }
[08:27:50.275]                         base::stop(msg)
[08:27:50.275]                       }
[08:27:50.275]                     })
[08:27:50.275]                   }
[08:27:50.275]                   ...future.strategy.old <- future::plan("list")
[08:27:50.275]                   options(future.plan = NULL)
[08:27:50.275]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.275]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.275]                 }
[08:27:50.275]                 ...future.workdir <- getwd()
[08:27:50.275]             }
[08:27:50.275]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.275]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.275]         }
[08:27:50.275]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.275]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.275]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.275]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.275]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.275]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.275]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.275]             base::names(...future.oldOptions))
[08:27:50.275]     }
[08:27:50.275]     if (FALSE) {
[08:27:50.275]     }
[08:27:50.275]     else {
[08:27:50.275]         if (TRUE) {
[08:27:50.275]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.275]                 open = "w")
[08:27:50.275]         }
[08:27:50.275]         else {
[08:27:50.275]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.275]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.275]         }
[08:27:50.275]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.275]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.275]             base::sink(type = "output", split = FALSE)
[08:27:50.275]             base::close(...future.stdout)
[08:27:50.275]         }, add = TRUE)
[08:27:50.275]     }
[08:27:50.275]     ...future.frame <- base::sys.nframe()
[08:27:50.275]     ...future.conditions <- base::list()
[08:27:50.275]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.275]     if (FALSE) {
[08:27:50.275]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.275]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.275]     }
[08:27:50.275]     ...future.result <- base::tryCatch({
[08:27:50.275]         base::withCallingHandlers({
[08:27:50.275]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.275]             future::FutureResult(value = ...future.value$value, 
[08:27:50.275]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.275]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.275]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.275]                     ...future.globalenv.names))
[08:27:50.275]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.275]         }, condition = base::local({
[08:27:50.275]             c <- base::c
[08:27:50.275]             inherits <- base::inherits
[08:27:50.275]             invokeRestart <- base::invokeRestart
[08:27:50.275]             length <- base::length
[08:27:50.275]             list <- base::list
[08:27:50.275]             seq.int <- base::seq.int
[08:27:50.275]             signalCondition <- base::signalCondition
[08:27:50.275]             sys.calls <- base::sys.calls
[08:27:50.275]             `[[` <- base::`[[`
[08:27:50.275]             `+` <- base::`+`
[08:27:50.275]             `<<-` <- base::`<<-`
[08:27:50.275]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.275]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.275]                   3L)]
[08:27:50.275]             }
[08:27:50.275]             function(cond) {
[08:27:50.275]                 is_error <- inherits(cond, "error")
[08:27:50.275]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.275]                   NULL)
[08:27:50.275]                 if (is_error) {
[08:27:50.275]                   sessionInformation <- function() {
[08:27:50.275]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.275]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.275]                       search = base::search(), system = base::Sys.info())
[08:27:50.275]                   }
[08:27:50.275]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.275]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.275]                     cond$call), session = sessionInformation(), 
[08:27:50.275]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.275]                   signalCondition(cond)
[08:27:50.275]                 }
[08:27:50.275]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.275]                 "immediateCondition"))) {
[08:27:50.275]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.275]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.275]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.275]                   if (TRUE && !signal) {
[08:27:50.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.275]                     {
[08:27:50.275]                       inherits <- base::inherits
[08:27:50.275]                       invokeRestart <- base::invokeRestart
[08:27:50.275]                       is.null <- base::is.null
[08:27:50.275]                       muffled <- FALSE
[08:27:50.275]                       if (inherits(cond, "message")) {
[08:27:50.275]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.275]                         if (muffled) 
[08:27:50.275]                           invokeRestart("muffleMessage")
[08:27:50.275]                       }
[08:27:50.275]                       else if (inherits(cond, "warning")) {
[08:27:50.275]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.275]                         if (muffled) 
[08:27:50.275]                           invokeRestart("muffleWarning")
[08:27:50.275]                       }
[08:27:50.275]                       else if (inherits(cond, "condition")) {
[08:27:50.275]                         if (!is.null(pattern)) {
[08:27:50.275]                           computeRestarts <- base::computeRestarts
[08:27:50.275]                           grepl <- base::grepl
[08:27:50.275]                           restarts <- computeRestarts(cond)
[08:27:50.275]                           for (restart in restarts) {
[08:27:50.275]                             name <- restart$name
[08:27:50.275]                             if (is.null(name)) 
[08:27:50.275]                               next
[08:27:50.275]                             if (!grepl(pattern, name)) 
[08:27:50.275]                               next
[08:27:50.275]                             invokeRestart(restart)
[08:27:50.275]                             muffled <- TRUE
[08:27:50.275]                             break
[08:27:50.275]                           }
[08:27:50.275]                         }
[08:27:50.275]                       }
[08:27:50.275]                       invisible(muffled)
[08:27:50.275]                     }
[08:27:50.275]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.275]                   }
[08:27:50.275]                 }
[08:27:50.275]                 else {
[08:27:50.275]                   if (TRUE) {
[08:27:50.275]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.275]                     {
[08:27:50.275]                       inherits <- base::inherits
[08:27:50.275]                       invokeRestart <- base::invokeRestart
[08:27:50.275]                       is.null <- base::is.null
[08:27:50.275]                       muffled <- FALSE
[08:27:50.275]                       if (inherits(cond, "message")) {
[08:27:50.275]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.275]                         if (muffled) 
[08:27:50.275]                           invokeRestart("muffleMessage")
[08:27:50.275]                       }
[08:27:50.275]                       else if (inherits(cond, "warning")) {
[08:27:50.275]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.275]                         if (muffled) 
[08:27:50.275]                           invokeRestart("muffleWarning")
[08:27:50.275]                       }
[08:27:50.275]                       else if (inherits(cond, "condition")) {
[08:27:50.275]                         if (!is.null(pattern)) {
[08:27:50.275]                           computeRestarts <- base::computeRestarts
[08:27:50.275]                           grepl <- base::grepl
[08:27:50.275]                           restarts <- computeRestarts(cond)
[08:27:50.275]                           for (restart in restarts) {
[08:27:50.275]                             name <- restart$name
[08:27:50.275]                             if (is.null(name)) 
[08:27:50.275]                               next
[08:27:50.275]                             if (!grepl(pattern, name)) 
[08:27:50.275]                               next
[08:27:50.275]                             invokeRestart(restart)
[08:27:50.275]                             muffled <- TRUE
[08:27:50.275]                             break
[08:27:50.275]                           }
[08:27:50.275]                         }
[08:27:50.275]                       }
[08:27:50.275]                       invisible(muffled)
[08:27:50.275]                     }
[08:27:50.275]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.275]                   }
[08:27:50.275]                 }
[08:27:50.275]             }
[08:27:50.275]         }))
[08:27:50.275]     }, error = function(ex) {
[08:27:50.275]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.275]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.275]                 ...future.rng), started = ...future.startTime, 
[08:27:50.275]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.275]             version = "1.8"), class = "FutureResult")
[08:27:50.275]     }, finally = {
[08:27:50.275]         if (!identical(...future.workdir, getwd())) 
[08:27:50.275]             setwd(...future.workdir)
[08:27:50.275]         {
[08:27:50.275]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.275]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.275]             }
[08:27:50.275]             base::options(...future.oldOptions)
[08:27:50.275]             if (.Platform$OS.type == "windows") {
[08:27:50.275]                 old_names <- names(...future.oldEnvVars)
[08:27:50.275]                 envs <- base::Sys.getenv()
[08:27:50.275]                 names <- names(envs)
[08:27:50.275]                 common <- intersect(names, old_names)
[08:27:50.275]                 added <- setdiff(names, old_names)
[08:27:50.275]                 removed <- setdiff(old_names, names)
[08:27:50.275]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.275]                   envs[common]]
[08:27:50.275]                 NAMES <- toupper(changed)
[08:27:50.275]                 args <- list()
[08:27:50.275]                 for (kk in seq_along(NAMES)) {
[08:27:50.275]                   name <- changed[[kk]]
[08:27:50.275]                   NAME <- NAMES[[kk]]
[08:27:50.275]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.275]                     next
[08:27:50.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.275]                 }
[08:27:50.275]                 NAMES <- toupper(added)
[08:27:50.275]                 for (kk in seq_along(NAMES)) {
[08:27:50.275]                   name <- added[[kk]]
[08:27:50.275]                   NAME <- NAMES[[kk]]
[08:27:50.275]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.275]                     next
[08:27:50.275]                   args[[name]] <- ""
[08:27:50.275]                 }
[08:27:50.275]                 NAMES <- toupper(removed)
[08:27:50.275]                 for (kk in seq_along(NAMES)) {
[08:27:50.275]                   name <- removed[[kk]]
[08:27:50.275]                   NAME <- NAMES[[kk]]
[08:27:50.275]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.275]                     next
[08:27:50.275]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.275]                 }
[08:27:50.275]                 if (length(args) > 0) 
[08:27:50.275]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.275]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.275]             }
[08:27:50.275]             else {
[08:27:50.275]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.275]             }
[08:27:50.275]             {
[08:27:50.275]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.275]                   0L) {
[08:27:50.275]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.275]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.275]                   base::options(opts)
[08:27:50.275]                 }
[08:27:50.275]                 {
[08:27:50.275]                   {
[08:27:50.275]                     NULL
[08:27:50.275]                     RNGkind("Mersenne-Twister")
[08:27:50.275]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.275]                       inherits = FALSE)
[08:27:50.275]                   }
[08:27:50.275]                   options(future.plan = NULL)
[08:27:50.275]                   if (is.na(NA_character_)) 
[08:27:50.275]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.275]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.275]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.275]                     .init = FALSE)
[08:27:50.275]                 }
[08:27:50.275]             }
[08:27:50.275]         }
[08:27:50.275]     })
[08:27:50.275]     if (TRUE) {
[08:27:50.275]         base::sink(type = "output", split = FALSE)
[08:27:50.275]         if (TRUE) {
[08:27:50.275]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.275]         }
[08:27:50.275]         else {
[08:27:50.275]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.275]         }
[08:27:50.275]         base::close(...future.stdout)
[08:27:50.275]         ...future.stdout <- NULL
[08:27:50.275]     }
[08:27:50.275]     ...future.result$conditions <- ...future.conditions
[08:27:50.275]     ...future.result$finished <- base::Sys.time()
[08:27:50.275]     ...future.result
[08:27:50.275] }
[08:27:50.277] plan(): Setting new future strategy stack:
[08:27:50.277] List of future strategies:
[08:27:50.277] 1. sequential:
[08:27:50.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.277]    - tweaked: FALSE
[08:27:50.277]    - call: NULL
[08:27:50.278] plan(): nbrOfWorkers() = 1
[08:27:50.278] plan(): Setting new future strategy stack:
[08:27:50.279] List of future strategies:
[08:27:50.279] 1. sequential:
[08:27:50.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.279]    - tweaked: FALSE
[08:27:50.279]    - call: plan(strategy)
[08:27:50.279] plan(): nbrOfWorkers() = 1
[08:27:50.279] SequentialFuture started (and completed)
[08:27:50.279] - Launch lazy future ... done
[08:27:50.279] run() for ‘SequentialFuture’ ... done
[08:27:50.279] getGlobalsAndPackages() ...
[08:27:50.279] Searching for globals...
[08:27:50.280] 
[08:27:50.280] Searching for globals ... DONE
[08:27:50.280] - globals: [0] <none>
[08:27:50.280] getGlobalsAndPackages() ... DONE
[08:27:50.280] run() for ‘Future’ ...
[08:27:50.280] - state: ‘created’
[08:27:50.280] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.281] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.281] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.281]   - Field: ‘label’
[08:27:50.281]   - Field: ‘local’
[08:27:50.281]   - Field: ‘owner’
[08:27:50.281]   - Field: ‘envir’
[08:27:50.281]   - Field: ‘packages’
[08:27:50.281]   - Field: ‘gc’
[08:27:50.281]   - Field: ‘conditions’
[08:27:50.281]   - Field: ‘expr’
[08:27:50.282]   - Field: ‘uuid’
[08:27:50.282]   - Field: ‘seed’
[08:27:50.282]   - Field: ‘version’
[08:27:50.282]   - Field: ‘result’
[08:27:50.282]   - Field: ‘asynchronous’
[08:27:50.282]   - Field: ‘calls’
[08:27:50.282]   - Field: ‘globals’
[08:27:50.282]   - Field: ‘stdout’
[08:27:50.282]   - Field: ‘earlySignal’
[08:27:50.282]   - Field: ‘lazy’
[08:27:50.282]   - Field: ‘state’
[08:27:50.283] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.283] - Launch lazy future ...
[08:27:50.283] Packages needed by the future expression (n = 0): <none>
[08:27:50.283] Packages needed by future strategies (n = 0): <none>
[08:27:50.283] {
[08:27:50.283]     {
[08:27:50.283]         {
[08:27:50.283]             ...future.startTime <- base::Sys.time()
[08:27:50.283]             {
[08:27:50.283]                 {
[08:27:50.283]                   {
[08:27:50.283]                     base::local({
[08:27:50.283]                       has_future <- base::requireNamespace("future", 
[08:27:50.283]                         quietly = TRUE)
[08:27:50.283]                       if (has_future) {
[08:27:50.283]                         ns <- base::getNamespace("future")
[08:27:50.283]                         version <- ns[[".package"]][["version"]]
[08:27:50.283]                         if (is.null(version)) 
[08:27:50.283]                           version <- utils::packageVersion("future")
[08:27:50.283]                       }
[08:27:50.283]                       else {
[08:27:50.283]                         version <- NULL
[08:27:50.283]                       }
[08:27:50.283]                       if (!has_future || version < "1.8.0") {
[08:27:50.283]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.283]                           "", base::R.version$version.string), 
[08:27:50.283]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.283]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.283]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.283]                             "release", "version")], collapse = " "), 
[08:27:50.283]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.283]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.283]                           info)
[08:27:50.283]                         info <- base::paste(info, collapse = "; ")
[08:27:50.283]                         if (!has_future) {
[08:27:50.283]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.283]                             info)
[08:27:50.283]                         }
[08:27:50.283]                         else {
[08:27:50.283]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.283]                             info, version)
[08:27:50.283]                         }
[08:27:50.283]                         base::stop(msg)
[08:27:50.283]                       }
[08:27:50.283]                     })
[08:27:50.283]                   }
[08:27:50.283]                   ...future.strategy.old <- future::plan("list")
[08:27:50.283]                   options(future.plan = NULL)
[08:27:50.283]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.283]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.283]                 }
[08:27:50.283]                 ...future.workdir <- getwd()
[08:27:50.283]             }
[08:27:50.283]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.283]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.283]         }
[08:27:50.283]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.283]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.283]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.283]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.283]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.283]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.283]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.283]             base::names(...future.oldOptions))
[08:27:50.283]     }
[08:27:50.283]     if (FALSE) {
[08:27:50.283]     }
[08:27:50.283]     else {
[08:27:50.283]         if (TRUE) {
[08:27:50.283]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.283]                 open = "w")
[08:27:50.283]         }
[08:27:50.283]         else {
[08:27:50.283]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.283]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.283]         }
[08:27:50.283]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.283]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.283]             base::sink(type = "output", split = FALSE)
[08:27:50.283]             base::close(...future.stdout)
[08:27:50.283]         }, add = TRUE)
[08:27:50.283]     }
[08:27:50.283]     ...future.frame <- base::sys.nframe()
[08:27:50.283]     ...future.conditions <- base::list()
[08:27:50.283]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.283]     if (FALSE) {
[08:27:50.283]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.283]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.283]     }
[08:27:50.283]     ...future.result <- base::tryCatch({
[08:27:50.283]         base::withCallingHandlers({
[08:27:50.283]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.283]             future::FutureResult(value = ...future.value$value, 
[08:27:50.283]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.283]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.283]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.283]                     ...future.globalenv.names))
[08:27:50.283]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.283]         }, condition = base::local({
[08:27:50.283]             c <- base::c
[08:27:50.283]             inherits <- base::inherits
[08:27:50.283]             invokeRestart <- base::invokeRestart
[08:27:50.283]             length <- base::length
[08:27:50.283]             list <- base::list
[08:27:50.283]             seq.int <- base::seq.int
[08:27:50.283]             signalCondition <- base::signalCondition
[08:27:50.283]             sys.calls <- base::sys.calls
[08:27:50.283]             `[[` <- base::`[[`
[08:27:50.283]             `+` <- base::`+`
[08:27:50.283]             `<<-` <- base::`<<-`
[08:27:50.283]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.283]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.283]                   3L)]
[08:27:50.283]             }
[08:27:50.283]             function(cond) {
[08:27:50.283]                 is_error <- inherits(cond, "error")
[08:27:50.283]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.283]                   NULL)
[08:27:50.283]                 if (is_error) {
[08:27:50.283]                   sessionInformation <- function() {
[08:27:50.283]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.283]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.283]                       search = base::search(), system = base::Sys.info())
[08:27:50.283]                   }
[08:27:50.283]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.283]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.283]                     cond$call), session = sessionInformation(), 
[08:27:50.283]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.283]                   signalCondition(cond)
[08:27:50.283]                 }
[08:27:50.283]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.283]                 "immediateCondition"))) {
[08:27:50.283]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.283]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.283]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.283]                   if (TRUE && !signal) {
[08:27:50.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.283]                     {
[08:27:50.283]                       inherits <- base::inherits
[08:27:50.283]                       invokeRestart <- base::invokeRestart
[08:27:50.283]                       is.null <- base::is.null
[08:27:50.283]                       muffled <- FALSE
[08:27:50.283]                       if (inherits(cond, "message")) {
[08:27:50.283]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.283]                         if (muffled) 
[08:27:50.283]                           invokeRestart("muffleMessage")
[08:27:50.283]                       }
[08:27:50.283]                       else if (inherits(cond, "warning")) {
[08:27:50.283]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.283]                         if (muffled) 
[08:27:50.283]                           invokeRestart("muffleWarning")
[08:27:50.283]                       }
[08:27:50.283]                       else if (inherits(cond, "condition")) {
[08:27:50.283]                         if (!is.null(pattern)) {
[08:27:50.283]                           computeRestarts <- base::computeRestarts
[08:27:50.283]                           grepl <- base::grepl
[08:27:50.283]                           restarts <- computeRestarts(cond)
[08:27:50.283]                           for (restart in restarts) {
[08:27:50.283]                             name <- restart$name
[08:27:50.283]                             if (is.null(name)) 
[08:27:50.283]                               next
[08:27:50.283]                             if (!grepl(pattern, name)) 
[08:27:50.283]                               next
[08:27:50.283]                             invokeRestart(restart)
[08:27:50.283]                             muffled <- TRUE
[08:27:50.283]                             break
[08:27:50.283]                           }
[08:27:50.283]                         }
[08:27:50.283]                       }
[08:27:50.283]                       invisible(muffled)
[08:27:50.283]                     }
[08:27:50.283]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.283]                   }
[08:27:50.283]                 }
[08:27:50.283]                 else {
[08:27:50.283]                   if (TRUE) {
[08:27:50.283]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.283]                     {
[08:27:50.283]                       inherits <- base::inherits
[08:27:50.283]                       invokeRestart <- base::invokeRestart
[08:27:50.283]                       is.null <- base::is.null
[08:27:50.283]                       muffled <- FALSE
[08:27:50.283]                       if (inherits(cond, "message")) {
[08:27:50.283]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.283]                         if (muffled) 
[08:27:50.283]                           invokeRestart("muffleMessage")
[08:27:50.283]                       }
[08:27:50.283]                       else if (inherits(cond, "warning")) {
[08:27:50.283]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.283]                         if (muffled) 
[08:27:50.283]                           invokeRestart("muffleWarning")
[08:27:50.283]                       }
[08:27:50.283]                       else if (inherits(cond, "condition")) {
[08:27:50.283]                         if (!is.null(pattern)) {
[08:27:50.283]                           computeRestarts <- base::computeRestarts
[08:27:50.283]                           grepl <- base::grepl
[08:27:50.283]                           restarts <- computeRestarts(cond)
[08:27:50.283]                           for (restart in restarts) {
[08:27:50.283]                             name <- restart$name
[08:27:50.283]                             if (is.null(name)) 
[08:27:50.283]                               next
[08:27:50.283]                             if (!grepl(pattern, name)) 
[08:27:50.283]                               next
[08:27:50.283]                             invokeRestart(restart)
[08:27:50.283]                             muffled <- TRUE
[08:27:50.283]                             break
[08:27:50.283]                           }
[08:27:50.283]                         }
[08:27:50.283]                       }
[08:27:50.283]                       invisible(muffled)
[08:27:50.283]                     }
[08:27:50.283]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.283]                   }
[08:27:50.283]                 }
[08:27:50.283]             }
[08:27:50.283]         }))
[08:27:50.283]     }, error = function(ex) {
[08:27:50.283]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.283]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.283]                 ...future.rng), started = ...future.startTime, 
[08:27:50.283]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.283]             version = "1.8"), class = "FutureResult")
[08:27:50.283]     }, finally = {
[08:27:50.283]         if (!identical(...future.workdir, getwd())) 
[08:27:50.283]             setwd(...future.workdir)
[08:27:50.283]         {
[08:27:50.283]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.283]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.283]             }
[08:27:50.283]             base::options(...future.oldOptions)
[08:27:50.283]             if (.Platform$OS.type == "windows") {
[08:27:50.283]                 old_names <- names(...future.oldEnvVars)
[08:27:50.283]                 envs <- base::Sys.getenv()
[08:27:50.283]                 names <- names(envs)
[08:27:50.283]                 common <- intersect(names, old_names)
[08:27:50.283]                 added <- setdiff(names, old_names)
[08:27:50.283]                 removed <- setdiff(old_names, names)
[08:27:50.283]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.283]                   envs[common]]
[08:27:50.283]                 NAMES <- toupper(changed)
[08:27:50.283]                 args <- list()
[08:27:50.283]                 for (kk in seq_along(NAMES)) {
[08:27:50.283]                   name <- changed[[kk]]
[08:27:50.283]                   NAME <- NAMES[[kk]]
[08:27:50.283]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.283]                     next
[08:27:50.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.283]                 }
[08:27:50.283]                 NAMES <- toupper(added)
[08:27:50.283]                 for (kk in seq_along(NAMES)) {
[08:27:50.283]                   name <- added[[kk]]
[08:27:50.283]                   NAME <- NAMES[[kk]]
[08:27:50.283]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.283]                     next
[08:27:50.283]                   args[[name]] <- ""
[08:27:50.283]                 }
[08:27:50.283]                 NAMES <- toupper(removed)
[08:27:50.283]                 for (kk in seq_along(NAMES)) {
[08:27:50.283]                   name <- removed[[kk]]
[08:27:50.283]                   NAME <- NAMES[[kk]]
[08:27:50.283]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.283]                     next
[08:27:50.283]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.283]                 }
[08:27:50.283]                 if (length(args) > 0) 
[08:27:50.283]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.283]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.283]             }
[08:27:50.283]             else {
[08:27:50.283]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.283]             }
[08:27:50.283]             {
[08:27:50.283]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.283]                   0L) {
[08:27:50.283]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.283]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.283]                   base::options(opts)
[08:27:50.283]                 }
[08:27:50.283]                 {
[08:27:50.283]                   {
[08:27:50.283]                     NULL
[08:27:50.283]                     RNGkind("Mersenne-Twister")
[08:27:50.283]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.283]                       inherits = FALSE)
[08:27:50.283]                   }
[08:27:50.283]                   options(future.plan = NULL)
[08:27:50.283]                   if (is.na(NA_character_)) 
[08:27:50.283]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.283]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.283]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.283]                     .init = FALSE)
[08:27:50.283]                 }
[08:27:50.283]             }
[08:27:50.283]         }
[08:27:50.283]     })
[08:27:50.283]     if (TRUE) {
[08:27:50.283]         base::sink(type = "output", split = FALSE)
[08:27:50.283]         if (TRUE) {
[08:27:50.283]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.283]         }
[08:27:50.283]         else {
[08:27:50.283]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.283]         }
[08:27:50.283]         base::close(...future.stdout)
[08:27:50.283]         ...future.stdout <- NULL
[08:27:50.283]     }
[08:27:50.283]     ...future.result$conditions <- ...future.conditions
[08:27:50.283]     ...future.result$finished <- base::Sys.time()
[08:27:50.283]     ...future.result
[08:27:50.283] }
[08:27:50.285] plan(): Setting new future strategy stack:
[08:27:50.285] List of future strategies:
[08:27:50.285] 1. sequential:
[08:27:50.285]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.285]    - tweaked: FALSE
[08:27:50.285]    - call: NULL
[08:27:50.286] plan(): nbrOfWorkers() = 1
[08:27:50.286] plan(): Setting new future strategy stack:
[08:27:50.286] List of future strategies:
[08:27:50.286] 1. sequential:
[08:27:50.286]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.286]    - tweaked: FALSE
[08:27:50.286]    - call: plan(strategy)
[08:27:50.287] plan(): nbrOfWorkers() = 1
[08:27:50.287] SequentialFuture started (and completed)
[08:27:50.287] - Launch lazy future ... done
[08:27:50.287] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d85f1ed398> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d8606fa1a8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d85f1ed398> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d8606fa1a8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[08:27:50.292] resolved() for ‘SequentialFuture’ ...
[08:27:50.292] - state: ‘finished’
[08:27:50.292] - run: TRUE
[08:27:50.292] - result: ‘FutureResult’
[08:27:50.292] resolved() for ‘SequentialFuture’ ... done
[08:27:50.292] resolved() for ‘SequentialFuture’ ...
[08:27:50.293] - state: ‘finished’
[08:27:50.293] - run: TRUE
[08:27:50.293] - result: ‘FutureResult’
[08:27:50.293] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:50.294] resolve() on list ...
[08:27:50.295]  recursive: 0
[08:27:50.295]  length: 6
[08:27:50.295]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:50.295] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.295] - nx: 6
[08:27:50.295] - relay: TRUE
[08:27:50.295] - stdout: TRUE
[08:27:50.295] - signal: TRUE
[08:27:50.295] - resignal: FALSE
[08:27:50.295] - force: TRUE
[08:27:50.295] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.295] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.296]  - until=2
[08:27:50.296]  - relaying element #2
[08:27:50.296] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.296] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.296] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.296]  length: 5 (resolved future 1)
[08:27:50.296] resolved() for ‘SequentialFuture’ ...
[08:27:50.296] - state: ‘finished’
[08:27:50.296] - run: TRUE
[08:27:50.296] - result: ‘FutureResult’
[08:27:50.296] resolved() for ‘SequentialFuture’ ... done
[08:27:50.296] Future #2
[08:27:50.297] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.297] - nx: 6
[08:27:50.298] - relay: TRUE
[08:27:50.298] - stdout: TRUE
[08:27:50.299] - signal: TRUE
[08:27:50.299] - resignal: FALSE
[08:27:50.299] - force: TRUE
[08:27:50.299] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.299] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.299]  - until=2
[08:27:50.299]  - relaying element #2
[08:27:50.299] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.299] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.299] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.300]  length: 4 (resolved future 2)
[08:27:50.300] resolved() for ‘SequentialFuture’ ...
[08:27:50.300] - state: ‘finished’
[08:27:50.300] - run: TRUE
[08:27:50.300] - result: ‘FutureResult’
[08:27:50.300] resolved() for ‘SequentialFuture’ ... done
[08:27:50.300] Future #3
[08:27:50.300] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.300] - nx: 6
[08:27:50.300] - relay: TRUE
[08:27:50.300] - stdout: TRUE
[08:27:50.300] - signal: TRUE
[08:27:50.301] - resignal: FALSE
[08:27:50.301] - force: TRUE
[08:27:50.301] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.301] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.301]  - until=3
[08:27:50.301]  - relaying element #3
[08:27:50.301] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.301] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.301] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.301]  length: 3 (resolved future 3)
[08:27:50.301] signalConditionsASAP(NULL, pos=4) ...
[08:27:50.302] - nx: 6
[08:27:50.302] - relay: TRUE
[08:27:50.302] - stdout: TRUE
[08:27:50.302] - signal: TRUE
[08:27:50.302] - resignal: FALSE
[08:27:50.302] - force: TRUE
[08:27:50.302] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.302] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.302]  - until=5
[08:27:50.302]  - relaying element #5
[08:27:50.302] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.302] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.303] signalConditionsASAP(NULL, pos=4) ... done
[08:27:50.303]  length: 2 (resolved future 4)
[08:27:50.303] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.303] - nx: 6
[08:27:50.303] - relay: TRUE
[08:27:50.303] - stdout: TRUE
[08:27:50.303] - signal: TRUE
[08:27:50.303] - resignal: FALSE
[08:27:50.303] - force: TRUE
[08:27:50.303] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.303] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.303]  - until=6
[08:27:50.303]  - relaying element #6
[08:27:50.304] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.304] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.304] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.304]  length: 1 (resolved future 5)
[08:27:50.304] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.304] - nx: 6
[08:27:50.304] - relay: TRUE
[08:27:50.304] - stdout: TRUE
[08:27:50.304] - signal: TRUE
[08:27:50.304] - resignal: FALSE
[08:27:50.304] - force: TRUE
[08:27:50.304] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.305] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.305]  - until=6
[08:27:50.305] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.305] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.305] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.305]  length: 0 (resolved future 6)
[08:27:50.305] Relaying remaining futures
[08:27:50.305] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.305] - nx: 6
[08:27:50.305] - relay: TRUE
[08:27:50.305] - stdout: TRUE
[08:27:50.305] - signal: TRUE
[08:27:50.305] - resignal: FALSE
[08:27:50.306] - force: TRUE
[08:27:50.306] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.306] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:50.306] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.306] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.306] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.306] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[08:27:50.309] getGlobalsAndPackages() ...
[08:27:50.309] Searching for globals...
[08:27:50.310] 
[08:27:50.310] Searching for globals ... DONE
[08:27:50.310] - globals: [0] <none>
[08:27:50.310] getGlobalsAndPackages() ... DONE
[08:27:50.310] run() for ‘Future’ ...
[08:27:50.310] - state: ‘created’
[08:27:50.311] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.311] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.311]   - Field: ‘label’
[08:27:50.311]   - Field: ‘local’
[08:27:50.311]   - Field: ‘owner’
[08:27:50.311]   - Field: ‘envir’
[08:27:50.311]   - Field: ‘packages’
[08:27:50.311]   - Field: ‘gc’
[08:27:50.312]   - Field: ‘conditions’
[08:27:50.312]   - Field: ‘expr’
[08:27:50.312]   - Field: ‘uuid’
[08:27:50.312]   - Field: ‘seed’
[08:27:50.312]   - Field: ‘version’
[08:27:50.312]   - Field: ‘result’
[08:27:50.312]   - Field: ‘asynchronous’
[08:27:50.312]   - Field: ‘calls’
[08:27:50.312]   - Field: ‘globals’
[08:27:50.312]   - Field: ‘stdout’
[08:27:50.312]   - Field: ‘earlySignal’
[08:27:50.312]   - Field: ‘lazy’
[08:27:50.313]   - Field: ‘state’
[08:27:50.313] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.313] - Launch lazy future ...
[08:27:50.313] Packages needed by the future expression (n = 0): <none>
[08:27:50.313] Packages needed by future strategies (n = 0): <none>
[08:27:50.313] {
[08:27:50.313]     {
[08:27:50.313]         {
[08:27:50.313]             ...future.startTime <- base::Sys.time()
[08:27:50.313]             {
[08:27:50.313]                 {
[08:27:50.313]                   {
[08:27:50.313]                     base::local({
[08:27:50.313]                       has_future <- base::requireNamespace("future", 
[08:27:50.313]                         quietly = TRUE)
[08:27:50.313]                       if (has_future) {
[08:27:50.313]                         ns <- base::getNamespace("future")
[08:27:50.313]                         version <- ns[[".package"]][["version"]]
[08:27:50.313]                         if (is.null(version)) 
[08:27:50.313]                           version <- utils::packageVersion("future")
[08:27:50.313]                       }
[08:27:50.313]                       else {
[08:27:50.313]                         version <- NULL
[08:27:50.313]                       }
[08:27:50.313]                       if (!has_future || version < "1.8.0") {
[08:27:50.313]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.313]                           "", base::R.version$version.string), 
[08:27:50.313]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.313]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.313]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.313]                             "release", "version")], collapse = " "), 
[08:27:50.313]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.313]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.313]                           info)
[08:27:50.313]                         info <- base::paste(info, collapse = "; ")
[08:27:50.313]                         if (!has_future) {
[08:27:50.313]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.313]                             info)
[08:27:50.313]                         }
[08:27:50.313]                         else {
[08:27:50.313]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.313]                             info, version)
[08:27:50.313]                         }
[08:27:50.313]                         base::stop(msg)
[08:27:50.313]                       }
[08:27:50.313]                     })
[08:27:50.313]                   }
[08:27:50.313]                   ...future.strategy.old <- future::plan("list")
[08:27:50.313]                   options(future.plan = NULL)
[08:27:50.313]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.313]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.313]                 }
[08:27:50.313]                 ...future.workdir <- getwd()
[08:27:50.313]             }
[08:27:50.313]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.313]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.313]         }
[08:27:50.313]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.313]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.313]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.313]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.313]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.313]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.313]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.313]             base::names(...future.oldOptions))
[08:27:50.313]     }
[08:27:50.313]     if (FALSE) {
[08:27:50.313]     }
[08:27:50.313]     else {
[08:27:50.313]         if (TRUE) {
[08:27:50.313]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.313]                 open = "w")
[08:27:50.313]         }
[08:27:50.313]         else {
[08:27:50.313]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.313]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.313]         }
[08:27:50.313]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.313]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.313]             base::sink(type = "output", split = FALSE)
[08:27:50.313]             base::close(...future.stdout)
[08:27:50.313]         }, add = TRUE)
[08:27:50.313]     }
[08:27:50.313]     ...future.frame <- base::sys.nframe()
[08:27:50.313]     ...future.conditions <- base::list()
[08:27:50.313]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.313]     if (FALSE) {
[08:27:50.313]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.313]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.313]     }
[08:27:50.313]     ...future.result <- base::tryCatch({
[08:27:50.313]         base::withCallingHandlers({
[08:27:50.313]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.313]             future::FutureResult(value = ...future.value$value, 
[08:27:50.313]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.313]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.313]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.313]                     ...future.globalenv.names))
[08:27:50.313]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.313]         }, condition = base::local({
[08:27:50.313]             c <- base::c
[08:27:50.313]             inherits <- base::inherits
[08:27:50.313]             invokeRestart <- base::invokeRestart
[08:27:50.313]             length <- base::length
[08:27:50.313]             list <- base::list
[08:27:50.313]             seq.int <- base::seq.int
[08:27:50.313]             signalCondition <- base::signalCondition
[08:27:50.313]             sys.calls <- base::sys.calls
[08:27:50.313]             `[[` <- base::`[[`
[08:27:50.313]             `+` <- base::`+`
[08:27:50.313]             `<<-` <- base::`<<-`
[08:27:50.313]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.313]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.313]                   3L)]
[08:27:50.313]             }
[08:27:50.313]             function(cond) {
[08:27:50.313]                 is_error <- inherits(cond, "error")
[08:27:50.313]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.313]                   NULL)
[08:27:50.313]                 if (is_error) {
[08:27:50.313]                   sessionInformation <- function() {
[08:27:50.313]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.313]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.313]                       search = base::search(), system = base::Sys.info())
[08:27:50.313]                   }
[08:27:50.313]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.313]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.313]                     cond$call), session = sessionInformation(), 
[08:27:50.313]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.313]                   signalCondition(cond)
[08:27:50.313]                 }
[08:27:50.313]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.313]                 "immediateCondition"))) {
[08:27:50.313]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.313]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.313]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.313]                   if (TRUE && !signal) {
[08:27:50.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.313]                     {
[08:27:50.313]                       inherits <- base::inherits
[08:27:50.313]                       invokeRestart <- base::invokeRestart
[08:27:50.313]                       is.null <- base::is.null
[08:27:50.313]                       muffled <- FALSE
[08:27:50.313]                       if (inherits(cond, "message")) {
[08:27:50.313]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.313]                         if (muffled) 
[08:27:50.313]                           invokeRestart("muffleMessage")
[08:27:50.313]                       }
[08:27:50.313]                       else if (inherits(cond, "warning")) {
[08:27:50.313]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.313]                         if (muffled) 
[08:27:50.313]                           invokeRestart("muffleWarning")
[08:27:50.313]                       }
[08:27:50.313]                       else if (inherits(cond, "condition")) {
[08:27:50.313]                         if (!is.null(pattern)) {
[08:27:50.313]                           computeRestarts <- base::computeRestarts
[08:27:50.313]                           grepl <- base::grepl
[08:27:50.313]                           restarts <- computeRestarts(cond)
[08:27:50.313]                           for (restart in restarts) {
[08:27:50.313]                             name <- restart$name
[08:27:50.313]                             if (is.null(name)) 
[08:27:50.313]                               next
[08:27:50.313]                             if (!grepl(pattern, name)) 
[08:27:50.313]                               next
[08:27:50.313]                             invokeRestart(restart)
[08:27:50.313]                             muffled <- TRUE
[08:27:50.313]                             break
[08:27:50.313]                           }
[08:27:50.313]                         }
[08:27:50.313]                       }
[08:27:50.313]                       invisible(muffled)
[08:27:50.313]                     }
[08:27:50.313]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.313]                   }
[08:27:50.313]                 }
[08:27:50.313]                 else {
[08:27:50.313]                   if (TRUE) {
[08:27:50.313]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.313]                     {
[08:27:50.313]                       inherits <- base::inherits
[08:27:50.313]                       invokeRestart <- base::invokeRestart
[08:27:50.313]                       is.null <- base::is.null
[08:27:50.313]                       muffled <- FALSE
[08:27:50.313]                       if (inherits(cond, "message")) {
[08:27:50.313]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.313]                         if (muffled) 
[08:27:50.313]                           invokeRestart("muffleMessage")
[08:27:50.313]                       }
[08:27:50.313]                       else if (inherits(cond, "warning")) {
[08:27:50.313]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.313]                         if (muffled) 
[08:27:50.313]                           invokeRestart("muffleWarning")
[08:27:50.313]                       }
[08:27:50.313]                       else if (inherits(cond, "condition")) {
[08:27:50.313]                         if (!is.null(pattern)) {
[08:27:50.313]                           computeRestarts <- base::computeRestarts
[08:27:50.313]                           grepl <- base::grepl
[08:27:50.313]                           restarts <- computeRestarts(cond)
[08:27:50.313]                           for (restart in restarts) {
[08:27:50.313]                             name <- restart$name
[08:27:50.313]                             if (is.null(name)) 
[08:27:50.313]                               next
[08:27:50.313]                             if (!grepl(pattern, name)) 
[08:27:50.313]                               next
[08:27:50.313]                             invokeRestart(restart)
[08:27:50.313]                             muffled <- TRUE
[08:27:50.313]                             break
[08:27:50.313]                           }
[08:27:50.313]                         }
[08:27:50.313]                       }
[08:27:50.313]                       invisible(muffled)
[08:27:50.313]                     }
[08:27:50.313]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.313]                   }
[08:27:50.313]                 }
[08:27:50.313]             }
[08:27:50.313]         }))
[08:27:50.313]     }, error = function(ex) {
[08:27:50.313]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.313]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.313]                 ...future.rng), started = ...future.startTime, 
[08:27:50.313]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.313]             version = "1.8"), class = "FutureResult")
[08:27:50.313]     }, finally = {
[08:27:50.313]         if (!identical(...future.workdir, getwd())) 
[08:27:50.313]             setwd(...future.workdir)
[08:27:50.313]         {
[08:27:50.313]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.313]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.313]             }
[08:27:50.313]             base::options(...future.oldOptions)
[08:27:50.313]             if (.Platform$OS.type == "windows") {
[08:27:50.313]                 old_names <- names(...future.oldEnvVars)
[08:27:50.313]                 envs <- base::Sys.getenv()
[08:27:50.313]                 names <- names(envs)
[08:27:50.313]                 common <- intersect(names, old_names)
[08:27:50.313]                 added <- setdiff(names, old_names)
[08:27:50.313]                 removed <- setdiff(old_names, names)
[08:27:50.313]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.313]                   envs[common]]
[08:27:50.313]                 NAMES <- toupper(changed)
[08:27:50.313]                 args <- list()
[08:27:50.313]                 for (kk in seq_along(NAMES)) {
[08:27:50.313]                   name <- changed[[kk]]
[08:27:50.313]                   NAME <- NAMES[[kk]]
[08:27:50.313]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.313]                     next
[08:27:50.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.313]                 }
[08:27:50.313]                 NAMES <- toupper(added)
[08:27:50.313]                 for (kk in seq_along(NAMES)) {
[08:27:50.313]                   name <- added[[kk]]
[08:27:50.313]                   NAME <- NAMES[[kk]]
[08:27:50.313]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.313]                     next
[08:27:50.313]                   args[[name]] <- ""
[08:27:50.313]                 }
[08:27:50.313]                 NAMES <- toupper(removed)
[08:27:50.313]                 for (kk in seq_along(NAMES)) {
[08:27:50.313]                   name <- removed[[kk]]
[08:27:50.313]                   NAME <- NAMES[[kk]]
[08:27:50.313]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.313]                     next
[08:27:50.313]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.313]                 }
[08:27:50.313]                 if (length(args) > 0) 
[08:27:50.313]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.313]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.313]             }
[08:27:50.313]             else {
[08:27:50.313]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.313]             }
[08:27:50.313]             {
[08:27:50.313]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.313]                   0L) {
[08:27:50.313]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.313]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.313]                   base::options(opts)
[08:27:50.313]                 }
[08:27:50.313]                 {
[08:27:50.313]                   {
[08:27:50.313]                     NULL
[08:27:50.313]                     RNGkind("Mersenne-Twister")
[08:27:50.313]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.313]                       inherits = FALSE)
[08:27:50.313]                   }
[08:27:50.313]                   options(future.plan = NULL)
[08:27:50.313]                   if (is.na(NA_character_)) 
[08:27:50.313]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.313]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.313]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.313]                     .init = FALSE)
[08:27:50.313]                 }
[08:27:50.313]             }
[08:27:50.313]         }
[08:27:50.313]     })
[08:27:50.313]     if (TRUE) {
[08:27:50.313]         base::sink(type = "output", split = FALSE)
[08:27:50.313]         if (TRUE) {
[08:27:50.313]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.313]         }
[08:27:50.313]         else {
[08:27:50.313]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.313]         }
[08:27:50.313]         base::close(...future.stdout)
[08:27:50.313]         ...future.stdout <- NULL
[08:27:50.313]     }
[08:27:50.313]     ...future.result$conditions <- ...future.conditions
[08:27:50.313]     ...future.result$finished <- base::Sys.time()
[08:27:50.313]     ...future.result
[08:27:50.313] }
[08:27:50.315] plan(): Setting new future strategy stack:
[08:27:50.315] List of future strategies:
[08:27:50.315] 1. sequential:
[08:27:50.315]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.315]    - tweaked: FALSE
[08:27:50.315]    - call: NULL
[08:27:50.316] plan(): nbrOfWorkers() = 1
[08:27:50.317] plan(): Setting new future strategy stack:
[08:27:50.317] List of future strategies:
[08:27:50.317] 1. sequential:
[08:27:50.317]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.317]    - tweaked: FALSE
[08:27:50.317]    - call: plan(strategy)
[08:27:50.317] plan(): nbrOfWorkers() = 1
[08:27:50.317] SequentialFuture started (and completed)
[08:27:50.317] - Launch lazy future ... done
[08:27:50.317] run() for ‘SequentialFuture’ ... done
[08:27:50.318] getGlobalsAndPackages() ...
[08:27:50.318] Searching for globals...
[08:27:50.318] 
[08:27:50.318] Searching for globals ... DONE
[08:27:50.318] - globals: [0] <none>
[08:27:50.318] getGlobalsAndPackages() ... DONE
[08:27:50.318] run() for ‘Future’ ...
[08:27:50.318] - state: ‘created’
[08:27:50.319] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.319] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.319] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.319]   - Field: ‘label’
[08:27:50.319]   - Field: ‘local’
[08:27:50.319]   - Field: ‘owner’
[08:27:50.319]   - Field: ‘envir’
[08:27:50.319]   - Field: ‘packages’
[08:27:50.319]   - Field: ‘gc’
[08:27:50.320]   - Field: ‘conditions’
[08:27:50.320]   - Field: ‘expr’
[08:27:50.320]   - Field: ‘uuid’
[08:27:50.320]   - Field: ‘seed’
[08:27:50.320]   - Field: ‘version’
[08:27:50.320]   - Field: ‘result’
[08:27:50.320]   - Field: ‘asynchronous’
[08:27:50.320]   - Field: ‘calls’
[08:27:50.320]   - Field: ‘globals’
[08:27:50.320]   - Field: ‘stdout’
[08:27:50.320]   - Field: ‘earlySignal’
[08:27:50.320]   - Field: ‘lazy’
[08:27:50.321]   - Field: ‘state’
[08:27:50.321] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.321] - Launch lazy future ...
[08:27:50.321] Packages needed by the future expression (n = 0): <none>
[08:27:50.321] Packages needed by future strategies (n = 0): <none>
[08:27:50.321] {
[08:27:50.321]     {
[08:27:50.321]         {
[08:27:50.321]             ...future.startTime <- base::Sys.time()
[08:27:50.321]             {
[08:27:50.321]                 {
[08:27:50.321]                   {
[08:27:50.321]                     base::local({
[08:27:50.321]                       has_future <- base::requireNamespace("future", 
[08:27:50.321]                         quietly = TRUE)
[08:27:50.321]                       if (has_future) {
[08:27:50.321]                         ns <- base::getNamespace("future")
[08:27:50.321]                         version <- ns[[".package"]][["version"]]
[08:27:50.321]                         if (is.null(version)) 
[08:27:50.321]                           version <- utils::packageVersion("future")
[08:27:50.321]                       }
[08:27:50.321]                       else {
[08:27:50.321]                         version <- NULL
[08:27:50.321]                       }
[08:27:50.321]                       if (!has_future || version < "1.8.0") {
[08:27:50.321]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.321]                           "", base::R.version$version.string), 
[08:27:50.321]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.321]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.321]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.321]                             "release", "version")], collapse = " "), 
[08:27:50.321]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.321]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.321]                           info)
[08:27:50.321]                         info <- base::paste(info, collapse = "; ")
[08:27:50.321]                         if (!has_future) {
[08:27:50.321]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.321]                             info)
[08:27:50.321]                         }
[08:27:50.321]                         else {
[08:27:50.321]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.321]                             info, version)
[08:27:50.321]                         }
[08:27:50.321]                         base::stop(msg)
[08:27:50.321]                       }
[08:27:50.321]                     })
[08:27:50.321]                   }
[08:27:50.321]                   ...future.strategy.old <- future::plan("list")
[08:27:50.321]                   options(future.plan = NULL)
[08:27:50.321]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.321]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.321]                 }
[08:27:50.321]                 ...future.workdir <- getwd()
[08:27:50.321]             }
[08:27:50.321]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.321]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.321]         }
[08:27:50.321]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.321]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.321]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.321]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.321]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.321]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.321]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.321]             base::names(...future.oldOptions))
[08:27:50.321]     }
[08:27:50.321]     if (FALSE) {
[08:27:50.321]     }
[08:27:50.321]     else {
[08:27:50.321]         if (TRUE) {
[08:27:50.321]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.321]                 open = "w")
[08:27:50.321]         }
[08:27:50.321]         else {
[08:27:50.321]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.321]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.321]         }
[08:27:50.321]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.321]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.321]             base::sink(type = "output", split = FALSE)
[08:27:50.321]             base::close(...future.stdout)
[08:27:50.321]         }, add = TRUE)
[08:27:50.321]     }
[08:27:50.321]     ...future.frame <- base::sys.nframe()
[08:27:50.321]     ...future.conditions <- base::list()
[08:27:50.321]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.321]     if (FALSE) {
[08:27:50.321]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.321]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.321]     }
[08:27:50.321]     ...future.result <- base::tryCatch({
[08:27:50.321]         base::withCallingHandlers({
[08:27:50.321]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.321]             future::FutureResult(value = ...future.value$value, 
[08:27:50.321]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.321]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.321]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.321]                     ...future.globalenv.names))
[08:27:50.321]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.321]         }, condition = base::local({
[08:27:50.321]             c <- base::c
[08:27:50.321]             inherits <- base::inherits
[08:27:50.321]             invokeRestart <- base::invokeRestart
[08:27:50.321]             length <- base::length
[08:27:50.321]             list <- base::list
[08:27:50.321]             seq.int <- base::seq.int
[08:27:50.321]             signalCondition <- base::signalCondition
[08:27:50.321]             sys.calls <- base::sys.calls
[08:27:50.321]             `[[` <- base::`[[`
[08:27:50.321]             `+` <- base::`+`
[08:27:50.321]             `<<-` <- base::`<<-`
[08:27:50.321]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.321]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.321]                   3L)]
[08:27:50.321]             }
[08:27:50.321]             function(cond) {
[08:27:50.321]                 is_error <- inherits(cond, "error")
[08:27:50.321]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.321]                   NULL)
[08:27:50.321]                 if (is_error) {
[08:27:50.321]                   sessionInformation <- function() {
[08:27:50.321]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.321]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.321]                       search = base::search(), system = base::Sys.info())
[08:27:50.321]                   }
[08:27:50.321]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.321]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.321]                     cond$call), session = sessionInformation(), 
[08:27:50.321]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.321]                   signalCondition(cond)
[08:27:50.321]                 }
[08:27:50.321]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.321]                 "immediateCondition"))) {
[08:27:50.321]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.321]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.321]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.321]                   if (TRUE && !signal) {
[08:27:50.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.321]                     {
[08:27:50.321]                       inherits <- base::inherits
[08:27:50.321]                       invokeRestart <- base::invokeRestart
[08:27:50.321]                       is.null <- base::is.null
[08:27:50.321]                       muffled <- FALSE
[08:27:50.321]                       if (inherits(cond, "message")) {
[08:27:50.321]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.321]                         if (muffled) 
[08:27:50.321]                           invokeRestart("muffleMessage")
[08:27:50.321]                       }
[08:27:50.321]                       else if (inherits(cond, "warning")) {
[08:27:50.321]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.321]                         if (muffled) 
[08:27:50.321]                           invokeRestart("muffleWarning")
[08:27:50.321]                       }
[08:27:50.321]                       else if (inherits(cond, "condition")) {
[08:27:50.321]                         if (!is.null(pattern)) {
[08:27:50.321]                           computeRestarts <- base::computeRestarts
[08:27:50.321]                           grepl <- base::grepl
[08:27:50.321]                           restarts <- computeRestarts(cond)
[08:27:50.321]                           for (restart in restarts) {
[08:27:50.321]                             name <- restart$name
[08:27:50.321]                             if (is.null(name)) 
[08:27:50.321]                               next
[08:27:50.321]                             if (!grepl(pattern, name)) 
[08:27:50.321]                               next
[08:27:50.321]                             invokeRestart(restart)
[08:27:50.321]                             muffled <- TRUE
[08:27:50.321]                             break
[08:27:50.321]                           }
[08:27:50.321]                         }
[08:27:50.321]                       }
[08:27:50.321]                       invisible(muffled)
[08:27:50.321]                     }
[08:27:50.321]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.321]                   }
[08:27:50.321]                 }
[08:27:50.321]                 else {
[08:27:50.321]                   if (TRUE) {
[08:27:50.321]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.321]                     {
[08:27:50.321]                       inherits <- base::inherits
[08:27:50.321]                       invokeRestart <- base::invokeRestart
[08:27:50.321]                       is.null <- base::is.null
[08:27:50.321]                       muffled <- FALSE
[08:27:50.321]                       if (inherits(cond, "message")) {
[08:27:50.321]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.321]                         if (muffled) 
[08:27:50.321]                           invokeRestart("muffleMessage")
[08:27:50.321]                       }
[08:27:50.321]                       else if (inherits(cond, "warning")) {
[08:27:50.321]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.321]                         if (muffled) 
[08:27:50.321]                           invokeRestart("muffleWarning")
[08:27:50.321]                       }
[08:27:50.321]                       else if (inherits(cond, "condition")) {
[08:27:50.321]                         if (!is.null(pattern)) {
[08:27:50.321]                           computeRestarts <- base::computeRestarts
[08:27:50.321]                           grepl <- base::grepl
[08:27:50.321]                           restarts <- computeRestarts(cond)
[08:27:50.321]                           for (restart in restarts) {
[08:27:50.321]                             name <- restart$name
[08:27:50.321]                             if (is.null(name)) 
[08:27:50.321]                               next
[08:27:50.321]                             if (!grepl(pattern, name)) 
[08:27:50.321]                               next
[08:27:50.321]                             invokeRestart(restart)
[08:27:50.321]                             muffled <- TRUE
[08:27:50.321]                             break
[08:27:50.321]                           }
[08:27:50.321]                         }
[08:27:50.321]                       }
[08:27:50.321]                       invisible(muffled)
[08:27:50.321]                     }
[08:27:50.321]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.321]                   }
[08:27:50.321]                 }
[08:27:50.321]             }
[08:27:50.321]         }))
[08:27:50.321]     }, error = function(ex) {
[08:27:50.321]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.321]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.321]                 ...future.rng), started = ...future.startTime, 
[08:27:50.321]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.321]             version = "1.8"), class = "FutureResult")
[08:27:50.321]     }, finally = {
[08:27:50.321]         if (!identical(...future.workdir, getwd())) 
[08:27:50.321]             setwd(...future.workdir)
[08:27:50.321]         {
[08:27:50.321]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.321]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.321]             }
[08:27:50.321]             base::options(...future.oldOptions)
[08:27:50.321]             if (.Platform$OS.type == "windows") {
[08:27:50.321]                 old_names <- names(...future.oldEnvVars)
[08:27:50.321]                 envs <- base::Sys.getenv()
[08:27:50.321]                 names <- names(envs)
[08:27:50.321]                 common <- intersect(names, old_names)
[08:27:50.321]                 added <- setdiff(names, old_names)
[08:27:50.321]                 removed <- setdiff(old_names, names)
[08:27:50.321]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.321]                   envs[common]]
[08:27:50.321]                 NAMES <- toupper(changed)
[08:27:50.321]                 args <- list()
[08:27:50.321]                 for (kk in seq_along(NAMES)) {
[08:27:50.321]                   name <- changed[[kk]]
[08:27:50.321]                   NAME <- NAMES[[kk]]
[08:27:50.321]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.321]                     next
[08:27:50.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.321]                 }
[08:27:50.321]                 NAMES <- toupper(added)
[08:27:50.321]                 for (kk in seq_along(NAMES)) {
[08:27:50.321]                   name <- added[[kk]]
[08:27:50.321]                   NAME <- NAMES[[kk]]
[08:27:50.321]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.321]                     next
[08:27:50.321]                   args[[name]] <- ""
[08:27:50.321]                 }
[08:27:50.321]                 NAMES <- toupper(removed)
[08:27:50.321]                 for (kk in seq_along(NAMES)) {
[08:27:50.321]                   name <- removed[[kk]]
[08:27:50.321]                   NAME <- NAMES[[kk]]
[08:27:50.321]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.321]                     next
[08:27:50.321]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.321]                 }
[08:27:50.321]                 if (length(args) > 0) 
[08:27:50.321]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.321]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.321]             }
[08:27:50.321]             else {
[08:27:50.321]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.321]             }
[08:27:50.321]             {
[08:27:50.321]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.321]                   0L) {
[08:27:50.321]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.321]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.321]                   base::options(opts)
[08:27:50.321]                 }
[08:27:50.321]                 {
[08:27:50.321]                   {
[08:27:50.321]                     NULL
[08:27:50.321]                     RNGkind("Mersenne-Twister")
[08:27:50.321]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.321]                       inherits = FALSE)
[08:27:50.321]                   }
[08:27:50.321]                   options(future.plan = NULL)
[08:27:50.321]                   if (is.na(NA_character_)) 
[08:27:50.321]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.321]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.321]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.321]                     .init = FALSE)
[08:27:50.321]                 }
[08:27:50.321]             }
[08:27:50.321]         }
[08:27:50.321]     })
[08:27:50.321]     if (TRUE) {
[08:27:50.321]         base::sink(type = "output", split = FALSE)
[08:27:50.321]         if (TRUE) {
[08:27:50.321]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.321]         }
[08:27:50.321]         else {
[08:27:50.321]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.321]         }
[08:27:50.321]         base::close(...future.stdout)
[08:27:50.321]         ...future.stdout <- NULL
[08:27:50.321]     }
[08:27:50.321]     ...future.result$conditions <- ...future.conditions
[08:27:50.321]     ...future.result$finished <- base::Sys.time()
[08:27:50.321]     ...future.result
[08:27:50.321] }
[08:27:50.323] plan(): Setting new future strategy stack:
[08:27:50.323] List of future strategies:
[08:27:50.323] 1. sequential:
[08:27:50.323]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.323]    - tweaked: FALSE
[08:27:50.323]    - call: NULL
[08:27:50.324] plan(): nbrOfWorkers() = 1
[08:27:50.324] plan(): Setting new future strategy stack:
[08:27:50.325] List of future strategies:
[08:27:50.325] 1. sequential:
[08:27:50.325]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.325]    - tweaked: FALSE
[08:27:50.325]    - call: plan(strategy)
[08:27:50.325] plan(): nbrOfWorkers() = 1
[08:27:50.325] SequentialFuture started (and completed)
[08:27:50.325] - Launch lazy future ... done
[08:27:50.325] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860a4c1e0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860ea3618> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860a4c1e0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55d860ea3618> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[08:27:50.332] resolved() for ‘SequentialFuture’ ...
[08:27:50.332] - state: ‘finished’
[08:27:50.332] - run: TRUE
[08:27:50.332] - result: ‘FutureResult’
[08:27:50.332] resolved() for ‘SequentialFuture’ ... done
[08:27:50.333] resolved() for ‘SequentialFuture’ ...
[08:27:50.333] - state: ‘finished’
[08:27:50.333] - run: TRUE
[08:27:50.333] - result: ‘FutureResult’
[08:27:50.333] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:50.335] resolve() on list ...
[08:27:50.335]  recursive: 0
[08:27:50.335]  length: 6
[08:27:50.335]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:50.335] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.335] - nx: 6
[08:27:50.335] - relay: TRUE
[08:27:50.335] - stdout: TRUE
[08:27:50.335] - signal: TRUE
[08:27:50.335] - resignal: FALSE
[08:27:50.336] - force: TRUE
[08:27:50.336] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.336] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.336]  - until=2
[08:27:50.336]  - relaying element #2
[08:27:50.336] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.336] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.336] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.336]  length: 5 (resolved future 1)
[08:27:50.336] resolved() for ‘SequentialFuture’ ...
[08:27:50.336] - state: ‘finished’
[08:27:50.337] - run: TRUE
[08:27:50.337] - result: ‘FutureResult’
[08:27:50.337] resolved() for ‘SequentialFuture’ ... done
[08:27:50.337] Future #2
[08:27:50.337] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.337] - nx: 6
[08:27:50.337] - relay: TRUE
[08:27:50.337] - stdout: TRUE
[08:27:50.337] - signal: TRUE
[08:27:50.337] - resignal: FALSE
[08:27:50.337] - force: TRUE
[08:27:50.337] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.338] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.338]  - until=2
[08:27:50.338]  - relaying element #2
[08:27:50.338] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.338] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.338] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.338]  length: 4 (resolved future 2)
[08:27:50.338] resolved() for ‘SequentialFuture’ ...
[08:27:50.338] - state: ‘finished’
[08:27:50.338] - run: TRUE
[08:27:50.339] - result: ‘FutureResult’
[08:27:50.339] resolved() for ‘SequentialFuture’ ... done
[08:27:50.339] Future #3
[08:27:50.339] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.339] - nx: 6
[08:27:50.339] - relay: TRUE
[08:27:50.339] - stdout: TRUE
[08:27:50.339] - signal: TRUE
[08:27:50.339] - resignal: FALSE
[08:27:50.339] - force: TRUE
[08:27:50.339] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.339] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.340]  - until=3
[08:27:50.340]  - relaying element #3
[08:27:50.340] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.340] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.340] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.340]  length: 3 (resolved future 3)
[08:27:50.340] signalConditionsASAP(NULL, pos=4) ...
[08:27:50.340] - nx: 6
[08:27:50.340] - relay: TRUE
[08:27:50.340] - stdout: TRUE
[08:27:50.340] - signal: TRUE
[08:27:50.340] - resignal: FALSE
[08:27:50.341] - force: TRUE
[08:27:50.341] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.341] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.341]  - until=5
[08:27:50.341]  - relaying element #5
[08:27:50.341] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.341] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.341] signalConditionsASAP(NULL, pos=4) ... done
[08:27:50.341]  length: 2 (resolved future 4)
[08:27:50.341] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.341] - nx: 6
[08:27:50.341] - relay: TRUE
[08:27:50.341] - stdout: TRUE
[08:27:50.342] - signal: TRUE
[08:27:50.342] - resignal: FALSE
[08:27:50.342] - force: TRUE
[08:27:50.342] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.342] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.342]  - until=6
[08:27:50.342]  - relaying element #6
[08:27:50.342] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.342] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.342] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.342]  length: 1 (resolved future 5)
[08:27:50.342] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.343] - nx: 6
[08:27:50.343] - relay: TRUE
[08:27:50.343] - stdout: TRUE
[08:27:50.343] - signal: TRUE
[08:27:50.343] - resignal: FALSE
[08:27:50.343] - force: TRUE
[08:27:50.343] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.343] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.343]  - until=6
[08:27:50.343] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.343] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.343] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.343]  length: 0 (resolved future 6)
[08:27:50.344] Relaying remaining futures
[08:27:50.344] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.344] - nx: 6
[08:27:50.344] - relay: TRUE
[08:27:50.344] - stdout: TRUE
[08:27:50.344] - signal: TRUE
[08:27:50.344] - resignal: FALSE
[08:27:50.344] - force: TRUE
[08:27:50.344] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.344] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:50.344] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.344] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.345] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.345] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[08:27:50.355] plan(): Setting new future strategy stack:
[08:27:50.355] List of future strategies:
[08:27:50.355] 1. sequential:
[08:27:50.355]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.355]    - tweaked: FALSE
[08:27:50.355]    - call: plan(strategy)
[08:27:50.355] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[08:27:50.355] getGlobalsAndPackages() ...
[08:27:50.355] Searching for globals...
[08:27:50.356] 
[08:27:50.356] Searching for globals ... DONE
[08:27:50.356] - globals: [0] <none>
[08:27:50.356] getGlobalsAndPackages() ... DONE
[08:27:50.356] run() for ‘Future’ ...
[08:27:50.356] - state: ‘created’
[08:27:50.356] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.357] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.357]   - Field: ‘label’
[08:27:50.357]   - Field: ‘local’
[08:27:50.357]   - Field: ‘owner’
[08:27:50.357]   - Field: ‘envir’
[08:27:50.357]   - Field: ‘packages’
[08:27:50.357]   - Field: ‘gc’
[08:27:50.357]   - Field: ‘conditions’
[08:27:50.358]   - Field: ‘expr’
[08:27:50.358]   - Field: ‘uuid’
[08:27:50.358]   - Field: ‘seed’
[08:27:50.358]   - Field: ‘version’
[08:27:50.358]   - Field: ‘result’
[08:27:50.358]   - Field: ‘asynchronous’
[08:27:50.358]   - Field: ‘calls’
[08:27:50.358]   - Field: ‘globals’
[08:27:50.358]   - Field: ‘stdout’
[08:27:50.358]   - Field: ‘earlySignal’
[08:27:50.358]   - Field: ‘lazy’
[08:27:50.358]   - Field: ‘state’
[08:27:50.359] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.359] - Launch lazy future ...
[08:27:50.359] Packages needed by the future expression (n = 0): <none>
[08:27:50.359] Packages needed by future strategies (n = 0): <none>
[08:27:50.359] {
[08:27:50.359]     {
[08:27:50.359]         {
[08:27:50.359]             ...future.startTime <- base::Sys.time()
[08:27:50.359]             {
[08:27:50.359]                 {
[08:27:50.359]                   {
[08:27:50.359]                     base::local({
[08:27:50.359]                       has_future <- base::requireNamespace("future", 
[08:27:50.359]                         quietly = TRUE)
[08:27:50.359]                       if (has_future) {
[08:27:50.359]                         ns <- base::getNamespace("future")
[08:27:50.359]                         version <- ns[[".package"]][["version"]]
[08:27:50.359]                         if (is.null(version)) 
[08:27:50.359]                           version <- utils::packageVersion("future")
[08:27:50.359]                       }
[08:27:50.359]                       else {
[08:27:50.359]                         version <- NULL
[08:27:50.359]                       }
[08:27:50.359]                       if (!has_future || version < "1.8.0") {
[08:27:50.359]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.359]                           "", base::R.version$version.string), 
[08:27:50.359]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.359]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.359]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.359]                             "release", "version")], collapse = " "), 
[08:27:50.359]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.359]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.359]                           info)
[08:27:50.359]                         info <- base::paste(info, collapse = "; ")
[08:27:50.359]                         if (!has_future) {
[08:27:50.359]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.359]                             info)
[08:27:50.359]                         }
[08:27:50.359]                         else {
[08:27:50.359]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.359]                             info, version)
[08:27:50.359]                         }
[08:27:50.359]                         base::stop(msg)
[08:27:50.359]                       }
[08:27:50.359]                     })
[08:27:50.359]                   }
[08:27:50.359]                   ...future.strategy.old <- future::plan("list")
[08:27:50.359]                   options(future.plan = NULL)
[08:27:50.359]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.359]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.359]                 }
[08:27:50.359]                 ...future.workdir <- getwd()
[08:27:50.359]             }
[08:27:50.359]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.359]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.359]         }
[08:27:50.359]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.359]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.359]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.359]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.359]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.359]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.359]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.359]             base::names(...future.oldOptions))
[08:27:50.359]     }
[08:27:50.359]     if (FALSE) {
[08:27:50.359]     }
[08:27:50.359]     else {
[08:27:50.359]         if (TRUE) {
[08:27:50.359]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.359]                 open = "w")
[08:27:50.359]         }
[08:27:50.359]         else {
[08:27:50.359]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.359]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.359]         }
[08:27:50.359]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.359]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.359]             base::sink(type = "output", split = FALSE)
[08:27:50.359]             base::close(...future.stdout)
[08:27:50.359]         }, add = TRUE)
[08:27:50.359]     }
[08:27:50.359]     ...future.frame <- base::sys.nframe()
[08:27:50.359]     ...future.conditions <- base::list()
[08:27:50.359]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.359]     if (FALSE) {
[08:27:50.359]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.359]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.359]     }
[08:27:50.359]     ...future.result <- base::tryCatch({
[08:27:50.359]         base::withCallingHandlers({
[08:27:50.359]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.359]             future::FutureResult(value = ...future.value$value, 
[08:27:50.359]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.359]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.359]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.359]                     ...future.globalenv.names))
[08:27:50.359]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.359]         }, condition = base::local({
[08:27:50.359]             c <- base::c
[08:27:50.359]             inherits <- base::inherits
[08:27:50.359]             invokeRestart <- base::invokeRestart
[08:27:50.359]             length <- base::length
[08:27:50.359]             list <- base::list
[08:27:50.359]             seq.int <- base::seq.int
[08:27:50.359]             signalCondition <- base::signalCondition
[08:27:50.359]             sys.calls <- base::sys.calls
[08:27:50.359]             `[[` <- base::`[[`
[08:27:50.359]             `+` <- base::`+`
[08:27:50.359]             `<<-` <- base::`<<-`
[08:27:50.359]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.359]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.359]                   3L)]
[08:27:50.359]             }
[08:27:50.359]             function(cond) {
[08:27:50.359]                 is_error <- inherits(cond, "error")
[08:27:50.359]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.359]                   NULL)
[08:27:50.359]                 if (is_error) {
[08:27:50.359]                   sessionInformation <- function() {
[08:27:50.359]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.359]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.359]                       search = base::search(), system = base::Sys.info())
[08:27:50.359]                   }
[08:27:50.359]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.359]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.359]                     cond$call), session = sessionInformation(), 
[08:27:50.359]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.359]                   signalCondition(cond)
[08:27:50.359]                 }
[08:27:50.359]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.359]                 "immediateCondition"))) {
[08:27:50.359]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.359]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.359]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.359]                   if (TRUE && !signal) {
[08:27:50.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.359]                     {
[08:27:50.359]                       inherits <- base::inherits
[08:27:50.359]                       invokeRestart <- base::invokeRestart
[08:27:50.359]                       is.null <- base::is.null
[08:27:50.359]                       muffled <- FALSE
[08:27:50.359]                       if (inherits(cond, "message")) {
[08:27:50.359]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.359]                         if (muffled) 
[08:27:50.359]                           invokeRestart("muffleMessage")
[08:27:50.359]                       }
[08:27:50.359]                       else if (inherits(cond, "warning")) {
[08:27:50.359]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.359]                         if (muffled) 
[08:27:50.359]                           invokeRestart("muffleWarning")
[08:27:50.359]                       }
[08:27:50.359]                       else if (inherits(cond, "condition")) {
[08:27:50.359]                         if (!is.null(pattern)) {
[08:27:50.359]                           computeRestarts <- base::computeRestarts
[08:27:50.359]                           grepl <- base::grepl
[08:27:50.359]                           restarts <- computeRestarts(cond)
[08:27:50.359]                           for (restart in restarts) {
[08:27:50.359]                             name <- restart$name
[08:27:50.359]                             if (is.null(name)) 
[08:27:50.359]                               next
[08:27:50.359]                             if (!grepl(pattern, name)) 
[08:27:50.359]                               next
[08:27:50.359]                             invokeRestart(restart)
[08:27:50.359]                             muffled <- TRUE
[08:27:50.359]                             break
[08:27:50.359]                           }
[08:27:50.359]                         }
[08:27:50.359]                       }
[08:27:50.359]                       invisible(muffled)
[08:27:50.359]                     }
[08:27:50.359]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.359]                   }
[08:27:50.359]                 }
[08:27:50.359]                 else {
[08:27:50.359]                   if (TRUE) {
[08:27:50.359]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.359]                     {
[08:27:50.359]                       inherits <- base::inherits
[08:27:50.359]                       invokeRestart <- base::invokeRestart
[08:27:50.359]                       is.null <- base::is.null
[08:27:50.359]                       muffled <- FALSE
[08:27:50.359]                       if (inherits(cond, "message")) {
[08:27:50.359]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.359]                         if (muffled) 
[08:27:50.359]                           invokeRestart("muffleMessage")
[08:27:50.359]                       }
[08:27:50.359]                       else if (inherits(cond, "warning")) {
[08:27:50.359]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.359]                         if (muffled) 
[08:27:50.359]                           invokeRestart("muffleWarning")
[08:27:50.359]                       }
[08:27:50.359]                       else if (inherits(cond, "condition")) {
[08:27:50.359]                         if (!is.null(pattern)) {
[08:27:50.359]                           computeRestarts <- base::computeRestarts
[08:27:50.359]                           grepl <- base::grepl
[08:27:50.359]                           restarts <- computeRestarts(cond)
[08:27:50.359]                           for (restart in restarts) {
[08:27:50.359]                             name <- restart$name
[08:27:50.359]                             if (is.null(name)) 
[08:27:50.359]                               next
[08:27:50.359]                             if (!grepl(pattern, name)) 
[08:27:50.359]                               next
[08:27:50.359]                             invokeRestart(restart)
[08:27:50.359]                             muffled <- TRUE
[08:27:50.359]                             break
[08:27:50.359]                           }
[08:27:50.359]                         }
[08:27:50.359]                       }
[08:27:50.359]                       invisible(muffled)
[08:27:50.359]                     }
[08:27:50.359]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.359]                   }
[08:27:50.359]                 }
[08:27:50.359]             }
[08:27:50.359]         }))
[08:27:50.359]     }, error = function(ex) {
[08:27:50.359]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.359]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.359]                 ...future.rng), started = ...future.startTime, 
[08:27:50.359]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.359]             version = "1.8"), class = "FutureResult")
[08:27:50.359]     }, finally = {
[08:27:50.359]         if (!identical(...future.workdir, getwd())) 
[08:27:50.359]             setwd(...future.workdir)
[08:27:50.359]         {
[08:27:50.359]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.359]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.359]             }
[08:27:50.359]             base::options(...future.oldOptions)
[08:27:50.359]             if (.Platform$OS.type == "windows") {
[08:27:50.359]                 old_names <- names(...future.oldEnvVars)
[08:27:50.359]                 envs <- base::Sys.getenv()
[08:27:50.359]                 names <- names(envs)
[08:27:50.359]                 common <- intersect(names, old_names)
[08:27:50.359]                 added <- setdiff(names, old_names)
[08:27:50.359]                 removed <- setdiff(old_names, names)
[08:27:50.359]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.359]                   envs[common]]
[08:27:50.359]                 NAMES <- toupper(changed)
[08:27:50.359]                 args <- list()
[08:27:50.359]                 for (kk in seq_along(NAMES)) {
[08:27:50.359]                   name <- changed[[kk]]
[08:27:50.359]                   NAME <- NAMES[[kk]]
[08:27:50.359]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.359]                     next
[08:27:50.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.359]                 }
[08:27:50.359]                 NAMES <- toupper(added)
[08:27:50.359]                 for (kk in seq_along(NAMES)) {
[08:27:50.359]                   name <- added[[kk]]
[08:27:50.359]                   NAME <- NAMES[[kk]]
[08:27:50.359]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.359]                     next
[08:27:50.359]                   args[[name]] <- ""
[08:27:50.359]                 }
[08:27:50.359]                 NAMES <- toupper(removed)
[08:27:50.359]                 for (kk in seq_along(NAMES)) {
[08:27:50.359]                   name <- removed[[kk]]
[08:27:50.359]                   NAME <- NAMES[[kk]]
[08:27:50.359]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.359]                     next
[08:27:50.359]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.359]                 }
[08:27:50.359]                 if (length(args) > 0) 
[08:27:50.359]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.359]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.359]             }
[08:27:50.359]             else {
[08:27:50.359]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.359]             }
[08:27:50.359]             {
[08:27:50.359]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.359]                   0L) {
[08:27:50.359]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.359]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.359]                   base::options(opts)
[08:27:50.359]                 }
[08:27:50.359]                 {
[08:27:50.359]                   {
[08:27:50.359]                     NULL
[08:27:50.359]                     RNGkind("Mersenne-Twister")
[08:27:50.359]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.359]                       inherits = FALSE)
[08:27:50.359]                   }
[08:27:50.359]                   options(future.plan = NULL)
[08:27:50.359]                   if (is.na(NA_character_)) 
[08:27:50.359]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.359]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.359]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.359]                     .init = FALSE)
[08:27:50.359]                 }
[08:27:50.359]             }
[08:27:50.359]         }
[08:27:50.359]     })
[08:27:50.359]     if (TRUE) {
[08:27:50.359]         base::sink(type = "output", split = FALSE)
[08:27:50.359]         if (TRUE) {
[08:27:50.359]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.359]         }
[08:27:50.359]         else {
[08:27:50.359]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.359]         }
[08:27:50.359]         base::close(...future.stdout)
[08:27:50.359]         ...future.stdout <- NULL
[08:27:50.359]     }
[08:27:50.359]     ...future.result$conditions <- ...future.conditions
[08:27:50.359]     ...future.result$finished <- base::Sys.time()
[08:27:50.359]     ...future.result
[08:27:50.359] }
[08:27:50.361] plan(): Setting new future strategy stack:
[08:27:50.361] List of future strategies:
[08:27:50.361] 1. sequential:
[08:27:50.361]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.361]    - tweaked: FALSE
[08:27:50.361]    - call: NULL
[08:27:50.362] plan(): nbrOfWorkers() = 1
[08:27:50.362] plan(): Setting new future strategy stack:
[08:27:50.362] List of future strategies:
[08:27:50.362] 1. sequential:
[08:27:50.362]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.362]    - tweaked: FALSE
[08:27:50.362]    - call: plan(strategy)
[08:27:50.363] plan(): nbrOfWorkers() = 1
[08:27:50.363] SequentialFuture started (and completed)
[08:27:50.363] - Launch lazy future ... done
[08:27:50.363] run() for ‘SequentialFuture’ ... done
[08:27:50.363] getGlobalsAndPackages() ...
[08:27:50.363] Searching for globals...
[08:27:50.364] 
[08:27:50.364] Searching for globals ... DONE
[08:27:50.364] - globals: [0] <none>
[08:27:50.364] getGlobalsAndPackages() ... DONE
[08:27:50.364] run() for ‘Future’ ...
[08:27:50.364] - state: ‘created’
[08:27:50.364] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.365] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.365]   - Field: ‘label’
[08:27:50.365]   - Field: ‘local’
[08:27:50.365]   - Field: ‘owner’
[08:27:50.365]   - Field: ‘envir’
[08:27:50.365]   - Field: ‘packages’
[08:27:50.365]   - Field: ‘gc’
[08:27:50.365]   - Field: ‘conditions’
[08:27:50.365]   - Field: ‘expr’
[08:27:50.366]   - Field: ‘uuid’
[08:27:50.366]   - Field: ‘seed’
[08:27:50.366]   - Field: ‘version’
[08:27:50.366]   - Field: ‘result’
[08:27:50.366]   - Field: ‘asynchronous’
[08:27:50.366]   - Field: ‘calls’
[08:27:50.366]   - Field: ‘globals’
[08:27:50.366]   - Field: ‘stdout’
[08:27:50.366]   - Field: ‘earlySignal’
[08:27:50.366]   - Field: ‘lazy’
[08:27:50.366]   - Field: ‘state’
[08:27:50.366] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.367] - Launch lazy future ...
[08:27:50.367] Packages needed by the future expression (n = 0): <none>
[08:27:50.367] Packages needed by future strategies (n = 0): <none>
[08:27:50.367] {
[08:27:50.367]     {
[08:27:50.367]         {
[08:27:50.367]             ...future.startTime <- base::Sys.time()
[08:27:50.367]             {
[08:27:50.367]                 {
[08:27:50.367]                   {
[08:27:50.367]                     base::local({
[08:27:50.367]                       has_future <- base::requireNamespace("future", 
[08:27:50.367]                         quietly = TRUE)
[08:27:50.367]                       if (has_future) {
[08:27:50.367]                         ns <- base::getNamespace("future")
[08:27:50.367]                         version <- ns[[".package"]][["version"]]
[08:27:50.367]                         if (is.null(version)) 
[08:27:50.367]                           version <- utils::packageVersion("future")
[08:27:50.367]                       }
[08:27:50.367]                       else {
[08:27:50.367]                         version <- NULL
[08:27:50.367]                       }
[08:27:50.367]                       if (!has_future || version < "1.8.0") {
[08:27:50.367]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.367]                           "", base::R.version$version.string), 
[08:27:50.367]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.367]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.367]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.367]                             "release", "version")], collapse = " "), 
[08:27:50.367]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.367]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.367]                           info)
[08:27:50.367]                         info <- base::paste(info, collapse = "; ")
[08:27:50.367]                         if (!has_future) {
[08:27:50.367]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.367]                             info)
[08:27:50.367]                         }
[08:27:50.367]                         else {
[08:27:50.367]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.367]                             info, version)
[08:27:50.367]                         }
[08:27:50.367]                         base::stop(msg)
[08:27:50.367]                       }
[08:27:50.367]                     })
[08:27:50.367]                   }
[08:27:50.367]                   ...future.strategy.old <- future::plan("list")
[08:27:50.367]                   options(future.plan = NULL)
[08:27:50.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.367]                 }
[08:27:50.367]                 ...future.workdir <- getwd()
[08:27:50.367]             }
[08:27:50.367]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.367]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.367]         }
[08:27:50.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.367]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.367]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.367]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.367]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.367]             base::names(...future.oldOptions))
[08:27:50.367]     }
[08:27:50.367]     if (FALSE) {
[08:27:50.367]     }
[08:27:50.367]     else {
[08:27:50.367]         if (TRUE) {
[08:27:50.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.367]                 open = "w")
[08:27:50.367]         }
[08:27:50.367]         else {
[08:27:50.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.367]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.367]         }
[08:27:50.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.367]             base::sink(type = "output", split = FALSE)
[08:27:50.367]             base::close(...future.stdout)
[08:27:50.367]         }, add = TRUE)
[08:27:50.367]     }
[08:27:50.367]     ...future.frame <- base::sys.nframe()
[08:27:50.367]     ...future.conditions <- base::list()
[08:27:50.367]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.367]     if (FALSE) {
[08:27:50.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.367]     }
[08:27:50.367]     ...future.result <- base::tryCatch({
[08:27:50.367]         base::withCallingHandlers({
[08:27:50.367]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.367]             future::FutureResult(value = ...future.value$value, 
[08:27:50.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.367]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.367]                     ...future.globalenv.names))
[08:27:50.367]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.367]         }, condition = base::local({
[08:27:50.367]             c <- base::c
[08:27:50.367]             inherits <- base::inherits
[08:27:50.367]             invokeRestart <- base::invokeRestart
[08:27:50.367]             length <- base::length
[08:27:50.367]             list <- base::list
[08:27:50.367]             seq.int <- base::seq.int
[08:27:50.367]             signalCondition <- base::signalCondition
[08:27:50.367]             sys.calls <- base::sys.calls
[08:27:50.367]             `[[` <- base::`[[`
[08:27:50.367]             `+` <- base::`+`
[08:27:50.367]             `<<-` <- base::`<<-`
[08:27:50.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.367]                   3L)]
[08:27:50.367]             }
[08:27:50.367]             function(cond) {
[08:27:50.367]                 is_error <- inherits(cond, "error")
[08:27:50.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.367]                   NULL)
[08:27:50.367]                 if (is_error) {
[08:27:50.367]                   sessionInformation <- function() {
[08:27:50.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.367]                       search = base::search(), system = base::Sys.info())
[08:27:50.367]                   }
[08:27:50.367]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.367]                     cond$call), session = sessionInformation(), 
[08:27:50.367]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.367]                   signalCondition(cond)
[08:27:50.367]                 }
[08:27:50.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.367]                 "immediateCondition"))) {
[08:27:50.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.367]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.367]                   if (TRUE && !signal) {
[08:27:50.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.367]                     {
[08:27:50.367]                       inherits <- base::inherits
[08:27:50.367]                       invokeRestart <- base::invokeRestart
[08:27:50.367]                       is.null <- base::is.null
[08:27:50.367]                       muffled <- FALSE
[08:27:50.367]                       if (inherits(cond, "message")) {
[08:27:50.367]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.367]                         if (muffled) 
[08:27:50.367]                           invokeRestart("muffleMessage")
[08:27:50.367]                       }
[08:27:50.367]                       else if (inherits(cond, "warning")) {
[08:27:50.367]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.367]                         if (muffled) 
[08:27:50.367]                           invokeRestart("muffleWarning")
[08:27:50.367]                       }
[08:27:50.367]                       else if (inherits(cond, "condition")) {
[08:27:50.367]                         if (!is.null(pattern)) {
[08:27:50.367]                           computeRestarts <- base::computeRestarts
[08:27:50.367]                           grepl <- base::grepl
[08:27:50.367]                           restarts <- computeRestarts(cond)
[08:27:50.367]                           for (restart in restarts) {
[08:27:50.367]                             name <- restart$name
[08:27:50.367]                             if (is.null(name)) 
[08:27:50.367]                               next
[08:27:50.367]                             if (!grepl(pattern, name)) 
[08:27:50.367]                               next
[08:27:50.367]                             invokeRestart(restart)
[08:27:50.367]                             muffled <- TRUE
[08:27:50.367]                             break
[08:27:50.367]                           }
[08:27:50.367]                         }
[08:27:50.367]                       }
[08:27:50.367]                       invisible(muffled)
[08:27:50.367]                     }
[08:27:50.367]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.367]                   }
[08:27:50.367]                 }
[08:27:50.367]                 else {
[08:27:50.367]                   if (TRUE) {
[08:27:50.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.367]                     {
[08:27:50.367]                       inherits <- base::inherits
[08:27:50.367]                       invokeRestart <- base::invokeRestart
[08:27:50.367]                       is.null <- base::is.null
[08:27:50.367]                       muffled <- FALSE
[08:27:50.367]                       if (inherits(cond, "message")) {
[08:27:50.367]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.367]                         if (muffled) 
[08:27:50.367]                           invokeRestart("muffleMessage")
[08:27:50.367]                       }
[08:27:50.367]                       else if (inherits(cond, "warning")) {
[08:27:50.367]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.367]                         if (muffled) 
[08:27:50.367]                           invokeRestart("muffleWarning")
[08:27:50.367]                       }
[08:27:50.367]                       else if (inherits(cond, "condition")) {
[08:27:50.367]                         if (!is.null(pattern)) {
[08:27:50.367]                           computeRestarts <- base::computeRestarts
[08:27:50.367]                           grepl <- base::grepl
[08:27:50.367]                           restarts <- computeRestarts(cond)
[08:27:50.367]                           for (restart in restarts) {
[08:27:50.367]                             name <- restart$name
[08:27:50.367]                             if (is.null(name)) 
[08:27:50.367]                               next
[08:27:50.367]                             if (!grepl(pattern, name)) 
[08:27:50.367]                               next
[08:27:50.367]                             invokeRestart(restart)
[08:27:50.367]                             muffled <- TRUE
[08:27:50.367]                             break
[08:27:50.367]                           }
[08:27:50.367]                         }
[08:27:50.367]                       }
[08:27:50.367]                       invisible(muffled)
[08:27:50.367]                     }
[08:27:50.367]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.367]                   }
[08:27:50.367]                 }
[08:27:50.367]             }
[08:27:50.367]         }))
[08:27:50.367]     }, error = function(ex) {
[08:27:50.367]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.367]                 ...future.rng), started = ...future.startTime, 
[08:27:50.367]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.367]             version = "1.8"), class = "FutureResult")
[08:27:50.367]     }, finally = {
[08:27:50.367]         if (!identical(...future.workdir, getwd())) 
[08:27:50.367]             setwd(...future.workdir)
[08:27:50.367]         {
[08:27:50.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.367]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.367]             }
[08:27:50.367]             base::options(...future.oldOptions)
[08:27:50.367]             if (.Platform$OS.type == "windows") {
[08:27:50.367]                 old_names <- names(...future.oldEnvVars)
[08:27:50.367]                 envs <- base::Sys.getenv()
[08:27:50.367]                 names <- names(envs)
[08:27:50.367]                 common <- intersect(names, old_names)
[08:27:50.367]                 added <- setdiff(names, old_names)
[08:27:50.367]                 removed <- setdiff(old_names, names)
[08:27:50.367]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.367]                   envs[common]]
[08:27:50.367]                 NAMES <- toupper(changed)
[08:27:50.367]                 args <- list()
[08:27:50.367]                 for (kk in seq_along(NAMES)) {
[08:27:50.367]                   name <- changed[[kk]]
[08:27:50.367]                   NAME <- NAMES[[kk]]
[08:27:50.367]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.367]                     next
[08:27:50.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.367]                 }
[08:27:50.367]                 NAMES <- toupper(added)
[08:27:50.367]                 for (kk in seq_along(NAMES)) {
[08:27:50.367]                   name <- added[[kk]]
[08:27:50.367]                   NAME <- NAMES[[kk]]
[08:27:50.367]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.367]                     next
[08:27:50.367]                   args[[name]] <- ""
[08:27:50.367]                 }
[08:27:50.367]                 NAMES <- toupper(removed)
[08:27:50.367]                 for (kk in seq_along(NAMES)) {
[08:27:50.367]                   name <- removed[[kk]]
[08:27:50.367]                   NAME <- NAMES[[kk]]
[08:27:50.367]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.367]                     next
[08:27:50.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.367]                 }
[08:27:50.367]                 if (length(args) > 0) 
[08:27:50.367]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.367]             }
[08:27:50.367]             else {
[08:27:50.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.367]             }
[08:27:50.367]             {
[08:27:50.367]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.367]                   0L) {
[08:27:50.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.367]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.367]                   base::options(opts)
[08:27:50.367]                 }
[08:27:50.367]                 {
[08:27:50.367]                   {
[08:27:50.367]                     NULL
[08:27:50.367]                     RNGkind("Mersenne-Twister")
[08:27:50.367]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.367]                       inherits = FALSE)
[08:27:50.367]                   }
[08:27:50.367]                   options(future.plan = NULL)
[08:27:50.367]                   if (is.na(NA_character_)) 
[08:27:50.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.367]                     .init = FALSE)
[08:27:50.367]                 }
[08:27:50.367]             }
[08:27:50.367]         }
[08:27:50.367]     })
[08:27:50.367]     if (TRUE) {
[08:27:50.367]         base::sink(type = "output", split = FALSE)
[08:27:50.367]         if (TRUE) {
[08:27:50.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.367]         }
[08:27:50.367]         else {
[08:27:50.367]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.367]         }
[08:27:50.367]         base::close(...future.stdout)
[08:27:50.367]         ...future.stdout <- NULL
[08:27:50.367]     }
[08:27:50.367]     ...future.result$conditions <- ...future.conditions
[08:27:50.367]     ...future.result$finished <- base::Sys.time()
[08:27:50.367]     ...future.result
[08:27:50.367] }
[08:27:50.369] plan(): Setting new future strategy stack:
[08:27:50.369] List of future strategies:
[08:27:50.369] 1. sequential:
[08:27:50.369]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.369]    - tweaked: FALSE
[08:27:50.369]    - call: NULL
[08:27:50.369] plan(): nbrOfWorkers() = 1
[08:27:50.370] plan(): Setting new future strategy stack:
[08:27:50.370] List of future strategies:
[08:27:50.370] 1. sequential:
[08:27:50.370]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.370]    - tweaked: FALSE
[08:27:50.370]    - call: plan(strategy)
[08:27:50.371] plan(): nbrOfWorkers() = 1
[08:27:50.371] SequentialFuture started (and completed)
[08:27:50.371] - Launch lazy future ... done
[08:27:50.371] run() for ‘SequentialFuture’ ... done
[08:27:50.372] getGlobalsAndPackages() ...
[08:27:50.372] Searching for globals...
[08:27:50.373] - globals found: [1] ‘{’
[08:27:50.373] Searching for globals ... DONE
[08:27:50.374] Resolving globals: FALSE
[08:27:50.374] 
[08:27:50.374] 
[08:27:50.374] getGlobalsAndPackages() ... DONE
[08:27:50.374] run() for ‘Future’ ...
[08:27:50.374] - state: ‘created’
[08:27:50.375] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.375] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.375] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.375]   - Field: ‘label’
[08:27:50.375]   - Field: ‘local’
[08:27:50.375]   - Field: ‘owner’
[08:27:50.375]   - Field: ‘envir’
[08:27:50.375]   - Field: ‘packages’
[08:27:50.375]   - Field: ‘gc’
[08:27:50.376]   - Field: ‘conditions’
[08:27:50.376]   - Field: ‘expr’
[08:27:50.376]   - Field: ‘uuid’
[08:27:50.376]   - Field: ‘seed’
[08:27:50.376]   - Field: ‘version’
[08:27:50.376]   - Field: ‘result’
[08:27:50.376]   - Field: ‘asynchronous’
[08:27:50.376]   - Field: ‘calls’
[08:27:50.376]   - Field: ‘globals’
[08:27:50.376]   - Field: ‘stdout’
[08:27:50.376]   - Field: ‘earlySignal’
[08:27:50.377]   - Field: ‘lazy’
[08:27:50.377]   - Field: ‘state’
[08:27:50.377] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.377] - Launch lazy future ...
[08:27:50.377] Packages needed by the future expression (n = 0): <none>
[08:27:50.377] Packages needed by future strategies (n = 0): <none>
[08:27:50.377] {
[08:27:50.377]     {
[08:27:50.377]         {
[08:27:50.377]             ...future.startTime <- base::Sys.time()
[08:27:50.377]             {
[08:27:50.377]                 {
[08:27:50.377]                   {
[08:27:50.377]                     base::local({
[08:27:50.377]                       has_future <- base::requireNamespace("future", 
[08:27:50.377]                         quietly = TRUE)
[08:27:50.377]                       if (has_future) {
[08:27:50.377]                         ns <- base::getNamespace("future")
[08:27:50.377]                         version <- ns[[".package"]][["version"]]
[08:27:50.377]                         if (is.null(version)) 
[08:27:50.377]                           version <- utils::packageVersion("future")
[08:27:50.377]                       }
[08:27:50.377]                       else {
[08:27:50.377]                         version <- NULL
[08:27:50.377]                       }
[08:27:50.377]                       if (!has_future || version < "1.8.0") {
[08:27:50.377]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.377]                           "", base::R.version$version.string), 
[08:27:50.377]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.377]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.377]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.377]                             "release", "version")], collapse = " "), 
[08:27:50.377]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.377]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.377]                           info)
[08:27:50.377]                         info <- base::paste(info, collapse = "; ")
[08:27:50.377]                         if (!has_future) {
[08:27:50.377]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.377]                             info)
[08:27:50.377]                         }
[08:27:50.377]                         else {
[08:27:50.377]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.377]                             info, version)
[08:27:50.377]                         }
[08:27:50.377]                         base::stop(msg)
[08:27:50.377]                       }
[08:27:50.377]                     })
[08:27:50.377]                   }
[08:27:50.377]                   ...future.strategy.old <- future::plan("list")
[08:27:50.377]                   options(future.plan = NULL)
[08:27:50.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.377]                 }
[08:27:50.377]                 ...future.workdir <- getwd()
[08:27:50.377]             }
[08:27:50.377]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.377]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.377]         }
[08:27:50.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.377]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.377]             base::names(...future.oldOptions))
[08:27:50.377]     }
[08:27:50.377]     if (FALSE) {
[08:27:50.377]     }
[08:27:50.377]     else {
[08:27:50.377]         if (TRUE) {
[08:27:50.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.377]                 open = "w")
[08:27:50.377]         }
[08:27:50.377]         else {
[08:27:50.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.377]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.377]         }
[08:27:50.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.377]             base::sink(type = "output", split = FALSE)
[08:27:50.377]             base::close(...future.stdout)
[08:27:50.377]         }, add = TRUE)
[08:27:50.377]     }
[08:27:50.377]     ...future.frame <- base::sys.nframe()
[08:27:50.377]     ...future.conditions <- base::list()
[08:27:50.377]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.377]     if (FALSE) {
[08:27:50.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.377]     }
[08:27:50.377]     ...future.result <- base::tryCatch({
[08:27:50.377]         base::withCallingHandlers({
[08:27:50.377]             ...future.value <- base::withVisible(base::local({
[08:27:50.377]                 4
[08:27:50.377]             }))
[08:27:50.377]             future::FutureResult(value = ...future.value$value, 
[08:27:50.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.377]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.377]                     ...future.globalenv.names))
[08:27:50.377]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.377]         }, condition = base::local({
[08:27:50.377]             c <- base::c
[08:27:50.377]             inherits <- base::inherits
[08:27:50.377]             invokeRestart <- base::invokeRestart
[08:27:50.377]             length <- base::length
[08:27:50.377]             list <- base::list
[08:27:50.377]             seq.int <- base::seq.int
[08:27:50.377]             signalCondition <- base::signalCondition
[08:27:50.377]             sys.calls <- base::sys.calls
[08:27:50.377]             `[[` <- base::`[[`
[08:27:50.377]             `+` <- base::`+`
[08:27:50.377]             `<<-` <- base::`<<-`
[08:27:50.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.377]                   3L)]
[08:27:50.377]             }
[08:27:50.377]             function(cond) {
[08:27:50.377]                 is_error <- inherits(cond, "error")
[08:27:50.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.377]                   NULL)
[08:27:50.377]                 if (is_error) {
[08:27:50.377]                   sessionInformation <- function() {
[08:27:50.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.377]                       search = base::search(), system = base::Sys.info())
[08:27:50.377]                   }
[08:27:50.377]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.377]                     cond$call), session = sessionInformation(), 
[08:27:50.377]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.377]                   signalCondition(cond)
[08:27:50.377]                 }
[08:27:50.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.377]                 "immediateCondition"))) {
[08:27:50.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.377]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.377]                   if (TRUE && !signal) {
[08:27:50.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.377]                     {
[08:27:50.377]                       inherits <- base::inherits
[08:27:50.377]                       invokeRestart <- base::invokeRestart
[08:27:50.377]                       is.null <- base::is.null
[08:27:50.377]                       muffled <- FALSE
[08:27:50.377]                       if (inherits(cond, "message")) {
[08:27:50.377]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.377]                         if (muffled) 
[08:27:50.377]                           invokeRestart("muffleMessage")
[08:27:50.377]                       }
[08:27:50.377]                       else if (inherits(cond, "warning")) {
[08:27:50.377]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.377]                         if (muffled) 
[08:27:50.377]                           invokeRestart("muffleWarning")
[08:27:50.377]                       }
[08:27:50.377]                       else if (inherits(cond, "condition")) {
[08:27:50.377]                         if (!is.null(pattern)) {
[08:27:50.377]                           computeRestarts <- base::computeRestarts
[08:27:50.377]                           grepl <- base::grepl
[08:27:50.377]                           restarts <- computeRestarts(cond)
[08:27:50.377]                           for (restart in restarts) {
[08:27:50.377]                             name <- restart$name
[08:27:50.377]                             if (is.null(name)) 
[08:27:50.377]                               next
[08:27:50.377]                             if (!grepl(pattern, name)) 
[08:27:50.377]                               next
[08:27:50.377]                             invokeRestart(restart)
[08:27:50.377]                             muffled <- TRUE
[08:27:50.377]                             break
[08:27:50.377]                           }
[08:27:50.377]                         }
[08:27:50.377]                       }
[08:27:50.377]                       invisible(muffled)
[08:27:50.377]                     }
[08:27:50.377]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.377]                   }
[08:27:50.377]                 }
[08:27:50.377]                 else {
[08:27:50.377]                   if (TRUE) {
[08:27:50.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.377]                     {
[08:27:50.377]                       inherits <- base::inherits
[08:27:50.377]                       invokeRestart <- base::invokeRestart
[08:27:50.377]                       is.null <- base::is.null
[08:27:50.377]                       muffled <- FALSE
[08:27:50.377]                       if (inherits(cond, "message")) {
[08:27:50.377]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.377]                         if (muffled) 
[08:27:50.377]                           invokeRestart("muffleMessage")
[08:27:50.377]                       }
[08:27:50.377]                       else if (inherits(cond, "warning")) {
[08:27:50.377]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.377]                         if (muffled) 
[08:27:50.377]                           invokeRestart("muffleWarning")
[08:27:50.377]                       }
[08:27:50.377]                       else if (inherits(cond, "condition")) {
[08:27:50.377]                         if (!is.null(pattern)) {
[08:27:50.377]                           computeRestarts <- base::computeRestarts
[08:27:50.377]                           grepl <- base::grepl
[08:27:50.377]                           restarts <- computeRestarts(cond)
[08:27:50.377]                           for (restart in restarts) {
[08:27:50.377]                             name <- restart$name
[08:27:50.377]                             if (is.null(name)) 
[08:27:50.377]                               next
[08:27:50.377]                             if (!grepl(pattern, name)) 
[08:27:50.377]                               next
[08:27:50.377]                             invokeRestart(restart)
[08:27:50.377]                             muffled <- TRUE
[08:27:50.377]                             break
[08:27:50.377]                           }
[08:27:50.377]                         }
[08:27:50.377]                       }
[08:27:50.377]                       invisible(muffled)
[08:27:50.377]                     }
[08:27:50.377]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.377]                   }
[08:27:50.377]                 }
[08:27:50.377]             }
[08:27:50.377]         }))
[08:27:50.377]     }, error = function(ex) {
[08:27:50.377]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.377]                 ...future.rng), started = ...future.startTime, 
[08:27:50.377]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.377]             version = "1.8"), class = "FutureResult")
[08:27:50.377]     }, finally = {
[08:27:50.377]         if (!identical(...future.workdir, getwd())) 
[08:27:50.377]             setwd(...future.workdir)
[08:27:50.377]         {
[08:27:50.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.377]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.377]             }
[08:27:50.377]             base::options(...future.oldOptions)
[08:27:50.377]             if (.Platform$OS.type == "windows") {
[08:27:50.377]                 old_names <- names(...future.oldEnvVars)
[08:27:50.377]                 envs <- base::Sys.getenv()
[08:27:50.377]                 names <- names(envs)
[08:27:50.377]                 common <- intersect(names, old_names)
[08:27:50.377]                 added <- setdiff(names, old_names)
[08:27:50.377]                 removed <- setdiff(old_names, names)
[08:27:50.377]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.377]                   envs[common]]
[08:27:50.377]                 NAMES <- toupper(changed)
[08:27:50.377]                 args <- list()
[08:27:50.377]                 for (kk in seq_along(NAMES)) {
[08:27:50.377]                   name <- changed[[kk]]
[08:27:50.377]                   NAME <- NAMES[[kk]]
[08:27:50.377]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.377]                     next
[08:27:50.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.377]                 }
[08:27:50.377]                 NAMES <- toupper(added)
[08:27:50.377]                 for (kk in seq_along(NAMES)) {
[08:27:50.377]                   name <- added[[kk]]
[08:27:50.377]                   NAME <- NAMES[[kk]]
[08:27:50.377]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.377]                     next
[08:27:50.377]                   args[[name]] <- ""
[08:27:50.377]                 }
[08:27:50.377]                 NAMES <- toupper(removed)
[08:27:50.377]                 for (kk in seq_along(NAMES)) {
[08:27:50.377]                   name <- removed[[kk]]
[08:27:50.377]                   NAME <- NAMES[[kk]]
[08:27:50.377]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.377]                     next
[08:27:50.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.377]                 }
[08:27:50.377]                 if (length(args) > 0) 
[08:27:50.377]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.377]             }
[08:27:50.377]             else {
[08:27:50.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.377]             }
[08:27:50.377]             {
[08:27:50.377]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.377]                   0L) {
[08:27:50.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.377]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.377]                   base::options(opts)
[08:27:50.377]                 }
[08:27:50.377]                 {
[08:27:50.377]                   {
[08:27:50.377]                     NULL
[08:27:50.377]                     RNGkind("Mersenne-Twister")
[08:27:50.377]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.377]                       inherits = FALSE)
[08:27:50.377]                   }
[08:27:50.377]                   options(future.plan = NULL)
[08:27:50.377]                   if (is.na(NA_character_)) 
[08:27:50.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.377]                     .init = FALSE)
[08:27:50.377]                 }
[08:27:50.377]             }
[08:27:50.377]         }
[08:27:50.377]     })
[08:27:50.377]     if (TRUE) {
[08:27:50.377]         base::sink(type = "output", split = FALSE)
[08:27:50.377]         if (TRUE) {
[08:27:50.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.377]         }
[08:27:50.377]         else {
[08:27:50.377]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.377]         }
[08:27:50.377]         base::close(...future.stdout)
[08:27:50.377]         ...future.stdout <- NULL
[08:27:50.377]     }
[08:27:50.377]     ...future.result$conditions <- ...future.conditions
[08:27:50.377]     ...future.result$finished <- base::Sys.time()
[08:27:50.377]     ...future.result
[08:27:50.377] }
[08:27:50.379] plan(): Setting new future strategy stack:
[08:27:50.379] List of future strategies:
[08:27:50.379] 1. sequential:
[08:27:50.379]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.379]    - tweaked: FALSE
[08:27:50.379]    - call: NULL
[08:27:50.380] plan(): nbrOfWorkers() = 1
[08:27:50.382] plan(): Setting new future strategy stack:
[08:27:50.382] List of future strategies:
[08:27:50.382] 1. sequential:
[08:27:50.382]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.382]    - tweaked: FALSE
[08:27:50.382]    - call: plan(strategy)
[08:27:50.383] plan(): nbrOfWorkers() = 1
[08:27:50.383] SequentialFuture started (and completed)
[08:27:50.383] - Launch lazy future ... done
[08:27:50.383] run() for ‘SequentialFuture’ ... done
<environment: 0x55d85eb400a8> 
<environment: 0x55d85f412f60> 
[08:27:50.385] resolved() for ‘SequentialFuture’ ...
[08:27:50.385] - state: ‘finished’
[08:27:50.385] - run: TRUE
[08:27:50.385] - result: ‘FutureResult’
[08:27:50.385] resolved() for ‘SequentialFuture’ ... done
[08:27:50.385] resolved() for ‘SequentialFuture’ ...
[08:27:50.385] - state: ‘finished’
[08:27:50.385] - run: TRUE
[08:27:50.385] - result: ‘FutureResult’
[08:27:50.386] resolved() for ‘SequentialFuture’ ... done
[08:27:50.386] resolved() for ‘SequentialFuture’ ...
[08:27:50.386] - state: ‘finished’
[08:27:50.386] - run: TRUE
[08:27:50.386] - result: ‘FutureResult’
[08:27:50.386] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:50.387] resolve() on environment ...
[08:27:50.387]  recursive: 0
[08:27:50.388]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:50.388] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.388] - nx: 4
[08:27:50.388] - relay: TRUE
[08:27:50.388] - stdout: TRUE
[08:27:50.388] - signal: TRUE
[08:27:50.388] - resignal: FALSE
[08:27:50.388] - force: TRUE
[08:27:50.389] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.389] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.389]  - until=2
[08:27:50.389]  - relaying element #2
[08:27:50.389] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.389] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.389] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.389]  length: 3 (resolved future 1)
[08:27:50.389] resolved() for ‘SequentialFuture’ ...
[08:27:50.389] - state: ‘finished’
[08:27:50.389] - run: TRUE
[08:27:50.389] - result: ‘FutureResult’
[08:27:50.390] resolved() for ‘SequentialFuture’ ... done
[08:27:50.390] Future #2
[08:27:50.390] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.390] - nx: 4
[08:27:50.390] - relay: TRUE
[08:27:50.390] - stdout: TRUE
[08:27:50.390] - signal: TRUE
[08:27:50.390] - resignal: FALSE
[08:27:50.390] - force: TRUE
[08:27:50.390] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.390] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.390]  - until=2
[08:27:50.391]  - relaying element #2
[08:27:50.391] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.391] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.391] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.391]  length: 2 (resolved future 2)
[08:27:50.391] resolved() for ‘SequentialFuture’ ...
[08:27:50.391] - state: ‘finished’
[08:27:50.391] - run: TRUE
[08:27:50.391] - result: ‘FutureResult’
[08:27:50.391] resolved() for ‘SequentialFuture’ ... done
[08:27:50.392] Future #3
[08:27:50.392] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.392] - nx: 4
[08:27:50.392] - relay: TRUE
[08:27:50.392] - stdout: TRUE
[08:27:50.392] - signal: TRUE
[08:27:50.392] - resignal: FALSE
[08:27:50.392] - force: TRUE
[08:27:50.392] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.392] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.392]  - until=3
[08:27:50.392]  - relaying element #3
[08:27:50.393] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.393] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.393] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.393]  length: 1 (resolved future 3)
[08:27:50.393] resolved() for ‘SequentialFuture’ ...
[08:27:50.393] - state: ‘finished’
[08:27:50.393] - run: TRUE
[08:27:50.393] - result: ‘FutureResult’
[08:27:50.393] resolved() for ‘SequentialFuture’ ... done
[08:27:50.393] Future #4
[08:27:50.394] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.394] - nx: 4
[08:27:50.394] - relay: TRUE
[08:27:50.394] - stdout: TRUE
[08:27:50.394] - signal: TRUE
[08:27:50.394] - resignal: FALSE
[08:27:50.394] - force: TRUE
[08:27:50.394] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.394] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.394]  - until=4
[08:27:50.394]  - relaying element #4
[08:27:50.394] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.395] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.395] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.395]  length: 0 (resolved future 4)
[08:27:50.395] Relaying remaining futures
[08:27:50.395] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.395] - nx: 4
[08:27:50.395] - relay: TRUE
[08:27:50.395] - stdout: TRUE
[08:27:50.395] - signal: TRUE
[08:27:50.395] - resignal: FALSE
[08:27:50.395] - force: TRUE
[08:27:50.395] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.395] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:50.396] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.396] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.396] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.396] resolve() on environment ... DONE
<environment: 0x55d85e83fc50> 
Dimensions: c(1, 6)
[08:27:50.396] getGlobalsAndPackages() ...
[08:27:50.396] Searching for globals...
[08:27:50.397] 
[08:27:50.397] Searching for globals ... DONE
[08:27:50.397] - globals: [0] <none>
[08:27:50.397] getGlobalsAndPackages() ... DONE
[08:27:50.397] run() for ‘Future’ ...
[08:27:50.397] - state: ‘created’
[08:27:50.397] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.398] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.398] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.398]   - Field: ‘label’
[08:27:50.398]   - Field: ‘local’
[08:27:50.398]   - Field: ‘owner’
[08:27:50.398]   - Field: ‘envir’
[08:27:50.398]   - Field: ‘packages’
[08:27:50.398]   - Field: ‘gc’
[08:27:50.398]   - Field: ‘conditions’
[08:27:50.398]   - Field: ‘expr’
[08:27:50.399]   - Field: ‘uuid’
[08:27:50.399]   - Field: ‘seed’
[08:27:50.399]   - Field: ‘version’
[08:27:50.399]   - Field: ‘result’
[08:27:50.399]   - Field: ‘asynchronous’
[08:27:50.399]   - Field: ‘calls’
[08:27:50.399]   - Field: ‘globals’
[08:27:50.399]   - Field: ‘stdout’
[08:27:50.399]   - Field: ‘earlySignal’
[08:27:50.399]   - Field: ‘lazy’
[08:27:50.399]   - Field: ‘state’
[08:27:50.399] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.400] - Launch lazy future ...
[08:27:50.400] Packages needed by the future expression (n = 0): <none>
[08:27:50.400] Packages needed by future strategies (n = 0): <none>
[08:27:50.400] {
[08:27:50.400]     {
[08:27:50.400]         {
[08:27:50.400]             ...future.startTime <- base::Sys.time()
[08:27:50.400]             {
[08:27:50.400]                 {
[08:27:50.400]                   {
[08:27:50.400]                     base::local({
[08:27:50.400]                       has_future <- base::requireNamespace("future", 
[08:27:50.400]                         quietly = TRUE)
[08:27:50.400]                       if (has_future) {
[08:27:50.400]                         ns <- base::getNamespace("future")
[08:27:50.400]                         version <- ns[[".package"]][["version"]]
[08:27:50.400]                         if (is.null(version)) 
[08:27:50.400]                           version <- utils::packageVersion("future")
[08:27:50.400]                       }
[08:27:50.400]                       else {
[08:27:50.400]                         version <- NULL
[08:27:50.400]                       }
[08:27:50.400]                       if (!has_future || version < "1.8.0") {
[08:27:50.400]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.400]                           "", base::R.version$version.string), 
[08:27:50.400]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.400]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.400]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.400]                             "release", "version")], collapse = " "), 
[08:27:50.400]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.400]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.400]                           info)
[08:27:50.400]                         info <- base::paste(info, collapse = "; ")
[08:27:50.400]                         if (!has_future) {
[08:27:50.400]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.400]                             info)
[08:27:50.400]                         }
[08:27:50.400]                         else {
[08:27:50.400]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.400]                             info, version)
[08:27:50.400]                         }
[08:27:50.400]                         base::stop(msg)
[08:27:50.400]                       }
[08:27:50.400]                     })
[08:27:50.400]                   }
[08:27:50.400]                   ...future.strategy.old <- future::plan("list")
[08:27:50.400]                   options(future.plan = NULL)
[08:27:50.400]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.400]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.400]                 }
[08:27:50.400]                 ...future.workdir <- getwd()
[08:27:50.400]             }
[08:27:50.400]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.400]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.400]         }
[08:27:50.400]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.400]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.400]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.400]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.400]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.400]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.400]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.400]             base::names(...future.oldOptions))
[08:27:50.400]     }
[08:27:50.400]     if (FALSE) {
[08:27:50.400]     }
[08:27:50.400]     else {
[08:27:50.400]         if (TRUE) {
[08:27:50.400]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.400]                 open = "w")
[08:27:50.400]         }
[08:27:50.400]         else {
[08:27:50.400]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.400]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.400]         }
[08:27:50.400]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.400]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.400]             base::sink(type = "output", split = FALSE)
[08:27:50.400]             base::close(...future.stdout)
[08:27:50.400]         }, add = TRUE)
[08:27:50.400]     }
[08:27:50.400]     ...future.frame <- base::sys.nframe()
[08:27:50.400]     ...future.conditions <- base::list()
[08:27:50.400]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.400]     if (FALSE) {
[08:27:50.400]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.400]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.400]     }
[08:27:50.400]     ...future.result <- base::tryCatch({
[08:27:50.400]         base::withCallingHandlers({
[08:27:50.400]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.400]             future::FutureResult(value = ...future.value$value, 
[08:27:50.400]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.400]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.400]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.400]                     ...future.globalenv.names))
[08:27:50.400]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.400]         }, condition = base::local({
[08:27:50.400]             c <- base::c
[08:27:50.400]             inherits <- base::inherits
[08:27:50.400]             invokeRestart <- base::invokeRestart
[08:27:50.400]             length <- base::length
[08:27:50.400]             list <- base::list
[08:27:50.400]             seq.int <- base::seq.int
[08:27:50.400]             signalCondition <- base::signalCondition
[08:27:50.400]             sys.calls <- base::sys.calls
[08:27:50.400]             `[[` <- base::`[[`
[08:27:50.400]             `+` <- base::`+`
[08:27:50.400]             `<<-` <- base::`<<-`
[08:27:50.400]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.400]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.400]                   3L)]
[08:27:50.400]             }
[08:27:50.400]             function(cond) {
[08:27:50.400]                 is_error <- inherits(cond, "error")
[08:27:50.400]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.400]                   NULL)
[08:27:50.400]                 if (is_error) {
[08:27:50.400]                   sessionInformation <- function() {
[08:27:50.400]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.400]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.400]                       search = base::search(), system = base::Sys.info())
[08:27:50.400]                   }
[08:27:50.400]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.400]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.400]                     cond$call), session = sessionInformation(), 
[08:27:50.400]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.400]                   signalCondition(cond)
[08:27:50.400]                 }
[08:27:50.400]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.400]                 "immediateCondition"))) {
[08:27:50.400]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.400]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.400]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.400]                   if (TRUE && !signal) {
[08:27:50.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.400]                     {
[08:27:50.400]                       inherits <- base::inherits
[08:27:50.400]                       invokeRestart <- base::invokeRestart
[08:27:50.400]                       is.null <- base::is.null
[08:27:50.400]                       muffled <- FALSE
[08:27:50.400]                       if (inherits(cond, "message")) {
[08:27:50.400]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.400]                         if (muffled) 
[08:27:50.400]                           invokeRestart("muffleMessage")
[08:27:50.400]                       }
[08:27:50.400]                       else if (inherits(cond, "warning")) {
[08:27:50.400]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.400]                         if (muffled) 
[08:27:50.400]                           invokeRestart("muffleWarning")
[08:27:50.400]                       }
[08:27:50.400]                       else if (inherits(cond, "condition")) {
[08:27:50.400]                         if (!is.null(pattern)) {
[08:27:50.400]                           computeRestarts <- base::computeRestarts
[08:27:50.400]                           grepl <- base::grepl
[08:27:50.400]                           restarts <- computeRestarts(cond)
[08:27:50.400]                           for (restart in restarts) {
[08:27:50.400]                             name <- restart$name
[08:27:50.400]                             if (is.null(name)) 
[08:27:50.400]                               next
[08:27:50.400]                             if (!grepl(pattern, name)) 
[08:27:50.400]                               next
[08:27:50.400]                             invokeRestart(restart)
[08:27:50.400]                             muffled <- TRUE
[08:27:50.400]                             break
[08:27:50.400]                           }
[08:27:50.400]                         }
[08:27:50.400]                       }
[08:27:50.400]                       invisible(muffled)
[08:27:50.400]                     }
[08:27:50.400]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.400]                   }
[08:27:50.400]                 }
[08:27:50.400]                 else {
[08:27:50.400]                   if (TRUE) {
[08:27:50.400]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.400]                     {
[08:27:50.400]                       inherits <- base::inherits
[08:27:50.400]                       invokeRestart <- base::invokeRestart
[08:27:50.400]                       is.null <- base::is.null
[08:27:50.400]                       muffled <- FALSE
[08:27:50.400]                       if (inherits(cond, "message")) {
[08:27:50.400]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.400]                         if (muffled) 
[08:27:50.400]                           invokeRestart("muffleMessage")
[08:27:50.400]                       }
[08:27:50.400]                       else if (inherits(cond, "warning")) {
[08:27:50.400]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.400]                         if (muffled) 
[08:27:50.400]                           invokeRestart("muffleWarning")
[08:27:50.400]                       }
[08:27:50.400]                       else if (inherits(cond, "condition")) {
[08:27:50.400]                         if (!is.null(pattern)) {
[08:27:50.400]                           computeRestarts <- base::computeRestarts
[08:27:50.400]                           grepl <- base::grepl
[08:27:50.400]                           restarts <- computeRestarts(cond)
[08:27:50.400]                           for (restart in restarts) {
[08:27:50.400]                             name <- restart$name
[08:27:50.400]                             if (is.null(name)) 
[08:27:50.400]                               next
[08:27:50.400]                             if (!grepl(pattern, name)) 
[08:27:50.400]                               next
[08:27:50.400]                             invokeRestart(restart)
[08:27:50.400]                             muffled <- TRUE
[08:27:50.400]                             break
[08:27:50.400]                           }
[08:27:50.400]                         }
[08:27:50.400]                       }
[08:27:50.400]                       invisible(muffled)
[08:27:50.400]                     }
[08:27:50.400]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.400]                   }
[08:27:50.400]                 }
[08:27:50.400]             }
[08:27:50.400]         }))
[08:27:50.400]     }, error = function(ex) {
[08:27:50.400]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.400]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.400]                 ...future.rng), started = ...future.startTime, 
[08:27:50.400]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.400]             version = "1.8"), class = "FutureResult")
[08:27:50.400]     }, finally = {
[08:27:50.400]         if (!identical(...future.workdir, getwd())) 
[08:27:50.400]             setwd(...future.workdir)
[08:27:50.400]         {
[08:27:50.400]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.400]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.400]             }
[08:27:50.400]             base::options(...future.oldOptions)
[08:27:50.400]             if (.Platform$OS.type == "windows") {
[08:27:50.400]                 old_names <- names(...future.oldEnvVars)
[08:27:50.400]                 envs <- base::Sys.getenv()
[08:27:50.400]                 names <- names(envs)
[08:27:50.400]                 common <- intersect(names, old_names)
[08:27:50.400]                 added <- setdiff(names, old_names)
[08:27:50.400]                 removed <- setdiff(old_names, names)
[08:27:50.400]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.400]                   envs[common]]
[08:27:50.400]                 NAMES <- toupper(changed)
[08:27:50.400]                 args <- list()
[08:27:50.400]                 for (kk in seq_along(NAMES)) {
[08:27:50.400]                   name <- changed[[kk]]
[08:27:50.400]                   NAME <- NAMES[[kk]]
[08:27:50.400]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.400]                     next
[08:27:50.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.400]                 }
[08:27:50.400]                 NAMES <- toupper(added)
[08:27:50.400]                 for (kk in seq_along(NAMES)) {
[08:27:50.400]                   name <- added[[kk]]
[08:27:50.400]                   NAME <- NAMES[[kk]]
[08:27:50.400]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.400]                     next
[08:27:50.400]                   args[[name]] <- ""
[08:27:50.400]                 }
[08:27:50.400]                 NAMES <- toupper(removed)
[08:27:50.400]                 for (kk in seq_along(NAMES)) {
[08:27:50.400]                   name <- removed[[kk]]
[08:27:50.400]                   NAME <- NAMES[[kk]]
[08:27:50.400]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.400]                     next
[08:27:50.400]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.400]                 }
[08:27:50.400]                 if (length(args) > 0) 
[08:27:50.400]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.400]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.400]             }
[08:27:50.400]             else {
[08:27:50.400]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.400]             }
[08:27:50.400]             {
[08:27:50.400]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.400]                   0L) {
[08:27:50.400]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.400]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.400]                   base::options(opts)
[08:27:50.400]                 }
[08:27:50.400]                 {
[08:27:50.400]                   {
[08:27:50.400]                     NULL
[08:27:50.400]                     RNGkind("Mersenne-Twister")
[08:27:50.400]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.400]                       inherits = FALSE)
[08:27:50.400]                   }
[08:27:50.400]                   options(future.plan = NULL)
[08:27:50.400]                   if (is.na(NA_character_)) 
[08:27:50.400]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.400]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.400]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.400]                     .init = FALSE)
[08:27:50.400]                 }
[08:27:50.400]             }
[08:27:50.400]         }
[08:27:50.400]     })
[08:27:50.400]     if (TRUE) {
[08:27:50.400]         base::sink(type = "output", split = FALSE)
[08:27:50.400]         if (TRUE) {
[08:27:50.400]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.400]         }
[08:27:50.400]         else {
[08:27:50.400]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.400]         }
[08:27:50.400]         base::close(...future.stdout)
[08:27:50.400]         ...future.stdout <- NULL
[08:27:50.400]     }
[08:27:50.400]     ...future.result$conditions <- ...future.conditions
[08:27:50.400]     ...future.result$finished <- base::Sys.time()
[08:27:50.400]     ...future.result
[08:27:50.400] }
[08:27:50.402] plan(): Setting new future strategy stack:
[08:27:50.402] List of future strategies:
[08:27:50.402] 1. sequential:
[08:27:50.402]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.402]    - tweaked: FALSE
[08:27:50.402]    - call: NULL
[08:27:50.403] plan(): nbrOfWorkers() = 1
[08:27:50.403] plan(): Setting new future strategy stack:
[08:27:50.403] List of future strategies:
[08:27:50.403] 1. sequential:
[08:27:50.403]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.403]    - tweaked: FALSE
[08:27:50.403]    - call: plan(strategy)
[08:27:50.404] plan(): nbrOfWorkers() = 1
[08:27:50.404] SequentialFuture started (and completed)
[08:27:50.404] - Launch lazy future ... done
[08:27:50.404] run() for ‘SequentialFuture’ ... done
[08:27:50.404] getGlobalsAndPackages() ...
[08:27:50.404] Searching for globals...
[08:27:50.405] 
[08:27:50.405] Searching for globals ... DONE
[08:27:50.405] - globals: [0] <none>
[08:27:50.405] getGlobalsAndPackages() ... DONE
[08:27:50.405] run() for ‘Future’ ...
[08:27:50.405] - state: ‘created’
[08:27:50.405] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.406] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.406] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.406]   - Field: ‘label’
[08:27:50.406]   - Field: ‘local’
[08:27:50.406]   - Field: ‘owner’
[08:27:50.406]   - Field: ‘envir’
[08:27:50.406]   - Field: ‘packages’
[08:27:50.406]   - Field: ‘gc’
[08:27:50.408]   - Field: ‘conditions’
[08:27:50.408]   - Field: ‘expr’
[08:27:50.408]   - Field: ‘uuid’
[08:27:50.408]   - Field: ‘seed’
[08:27:50.408]   - Field: ‘version’
[08:27:50.408]   - Field: ‘result’
[08:27:50.408]   - Field: ‘asynchronous’
[08:27:50.409]   - Field: ‘calls’
[08:27:50.409]   - Field: ‘globals’
[08:27:50.409]   - Field: ‘stdout’
[08:27:50.409]   - Field: ‘earlySignal’
[08:27:50.409]   - Field: ‘lazy’
[08:27:50.409]   - Field: ‘state’
[08:27:50.409] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.409] - Launch lazy future ...
[08:27:50.409] Packages needed by the future expression (n = 0): <none>
[08:27:50.409] Packages needed by future strategies (n = 0): <none>
[08:27:50.410] {
[08:27:50.410]     {
[08:27:50.410]         {
[08:27:50.410]             ...future.startTime <- base::Sys.time()
[08:27:50.410]             {
[08:27:50.410]                 {
[08:27:50.410]                   {
[08:27:50.410]                     base::local({
[08:27:50.410]                       has_future <- base::requireNamespace("future", 
[08:27:50.410]                         quietly = TRUE)
[08:27:50.410]                       if (has_future) {
[08:27:50.410]                         ns <- base::getNamespace("future")
[08:27:50.410]                         version <- ns[[".package"]][["version"]]
[08:27:50.410]                         if (is.null(version)) 
[08:27:50.410]                           version <- utils::packageVersion("future")
[08:27:50.410]                       }
[08:27:50.410]                       else {
[08:27:50.410]                         version <- NULL
[08:27:50.410]                       }
[08:27:50.410]                       if (!has_future || version < "1.8.0") {
[08:27:50.410]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.410]                           "", base::R.version$version.string), 
[08:27:50.410]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.410]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.410]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.410]                             "release", "version")], collapse = " "), 
[08:27:50.410]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.410]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.410]                           info)
[08:27:50.410]                         info <- base::paste(info, collapse = "; ")
[08:27:50.410]                         if (!has_future) {
[08:27:50.410]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.410]                             info)
[08:27:50.410]                         }
[08:27:50.410]                         else {
[08:27:50.410]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.410]                             info, version)
[08:27:50.410]                         }
[08:27:50.410]                         base::stop(msg)
[08:27:50.410]                       }
[08:27:50.410]                     })
[08:27:50.410]                   }
[08:27:50.410]                   ...future.strategy.old <- future::plan("list")
[08:27:50.410]                   options(future.plan = NULL)
[08:27:50.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.410]                 }
[08:27:50.410]                 ...future.workdir <- getwd()
[08:27:50.410]             }
[08:27:50.410]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.410]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.410]         }
[08:27:50.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.410]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.410]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.410]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.410]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.410]             base::names(...future.oldOptions))
[08:27:50.410]     }
[08:27:50.410]     if (FALSE) {
[08:27:50.410]     }
[08:27:50.410]     else {
[08:27:50.410]         if (TRUE) {
[08:27:50.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.410]                 open = "w")
[08:27:50.410]         }
[08:27:50.410]         else {
[08:27:50.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.410]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.410]         }
[08:27:50.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.410]             base::sink(type = "output", split = FALSE)
[08:27:50.410]             base::close(...future.stdout)
[08:27:50.410]         }, add = TRUE)
[08:27:50.410]     }
[08:27:50.410]     ...future.frame <- base::sys.nframe()
[08:27:50.410]     ...future.conditions <- base::list()
[08:27:50.410]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.410]     if (FALSE) {
[08:27:50.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.410]     }
[08:27:50.410]     ...future.result <- base::tryCatch({
[08:27:50.410]         base::withCallingHandlers({
[08:27:50.410]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.410]             future::FutureResult(value = ...future.value$value, 
[08:27:50.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.410]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.410]                     ...future.globalenv.names))
[08:27:50.410]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.410]         }, condition = base::local({
[08:27:50.410]             c <- base::c
[08:27:50.410]             inherits <- base::inherits
[08:27:50.410]             invokeRestart <- base::invokeRestart
[08:27:50.410]             length <- base::length
[08:27:50.410]             list <- base::list
[08:27:50.410]             seq.int <- base::seq.int
[08:27:50.410]             signalCondition <- base::signalCondition
[08:27:50.410]             sys.calls <- base::sys.calls
[08:27:50.410]             `[[` <- base::`[[`
[08:27:50.410]             `+` <- base::`+`
[08:27:50.410]             `<<-` <- base::`<<-`
[08:27:50.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.410]                   3L)]
[08:27:50.410]             }
[08:27:50.410]             function(cond) {
[08:27:50.410]                 is_error <- inherits(cond, "error")
[08:27:50.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.410]                   NULL)
[08:27:50.410]                 if (is_error) {
[08:27:50.410]                   sessionInformation <- function() {
[08:27:50.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.410]                       search = base::search(), system = base::Sys.info())
[08:27:50.410]                   }
[08:27:50.410]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.410]                     cond$call), session = sessionInformation(), 
[08:27:50.410]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.410]                   signalCondition(cond)
[08:27:50.410]                 }
[08:27:50.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.410]                 "immediateCondition"))) {
[08:27:50.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.410]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.410]                   if (TRUE && !signal) {
[08:27:50.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.410]                     {
[08:27:50.410]                       inherits <- base::inherits
[08:27:50.410]                       invokeRestart <- base::invokeRestart
[08:27:50.410]                       is.null <- base::is.null
[08:27:50.410]                       muffled <- FALSE
[08:27:50.410]                       if (inherits(cond, "message")) {
[08:27:50.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.410]                         if (muffled) 
[08:27:50.410]                           invokeRestart("muffleMessage")
[08:27:50.410]                       }
[08:27:50.410]                       else if (inherits(cond, "warning")) {
[08:27:50.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.410]                         if (muffled) 
[08:27:50.410]                           invokeRestart("muffleWarning")
[08:27:50.410]                       }
[08:27:50.410]                       else if (inherits(cond, "condition")) {
[08:27:50.410]                         if (!is.null(pattern)) {
[08:27:50.410]                           computeRestarts <- base::computeRestarts
[08:27:50.410]                           grepl <- base::grepl
[08:27:50.410]                           restarts <- computeRestarts(cond)
[08:27:50.410]                           for (restart in restarts) {
[08:27:50.410]                             name <- restart$name
[08:27:50.410]                             if (is.null(name)) 
[08:27:50.410]                               next
[08:27:50.410]                             if (!grepl(pattern, name)) 
[08:27:50.410]                               next
[08:27:50.410]                             invokeRestart(restart)
[08:27:50.410]                             muffled <- TRUE
[08:27:50.410]                             break
[08:27:50.410]                           }
[08:27:50.410]                         }
[08:27:50.410]                       }
[08:27:50.410]                       invisible(muffled)
[08:27:50.410]                     }
[08:27:50.410]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.410]                   }
[08:27:50.410]                 }
[08:27:50.410]                 else {
[08:27:50.410]                   if (TRUE) {
[08:27:50.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.410]                     {
[08:27:50.410]                       inherits <- base::inherits
[08:27:50.410]                       invokeRestart <- base::invokeRestart
[08:27:50.410]                       is.null <- base::is.null
[08:27:50.410]                       muffled <- FALSE
[08:27:50.410]                       if (inherits(cond, "message")) {
[08:27:50.410]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.410]                         if (muffled) 
[08:27:50.410]                           invokeRestart("muffleMessage")
[08:27:50.410]                       }
[08:27:50.410]                       else if (inherits(cond, "warning")) {
[08:27:50.410]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.410]                         if (muffled) 
[08:27:50.410]                           invokeRestart("muffleWarning")
[08:27:50.410]                       }
[08:27:50.410]                       else if (inherits(cond, "condition")) {
[08:27:50.410]                         if (!is.null(pattern)) {
[08:27:50.410]                           computeRestarts <- base::computeRestarts
[08:27:50.410]                           grepl <- base::grepl
[08:27:50.410]                           restarts <- computeRestarts(cond)
[08:27:50.410]                           for (restart in restarts) {
[08:27:50.410]                             name <- restart$name
[08:27:50.410]                             if (is.null(name)) 
[08:27:50.410]                               next
[08:27:50.410]                             if (!grepl(pattern, name)) 
[08:27:50.410]                               next
[08:27:50.410]                             invokeRestart(restart)
[08:27:50.410]                             muffled <- TRUE
[08:27:50.410]                             break
[08:27:50.410]                           }
[08:27:50.410]                         }
[08:27:50.410]                       }
[08:27:50.410]                       invisible(muffled)
[08:27:50.410]                     }
[08:27:50.410]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.410]                   }
[08:27:50.410]                 }
[08:27:50.410]             }
[08:27:50.410]         }))
[08:27:50.410]     }, error = function(ex) {
[08:27:50.410]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.410]                 ...future.rng), started = ...future.startTime, 
[08:27:50.410]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.410]             version = "1.8"), class = "FutureResult")
[08:27:50.410]     }, finally = {
[08:27:50.410]         if (!identical(...future.workdir, getwd())) 
[08:27:50.410]             setwd(...future.workdir)
[08:27:50.410]         {
[08:27:50.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.410]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.410]             }
[08:27:50.410]             base::options(...future.oldOptions)
[08:27:50.410]             if (.Platform$OS.type == "windows") {
[08:27:50.410]                 old_names <- names(...future.oldEnvVars)
[08:27:50.410]                 envs <- base::Sys.getenv()
[08:27:50.410]                 names <- names(envs)
[08:27:50.410]                 common <- intersect(names, old_names)
[08:27:50.410]                 added <- setdiff(names, old_names)
[08:27:50.410]                 removed <- setdiff(old_names, names)
[08:27:50.410]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.410]                   envs[common]]
[08:27:50.410]                 NAMES <- toupper(changed)
[08:27:50.410]                 args <- list()
[08:27:50.410]                 for (kk in seq_along(NAMES)) {
[08:27:50.410]                   name <- changed[[kk]]
[08:27:50.410]                   NAME <- NAMES[[kk]]
[08:27:50.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.410]                     next
[08:27:50.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.410]                 }
[08:27:50.410]                 NAMES <- toupper(added)
[08:27:50.410]                 for (kk in seq_along(NAMES)) {
[08:27:50.410]                   name <- added[[kk]]
[08:27:50.410]                   NAME <- NAMES[[kk]]
[08:27:50.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.410]                     next
[08:27:50.410]                   args[[name]] <- ""
[08:27:50.410]                 }
[08:27:50.410]                 NAMES <- toupper(removed)
[08:27:50.410]                 for (kk in seq_along(NAMES)) {
[08:27:50.410]                   name <- removed[[kk]]
[08:27:50.410]                   NAME <- NAMES[[kk]]
[08:27:50.410]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.410]                     next
[08:27:50.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.410]                 }
[08:27:50.410]                 if (length(args) > 0) 
[08:27:50.410]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.410]             }
[08:27:50.410]             else {
[08:27:50.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.410]             }
[08:27:50.410]             {
[08:27:50.410]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.410]                   0L) {
[08:27:50.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.410]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.410]                   base::options(opts)
[08:27:50.410]                 }
[08:27:50.410]                 {
[08:27:50.410]                   {
[08:27:50.410]                     NULL
[08:27:50.410]                     RNGkind("Mersenne-Twister")
[08:27:50.410]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.410]                       inherits = FALSE)
[08:27:50.410]                   }
[08:27:50.410]                   options(future.plan = NULL)
[08:27:50.410]                   if (is.na(NA_character_)) 
[08:27:50.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.410]                     .init = FALSE)
[08:27:50.410]                 }
[08:27:50.410]             }
[08:27:50.410]         }
[08:27:50.410]     })
[08:27:50.410]     if (TRUE) {
[08:27:50.410]         base::sink(type = "output", split = FALSE)
[08:27:50.410]         if (TRUE) {
[08:27:50.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.410]         }
[08:27:50.410]         else {
[08:27:50.410]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.410]         }
[08:27:50.410]         base::close(...future.stdout)
[08:27:50.410]         ...future.stdout <- NULL
[08:27:50.410]     }
[08:27:50.410]     ...future.result$conditions <- ...future.conditions
[08:27:50.410]     ...future.result$finished <- base::Sys.time()
[08:27:50.410]     ...future.result
[08:27:50.410] }
[08:27:50.412] plan(): Setting new future strategy stack:
[08:27:50.412] List of future strategies:
[08:27:50.412] 1. sequential:
[08:27:50.412]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.412]    - tweaked: FALSE
[08:27:50.412]    - call: NULL
[08:27:50.412] plan(): nbrOfWorkers() = 1
[08:27:50.413] plan(): Setting new future strategy stack:
[08:27:50.413] List of future strategies:
[08:27:50.413] 1. sequential:
[08:27:50.413]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.413]    - tweaked: FALSE
[08:27:50.413]    - call: plan(strategy)
[08:27:50.413] plan(): nbrOfWorkers() = 1
[08:27:50.413] SequentialFuture started (and completed)
[08:27:50.414] - Launch lazy future ... done
[08:27:50.414] run() for ‘SequentialFuture’ ... done
[08:27:50.414] getGlobalsAndPackages() ...
[08:27:50.414] Searching for globals...
[08:27:50.415] - globals found: [1] ‘{’
[08:27:50.415] Searching for globals ... DONE
[08:27:50.415] Resolving globals: FALSE
[08:27:50.415] 
[08:27:50.415] 
[08:27:50.415] getGlobalsAndPackages() ... DONE
[08:27:50.415] run() for ‘Future’ ...
[08:27:50.416] - state: ‘created’
[08:27:50.416] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.416] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.416] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.416]   - Field: ‘label’
[08:27:50.416]   - Field: ‘local’
[08:27:50.416]   - Field: ‘owner’
[08:27:50.416]   - Field: ‘envir’
[08:27:50.416]   - Field: ‘packages’
[08:27:50.417]   - Field: ‘gc’
[08:27:50.417]   - Field: ‘conditions’
[08:27:50.417]   - Field: ‘expr’
[08:27:50.417]   - Field: ‘uuid’
[08:27:50.417]   - Field: ‘seed’
[08:27:50.417]   - Field: ‘version’
[08:27:50.417]   - Field: ‘result’
[08:27:50.417]   - Field: ‘asynchronous’
[08:27:50.417]   - Field: ‘calls’
[08:27:50.417]   - Field: ‘globals’
[08:27:50.417]   - Field: ‘stdout’
[08:27:50.417]   - Field: ‘earlySignal’
[08:27:50.418]   - Field: ‘lazy’
[08:27:50.418]   - Field: ‘state’
[08:27:50.418] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.418] - Launch lazy future ...
[08:27:50.418] Packages needed by the future expression (n = 0): <none>
[08:27:50.418] Packages needed by future strategies (n = 0): <none>
[08:27:50.419] {
[08:27:50.419]     {
[08:27:50.419]         {
[08:27:50.419]             ...future.startTime <- base::Sys.time()
[08:27:50.419]             {
[08:27:50.419]                 {
[08:27:50.419]                   {
[08:27:50.419]                     base::local({
[08:27:50.419]                       has_future <- base::requireNamespace("future", 
[08:27:50.419]                         quietly = TRUE)
[08:27:50.419]                       if (has_future) {
[08:27:50.419]                         ns <- base::getNamespace("future")
[08:27:50.419]                         version <- ns[[".package"]][["version"]]
[08:27:50.419]                         if (is.null(version)) 
[08:27:50.419]                           version <- utils::packageVersion("future")
[08:27:50.419]                       }
[08:27:50.419]                       else {
[08:27:50.419]                         version <- NULL
[08:27:50.419]                       }
[08:27:50.419]                       if (!has_future || version < "1.8.0") {
[08:27:50.419]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.419]                           "", base::R.version$version.string), 
[08:27:50.419]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.419]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.419]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.419]                             "release", "version")], collapse = " "), 
[08:27:50.419]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.419]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.419]                           info)
[08:27:50.419]                         info <- base::paste(info, collapse = "; ")
[08:27:50.419]                         if (!has_future) {
[08:27:50.419]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.419]                             info)
[08:27:50.419]                         }
[08:27:50.419]                         else {
[08:27:50.419]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.419]                             info, version)
[08:27:50.419]                         }
[08:27:50.419]                         base::stop(msg)
[08:27:50.419]                       }
[08:27:50.419]                     })
[08:27:50.419]                   }
[08:27:50.419]                   ...future.strategy.old <- future::plan("list")
[08:27:50.419]                   options(future.plan = NULL)
[08:27:50.419]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.419]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.419]                 }
[08:27:50.419]                 ...future.workdir <- getwd()
[08:27:50.419]             }
[08:27:50.419]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.419]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.419]         }
[08:27:50.419]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.419]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.419]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.419]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.419]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.419]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.419]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.419]             base::names(...future.oldOptions))
[08:27:50.419]     }
[08:27:50.419]     if (FALSE) {
[08:27:50.419]     }
[08:27:50.419]     else {
[08:27:50.419]         if (TRUE) {
[08:27:50.419]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.419]                 open = "w")
[08:27:50.419]         }
[08:27:50.419]         else {
[08:27:50.419]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.419]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.419]         }
[08:27:50.419]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.419]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.419]             base::sink(type = "output", split = FALSE)
[08:27:50.419]             base::close(...future.stdout)
[08:27:50.419]         }, add = TRUE)
[08:27:50.419]     }
[08:27:50.419]     ...future.frame <- base::sys.nframe()
[08:27:50.419]     ...future.conditions <- base::list()
[08:27:50.419]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.419]     if (FALSE) {
[08:27:50.419]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.419]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.419]     }
[08:27:50.419]     ...future.result <- base::tryCatch({
[08:27:50.419]         base::withCallingHandlers({
[08:27:50.419]             ...future.value <- base::withVisible(base::local({
[08:27:50.419]                 4
[08:27:50.419]             }))
[08:27:50.419]             future::FutureResult(value = ...future.value$value, 
[08:27:50.419]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.419]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.419]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.419]                     ...future.globalenv.names))
[08:27:50.419]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.419]         }, condition = base::local({
[08:27:50.419]             c <- base::c
[08:27:50.419]             inherits <- base::inherits
[08:27:50.419]             invokeRestart <- base::invokeRestart
[08:27:50.419]             length <- base::length
[08:27:50.419]             list <- base::list
[08:27:50.419]             seq.int <- base::seq.int
[08:27:50.419]             signalCondition <- base::signalCondition
[08:27:50.419]             sys.calls <- base::sys.calls
[08:27:50.419]             `[[` <- base::`[[`
[08:27:50.419]             `+` <- base::`+`
[08:27:50.419]             `<<-` <- base::`<<-`
[08:27:50.419]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.419]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.419]                   3L)]
[08:27:50.419]             }
[08:27:50.419]             function(cond) {
[08:27:50.419]                 is_error <- inherits(cond, "error")
[08:27:50.419]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.419]                   NULL)
[08:27:50.419]                 if (is_error) {
[08:27:50.419]                   sessionInformation <- function() {
[08:27:50.419]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.419]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.419]                       search = base::search(), system = base::Sys.info())
[08:27:50.419]                   }
[08:27:50.419]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.419]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.419]                     cond$call), session = sessionInformation(), 
[08:27:50.419]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.419]                   signalCondition(cond)
[08:27:50.419]                 }
[08:27:50.419]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.419]                 "immediateCondition"))) {
[08:27:50.419]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.419]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.419]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.419]                   if (TRUE && !signal) {
[08:27:50.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.419]                     {
[08:27:50.419]                       inherits <- base::inherits
[08:27:50.419]                       invokeRestart <- base::invokeRestart
[08:27:50.419]                       is.null <- base::is.null
[08:27:50.419]                       muffled <- FALSE
[08:27:50.419]                       if (inherits(cond, "message")) {
[08:27:50.419]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.419]                         if (muffled) 
[08:27:50.419]                           invokeRestart("muffleMessage")
[08:27:50.419]                       }
[08:27:50.419]                       else if (inherits(cond, "warning")) {
[08:27:50.419]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.419]                         if (muffled) 
[08:27:50.419]                           invokeRestart("muffleWarning")
[08:27:50.419]                       }
[08:27:50.419]                       else if (inherits(cond, "condition")) {
[08:27:50.419]                         if (!is.null(pattern)) {
[08:27:50.419]                           computeRestarts <- base::computeRestarts
[08:27:50.419]                           grepl <- base::grepl
[08:27:50.419]                           restarts <- computeRestarts(cond)
[08:27:50.419]                           for (restart in restarts) {
[08:27:50.419]                             name <- restart$name
[08:27:50.419]                             if (is.null(name)) 
[08:27:50.419]                               next
[08:27:50.419]                             if (!grepl(pattern, name)) 
[08:27:50.419]                               next
[08:27:50.419]                             invokeRestart(restart)
[08:27:50.419]                             muffled <- TRUE
[08:27:50.419]                             break
[08:27:50.419]                           }
[08:27:50.419]                         }
[08:27:50.419]                       }
[08:27:50.419]                       invisible(muffled)
[08:27:50.419]                     }
[08:27:50.419]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.419]                   }
[08:27:50.419]                 }
[08:27:50.419]                 else {
[08:27:50.419]                   if (TRUE) {
[08:27:50.419]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.419]                     {
[08:27:50.419]                       inherits <- base::inherits
[08:27:50.419]                       invokeRestart <- base::invokeRestart
[08:27:50.419]                       is.null <- base::is.null
[08:27:50.419]                       muffled <- FALSE
[08:27:50.419]                       if (inherits(cond, "message")) {
[08:27:50.419]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.419]                         if (muffled) 
[08:27:50.419]                           invokeRestart("muffleMessage")
[08:27:50.419]                       }
[08:27:50.419]                       else if (inherits(cond, "warning")) {
[08:27:50.419]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.419]                         if (muffled) 
[08:27:50.419]                           invokeRestart("muffleWarning")
[08:27:50.419]                       }
[08:27:50.419]                       else if (inherits(cond, "condition")) {
[08:27:50.419]                         if (!is.null(pattern)) {
[08:27:50.419]                           computeRestarts <- base::computeRestarts
[08:27:50.419]                           grepl <- base::grepl
[08:27:50.419]                           restarts <- computeRestarts(cond)
[08:27:50.419]                           for (restart in restarts) {
[08:27:50.419]                             name <- restart$name
[08:27:50.419]                             if (is.null(name)) 
[08:27:50.419]                               next
[08:27:50.419]                             if (!grepl(pattern, name)) 
[08:27:50.419]                               next
[08:27:50.419]                             invokeRestart(restart)
[08:27:50.419]                             muffled <- TRUE
[08:27:50.419]                             break
[08:27:50.419]                           }
[08:27:50.419]                         }
[08:27:50.419]                       }
[08:27:50.419]                       invisible(muffled)
[08:27:50.419]                     }
[08:27:50.419]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.419]                   }
[08:27:50.419]                 }
[08:27:50.419]             }
[08:27:50.419]         }))
[08:27:50.419]     }, error = function(ex) {
[08:27:50.419]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.419]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.419]                 ...future.rng), started = ...future.startTime, 
[08:27:50.419]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.419]             version = "1.8"), class = "FutureResult")
[08:27:50.419]     }, finally = {
[08:27:50.419]         if (!identical(...future.workdir, getwd())) 
[08:27:50.419]             setwd(...future.workdir)
[08:27:50.419]         {
[08:27:50.419]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.419]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.419]             }
[08:27:50.419]             base::options(...future.oldOptions)
[08:27:50.419]             if (.Platform$OS.type == "windows") {
[08:27:50.419]                 old_names <- names(...future.oldEnvVars)
[08:27:50.419]                 envs <- base::Sys.getenv()
[08:27:50.419]                 names <- names(envs)
[08:27:50.419]                 common <- intersect(names, old_names)
[08:27:50.419]                 added <- setdiff(names, old_names)
[08:27:50.419]                 removed <- setdiff(old_names, names)
[08:27:50.419]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.419]                   envs[common]]
[08:27:50.419]                 NAMES <- toupper(changed)
[08:27:50.419]                 args <- list()
[08:27:50.419]                 for (kk in seq_along(NAMES)) {
[08:27:50.419]                   name <- changed[[kk]]
[08:27:50.419]                   NAME <- NAMES[[kk]]
[08:27:50.419]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.419]                     next
[08:27:50.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.419]                 }
[08:27:50.419]                 NAMES <- toupper(added)
[08:27:50.419]                 for (kk in seq_along(NAMES)) {
[08:27:50.419]                   name <- added[[kk]]
[08:27:50.419]                   NAME <- NAMES[[kk]]
[08:27:50.419]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.419]                     next
[08:27:50.419]                   args[[name]] <- ""
[08:27:50.419]                 }
[08:27:50.419]                 NAMES <- toupper(removed)
[08:27:50.419]                 for (kk in seq_along(NAMES)) {
[08:27:50.419]                   name <- removed[[kk]]
[08:27:50.419]                   NAME <- NAMES[[kk]]
[08:27:50.419]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.419]                     next
[08:27:50.419]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.419]                 }
[08:27:50.419]                 if (length(args) > 0) 
[08:27:50.419]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.419]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.419]             }
[08:27:50.419]             else {
[08:27:50.419]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.419]             }
[08:27:50.419]             {
[08:27:50.419]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.419]                   0L) {
[08:27:50.419]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.419]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.419]                   base::options(opts)
[08:27:50.419]                 }
[08:27:50.419]                 {
[08:27:50.419]                   {
[08:27:50.419]                     NULL
[08:27:50.419]                     RNGkind("Mersenne-Twister")
[08:27:50.419]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.419]                       inherits = FALSE)
[08:27:50.419]                   }
[08:27:50.419]                   options(future.plan = NULL)
[08:27:50.419]                   if (is.na(NA_character_)) 
[08:27:50.419]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.419]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.419]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.419]                     .init = FALSE)
[08:27:50.419]                 }
[08:27:50.419]             }
[08:27:50.419]         }
[08:27:50.419]     })
[08:27:50.419]     if (TRUE) {
[08:27:50.419]         base::sink(type = "output", split = FALSE)
[08:27:50.419]         if (TRUE) {
[08:27:50.419]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.419]         }
[08:27:50.419]         else {
[08:27:50.419]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.419]         }
[08:27:50.419]         base::close(...future.stdout)
[08:27:50.419]         ...future.stdout <- NULL
[08:27:50.419]     }
[08:27:50.419]     ...future.result$conditions <- ...future.conditions
[08:27:50.419]     ...future.result$finished <- base::Sys.time()
[08:27:50.419]     ...future.result
[08:27:50.419] }
[08:27:50.420] plan(): Setting new future strategy stack:
[08:27:50.420] List of future strategies:
[08:27:50.420] 1. sequential:
[08:27:50.420]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.420]    - tweaked: FALSE
[08:27:50.420]    - call: NULL
[08:27:50.421] plan(): nbrOfWorkers() = 1
[08:27:50.421] plan(): Setting new future strategy stack:
[08:27:50.422] List of future strategies:
[08:27:50.422] 1. sequential:
[08:27:50.422]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.422]    - tweaked: FALSE
[08:27:50.422]    - call: plan(strategy)
[08:27:50.422] plan(): nbrOfWorkers() = 1
[08:27:50.422] SequentialFuture started (and completed)
[08:27:50.422] - Launch lazy future ... done
[08:27:50.422] run() for ‘SequentialFuture’ ... done
<environment: 0x55d860b85408> 
<environment: 0x55d8609e57a8> 
[08:27:50.424] resolved() for ‘SequentialFuture’ ...
[08:27:50.424] - state: ‘finished’
[08:27:50.424] - run: TRUE
[08:27:50.424] - result: ‘FutureResult’
[08:27:50.424] resolved() for ‘SequentialFuture’ ... done
[08:27:50.424] resolved() for ‘SequentialFuture’ ...
[08:27:50.424] - state: ‘finished’
[08:27:50.424] - run: TRUE
[08:27:50.424] - result: ‘FutureResult’
[08:27:50.424] resolved() for ‘SequentialFuture’ ... done
[08:27:50.424] resolved() for ‘SequentialFuture’ ...
[08:27:50.425] - state: ‘finished’
[08:27:50.425] - run: TRUE
[08:27:50.425] - result: ‘FutureResult’
[08:27:50.425] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:50.426] resolve() on environment ...
[08:27:50.426]  recursive: 0
[08:27:50.426]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:50.427] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.427] - nx: 4
[08:27:50.427] - relay: TRUE
[08:27:50.427] - stdout: TRUE
[08:27:50.427] - signal: TRUE
[08:27:50.427] - resignal: FALSE
[08:27:50.427] - force: TRUE
[08:27:50.427] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.427] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.427]  - until=2
[08:27:50.427]  - relaying element #2
[08:27:50.428] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.428] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.428] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.428]  length: 3 (resolved future 1)
[08:27:50.428] resolved() for ‘SequentialFuture’ ...
[08:27:50.428] - state: ‘finished’
[08:27:50.428] - run: TRUE
[08:27:50.428] - result: ‘FutureResult’
[08:27:50.428] resolved() for ‘SequentialFuture’ ... done
[08:27:50.428] Future #2
[08:27:50.428] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.429] - nx: 4
[08:27:50.429] - relay: TRUE
[08:27:50.429] - stdout: TRUE
[08:27:50.429] - signal: TRUE
[08:27:50.429] - resignal: FALSE
[08:27:50.429] - force: TRUE
[08:27:50.429] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.429] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.429]  - until=2
[08:27:50.429]  - relaying element #2
[08:27:50.429] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.430] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.430] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.430]  length: 2 (resolved future 2)
[08:27:50.430] resolved() for ‘SequentialFuture’ ...
[08:27:50.430] - state: ‘finished’
[08:27:50.430] - run: TRUE
[08:27:50.430] - result: ‘FutureResult’
[08:27:50.430] resolved() for ‘SequentialFuture’ ... done
[08:27:50.430] Future #3
[08:27:50.430] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.430] - nx: 4
[08:27:50.431] - relay: TRUE
[08:27:50.431] - stdout: TRUE
[08:27:50.431] - signal: TRUE
[08:27:50.431] - resignal: FALSE
[08:27:50.431] - force: TRUE
[08:27:50.431] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.431] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.431]  - until=3
[08:27:50.431]  - relaying element #3
[08:27:50.431] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.431] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.431] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.432]  length: 1 (resolved future 3)
[08:27:50.432] resolved() for ‘SequentialFuture’ ...
[08:27:50.432] - state: ‘finished’
[08:27:50.432] - run: TRUE
[08:27:50.432] - result: ‘FutureResult’
[08:27:50.432] resolved() for ‘SequentialFuture’ ... done
[08:27:50.432] Future #4
[08:27:50.432] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.432] - nx: 4
[08:27:50.432] - relay: TRUE
[08:27:50.432] - stdout: TRUE
[08:27:50.433] - signal: TRUE
[08:27:50.433] - resignal: FALSE
[08:27:50.433] - force: TRUE
[08:27:50.433] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.433] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.433]  - until=4
[08:27:50.433]  - relaying element #4
[08:27:50.433] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.433] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.433] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.435]  length: 0 (resolved future 4)
[08:27:50.435] Relaying remaining futures
[08:27:50.435] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.435] - nx: 4
[08:27:50.436] - relay: TRUE
[08:27:50.436] - stdout: TRUE
[08:27:50.436] - signal: TRUE
[08:27:50.436] - resignal: FALSE
[08:27:50.436] - force: TRUE
[08:27:50.436] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.436] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:50.436] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.436] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.436] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.436] resolve() on environment ... DONE
<environment: 0x55d860b8dc90> 
Dimensions: c(2, 3)
[08:27:50.437] getGlobalsAndPackages() ...
[08:27:50.437] Searching for globals...
[08:27:50.437] 
[08:27:50.437] Searching for globals ... DONE
[08:27:50.438] - globals: [0] <none>
[08:27:50.438] getGlobalsAndPackages() ... DONE
[08:27:50.438] run() for ‘Future’ ...
[08:27:50.438] - state: ‘created’
[08:27:50.438] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.438] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.438] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.439]   - Field: ‘label’
[08:27:50.439]   - Field: ‘local’
[08:27:50.439]   - Field: ‘owner’
[08:27:50.439]   - Field: ‘envir’
[08:27:50.439]   - Field: ‘packages’
[08:27:50.439]   - Field: ‘gc’
[08:27:50.439]   - Field: ‘conditions’
[08:27:50.439]   - Field: ‘expr’
[08:27:50.439]   - Field: ‘uuid’
[08:27:50.439]   - Field: ‘seed’
[08:27:50.439]   - Field: ‘version’
[08:27:50.439]   - Field: ‘result’
[08:27:50.440]   - Field: ‘asynchronous’
[08:27:50.440]   - Field: ‘calls’
[08:27:50.440]   - Field: ‘globals’
[08:27:50.440]   - Field: ‘stdout’
[08:27:50.440]   - Field: ‘earlySignal’
[08:27:50.440]   - Field: ‘lazy’
[08:27:50.440]   - Field: ‘state’
[08:27:50.440] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.440] - Launch lazy future ...
[08:27:50.440] Packages needed by the future expression (n = 0): <none>
[08:27:50.441] Packages needed by future strategies (n = 0): <none>
[08:27:50.441] {
[08:27:50.441]     {
[08:27:50.441]         {
[08:27:50.441]             ...future.startTime <- base::Sys.time()
[08:27:50.441]             {
[08:27:50.441]                 {
[08:27:50.441]                   {
[08:27:50.441]                     base::local({
[08:27:50.441]                       has_future <- base::requireNamespace("future", 
[08:27:50.441]                         quietly = TRUE)
[08:27:50.441]                       if (has_future) {
[08:27:50.441]                         ns <- base::getNamespace("future")
[08:27:50.441]                         version <- ns[[".package"]][["version"]]
[08:27:50.441]                         if (is.null(version)) 
[08:27:50.441]                           version <- utils::packageVersion("future")
[08:27:50.441]                       }
[08:27:50.441]                       else {
[08:27:50.441]                         version <- NULL
[08:27:50.441]                       }
[08:27:50.441]                       if (!has_future || version < "1.8.0") {
[08:27:50.441]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.441]                           "", base::R.version$version.string), 
[08:27:50.441]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.441]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.441]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.441]                             "release", "version")], collapse = " "), 
[08:27:50.441]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.441]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.441]                           info)
[08:27:50.441]                         info <- base::paste(info, collapse = "; ")
[08:27:50.441]                         if (!has_future) {
[08:27:50.441]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.441]                             info)
[08:27:50.441]                         }
[08:27:50.441]                         else {
[08:27:50.441]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.441]                             info, version)
[08:27:50.441]                         }
[08:27:50.441]                         base::stop(msg)
[08:27:50.441]                       }
[08:27:50.441]                     })
[08:27:50.441]                   }
[08:27:50.441]                   ...future.strategy.old <- future::plan("list")
[08:27:50.441]                   options(future.plan = NULL)
[08:27:50.441]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.441]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.441]                 }
[08:27:50.441]                 ...future.workdir <- getwd()
[08:27:50.441]             }
[08:27:50.441]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.441]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.441]         }
[08:27:50.441]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.441]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.441]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.441]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.441]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.441]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.441]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.441]             base::names(...future.oldOptions))
[08:27:50.441]     }
[08:27:50.441]     if (FALSE) {
[08:27:50.441]     }
[08:27:50.441]     else {
[08:27:50.441]         if (TRUE) {
[08:27:50.441]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.441]                 open = "w")
[08:27:50.441]         }
[08:27:50.441]         else {
[08:27:50.441]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.441]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.441]         }
[08:27:50.441]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.441]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.441]             base::sink(type = "output", split = FALSE)
[08:27:50.441]             base::close(...future.stdout)
[08:27:50.441]         }, add = TRUE)
[08:27:50.441]     }
[08:27:50.441]     ...future.frame <- base::sys.nframe()
[08:27:50.441]     ...future.conditions <- base::list()
[08:27:50.441]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.441]     if (FALSE) {
[08:27:50.441]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.441]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.441]     }
[08:27:50.441]     ...future.result <- base::tryCatch({
[08:27:50.441]         base::withCallingHandlers({
[08:27:50.441]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.441]             future::FutureResult(value = ...future.value$value, 
[08:27:50.441]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.441]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.441]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.441]                     ...future.globalenv.names))
[08:27:50.441]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.441]         }, condition = base::local({
[08:27:50.441]             c <- base::c
[08:27:50.441]             inherits <- base::inherits
[08:27:50.441]             invokeRestart <- base::invokeRestart
[08:27:50.441]             length <- base::length
[08:27:50.441]             list <- base::list
[08:27:50.441]             seq.int <- base::seq.int
[08:27:50.441]             signalCondition <- base::signalCondition
[08:27:50.441]             sys.calls <- base::sys.calls
[08:27:50.441]             `[[` <- base::`[[`
[08:27:50.441]             `+` <- base::`+`
[08:27:50.441]             `<<-` <- base::`<<-`
[08:27:50.441]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.441]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.441]                   3L)]
[08:27:50.441]             }
[08:27:50.441]             function(cond) {
[08:27:50.441]                 is_error <- inherits(cond, "error")
[08:27:50.441]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.441]                   NULL)
[08:27:50.441]                 if (is_error) {
[08:27:50.441]                   sessionInformation <- function() {
[08:27:50.441]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.441]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.441]                       search = base::search(), system = base::Sys.info())
[08:27:50.441]                   }
[08:27:50.441]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.441]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.441]                     cond$call), session = sessionInformation(), 
[08:27:50.441]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.441]                   signalCondition(cond)
[08:27:50.441]                 }
[08:27:50.441]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.441]                 "immediateCondition"))) {
[08:27:50.441]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.441]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.441]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.441]                   if (TRUE && !signal) {
[08:27:50.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.441]                     {
[08:27:50.441]                       inherits <- base::inherits
[08:27:50.441]                       invokeRestart <- base::invokeRestart
[08:27:50.441]                       is.null <- base::is.null
[08:27:50.441]                       muffled <- FALSE
[08:27:50.441]                       if (inherits(cond, "message")) {
[08:27:50.441]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.441]                         if (muffled) 
[08:27:50.441]                           invokeRestart("muffleMessage")
[08:27:50.441]                       }
[08:27:50.441]                       else if (inherits(cond, "warning")) {
[08:27:50.441]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.441]                         if (muffled) 
[08:27:50.441]                           invokeRestart("muffleWarning")
[08:27:50.441]                       }
[08:27:50.441]                       else if (inherits(cond, "condition")) {
[08:27:50.441]                         if (!is.null(pattern)) {
[08:27:50.441]                           computeRestarts <- base::computeRestarts
[08:27:50.441]                           grepl <- base::grepl
[08:27:50.441]                           restarts <- computeRestarts(cond)
[08:27:50.441]                           for (restart in restarts) {
[08:27:50.441]                             name <- restart$name
[08:27:50.441]                             if (is.null(name)) 
[08:27:50.441]                               next
[08:27:50.441]                             if (!grepl(pattern, name)) 
[08:27:50.441]                               next
[08:27:50.441]                             invokeRestart(restart)
[08:27:50.441]                             muffled <- TRUE
[08:27:50.441]                             break
[08:27:50.441]                           }
[08:27:50.441]                         }
[08:27:50.441]                       }
[08:27:50.441]                       invisible(muffled)
[08:27:50.441]                     }
[08:27:50.441]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.441]                   }
[08:27:50.441]                 }
[08:27:50.441]                 else {
[08:27:50.441]                   if (TRUE) {
[08:27:50.441]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.441]                     {
[08:27:50.441]                       inherits <- base::inherits
[08:27:50.441]                       invokeRestart <- base::invokeRestart
[08:27:50.441]                       is.null <- base::is.null
[08:27:50.441]                       muffled <- FALSE
[08:27:50.441]                       if (inherits(cond, "message")) {
[08:27:50.441]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.441]                         if (muffled) 
[08:27:50.441]                           invokeRestart("muffleMessage")
[08:27:50.441]                       }
[08:27:50.441]                       else if (inherits(cond, "warning")) {
[08:27:50.441]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.441]                         if (muffled) 
[08:27:50.441]                           invokeRestart("muffleWarning")
[08:27:50.441]                       }
[08:27:50.441]                       else if (inherits(cond, "condition")) {
[08:27:50.441]                         if (!is.null(pattern)) {
[08:27:50.441]                           computeRestarts <- base::computeRestarts
[08:27:50.441]                           grepl <- base::grepl
[08:27:50.441]                           restarts <- computeRestarts(cond)
[08:27:50.441]                           for (restart in restarts) {
[08:27:50.441]                             name <- restart$name
[08:27:50.441]                             if (is.null(name)) 
[08:27:50.441]                               next
[08:27:50.441]                             if (!grepl(pattern, name)) 
[08:27:50.441]                               next
[08:27:50.441]                             invokeRestart(restart)
[08:27:50.441]                             muffled <- TRUE
[08:27:50.441]                             break
[08:27:50.441]                           }
[08:27:50.441]                         }
[08:27:50.441]                       }
[08:27:50.441]                       invisible(muffled)
[08:27:50.441]                     }
[08:27:50.441]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.441]                   }
[08:27:50.441]                 }
[08:27:50.441]             }
[08:27:50.441]         }))
[08:27:50.441]     }, error = function(ex) {
[08:27:50.441]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.441]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.441]                 ...future.rng), started = ...future.startTime, 
[08:27:50.441]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.441]             version = "1.8"), class = "FutureResult")
[08:27:50.441]     }, finally = {
[08:27:50.441]         if (!identical(...future.workdir, getwd())) 
[08:27:50.441]             setwd(...future.workdir)
[08:27:50.441]         {
[08:27:50.441]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.441]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.441]             }
[08:27:50.441]             base::options(...future.oldOptions)
[08:27:50.441]             if (.Platform$OS.type == "windows") {
[08:27:50.441]                 old_names <- names(...future.oldEnvVars)
[08:27:50.441]                 envs <- base::Sys.getenv()
[08:27:50.441]                 names <- names(envs)
[08:27:50.441]                 common <- intersect(names, old_names)
[08:27:50.441]                 added <- setdiff(names, old_names)
[08:27:50.441]                 removed <- setdiff(old_names, names)
[08:27:50.441]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.441]                   envs[common]]
[08:27:50.441]                 NAMES <- toupper(changed)
[08:27:50.441]                 args <- list()
[08:27:50.441]                 for (kk in seq_along(NAMES)) {
[08:27:50.441]                   name <- changed[[kk]]
[08:27:50.441]                   NAME <- NAMES[[kk]]
[08:27:50.441]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.441]                     next
[08:27:50.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.441]                 }
[08:27:50.441]                 NAMES <- toupper(added)
[08:27:50.441]                 for (kk in seq_along(NAMES)) {
[08:27:50.441]                   name <- added[[kk]]
[08:27:50.441]                   NAME <- NAMES[[kk]]
[08:27:50.441]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.441]                     next
[08:27:50.441]                   args[[name]] <- ""
[08:27:50.441]                 }
[08:27:50.441]                 NAMES <- toupper(removed)
[08:27:50.441]                 for (kk in seq_along(NAMES)) {
[08:27:50.441]                   name <- removed[[kk]]
[08:27:50.441]                   NAME <- NAMES[[kk]]
[08:27:50.441]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.441]                     next
[08:27:50.441]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.441]                 }
[08:27:50.441]                 if (length(args) > 0) 
[08:27:50.441]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.441]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.441]             }
[08:27:50.441]             else {
[08:27:50.441]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.441]             }
[08:27:50.441]             {
[08:27:50.441]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.441]                   0L) {
[08:27:50.441]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.441]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.441]                   base::options(opts)
[08:27:50.441]                 }
[08:27:50.441]                 {
[08:27:50.441]                   {
[08:27:50.441]                     NULL
[08:27:50.441]                     RNGkind("Mersenne-Twister")
[08:27:50.441]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.441]                       inherits = FALSE)
[08:27:50.441]                   }
[08:27:50.441]                   options(future.plan = NULL)
[08:27:50.441]                   if (is.na(NA_character_)) 
[08:27:50.441]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.441]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.441]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.441]                     .init = FALSE)
[08:27:50.441]                 }
[08:27:50.441]             }
[08:27:50.441]         }
[08:27:50.441]     })
[08:27:50.441]     if (TRUE) {
[08:27:50.441]         base::sink(type = "output", split = FALSE)
[08:27:50.441]         if (TRUE) {
[08:27:50.441]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.441]         }
[08:27:50.441]         else {
[08:27:50.441]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.441]         }
[08:27:50.441]         base::close(...future.stdout)
[08:27:50.441]         ...future.stdout <- NULL
[08:27:50.441]     }
[08:27:50.441]     ...future.result$conditions <- ...future.conditions
[08:27:50.441]     ...future.result$finished <- base::Sys.time()
[08:27:50.441]     ...future.result
[08:27:50.441] }
[08:27:50.443] plan(): Setting new future strategy stack:
[08:27:50.443] List of future strategies:
[08:27:50.443] 1. sequential:
[08:27:50.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.443]    - tweaked: FALSE
[08:27:50.443]    - call: NULL
[08:27:50.443] plan(): nbrOfWorkers() = 1
[08:27:50.444] plan(): Setting new future strategy stack:
[08:27:50.444] List of future strategies:
[08:27:50.444] 1. sequential:
[08:27:50.444]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.444]    - tweaked: FALSE
[08:27:50.444]    - call: plan(strategy)
[08:27:50.445] plan(): nbrOfWorkers() = 1
[08:27:50.445] SequentialFuture started (and completed)
[08:27:50.445] - Launch lazy future ... done
[08:27:50.445] run() for ‘SequentialFuture’ ... done
[08:27:50.445] getGlobalsAndPackages() ...
[08:27:50.445] Searching for globals...
[08:27:50.445] 
[08:27:50.446] Searching for globals ... DONE
[08:27:50.446] - globals: [0] <none>
[08:27:50.446] getGlobalsAndPackages() ... DONE
[08:27:50.446] run() for ‘Future’ ...
[08:27:50.446] - state: ‘created’
[08:27:50.446] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.446] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.446] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.447]   - Field: ‘label’
[08:27:50.447]   - Field: ‘local’
[08:27:50.447]   - Field: ‘owner’
[08:27:50.447]   - Field: ‘envir’
[08:27:50.447]   - Field: ‘packages’
[08:27:50.447]   - Field: ‘gc’
[08:27:50.447]   - Field: ‘conditions’
[08:27:50.447]   - Field: ‘expr’
[08:27:50.447]   - Field: ‘uuid’
[08:27:50.447]   - Field: ‘seed’
[08:27:50.447]   - Field: ‘version’
[08:27:50.448]   - Field: ‘result’
[08:27:50.448]   - Field: ‘asynchronous’
[08:27:50.448]   - Field: ‘calls’
[08:27:50.448]   - Field: ‘globals’
[08:27:50.448]   - Field: ‘stdout’
[08:27:50.448]   - Field: ‘earlySignal’
[08:27:50.448]   - Field: ‘lazy’
[08:27:50.448]   - Field: ‘state’
[08:27:50.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.448] - Launch lazy future ...
[08:27:50.448] Packages needed by the future expression (n = 0): <none>
[08:27:50.449] Packages needed by future strategies (n = 0): <none>
[08:27:50.449] {
[08:27:50.449]     {
[08:27:50.449]         {
[08:27:50.449]             ...future.startTime <- base::Sys.time()
[08:27:50.449]             {
[08:27:50.449]                 {
[08:27:50.449]                   {
[08:27:50.449]                     base::local({
[08:27:50.449]                       has_future <- base::requireNamespace("future", 
[08:27:50.449]                         quietly = TRUE)
[08:27:50.449]                       if (has_future) {
[08:27:50.449]                         ns <- base::getNamespace("future")
[08:27:50.449]                         version <- ns[[".package"]][["version"]]
[08:27:50.449]                         if (is.null(version)) 
[08:27:50.449]                           version <- utils::packageVersion("future")
[08:27:50.449]                       }
[08:27:50.449]                       else {
[08:27:50.449]                         version <- NULL
[08:27:50.449]                       }
[08:27:50.449]                       if (!has_future || version < "1.8.0") {
[08:27:50.449]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.449]                           "", base::R.version$version.string), 
[08:27:50.449]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.449]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.449]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.449]                             "release", "version")], collapse = " "), 
[08:27:50.449]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.449]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.449]                           info)
[08:27:50.449]                         info <- base::paste(info, collapse = "; ")
[08:27:50.449]                         if (!has_future) {
[08:27:50.449]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.449]                             info)
[08:27:50.449]                         }
[08:27:50.449]                         else {
[08:27:50.449]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.449]                             info, version)
[08:27:50.449]                         }
[08:27:50.449]                         base::stop(msg)
[08:27:50.449]                       }
[08:27:50.449]                     })
[08:27:50.449]                   }
[08:27:50.449]                   ...future.strategy.old <- future::plan("list")
[08:27:50.449]                   options(future.plan = NULL)
[08:27:50.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.449]                 }
[08:27:50.449]                 ...future.workdir <- getwd()
[08:27:50.449]             }
[08:27:50.449]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.449]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.449]         }
[08:27:50.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.449]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.449]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.449]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.449]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.449]             base::names(...future.oldOptions))
[08:27:50.449]     }
[08:27:50.449]     if (FALSE) {
[08:27:50.449]     }
[08:27:50.449]     else {
[08:27:50.449]         if (TRUE) {
[08:27:50.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.449]                 open = "w")
[08:27:50.449]         }
[08:27:50.449]         else {
[08:27:50.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.449]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.449]         }
[08:27:50.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.449]             base::sink(type = "output", split = FALSE)
[08:27:50.449]             base::close(...future.stdout)
[08:27:50.449]         }, add = TRUE)
[08:27:50.449]     }
[08:27:50.449]     ...future.frame <- base::sys.nframe()
[08:27:50.449]     ...future.conditions <- base::list()
[08:27:50.449]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.449]     if (FALSE) {
[08:27:50.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.449]     }
[08:27:50.449]     ...future.result <- base::tryCatch({
[08:27:50.449]         base::withCallingHandlers({
[08:27:50.449]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.449]             future::FutureResult(value = ...future.value$value, 
[08:27:50.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.449]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.449]                     ...future.globalenv.names))
[08:27:50.449]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.449]         }, condition = base::local({
[08:27:50.449]             c <- base::c
[08:27:50.449]             inherits <- base::inherits
[08:27:50.449]             invokeRestart <- base::invokeRestart
[08:27:50.449]             length <- base::length
[08:27:50.449]             list <- base::list
[08:27:50.449]             seq.int <- base::seq.int
[08:27:50.449]             signalCondition <- base::signalCondition
[08:27:50.449]             sys.calls <- base::sys.calls
[08:27:50.449]             `[[` <- base::`[[`
[08:27:50.449]             `+` <- base::`+`
[08:27:50.449]             `<<-` <- base::`<<-`
[08:27:50.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.449]                   3L)]
[08:27:50.449]             }
[08:27:50.449]             function(cond) {
[08:27:50.449]                 is_error <- inherits(cond, "error")
[08:27:50.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.449]                   NULL)
[08:27:50.449]                 if (is_error) {
[08:27:50.449]                   sessionInformation <- function() {
[08:27:50.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.449]                       search = base::search(), system = base::Sys.info())
[08:27:50.449]                   }
[08:27:50.449]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.449]                     cond$call), session = sessionInformation(), 
[08:27:50.449]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.449]                   signalCondition(cond)
[08:27:50.449]                 }
[08:27:50.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.449]                 "immediateCondition"))) {
[08:27:50.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.449]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.449]                   if (TRUE && !signal) {
[08:27:50.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.449]                     {
[08:27:50.449]                       inherits <- base::inherits
[08:27:50.449]                       invokeRestart <- base::invokeRestart
[08:27:50.449]                       is.null <- base::is.null
[08:27:50.449]                       muffled <- FALSE
[08:27:50.449]                       if (inherits(cond, "message")) {
[08:27:50.449]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.449]                         if (muffled) 
[08:27:50.449]                           invokeRestart("muffleMessage")
[08:27:50.449]                       }
[08:27:50.449]                       else if (inherits(cond, "warning")) {
[08:27:50.449]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.449]                         if (muffled) 
[08:27:50.449]                           invokeRestart("muffleWarning")
[08:27:50.449]                       }
[08:27:50.449]                       else if (inherits(cond, "condition")) {
[08:27:50.449]                         if (!is.null(pattern)) {
[08:27:50.449]                           computeRestarts <- base::computeRestarts
[08:27:50.449]                           grepl <- base::grepl
[08:27:50.449]                           restarts <- computeRestarts(cond)
[08:27:50.449]                           for (restart in restarts) {
[08:27:50.449]                             name <- restart$name
[08:27:50.449]                             if (is.null(name)) 
[08:27:50.449]                               next
[08:27:50.449]                             if (!grepl(pattern, name)) 
[08:27:50.449]                               next
[08:27:50.449]                             invokeRestart(restart)
[08:27:50.449]                             muffled <- TRUE
[08:27:50.449]                             break
[08:27:50.449]                           }
[08:27:50.449]                         }
[08:27:50.449]                       }
[08:27:50.449]                       invisible(muffled)
[08:27:50.449]                     }
[08:27:50.449]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.449]                   }
[08:27:50.449]                 }
[08:27:50.449]                 else {
[08:27:50.449]                   if (TRUE) {
[08:27:50.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.449]                     {
[08:27:50.449]                       inherits <- base::inherits
[08:27:50.449]                       invokeRestart <- base::invokeRestart
[08:27:50.449]                       is.null <- base::is.null
[08:27:50.449]                       muffled <- FALSE
[08:27:50.449]                       if (inherits(cond, "message")) {
[08:27:50.449]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.449]                         if (muffled) 
[08:27:50.449]                           invokeRestart("muffleMessage")
[08:27:50.449]                       }
[08:27:50.449]                       else if (inherits(cond, "warning")) {
[08:27:50.449]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.449]                         if (muffled) 
[08:27:50.449]                           invokeRestart("muffleWarning")
[08:27:50.449]                       }
[08:27:50.449]                       else if (inherits(cond, "condition")) {
[08:27:50.449]                         if (!is.null(pattern)) {
[08:27:50.449]                           computeRestarts <- base::computeRestarts
[08:27:50.449]                           grepl <- base::grepl
[08:27:50.449]                           restarts <- computeRestarts(cond)
[08:27:50.449]                           for (restart in restarts) {
[08:27:50.449]                             name <- restart$name
[08:27:50.449]                             if (is.null(name)) 
[08:27:50.449]                               next
[08:27:50.449]                             if (!grepl(pattern, name)) 
[08:27:50.449]                               next
[08:27:50.449]                             invokeRestart(restart)
[08:27:50.449]                             muffled <- TRUE
[08:27:50.449]                             break
[08:27:50.449]                           }
[08:27:50.449]                         }
[08:27:50.449]                       }
[08:27:50.449]                       invisible(muffled)
[08:27:50.449]                     }
[08:27:50.449]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.449]                   }
[08:27:50.449]                 }
[08:27:50.449]             }
[08:27:50.449]         }))
[08:27:50.449]     }, error = function(ex) {
[08:27:50.449]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.449]                 ...future.rng), started = ...future.startTime, 
[08:27:50.449]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.449]             version = "1.8"), class = "FutureResult")
[08:27:50.449]     }, finally = {
[08:27:50.449]         if (!identical(...future.workdir, getwd())) 
[08:27:50.449]             setwd(...future.workdir)
[08:27:50.449]         {
[08:27:50.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.449]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.449]             }
[08:27:50.449]             base::options(...future.oldOptions)
[08:27:50.449]             if (.Platform$OS.type == "windows") {
[08:27:50.449]                 old_names <- names(...future.oldEnvVars)
[08:27:50.449]                 envs <- base::Sys.getenv()
[08:27:50.449]                 names <- names(envs)
[08:27:50.449]                 common <- intersect(names, old_names)
[08:27:50.449]                 added <- setdiff(names, old_names)
[08:27:50.449]                 removed <- setdiff(old_names, names)
[08:27:50.449]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.449]                   envs[common]]
[08:27:50.449]                 NAMES <- toupper(changed)
[08:27:50.449]                 args <- list()
[08:27:50.449]                 for (kk in seq_along(NAMES)) {
[08:27:50.449]                   name <- changed[[kk]]
[08:27:50.449]                   NAME <- NAMES[[kk]]
[08:27:50.449]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.449]                     next
[08:27:50.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.449]                 }
[08:27:50.449]                 NAMES <- toupper(added)
[08:27:50.449]                 for (kk in seq_along(NAMES)) {
[08:27:50.449]                   name <- added[[kk]]
[08:27:50.449]                   NAME <- NAMES[[kk]]
[08:27:50.449]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.449]                     next
[08:27:50.449]                   args[[name]] <- ""
[08:27:50.449]                 }
[08:27:50.449]                 NAMES <- toupper(removed)
[08:27:50.449]                 for (kk in seq_along(NAMES)) {
[08:27:50.449]                   name <- removed[[kk]]
[08:27:50.449]                   NAME <- NAMES[[kk]]
[08:27:50.449]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.449]                     next
[08:27:50.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.449]                 }
[08:27:50.449]                 if (length(args) > 0) 
[08:27:50.449]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.449]             }
[08:27:50.449]             else {
[08:27:50.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.449]             }
[08:27:50.449]             {
[08:27:50.449]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.449]                   0L) {
[08:27:50.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.449]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.449]                   base::options(opts)
[08:27:50.449]                 }
[08:27:50.449]                 {
[08:27:50.449]                   {
[08:27:50.449]                     NULL
[08:27:50.449]                     RNGkind("Mersenne-Twister")
[08:27:50.449]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.449]                       inherits = FALSE)
[08:27:50.449]                   }
[08:27:50.449]                   options(future.plan = NULL)
[08:27:50.449]                   if (is.na(NA_character_)) 
[08:27:50.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.449]                     .init = FALSE)
[08:27:50.449]                 }
[08:27:50.449]             }
[08:27:50.449]         }
[08:27:50.449]     })
[08:27:50.449]     if (TRUE) {
[08:27:50.449]         base::sink(type = "output", split = FALSE)
[08:27:50.449]         if (TRUE) {
[08:27:50.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.449]         }
[08:27:50.449]         else {
[08:27:50.449]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.449]         }
[08:27:50.449]         base::close(...future.stdout)
[08:27:50.449]         ...future.stdout <- NULL
[08:27:50.449]     }
[08:27:50.449]     ...future.result$conditions <- ...future.conditions
[08:27:50.449]     ...future.result$finished <- base::Sys.time()
[08:27:50.449]     ...future.result
[08:27:50.449] }
[08:27:50.451] plan(): Setting new future strategy stack:
[08:27:50.451] List of future strategies:
[08:27:50.451] 1. sequential:
[08:27:50.451]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.451]    - tweaked: FALSE
[08:27:50.451]    - call: NULL
[08:27:50.451] plan(): nbrOfWorkers() = 1
[08:27:50.452] plan(): Setting new future strategy stack:
[08:27:50.452] List of future strategies:
[08:27:50.452] 1. sequential:
[08:27:50.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.452]    - tweaked: FALSE
[08:27:50.452]    - call: plan(strategy)
[08:27:50.452] plan(): nbrOfWorkers() = 1
[08:27:50.453] SequentialFuture started (and completed)
[08:27:50.453] - Launch lazy future ... done
[08:27:50.453] run() for ‘SequentialFuture’ ... done
[08:27:50.453] getGlobalsAndPackages() ...
[08:27:50.453] Searching for globals...
[08:27:50.454] - globals found: [1] ‘{’
[08:27:50.454] Searching for globals ... DONE
[08:27:50.454] Resolving globals: FALSE
[08:27:50.454] 
[08:27:50.454] 
[08:27:50.454] getGlobalsAndPackages() ... DONE
[08:27:50.455] run() for ‘Future’ ...
[08:27:50.455] - state: ‘created’
[08:27:50.455] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.455] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.455] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.455]   - Field: ‘label’
[08:27:50.455]   - Field: ‘local’
[08:27:50.456]   - Field: ‘owner’
[08:27:50.456]   - Field: ‘envir’
[08:27:50.456]   - Field: ‘packages’
[08:27:50.456]   - Field: ‘gc’
[08:27:50.456]   - Field: ‘conditions’
[08:27:50.456]   - Field: ‘expr’
[08:27:50.456]   - Field: ‘uuid’
[08:27:50.456]   - Field: ‘seed’
[08:27:50.456]   - Field: ‘version’
[08:27:50.456]   - Field: ‘result’
[08:27:50.456]   - Field: ‘asynchronous’
[08:27:50.456]   - Field: ‘calls’
[08:27:50.457]   - Field: ‘globals’
[08:27:50.457]   - Field: ‘stdout’
[08:27:50.457]   - Field: ‘earlySignal’
[08:27:50.457]   - Field: ‘lazy’
[08:27:50.457]   - Field: ‘state’
[08:27:50.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.457] - Launch lazy future ...
[08:27:50.457] Packages needed by the future expression (n = 0): <none>
[08:27:50.457] Packages needed by future strategies (n = 0): <none>
[08:27:50.458] {
[08:27:50.458]     {
[08:27:50.458]         {
[08:27:50.458]             ...future.startTime <- base::Sys.time()
[08:27:50.458]             {
[08:27:50.458]                 {
[08:27:50.458]                   {
[08:27:50.458]                     base::local({
[08:27:50.458]                       has_future <- base::requireNamespace("future", 
[08:27:50.458]                         quietly = TRUE)
[08:27:50.458]                       if (has_future) {
[08:27:50.458]                         ns <- base::getNamespace("future")
[08:27:50.458]                         version <- ns[[".package"]][["version"]]
[08:27:50.458]                         if (is.null(version)) 
[08:27:50.458]                           version <- utils::packageVersion("future")
[08:27:50.458]                       }
[08:27:50.458]                       else {
[08:27:50.458]                         version <- NULL
[08:27:50.458]                       }
[08:27:50.458]                       if (!has_future || version < "1.8.0") {
[08:27:50.458]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.458]                           "", base::R.version$version.string), 
[08:27:50.458]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.458]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.458]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.458]                             "release", "version")], collapse = " "), 
[08:27:50.458]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.458]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.458]                           info)
[08:27:50.458]                         info <- base::paste(info, collapse = "; ")
[08:27:50.458]                         if (!has_future) {
[08:27:50.458]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.458]                             info)
[08:27:50.458]                         }
[08:27:50.458]                         else {
[08:27:50.458]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.458]                             info, version)
[08:27:50.458]                         }
[08:27:50.458]                         base::stop(msg)
[08:27:50.458]                       }
[08:27:50.458]                     })
[08:27:50.458]                   }
[08:27:50.458]                   ...future.strategy.old <- future::plan("list")
[08:27:50.458]                   options(future.plan = NULL)
[08:27:50.458]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.458]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.458]                 }
[08:27:50.458]                 ...future.workdir <- getwd()
[08:27:50.458]             }
[08:27:50.458]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.458]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.458]         }
[08:27:50.458]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.458]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.458]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.458]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.458]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.458]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.458]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.458]             base::names(...future.oldOptions))
[08:27:50.458]     }
[08:27:50.458]     if (FALSE) {
[08:27:50.458]     }
[08:27:50.458]     else {
[08:27:50.458]         if (TRUE) {
[08:27:50.458]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.458]                 open = "w")
[08:27:50.458]         }
[08:27:50.458]         else {
[08:27:50.458]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.458]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.458]         }
[08:27:50.458]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.458]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.458]             base::sink(type = "output", split = FALSE)
[08:27:50.458]             base::close(...future.stdout)
[08:27:50.458]         }, add = TRUE)
[08:27:50.458]     }
[08:27:50.458]     ...future.frame <- base::sys.nframe()
[08:27:50.458]     ...future.conditions <- base::list()
[08:27:50.458]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.458]     if (FALSE) {
[08:27:50.458]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.458]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.458]     }
[08:27:50.458]     ...future.result <- base::tryCatch({
[08:27:50.458]         base::withCallingHandlers({
[08:27:50.458]             ...future.value <- base::withVisible(base::local({
[08:27:50.458]                 4
[08:27:50.458]             }))
[08:27:50.458]             future::FutureResult(value = ...future.value$value, 
[08:27:50.458]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.458]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.458]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.458]                     ...future.globalenv.names))
[08:27:50.458]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.458]         }, condition = base::local({
[08:27:50.458]             c <- base::c
[08:27:50.458]             inherits <- base::inherits
[08:27:50.458]             invokeRestart <- base::invokeRestart
[08:27:50.458]             length <- base::length
[08:27:50.458]             list <- base::list
[08:27:50.458]             seq.int <- base::seq.int
[08:27:50.458]             signalCondition <- base::signalCondition
[08:27:50.458]             sys.calls <- base::sys.calls
[08:27:50.458]             `[[` <- base::`[[`
[08:27:50.458]             `+` <- base::`+`
[08:27:50.458]             `<<-` <- base::`<<-`
[08:27:50.458]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.458]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.458]                   3L)]
[08:27:50.458]             }
[08:27:50.458]             function(cond) {
[08:27:50.458]                 is_error <- inherits(cond, "error")
[08:27:50.458]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.458]                   NULL)
[08:27:50.458]                 if (is_error) {
[08:27:50.458]                   sessionInformation <- function() {
[08:27:50.458]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.458]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.458]                       search = base::search(), system = base::Sys.info())
[08:27:50.458]                   }
[08:27:50.458]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.458]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.458]                     cond$call), session = sessionInformation(), 
[08:27:50.458]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.458]                   signalCondition(cond)
[08:27:50.458]                 }
[08:27:50.458]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.458]                 "immediateCondition"))) {
[08:27:50.458]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.458]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.458]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.458]                   if (TRUE && !signal) {
[08:27:50.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.458]                     {
[08:27:50.458]                       inherits <- base::inherits
[08:27:50.458]                       invokeRestart <- base::invokeRestart
[08:27:50.458]                       is.null <- base::is.null
[08:27:50.458]                       muffled <- FALSE
[08:27:50.458]                       if (inherits(cond, "message")) {
[08:27:50.458]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.458]                         if (muffled) 
[08:27:50.458]                           invokeRestart("muffleMessage")
[08:27:50.458]                       }
[08:27:50.458]                       else if (inherits(cond, "warning")) {
[08:27:50.458]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.458]                         if (muffled) 
[08:27:50.458]                           invokeRestart("muffleWarning")
[08:27:50.458]                       }
[08:27:50.458]                       else if (inherits(cond, "condition")) {
[08:27:50.458]                         if (!is.null(pattern)) {
[08:27:50.458]                           computeRestarts <- base::computeRestarts
[08:27:50.458]                           grepl <- base::grepl
[08:27:50.458]                           restarts <- computeRestarts(cond)
[08:27:50.458]                           for (restart in restarts) {
[08:27:50.458]                             name <- restart$name
[08:27:50.458]                             if (is.null(name)) 
[08:27:50.458]                               next
[08:27:50.458]                             if (!grepl(pattern, name)) 
[08:27:50.458]                               next
[08:27:50.458]                             invokeRestart(restart)
[08:27:50.458]                             muffled <- TRUE
[08:27:50.458]                             break
[08:27:50.458]                           }
[08:27:50.458]                         }
[08:27:50.458]                       }
[08:27:50.458]                       invisible(muffled)
[08:27:50.458]                     }
[08:27:50.458]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.458]                   }
[08:27:50.458]                 }
[08:27:50.458]                 else {
[08:27:50.458]                   if (TRUE) {
[08:27:50.458]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.458]                     {
[08:27:50.458]                       inherits <- base::inherits
[08:27:50.458]                       invokeRestart <- base::invokeRestart
[08:27:50.458]                       is.null <- base::is.null
[08:27:50.458]                       muffled <- FALSE
[08:27:50.458]                       if (inherits(cond, "message")) {
[08:27:50.458]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.458]                         if (muffled) 
[08:27:50.458]                           invokeRestart("muffleMessage")
[08:27:50.458]                       }
[08:27:50.458]                       else if (inherits(cond, "warning")) {
[08:27:50.458]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.458]                         if (muffled) 
[08:27:50.458]                           invokeRestart("muffleWarning")
[08:27:50.458]                       }
[08:27:50.458]                       else if (inherits(cond, "condition")) {
[08:27:50.458]                         if (!is.null(pattern)) {
[08:27:50.458]                           computeRestarts <- base::computeRestarts
[08:27:50.458]                           grepl <- base::grepl
[08:27:50.458]                           restarts <- computeRestarts(cond)
[08:27:50.458]                           for (restart in restarts) {
[08:27:50.458]                             name <- restart$name
[08:27:50.458]                             if (is.null(name)) 
[08:27:50.458]                               next
[08:27:50.458]                             if (!grepl(pattern, name)) 
[08:27:50.458]                               next
[08:27:50.458]                             invokeRestart(restart)
[08:27:50.458]                             muffled <- TRUE
[08:27:50.458]                             break
[08:27:50.458]                           }
[08:27:50.458]                         }
[08:27:50.458]                       }
[08:27:50.458]                       invisible(muffled)
[08:27:50.458]                     }
[08:27:50.458]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.458]                   }
[08:27:50.458]                 }
[08:27:50.458]             }
[08:27:50.458]         }))
[08:27:50.458]     }, error = function(ex) {
[08:27:50.458]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.458]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.458]                 ...future.rng), started = ...future.startTime, 
[08:27:50.458]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.458]             version = "1.8"), class = "FutureResult")
[08:27:50.458]     }, finally = {
[08:27:50.458]         if (!identical(...future.workdir, getwd())) 
[08:27:50.458]             setwd(...future.workdir)
[08:27:50.458]         {
[08:27:50.458]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.458]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.458]             }
[08:27:50.458]             base::options(...future.oldOptions)
[08:27:50.458]             if (.Platform$OS.type == "windows") {
[08:27:50.458]                 old_names <- names(...future.oldEnvVars)
[08:27:50.458]                 envs <- base::Sys.getenv()
[08:27:50.458]                 names <- names(envs)
[08:27:50.458]                 common <- intersect(names, old_names)
[08:27:50.458]                 added <- setdiff(names, old_names)
[08:27:50.458]                 removed <- setdiff(old_names, names)
[08:27:50.458]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.458]                   envs[common]]
[08:27:50.458]                 NAMES <- toupper(changed)
[08:27:50.458]                 args <- list()
[08:27:50.458]                 for (kk in seq_along(NAMES)) {
[08:27:50.458]                   name <- changed[[kk]]
[08:27:50.458]                   NAME <- NAMES[[kk]]
[08:27:50.458]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.458]                     next
[08:27:50.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.458]                 }
[08:27:50.458]                 NAMES <- toupper(added)
[08:27:50.458]                 for (kk in seq_along(NAMES)) {
[08:27:50.458]                   name <- added[[kk]]
[08:27:50.458]                   NAME <- NAMES[[kk]]
[08:27:50.458]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.458]                     next
[08:27:50.458]                   args[[name]] <- ""
[08:27:50.458]                 }
[08:27:50.458]                 NAMES <- toupper(removed)
[08:27:50.458]                 for (kk in seq_along(NAMES)) {
[08:27:50.458]                   name <- removed[[kk]]
[08:27:50.458]                   NAME <- NAMES[[kk]]
[08:27:50.458]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.458]                     next
[08:27:50.458]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.458]                 }
[08:27:50.458]                 if (length(args) > 0) 
[08:27:50.458]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.458]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.458]             }
[08:27:50.458]             else {
[08:27:50.458]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.458]             }
[08:27:50.458]             {
[08:27:50.458]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.458]                   0L) {
[08:27:50.458]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.458]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.458]                   base::options(opts)
[08:27:50.458]                 }
[08:27:50.458]                 {
[08:27:50.458]                   {
[08:27:50.458]                     NULL
[08:27:50.458]                     RNGkind("Mersenne-Twister")
[08:27:50.458]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.458]                       inherits = FALSE)
[08:27:50.458]                   }
[08:27:50.458]                   options(future.plan = NULL)
[08:27:50.458]                   if (is.na(NA_character_)) 
[08:27:50.458]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.458]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.458]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.458]                     .init = FALSE)
[08:27:50.458]                 }
[08:27:50.458]             }
[08:27:50.458]         }
[08:27:50.458]     })
[08:27:50.458]     if (TRUE) {
[08:27:50.458]         base::sink(type = "output", split = FALSE)
[08:27:50.458]         if (TRUE) {
[08:27:50.458]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.458]         }
[08:27:50.458]         else {
[08:27:50.458]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.458]         }
[08:27:50.458]         base::close(...future.stdout)
[08:27:50.458]         ...future.stdout <- NULL
[08:27:50.458]     }
[08:27:50.458]     ...future.result$conditions <- ...future.conditions
[08:27:50.458]     ...future.result$finished <- base::Sys.time()
[08:27:50.458]     ...future.result
[08:27:50.458] }
[08:27:50.459] plan(): Setting new future strategy stack:
[08:27:50.460] List of future strategies:
[08:27:50.460] 1. sequential:
[08:27:50.460]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.460]    - tweaked: FALSE
[08:27:50.460]    - call: NULL
[08:27:50.460] plan(): nbrOfWorkers() = 1
[08:27:50.461] plan(): Setting new future strategy stack:
[08:27:50.461] List of future strategies:
[08:27:50.461] 1. sequential:
[08:27:50.461]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.461]    - tweaked: FALSE
[08:27:50.461]    - call: plan(strategy)
[08:27:50.461] plan(): nbrOfWorkers() = 1
[08:27:50.461] SequentialFuture started (and completed)
[08:27:50.462] - Launch lazy future ... done
[08:27:50.462] run() for ‘SequentialFuture’ ... done
<environment: 0x55d85f40a5e0> 
<environment: 0x55d8613e8520> 
[08:27:50.465] resolved() for ‘SequentialFuture’ ...
[08:27:50.465] - state: ‘finished’
[08:27:50.465] - run: TRUE
[08:27:50.465] - result: ‘FutureResult’
[08:27:50.465] resolved() for ‘SequentialFuture’ ... done
[08:27:50.465] resolved() for ‘SequentialFuture’ ...
[08:27:50.465] - state: ‘finished’
[08:27:50.465] - run: TRUE
[08:27:50.465] - result: ‘FutureResult’
[08:27:50.466] resolved() for ‘SequentialFuture’ ... done
[08:27:50.466] resolved() for ‘SequentialFuture’ ...
[08:27:50.466] - state: ‘finished’
[08:27:50.466] - run: TRUE
[08:27:50.466] - result: ‘FutureResult’
[08:27:50.466] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:50.467] resolve() on environment ...
[08:27:50.467]  recursive: 0
[08:27:50.468]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:50.468] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.468] - nx: 4
[08:27:50.468] - relay: TRUE
[08:27:50.468] - stdout: TRUE
[08:27:50.468] - signal: TRUE
[08:27:50.468] - resignal: FALSE
[08:27:50.468] - force: TRUE
[08:27:50.468] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.468] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.469]  - until=2
[08:27:50.469]  - relaying element #2
[08:27:50.469] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.469] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.469] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.469]  length: 3 (resolved future 1)
[08:27:50.469] resolved() for ‘SequentialFuture’ ...
[08:27:50.469] - state: ‘finished’
[08:27:50.469] - run: TRUE
[08:27:50.469] - result: ‘FutureResult’
[08:27:50.469] resolved() for ‘SequentialFuture’ ... done
[08:27:50.470] Future #2
[08:27:50.470] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.470] - nx: 4
[08:27:50.470] - relay: TRUE
[08:27:50.470] - stdout: TRUE
[08:27:50.470] - signal: TRUE
[08:27:50.470] - resignal: FALSE
[08:27:50.470] - force: TRUE
[08:27:50.470] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.470] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.470]  - until=2
[08:27:50.471]  - relaying element #2
[08:27:50.471] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.471] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.471] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.471]  length: 2 (resolved future 2)
[08:27:50.471] resolved() for ‘SequentialFuture’ ...
[08:27:50.471] - state: ‘finished’
[08:27:50.471] - run: TRUE
[08:27:50.471] - result: ‘FutureResult’
[08:27:50.471] resolved() for ‘SequentialFuture’ ... done
[08:27:50.471] Future #3
[08:27:50.472] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.472] - nx: 4
[08:27:50.472] - relay: TRUE
[08:27:50.472] - stdout: TRUE
[08:27:50.472] - signal: TRUE
[08:27:50.472] - resignal: FALSE
[08:27:50.472] - force: TRUE
[08:27:50.472] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.472] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.472]  - until=3
[08:27:50.472]  - relaying element #3
[08:27:50.473] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.473] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.473] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.473]  length: 1 (resolved future 3)
[08:27:50.473] resolved() for ‘SequentialFuture’ ...
[08:27:50.473] - state: ‘finished’
[08:27:50.473] - run: TRUE
[08:27:50.473] - result: ‘FutureResult’
[08:27:50.473] resolved() for ‘SequentialFuture’ ... done
[08:27:50.473] Future #4
[08:27:50.474] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.474] - nx: 4
[08:27:50.474] - relay: TRUE
[08:27:50.474] - stdout: TRUE
[08:27:50.474] - signal: TRUE
[08:27:50.474] - resignal: FALSE
[08:27:50.474] - force: TRUE
[08:27:50.474] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.474] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.474]  - until=4
[08:27:50.474]  - relaying element #4
[08:27:50.474] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.475] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.475] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.475]  length: 0 (resolved future 4)
[08:27:50.475] Relaying remaining futures
[08:27:50.475] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.475] - nx: 4
[08:27:50.475] - relay: TRUE
[08:27:50.475] - stdout: TRUE
[08:27:50.475] - signal: TRUE
[08:27:50.475] - resignal: FALSE
[08:27:50.475] - force: TRUE
[08:27:50.475] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.476] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:50.476] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.476] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.476] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.476] resolve() on environment ... DONE
<environment: 0x55d85f2a6e18> 
Dimensions: c(2, 3, 1)
[08:27:50.476] getGlobalsAndPackages() ...
[08:27:50.477] Searching for globals...
[08:27:50.477] 
[08:27:50.477] Searching for globals ... DONE
[08:27:50.477] - globals: [0] <none>
[08:27:50.477] getGlobalsAndPackages() ... DONE
[08:27:50.477] run() for ‘Future’ ...
[08:27:50.478] - state: ‘created’
[08:27:50.478] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.478] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.478] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.478]   - Field: ‘label’
[08:27:50.478]   - Field: ‘local’
[08:27:50.478]   - Field: ‘owner’
[08:27:50.478]   - Field: ‘envir’
[08:27:50.478]   - Field: ‘packages’
[08:27:50.479]   - Field: ‘gc’
[08:27:50.479]   - Field: ‘conditions’
[08:27:50.479]   - Field: ‘expr’
[08:27:50.479]   - Field: ‘uuid’
[08:27:50.479]   - Field: ‘seed’
[08:27:50.479]   - Field: ‘version’
[08:27:50.479]   - Field: ‘result’
[08:27:50.479]   - Field: ‘asynchronous’
[08:27:50.479]   - Field: ‘calls’
[08:27:50.479]   - Field: ‘globals’
[08:27:50.479]   - Field: ‘stdout’
[08:27:50.479]   - Field: ‘earlySignal’
[08:27:50.480]   - Field: ‘lazy’
[08:27:50.480]   - Field: ‘state’
[08:27:50.480] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.480] - Launch lazy future ...
[08:27:50.480] Packages needed by the future expression (n = 0): <none>
[08:27:50.480] Packages needed by future strategies (n = 0): <none>
[08:27:50.481] {
[08:27:50.481]     {
[08:27:50.481]         {
[08:27:50.481]             ...future.startTime <- base::Sys.time()
[08:27:50.481]             {
[08:27:50.481]                 {
[08:27:50.481]                   {
[08:27:50.481]                     base::local({
[08:27:50.481]                       has_future <- base::requireNamespace("future", 
[08:27:50.481]                         quietly = TRUE)
[08:27:50.481]                       if (has_future) {
[08:27:50.481]                         ns <- base::getNamespace("future")
[08:27:50.481]                         version <- ns[[".package"]][["version"]]
[08:27:50.481]                         if (is.null(version)) 
[08:27:50.481]                           version <- utils::packageVersion("future")
[08:27:50.481]                       }
[08:27:50.481]                       else {
[08:27:50.481]                         version <- NULL
[08:27:50.481]                       }
[08:27:50.481]                       if (!has_future || version < "1.8.0") {
[08:27:50.481]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.481]                           "", base::R.version$version.string), 
[08:27:50.481]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.481]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.481]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.481]                             "release", "version")], collapse = " "), 
[08:27:50.481]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.481]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.481]                           info)
[08:27:50.481]                         info <- base::paste(info, collapse = "; ")
[08:27:50.481]                         if (!has_future) {
[08:27:50.481]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.481]                             info)
[08:27:50.481]                         }
[08:27:50.481]                         else {
[08:27:50.481]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.481]                             info, version)
[08:27:50.481]                         }
[08:27:50.481]                         base::stop(msg)
[08:27:50.481]                       }
[08:27:50.481]                     })
[08:27:50.481]                   }
[08:27:50.481]                   ...future.strategy.old <- future::plan("list")
[08:27:50.481]                   options(future.plan = NULL)
[08:27:50.481]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.481]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.481]                 }
[08:27:50.481]                 ...future.workdir <- getwd()
[08:27:50.481]             }
[08:27:50.481]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.481]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.481]         }
[08:27:50.481]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.481]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.481]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.481]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.481]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.481]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.481]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.481]             base::names(...future.oldOptions))
[08:27:50.481]     }
[08:27:50.481]     if (FALSE) {
[08:27:50.481]     }
[08:27:50.481]     else {
[08:27:50.481]         if (TRUE) {
[08:27:50.481]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.481]                 open = "w")
[08:27:50.481]         }
[08:27:50.481]         else {
[08:27:50.481]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.481]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.481]         }
[08:27:50.481]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.481]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.481]             base::sink(type = "output", split = FALSE)
[08:27:50.481]             base::close(...future.stdout)
[08:27:50.481]         }, add = TRUE)
[08:27:50.481]     }
[08:27:50.481]     ...future.frame <- base::sys.nframe()
[08:27:50.481]     ...future.conditions <- base::list()
[08:27:50.481]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.481]     if (FALSE) {
[08:27:50.481]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.481]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.481]     }
[08:27:50.481]     ...future.result <- base::tryCatch({
[08:27:50.481]         base::withCallingHandlers({
[08:27:50.481]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.481]             future::FutureResult(value = ...future.value$value, 
[08:27:50.481]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.481]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.481]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.481]                     ...future.globalenv.names))
[08:27:50.481]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.481]         }, condition = base::local({
[08:27:50.481]             c <- base::c
[08:27:50.481]             inherits <- base::inherits
[08:27:50.481]             invokeRestart <- base::invokeRestart
[08:27:50.481]             length <- base::length
[08:27:50.481]             list <- base::list
[08:27:50.481]             seq.int <- base::seq.int
[08:27:50.481]             signalCondition <- base::signalCondition
[08:27:50.481]             sys.calls <- base::sys.calls
[08:27:50.481]             `[[` <- base::`[[`
[08:27:50.481]             `+` <- base::`+`
[08:27:50.481]             `<<-` <- base::`<<-`
[08:27:50.481]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.481]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.481]                   3L)]
[08:27:50.481]             }
[08:27:50.481]             function(cond) {
[08:27:50.481]                 is_error <- inherits(cond, "error")
[08:27:50.481]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.481]                   NULL)
[08:27:50.481]                 if (is_error) {
[08:27:50.481]                   sessionInformation <- function() {
[08:27:50.481]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.481]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.481]                       search = base::search(), system = base::Sys.info())
[08:27:50.481]                   }
[08:27:50.481]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.481]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.481]                     cond$call), session = sessionInformation(), 
[08:27:50.481]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.481]                   signalCondition(cond)
[08:27:50.481]                 }
[08:27:50.481]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.481]                 "immediateCondition"))) {
[08:27:50.481]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.481]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.481]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.481]                   if (TRUE && !signal) {
[08:27:50.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.481]                     {
[08:27:50.481]                       inherits <- base::inherits
[08:27:50.481]                       invokeRestart <- base::invokeRestart
[08:27:50.481]                       is.null <- base::is.null
[08:27:50.481]                       muffled <- FALSE
[08:27:50.481]                       if (inherits(cond, "message")) {
[08:27:50.481]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.481]                         if (muffled) 
[08:27:50.481]                           invokeRestart("muffleMessage")
[08:27:50.481]                       }
[08:27:50.481]                       else if (inherits(cond, "warning")) {
[08:27:50.481]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.481]                         if (muffled) 
[08:27:50.481]                           invokeRestart("muffleWarning")
[08:27:50.481]                       }
[08:27:50.481]                       else if (inherits(cond, "condition")) {
[08:27:50.481]                         if (!is.null(pattern)) {
[08:27:50.481]                           computeRestarts <- base::computeRestarts
[08:27:50.481]                           grepl <- base::grepl
[08:27:50.481]                           restarts <- computeRestarts(cond)
[08:27:50.481]                           for (restart in restarts) {
[08:27:50.481]                             name <- restart$name
[08:27:50.481]                             if (is.null(name)) 
[08:27:50.481]                               next
[08:27:50.481]                             if (!grepl(pattern, name)) 
[08:27:50.481]                               next
[08:27:50.481]                             invokeRestart(restart)
[08:27:50.481]                             muffled <- TRUE
[08:27:50.481]                             break
[08:27:50.481]                           }
[08:27:50.481]                         }
[08:27:50.481]                       }
[08:27:50.481]                       invisible(muffled)
[08:27:50.481]                     }
[08:27:50.481]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.481]                   }
[08:27:50.481]                 }
[08:27:50.481]                 else {
[08:27:50.481]                   if (TRUE) {
[08:27:50.481]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.481]                     {
[08:27:50.481]                       inherits <- base::inherits
[08:27:50.481]                       invokeRestart <- base::invokeRestart
[08:27:50.481]                       is.null <- base::is.null
[08:27:50.481]                       muffled <- FALSE
[08:27:50.481]                       if (inherits(cond, "message")) {
[08:27:50.481]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.481]                         if (muffled) 
[08:27:50.481]                           invokeRestart("muffleMessage")
[08:27:50.481]                       }
[08:27:50.481]                       else if (inherits(cond, "warning")) {
[08:27:50.481]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.481]                         if (muffled) 
[08:27:50.481]                           invokeRestart("muffleWarning")
[08:27:50.481]                       }
[08:27:50.481]                       else if (inherits(cond, "condition")) {
[08:27:50.481]                         if (!is.null(pattern)) {
[08:27:50.481]                           computeRestarts <- base::computeRestarts
[08:27:50.481]                           grepl <- base::grepl
[08:27:50.481]                           restarts <- computeRestarts(cond)
[08:27:50.481]                           for (restart in restarts) {
[08:27:50.481]                             name <- restart$name
[08:27:50.481]                             if (is.null(name)) 
[08:27:50.481]                               next
[08:27:50.481]                             if (!grepl(pattern, name)) 
[08:27:50.481]                               next
[08:27:50.481]                             invokeRestart(restart)
[08:27:50.481]                             muffled <- TRUE
[08:27:50.481]                             break
[08:27:50.481]                           }
[08:27:50.481]                         }
[08:27:50.481]                       }
[08:27:50.481]                       invisible(muffled)
[08:27:50.481]                     }
[08:27:50.481]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.481]                   }
[08:27:50.481]                 }
[08:27:50.481]             }
[08:27:50.481]         }))
[08:27:50.481]     }, error = function(ex) {
[08:27:50.481]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.481]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.481]                 ...future.rng), started = ...future.startTime, 
[08:27:50.481]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.481]             version = "1.8"), class = "FutureResult")
[08:27:50.481]     }, finally = {
[08:27:50.481]         if (!identical(...future.workdir, getwd())) 
[08:27:50.481]             setwd(...future.workdir)
[08:27:50.481]         {
[08:27:50.481]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.481]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.481]             }
[08:27:50.481]             base::options(...future.oldOptions)
[08:27:50.481]             if (.Platform$OS.type == "windows") {
[08:27:50.481]                 old_names <- names(...future.oldEnvVars)
[08:27:50.481]                 envs <- base::Sys.getenv()
[08:27:50.481]                 names <- names(envs)
[08:27:50.481]                 common <- intersect(names, old_names)
[08:27:50.481]                 added <- setdiff(names, old_names)
[08:27:50.481]                 removed <- setdiff(old_names, names)
[08:27:50.481]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.481]                   envs[common]]
[08:27:50.481]                 NAMES <- toupper(changed)
[08:27:50.481]                 args <- list()
[08:27:50.481]                 for (kk in seq_along(NAMES)) {
[08:27:50.481]                   name <- changed[[kk]]
[08:27:50.481]                   NAME <- NAMES[[kk]]
[08:27:50.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.481]                     next
[08:27:50.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.481]                 }
[08:27:50.481]                 NAMES <- toupper(added)
[08:27:50.481]                 for (kk in seq_along(NAMES)) {
[08:27:50.481]                   name <- added[[kk]]
[08:27:50.481]                   NAME <- NAMES[[kk]]
[08:27:50.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.481]                     next
[08:27:50.481]                   args[[name]] <- ""
[08:27:50.481]                 }
[08:27:50.481]                 NAMES <- toupper(removed)
[08:27:50.481]                 for (kk in seq_along(NAMES)) {
[08:27:50.481]                   name <- removed[[kk]]
[08:27:50.481]                   NAME <- NAMES[[kk]]
[08:27:50.481]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.481]                     next
[08:27:50.481]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.481]                 }
[08:27:50.481]                 if (length(args) > 0) 
[08:27:50.481]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.481]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.481]             }
[08:27:50.481]             else {
[08:27:50.481]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.481]             }
[08:27:50.481]             {
[08:27:50.481]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.481]                   0L) {
[08:27:50.481]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.481]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.481]                   base::options(opts)
[08:27:50.481]                 }
[08:27:50.481]                 {
[08:27:50.481]                   {
[08:27:50.481]                     NULL
[08:27:50.481]                     RNGkind("Mersenne-Twister")
[08:27:50.481]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.481]                       inherits = FALSE)
[08:27:50.481]                   }
[08:27:50.481]                   options(future.plan = NULL)
[08:27:50.481]                   if (is.na(NA_character_)) 
[08:27:50.481]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.481]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.481]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.481]                     .init = FALSE)
[08:27:50.481]                 }
[08:27:50.481]             }
[08:27:50.481]         }
[08:27:50.481]     })
[08:27:50.481]     if (TRUE) {
[08:27:50.481]         base::sink(type = "output", split = FALSE)
[08:27:50.481]         if (TRUE) {
[08:27:50.481]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.481]         }
[08:27:50.481]         else {
[08:27:50.481]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.481]         }
[08:27:50.481]         base::close(...future.stdout)
[08:27:50.481]         ...future.stdout <- NULL
[08:27:50.481]     }
[08:27:50.481]     ...future.result$conditions <- ...future.conditions
[08:27:50.481]     ...future.result$finished <- base::Sys.time()
[08:27:50.481]     ...future.result
[08:27:50.481] }
[08:27:50.482] plan(): Setting new future strategy stack:
[08:27:50.483] List of future strategies:
[08:27:50.483] 1. sequential:
[08:27:50.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.483]    - tweaked: FALSE
[08:27:50.483]    - call: NULL
[08:27:50.483] plan(): nbrOfWorkers() = 1
[08:27:50.484] plan(): Setting new future strategy stack:
[08:27:50.484] List of future strategies:
[08:27:50.484] 1. sequential:
[08:27:50.484]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.484]    - tweaked: FALSE
[08:27:50.484]    - call: plan(strategy)
[08:27:50.484] plan(): nbrOfWorkers() = 1
[08:27:50.484] SequentialFuture started (and completed)
[08:27:50.485] - Launch lazy future ... done
[08:27:50.485] run() for ‘SequentialFuture’ ... done
[08:27:50.485] getGlobalsAndPackages() ...
[08:27:50.485] Searching for globals...
[08:27:50.485] 
[08:27:50.485] Searching for globals ... DONE
[08:27:50.485] - globals: [0] <none>
[08:27:50.485] getGlobalsAndPackages() ... DONE
[08:27:50.486] run() for ‘Future’ ...
[08:27:50.486] - state: ‘created’
[08:27:50.486] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.486] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.486] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.486]   - Field: ‘label’
[08:27:50.486]   - Field: ‘local’
[08:27:50.486]   - Field: ‘owner’
[08:27:50.487]   - Field: ‘envir’
[08:27:50.487]   - Field: ‘packages’
[08:27:50.487]   - Field: ‘gc’
[08:27:50.487]   - Field: ‘conditions’
[08:27:50.487]   - Field: ‘expr’
[08:27:50.487]   - Field: ‘uuid’
[08:27:50.487]   - Field: ‘seed’
[08:27:50.487]   - Field: ‘version’
[08:27:50.487]   - Field: ‘result’
[08:27:50.487]   - Field: ‘asynchronous’
[08:27:50.487]   - Field: ‘calls’
[08:27:50.487]   - Field: ‘globals’
[08:27:50.488]   - Field: ‘stdout’
[08:27:50.488]   - Field: ‘earlySignal’
[08:27:50.488]   - Field: ‘lazy’
[08:27:50.488]   - Field: ‘state’
[08:27:50.488] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.488] - Launch lazy future ...
[08:27:50.488] Packages needed by the future expression (n = 0): <none>
[08:27:50.488] Packages needed by future strategies (n = 0): <none>
[08:27:50.490] {
[08:27:50.490]     {
[08:27:50.490]         {
[08:27:50.490]             ...future.startTime <- base::Sys.time()
[08:27:50.490]             {
[08:27:50.490]                 {
[08:27:50.490]                   {
[08:27:50.490]                     base::local({
[08:27:50.490]                       has_future <- base::requireNamespace("future", 
[08:27:50.490]                         quietly = TRUE)
[08:27:50.490]                       if (has_future) {
[08:27:50.490]                         ns <- base::getNamespace("future")
[08:27:50.490]                         version <- ns[[".package"]][["version"]]
[08:27:50.490]                         if (is.null(version)) 
[08:27:50.490]                           version <- utils::packageVersion("future")
[08:27:50.490]                       }
[08:27:50.490]                       else {
[08:27:50.490]                         version <- NULL
[08:27:50.490]                       }
[08:27:50.490]                       if (!has_future || version < "1.8.0") {
[08:27:50.490]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.490]                           "", base::R.version$version.string), 
[08:27:50.490]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.490]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.490]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.490]                             "release", "version")], collapse = " "), 
[08:27:50.490]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.490]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.490]                           info)
[08:27:50.490]                         info <- base::paste(info, collapse = "; ")
[08:27:50.490]                         if (!has_future) {
[08:27:50.490]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.490]                             info)
[08:27:50.490]                         }
[08:27:50.490]                         else {
[08:27:50.490]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.490]                             info, version)
[08:27:50.490]                         }
[08:27:50.490]                         base::stop(msg)
[08:27:50.490]                       }
[08:27:50.490]                     })
[08:27:50.490]                   }
[08:27:50.490]                   ...future.strategy.old <- future::plan("list")
[08:27:50.490]                   options(future.plan = NULL)
[08:27:50.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.490]                 }
[08:27:50.490]                 ...future.workdir <- getwd()
[08:27:50.490]             }
[08:27:50.490]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.490]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.490]         }
[08:27:50.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.490]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.490]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.490]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.490]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.490]             base::names(...future.oldOptions))
[08:27:50.490]     }
[08:27:50.490]     if (FALSE) {
[08:27:50.490]     }
[08:27:50.490]     else {
[08:27:50.490]         if (TRUE) {
[08:27:50.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.490]                 open = "w")
[08:27:50.490]         }
[08:27:50.490]         else {
[08:27:50.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.490]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.490]         }
[08:27:50.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.490]             base::sink(type = "output", split = FALSE)
[08:27:50.490]             base::close(...future.stdout)
[08:27:50.490]         }, add = TRUE)
[08:27:50.490]     }
[08:27:50.490]     ...future.frame <- base::sys.nframe()
[08:27:50.490]     ...future.conditions <- base::list()
[08:27:50.490]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.490]     if (FALSE) {
[08:27:50.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.490]     }
[08:27:50.490]     ...future.result <- base::tryCatch({
[08:27:50.490]         base::withCallingHandlers({
[08:27:50.490]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.490]             future::FutureResult(value = ...future.value$value, 
[08:27:50.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.490]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.490]                     ...future.globalenv.names))
[08:27:50.490]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.490]         }, condition = base::local({
[08:27:50.490]             c <- base::c
[08:27:50.490]             inherits <- base::inherits
[08:27:50.490]             invokeRestart <- base::invokeRestart
[08:27:50.490]             length <- base::length
[08:27:50.490]             list <- base::list
[08:27:50.490]             seq.int <- base::seq.int
[08:27:50.490]             signalCondition <- base::signalCondition
[08:27:50.490]             sys.calls <- base::sys.calls
[08:27:50.490]             `[[` <- base::`[[`
[08:27:50.490]             `+` <- base::`+`
[08:27:50.490]             `<<-` <- base::`<<-`
[08:27:50.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.490]                   3L)]
[08:27:50.490]             }
[08:27:50.490]             function(cond) {
[08:27:50.490]                 is_error <- inherits(cond, "error")
[08:27:50.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.490]                   NULL)
[08:27:50.490]                 if (is_error) {
[08:27:50.490]                   sessionInformation <- function() {
[08:27:50.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.490]                       search = base::search(), system = base::Sys.info())
[08:27:50.490]                   }
[08:27:50.490]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.490]                     cond$call), session = sessionInformation(), 
[08:27:50.490]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.490]                   signalCondition(cond)
[08:27:50.490]                 }
[08:27:50.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.490]                 "immediateCondition"))) {
[08:27:50.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.490]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.490]                   if (TRUE && !signal) {
[08:27:50.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.490]                     {
[08:27:50.490]                       inherits <- base::inherits
[08:27:50.490]                       invokeRestart <- base::invokeRestart
[08:27:50.490]                       is.null <- base::is.null
[08:27:50.490]                       muffled <- FALSE
[08:27:50.490]                       if (inherits(cond, "message")) {
[08:27:50.490]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.490]                         if (muffled) 
[08:27:50.490]                           invokeRestart("muffleMessage")
[08:27:50.490]                       }
[08:27:50.490]                       else if (inherits(cond, "warning")) {
[08:27:50.490]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.490]                         if (muffled) 
[08:27:50.490]                           invokeRestart("muffleWarning")
[08:27:50.490]                       }
[08:27:50.490]                       else if (inherits(cond, "condition")) {
[08:27:50.490]                         if (!is.null(pattern)) {
[08:27:50.490]                           computeRestarts <- base::computeRestarts
[08:27:50.490]                           grepl <- base::grepl
[08:27:50.490]                           restarts <- computeRestarts(cond)
[08:27:50.490]                           for (restart in restarts) {
[08:27:50.490]                             name <- restart$name
[08:27:50.490]                             if (is.null(name)) 
[08:27:50.490]                               next
[08:27:50.490]                             if (!grepl(pattern, name)) 
[08:27:50.490]                               next
[08:27:50.490]                             invokeRestart(restart)
[08:27:50.490]                             muffled <- TRUE
[08:27:50.490]                             break
[08:27:50.490]                           }
[08:27:50.490]                         }
[08:27:50.490]                       }
[08:27:50.490]                       invisible(muffled)
[08:27:50.490]                     }
[08:27:50.490]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.490]                   }
[08:27:50.490]                 }
[08:27:50.490]                 else {
[08:27:50.490]                   if (TRUE) {
[08:27:50.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.490]                     {
[08:27:50.490]                       inherits <- base::inherits
[08:27:50.490]                       invokeRestart <- base::invokeRestart
[08:27:50.490]                       is.null <- base::is.null
[08:27:50.490]                       muffled <- FALSE
[08:27:50.490]                       if (inherits(cond, "message")) {
[08:27:50.490]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.490]                         if (muffled) 
[08:27:50.490]                           invokeRestart("muffleMessage")
[08:27:50.490]                       }
[08:27:50.490]                       else if (inherits(cond, "warning")) {
[08:27:50.490]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.490]                         if (muffled) 
[08:27:50.490]                           invokeRestart("muffleWarning")
[08:27:50.490]                       }
[08:27:50.490]                       else if (inherits(cond, "condition")) {
[08:27:50.490]                         if (!is.null(pattern)) {
[08:27:50.490]                           computeRestarts <- base::computeRestarts
[08:27:50.490]                           grepl <- base::grepl
[08:27:50.490]                           restarts <- computeRestarts(cond)
[08:27:50.490]                           for (restart in restarts) {
[08:27:50.490]                             name <- restart$name
[08:27:50.490]                             if (is.null(name)) 
[08:27:50.490]                               next
[08:27:50.490]                             if (!grepl(pattern, name)) 
[08:27:50.490]                               next
[08:27:50.490]                             invokeRestart(restart)
[08:27:50.490]                             muffled <- TRUE
[08:27:50.490]                             break
[08:27:50.490]                           }
[08:27:50.490]                         }
[08:27:50.490]                       }
[08:27:50.490]                       invisible(muffled)
[08:27:50.490]                     }
[08:27:50.490]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.490]                   }
[08:27:50.490]                 }
[08:27:50.490]             }
[08:27:50.490]         }))
[08:27:50.490]     }, error = function(ex) {
[08:27:50.490]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.490]                 ...future.rng), started = ...future.startTime, 
[08:27:50.490]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.490]             version = "1.8"), class = "FutureResult")
[08:27:50.490]     }, finally = {
[08:27:50.490]         if (!identical(...future.workdir, getwd())) 
[08:27:50.490]             setwd(...future.workdir)
[08:27:50.490]         {
[08:27:50.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.490]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.490]             }
[08:27:50.490]             base::options(...future.oldOptions)
[08:27:50.490]             if (.Platform$OS.type == "windows") {
[08:27:50.490]                 old_names <- names(...future.oldEnvVars)
[08:27:50.490]                 envs <- base::Sys.getenv()
[08:27:50.490]                 names <- names(envs)
[08:27:50.490]                 common <- intersect(names, old_names)
[08:27:50.490]                 added <- setdiff(names, old_names)
[08:27:50.490]                 removed <- setdiff(old_names, names)
[08:27:50.490]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.490]                   envs[common]]
[08:27:50.490]                 NAMES <- toupper(changed)
[08:27:50.490]                 args <- list()
[08:27:50.490]                 for (kk in seq_along(NAMES)) {
[08:27:50.490]                   name <- changed[[kk]]
[08:27:50.490]                   NAME <- NAMES[[kk]]
[08:27:50.490]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.490]                     next
[08:27:50.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.490]                 }
[08:27:50.490]                 NAMES <- toupper(added)
[08:27:50.490]                 for (kk in seq_along(NAMES)) {
[08:27:50.490]                   name <- added[[kk]]
[08:27:50.490]                   NAME <- NAMES[[kk]]
[08:27:50.490]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.490]                     next
[08:27:50.490]                   args[[name]] <- ""
[08:27:50.490]                 }
[08:27:50.490]                 NAMES <- toupper(removed)
[08:27:50.490]                 for (kk in seq_along(NAMES)) {
[08:27:50.490]                   name <- removed[[kk]]
[08:27:50.490]                   NAME <- NAMES[[kk]]
[08:27:50.490]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.490]                     next
[08:27:50.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.490]                 }
[08:27:50.490]                 if (length(args) > 0) 
[08:27:50.490]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.490]             }
[08:27:50.490]             else {
[08:27:50.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.490]             }
[08:27:50.490]             {
[08:27:50.490]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.490]                   0L) {
[08:27:50.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.490]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.490]                   base::options(opts)
[08:27:50.490]                 }
[08:27:50.490]                 {
[08:27:50.490]                   {
[08:27:50.490]                     NULL
[08:27:50.490]                     RNGkind("Mersenne-Twister")
[08:27:50.490]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.490]                       inherits = FALSE)
[08:27:50.490]                   }
[08:27:50.490]                   options(future.plan = NULL)
[08:27:50.490]                   if (is.na(NA_character_)) 
[08:27:50.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.490]                     .init = FALSE)
[08:27:50.490]                 }
[08:27:50.490]             }
[08:27:50.490]         }
[08:27:50.490]     })
[08:27:50.490]     if (TRUE) {
[08:27:50.490]         base::sink(type = "output", split = FALSE)
[08:27:50.490]         if (TRUE) {
[08:27:50.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.490]         }
[08:27:50.490]         else {
[08:27:50.490]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.490]         }
[08:27:50.490]         base::close(...future.stdout)
[08:27:50.490]         ...future.stdout <- NULL
[08:27:50.490]     }
[08:27:50.490]     ...future.result$conditions <- ...future.conditions
[08:27:50.490]     ...future.result$finished <- base::Sys.time()
[08:27:50.490]     ...future.result
[08:27:50.490] }
[08:27:50.492] plan(): Setting new future strategy stack:
[08:27:50.492] List of future strategies:
[08:27:50.492] 1. sequential:
[08:27:50.492]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.492]    - tweaked: FALSE
[08:27:50.492]    - call: NULL
[08:27:50.493] plan(): nbrOfWorkers() = 1
[08:27:50.494] plan(): Setting new future strategy stack:
[08:27:50.494] List of future strategies:
[08:27:50.494] 1. sequential:
[08:27:50.494]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.494]    - tweaked: FALSE
[08:27:50.494]    - call: plan(strategy)
[08:27:50.494] plan(): nbrOfWorkers() = 1
[08:27:50.494] SequentialFuture started (and completed)
[08:27:50.494] - Launch lazy future ... done
[08:27:50.494] run() for ‘SequentialFuture’ ... done
[08:27:50.495] getGlobalsAndPackages() ...
[08:27:50.495] Searching for globals...
[08:27:50.495] - globals found: [1] ‘{’
[08:27:50.496] Searching for globals ... DONE
[08:27:50.496] Resolving globals: FALSE
[08:27:50.496] 
[08:27:50.496] 
[08:27:50.496] getGlobalsAndPackages() ... DONE
[08:27:50.496] run() for ‘Future’ ...
[08:27:50.496] - state: ‘created’
[08:27:50.497] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.497] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.497] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.497]   - Field: ‘label’
[08:27:50.497]   - Field: ‘local’
[08:27:50.497]   - Field: ‘owner’
[08:27:50.497]   - Field: ‘envir’
[08:27:50.497]   - Field: ‘packages’
[08:27:50.497]   - Field: ‘gc’
[08:27:50.498]   - Field: ‘conditions’
[08:27:50.498]   - Field: ‘expr’
[08:27:50.498]   - Field: ‘uuid’
[08:27:50.498]   - Field: ‘seed’
[08:27:50.498]   - Field: ‘version’
[08:27:50.498]   - Field: ‘result’
[08:27:50.498]   - Field: ‘asynchronous’
[08:27:50.498]   - Field: ‘calls’
[08:27:50.498]   - Field: ‘globals’
[08:27:50.498]   - Field: ‘stdout’
[08:27:50.498]   - Field: ‘earlySignal’
[08:27:50.499]   - Field: ‘lazy’
[08:27:50.499]   - Field: ‘state’
[08:27:50.499] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.499] - Launch lazy future ...
[08:27:50.499] Packages needed by the future expression (n = 0): <none>
[08:27:50.499] Packages needed by future strategies (n = 0): <none>
[08:27:50.499] {
[08:27:50.499]     {
[08:27:50.499]         {
[08:27:50.499]             ...future.startTime <- base::Sys.time()
[08:27:50.499]             {
[08:27:50.499]                 {
[08:27:50.499]                   {
[08:27:50.499]                     base::local({
[08:27:50.499]                       has_future <- base::requireNamespace("future", 
[08:27:50.499]                         quietly = TRUE)
[08:27:50.499]                       if (has_future) {
[08:27:50.499]                         ns <- base::getNamespace("future")
[08:27:50.499]                         version <- ns[[".package"]][["version"]]
[08:27:50.499]                         if (is.null(version)) 
[08:27:50.499]                           version <- utils::packageVersion("future")
[08:27:50.499]                       }
[08:27:50.499]                       else {
[08:27:50.499]                         version <- NULL
[08:27:50.499]                       }
[08:27:50.499]                       if (!has_future || version < "1.8.0") {
[08:27:50.499]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.499]                           "", base::R.version$version.string), 
[08:27:50.499]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.499]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.499]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.499]                             "release", "version")], collapse = " "), 
[08:27:50.499]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.499]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.499]                           info)
[08:27:50.499]                         info <- base::paste(info, collapse = "; ")
[08:27:50.499]                         if (!has_future) {
[08:27:50.499]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.499]                             info)
[08:27:50.499]                         }
[08:27:50.499]                         else {
[08:27:50.499]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.499]                             info, version)
[08:27:50.499]                         }
[08:27:50.499]                         base::stop(msg)
[08:27:50.499]                       }
[08:27:50.499]                     })
[08:27:50.499]                   }
[08:27:50.499]                   ...future.strategy.old <- future::plan("list")
[08:27:50.499]                   options(future.plan = NULL)
[08:27:50.499]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.499]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.499]                 }
[08:27:50.499]                 ...future.workdir <- getwd()
[08:27:50.499]             }
[08:27:50.499]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.499]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.499]         }
[08:27:50.499]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.499]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.499]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.499]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.499]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.499]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.499]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.499]             base::names(...future.oldOptions))
[08:27:50.499]     }
[08:27:50.499]     if (FALSE) {
[08:27:50.499]     }
[08:27:50.499]     else {
[08:27:50.499]         if (TRUE) {
[08:27:50.499]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.499]                 open = "w")
[08:27:50.499]         }
[08:27:50.499]         else {
[08:27:50.499]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.499]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.499]         }
[08:27:50.499]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.499]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.499]             base::sink(type = "output", split = FALSE)
[08:27:50.499]             base::close(...future.stdout)
[08:27:50.499]         }, add = TRUE)
[08:27:50.499]     }
[08:27:50.499]     ...future.frame <- base::sys.nframe()
[08:27:50.499]     ...future.conditions <- base::list()
[08:27:50.499]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.499]     if (FALSE) {
[08:27:50.499]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.499]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.499]     }
[08:27:50.499]     ...future.result <- base::tryCatch({
[08:27:50.499]         base::withCallingHandlers({
[08:27:50.499]             ...future.value <- base::withVisible(base::local({
[08:27:50.499]                 4
[08:27:50.499]             }))
[08:27:50.499]             future::FutureResult(value = ...future.value$value, 
[08:27:50.499]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.499]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.499]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.499]                     ...future.globalenv.names))
[08:27:50.499]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.499]         }, condition = base::local({
[08:27:50.499]             c <- base::c
[08:27:50.499]             inherits <- base::inherits
[08:27:50.499]             invokeRestart <- base::invokeRestart
[08:27:50.499]             length <- base::length
[08:27:50.499]             list <- base::list
[08:27:50.499]             seq.int <- base::seq.int
[08:27:50.499]             signalCondition <- base::signalCondition
[08:27:50.499]             sys.calls <- base::sys.calls
[08:27:50.499]             `[[` <- base::`[[`
[08:27:50.499]             `+` <- base::`+`
[08:27:50.499]             `<<-` <- base::`<<-`
[08:27:50.499]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.499]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.499]                   3L)]
[08:27:50.499]             }
[08:27:50.499]             function(cond) {
[08:27:50.499]                 is_error <- inherits(cond, "error")
[08:27:50.499]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.499]                   NULL)
[08:27:50.499]                 if (is_error) {
[08:27:50.499]                   sessionInformation <- function() {
[08:27:50.499]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.499]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.499]                       search = base::search(), system = base::Sys.info())
[08:27:50.499]                   }
[08:27:50.499]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.499]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.499]                     cond$call), session = sessionInformation(), 
[08:27:50.499]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.499]                   signalCondition(cond)
[08:27:50.499]                 }
[08:27:50.499]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.499]                 "immediateCondition"))) {
[08:27:50.499]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.499]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.499]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.499]                   if (TRUE && !signal) {
[08:27:50.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.499]                     {
[08:27:50.499]                       inherits <- base::inherits
[08:27:50.499]                       invokeRestart <- base::invokeRestart
[08:27:50.499]                       is.null <- base::is.null
[08:27:50.499]                       muffled <- FALSE
[08:27:50.499]                       if (inherits(cond, "message")) {
[08:27:50.499]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.499]                         if (muffled) 
[08:27:50.499]                           invokeRestart("muffleMessage")
[08:27:50.499]                       }
[08:27:50.499]                       else if (inherits(cond, "warning")) {
[08:27:50.499]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.499]                         if (muffled) 
[08:27:50.499]                           invokeRestart("muffleWarning")
[08:27:50.499]                       }
[08:27:50.499]                       else if (inherits(cond, "condition")) {
[08:27:50.499]                         if (!is.null(pattern)) {
[08:27:50.499]                           computeRestarts <- base::computeRestarts
[08:27:50.499]                           grepl <- base::grepl
[08:27:50.499]                           restarts <- computeRestarts(cond)
[08:27:50.499]                           for (restart in restarts) {
[08:27:50.499]                             name <- restart$name
[08:27:50.499]                             if (is.null(name)) 
[08:27:50.499]                               next
[08:27:50.499]                             if (!grepl(pattern, name)) 
[08:27:50.499]                               next
[08:27:50.499]                             invokeRestart(restart)
[08:27:50.499]                             muffled <- TRUE
[08:27:50.499]                             break
[08:27:50.499]                           }
[08:27:50.499]                         }
[08:27:50.499]                       }
[08:27:50.499]                       invisible(muffled)
[08:27:50.499]                     }
[08:27:50.499]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.499]                   }
[08:27:50.499]                 }
[08:27:50.499]                 else {
[08:27:50.499]                   if (TRUE) {
[08:27:50.499]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.499]                     {
[08:27:50.499]                       inherits <- base::inherits
[08:27:50.499]                       invokeRestart <- base::invokeRestart
[08:27:50.499]                       is.null <- base::is.null
[08:27:50.499]                       muffled <- FALSE
[08:27:50.499]                       if (inherits(cond, "message")) {
[08:27:50.499]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.499]                         if (muffled) 
[08:27:50.499]                           invokeRestart("muffleMessage")
[08:27:50.499]                       }
[08:27:50.499]                       else if (inherits(cond, "warning")) {
[08:27:50.499]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.499]                         if (muffled) 
[08:27:50.499]                           invokeRestart("muffleWarning")
[08:27:50.499]                       }
[08:27:50.499]                       else if (inherits(cond, "condition")) {
[08:27:50.499]                         if (!is.null(pattern)) {
[08:27:50.499]                           computeRestarts <- base::computeRestarts
[08:27:50.499]                           grepl <- base::grepl
[08:27:50.499]                           restarts <- computeRestarts(cond)
[08:27:50.499]                           for (restart in restarts) {
[08:27:50.499]                             name <- restart$name
[08:27:50.499]                             if (is.null(name)) 
[08:27:50.499]                               next
[08:27:50.499]                             if (!grepl(pattern, name)) 
[08:27:50.499]                               next
[08:27:50.499]                             invokeRestart(restart)
[08:27:50.499]                             muffled <- TRUE
[08:27:50.499]                             break
[08:27:50.499]                           }
[08:27:50.499]                         }
[08:27:50.499]                       }
[08:27:50.499]                       invisible(muffled)
[08:27:50.499]                     }
[08:27:50.499]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.499]                   }
[08:27:50.499]                 }
[08:27:50.499]             }
[08:27:50.499]         }))
[08:27:50.499]     }, error = function(ex) {
[08:27:50.499]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.499]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.499]                 ...future.rng), started = ...future.startTime, 
[08:27:50.499]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.499]             version = "1.8"), class = "FutureResult")
[08:27:50.499]     }, finally = {
[08:27:50.499]         if (!identical(...future.workdir, getwd())) 
[08:27:50.499]             setwd(...future.workdir)
[08:27:50.499]         {
[08:27:50.499]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.499]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.499]             }
[08:27:50.499]             base::options(...future.oldOptions)
[08:27:50.499]             if (.Platform$OS.type == "windows") {
[08:27:50.499]                 old_names <- names(...future.oldEnvVars)
[08:27:50.499]                 envs <- base::Sys.getenv()
[08:27:50.499]                 names <- names(envs)
[08:27:50.499]                 common <- intersect(names, old_names)
[08:27:50.499]                 added <- setdiff(names, old_names)
[08:27:50.499]                 removed <- setdiff(old_names, names)
[08:27:50.499]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.499]                   envs[common]]
[08:27:50.499]                 NAMES <- toupper(changed)
[08:27:50.499]                 args <- list()
[08:27:50.499]                 for (kk in seq_along(NAMES)) {
[08:27:50.499]                   name <- changed[[kk]]
[08:27:50.499]                   NAME <- NAMES[[kk]]
[08:27:50.499]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.499]                     next
[08:27:50.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.499]                 }
[08:27:50.499]                 NAMES <- toupper(added)
[08:27:50.499]                 for (kk in seq_along(NAMES)) {
[08:27:50.499]                   name <- added[[kk]]
[08:27:50.499]                   NAME <- NAMES[[kk]]
[08:27:50.499]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.499]                     next
[08:27:50.499]                   args[[name]] <- ""
[08:27:50.499]                 }
[08:27:50.499]                 NAMES <- toupper(removed)
[08:27:50.499]                 for (kk in seq_along(NAMES)) {
[08:27:50.499]                   name <- removed[[kk]]
[08:27:50.499]                   NAME <- NAMES[[kk]]
[08:27:50.499]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.499]                     next
[08:27:50.499]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.499]                 }
[08:27:50.499]                 if (length(args) > 0) 
[08:27:50.499]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.499]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.499]             }
[08:27:50.499]             else {
[08:27:50.499]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.499]             }
[08:27:50.499]             {
[08:27:50.499]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.499]                   0L) {
[08:27:50.499]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.499]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.499]                   base::options(opts)
[08:27:50.499]                 }
[08:27:50.499]                 {
[08:27:50.499]                   {
[08:27:50.499]                     NULL
[08:27:50.499]                     RNGkind("Mersenne-Twister")
[08:27:50.499]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.499]                       inherits = FALSE)
[08:27:50.499]                   }
[08:27:50.499]                   options(future.plan = NULL)
[08:27:50.499]                   if (is.na(NA_character_)) 
[08:27:50.499]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.499]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.499]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.499]                     .init = FALSE)
[08:27:50.499]                 }
[08:27:50.499]             }
[08:27:50.499]         }
[08:27:50.499]     })
[08:27:50.499]     if (TRUE) {
[08:27:50.499]         base::sink(type = "output", split = FALSE)
[08:27:50.499]         if (TRUE) {
[08:27:50.499]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.499]         }
[08:27:50.499]         else {
[08:27:50.499]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.499]         }
[08:27:50.499]         base::close(...future.stdout)
[08:27:50.499]         ...future.stdout <- NULL
[08:27:50.499]     }
[08:27:50.499]     ...future.result$conditions <- ...future.conditions
[08:27:50.499]     ...future.result$finished <- base::Sys.time()
[08:27:50.499]     ...future.result
[08:27:50.499] }
[08:27:50.501] plan(): Setting new future strategy stack:
[08:27:50.501] List of future strategies:
[08:27:50.501] 1. sequential:
[08:27:50.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.501]    - tweaked: FALSE
[08:27:50.501]    - call: NULL
[08:27:50.502] plan(): nbrOfWorkers() = 1
[08:27:50.502] plan(): Setting new future strategy stack:
[08:27:50.503] List of future strategies:
[08:27:50.503] 1. sequential:
[08:27:50.503]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.503]    - tweaked: FALSE
[08:27:50.503]    - call: plan(strategy)
[08:27:50.503] plan(): nbrOfWorkers() = 1
[08:27:50.503] SequentialFuture started (and completed)
[08:27:50.503] - Launch lazy future ... done
[08:27:50.503] run() for ‘SequentialFuture’ ... done
<environment: 0x55d860a2dac8> 
<environment: 0x55d8607829b8> 
[08:27:50.505] resolved() for ‘SequentialFuture’ ...
[08:27:50.505] - state: ‘finished’
[08:27:50.505] - run: TRUE
[08:27:50.505] - result: ‘FutureResult’
[08:27:50.505] resolved() for ‘SequentialFuture’ ... done
[08:27:50.505] resolved() for ‘SequentialFuture’ ...
[08:27:50.505] - state: ‘finished’
[08:27:50.505] - run: TRUE
[08:27:50.505] - result: ‘FutureResult’
[08:27:50.505] resolved() for ‘SequentialFuture’ ... done
[08:27:50.506] resolved() for ‘SequentialFuture’ ...
[08:27:50.506] - state: ‘finished’
[08:27:50.506] - run: TRUE
[08:27:50.506] - result: ‘FutureResult’
[08:27:50.506] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:50.507] resolve() on environment ...
[08:27:50.507]  recursive: 0
[08:27:50.508]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:50.508] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.508] - nx: 4
[08:27:50.508] - relay: TRUE
[08:27:50.508] - stdout: TRUE
[08:27:50.508] - signal: TRUE
[08:27:50.508] - resignal: FALSE
[08:27:50.508] - force: TRUE
[08:27:50.508] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.508] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.508]  - until=2
[08:27:50.509]  - relaying element #2
[08:27:50.509] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.509] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.509] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.509]  length: 3 (resolved future 1)
[08:27:50.509] resolved() for ‘SequentialFuture’ ...
[08:27:50.509] - state: ‘finished’
[08:27:50.509] - run: TRUE
[08:27:50.509] - result: ‘FutureResult’
[08:27:50.509] resolved() for ‘SequentialFuture’ ... done
[08:27:50.509] Future #2
[08:27:50.510] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.510] - nx: 4
[08:27:50.510] - relay: TRUE
[08:27:50.510] - stdout: TRUE
[08:27:50.510] - signal: TRUE
[08:27:50.510] - resignal: FALSE
[08:27:50.510] - force: TRUE
[08:27:50.510] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.511] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.511]  - until=2
[08:27:50.511]  - relaying element #2
[08:27:50.511] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.511] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.511] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.511]  length: 2 (resolved future 2)
[08:27:50.512] resolved() for ‘SequentialFuture’ ...
[08:27:50.512] - state: ‘finished’
[08:27:50.512] - run: TRUE
[08:27:50.512] - result: ‘FutureResult’
[08:27:50.512] resolved() for ‘SequentialFuture’ ... done
[08:27:50.512] Future #3
[08:27:50.512] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.512] - nx: 4
[08:27:50.512] - relay: TRUE
[08:27:50.512] - stdout: TRUE
[08:27:50.512] - signal: TRUE
[08:27:50.512] - resignal: FALSE
[08:27:50.513] - force: TRUE
[08:27:50.513] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.513] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.513]  - until=3
[08:27:50.513]  - relaying element #3
[08:27:50.513] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.513] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.513] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.513]  length: 1 (resolved future 3)
[08:27:50.513] resolved() for ‘SequentialFuture’ ...
[08:27:50.514] - state: ‘finished’
[08:27:50.514] - run: TRUE
[08:27:50.514] - result: ‘FutureResult’
[08:27:50.514] resolved() for ‘SequentialFuture’ ... done
[08:27:50.514] Future #4
[08:27:50.514] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.514] - nx: 4
[08:27:50.514] - relay: TRUE
[08:27:50.514] - stdout: TRUE
[08:27:50.514] - signal: TRUE
[08:27:50.514] - resignal: FALSE
[08:27:50.514] - force: TRUE
[08:27:50.515] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.515] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.515]  - until=4
[08:27:50.515]  - relaying element #4
[08:27:50.515] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.515] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.515] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.515]  length: 0 (resolved future 4)
[08:27:50.515] Relaying remaining futures
[08:27:50.515] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.515] - nx: 4
[08:27:50.515] - relay: TRUE
[08:27:50.516] - stdout: TRUE
[08:27:50.516] - signal: TRUE
[08:27:50.516] - resignal: FALSE
[08:27:50.516] - force: TRUE
[08:27:50.516] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.516] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:50.516] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.516] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.516] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.516] resolve() on environment ... DONE
<environment: 0x55d860a6e488> 
Dimensions: c(2, 1, 3, 1)
[08:27:50.519] getGlobalsAndPackages() ...
[08:27:50.519] Searching for globals...
[08:27:50.519] 
[08:27:50.519] Searching for globals ... DONE
[08:27:50.519] - globals: [0] <none>
[08:27:50.519] getGlobalsAndPackages() ... DONE
[08:27:50.520] run() for ‘Future’ ...
[08:27:50.520] - state: ‘created’
[08:27:50.520] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.520] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.520]   - Field: ‘label’
[08:27:50.520]   - Field: ‘local’
[08:27:50.521]   - Field: ‘owner’
[08:27:50.521]   - Field: ‘envir’
[08:27:50.521]   - Field: ‘packages’
[08:27:50.521]   - Field: ‘gc’
[08:27:50.521]   - Field: ‘conditions’
[08:27:50.521]   - Field: ‘expr’
[08:27:50.521]   - Field: ‘uuid’
[08:27:50.521]   - Field: ‘seed’
[08:27:50.521]   - Field: ‘version’
[08:27:50.521]   - Field: ‘result’
[08:27:50.521]   - Field: ‘asynchronous’
[08:27:50.521]   - Field: ‘calls’
[08:27:50.522]   - Field: ‘globals’
[08:27:50.522]   - Field: ‘stdout’
[08:27:50.522]   - Field: ‘earlySignal’
[08:27:50.522]   - Field: ‘lazy’
[08:27:50.522]   - Field: ‘state’
[08:27:50.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.522] - Launch lazy future ...
[08:27:50.522] Packages needed by the future expression (n = 0): <none>
[08:27:50.522] Packages needed by future strategies (n = 0): <none>
[08:27:50.523] {
[08:27:50.523]     {
[08:27:50.523]         {
[08:27:50.523]             ...future.startTime <- base::Sys.time()
[08:27:50.523]             {
[08:27:50.523]                 {
[08:27:50.523]                   {
[08:27:50.523]                     base::local({
[08:27:50.523]                       has_future <- base::requireNamespace("future", 
[08:27:50.523]                         quietly = TRUE)
[08:27:50.523]                       if (has_future) {
[08:27:50.523]                         ns <- base::getNamespace("future")
[08:27:50.523]                         version <- ns[[".package"]][["version"]]
[08:27:50.523]                         if (is.null(version)) 
[08:27:50.523]                           version <- utils::packageVersion("future")
[08:27:50.523]                       }
[08:27:50.523]                       else {
[08:27:50.523]                         version <- NULL
[08:27:50.523]                       }
[08:27:50.523]                       if (!has_future || version < "1.8.0") {
[08:27:50.523]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.523]                           "", base::R.version$version.string), 
[08:27:50.523]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.523]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.523]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.523]                             "release", "version")], collapse = " "), 
[08:27:50.523]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.523]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.523]                           info)
[08:27:50.523]                         info <- base::paste(info, collapse = "; ")
[08:27:50.523]                         if (!has_future) {
[08:27:50.523]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.523]                             info)
[08:27:50.523]                         }
[08:27:50.523]                         else {
[08:27:50.523]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.523]                             info, version)
[08:27:50.523]                         }
[08:27:50.523]                         base::stop(msg)
[08:27:50.523]                       }
[08:27:50.523]                     })
[08:27:50.523]                   }
[08:27:50.523]                   ...future.strategy.old <- future::plan("list")
[08:27:50.523]                   options(future.plan = NULL)
[08:27:50.523]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.523]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.523]                 }
[08:27:50.523]                 ...future.workdir <- getwd()
[08:27:50.523]             }
[08:27:50.523]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.523]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.523]         }
[08:27:50.523]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.523]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.523]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.523]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.523]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.523]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.523]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.523]             base::names(...future.oldOptions))
[08:27:50.523]     }
[08:27:50.523]     if (FALSE) {
[08:27:50.523]     }
[08:27:50.523]     else {
[08:27:50.523]         if (TRUE) {
[08:27:50.523]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.523]                 open = "w")
[08:27:50.523]         }
[08:27:50.523]         else {
[08:27:50.523]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.523]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.523]         }
[08:27:50.523]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.523]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.523]             base::sink(type = "output", split = FALSE)
[08:27:50.523]             base::close(...future.stdout)
[08:27:50.523]         }, add = TRUE)
[08:27:50.523]     }
[08:27:50.523]     ...future.frame <- base::sys.nframe()
[08:27:50.523]     ...future.conditions <- base::list()
[08:27:50.523]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.523]     if (FALSE) {
[08:27:50.523]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.523]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.523]     }
[08:27:50.523]     ...future.result <- base::tryCatch({
[08:27:50.523]         base::withCallingHandlers({
[08:27:50.523]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.523]             future::FutureResult(value = ...future.value$value, 
[08:27:50.523]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.523]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.523]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.523]                     ...future.globalenv.names))
[08:27:50.523]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.523]         }, condition = base::local({
[08:27:50.523]             c <- base::c
[08:27:50.523]             inherits <- base::inherits
[08:27:50.523]             invokeRestart <- base::invokeRestart
[08:27:50.523]             length <- base::length
[08:27:50.523]             list <- base::list
[08:27:50.523]             seq.int <- base::seq.int
[08:27:50.523]             signalCondition <- base::signalCondition
[08:27:50.523]             sys.calls <- base::sys.calls
[08:27:50.523]             `[[` <- base::`[[`
[08:27:50.523]             `+` <- base::`+`
[08:27:50.523]             `<<-` <- base::`<<-`
[08:27:50.523]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.523]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.523]                   3L)]
[08:27:50.523]             }
[08:27:50.523]             function(cond) {
[08:27:50.523]                 is_error <- inherits(cond, "error")
[08:27:50.523]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.523]                   NULL)
[08:27:50.523]                 if (is_error) {
[08:27:50.523]                   sessionInformation <- function() {
[08:27:50.523]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.523]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.523]                       search = base::search(), system = base::Sys.info())
[08:27:50.523]                   }
[08:27:50.523]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.523]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.523]                     cond$call), session = sessionInformation(), 
[08:27:50.523]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.523]                   signalCondition(cond)
[08:27:50.523]                 }
[08:27:50.523]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.523]                 "immediateCondition"))) {
[08:27:50.523]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.523]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.523]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.523]                   if (TRUE && !signal) {
[08:27:50.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.523]                     {
[08:27:50.523]                       inherits <- base::inherits
[08:27:50.523]                       invokeRestart <- base::invokeRestart
[08:27:50.523]                       is.null <- base::is.null
[08:27:50.523]                       muffled <- FALSE
[08:27:50.523]                       if (inherits(cond, "message")) {
[08:27:50.523]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.523]                         if (muffled) 
[08:27:50.523]                           invokeRestart("muffleMessage")
[08:27:50.523]                       }
[08:27:50.523]                       else if (inherits(cond, "warning")) {
[08:27:50.523]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.523]                         if (muffled) 
[08:27:50.523]                           invokeRestart("muffleWarning")
[08:27:50.523]                       }
[08:27:50.523]                       else if (inherits(cond, "condition")) {
[08:27:50.523]                         if (!is.null(pattern)) {
[08:27:50.523]                           computeRestarts <- base::computeRestarts
[08:27:50.523]                           grepl <- base::grepl
[08:27:50.523]                           restarts <- computeRestarts(cond)
[08:27:50.523]                           for (restart in restarts) {
[08:27:50.523]                             name <- restart$name
[08:27:50.523]                             if (is.null(name)) 
[08:27:50.523]                               next
[08:27:50.523]                             if (!grepl(pattern, name)) 
[08:27:50.523]                               next
[08:27:50.523]                             invokeRestart(restart)
[08:27:50.523]                             muffled <- TRUE
[08:27:50.523]                             break
[08:27:50.523]                           }
[08:27:50.523]                         }
[08:27:50.523]                       }
[08:27:50.523]                       invisible(muffled)
[08:27:50.523]                     }
[08:27:50.523]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.523]                   }
[08:27:50.523]                 }
[08:27:50.523]                 else {
[08:27:50.523]                   if (TRUE) {
[08:27:50.523]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.523]                     {
[08:27:50.523]                       inherits <- base::inherits
[08:27:50.523]                       invokeRestart <- base::invokeRestart
[08:27:50.523]                       is.null <- base::is.null
[08:27:50.523]                       muffled <- FALSE
[08:27:50.523]                       if (inherits(cond, "message")) {
[08:27:50.523]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.523]                         if (muffled) 
[08:27:50.523]                           invokeRestart("muffleMessage")
[08:27:50.523]                       }
[08:27:50.523]                       else if (inherits(cond, "warning")) {
[08:27:50.523]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.523]                         if (muffled) 
[08:27:50.523]                           invokeRestart("muffleWarning")
[08:27:50.523]                       }
[08:27:50.523]                       else if (inherits(cond, "condition")) {
[08:27:50.523]                         if (!is.null(pattern)) {
[08:27:50.523]                           computeRestarts <- base::computeRestarts
[08:27:50.523]                           grepl <- base::grepl
[08:27:50.523]                           restarts <- computeRestarts(cond)
[08:27:50.523]                           for (restart in restarts) {
[08:27:50.523]                             name <- restart$name
[08:27:50.523]                             if (is.null(name)) 
[08:27:50.523]                               next
[08:27:50.523]                             if (!grepl(pattern, name)) 
[08:27:50.523]                               next
[08:27:50.523]                             invokeRestart(restart)
[08:27:50.523]                             muffled <- TRUE
[08:27:50.523]                             break
[08:27:50.523]                           }
[08:27:50.523]                         }
[08:27:50.523]                       }
[08:27:50.523]                       invisible(muffled)
[08:27:50.523]                     }
[08:27:50.523]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.523]                   }
[08:27:50.523]                 }
[08:27:50.523]             }
[08:27:50.523]         }))
[08:27:50.523]     }, error = function(ex) {
[08:27:50.523]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.523]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.523]                 ...future.rng), started = ...future.startTime, 
[08:27:50.523]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.523]             version = "1.8"), class = "FutureResult")
[08:27:50.523]     }, finally = {
[08:27:50.523]         if (!identical(...future.workdir, getwd())) 
[08:27:50.523]             setwd(...future.workdir)
[08:27:50.523]         {
[08:27:50.523]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.523]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.523]             }
[08:27:50.523]             base::options(...future.oldOptions)
[08:27:50.523]             if (.Platform$OS.type == "windows") {
[08:27:50.523]                 old_names <- names(...future.oldEnvVars)
[08:27:50.523]                 envs <- base::Sys.getenv()
[08:27:50.523]                 names <- names(envs)
[08:27:50.523]                 common <- intersect(names, old_names)
[08:27:50.523]                 added <- setdiff(names, old_names)
[08:27:50.523]                 removed <- setdiff(old_names, names)
[08:27:50.523]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.523]                   envs[common]]
[08:27:50.523]                 NAMES <- toupper(changed)
[08:27:50.523]                 args <- list()
[08:27:50.523]                 for (kk in seq_along(NAMES)) {
[08:27:50.523]                   name <- changed[[kk]]
[08:27:50.523]                   NAME <- NAMES[[kk]]
[08:27:50.523]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.523]                     next
[08:27:50.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.523]                 }
[08:27:50.523]                 NAMES <- toupper(added)
[08:27:50.523]                 for (kk in seq_along(NAMES)) {
[08:27:50.523]                   name <- added[[kk]]
[08:27:50.523]                   NAME <- NAMES[[kk]]
[08:27:50.523]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.523]                     next
[08:27:50.523]                   args[[name]] <- ""
[08:27:50.523]                 }
[08:27:50.523]                 NAMES <- toupper(removed)
[08:27:50.523]                 for (kk in seq_along(NAMES)) {
[08:27:50.523]                   name <- removed[[kk]]
[08:27:50.523]                   NAME <- NAMES[[kk]]
[08:27:50.523]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.523]                     next
[08:27:50.523]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.523]                 }
[08:27:50.523]                 if (length(args) > 0) 
[08:27:50.523]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.523]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.523]             }
[08:27:50.523]             else {
[08:27:50.523]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.523]             }
[08:27:50.523]             {
[08:27:50.523]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.523]                   0L) {
[08:27:50.523]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.523]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.523]                   base::options(opts)
[08:27:50.523]                 }
[08:27:50.523]                 {
[08:27:50.523]                   {
[08:27:50.523]                     NULL
[08:27:50.523]                     RNGkind("Mersenne-Twister")
[08:27:50.523]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.523]                       inherits = FALSE)
[08:27:50.523]                   }
[08:27:50.523]                   options(future.plan = NULL)
[08:27:50.523]                   if (is.na(NA_character_)) 
[08:27:50.523]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.523]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.523]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.523]                     .init = FALSE)
[08:27:50.523]                 }
[08:27:50.523]             }
[08:27:50.523]         }
[08:27:50.523]     })
[08:27:50.523]     if (TRUE) {
[08:27:50.523]         base::sink(type = "output", split = FALSE)
[08:27:50.523]         if (TRUE) {
[08:27:50.523]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.523]         }
[08:27:50.523]         else {
[08:27:50.523]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.523]         }
[08:27:50.523]         base::close(...future.stdout)
[08:27:50.523]         ...future.stdout <- NULL
[08:27:50.523]     }
[08:27:50.523]     ...future.result$conditions <- ...future.conditions
[08:27:50.523]     ...future.result$finished <- base::Sys.time()
[08:27:50.523]     ...future.result
[08:27:50.523] }
[08:27:50.525] plan(): Setting new future strategy stack:
[08:27:50.525] List of future strategies:
[08:27:50.525] 1. sequential:
[08:27:50.525]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.525]    - tweaked: FALSE
[08:27:50.525]    - call: NULL
[08:27:50.525] plan(): nbrOfWorkers() = 1
[08:27:50.526] plan(): Setting new future strategy stack:
[08:27:50.526] List of future strategies:
[08:27:50.526] 1. sequential:
[08:27:50.526]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.526]    - tweaked: FALSE
[08:27:50.526]    - call: plan(strategy)
[08:27:50.526] plan(): nbrOfWorkers() = 1
[08:27:50.527] SequentialFuture started (and completed)
[08:27:50.527] - Launch lazy future ... done
[08:27:50.527] run() for ‘SequentialFuture’ ... done
[08:27:50.527] getGlobalsAndPackages() ...
[08:27:50.527] Searching for globals...
[08:27:50.527] 
[08:27:50.527] Searching for globals ... DONE
[08:27:50.527] - globals: [0] <none>
[08:27:50.528] getGlobalsAndPackages() ... DONE
[08:27:50.528] run() for ‘Future’ ...
[08:27:50.528] - state: ‘created’
[08:27:50.528] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.528] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.528] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.528]   - Field: ‘label’
[08:27:50.529]   - Field: ‘local’
[08:27:50.529]   - Field: ‘owner’
[08:27:50.529]   - Field: ‘envir’
[08:27:50.529]   - Field: ‘packages’
[08:27:50.529]   - Field: ‘gc’
[08:27:50.529]   - Field: ‘conditions’
[08:27:50.529]   - Field: ‘expr’
[08:27:50.529]   - Field: ‘uuid’
[08:27:50.529]   - Field: ‘seed’
[08:27:50.529]   - Field: ‘version’
[08:27:50.529]   - Field: ‘result’
[08:27:50.529]   - Field: ‘asynchronous’
[08:27:50.530]   - Field: ‘calls’
[08:27:50.530]   - Field: ‘globals’
[08:27:50.530]   - Field: ‘stdout’
[08:27:50.530]   - Field: ‘earlySignal’
[08:27:50.530]   - Field: ‘lazy’
[08:27:50.530]   - Field: ‘state’
[08:27:50.530] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.530] - Launch lazy future ...
[08:27:50.530] Packages needed by the future expression (n = 0): <none>
[08:27:50.530] Packages needed by future strategies (n = 0): <none>
[08:27:50.531] {
[08:27:50.531]     {
[08:27:50.531]         {
[08:27:50.531]             ...future.startTime <- base::Sys.time()
[08:27:50.531]             {
[08:27:50.531]                 {
[08:27:50.531]                   {
[08:27:50.531]                     base::local({
[08:27:50.531]                       has_future <- base::requireNamespace("future", 
[08:27:50.531]                         quietly = TRUE)
[08:27:50.531]                       if (has_future) {
[08:27:50.531]                         ns <- base::getNamespace("future")
[08:27:50.531]                         version <- ns[[".package"]][["version"]]
[08:27:50.531]                         if (is.null(version)) 
[08:27:50.531]                           version <- utils::packageVersion("future")
[08:27:50.531]                       }
[08:27:50.531]                       else {
[08:27:50.531]                         version <- NULL
[08:27:50.531]                       }
[08:27:50.531]                       if (!has_future || version < "1.8.0") {
[08:27:50.531]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.531]                           "", base::R.version$version.string), 
[08:27:50.531]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.531]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.531]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.531]                             "release", "version")], collapse = " "), 
[08:27:50.531]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.531]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.531]                           info)
[08:27:50.531]                         info <- base::paste(info, collapse = "; ")
[08:27:50.531]                         if (!has_future) {
[08:27:50.531]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.531]                             info)
[08:27:50.531]                         }
[08:27:50.531]                         else {
[08:27:50.531]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.531]                             info, version)
[08:27:50.531]                         }
[08:27:50.531]                         base::stop(msg)
[08:27:50.531]                       }
[08:27:50.531]                     })
[08:27:50.531]                   }
[08:27:50.531]                   ...future.strategy.old <- future::plan("list")
[08:27:50.531]                   options(future.plan = NULL)
[08:27:50.531]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.531]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.531]                 }
[08:27:50.531]                 ...future.workdir <- getwd()
[08:27:50.531]             }
[08:27:50.531]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.531]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.531]         }
[08:27:50.531]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.531]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.531]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.531]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.531]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.531]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.531]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.531]             base::names(...future.oldOptions))
[08:27:50.531]     }
[08:27:50.531]     if (FALSE) {
[08:27:50.531]     }
[08:27:50.531]     else {
[08:27:50.531]         if (TRUE) {
[08:27:50.531]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.531]                 open = "w")
[08:27:50.531]         }
[08:27:50.531]         else {
[08:27:50.531]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.531]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.531]         }
[08:27:50.531]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.531]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.531]             base::sink(type = "output", split = FALSE)
[08:27:50.531]             base::close(...future.stdout)
[08:27:50.531]         }, add = TRUE)
[08:27:50.531]     }
[08:27:50.531]     ...future.frame <- base::sys.nframe()
[08:27:50.531]     ...future.conditions <- base::list()
[08:27:50.531]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.531]     if (FALSE) {
[08:27:50.531]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.531]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.531]     }
[08:27:50.531]     ...future.result <- base::tryCatch({
[08:27:50.531]         base::withCallingHandlers({
[08:27:50.531]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.531]             future::FutureResult(value = ...future.value$value, 
[08:27:50.531]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.531]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.531]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.531]                     ...future.globalenv.names))
[08:27:50.531]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.531]         }, condition = base::local({
[08:27:50.531]             c <- base::c
[08:27:50.531]             inherits <- base::inherits
[08:27:50.531]             invokeRestart <- base::invokeRestart
[08:27:50.531]             length <- base::length
[08:27:50.531]             list <- base::list
[08:27:50.531]             seq.int <- base::seq.int
[08:27:50.531]             signalCondition <- base::signalCondition
[08:27:50.531]             sys.calls <- base::sys.calls
[08:27:50.531]             `[[` <- base::`[[`
[08:27:50.531]             `+` <- base::`+`
[08:27:50.531]             `<<-` <- base::`<<-`
[08:27:50.531]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.531]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.531]                   3L)]
[08:27:50.531]             }
[08:27:50.531]             function(cond) {
[08:27:50.531]                 is_error <- inherits(cond, "error")
[08:27:50.531]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.531]                   NULL)
[08:27:50.531]                 if (is_error) {
[08:27:50.531]                   sessionInformation <- function() {
[08:27:50.531]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.531]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.531]                       search = base::search(), system = base::Sys.info())
[08:27:50.531]                   }
[08:27:50.531]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.531]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.531]                     cond$call), session = sessionInformation(), 
[08:27:50.531]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.531]                   signalCondition(cond)
[08:27:50.531]                 }
[08:27:50.531]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.531]                 "immediateCondition"))) {
[08:27:50.531]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.531]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.531]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.531]                   if (TRUE && !signal) {
[08:27:50.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.531]                     {
[08:27:50.531]                       inherits <- base::inherits
[08:27:50.531]                       invokeRestart <- base::invokeRestart
[08:27:50.531]                       is.null <- base::is.null
[08:27:50.531]                       muffled <- FALSE
[08:27:50.531]                       if (inherits(cond, "message")) {
[08:27:50.531]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.531]                         if (muffled) 
[08:27:50.531]                           invokeRestart("muffleMessage")
[08:27:50.531]                       }
[08:27:50.531]                       else if (inherits(cond, "warning")) {
[08:27:50.531]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.531]                         if (muffled) 
[08:27:50.531]                           invokeRestart("muffleWarning")
[08:27:50.531]                       }
[08:27:50.531]                       else if (inherits(cond, "condition")) {
[08:27:50.531]                         if (!is.null(pattern)) {
[08:27:50.531]                           computeRestarts <- base::computeRestarts
[08:27:50.531]                           grepl <- base::grepl
[08:27:50.531]                           restarts <- computeRestarts(cond)
[08:27:50.531]                           for (restart in restarts) {
[08:27:50.531]                             name <- restart$name
[08:27:50.531]                             if (is.null(name)) 
[08:27:50.531]                               next
[08:27:50.531]                             if (!grepl(pattern, name)) 
[08:27:50.531]                               next
[08:27:50.531]                             invokeRestart(restart)
[08:27:50.531]                             muffled <- TRUE
[08:27:50.531]                             break
[08:27:50.531]                           }
[08:27:50.531]                         }
[08:27:50.531]                       }
[08:27:50.531]                       invisible(muffled)
[08:27:50.531]                     }
[08:27:50.531]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.531]                   }
[08:27:50.531]                 }
[08:27:50.531]                 else {
[08:27:50.531]                   if (TRUE) {
[08:27:50.531]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.531]                     {
[08:27:50.531]                       inherits <- base::inherits
[08:27:50.531]                       invokeRestart <- base::invokeRestart
[08:27:50.531]                       is.null <- base::is.null
[08:27:50.531]                       muffled <- FALSE
[08:27:50.531]                       if (inherits(cond, "message")) {
[08:27:50.531]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.531]                         if (muffled) 
[08:27:50.531]                           invokeRestart("muffleMessage")
[08:27:50.531]                       }
[08:27:50.531]                       else if (inherits(cond, "warning")) {
[08:27:50.531]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.531]                         if (muffled) 
[08:27:50.531]                           invokeRestart("muffleWarning")
[08:27:50.531]                       }
[08:27:50.531]                       else if (inherits(cond, "condition")) {
[08:27:50.531]                         if (!is.null(pattern)) {
[08:27:50.531]                           computeRestarts <- base::computeRestarts
[08:27:50.531]                           grepl <- base::grepl
[08:27:50.531]                           restarts <- computeRestarts(cond)
[08:27:50.531]                           for (restart in restarts) {
[08:27:50.531]                             name <- restart$name
[08:27:50.531]                             if (is.null(name)) 
[08:27:50.531]                               next
[08:27:50.531]                             if (!grepl(pattern, name)) 
[08:27:50.531]                               next
[08:27:50.531]                             invokeRestart(restart)
[08:27:50.531]                             muffled <- TRUE
[08:27:50.531]                             break
[08:27:50.531]                           }
[08:27:50.531]                         }
[08:27:50.531]                       }
[08:27:50.531]                       invisible(muffled)
[08:27:50.531]                     }
[08:27:50.531]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.531]                   }
[08:27:50.531]                 }
[08:27:50.531]             }
[08:27:50.531]         }))
[08:27:50.531]     }, error = function(ex) {
[08:27:50.531]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.531]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.531]                 ...future.rng), started = ...future.startTime, 
[08:27:50.531]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.531]             version = "1.8"), class = "FutureResult")
[08:27:50.531]     }, finally = {
[08:27:50.531]         if (!identical(...future.workdir, getwd())) 
[08:27:50.531]             setwd(...future.workdir)
[08:27:50.531]         {
[08:27:50.531]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.531]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.531]             }
[08:27:50.531]             base::options(...future.oldOptions)
[08:27:50.531]             if (.Platform$OS.type == "windows") {
[08:27:50.531]                 old_names <- names(...future.oldEnvVars)
[08:27:50.531]                 envs <- base::Sys.getenv()
[08:27:50.531]                 names <- names(envs)
[08:27:50.531]                 common <- intersect(names, old_names)
[08:27:50.531]                 added <- setdiff(names, old_names)
[08:27:50.531]                 removed <- setdiff(old_names, names)
[08:27:50.531]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.531]                   envs[common]]
[08:27:50.531]                 NAMES <- toupper(changed)
[08:27:50.531]                 args <- list()
[08:27:50.531]                 for (kk in seq_along(NAMES)) {
[08:27:50.531]                   name <- changed[[kk]]
[08:27:50.531]                   NAME <- NAMES[[kk]]
[08:27:50.531]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.531]                     next
[08:27:50.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.531]                 }
[08:27:50.531]                 NAMES <- toupper(added)
[08:27:50.531]                 for (kk in seq_along(NAMES)) {
[08:27:50.531]                   name <- added[[kk]]
[08:27:50.531]                   NAME <- NAMES[[kk]]
[08:27:50.531]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.531]                     next
[08:27:50.531]                   args[[name]] <- ""
[08:27:50.531]                 }
[08:27:50.531]                 NAMES <- toupper(removed)
[08:27:50.531]                 for (kk in seq_along(NAMES)) {
[08:27:50.531]                   name <- removed[[kk]]
[08:27:50.531]                   NAME <- NAMES[[kk]]
[08:27:50.531]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.531]                     next
[08:27:50.531]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.531]                 }
[08:27:50.531]                 if (length(args) > 0) 
[08:27:50.531]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.531]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.531]             }
[08:27:50.531]             else {
[08:27:50.531]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.531]             }
[08:27:50.531]             {
[08:27:50.531]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.531]                   0L) {
[08:27:50.531]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.531]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.531]                   base::options(opts)
[08:27:50.531]                 }
[08:27:50.531]                 {
[08:27:50.531]                   {
[08:27:50.531]                     NULL
[08:27:50.531]                     RNGkind("Mersenne-Twister")
[08:27:50.531]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.531]                       inherits = FALSE)
[08:27:50.531]                   }
[08:27:50.531]                   options(future.plan = NULL)
[08:27:50.531]                   if (is.na(NA_character_)) 
[08:27:50.531]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.531]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.531]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.531]                     .init = FALSE)
[08:27:50.531]                 }
[08:27:50.531]             }
[08:27:50.531]         }
[08:27:50.531]     })
[08:27:50.531]     if (TRUE) {
[08:27:50.531]         base::sink(type = "output", split = FALSE)
[08:27:50.531]         if (TRUE) {
[08:27:50.531]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.531]         }
[08:27:50.531]         else {
[08:27:50.531]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.531]         }
[08:27:50.531]         base::close(...future.stdout)
[08:27:50.531]         ...future.stdout <- NULL
[08:27:50.531]     }
[08:27:50.531]     ...future.result$conditions <- ...future.conditions
[08:27:50.531]     ...future.result$finished <- base::Sys.time()
[08:27:50.531]     ...future.result
[08:27:50.531] }
[08:27:50.533] plan(): Setting new future strategy stack:
[08:27:50.533] List of future strategies:
[08:27:50.533] 1. sequential:
[08:27:50.533]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.533]    - tweaked: FALSE
[08:27:50.533]    - call: NULL
[08:27:50.533] plan(): nbrOfWorkers() = 1
[08:27:50.534] plan(): Setting new future strategy stack:
[08:27:50.534] List of future strategies:
[08:27:50.534] 1. sequential:
[08:27:50.534]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.534]    - tweaked: FALSE
[08:27:50.534]    - call: plan(strategy)
[08:27:50.534] plan(): nbrOfWorkers() = 1
[08:27:50.534] SequentialFuture started (and completed)
[08:27:50.535] - Launch lazy future ... done
[08:27:50.535] run() for ‘SequentialFuture’ ... done
[08:27:50.535] getGlobalsAndPackages() ...
[08:27:50.535] Searching for globals...
[08:27:50.536] - globals found: [1] ‘{’
[08:27:50.536] Searching for globals ... DONE
[08:27:50.536] Resolving globals: FALSE
[08:27:50.536] 
[08:27:50.536] 
[08:27:50.536] getGlobalsAndPackages() ... DONE
[08:27:50.537] run() for ‘Future’ ...
[08:27:50.537] - state: ‘created’
[08:27:50.537] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.537] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.537] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.537]   - Field: ‘label’
[08:27:50.537]   - Field: ‘local’
[08:27:50.537]   - Field: ‘owner’
[08:27:50.537]   - Field: ‘envir’
[08:27:50.538]   - Field: ‘packages’
[08:27:50.538]   - Field: ‘gc’
[08:27:50.538]   - Field: ‘conditions’
[08:27:50.538]   - Field: ‘expr’
[08:27:50.538]   - Field: ‘uuid’
[08:27:50.538]   - Field: ‘seed’
[08:27:50.538]   - Field: ‘version’
[08:27:50.538]   - Field: ‘result’
[08:27:50.538]   - Field: ‘asynchronous’
[08:27:50.538]   - Field: ‘calls’
[08:27:50.538]   - Field: ‘globals’
[08:27:50.538]   - Field: ‘stdout’
[08:27:50.539]   - Field: ‘earlySignal’
[08:27:50.539]   - Field: ‘lazy’
[08:27:50.539]   - Field: ‘state’
[08:27:50.539] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.539] - Launch lazy future ...
[08:27:50.539] Packages needed by the future expression (n = 0): <none>
[08:27:50.539] Packages needed by future strategies (n = 0): <none>
[08:27:50.540] {
[08:27:50.540]     {
[08:27:50.540]         {
[08:27:50.540]             ...future.startTime <- base::Sys.time()
[08:27:50.540]             {
[08:27:50.540]                 {
[08:27:50.540]                   {
[08:27:50.540]                     base::local({
[08:27:50.540]                       has_future <- base::requireNamespace("future", 
[08:27:50.540]                         quietly = TRUE)
[08:27:50.540]                       if (has_future) {
[08:27:50.540]                         ns <- base::getNamespace("future")
[08:27:50.540]                         version <- ns[[".package"]][["version"]]
[08:27:50.540]                         if (is.null(version)) 
[08:27:50.540]                           version <- utils::packageVersion("future")
[08:27:50.540]                       }
[08:27:50.540]                       else {
[08:27:50.540]                         version <- NULL
[08:27:50.540]                       }
[08:27:50.540]                       if (!has_future || version < "1.8.0") {
[08:27:50.540]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.540]                           "", base::R.version$version.string), 
[08:27:50.540]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.540]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.540]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.540]                             "release", "version")], collapse = " "), 
[08:27:50.540]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.540]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.540]                           info)
[08:27:50.540]                         info <- base::paste(info, collapse = "; ")
[08:27:50.540]                         if (!has_future) {
[08:27:50.540]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.540]                             info)
[08:27:50.540]                         }
[08:27:50.540]                         else {
[08:27:50.540]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.540]                             info, version)
[08:27:50.540]                         }
[08:27:50.540]                         base::stop(msg)
[08:27:50.540]                       }
[08:27:50.540]                     })
[08:27:50.540]                   }
[08:27:50.540]                   ...future.strategy.old <- future::plan("list")
[08:27:50.540]                   options(future.plan = NULL)
[08:27:50.540]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.540]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.540]                 }
[08:27:50.540]                 ...future.workdir <- getwd()
[08:27:50.540]             }
[08:27:50.540]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.540]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.540]         }
[08:27:50.540]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.540]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.540]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.540]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.540]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.540]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.540]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.540]             base::names(...future.oldOptions))
[08:27:50.540]     }
[08:27:50.540]     if (FALSE) {
[08:27:50.540]     }
[08:27:50.540]     else {
[08:27:50.540]         if (TRUE) {
[08:27:50.540]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.540]                 open = "w")
[08:27:50.540]         }
[08:27:50.540]         else {
[08:27:50.540]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.540]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.540]         }
[08:27:50.540]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.540]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.540]             base::sink(type = "output", split = FALSE)
[08:27:50.540]             base::close(...future.stdout)
[08:27:50.540]         }, add = TRUE)
[08:27:50.540]     }
[08:27:50.540]     ...future.frame <- base::sys.nframe()
[08:27:50.540]     ...future.conditions <- base::list()
[08:27:50.540]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.540]     if (FALSE) {
[08:27:50.540]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.540]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.540]     }
[08:27:50.540]     ...future.result <- base::tryCatch({
[08:27:50.540]         base::withCallingHandlers({
[08:27:50.540]             ...future.value <- base::withVisible(base::local({
[08:27:50.540]                 4
[08:27:50.540]             }))
[08:27:50.540]             future::FutureResult(value = ...future.value$value, 
[08:27:50.540]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.540]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.540]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.540]                     ...future.globalenv.names))
[08:27:50.540]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.540]         }, condition = base::local({
[08:27:50.540]             c <- base::c
[08:27:50.540]             inherits <- base::inherits
[08:27:50.540]             invokeRestart <- base::invokeRestart
[08:27:50.540]             length <- base::length
[08:27:50.540]             list <- base::list
[08:27:50.540]             seq.int <- base::seq.int
[08:27:50.540]             signalCondition <- base::signalCondition
[08:27:50.540]             sys.calls <- base::sys.calls
[08:27:50.540]             `[[` <- base::`[[`
[08:27:50.540]             `+` <- base::`+`
[08:27:50.540]             `<<-` <- base::`<<-`
[08:27:50.540]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.540]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.540]                   3L)]
[08:27:50.540]             }
[08:27:50.540]             function(cond) {
[08:27:50.540]                 is_error <- inherits(cond, "error")
[08:27:50.540]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.540]                   NULL)
[08:27:50.540]                 if (is_error) {
[08:27:50.540]                   sessionInformation <- function() {
[08:27:50.540]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.540]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.540]                       search = base::search(), system = base::Sys.info())
[08:27:50.540]                   }
[08:27:50.540]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.540]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.540]                     cond$call), session = sessionInformation(), 
[08:27:50.540]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.540]                   signalCondition(cond)
[08:27:50.540]                 }
[08:27:50.540]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.540]                 "immediateCondition"))) {
[08:27:50.540]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.540]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.540]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.540]                   if (TRUE && !signal) {
[08:27:50.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.540]                     {
[08:27:50.540]                       inherits <- base::inherits
[08:27:50.540]                       invokeRestart <- base::invokeRestart
[08:27:50.540]                       is.null <- base::is.null
[08:27:50.540]                       muffled <- FALSE
[08:27:50.540]                       if (inherits(cond, "message")) {
[08:27:50.540]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.540]                         if (muffled) 
[08:27:50.540]                           invokeRestart("muffleMessage")
[08:27:50.540]                       }
[08:27:50.540]                       else if (inherits(cond, "warning")) {
[08:27:50.540]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.540]                         if (muffled) 
[08:27:50.540]                           invokeRestart("muffleWarning")
[08:27:50.540]                       }
[08:27:50.540]                       else if (inherits(cond, "condition")) {
[08:27:50.540]                         if (!is.null(pattern)) {
[08:27:50.540]                           computeRestarts <- base::computeRestarts
[08:27:50.540]                           grepl <- base::grepl
[08:27:50.540]                           restarts <- computeRestarts(cond)
[08:27:50.540]                           for (restart in restarts) {
[08:27:50.540]                             name <- restart$name
[08:27:50.540]                             if (is.null(name)) 
[08:27:50.540]                               next
[08:27:50.540]                             if (!grepl(pattern, name)) 
[08:27:50.540]                               next
[08:27:50.540]                             invokeRestart(restart)
[08:27:50.540]                             muffled <- TRUE
[08:27:50.540]                             break
[08:27:50.540]                           }
[08:27:50.540]                         }
[08:27:50.540]                       }
[08:27:50.540]                       invisible(muffled)
[08:27:50.540]                     }
[08:27:50.540]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.540]                   }
[08:27:50.540]                 }
[08:27:50.540]                 else {
[08:27:50.540]                   if (TRUE) {
[08:27:50.540]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.540]                     {
[08:27:50.540]                       inherits <- base::inherits
[08:27:50.540]                       invokeRestart <- base::invokeRestart
[08:27:50.540]                       is.null <- base::is.null
[08:27:50.540]                       muffled <- FALSE
[08:27:50.540]                       if (inherits(cond, "message")) {
[08:27:50.540]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.540]                         if (muffled) 
[08:27:50.540]                           invokeRestart("muffleMessage")
[08:27:50.540]                       }
[08:27:50.540]                       else if (inherits(cond, "warning")) {
[08:27:50.540]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.540]                         if (muffled) 
[08:27:50.540]                           invokeRestart("muffleWarning")
[08:27:50.540]                       }
[08:27:50.540]                       else if (inherits(cond, "condition")) {
[08:27:50.540]                         if (!is.null(pattern)) {
[08:27:50.540]                           computeRestarts <- base::computeRestarts
[08:27:50.540]                           grepl <- base::grepl
[08:27:50.540]                           restarts <- computeRestarts(cond)
[08:27:50.540]                           for (restart in restarts) {
[08:27:50.540]                             name <- restart$name
[08:27:50.540]                             if (is.null(name)) 
[08:27:50.540]                               next
[08:27:50.540]                             if (!grepl(pattern, name)) 
[08:27:50.540]                               next
[08:27:50.540]                             invokeRestart(restart)
[08:27:50.540]                             muffled <- TRUE
[08:27:50.540]                             break
[08:27:50.540]                           }
[08:27:50.540]                         }
[08:27:50.540]                       }
[08:27:50.540]                       invisible(muffled)
[08:27:50.540]                     }
[08:27:50.540]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.540]                   }
[08:27:50.540]                 }
[08:27:50.540]             }
[08:27:50.540]         }))
[08:27:50.540]     }, error = function(ex) {
[08:27:50.540]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.540]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.540]                 ...future.rng), started = ...future.startTime, 
[08:27:50.540]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.540]             version = "1.8"), class = "FutureResult")
[08:27:50.540]     }, finally = {
[08:27:50.540]         if (!identical(...future.workdir, getwd())) 
[08:27:50.540]             setwd(...future.workdir)
[08:27:50.540]         {
[08:27:50.540]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.540]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.540]             }
[08:27:50.540]             base::options(...future.oldOptions)
[08:27:50.540]             if (.Platform$OS.type == "windows") {
[08:27:50.540]                 old_names <- names(...future.oldEnvVars)
[08:27:50.540]                 envs <- base::Sys.getenv()
[08:27:50.540]                 names <- names(envs)
[08:27:50.540]                 common <- intersect(names, old_names)
[08:27:50.540]                 added <- setdiff(names, old_names)
[08:27:50.540]                 removed <- setdiff(old_names, names)
[08:27:50.540]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.540]                   envs[common]]
[08:27:50.540]                 NAMES <- toupper(changed)
[08:27:50.540]                 args <- list()
[08:27:50.540]                 for (kk in seq_along(NAMES)) {
[08:27:50.540]                   name <- changed[[kk]]
[08:27:50.540]                   NAME <- NAMES[[kk]]
[08:27:50.540]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.540]                     next
[08:27:50.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.540]                 }
[08:27:50.540]                 NAMES <- toupper(added)
[08:27:50.540]                 for (kk in seq_along(NAMES)) {
[08:27:50.540]                   name <- added[[kk]]
[08:27:50.540]                   NAME <- NAMES[[kk]]
[08:27:50.540]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.540]                     next
[08:27:50.540]                   args[[name]] <- ""
[08:27:50.540]                 }
[08:27:50.540]                 NAMES <- toupper(removed)
[08:27:50.540]                 for (kk in seq_along(NAMES)) {
[08:27:50.540]                   name <- removed[[kk]]
[08:27:50.540]                   NAME <- NAMES[[kk]]
[08:27:50.540]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.540]                     next
[08:27:50.540]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.540]                 }
[08:27:50.540]                 if (length(args) > 0) 
[08:27:50.540]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.540]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.540]             }
[08:27:50.540]             else {
[08:27:50.540]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.540]             }
[08:27:50.540]             {
[08:27:50.540]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.540]                   0L) {
[08:27:50.540]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.540]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.540]                   base::options(opts)
[08:27:50.540]                 }
[08:27:50.540]                 {
[08:27:50.540]                   {
[08:27:50.540]                     NULL
[08:27:50.540]                     RNGkind("Mersenne-Twister")
[08:27:50.540]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.540]                       inherits = FALSE)
[08:27:50.540]                   }
[08:27:50.540]                   options(future.plan = NULL)
[08:27:50.540]                   if (is.na(NA_character_)) 
[08:27:50.540]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.540]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.540]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.540]                     .init = FALSE)
[08:27:50.540]                 }
[08:27:50.540]             }
[08:27:50.540]         }
[08:27:50.540]     })
[08:27:50.540]     if (TRUE) {
[08:27:50.540]         base::sink(type = "output", split = FALSE)
[08:27:50.540]         if (TRUE) {
[08:27:50.540]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.540]         }
[08:27:50.540]         else {
[08:27:50.540]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.540]         }
[08:27:50.540]         base::close(...future.stdout)
[08:27:50.540]         ...future.stdout <- NULL
[08:27:50.540]     }
[08:27:50.540]     ...future.result$conditions <- ...future.conditions
[08:27:50.540]     ...future.result$finished <- base::Sys.time()
[08:27:50.540]     ...future.result
[08:27:50.540] }
[08:27:50.541] plan(): Setting new future strategy stack:
[08:27:50.541] List of future strategies:
[08:27:50.541] 1. sequential:
[08:27:50.541]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.541]    - tweaked: FALSE
[08:27:50.541]    - call: NULL
[08:27:50.542] plan(): nbrOfWorkers() = 1
[08:27:50.543] plan(): Setting new future strategy stack:
[08:27:50.543] List of future strategies:
[08:27:50.543] 1. sequential:
[08:27:50.543]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.543]    - tweaked: FALSE
[08:27:50.543]    - call: plan(strategy)
[08:27:50.543] plan(): nbrOfWorkers() = 1
[08:27:50.543] SequentialFuture started (and completed)
[08:27:50.543] - Launch lazy future ... done
[08:27:50.544] run() for ‘SequentialFuture’ ... done
<environment: 0x55d8600dbd90> 
<environment: 0x55d86107b440> 
[08:27:50.545] resolved() for ‘SequentialFuture’ ...
[08:27:50.545] - state: ‘finished’
[08:27:50.545] - run: TRUE
[08:27:50.545] - result: ‘FutureResult’
[08:27:50.545] resolved() for ‘SequentialFuture’ ... done
[08:27:50.545] resolved() for ‘SequentialFuture’ ...
[08:27:50.545] - state: ‘finished’
[08:27:50.545] - run: TRUE
[08:27:50.546] - result: ‘FutureResult’
[08:27:50.546] resolved() for ‘SequentialFuture’ ... done
[08:27:50.548] resolved() for ‘SequentialFuture’ ...
[08:27:50.548] - state: ‘finished’
[08:27:50.548] - run: TRUE
[08:27:50.548] - result: ‘FutureResult’
[08:27:50.548] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:50.549] resolve() on environment ...
[08:27:50.549]  recursive: 0
[08:27:50.550]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:50.550] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.550] - nx: 4
[08:27:50.550] - relay: TRUE
[08:27:50.550] - stdout: TRUE
[08:27:50.550] - signal: TRUE
[08:27:50.550] - resignal: FALSE
[08:27:50.550] - force: TRUE
[08:27:50.550] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.550] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.551]  - until=2
[08:27:50.551]  - relaying element #2
[08:27:50.551] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.551] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.551] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.551]  length: 3 (resolved future 1)
[08:27:50.551] resolved() for ‘SequentialFuture’ ...
[08:27:50.551] - state: ‘finished’
[08:27:50.551] - run: TRUE
[08:27:50.551] - result: ‘FutureResult’
[08:27:50.551] resolved() for ‘SequentialFuture’ ... done
[08:27:50.552] Future #2
[08:27:50.552] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.552] - nx: 4
[08:27:50.552] - relay: TRUE
[08:27:50.552] - stdout: TRUE
[08:27:50.552] - signal: TRUE
[08:27:50.552] - resignal: FALSE
[08:27:50.552] - force: TRUE
[08:27:50.552] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:50.552] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:50.552]  - until=2
[08:27:50.552]  - relaying element #2
[08:27:50.553] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.553] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.553] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.553]  length: 2 (resolved future 2)
[08:27:50.553] resolved() for ‘SequentialFuture’ ...
[08:27:50.553] - state: ‘finished’
[08:27:50.553] - run: TRUE
[08:27:50.553] - result: ‘FutureResult’
[08:27:50.553] resolved() for ‘SequentialFuture’ ... done
[08:27:50.553] Future #3
[08:27:50.554] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.554] - nx: 4
[08:27:50.554] - relay: TRUE
[08:27:50.554] - stdout: TRUE
[08:27:50.554] - signal: TRUE
[08:27:50.554] - resignal: FALSE
[08:27:50.554] - force: TRUE
[08:27:50.554] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:50.554] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:50.554]  - until=3
[08:27:50.554]  - relaying element #3
[08:27:50.555] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.555] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.555] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.555]  length: 1 (resolved future 3)
[08:27:50.555] resolved() for ‘SequentialFuture’ ...
[08:27:50.555] - state: ‘finished’
[08:27:50.555] - run: TRUE
[08:27:50.555] - result: ‘FutureResult’
[08:27:50.555] resolved() for ‘SequentialFuture’ ... done
[08:27:50.555] Future #4
[08:27:50.555] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.556] - nx: 4
[08:27:50.556] - relay: TRUE
[08:27:50.556] - stdout: TRUE
[08:27:50.556] - signal: TRUE
[08:27:50.556] - resignal: FALSE
[08:27:50.556] - force: TRUE
[08:27:50.556] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:50.556] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:50.556]  - until=4
[08:27:50.556]  - relaying element #4
[08:27:50.556] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.557] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.557] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.557]  length: 0 (resolved future 4)
[08:27:50.557] Relaying remaining futures
[08:27:50.557] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.557] - nx: 4
[08:27:50.557] - relay: TRUE
[08:27:50.557] - stdout: TRUE
[08:27:50.557] - signal: TRUE
[08:27:50.557] - resignal: FALSE
[08:27:50.557] - force: TRUE
[08:27:50.557] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.557] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:50.558] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:50.558] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:50.558] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.558] resolve() on environment ... DONE
<environment: 0x55d85f555e90> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[08:27:50.559] plan(): Setting new future strategy stack:
[08:27:50.559] List of future strategies:
[08:27:50.559] 1. sequential:
[08:27:50.559]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.559]    - tweaked: FALSE
[08:27:50.559]    - call: plan(strategy)
[08:27:50.559] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[08:27:50.560] getGlobalsAndPackages() ...
[08:27:50.560] Searching for globals...
[08:27:50.560] 
[08:27:50.560] Searching for globals ... DONE
[08:27:50.560] - globals: [0] <none>
[08:27:50.560] getGlobalsAndPackages() ... DONE
[08:27:50.560] run() for ‘Future’ ...
[08:27:50.561] - state: ‘created’
[08:27:50.561] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.561] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.561]   - Field: ‘label’
[08:27:50.561]   - Field: ‘local’
[08:27:50.561]   - Field: ‘owner’
[08:27:50.561]   - Field: ‘envir’
[08:27:50.561]   - Field: ‘packages’
[08:27:50.562]   - Field: ‘gc’
[08:27:50.562]   - Field: ‘conditions’
[08:27:50.562]   - Field: ‘expr’
[08:27:50.562]   - Field: ‘uuid’
[08:27:50.562]   - Field: ‘seed’
[08:27:50.562]   - Field: ‘version’
[08:27:50.562]   - Field: ‘result’
[08:27:50.562]   - Field: ‘asynchronous’
[08:27:50.562]   - Field: ‘calls’
[08:27:50.562]   - Field: ‘globals’
[08:27:50.562]   - Field: ‘stdout’
[08:27:50.562]   - Field: ‘earlySignal’
[08:27:50.563]   - Field: ‘lazy’
[08:27:50.563]   - Field: ‘state’
[08:27:50.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.563] - Launch lazy future ...
[08:27:50.563] Packages needed by the future expression (n = 0): <none>
[08:27:50.563] Packages needed by future strategies (n = 0): <none>
[08:27:50.564] {
[08:27:50.564]     {
[08:27:50.564]         {
[08:27:50.564]             ...future.startTime <- base::Sys.time()
[08:27:50.564]             {
[08:27:50.564]                 {
[08:27:50.564]                   {
[08:27:50.564]                     base::local({
[08:27:50.564]                       has_future <- base::requireNamespace("future", 
[08:27:50.564]                         quietly = TRUE)
[08:27:50.564]                       if (has_future) {
[08:27:50.564]                         ns <- base::getNamespace("future")
[08:27:50.564]                         version <- ns[[".package"]][["version"]]
[08:27:50.564]                         if (is.null(version)) 
[08:27:50.564]                           version <- utils::packageVersion("future")
[08:27:50.564]                       }
[08:27:50.564]                       else {
[08:27:50.564]                         version <- NULL
[08:27:50.564]                       }
[08:27:50.564]                       if (!has_future || version < "1.8.0") {
[08:27:50.564]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.564]                           "", base::R.version$version.string), 
[08:27:50.564]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.564]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.564]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.564]                             "release", "version")], collapse = " "), 
[08:27:50.564]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.564]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.564]                           info)
[08:27:50.564]                         info <- base::paste(info, collapse = "; ")
[08:27:50.564]                         if (!has_future) {
[08:27:50.564]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.564]                             info)
[08:27:50.564]                         }
[08:27:50.564]                         else {
[08:27:50.564]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.564]                             info, version)
[08:27:50.564]                         }
[08:27:50.564]                         base::stop(msg)
[08:27:50.564]                       }
[08:27:50.564]                     })
[08:27:50.564]                   }
[08:27:50.564]                   ...future.strategy.old <- future::plan("list")
[08:27:50.564]                   options(future.plan = NULL)
[08:27:50.564]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.564]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.564]                 }
[08:27:50.564]                 ...future.workdir <- getwd()
[08:27:50.564]             }
[08:27:50.564]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.564]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.564]         }
[08:27:50.564]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.564]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.564]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.564]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.564]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.564]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.564]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.564]             base::names(...future.oldOptions))
[08:27:50.564]     }
[08:27:50.564]     if (FALSE) {
[08:27:50.564]     }
[08:27:50.564]     else {
[08:27:50.564]         if (TRUE) {
[08:27:50.564]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.564]                 open = "w")
[08:27:50.564]         }
[08:27:50.564]         else {
[08:27:50.564]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.564]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.564]         }
[08:27:50.564]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.564]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.564]             base::sink(type = "output", split = FALSE)
[08:27:50.564]             base::close(...future.stdout)
[08:27:50.564]         }, add = TRUE)
[08:27:50.564]     }
[08:27:50.564]     ...future.frame <- base::sys.nframe()
[08:27:50.564]     ...future.conditions <- base::list()
[08:27:50.564]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.564]     if (FALSE) {
[08:27:50.564]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.564]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.564]     }
[08:27:50.564]     ...future.result <- base::tryCatch({
[08:27:50.564]         base::withCallingHandlers({
[08:27:50.564]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.564]             future::FutureResult(value = ...future.value$value, 
[08:27:50.564]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.564]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.564]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.564]                     ...future.globalenv.names))
[08:27:50.564]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.564]         }, condition = base::local({
[08:27:50.564]             c <- base::c
[08:27:50.564]             inherits <- base::inherits
[08:27:50.564]             invokeRestart <- base::invokeRestart
[08:27:50.564]             length <- base::length
[08:27:50.564]             list <- base::list
[08:27:50.564]             seq.int <- base::seq.int
[08:27:50.564]             signalCondition <- base::signalCondition
[08:27:50.564]             sys.calls <- base::sys.calls
[08:27:50.564]             `[[` <- base::`[[`
[08:27:50.564]             `+` <- base::`+`
[08:27:50.564]             `<<-` <- base::`<<-`
[08:27:50.564]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.564]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.564]                   3L)]
[08:27:50.564]             }
[08:27:50.564]             function(cond) {
[08:27:50.564]                 is_error <- inherits(cond, "error")
[08:27:50.564]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.564]                   NULL)
[08:27:50.564]                 if (is_error) {
[08:27:50.564]                   sessionInformation <- function() {
[08:27:50.564]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.564]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.564]                       search = base::search(), system = base::Sys.info())
[08:27:50.564]                   }
[08:27:50.564]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.564]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.564]                     cond$call), session = sessionInformation(), 
[08:27:50.564]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.564]                   signalCondition(cond)
[08:27:50.564]                 }
[08:27:50.564]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.564]                 "immediateCondition"))) {
[08:27:50.564]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.564]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.564]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.564]                   if (TRUE && !signal) {
[08:27:50.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.564]                     {
[08:27:50.564]                       inherits <- base::inherits
[08:27:50.564]                       invokeRestart <- base::invokeRestart
[08:27:50.564]                       is.null <- base::is.null
[08:27:50.564]                       muffled <- FALSE
[08:27:50.564]                       if (inherits(cond, "message")) {
[08:27:50.564]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.564]                         if (muffled) 
[08:27:50.564]                           invokeRestart("muffleMessage")
[08:27:50.564]                       }
[08:27:50.564]                       else if (inherits(cond, "warning")) {
[08:27:50.564]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.564]                         if (muffled) 
[08:27:50.564]                           invokeRestart("muffleWarning")
[08:27:50.564]                       }
[08:27:50.564]                       else if (inherits(cond, "condition")) {
[08:27:50.564]                         if (!is.null(pattern)) {
[08:27:50.564]                           computeRestarts <- base::computeRestarts
[08:27:50.564]                           grepl <- base::grepl
[08:27:50.564]                           restarts <- computeRestarts(cond)
[08:27:50.564]                           for (restart in restarts) {
[08:27:50.564]                             name <- restart$name
[08:27:50.564]                             if (is.null(name)) 
[08:27:50.564]                               next
[08:27:50.564]                             if (!grepl(pattern, name)) 
[08:27:50.564]                               next
[08:27:50.564]                             invokeRestart(restart)
[08:27:50.564]                             muffled <- TRUE
[08:27:50.564]                             break
[08:27:50.564]                           }
[08:27:50.564]                         }
[08:27:50.564]                       }
[08:27:50.564]                       invisible(muffled)
[08:27:50.564]                     }
[08:27:50.564]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.564]                   }
[08:27:50.564]                 }
[08:27:50.564]                 else {
[08:27:50.564]                   if (TRUE) {
[08:27:50.564]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.564]                     {
[08:27:50.564]                       inherits <- base::inherits
[08:27:50.564]                       invokeRestart <- base::invokeRestart
[08:27:50.564]                       is.null <- base::is.null
[08:27:50.564]                       muffled <- FALSE
[08:27:50.564]                       if (inherits(cond, "message")) {
[08:27:50.564]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.564]                         if (muffled) 
[08:27:50.564]                           invokeRestart("muffleMessage")
[08:27:50.564]                       }
[08:27:50.564]                       else if (inherits(cond, "warning")) {
[08:27:50.564]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.564]                         if (muffled) 
[08:27:50.564]                           invokeRestart("muffleWarning")
[08:27:50.564]                       }
[08:27:50.564]                       else if (inherits(cond, "condition")) {
[08:27:50.564]                         if (!is.null(pattern)) {
[08:27:50.564]                           computeRestarts <- base::computeRestarts
[08:27:50.564]                           grepl <- base::grepl
[08:27:50.564]                           restarts <- computeRestarts(cond)
[08:27:50.564]                           for (restart in restarts) {
[08:27:50.564]                             name <- restart$name
[08:27:50.564]                             if (is.null(name)) 
[08:27:50.564]                               next
[08:27:50.564]                             if (!grepl(pattern, name)) 
[08:27:50.564]                               next
[08:27:50.564]                             invokeRestart(restart)
[08:27:50.564]                             muffled <- TRUE
[08:27:50.564]                             break
[08:27:50.564]                           }
[08:27:50.564]                         }
[08:27:50.564]                       }
[08:27:50.564]                       invisible(muffled)
[08:27:50.564]                     }
[08:27:50.564]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.564]                   }
[08:27:50.564]                 }
[08:27:50.564]             }
[08:27:50.564]         }))
[08:27:50.564]     }, error = function(ex) {
[08:27:50.564]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.564]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.564]                 ...future.rng), started = ...future.startTime, 
[08:27:50.564]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.564]             version = "1.8"), class = "FutureResult")
[08:27:50.564]     }, finally = {
[08:27:50.564]         if (!identical(...future.workdir, getwd())) 
[08:27:50.564]             setwd(...future.workdir)
[08:27:50.564]         {
[08:27:50.564]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.564]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.564]             }
[08:27:50.564]             base::options(...future.oldOptions)
[08:27:50.564]             if (.Platform$OS.type == "windows") {
[08:27:50.564]                 old_names <- names(...future.oldEnvVars)
[08:27:50.564]                 envs <- base::Sys.getenv()
[08:27:50.564]                 names <- names(envs)
[08:27:50.564]                 common <- intersect(names, old_names)
[08:27:50.564]                 added <- setdiff(names, old_names)
[08:27:50.564]                 removed <- setdiff(old_names, names)
[08:27:50.564]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.564]                   envs[common]]
[08:27:50.564]                 NAMES <- toupper(changed)
[08:27:50.564]                 args <- list()
[08:27:50.564]                 for (kk in seq_along(NAMES)) {
[08:27:50.564]                   name <- changed[[kk]]
[08:27:50.564]                   NAME <- NAMES[[kk]]
[08:27:50.564]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.564]                     next
[08:27:50.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.564]                 }
[08:27:50.564]                 NAMES <- toupper(added)
[08:27:50.564]                 for (kk in seq_along(NAMES)) {
[08:27:50.564]                   name <- added[[kk]]
[08:27:50.564]                   NAME <- NAMES[[kk]]
[08:27:50.564]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.564]                     next
[08:27:50.564]                   args[[name]] <- ""
[08:27:50.564]                 }
[08:27:50.564]                 NAMES <- toupper(removed)
[08:27:50.564]                 for (kk in seq_along(NAMES)) {
[08:27:50.564]                   name <- removed[[kk]]
[08:27:50.564]                   NAME <- NAMES[[kk]]
[08:27:50.564]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.564]                     next
[08:27:50.564]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.564]                 }
[08:27:50.564]                 if (length(args) > 0) 
[08:27:50.564]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.564]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.564]             }
[08:27:50.564]             else {
[08:27:50.564]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.564]             }
[08:27:50.564]             {
[08:27:50.564]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.564]                   0L) {
[08:27:50.564]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.564]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.564]                   base::options(opts)
[08:27:50.564]                 }
[08:27:50.564]                 {
[08:27:50.564]                   {
[08:27:50.564]                     NULL
[08:27:50.564]                     RNGkind("Mersenne-Twister")
[08:27:50.564]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.564]                       inherits = FALSE)
[08:27:50.564]                   }
[08:27:50.564]                   options(future.plan = NULL)
[08:27:50.564]                   if (is.na(NA_character_)) 
[08:27:50.564]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.564]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.564]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.564]                     .init = FALSE)
[08:27:50.564]                 }
[08:27:50.564]             }
[08:27:50.564]         }
[08:27:50.564]     })
[08:27:50.564]     if (TRUE) {
[08:27:50.564]         base::sink(type = "output", split = FALSE)
[08:27:50.564]         if (TRUE) {
[08:27:50.564]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.564]         }
[08:27:50.564]         else {
[08:27:50.564]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.564]         }
[08:27:50.564]         base::close(...future.stdout)
[08:27:50.564]         ...future.stdout <- NULL
[08:27:50.564]     }
[08:27:50.564]     ...future.result$conditions <- ...future.conditions
[08:27:50.564]     ...future.result$finished <- base::Sys.time()
[08:27:50.564]     ...future.result
[08:27:50.564] }
[08:27:50.565] plan(): Setting new future strategy stack:
[08:27:50.565] List of future strategies:
[08:27:50.565] 1. sequential:
[08:27:50.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.565]    - tweaked: FALSE
[08:27:50.565]    - call: NULL
[08:27:50.566] plan(): nbrOfWorkers() = 1
[08:27:50.567] plan(): Setting new future strategy stack:
[08:27:50.567] List of future strategies:
[08:27:50.567] 1. sequential:
[08:27:50.567]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.567]    - tweaked: FALSE
[08:27:50.567]    - call: plan(strategy)
[08:27:50.567] plan(): nbrOfWorkers() = 1
[08:27:50.567] SequentialFuture started (and completed)
[08:27:50.567] - Launch lazy future ... done
[08:27:50.567] run() for ‘SequentialFuture’ ... done
[08:27:50.568] getGlobalsAndPackages() ...
[08:27:50.568] Searching for globals...
[08:27:50.568] 
[08:27:50.568] Searching for globals ... DONE
[08:27:50.568] - globals: [0] <none>
[08:27:50.568] getGlobalsAndPackages() ... DONE
[08:27:50.568] run() for ‘Future’ ...
[08:27:50.569] - state: ‘created’
[08:27:50.569] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.569] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.569] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.569]   - Field: ‘label’
[08:27:50.569]   - Field: ‘local’
[08:27:50.569]   - Field: ‘owner’
[08:27:50.569]   - Field: ‘envir’
[08:27:50.569]   - Field: ‘packages’
[08:27:50.570]   - Field: ‘gc’
[08:27:50.570]   - Field: ‘conditions’
[08:27:50.570]   - Field: ‘expr’
[08:27:50.570]   - Field: ‘uuid’
[08:27:50.570]   - Field: ‘seed’
[08:27:50.570]   - Field: ‘version’
[08:27:50.570]   - Field: ‘result’
[08:27:50.570]   - Field: ‘asynchronous’
[08:27:50.570]   - Field: ‘calls’
[08:27:50.570]   - Field: ‘globals’
[08:27:50.570]   - Field: ‘stdout’
[08:27:50.571]   - Field: ‘earlySignal’
[08:27:50.571]   - Field: ‘lazy’
[08:27:50.571]   - Field: ‘state’
[08:27:50.571] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.573] - Launch lazy future ...
[08:27:50.573] Packages needed by the future expression (n = 0): <none>
[08:27:50.573] Packages needed by future strategies (n = 0): <none>
[08:27:50.573] {
[08:27:50.573]     {
[08:27:50.573]         {
[08:27:50.573]             ...future.startTime <- base::Sys.time()
[08:27:50.573]             {
[08:27:50.573]                 {
[08:27:50.573]                   {
[08:27:50.573]                     base::local({
[08:27:50.573]                       has_future <- base::requireNamespace("future", 
[08:27:50.573]                         quietly = TRUE)
[08:27:50.573]                       if (has_future) {
[08:27:50.573]                         ns <- base::getNamespace("future")
[08:27:50.573]                         version <- ns[[".package"]][["version"]]
[08:27:50.573]                         if (is.null(version)) 
[08:27:50.573]                           version <- utils::packageVersion("future")
[08:27:50.573]                       }
[08:27:50.573]                       else {
[08:27:50.573]                         version <- NULL
[08:27:50.573]                       }
[08:27:50.573]                       if (!has_future || version < "1.8.0") {
[08:27:50.573]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.573]                           "", base::R.version$version.string), 
[08:27:50.573]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.573]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.573]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.573]                             "release", "version")], collapse = " "), 
[08:27:50.573]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.573]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.573]                           info)
[08:27:50.573]                         info <- base::paste(info, collapse = "; ")
[08:27:50.573]                         if (!has_future) {
[08:27:50.573]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.573]                             info)
[08:27:50.573]                         }
[08:27:50.573]                         else {
[08:27:50.573]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.573]                             info, version)
[08:27:50.573]                         }
[08:27:50.573]                         base::stop(msg)
[08:27:50.573]                       }
[08:27:50.573]                     })
[08:27:50.573]                   }
[08:27:50.573]                   ...future.strategy.old <- future::plan("list")
[08:27:50.573]                   options(future.plan = NULL)
[08:27:50.573]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.573]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.573]                 }
[08:27:50.573]                 ...future.workdir <- getwd()
[08:27:50.573]             }
[08:27:50.573]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.573]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.573]         }
[08:27:50.573]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.573]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.573]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.573]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.573]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.573]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.573]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.573]             base::names(...future.oldOptions))
[08:27:50.573]     }
[08:27:50.573]     if (FALSE) {
[08:27:50.573]     }
[08:27:50.573]     else {
[08:27:50.573]         if (TRUE) {
[08:27:50.573]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.573]                 open = "w")
[08:27:50.573]         }
[08:27:50.573]         else {
[08:27:50.573]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.573]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.573]         }
[08:27:50.573]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.573]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.573]             base::sink(type = "output", split = FALSE)
[08:27:50.573]             base::close(...future.stdout)
[08:27:50.573]         }, add = TRUE)
[08:27:50.573]     }
[08:27:50.573]     ...future.frame <- base::sys.nframe()
[08:27:50.573]     ...future.conditions <- base::list()
[08:27:50.573]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.573]     if (FALSE) {
[08:27:50.573]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.573]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.573]     }
[08:27:50.573]     ...future.result <- base::tryCatch({
[08:27:50.573]         base::withCallingHandlers({
[08:27:50.573]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.573]             future::FutureResult(value = ...future.value$value, 
[08:27:50.573]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.573]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.573]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.573]                     ...future.globalenv.names))
[08:27:50.573]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.573]         }, condition = base::local({
[08:27:50.573]             c <- base::c
[08:27:50.573]             inherits <- base::inherits
[08:27:50.573]             invokeRestart <- base::invokeRestart
[08:27:50.573]             length <- base::length
[08:27:50.573]             list <- base::list
[08:27:50.573]             seq.int <- base::seq.int
[08:27:50.573]             signalCondition <- base::signalCondition
[08:27:50.573]             sys.calls <- base::sys.calls
[08:27:50.573]             `[[` <- base::`[[`
[08:27:50.573]             `+` <- base::`+`
[08:27:50.573]             `<<-` <- base::`<<-`
[08:27:50.573]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.573]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.573]                   3L)]
[08:27:50.573]             }
[08:27:50.573]             function(cond) {
[08:27:50.573]                 is_error <- inherits(cond, "error")
[08:27:50.573]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.573]                   NULL)
[08:27:50.573]                 if (is_error) {
[08:27:50.573]                   sessionInformation <- function() {
[08:27:50.573]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.573]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.573]                       search = base::search(), system = base::Sys.info())
[08:27:50.573]                   }
[08:27:50.573]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.573]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.573]                     cond$call), session = sessionInformation(), 
[08:27:50.573]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.573]                   signalCondition(cond)
[08:27:50.573]                 }
[08:27:50.573]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.573]                 "immediateCondition"))) {
[08:27:50.573]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.573]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.573]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.573]                   if (TRUE && !signal) {
[08:27:50.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.573]                     {
[08:27:50.573]                       inherits <- base::inherits
[08:27:50.573]                       invokeRestart <- base::invokeRestart
[08:27:50.573]                       is.null <- base::is.null
[08:27:50.573]                       muffled <- FALSE
[08:27:50.573]                       if (inherits(cond, "message")) {
[08:27:50.573]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.573]                         if (muffled) 
[08:27:50.573]                           invokeRestart("muffleMessage")
[08:27:50.573]                       }
[08:27:50.573]                       else if (inherits(cond, "warning")) {
[08:27:50.573]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.573]                         if (muffled) 
[08:27:50.573]                           invokeRestart("muffleWarning")
[08:27:50.573]                       }
[08:27:50.573]                       else if (inherits(cond, "condition")) {
[08:27:50.573]                         if (!is.null(pattern)) {
[08:27:50.573]                           computeRestarts <- base::computeRestarts
[08:27:50.573]                           grepl <- base::grepl
[08:27:50.573]                           restarts <- computeRestarts(cond)
[08:27:50.573]                           for (restart in restarts) {
[08:27:50.573]                             name <- restart$name
[08:27:50.573]                             if (is.null(name)) 
[08:27:50.573]                               next
[08:27:50.573]                             if (!grepl(pattern, name)) 
[08:27:50.573]                               next
[08:27:50.573]                             invokeRestart(restart)
[08:27:50.573]                             muffled <- TRUE
[08:27:50.573]                             break
[08:27:50.573]                           }
[08:27:50.573]                         }
[08:27:50.573]                       }
[08:27:50.573]                       invisible(muffled)
[08:27:50.573]                     }
[08:27:50.573]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.573]                   }
[08:27:50.573]                 }
[08:27:50.573]                 else {
[08:27:50.573]                   if (TRUE) {
[08:27:50.573]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.573]                     {
[08:27:50.573]                       inherits <- base::inherits
[08:27:50.573]                       invokeRestart <- base::invokeRestart
[08:27:50.573]                       is.null <- base::is.null
[08:27:50.573]                       muffled <- FALSE
[08:27:50.573]                       if (inherits(cond, "message")) {
[08:27:50.573]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.573]                         if (muffled) 
[08:27:50.573]                           invokeRestart("muffleMessage")
[08:27:50.573]                       }
[08:27:50.573]                       else if (inherits(cond, "warning")) {
[08:27:50.573]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.573]                         if (muffled) 
[08:27:50.573]                           invokeRestart("muffleWarning")
[08:27:50.573]                       }
[08:27:50.573]                       else if (inherits(cond, "condition")) {
[08:27:50.573]                         if (!is.null(pattern)) {
[08:27:50.573]                           computeRestarts <- base::computeRestarts
[08:27:50.573]                           grepl <- base::grepl
[08:27:50.573]                           restarts <- computeRestarts(cond)
[08:27:50.573]                           for (restart in restarts) {
[08:27:50.573]                             name <- restart$name
[08:27:50.573]                             if (is.null(name)) 
[08:27:50.573]                               next
[08:27:50.573]                             if (!grepl(pattern, name)) 
[08:27:50.573]                               next
[08:27:50.573]                             invokeRestart(restart)
[08:27:50.573]                             muffled <- TRUE
[08:27:50.573]                             break
[08:27:50.573]                           }
[08:27:50.573]                         }
[08:27:50.573]                       }
[08:27:50.573]                       invisible(muffled)
[08:27:50.573]                     }
[08:27:50.573]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.573]                   }
[08:27:50.573]                 }
[08:27:50.573]             }
[08:27:50.573]         }))
[08:27:50.573]     }, error = function(ex) {
[08:27:50.573]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.573]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.573]                 ...future.rng), started = ...future.startTime, 
[08:27:50.573]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.573]             version = "1.8"), class = "FutureResult")
[08:27:50.573]     }, finally = {
[08:27:50.573]         if (!identical(...future.workdir, getwd())) 
[08:27:50.573]             setwd(...future.workdir)
[08:27:50.573]         {
[08:27:50.573]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.573]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.573]             }
[08:27:50.573]             base::options(...future.oldOptions)
[08:27:50.573]             if (.Platform$OS.type == "windows") {
[08:27:50.573]                 old_names <- names(...future.oldEnvVars)
[08:27:50.573]                 envs <- base::Sys.getenv()
[08:27:50.573]                 names <- names(envs)
[08:27:50.573]                 common <- intersect(names, old_names)
[08:27:50.573]                 added <- setdiff(names, old_names)
[08:27:50.573]                 removed <- setdiff(old_names, names)
[08:27:50.573]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.573]                   envs[common]]
[08:27:50.573]                 NAMES <- toupper(changed)
[08:27:50.573]                 args <- list()
[08:27:50.573]                 for (kk in seq_along(NAMES)) {
[08:27:50.573]                   name <- changed[[kk]]
[08:27:50.573]                   NAME <- NAMES[[kk]]
[08:27:50.573]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.573]                     next
[08:27:50.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.573]                 }
[08:27:50.573]                 NAMES <- toupper(added)
[08:27:50.573]                 for (kk in seq_along(NAMES)) {
[08:27:50.573]                   name <- added[[kk]]
[08:27:50.573]                   NAME <- NAMES[[kk]]
[08:27:50.573]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.573]                     next
[08:27:50.573]                   args[[name]] <- ""
[08:27:50.573]                 }
[08:27:50.573]                 NAMES <- toupper(removed)
[08:27:50.573]                 for (kk in seq_along(NAMES)) {
[08:27:50.573]                   name <- removed[[kk]]
[08:27:50.573]                   NAME <- NAMES[[kk]]
[08:27:50.573]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.573]                     next
[08:27:50.573]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.573]                 }
[08:27:50.573]                 if (length(args) > 0) 
[08:27:50.573]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.573]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.573]             }
[08:27:50.573]             else {
[08:27:50.573]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.573]             }
[08:27:50.573]             {
[08:27:50.573]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.573]                   0L) {
[08:27:50.573]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.573]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.573]                   base::options(opts)
[08:27:50.573]                 }
[08:27:50.573]                 {
[08:27:50.573]                   {
[08:27:50.573]                     NULL
[08:27:50.573]                     RNGkind("Mersenne-Twister")
[08:27:50.573]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.573]                       inherits = FALSE)
[08:27:50.573]                   }
[08:27:50.573]                   options(future.plan = NULL)
[08:27:50.573]                   if (is.na(NA_character_)) 
[08:27:50.573]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.573]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.573]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.573]                     .init = FALSE)
[08:27:50.573]                 }
[08:27:50.573]             }
[08:27:50.573]         }
[08:27:50.573]     })
[08:27:50.573]     if (TRUE) {
[08:27:50.573]         base::sink(type = "output", split = FALSE)
[08:27:50.573]         if (TRUE) {
[08:27:50.573]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.573]         }
[08:27:50.573]         else {
[08:27:50.573]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.573]         }
[08:27:50.573]         base::close(...future.stdout)
[08:27:50.573]         ...future.stdout <- NULL
[08:27:50.573]     }
[08:27:50.573]     ...future.result$conditions <- ...future.conditions
[08:27:50.573]     ...future.result$finished <- base::Sys.time()
[08:27:50.573]     ...future.result
[08:27:50.573] }
[08:27:50.575] plan(): Setting new future strategy stack:
[08:27:50.575] List of future strategies:
[08:27:50.575] 1. sequential:
[08:27:50.575]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.575]    - tweaked: FALSE
[08:27:50.575]    - call: NULL
[08:27:50.576] plan(): nbrOfWorkers() = 1
[08:27:50.576] plan(): Setting new future strategy stack:
[08:27:50.577] List of future strategies:
[08:27:50.577] 1. sequential:
[08:27:50.577]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.577]    - tweaked: FALSE
[08:27:50.577]    - call: plan(strategy)
[08:27:50.577] plan(): nbrOfWorkers() = 1
[08:27:50.577] SequentialFuture started (and completed)
[08:27:50.577] - Launch lazy future ... done
[08:27:50.577] run() for ‘SequentialFuture’ ... done
[08:27:50.578] getGlobalsAndPackages() ...
[08:27:50.578] Searching for globals...
[08:27:50.579] - globals found: [1] ‘{’
[08:27:50.579] Searching for globals ... DONE
[08:27:50.579] Resolving globals: FALSE
[08:27:50.579] 
[08:27:50.579] 
[08:27:50.579] getGlobalsAndPackages() ... DONE
[08:27:50.579] run() for ‘Future’ ...
[08:27:50.580] - state: ‘created’
[08:27:50.580] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.580] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.580] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.580]   - Field: ‘label’
[08:27:50.580]   - Field: ‘local’
[08:27:50.580]   - Field: ‘owner’
[08:27:50.580]   - Field: ‘envir’
[08:27:50.581]   - Field: ‘packages’
[08:27:50.581]   - Field: ‘gc’
[08:27:50.581]   - Field: ‘conditions’
[08:27:50.581]   - Field: ‘expr’
[08:27:50.581]   - Field: ‘uuid’
[08:27:50.581]   - Field: ‘seed’
[08:27:50.581]   - Field: ‘version’
[08:27:50.581]   - Field: ‘result’
[08:27:50.581]   - Field: ‘asynchronous’
[08:27:50.581]   - Field: ‘calls’
[08:27:50.581]   - Field: ‘globals’
[08:27:50.581]   - Field: ‘stdout’
[08:27:50.582]   - Field: ‘earlySignal’
[08:27:50.582]   - Field: ‘lazy’
[08:27:50.582]   - Field: ‘state’
[08:27:50.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.582] - Launch lazy future ...
[08:27:50.582] Packages needed by the future expression (n = 0): <none>
[08:27:50.582] Packages needed by future strategies (n = 0): <none>
[08:27:50.583] {
[08:27:50.583]     {
[08:27:50.583]         {
[08:27:50.583]             ...future.startTime <- base::Sys.time()
[08:27:50.583]             {
[08:27:50.583]                 {
[08:27:50.583]                   {
[08:27:50.583]                     base::local({
[08:27:50.583]                       has_future <- base::requireNamespace("future", 
[08:27:50.583]                         quietly = TRUE)
[08:27:50.583]                       if (has_future) {
[08:27:50.583]                         ns <- base::getNamespace("future")
[08:27:50.583]                         version <- ns[[".package"]][["version"]]
[08:27:50.583]                         if (is.null(version)) 
[08:27:50.583]                           version <- utils::packageVersion("future")
[08:27:50.583]                       }
[08:27:50.583]                       else {
[08:27:50.583]                         version <- NULL
[08:27:50.583]                       }
[08:27:50.583]                       if (!has_future || version < "1.8.0") {
[08:27:50.583]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.583]                           "", base::R.version$version.string), 
[08:27:50.583]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.583]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.583]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.583]                             "release", "version")], collapse = " "), 
[08:27:50.583]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.583]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.583]                           info)
[08:27:50.583]                         info <- base::paste(info, collapse = "; ")
[08:27:50.583]                         if (!has_future) {
[08:27:50.583]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.583]                             info)
[08:27:50.583]                         }
[08:27:50.583]                         else {
[08:27:50.583]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.583]                             info, version)
[08:27:50.583]                         }
[08:27:50.583]                         base::stop(msg)
[08:27:50.583]                       }
[08:27:50.583]                     })
[08:27:50.583]                   }
[08:27:50.583]                   ...future.strategy.old <- future::plan("list")
[08:27:50.583]                   options(future.plan = NULL)
[08:27:50.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.583]                 }
[08:27:50.583]                 ...future.workdir <- getwd()
[08:27:50.583]             }
[08:27:50.583]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.583]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.583]         }
[08:27:50.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.583]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.583]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.583]             base::names(...future.oldOptions))
[08:27:50.583]     }
[08:27:50.583]     if (FALSE) {
[08:27:50.583]     }
[08:27:50.583]     else {
[08:27:50.583]         if (TRUE) {
[08:27:50.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.583]                 open = "w")
[08:27:50.583]         }
[08:27:50.583]         else {
[08:27:50.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.583]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.583]         }
[08:27:50.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.583]             base::sink(type = "output", split = FALSE)
[08:27:50.583]             base::close(...future.stdout)
[08:27:50.583]         }, add = TRUE)
[08:27:50.583]     }
[08:27:50.583]     ...future.frame <- base::sys.nframe()
[08:27:50.583]     ...future.conditions <- base::list()
[08:27:50.583]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.583]     if (FALSE) {
[08:27:50.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.583]     }
[08:27:50.583]     ...future.result <- base::tryCatch({
[08:27:50.583]         base::withCallingHandlers({
[08:27:50.583]             ...future.value <- base::withVisible(base::local({
[08:27:50.583]                 4
[08:27:50.583]             }))
[08:27:50.583]             future::FutureResult(value = ...future.value$value, 
[08:27:50.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.583]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.583]                     ...future.globalenv.names))
[08:27:50.583]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.583]         }, condition = base::local({
[08:27:50.583]             c <- base::c
[08:27:50.583]             inherits <- base::inherits
[08:27:50.583]             invokeRestart <- base::invokeRestart
[08:27:50.583]             length <- base::length
[08:27:50.583]             list <- base::list
[08:27:50.583]             seq.int <- base::seq.int
[08:27:50.583]             signalCondition <- base::signalCondition
[08:27:50.583]             sys.calls <- base::sys.calls
[08:27:50.583]             `[[` <- base::`[[`
[08:27:50.583]             `+` <- base::`+`
[08:27:50.583]             `<<-` <- base::`<<-`
[08:27:50.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.583]                   3L)]
[08:27:50.583]             }
[08:27:50.583]             function(cond) {
[08:27:50.583]                 is_error <- inherits(cond, "error")
[08:27:50.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.583]                   NULL)
[08:27:50.583]                 if (is_error) {
[08:27:50.583]                   sessionInformation <- function() {
[08:27:50.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.583]                       search = base::search(), system = base::Sys.info())
[08:27:50.583]                   }
[08:27:50.583]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.583]                     cond$call), session = sessionInformation(), 
[08:27:50.583]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.583]                   signalCondition(cond)
[08:27:50.583]                 }
[08:27:50.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.583]                 "immediateCondition"))) {
[08:27:50.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.583]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.583]                   if (TRUE && !signal) {
[08:27:50.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.583]                     {
[08:27:50.583]                       inherits <- base::inherits
[08:27:50.583]                       invokeRestart <- base::invokeRestart
[08:27:50.583]                       is.null <- base::is.null
[08:27:50.583]                       muffled <- FALSE
[08:27:50.583]                       if (inherits(cond, "message")) {
[08:27:50.583]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.583]                         if (muffled) 
[08:27:50.583]                           invokeRestart("muffleMessage")
[08:27:50.583]                       }
[08:27:50.583]                       else if (inherits(cond, "warning")) {
[08:27:50.583]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.583]                         if (muffled) 
[08:27:50.583]                           invokeRestart("muffleWarning")
[08:27:50.583]                       }
[08:27:50.583]                       else if (inherits(cond, "condition")) {
[08:27:50.583]                         if (!is.null(pattern)) {
[08:27:50.583]                           computeRestarts <- base::computeRestarts
[08:27:50.583]                           grepl <- base::grepl
[08:27:50.583]                           restarts <- computeRestarts(cond)
[08:27:50.583]                           for (restart in restarts) {
[08:27:50.583]                             name <- restart$name
[08:27:50.583]                             if (is.null(name)) 
[08:27:50.583]                               next
[08:27:50.583]                             if (!grepl(pattern, name)) 
[08:27:50.583]                               next
[08:27:50.583]                             invokeRestart(restart)
[08:27:50.583]                             muffled <- TRUE
[08:27:50.583]                             break
[08:27:50.583]                           }
[08:27:50.583]                         }
[08:27:50.583]                       }
[08:27:50.583]                       invisible(muffled)
[08:27:50.583]                     }
[08:27:50.583]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.583]                   }
[08:27:50.583]                 }
[08:27:50.583]                 else {
[08:27:50.583]                   if (TRUE) {
[08:27:50.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.583]                     {
[08:27:50.583]                       inherits <- base::inherits
[08:27:50.583]                       invokeRestart <- base::invokeRestart
[08:27:50.583]                       is.null <- base::is.null
[08:27:50.583]                       muffled <- FALSE
[08:27:50.583]                       if (inherits(cond, "message")) {
[08:27:50.583]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.583]                         if (muffled) 
[08:27:50.583]                           invokeRestart("muffleMessage")
[08:27:50.583]                       }
[08:27:50.583]                       else if (inherits(cond, "warning")) {
[08:27:50.583]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.583]                         if (muffled) 
[08:27:50.583]                           invokeRestart("muffleWarning")
[08:27:50.583]                       }
[08:27:50.583]                       else if (inherits(cond, "condition")) {
[08:27:50.583]                         if (!is.null(pattern)) {
[08:27:50.583]                           computeRestarts <- base::computeRestarts
[08:27:50.583]                           grepl <- base::grepl
[08:27:50.583]                           restarts <- computeRestarts(cond)
[08:27:50.583]                           for (restart in restarts) {
[08:27:50.583]                             name <- restart$name
[08:27:50.583]                             if (is.null(name)) 
[08:27:50.583]                               next
[08:27:50.583]                             if (!grepl(pattern, name)) 
[08:27:50.583]                               next
[08:27:50.583]                             invokeRestart(restart)
[08:27:50.583]                             muffled <- TRUE
[08:27:50.583]                             break
[08:27:50.583]                           }
[08:27:50.583]                         }
[08:27:50.583]                       }
[08:27:50.583]                       invisible(muffled)
[08:27:50.583]                     }
[08:27:50.583]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.583]                   }
[08:27:50.583]                 }
[08:27:50.583]             }
[08:27:50.583]         }))
[08:27:50.583]     }, error = function(ex) {
[08:27:50.583]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.583]                 ...future.rng), started = ...future.startTime, 
[08:27:50.583]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.583]             version = "1.8"), class = "FutureResult")
[08:27:50.583]     }, finally = {
[08:27:50.583]         if (!identical(...future.workdir, getwd())) 
[08:27:50.583]             setwd(...future.workdir)
[08:27:50.583]         {
[08:27:50.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.583]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.583]             }
[08:27:50.583]             base::options(...future.oldOptions)
[08:27:50.583]             if (.Platform$OS.type == "windows") {
[08:27:50.583]                 old_names <- names(...future.oldEnvVars)
[08:27:50.583]                 envs <- base::Sys.getenv()
[08:27:50.583]                 names <- names(envs)
[08:27:50.583]                 common <- intersect(names, old_names)
[08:27:50.583]                 added <- setdiff(names, old_names)
[08:27:50.583]                 removed <- setdiff(old_names, names)
[08:27:50.583]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.583]                   envs[common]]
[08:27:50.583]                 NAMES <- toupper(changed)
[08:27:50.583]                 args <- list()
[08:27:50.583]                 for (kk in seq_along(NAMES)) {
[08:27:50.583]                   name <- changed[[kk]]
[08:27:50.583]                   NAME <- NAMES[[kk]]
[08:27:50.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.583]                     next
[08:27:50.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.583]                 }
[08:27:50.583]                 NAMES <- toupper(added)
[08:27:50.583]                 for (kk in seq_along(NAMES)) {
[08:27:50.583]                   name <- added[[kk]]
[08:27:50.583]                   NAME <- NAMES[[kk]]
[08:27:50.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.583]                     next
[08:27:50.583]                   args[[name]] <- ""
[08:27:50.583]                 }
[08:27:50.583]                 NAMES <- toupper(removed)
[08:27:50.583]                 for (kk in seq_along(NAMES)) {
[08:27:50.583]                   name <- removed[[kk]]
[08:27:50.583]                   NAME <- NAMES[[kk]]
[08:27:50.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.583]                     next
[08:27:50.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.583]                 }
[08:27:50.583]                 if (length(args) > 0) 
[08:27:50.583]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.583]             }
[08:27:50.583]             else {
[08:27:50.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.583]             }
[08:27:50.583]             {
[08:27:50.583]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.583]                   0L) {
[08:27:50.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.583]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.583]                   base::options(opts)
[08:27:50.583]                 }
[08:27:50.583]                 {
[08:27:50.583]                   {
[08:27:50.583]                     NULL
[08:27:50.583]                     RNGkind("Mersenne-Twister")
[08:27:50.583]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.583]                       inherits = FALSE)
[08:27:50.583]                   }
[08:27:50.583]                   options(future.plan = NULL)
[08:27:50.583]                   if (is.na(NA_character_)) 
[08:27:50.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.583]                     .init = FALSE)
[08:27:50.583]                 }
[08:27:50.583]             }
[08:27:50.583]         }
[08:27:50.583]     })
[08:27:50.583]     if (TRUE) {
[08:27:50.583]         base::sink(type = "output", split = FALSE)
[08:27:50.583]         if (TRUE) {
[08:27:50.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.583]         }
[08:27:50.583]         else {
[08:27:50.583]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.583]         }
[08:27:50.583]         base::close(...future.stdout)
[08:27:50.583]         ...future.stdout <- NULL
[08:27:50.583]     }
[08:27:50.583]     ...future.result$conditions <- ...future.conditions
[08:27:50.583]     ...future.result$finished <- base::Sys.time()
[08:27:50.583]     ...future.result
[08:27:50.583] }
[08:27:50.584] plan(): Setting new future strategy stack:
[08:27:50.585] List of future strategies:
[08:27:50.585] 1. sequential:
[08:27:50.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.585]    - tweaked: FALSE
[08:27:50.585]    - call: NULL
[08:27:50.585] plan(): nbrOfWorkers() = 1
[08:27:50.586] plan(): Setting new future strategy stack:
[08:27:50.586] List of future strategies:
[08:27:50.586] 1. sequential:
[08:27:50.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.586]    - tweaked: FALSE
[08:27:50.586]    - call: plan(strategy)
[08:27:50.586] plan(): nbrOfWorkers() = 1
[08:27:50.586] SequentialFuture started (and completed)
[08:27:50.586] - Launch lazy future ... done
[08:27:50.587] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d860a33d68> 
Classes 'listenv', 'environment' <environment: 0x55d860986a18> 
[08:27:50.589] resolved() for ‘SequentialFuture’ ...
[08:27:50.589] - state: ‘finished’
[08:27:50.590] - run: TRUE
[08:27:50.590] - result: ‘FutureResult’
[08:27:50.590] resolved() for ‘SequentialFuture’ ... done
[08:27:50.590] resolved() for ‘SequentialFuture’ ...
[08:27:50.590] - state: ‘finished’
[08:27:50.590] - run: TRUE
[08:27:50.590] - result: ‘FutureResult’
[08:27:50.590] resolved() for ‘SequentialFuture’ ... done
[08:27:50.590] resolved() for ‘SequentialFuture’ ...
[08:27:50.590] - state: ‘finished’
[08:27:50.590] - run: TRUE
[08:27:50.591] - result: ‘FutureResult’
[08:27:50.591] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:50.592] resolve() on list environment ...
[08:27:50.592]  recursive: 0
[08:27:50.593]  length: 6
[08:27:50.593]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:50.593] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.594] - nx: 6
[08:27:50.594] - relay: TRUE
[08:27:50.594] - stdout: TRUE
[08:27:50.594] - signal: TRUE
[08:27:50.594] - resignal: FALSE
[08:27:50.594] - force: TRUE
[08:27:50.594] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.594] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.594]  - until=2
[08:27:50.594]  - relaying element #2
[08:27:50.594] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.594] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.595] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.595]  length: 5 (resolved future 1)
[08:27:50.595] resolved() for ‘SequentialFuture’ ...
[08:27:50.595] - state: ‘finished’
[08:27:50.595] - run: TRUE
[08:27:50.595] - result: ‘FutureResult’
[08:27:50.595] resolved() for ‘SequentialFuture’ ... done
[08:27:50.595] Future #2
[08:27:50.595] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.595] - nx: 6
[08:27:50.596] - relay: TRUE
[08:27:50.596] - stdout: TRUE
[08:27:50.596] - signal: TRUE
[08:27:50.596] - resignal: FALSE
[08:27:50.596] - force: TRUE
[08:27:50.596] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.596] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.596]  - until=2
[08:27:50.596]  - relaying element #2
[08:27:50.596] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.596] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.597] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.597]  length: 4 (resolved future 2)
[08:27:50.597] resolved() for ‘SequentialFuture’ ...
[08:27:50.597] - state: ‘finished’
[08:27:50.597] - run: TRUE
[08:27:50.597] - result: ‘FutureResult’
[08:27:50.597] resolved() for ‘SequentialFuture’ ... done
[08:27:50.597] Future #3
[08:27:50.597] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.597] - nx: 6
[08:27:50.597] - relay: TRUE
[08:27:50.598] - stdout: TRUE
[08:27:50.598] - signal: TRUE
[08:27:50.600] - resignal: FALSE
[08:27:50.600] - force: TRUE
[08:27:50.600] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.600] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.600]  - until=3
[08:27:50.600]  - relaying element #3
[08:27:50.600] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.600] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.601] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.601]  length: 3 (resolved future 3)
[08:27:50.601] resolved() for ‘SequentialFuture’ ...
[08:27:50.601] - state: ‘finished’
[08:27:50.601] - run: TRUE
[08:27:50.601] - result: ‘FutureResult’
[08:27:50.601] resolved() for ‘SequentialFuture’ ... done
[08:27:50.601] Future #4
[08:27:50.601] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.601] - nx: 6
[08:27:50.601] - relay: TRUE
[08:27:50.602] - stdout: TRUE
[08:27:50.602] - signal: TRUE
[08:27:50.602] - resignal: FALSE
[08:27:50.602] - force: TRUE
[08:27:50.602] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.602] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.602]  - until=4
[08:27:50.602]  - relaying element #4
[08:27:50.602] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.602] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.602] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.603]  length: 2 (resolved future 4)
[08:27:50.603] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.603] - nx: 6
[08:27:50.603] - relay: TRUE
[08:27:50.603] - stdout: TRUE
[08:27:50.603] - signal: TRUE
[08:27:50.603] - resignal: FALSE
[08:27:50.603] - force: TRUE
[08:27:50.603] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.603] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.603]  - until=6
[08:27:50.603]  - relaying element #6
[08:27:50.604] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.604] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.604] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.604]  length: 1 (resolved future 5)
[08:27:50.604] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.604] - nx: 6
[08:27:50.604] - relay: TRUE
[08:27:50.604] - stdout: TRUE
[08:27:50.604] - signal: TRUE
[08:27:50.604] - resignal: FALSE
[08:27:50.604] - force: TRUE
[08:27:50.604] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.605] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.605]  - until=6
[08:27:50.605] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.605] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.605] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.605]  length: 0 (resolved future 6)
[08:27:50.605] Relaying remaining futures
[08:27:50.605] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.605] - nx: 6
[08:27:50.605] - relay: TRUE
[08:27:50.605] - stdout: TRUE
[08:27:50.605] - signal: TRUE
[08:27:50.605] - resignal: FALSE
[08:27:50.606] - force: TRUE
[08:27:50.606] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.606] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:50.606] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.606] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.606] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.606] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55d860c49fe0> 
Dimensions: c(1, 6)
[08:27:50.607] getGlobalsAndPackages() ...
[08:27:50.607] Searching for globals...
[08:27:50.607] 
[08:27:50.607] Searching for globals ... DONE
[08:27:50.608] - globals: [0] <none>
[08:27:50.608] getGlobalsAndPackages() ... DONE
[08:27:50.608] run() for ‘Future’ ...
[08:27:50.608] - state: ‘created’
[08:27:50.608] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.608] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.608] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.609]   - Field: ‘label’
[08:27:50.609]   - Field: ‘local’
[08:27:50.609]   - Field: ‘owner’
[08:27:50.609]   - Field: ‘envir’
[08:27:50.609]   - Field: ‘packages’
[08:27:50.609]   - Field: ‘gc’
[08:27:50.609]   - Field: ‘conditions’
[08:27:50.609]   - Field: ‘expr’
[08:27:50.609]   - Field: ‘uuid’
[08:27:50.609]   - Field: ‘seed’
[08:27:50.609]   - Field: ‘version’
[08:27:50.609]   - Field: ‘result’
[08:27:50.610]   - Field: ‘asynchronous’
[08:27:50.610]   - Field: ‘calls’
[08:27:50.610]   - Field: ‘globals’
[08:27:50.610]   - Field: ‘stdout’
[08:27:50.610]   - Field: ‘earlySignal’
[08:27:50.610]   - Field: ‘lazy’
[08:27:50.610]   - Field: ‘state’
[08:27:50.610] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.610] - Launch lazy future ...
[08:27:50.610] Packages needed by the future expression (n = 0): <none>
[08:27:50.611] Packages needed by future strategies (n = 0): <none>
[08:27:50.611] {
[08:27:50.611]     {
[08:27:50.611]         {
[08:27:50.611]             ...future.startTime <- base::Sys.time()
[08:27:50.611]             {
[08:27:50.611]                 {
[08:27:50.611]                   {
[08:27:50.611]                     base::local({
[08:27:50.611]                       has_future <- base::requireNamespace("future", 
[08:27:50.611]                         quietly = TRUE)
[08:27:50.611]                       if (has_future) {
[08:27:50.611]                         ns <- base::getNamespace("future")
[08:27:50.611]                         version <- ns[[".package"]][["version"]]
[08:27:50.611]                         if (is.null(version)) 
[08:27:50.611]                           version <- utils::packageVersion("future")
[08:27:50.611]                       }
[08:27:50.611]                       else {
[08:27:50.611]                         version <- NULL
[08:27:50.611]                       }
[08:27:50.611]                       if (!has_future || version < "1.8.0") {
[08:27:50.611]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.611]                           "", base::R.version$version.string), 
[08:27:50.611]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.611]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.611]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.611]                             "release", "version")], collapse = " "), 
[08:27:50.611]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.611]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.611]                           info)
[08:27:50.611]                         info <- base::paste(info, collapse = "; ")
[08:27:50.611]                         if (!has_future) {
[08:27:50.611]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.611]                             info)
[08:27:50.611]                         }
[08:27:50.611]                         else {
[08:27:50.611]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.611]                             info, version)
[08:27:50.611]                         }
[08:27:50.611]                         base::stop(msg)
[08:27:50.611]                       }
[08:27:50.611]                     })
[08:27:50.611]                   }
[08:27:50.611]                   ...future.strategy.old <- future::plan("list")
[08:27:50.611]                   options(future.plan = NULL)
[08:27:50.611]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.611]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.611]                 }
[08:27:50.611]                 ...future.workdir <- getwd()
[08:27:50.611]             }
[08:27:50.611]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.611]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.611]         }
[08:27:50.611]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.611]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.611]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.611]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.611]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.611]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.611]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.611]             base::names(...future.oldOptions))
[08:27:50.611]     }
[08:27:50.611]     if (FALSE) {
[08:27:50.611]     }
[08:27:50.611]     else {
[08:27:50.611]         if (TRUE) {
[08:27:50.611]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.611]                 open = "w")
[08:27:50.611]         }
[08:27:50.611]         else {
[08:27:50.611]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.611]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.611]         }
[08:27:50.611]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.611]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.611]             base::sink(type = "output", split = FALSE)
[08:27:50.611]             base::close(...future.stdout)
[08:27:50.611]         }, add = TRUE)
[08:27:50.611]     }
[08:27:50.611]     ...future.frame <- base::sys.nframe()
[08:27:50.611]     ...future.conditions <- base::list()
[08:27:50.611]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.611]     if (FALSE) {
[08:27:50.611]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.611]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.611]     }
[08:27:50.611]     ...future.result <- base::tryCatch({
[08:27:50.611]         base::withCallingHandlers({
[08:27:50.611]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.611]             future::FutureResult(value = ...future.value$value, 
[08:27:50.611]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.611]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.611]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.611]                     ...future.globalenv.names))
[08:27:50.611]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.611]         }, condition = base::local({
[08:27:50.611]             c <- base::c
[08:27:50.611]             inherits <- base::inherits
[08:27:50.611]             invokeRestart <- base::invokeRestart
[08:27:50.611]             length <- base::length
[08:27:50.611]             list <- base::list
[08:27:50.611]             seq.int <- base::seq.int
[08:27:50.611]             signalCondition <- base::signalCondition
[08:27:50.611]             sys.calls <- base::sys.calls
[08:27:50.611]             `[[` <- base::`[[`
[08:27:50.611]             `+` <- base::`+`
[08:27:50.611]             `<<-` <- base::`<<-`
[08:27:50.611]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.611]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.611]                   3L)]
[08:27:50.611]             }
[08:27:50.611]             function(cond) {
[08:27:50.611]                 is_error <- inherits(cond, "error")
[08:27:50.611]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.611]                   NULL)
[08:27:50.611]                 if (is_error) {
[08:27:50.611]                   sessionInformation <- function() {
[08:27:50.611]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.611]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.611]                       search = base::search(), system = base::Sys.info())
[08:27:50.611]                   }
[08:27:50.611]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.611]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.611]                     cond$call), session = sessionInformation(), 
[08:27:50.611]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.611]                   signalCondition(cond)
[08:27:50.611]                 }
[08:27:50.611]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.611]                 "immediateCondition"))) {
[08:27:50.611]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.611]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.611]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.611]                   if (TRUE && !signal) {
[08:27:50.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.611]                     {
[08:27:50.611]                       inherits <- base::inherits
[08:27:50.611]                       invokeRestart <- base::invokeRestart
[08:27:50.611]                       is.null <- base::is.null
[08:27:50.611]                       muffled <- FALSE
[08:27:50.611]                       if (inherits(cond, "message")) {
[08:27:50.611]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.611]                         if (muffled) 
[08:27:50.611]                           invokeRestart("muffleMessage")
[08:27:50.611]                       }
[08:27:50.611]                       else if (inherits(cond, "warning")) {
[08:27:50.611]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.611]                         if (muffled) 
[08:27:50.611]                           invokeRestart("muffleWarning")
[08:27:50.611]                       }
[08:27:50.611]                       else if (inherits(cond, "condition")) {
[08:27:50.611]                         if (!is.null(pattern)) {
[08:27:50.611]                           computeRestarts <- base::computeRestarts
[08:27:50.611]                           grepl <- base::grepl
[08:27:50.611]                           restarts <- computeRestarts(cond)
[08:27:50.611]                           for (restart in restarts) {
[08:27:50.611]                             name <- restart$name
[08:27:50.611]                             if (is.null(name)) 
[08:27:50.611]                               next
[08:27:50.611]                             if (!grepl(pattern, name)) 
[08:27:50.611]                               next
[08:27:50.611]                             invokeRestart(restart)
[08:27:50.611]                             muffled <- TRUE
[08:27:50.611]                             break
[08:27:50.611]                           }
[08:27:50.611]                         }
[08:27:50.611]                       }
[08:27:50.611]                       invisible(muffled)
[08:27:50.611]                     }
[08:27:50.611]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.611]                   }
[08:27:50.611]                 }
[08:27:50.611]                 else {
[08:27:50.611]                   if (TRUE) {
[08:27:50.611]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.611]                     {
[08:27:50.611]                       inherits <- base::inherits
[08:27:50.611]                       invokeRestart <- base::invokeRestart
[08:27:50.611]                       is.null <- base::is.null
[08:27:50.611]                       muffled <- FALSE
[08:27:50.611]                       if (inherits(cond, "message")) {
[08:27:50.611]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.611]                         if (muffled) 
[08:27:50.611]                           invokeRestart("muffleMessage")
[08:27:50.611]                       }
[08:27:50.611]                       else if (inherits(cond, "warning")) {
[08:27:50.611]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.611]                         if (muffled) 
[08:27:50.611]                           invokeRestart("muffleWarning")
[08:27:50.611]                       }
[08:27:50.611]                       else if (inherits(cond, "condition")) {
[08:27:50.611]                         if (!is.null(pattern)) {
[08:27:50.611]                           computeRestarts <- base::computeRestarts
[08:27:50.611]                           grepl <- base::grepl
[08:27:50.611]                           restarts <- computeRestarts(cond)
[08:27:50.611]                           for (restart in restarts) {
[08:27:50.611]                             name <- restart$name
[08:27:50.611]                             if (is.null(name)) 
[08:27:50.611]                               next
[08:27:50.611]                             if (!grepl(pattern, name)) 
[08:27:50.611]                               next
[08:27:50.611]                             invokeRestart(restart)
[08:27:50.611]                             muffled <- TRUE
[08:27:50.611]                             break
[08:27:50.611]                           }
[08:27:50.611]                         }
[08:27:50.611]                       }
[08:27:50.611]                       invisible(muffled)
[08:27:50.611]                     }
[08:27:50.611]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.611]                   }
[08:27:50.611]                 }
[08:27:50.611]             }
[08:27:50.611]         }))
[08:27:50.611]     }, error = function(ex) {
[08:27:50.611]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.611]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.611]                 ...future.rng), started = ...future.startTime, 
[08:27:50.611]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.611]             version = "1.8"), class = "FutureResult")
[08:27:50.611]     }, finally = {
[08:27:50.611]         if (!identical(...future.workdir, getwd())) 
[08:27:50.611]             setwd(...future.workdir)
[08:27:50.611]         {
[08:27:50.611]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.611]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.611]             }
[08:27:50.611]             base::options(...future.oldOptions)
[08:27:50.611]             if (.Platform$OS.type == "windows") {
[08:27:50.611]                 old_names <- names(...future.oldEnvVars)
[08:27:50.611]                 envs <- base::Sys.getenv()
[08:27:50.611]                 names <- names(envs)
[08:27:50.611]                 common <- intersect(names, old_names)
[08:27:50.611]                 added <- setdiff(names, old_names)
[08:27:50.611]                 removed <- setdiff(old_names, names)
[08:27:50.611]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.611]                   envs[common]]
[08:27:50.611]                 NAMES <- toupper(changed)
[08:27:50.611]                 args <- list()
[08:27:50.611]                 for (kk in seq_along(NAMES)) {
[08:27:50.611]                   name <- changed[[kk]]
[08:27:50.611]                   NAME <- NAMES[[kk]]
[08:27:50.611]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.611]                     next
[08:27:50.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.611]                 }
[08:27:50.611]                 NAMES <- toupper(added)
[08:27:50.611]                 for (kk in seq_along(NAMES)) {
[08:27:50.611]                   name <- added[[kk]]
[08:27:50.611]                   NAME <- NAMES[[kk]]
[08:27:50.611]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.611]                     next
[08:27:50.611]                   args[[name]] <- ""
[08:27:50.611]                 }
[08:27:50.611]                 NAMES <- toupper(removed)
[08:27:50.611]                 for (kk in seq_along(NAMES)) {
[08:27:50.611]                   name <- removed[[kk]]
[08:27:50.611]                   NAME <- NAMES[[kk]]
[08:27:50.611]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.611]                     next
[08:27:50.611]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.611]                 }
[08:27:50.611]                 if (length(args) > 0) 
[08:27:50.611]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.611]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.611]             }
[08:27:50.611]             else {
[08:27:50.611]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.611]             }
[08:27:50.611]             {
[08:27:50.611]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.611]                   0L) {
[08:27:50.611]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.611]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.611]                   base::options(opts)
[08:27:50.611]                 }
[08:27:50.611]                 {
[08:27:50.611]                   {
[08:27:50.611]                     NULL
[08:27:50.611]                     RNGkind("Mersenne-Twister")
[08:27:50.611]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.611]                       inherits = FALSE)
[08:27:50.611]                   }
[08:27:50.611]                   options(future.plan = NULL)
[08:27:50.611]                   if (is.na(NA_character_)) 
[08:27:50.611]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.611]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.611]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.611]                     .init = FALSE)
[08:27:50.611]                 }
[08:27:50.611]             }
[08:27:50.611]         }
[08:27:50.611]     })
[08:27:50.611]     if (TRUE) {
[08:27:50.611]         base::sink(type = "output", split = FALSE)
[08:27:50.611]         if (TRUE) {
[08:27:50.611]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.611]         }
[08:27:50.611]         else {
[08:27:50.611]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.611]         }
[08:27:50.611]         base::close(...future.stdout)
[08:27:50.611]         ...future.stdout <- NULL
[08:27:50.611]     }
[08:27:50.611]     ...future.result$conditions <- ...future.conditions
[08:27:50.611]     ...future.result$finished <- base::Sys.time()
[08:27:50.611]     ...future.result
[08:27:50.611] }
[08:27:50.613] plan(): Setting new future strategy stack:
[08:27:50.613] List of future strategies:
[08:27:50.613] 1. sequential:
[08:27:50.613]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.613]    - tweaked: FALSE
[08:27:50.613]    - call: NULL
[08:27:50.613] plan(): nbrOfWorkers() = 1
[08:27:50.614] plan(): Setting new future strategy stack:
[08:27:50.614] List of future strategies:
[08:27:50.614] 1. sequential:
[08:27:50.614]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.614]    - tweaked: FALSE
[08:27:50.614]    - call: plan(strategy)
[08:27:50.615] plan(): nbrOfWorkers() = 1
[08:27:50.615] SequentialFuture started (and completed)
[08:27:50.615] - Launch lazy future ... done
[08:27:50.615] run() for ‘SequentialFuture’ ... done
[08:27:50.615] getGlobalsAndPackages() ...
[08:27:50.615] Searching for globals...
[08:27:50.616] 
[08:27:50.616] Searching for globals ... DONE
[08:27:50.616] - globals: [0] <none>
[08:27:50.616] getGlobalsAndPackages() ... DONE
[08:27:50.616] run() for ‘Future’ ...
[08:27:50.616] - state: ‘created’
[08:27:50.616] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.616] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.617] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.617]   - Field: ‘label’
[08:27:50.617]   - Field: ‘local’
[08:27:50.617]   - Field: ‘owner’
[08:27:50.617]   - Field: ‘envir’
[08:27:50.617]   - Field: ‘packages’
[08:27:50.617]   - Field: ‘gc’
[08:27:50.617]   - Field: ‘conditions’
[08:27:50.617]   - Field: ‘expr’
[08:27:50.617]   - Field: ‘uuid’
[08:27:50.617]   - Field: ‘seed’
[08:27:50.618]   - Field: ‘version’
[08:27:50.618]   - Field: ‘result’
[08:27:50.618]   - Field: ‘asynchronous’
[08:27:50.618]   - Field: ‘calls’
[08:27:50.618]   - Field: ‘globals’
[08:27:50.618]   - Field: ‘stdout’
[08:27:50.618]   - Field: ‘earlySignal’
[08:27:50.618]   - Field: ‘lazy’
[08:27:50.618]   - Field: ‘state’
[08:27:50.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.618] - Launch lazy future ...
[08:27:50.619] Packages needed by the future expression (n = 0): <none>
[08:27:50.619] Packages needed by future strategies (n = 0): <none>
[08:27:50.619] {
[08:27:50.619]     {
[08:27:50.619]         {
[08:27:50.619]             ...future.startTime <- base::Sys.time()
[08:27:50.619]             {
[08:27:50.619]                 {
[08:27:50.619]                   {
[08:27:50.619]                     base::local({
[08:27:50.619]                       has_future <- base::requireNamespace("future", 
[08:27:50.619]                         quietly = TRUE)
[08:27:50.619]                       if (has_future) {
[08:27:50.619]                         ns <- base::getNamespace("future")
[08:27:50.619]                         version <- ns[[".package"]][["version"]]
[08:27:50.619]                         if (is.null(version)) 
[08:27:50.619]                           version <- utils::packageVersion("future")
[08:27:50.619]                       }
[08:27:50.619]                       else {
[08:27:50.619]                         version <- NULL
[08:27:50.619]                       }
[08:27:50.619]                       if (!has_future || version < "1.8.0") {
[08:27:50.619]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.619]                           "", base::R.version$version.string), 
[08:27:50.619]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.619]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.619]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.619]                             "release", "version")], collapse = " "), 
[08:27:50.619]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.619]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.619]                           info)
[08:27:50.619]                         info <- base::paste(info, collapse = "; ")
[08:27:50.619]                         if (!has_future) {
[08:27:50.619]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.619]                             info)
[08:27:50.619]                         }
[08:27:50.619]                         else {
[08:27:50.619]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.619]                             info, version)
[08:27:50.619]                         }
[08:27:50.619]                         base::stop(msg)
[08:27:50.619]                       }
[08:27:50.619]                     })
[08:27:50.619]                   }
[08:27:50.619]                   ...future.strategy.old <- future::plan("list")
[08:27:50.619]                   options(future.plan = NULL)
[08:27:50.619]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.619]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.619]                 }
[08:27:50.619]                 ...future.workdir <- getwd()
[08:27:50.619]             }
[08:27:50.619]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.619]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.619]         }
[08:27:50.619]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.619]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.619]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.619]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.619]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.619]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.619]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.619]             base::names(...future.oldOptions))
[08:27:50.619]     }
[08:27:50.619]     if (FALSE) {
[08:27:50.619]     }
[08:27:50.619]     else {
[08:27:50.619]         if (TRUE) {
[08:27:50.619]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.619]                 open = "w")
[08:27:50.619]         }
[08:27:50.619]         else {
[08:27:50.619]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.619]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.619]         }
[08:27:50.619]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.619]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.619]             base::sink(type = "output", split = FALSE)
[08:27:50.619]             base::close(...future.stdout)
[08:27:50.619]         }, add = TRUE)
[08:27:50.619]     }
[08:27:50.619]     ...future.frame <- base::sys.nframe()
[08:27:50.619]     ...future.conditions <- base::list()
[08:27:50.619]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.619]     if (FALSE) {
[08:27:50.619]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.619]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.619]     }
[08:27:50.619]     ...future.result <- base::tryCatch({
[08:27:50.619]         base::withCallingHandlers({
[08:27:50.619]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.619]             future::FutureResult(value = ...future.value$value, 
[08:27:50.619]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.619]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.619]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.619]                     ...future.globalenv.names))
[08:27:50.619]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.619]         }, condition = base::local({
[08:27:50.619]             c <- base::c
[08:27:50.619]             inherits <- base::inherits
[08:27:50.619]             invokeRestart <- base::invokeRestart
[08:27:50.619]             length <- base::length
[08:27:50.619]             list <- base::list
[08:27:50.619]             seq.int <- base::seq.int
[08:27:50.619]             signalCondition <- base::signalCondition
[08:27:50.619]             sys.calls <- base::sys.calls
[08:27:50.619]             `[[` <- base::`[[`
[08:27:50.619]             `+` <- base::`+`
[08:27:50.619]             `<<-` <- base::`<<-`
[08:27:50.619]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.619]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.619]                   3L)]
[08:27:50.619]             }
[08:27:50.619]             function(cond) {
[08:27:50.619]                 is_error <- inherits(cond, "error")
[08:27:50.619]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.619]                   NULL)
[08:27:50.619]                 if (is_error) {
[08:27:50.619]                   sessionInformation <- function() {
[08:27:50.619]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.619]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.619]                       search = base::search(), system = base::Sys.info())
[08:27:50.619]                   }
[08:27:50.619]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.619]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.619]                     cond$call), session = sessionInformation(), 
[08:27:50.619]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.619]                   signalCondition(cond)
[08:27:50.619]                 }
[08:27:50.619]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.619]                 "immediateCondition"))) {
[08:27:50.619]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.619]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.619]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.619]                   if (TRUE && !signal) {
[08:27:50.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.619]                     {
[08:27:50.619]                       inherits <- base::inherits
[08:27:50.619]                       invokeRestart <- base::invokeRestart
[08:27:50.619]                       is.null <- base::is.null
[08:27:50.619]                       muffled <- FALSE
[08:27:50.619]                       if (inherits(cond, "message")) {
[08:27:50.619]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.619]                         if (muffled) 
[08:27:50.619]                           invokeRestart("muffleMessage")
[08:27:50.619]                       }
[08:27:50.619]                       else if (inherits(cond, "warning")) {
[08:27:50.619]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.619]                         if (muffled) 
[08:27:50.619]                           invokeRestart("muffleWarning")
[08:27:50.619]                       }
[08:27:50.619]                       else if (inherits(cond, "condition")) {
[08:27:50.619]                         if (!is.null(pattern)) {
[08:27:50.619]                           computeRestarts <- base::computeRestarts
[08:27:50.619]                           grepl <- base::grepl
[08:27:50.619]                           restarts <- computeRestarts(cond)
[08:27:50.619]                           for (restart in restarts) {
[08:27:50.619]                             name <- restart$name
[08:27:50.619]                             if (is.null(name)) 
[08:27:50.619]                               next
[08:27:50.619]                             if (!grepl(pattern, name)) 
[08:27:50.619]                               next
[08:27:50.619]                             invokeRestart(restart)
[08:27:50.619]                             muffled <- TRUE
[08:27:50.619]                             break
[08:27:50.619]                           }
[08:27:50.619]                         }
[08:27:50.619]                       }
[08:27:50.619]                       invisible(muffled)
[08:27:50.619]                     }
[08:27:50.619]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.619]                   }
[08:27:50.619]                 }
[08:27:50.619]                 else {
[08:27:50.619]                   if (TRUE) {
[08:27:50.619]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.619]                     {
[08:27:50.619]                       inherits <- base::inherits
[08:27:50.619]                       invokeRestart <- base::invokeRestart
[08:27:50.619]                       is.null <- base::is.null
[08:27:50.619]                       muffled <- FALSE
[08:27:50.619]                       if (inherits(cond, "message")) {
[08:27:50.619]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.619]                         if (muffled) 
[08:27:50.619]                           invokeRestart("muffleMessage")
[08:27:50.619]                       }
[08:27:50.619]                       else if (inherits(cond, "warning")) {
[08:27:50.619]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.619]                         if (muffled) 
[08:27:50.619]                           invokeRestart("muffleWarning")
[08:27:50.619]                       }
[08:27:50.619]                       else if (inherits(cond, "condition")) {
[08:27:50.619]                         if (!is.null(pattern)) {
[08:27:50.619]                           computeRestarts <- base::computeRestarts
[08:27:50.619]                           grepl <- base::grepl
[08:27:50.619]                           restarts <- computeRestarts(cond)
[08:27:50.619]                           for (restart in restarts) {
[08:27:50.619]                             name <- restart$name
[08:27:50.619]                             if (is.null(name)) 
[08:27:50.619]                               next
[08:27:50.619]                             if (!grepl(pattern, name)) 
[08:27:50.619]                               next
[08:27:50.619]                             invokeRestart(restart)
[08:27:50.619]                             muffled <- TRUE
[08:27:50.619]                             break
[08:27:50.619]                           }
[08:27:50.619]                         }
[08:27:50.619]                       }
[08:27:50.619]                       invisible(muffled)
[08:27:50.619]                     }
[08:27:50.619]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.619]                   }
[08:27:50.619]                 }
[08:27:50.619]             }
[08:27:50.619]         }))
[08:27:50.619]     }, error = function(ex) {
[08:27:50.619]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.619]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.619]                 ...future.rng), started = ...future.startTime, 
[08:27:50.619]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.619]             version = "1.8"), class = "FutureResult")
[08:27:50.619]     }, finally = {
[08:27:50.619]         if (!identical(...future.workdir, getwd())) 
[08:27:50.619]             setwd(...future.workdir)
[08:27:50.619]         {
[08:27:50.619]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.619]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.619]             }
[08:27:50.619]             base::options(...future.oldOptions)
[08:27:50.619]             if (.Platform$OS.type == "windows") {
[08:27:50.619]                 old_names <- names(...future.oldEnvVars)
[08:27:50.619]                 envs <- base::Sys.getenv()
[08:27:50.619]                 names <- names(envs)
[08:27:50.619]                 common <- intersect(names, old_names)
[08:27:50.619]                 added <- setdiff(names, old_names)
[08:27:50.619]                 removed <- setdiff(old_names, names)
[08:27:50.619]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.619]                   envs[common]]
[08:27:50.619]                 NAMES <- toupper(changed)
[08:27:50.619]                 args <- list()
[08:27:50.619]                 for (kk in seq_along(NAMES)) {
[08:27:50.619]                   name <- changed[[kk]]
[08:27:50.619]                   NAME <- NAMES[[kk]]
[08:27:50.619]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.619]                     next
[08:27:50.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.619]                 }
[08:27:50.619]                 NAMES <- toupper(added)
[08:27:50.619]                 for (kk in seq_along(NAMES)) {
[08:27:50.619]                   name <- added[[kk]]
[08:27:50.619]                   NAME <- NAMES[[kk]]
[08:27:50.619]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.619]                     next
[08:27:50.619]                   args[[name]] <- ""
[08:27:50.619]                 }
[08:27:50.619]                 NAMES <- toupper(removed)
[08:27:50.619]                 for (kk in seq_along(NAMES)) {
[08:27:50.619]                   name <- removed[[kk]]
[08:27:50.619]                   NAME <- NAMES[[kk]]
[08:27:50.619]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.619]                     next
[08:27:50.619]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.619]                 }
[08:27:50.619]                 if (length(args) > 0) 
[08:27:50.619]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.619]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.619]             }
[08:27:50.619]             else {
[08:27:50.619]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.619]             }
[08:27:50.619]             {
[08:27:50.619]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.619]                   0L) {
[08:27:50.619]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.619]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.619]                   base::options(opts)
[08:27:50.619]                 }
[08:27:50.619]                 {
[08:27:50.619]                   {
[08:27:50.619]                     NULL
[08:27:50.619]                     RNGkind("Mersenne-Twister")
[08:27:50.619]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.619]                       inherits = FALSE)
[08:27:50.619]                   }
[08:27:50.619]                   options(future.plan = NULL)
[08:27:50.619]                   if (is.na(NA_character_)) 
[08:27:50.619]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.619]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.619]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.619]                     .init = FALSE)
[08:27:50.619]                 }
[08:27:50.619]             }
[08:27:50.619]         }
[08:27:50.619]     })
[08:27:50.619]     if (TRUE) {
[08:27:50.619]         base::sink(type = "output", split = FALSE)
[08:27:50.619]         if (TRUE) {
[08:27:50.619]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.619]         }
[08:27:50.619]         else {
[08:27:50.619]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.619]         }
[08:27:50.619]         base::close(...future.stdout)
[08:27:50.619]         ...future.stdout <- NULL
[08:27:50.619]     }
[08:27:50.619]     ...future.result$conditions <- ...future.conditions
[08:27:50.619]     ...future.result$finished <- base::Sys.time()
[08:27:50.619]     ...future.result
[08:27:50.619] }
[08:27:50.621] plan(): Setting new future strategy stack:
[08:27:50.621] List of future strategies:
[08:27:50.621] 1. sequential:
[08:27:50.621]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.621]    - tweaked: FALSE
[08:27:50.621]    - call: NULL
[08:27:50.621] plan(): nbrOfWorkers() = 1
[08:27:50.622] plan(): Setting new future strategy stack:
[08:27:50.622] List of future strategies:
[08:27:50.622] 1. sequential:
[08:27:50.622]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.622]    - tweaked: FALSE
[08:27:50.622]    - call: plan(strategy)
[08:27:50.623] plan(): nbrOfWorkers() = 1
[08:27:50.623] SequentialFuture started (and completed)
[08:27:50.623] - Launch lazy future ... done
[08:27:50.623] run() for ‘SequentialFuture’ ... done
[08:27:50.623] getGlobalsAndPackages() ...
[08:27:50.623] Searching for globals...
[08:27:50.654] - globals found: [1] ‘{’
[08:27:50.654] Searching for globals ... DONE
[08:27:50.654] Resolving globals: FALSE
[08:27:50.654] 
[08:27:50.655] 
[08:27:50.655] getGlobalsAndPackages() ... DONE
[08:27:50.655] run() for ‘Future’ ...
[08:27:50.655] - state: ‘created’
[08:27:50.655] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.656] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.656]   - Field: ‘label’
[08:27:50.656]   - Field: ‘local’
[08:27:50.656]   - Field: ‘owner’
[08:27:50.656]   - Field: ‘envir’
[08:27:50.656]   - Field: ‘packages’
[08:27:50.656]   - Field: ‘gc’
[08:27:50.656]   - Field: ‘conditions’
[08:27:50.656]   - Field: ‘expr’
[08:27:50.657]   - Field: ‘uuid’
[08:27:50.657]   - Field: ‘seed’
[08:27:50.657]   - Field: ‘version’
[08:27:50.657]   - Field: ‘result’
[08:27:50.657]   - Field: ‘asynchronous’
[08:27:50.657]   - Field: ‘calls’
[08:27:50.657]   - Field: ‘globals’
[08:27:50.657]   - Field: ‘stdout’
[08:27:50.657]   - Field: ‘earlySignal’
[08:27:50.657]   - Field: ‘lazy’
[08:27:50.657]   - Field: ‘state’
[08:27:50.658] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.658] - Launch lazy future ...
[08:27:50.658] Packages needed by the future expression (n = 0): <none>
[08:27:50.658] Packages needed by future strategies (n = 0): <none>
[08:27:50.658] {
[08:27:50.658]     {
[08:27:50.658]         {
[08:27:50.658]             ...future.startTime <- base::Sys.time()
[08:27:50.658]             {
[08:27:50.658]                 {
[08:27:50.658]                   {
[08:27:50.658]                     base::local({
[08:27:50.658]                       has_future <- base::requireNamespace("future", 
[08:27:50.658]                         quietly = TRUE)
[08:27:50.658]                       if (has_future) {
[08:27:50.658]                         ns <- base::getNamespace("future")
[08:27:50.658]                         version <- ns[[".package"]][["version"]]
[08:27:50.658]                         if (is.null(version)) 
[08:27:50.658]                           version <- utils::packageVersion("future")
[08:27:50.658]                       }
[08:27:50.658]                       else {
[08:27:50.658]                         version <- NULL
[08:27:50.658]                       }
[08:27:50.658]                       if (!has_future || version < "1.8.0") {
[08:27:50.658]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.658]                           "", base::R.version$version.string), 
[08:27:50.658]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.658]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.658]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.658]                             "release", "version")], collapse = " "), 
[08:27:50.658]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.658]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.658]                           info)
[08:27:50.658]                         info <- base::paste(info, collapse = "; ")
[08:27:50.658]                         if (!has_future) {
[08:27:50.658]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.658]                             info)
[08:27:50.658]                         }
[08:27:50.658]                         else {
[08:27:50.658]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.658]                             info, version)
[08:27:50.658]                         }
[08:27:50.658]                         base::stop(msg)
[08:27:50.658]                       }
[08:27:50.658]                     })
[08:27:50.658]                   }
[08:27:50.658]                   ...future.strategy.old <- future::plan("list")
[08:27:50.658]                   options(future.plan = NULL)
[08:27:50.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.658]                 }
[08:27:50.658]                 ...future.workdir <- getwd()
[08:27:50.658]             }
[08:27:50.658]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.658]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.658]         }
[08:27:50.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.658]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.658]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.658]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.658]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.658]             base::names(...future.oldOptions))
[08:27:50.658]     }
[08:27:50.658]     if (FALSE) {
[08:27:50.658]     }
[08:27:50.658]     else {
[08:27:50.658]         if (TRUE) {
[08:27:50.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.658]                 open = "w")
[08:27:50.658]         }
[08:27:50.658]         else {
[08:27:50.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.658]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.658]         }
[08:27:50.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.658]             base::sink(type = "output", split = FALSE)
[08:27:50.658]             base::close(...future.stdout)
[08:27:50.658]         }, add = TRUE)
[08:27:50.658]     }
[08:27:50.658]     ...future.frame <- base::sys.nframe()
[08:27:50.658]     ...future.conditions <- base::list()
[08:27:50.658]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.658]     if (FALSE) {
[08:27:50.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.658]     }
[08:27:50.658]     ...future.result <- base::tryCatch({
[08:27:50.658]         base::withCallingHandlers({
[08:27:50.658]             ...future.value <- base::withVisible(base::local({
[08:27:50.658]                 4
[08:27:50.658]             }))
[08:27:50.658]             future::FutureResult(value = ...future.value$value, 
[08:27:50.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.658]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.658]                     ...future.globalenv.names))
[08:27:50.658]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.658]         }, condition = base::local({
[08:27:50.658]             c <- base::c
[08:27:50.658]             inherits <- base::inherits
[08:27:50.658]             invokeRestart <- base::invokeRestart
[08:27:50.658]             length <- base::length
[08:27:50.658]             list <- base::list
[08:27:50.658]             seq.int <- base::seq.int
[08:27:50.658]             signalCondition <- base::signalCondition
[08:27:50.658]             sys.calls <- base::sys.calls
[08:27:50.658]             `[[` <- base::`[[`
[08:27:50.658]             `+` <- base::`+`
[08:27:50.658]             `<<-` <- base::`<<-`
[08:27:50.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.658]                   3L)]
[08:27:50.658]             }
[08:27:50.658]             function(cond) {
[08:27:50.658]                 is_error <- inherits(cond, "error")
[08:27:50.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.658]                   NULL)
[08:27:50.658]                 if (is_error) {
[08:27:50.658]                   sessionInformation <- function() {
[08:27:50.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.658]                       search = base::search(), system = base::Sys.info())
[08:27:50.658]                   }
[08:27:50.658]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.658]                     cond$call), session = sessionInformation(), 
[08:27:50.658]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.658]                   signalCondition(cond)
[08:27:50.658]                 }
[08:27:50.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.658]                 "immediateCondition"))) {
[08:27:50.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.658]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.658]                   if (TRUE && !signal) {
[08:27:50.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.658]                     {
[08:27:50.658]                       inherits <- base::inherits
[08:27:50.658]                       invokeRestart <- base::invokeRestart
[08:27:50.658]                       is.null <- base::is.null
[08:27:50.658]                       muffled <- FALSE
[08:27:50.658]                       if (inherits(cond, "message")) {
[08:27:50.658]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.658]                         if (muffled) 
[08:27:50.658]                           invokeRestart("muffleMessage")
[08:27:50.658]                       }
[08:27:50.658]                       else if (inherits(cond, "warning")) {
[08:27:50.658]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.658]                         if (muffled) 
[08:27:50.658]                           invokeRestart("muffleWarning")
[08:27:50.658]                       }
[08:27:50.658]                       else if (inherits(cond, "condition")) {
[08:27:50.658]                         if (!is.null(pattern)) {
[08:27:50.658]                           computeRestarts <- base::computeRestarts
[08:27:50.658]                           grepl <- base::grepl
[08:27:50.658]                           restarts <- computeRestarts(cond)
[08:27:50.658]                           for (restart in restarts) {
[08:27:50.658]                             name <- restart$name
[08:27:50.658]                             if (is.null(name)) 
[08:27:50.658]                               next
[08:27:50.658]                             if (!grepl(pattern, name)) 
[08:27:50.658]                               next
[08:27:50.658]                             invokeRestart(restart)
[08:27:50.658]                             muffled <- TRUE
[08:27:50.658]                             break
[08:27:50.658]                           }
[08:27:50.658]                         }
[08:27:50.658]                       }
[08:27:50.658]                       invisible(muffled)
[08:27:50.658]                     }
[08:27:50.658]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.658]                   }
[08:27:50.658]                 }
[08:27:50.658]                 else {
[08:27:50.658]                   if (TRUE) {
[08:27:50.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.658]                     {
[08:27:50.658]                       inherits <- base::inherits
[08:27:50.658]                       invokeRestart <- base::invokeRestart
[08:27:50.658]                       is.null <- base::is.null
[08:27:50.658]                       muffled <- FALSE
[08:27:50.658]                       if (inherits(cond, "message")) {
[08:27:50.658]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.658]                         if (muffled) 
[08:27:50.658]                           invokeRestart("muffleMessage")
[08:27:50.658]                       }
[08:27:50.658]                       else if (inherits(cond, "warning")) {
[08:27:50.658]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.658]                         if (muffled) 
[08:27:50.658]                           invokeRestart("muffleWarning")
[08:27:50.658]                       }
[08:27:50.658]                       else if (inherits(cond, "condition")) {
[08:27:50.658]                         if (!is.null(pattern)) {
[08:27:50.658]                           computeRestarts <- base::computeRestarts
[08:27:50.658]                           grepl <- base::grepl
[08:27:50.658]                           restarts <- computeRestarts(cond)
[08:27:50.658]                           for (restart in restarts) {
[08:27:50.658]                             name <- restart$name
[08:27:50.658]                             if (is.null(name)) 
[08:27:50.658]                               next
[08:27:50.658]                             if (!grepl(pattern, name)) 
[08:27:50.658]                               next
[08:27:50.658]                             invokeRestart(restart)
[08:27:50.658]                             muffled <- TRUE
[08:27:50.658]                             break
[08:27:50.658]                           }
[08:27:50.658]                         }
[08:27:50.658]                       }
[08:27:50.658]                       invisible(muffled)
[08:27:50.658]                     }
[08:27:50.658]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.658]                   }
[08:27:50.658]                 }
[08:27:50.658]             }
[08:27:50.658]         }))
[08:27:50.658]     }, error = function(ex) {
[08:27:50.658]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.658]                 ...future.rng), started = ...future.startTime, 
[08:27:50.658]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.658]             version = "1.8"), class = "FutureResult")
[08:27:50.658]     }, finally = {
[08:27:50.658]         if (!identical(...future.workdir, getwd())) 
[08:27:50.658]             setwd(...future.workdir)
[08:27:50.658]         {
[08:27:50.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.658]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.658]             }
[08:27:50.658]             base::options(...future.oldOptions)
[08:27:50.658]             if (.Platform$OS.type == "windows") {
[08:27:50.658]                 old_names <- names(...future.oldEnvVars)
[08:27:50.658]                 envs <- base::Sys.getenv()
[08:27:50.658]                 names <- names(envs)
[08:27:50.658]                 common <- intersect(names, old_names)
[08:27:50.658]                 added <- setdiff(names, old_names)
[08:27:50.658]                 removed <- setdiff(old_names, names)
[08:27:50.658]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.658]                   envs[common]]
[08:27:50.658]                 NAMES <- toupper(changed)
[08:27:50.658]                 args <- list()
[08:27:50.658]                 for (kk in seq_along(NAMES)) {
[08:27:50.658]                   name <- changed[[kk]]
[08:27:50.658]                   NAME <- NAMES[[kk]]
[08:27:50.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.658]                     next
[08:27:50.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.658]                 }
[08:27:50.658]                 NAMES <- toupper(added)
[08:27:50.658]                 for (kk in seq_along(NAMES)) {
[08:27:50.658]                   name <- added[[kk]]
[08:27:50.658]                   NAME <- NAMES[[kk]]
[08:27:50.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.658]                     next
[08:27:50.658]                   args[[name]] <- ""
[08:27:50.658]                 }
[08:27:50.658]                 NAMES <- toupper(removed)
[08:27:50.658]                 for (kk in seq_along(NAMES)) {
[08:27:50.658]                   name <- removed[[kk]]
[08:27:50.658]                   NAME <- NAMES[[kk]]
[08:27:50.658]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.658]                     next
[08:27:50.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.658]                 }
[08:27:50.658]                 if (length(args) > 0) 
[08:27:50.658]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.658]             }
[08:27:50.658]             else {
[08:27:50.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.658]             }
[08:27:50.658]             {
[08:27:50.658]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.658]                   0L) {
[08:27:50.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.658]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.658]                   base::options(opts)
[08:27:50.658]                 }
[08:27:50.658]                 {
[08:27:50.658]                   {
[08:27:50.658]                     NULL
[08:27:50.658]                     RNGkind("Mersenne-Twister")
[08:27:50.658]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.658]                       inherits = FALSE)
[08:27:50.658]                   }
[08:27:50.658]                   options(future.plan = NULL)
[08:27:50.658]                   if (is.na(NA_character_)) 
[08:27:50.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.658]                     .init = FALSE)
[08:27:50.658]                 }
[08:27:50.658]             }
[08:27:50.658]         }
[08:27:50.658]     })
[08:27:50.658]     if (TRUE) {
[08:27:50.658]         base::sink(type = "output", split = FALSE)
[08:27:50.658]         if (TRUE) {
[08:27:50.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.658]         }
[08:27:50.658]         else {
[08:27:50.658]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.658]         }
[08:27:50.658]         base::close(...future.stdout)
[08:27:50.658]         ...future.stdout <- NULL
[08:27:50.658]     }
[08:27:50.658]     ...future.result$conditions <- ...future.conditions
[08:27:50.658]     ...future.result$finished <- base::Sys.time()
[08:27:50.658]     ...future.result
[08:27:50.658] }
[08:27:50.660] plan(): Setting new future strategy stack:
[08:27:50.660] List of future strategies:
[08:27:50.660] 1. sequential:
[08:27:50.660]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.660]    - tweaked: FALSE
[08:27:50.660]    - call: NULL
[08:27:50.661] plan(): nbrOfWorkers() = 1
[08:27:50.662] plan(): Setting new future strategy stack:
[08:27:50.662] List of future strategies:
[08:27:50.662] 1. sequential:
[08:27:50.662]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.662]    - tweaked: FALSE
[08:27:50.662]    - call: plan(strategy)
[08:27:50.662] plan(): nbrOfWorkers() = 1
[08:27:50.662] SequentialFuture started (and completed)
[08:27:50.662] - Launch lazy future ... done
[08:27:50.662] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d86037e310> 
Classes 'listenv', 'environment' <environment: 0x55d85ed68a00> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[08:27:50.666] resolved() for ‘SequentialFuture’ ...
[08:27:50.666] - state: ‘finished’
[08:27:50.666] - run: TRUE
[08:27:50.666] - result: ‘FutureResult’
[08:27:50.666] resolved() for ‘SequentialFuture’ ... done
[08:27:50.666] resolved() for ‘SequentialFuture’ ...
[08:27:50.667] - state: ‘finished’
[08:27:50.667] - run: TRUE
[08:27:50.667] - result: ‘FutureResult’
[08:27:50.667] resolved() for ‘SequentialFuture’ ... done
[08:27:50.667] resolved() for ‘SequentialFuture’ ...
[08:27:50.667] - state: ‘finished’
[08:27:50.667] - run: TRUE
[08:27:50.667] - result: ‘FutureResult’
[08:27:50.667] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:50.669] resolve() on list environment ...
[08:27:50.669]  recursive: 0
[08:27:50.670]  length: 6
[08:27:50.670]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:50.671] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.671] - nx: 6
[08:27:50.671] - relay: TRUE
[08:27:50.671] - stdout: TRUE
[08:27:50.671] - signal: TRUE
[08:27:50.671] - resignal: FALSE
[08:27:50.671] - force: TRUE
[08:27:50.671] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.671] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.671]  - until=2
[08:27:50.671]  - relaying element #2
[08:27:50.671] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.672] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.672] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.672]  length: 5 (resolved future 1)
[08:27:50.672] resolved() for ‘SequentialFuture’ ...
[08:27:50.672] - state: ‘finished’
[08:27:50.672] - run: TRUE
[08:27:50.672] - result: ‘FutureResult’
[08:27:50.672] resolved() for ‘SequentialFuture’ ... done
[08:27:50.672] Future #2
[08:27:50.672] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.673] - nx: 6
[08:27:50.673] - relay: TRUE
[08:27:50.673] - stdout: TRUE
[08:27:50.673] - signal: TRUE
[08:27:50.673] - resignal: FALSE
[08:27:50.673] - force: TRUE
[08:27:50.673] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.673] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.673]  - until=2
[08:27:50.673]  - relaying element #2
[08:27:50.673] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.673] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.674] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.674]  length: 4 (resolved future 2)
[08:27:50.674] resolved() for ‘SequentialFuture’ ...
[08:27:50.674] - state: ‘finished’
[08:27:50.674] - run: TRUE
[08:27:50.674] - result: ‘FutureResult’
[08:27:50.674] resolved() for ‘SequentialFuture’ ... done
[08:27:50.674] Future #3
[08:27:50.674] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.674] - nx: 6
[08:27:50.675] - relay: TRUE
[08:27:50.675] - stdout: TRUE
[08:27:50.675] - signal: TRUE
[08:27:50.675] - resignal: FALSE
[08:27:50.675] - force: TRUE
[08:27:50.675] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.675] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.675]  - until=3
[08:27:50.675]  - relaying element #3
[08:27:50.675] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.675] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.676] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.676]  length: 3 (resolved future 3)
[08:27:50.676] resolved() for ‘SequentialFuture’ ...
[08:27:50.676] - state: ‘finished’
[08:27:50.676] - run: TRUE
[08:27:50.676] - result: ‘FutureResult’
[08:27:50.676] resolved() for ‘SequentialFuture’ ... done
[08:27:50.676] Future #4
[08:27:50.676] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.676] - nx: 6
[08:27:50.676] - relay: TRUE
[08:27:50.677] - stdout: TRUE
[08:27:50.677] - signal: TRUE
[08:27:50.677] - resignal: FALSE
[08:27:50.677] - force: TRUE
[08:27:50.677] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.677] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.677]  - until=4
[08:27:50.677]  - relaying element #4
[08:27:50.677] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.677] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.677] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.678]  length: 2 (resolved future 4)
[08:27:50.678] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.678] - nx: 6
[08:27:50.678] - relay: TRUE
[08:27:50.678] - stdout: TRUE
[08:27:50.678] - signal: TRUE
[08:27:50.678] - resignal: FALSE
[08:27:50.678] - force: TRUE
[08:27:50.678] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.678] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.678]  - until=6
[08:27:50.678]  - relaying element #6
[08:27:50.679] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.679] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.679] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.679]  length: 1 (resolved future 5)
[08:27:50.679] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.679] - nx: 6
[08:27:50.679] - relay: TRUE
[08:27:50.681] - stdout: TRUE
[08:27:50.681] - signal: TRUE
[08:27:50.681] - resignal: FALSE
[08:27:50.681] - force: TRUE
[08:27:50.681] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.681] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.681]  - until=6
[08:27:50.681] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.681] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.681] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.682]  length: 0 (resolved future 6)
[08:27:50.682] Relaying remaining futures
[08:27:50.682] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.682] - nx: 6
[08:27:50.682] - relay: TRUE
[08:27:50.682] - stdout: TRUE
[08:27:50.682] - signal: TRUE
[08:27:50.682] - resignal: FALSE
[08:27:50.682] - force: TRUE
[08:27:50.682] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.682] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:50.683] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.683] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.683] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.683] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55d860a4eb18> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[08:27:50.685] getGlobalsAndPackages() ...
[08:27:50.685] Searching for globals...
[08:27:50.685] 
[08:27:50.685] Searching for globals ... DONE
[08:27:50.685] - globals: [0] <none>
[08:27:50.686] getGlobalsAndPackages() ... DONE
[08:27:50.686] run() for ‘Future’ ...
[08:27:50.686] - state: ‘created’
[08:27:50.686] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.686] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.686] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.686]   - Field: ‘label’
[08:27:50.687]   - Field: ‘local’
[08:27:50.687]   - Field: ‘owner’
[08:27:50.687]   - Field: ‘envir’
[08:27:50.687]   - Field: ‘packages’
[08:27:50.687]   - Field: ‘gc’
[08:27:50.687]   - Field: ‘conditions’
[08:27:50.687]   - Field: ‘expr’
[08:27:50.687]   - Field: ‘uuid’
[08:27:50.687]   - Field: ‘seed’
[08:27:50.687]   - Field: ‘version’
[08:27:50.687]   - Field: ‘result’
[08:27:50.687]   - Field: ‘asynchronous’
[08:27:50.688]   - Field: ‘calls’
[08:27:50.688]   - Field: ‘globals’
[08:27:50.688]   - Field: ‘stdout’
[08:27:50.688]   - Field: ‘earlySignal’
[08:27:50.688]   - Field: ‘lazy’
[08:27:50.688]   - Field: ‘state’
[08:27:50.688] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.688] - Launch lazy future ...
[08:27:50.688] Packages needed by the future expression (n = 0): <none>
[08:27:50.688] Packages needed by future strategies (n = 0): <none>
[08:27:50.689] {
[08:27:50.689]     {
[08:27:50.689]         {
[08:27:50.689]             ...future.startTime <- base::Sys.time()
[08:27:50.689]             {
[08:27:50.689]                 {
[08:27:50.689]                   {
[08:27:50.689]                     base::local({
[08:27:50.689]                       has_future <- base::requireNamespace("future", 
[08:27:50.689]                         quietly = TRUE)
[08:27:50.689]                       if (has_future) {
[08:27:50.689]                         ns <- base::getNamespace("future")
[08:27:50.689]                         version <- ns[[".package"]][["version"]]
[08:27:50.689]                         if (is.null(version)) 
[08:27:50.689]                           version <- utils::packageVersion("future")
[08:27:50.689]                       }
[08:27:50.689]                       else {
[08:27:50.689]                         version <- NULL
[08:27:50.689]                       }
[08:27:50.689]                       if (!has_future || version < "1.8.0") {
[08:27:50.689]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.689]                           "", base::R.version$version.string), 
[08:27:50.689]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.689]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.689]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.689]                             "release", "version")], collapse = " "), 
[08:27:50.689]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.689]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.689]                           info)
[08:27:50.689]                         info <- base::paste(info, collapse = "; ")
[08:27:50.689]                         if (!has_future) {
[08:27:50.689]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.689]                             info)
[08:27:50.689]                         }
[08:27:50.689]                         else {
[08:27:50.689]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.689]                             info, version)
[08:27:50.689]                         }
[08:27:50.689]                         base::stop(msg)
[08:27:50.689]                       }
[08:27:50.689]                     })
[08:27:50.689]                   }
[08:27:50.689]                   ...future.strategy.old <- future::plan("list")
[08:27:50.689]                   options(future.plan = NULL)
[08:27:50.689]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.689]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.689]                 }
[08:27:50.689]                 ...future.workdir <- getwd()
[08:27:50.689]             }
[08:27:50.689]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.689]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.689]         }
[08:27:50.689]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.689]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.689]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.689]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.689]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.689]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.689]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.689]             base::names(...future.oldOptions))
[08:27:50.689]     }
[08:27:50.689]     if (FALSE) {
[08:27:50.689]     }
[08:27:50.689]     else {
[08:27:50.689]         if (TRUE) {
[08:27:50.689]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.689]                 open = "w")
[08:27:50.689]         }
[08:27:50.689]         else {
[08:27:50.689]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.689]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.689]         }
[08:27:50.689]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.689]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.689]             base::sink(type = "output", split = FALSE)
[08:27:50.689]             base::close(...future.stdout)
[08:27:50.689]         }, add = TRUE)
[08:27:50.689]     }
[08:27:50.689]     ...future.frame <- base::sys.nframe()
[08:27:50.689]     ...future.conditions <- base::list()
[08:27:50.689]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.689]     if (FALSE) {
[08:27:50.689]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.689]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.689]     }
[08:27:50.689]     ...future.result <- base::tryCatch({
[08:27:50.689]         base::withCallingHandlers({
[08:27:50.689]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.689]             future::FutureResult(value = ...future.value$value, 
[08:27:50.689]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.689]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.689]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.689]                     ...future.globalenv.names))
[08:27:50.689]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.689]         }, condition = base::local({
[08:27:50.689]             c <- base::c
[08:27:50.689]             inherits <- base::inherits
[08:27:50.689]             invokeRestart <- base::invokeRestart
[08:27:50.689]             length <- base::length
[08:27:50.689]             list <- base::list
[08:27:50.689]             seq.int <- base::seq.int
[08:27:50.689]             signalCondition <- base::signalCondition
[08:27:50.689]             sys.calls <- base::sys.calls
[08:27:50.689]             `[[` <- base::`[[`
[08:27:50.689]             `+` <- base::`+`
[08:27:50.689]             `<<-` <- base::`<<-`
[08:27:50.689]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.689]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.689]                   3L)]
[08:27:50.689]             }
[08:27:50.689]             function(cond) {
[08:27:50.689]                 is_error <- inherits(cond, "error")
[08:27:50.689]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.689]                   NULL)
[08:27:50.689]                 if (is_error) {
[08:27:50.689]                   sessionInformation <- function() {
[08:27:50.689]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.689]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.689]                       search = base::search(), system = base::Sys.info())
[08:27:50.689]                   }
[08:27:50.689]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.689]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.689]                     cond$call), session = sessionInformation(), 
[08:27:50.689]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.689]                   signalCondition(cond)
[08:27:50.689]                 }
[08:27:50.689]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.689]                 "immediateCondition"))) {
[08:27:50.689]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.689]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.689]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.689]                   if (TRUE && !signal) {
[08:27:50.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.689]                     {
[08:27:50.689]                       inherits <- base::inherits
[08:27:50.689]                       invokeRestart <- base::invokeRestart
[08:27:50.689]                       is.null <- base::is.null
[08:27:50.689]                       muffled <- FALSE
[08:27:50.689]                       if (inherits(cond, "message")) {
[08:27:50.689]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.689]                         if (muffled) 
[08:27:50.689]                           invokeRestart("muffleMessage")
[08:27:50.689]                       }
[08:27:50.689]                       else if (inherits(cond, "warning")) {
[08:27:50.689]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.689]                         if (muffled) 
[08:27:50.689]                           invokeRestart("muffleWarning")
[08:27:50.689]                       }
[08:27:50.689]                       else if (inherits(cond, "condition")) {
[08:27:50.689]                         if (!is.null(pattern)) {
[08:27:50.689]                           computeRestarts <- base::computeRestarts
[08:27:50.689]                           grepl <- base::grepl
[08:27:50.689]                           restarts <- computeRestarts(cond)
[08:27:50.689]                           for (restart in restarts) {
[08:27:50.689]                             name <- restart$name
[08:27:50.689]                             if (is.null(name)) 
[08:27:50.689]                               next
[08:27:50.689]                             if (!grepl(pattern, name)) 
[08:27:50.689]                               next
[08:27:50.689]                             invokeRestart(restart)
[08:27:50.689]                             muffled <- TRUE
[08:27:50.689]                             break
[08:27:50.689]                           }
[08:27:50.689]                         }
[08:27:50.689]                       }
[08:27:50.689]                       invisible(muffled)
[08:27:50.689]                     }
[08:27:50.689]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.689]                   }
[08:27:50.689]                 }
[08:27:50.689]                 else {
[08:27:50.689]                   if (TRUE) {
[08:27:50.689]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.689]                     {
[08:27:50.689]                       inherits <- base::inherits
[08:27:50.689]                       invokeRestart <- base::invokeRestart
[08:27:50.689]                       is.null <- base::is.null
[08:27:50.689]                       muffled <- FALSE
[08:27:50.689]                       if (inherits(cond, "message")) {
[08:27:50.689]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.689]                         if (muffled) 
[08:27:50.689]                           invokeRestart("muffleMessage")
[08:27:50.689]                       }
[08:27:50.689]                       else if (inherits(cond, "warning")) {
[08:27:50.689]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.689]                         if (muffled) 
[08:27:50.689]                           invokeRestart("muffleWarning")
[08:27:50.689]                       }
[08:27:50.689]                       else if (inherits(cond, "condition")) {
[08:27:50.689]                         if (!is.null(pattern)) {
[08:27:50.689]                           computeRestarts <- base::computeRestarts
[08:27:50.689]                           grepl <- base::grepl
[08:27:50.689]                           restarts <- computeRestarts(cond)
[08:27:50.689]                           for (restart in restarts) {
[08:27:50.689]                             name <- restart$name
[08:27:50.689]                             if (is.null(name)) 
[08:27:50.689]                               next
[08:27:50.689]                             if (!grepl(pattern, name)) 
[08:27:50.689]                               next
[08:27:50.689]                             invokeRestart(restart)
[08:27:50.689]                             muffled <- TRUE
[08:27:50.689]                             break
[08:27:50.689]                           }
[08:27:50.689]                         }
[08:27:50.689]                       }
[08:27:50.689]                       invisible(muffled)
[08:27:50.689]                     }
[08:27:50.689]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.689]                   }
[08:27:50.689]                 }
[08:27:50.689]             }
[08:27:50.689]         }))
[08:27:50.689]     }, error = function(ex) {
[08:27:50.689]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.689]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.689]                 ...future.rng), started = ...future.startTime, 
[08:27:50.689]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.689]             version = "1.8"), class = "FutureResult")
[08:27:50.689]     }, finally = {
[08:27:50.689]         if (!identical(...future.workdir, getwd())) 
[08:27:50.689]             setwd(...future.workdir)
[08:27:50.689]         {
[08:27:50.689]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.689]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.689]             }
[08:27:50.689]             base::options(...future.oldOptions)
[08:27:50.689]             if (.Platform$OS.type == "windows") {
[08:27:50.689]                 old_names <- names(...future.oldEnvVars)
[08:27:50.689]                 envs <- base::Sys.getenv()
[08:27:50.689]                 names <- names(envs)
[08:27:50.689]                 common <- intersect(names, old_names)
[08:27:50.689]                 added <- setdiff(names, old_names)
[08:27:50.689]                 removed <- setdiff(old_names, names)
[08:27:50.689]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.689]                   envs[common]]
[08:27:50.689]                 NAMES <- toupper(changed)
[08:27:50.689]                 args <- list()
[08:27:50.689]                 for (kk in seq_along(NAMES)) {
[08:27:50.689]                   name <- changed[[kk]]
[08:27:50.689]                   NAME <- NAMES[[kk]]
[08:27:50.689]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.689]                     next
[08:27:50.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.689]                 }
[08:27:50.689]                 NAMES <- toupper(added)
[08:27:50.689]                 for (kk in seq_along(NAMES)) {
[08:27:50.689]                   name <- added[[kk]]
[08:27:50.689]                   NAME <- NAMES[[kk]]
[08:27:50.689]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.689]                     next
[08:27:50.689]                   args[[name]] <- ""
[08:27:50.689]                 }
[08:27:50.689]                 NAMES <- toupper(removed)
[08:27:50.689]                 for (kk in seq_along(NAMES)) {
[08:27:50.689]                   name <- removed[[kk]]
[08:27:50.689]                   NAME <- NAMES[[kk]]
[08:27:50.689]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.689]                     next
[08:27:50.689]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.689]                 }
[08:27:50.689]                 if (length(args) > 0) 
[08:27:50.689]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.689]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.689]             }
[08:27:50.689]             else {
[08:27:50.689]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.689]             }
[08:27:50.689]             {
[08:27:50.689]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.689]                   0L) {
[08:27:50.689]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.689]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.689]                   base::options(opts)
[08:27:50.689]                 }
[08:27:50.689]                 {
[08:27:50.689]                   {
[08:27:50.689]                     NULL
[08:27:50.689]                     RNGkind("Mersenne-Twister")
[08:27:50.689]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.689]                       inherits = FALSE)
[08:27:50.689]                   }
[08:27:50.689]                   options(future.plan = NULL)
[08:27:50.689]                   if (is.na(NA_character_)) 
[08:27:50.689]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.689]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.689]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.689]                     .init = FALSE)
[08:27:50.689]                 }
[08:27:50.689]             }
[08:27:50.689]         }
[08:27:50.689]     })
[08:27:50.689]     if (TRUE) {
[08:27:50.689]         base::sink(type = "output", split = FALSE)
[08:27:50.689]         if (TRUE) {
[08:27:50.689]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.689]         }
[08:27:50.689]         else {
[08:27:50.689]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.689]         }
[08:27:50.689]         base::close(...future.stdout)
[08:27:50.689]         ...future.stdout <- NULL
[08:27:50.689]     }
[08:27:50.689]     ...future.result$conditions <- ...future.conditions
[08:27:50.689]     ...future.result$finished <- base::Sys.time()
[08:27:50.689]     ...future.result
[08:27:50.689] }
[08:27:50.691] plan(): Setting new future strategy stack:
[08:27:50.691] List of future strategies:
[08:27:50.691] 1. sequential:
[08:27:50.691]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.691]    - tweaked: FALSE
[08:27:50.691]    - call: NULL
[08:27:50.691] plan(): nbrOfWorkers() = 1
[08:27:50.692] plan(): Setting new future strategy stack:
[08:27:50.692] List of future strategies:
[08:27:50.692] 1. sequential:
[08:27:50.692]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.692]    - tweaked: FALSE
[08:27:50.692]    - call: plan(strategy)
[08:27:50.693] plan(): nbrOfWorkers() = 1
[08:27:50.693] SequentialFuture started (and completed)
[08:27:50.693] - Launch lazy future ... done
[08:27:50.693] run() for ‘SequentialFuture’ ... done
[08:27:50.693] getGlobalsAndPackages() ...
[08:27:50.693] Searching for globals...
[08:27:50.693] 
[08:27:50.693] Searching for globals ... DONE
[08:27:50.694] - globals: [0] <none>
[08:27:50.694] getGlobalsAndPackages() ... DONE
[08:27:50.694] run() for ‘Future’ ...
[08:27:50.694] - state: ‘created’
[08:27:50.694] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.694] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.694] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.695]   - Field: ‘label’
[08:27:50.695]   - Field: ‘local’
[08:27:50.695]   - Field: ‘owner’
[08:27:50.695]   - Field: ‘envir’
[08:27:50.695]   - Field: ‘packages’
[08:27:50.695]   - Field: ‘gc’
[08:27:50.695]   - Field: ‘conditions’
[08:27:50.695]   - Field: ‘expr’
[08:27:50.695]   - Field: ‘uuid’
[08:27:50.695]   - Field: ‘seed’
[08:27:50.695]   - Field: ‘version’
[08:27:50.695]   - Field: ‘result’
[08:27:50.696]   - Field: ‘asynchronous’
[08:27:50.696]   - Field: ‘calls’
[08:27:50.696]   - Field: ‘globals’
[08:27:50.696]   - Field: ‘stdout’
[08:27:50.696]   - Field: ‘earlySignal’
[08:27:50.696]   - Field: ‘lazy’
[08:27:50.696]   - Field: ‘state’
[08:27:50.696] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.696] - Launch lazy future ...
[08:27:50.696] Packages needed by the future expression (n = 0): <none>
[08:27:50.696] Packages needed by future strategies (n = 0): <none>
[08:27:50.697] {
[08:27:50.697]     {
[08:27:50.697]         {
[08:27:50.697]             ...future.startTime <- base::Sys.time()
[08:27:50.697]             {
[08:27:50.697]                 {
[08:27:50.697]                   {
[08:27:50.697]                     base::local({
[08:27:50.697]                       has_future <- base::requireNamespace("future", 
[08:27:50.697]                         quietly = TRUE)
[08:27:50.697]                       if (has_future) {
[08:27:50.697]                         ns <- base::getNamespace("future")
[08:27:50.697]                         version <- ns[[".package"]][["version"]]
[08:27:50.697]                         if (is.null(version)) 
[08:27:50.697]                           version <- utils::packageVersion("future")
[08:27:50.697]                       }
[08:27:50.697]                       else {
[08:27:50.697]                         version <- NULL
[08:27:50.697]                       }
[08:27:50.697]                       if (!has_future || version < "1.8.0") {
[08:27:50.697]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.697]                           "", base::R.version$version.string), 
[08:27:50.697]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.697]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.697]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.697]                             "release", "version")], collapse = " "), 
[08:27:50.697]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.697]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.697]                           info)
[08:27:50.697]                         info <- base::paste(info, collapse = "; ")
[08:27:50.697]                         if (!has_future) {
[08:27:50.697]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.697]                             info)
[08:27:50.697]                         }
[08:27:50.697]                         else {
[08:27:50.697]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.697]                             info, version)
[08:27:50.697]                         }
[08:27:50.697]                         base::stop(msg)
[08:27:50.697]                       }
[08:27:50.697]                     })
[08:27:50.697]                   }
[08:27:50.697]                   ...future.strategy.old <- future::plan("list")
[08:27:50.697]                   options(future.plan = NULL)
[08:27:50.697]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.697]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.697]                 }
[08:27:50.697]                 ...future.workdir <- getwd()
[08:27:50.697]             }
[08:27:50.697]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.697]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.697]         }
[08:27:50.697]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.697]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.697]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.697]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.697]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.697]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.697]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.697]             base::names(...future.oldOptions))
[08:27:50.697]     }
[08:27:50.697]     if (FALSE) {
[08:27:50.697]     }
[08:27:50.697]     else {
[08:27:50.697]         if (TRUE) {
[08:27:50.697]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.697]                 open = "w")
[08:27:50.697]         }
[08:27:50.697]         else {
[08:27:50.697]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.697]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.697]         }
[08:27:50.697]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.697]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.697]             base::sink(type = "output", split = FALSE)
[08:27:50.697]             base::close(...future.stdout)
[08:27:50.697]         }, add = TRUE)
[08:27:50.697]     }
[08:27:50.697]     ...future.frame <- base::sys.nframe()
[08:27:50.697]     ...future.conditions <- base::list()
[08:27:50.697]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.697]     if (FALSE) {
[08:27:50.697]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.697]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.697]     }
[08:27:50.697]     ...future.result <- base::tryCatch({
[08:27:50.697]         base::withCallingHandlers({
[08:27:50.697]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.697]             future::FutureResult(value = ...future.value$value, 
[08:27:50.697]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.697]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.697]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.697]                     ...future.globalenv.names))
[08:27:50.697]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.697]         }, condition = base::local({
[08:27:50.697]             c <- base::c
[08:27:50.697]             inherits <- base::inherits
[08:27:50.697]             invokeRestart <- base::invokeRestart
[08:27:50.697]             length <- base::length
[08:27:50.697]             list <- base::list
[08:27:50.697]             seq.int <- base::seq.int
[08:27:50.697]             signalCondition <- base::signalCondition
[08:27:50.697]             sys.calls <- base::sys.calls
[08:27:50.697]             `[[` <- base::`[[`
[08:27:50.697]             `+` <- base::`+`
[08:27:50.697]             `<<-` <- base::`<<-`
[08:27:50.697]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.697]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.697]                   3L)]
[08:27:50.697]             }
[08:27:50.697]             function(cond) {
[08:27:50.697]                 is_error <- inherits(cond, "error")
[08:27:50.697]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.697]                   NULL)
[08:27:50.697]                 if (is_error) {
[08:27:50.697]                   sessionInformation <- function() {
[08:27:50.697]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.697]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.697]                       search = base::search(), system = base::Sys.info())
[08:27:50.697]                   }
[08:27:50.697]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.697]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.697]                     cond$call), session = sessionInformation(), 
[08:27:50.697]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.697]                   signalCondition(cond)
[08:27:50.697]                 }
[08:27:50.697]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.697]                 "immediateCondition"))) {
[08:27:50.697]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.697]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.697]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.697]                   if (TRUE && !signal) {
[08:27:50.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.697]                     {
[08:27:50.697]                       inherits <- base::inherits
[08:27:50.697]                       invokeRestart <- base::invokeRestart
[08:27:50.697]                       is.null <- base::is.null
[08:27:50.697]                       muffled <- FALSE
[08:27:50.697]                       if (inherits(cond, "message")) {
[08:27:50.697]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.697]                         if (muffled) 
[08:27:50.697]                           invokeRestart("muffleMessage")
[08:27:50.697]                       }
[08:27:50.697]                       else if (inherits(cond, "warning")) {
[08:27:50.697]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.697]                         if (muffled) 
[08:27:50.697]                           invokeRestart("muffleWarning")
[08:27:50.697]                       }
[08:27:50.697]                       else if (inherits(cond, "condition")) {
[08:27:50.697]                         if (!is.null(pattern)) {
[08:27:50.697]                           computeRestarts <- base::computeRestarts
[08:27:50.697]                           grepl <- base::grepl
[08:27:50.697]                           restarts <- computeRestarts(cond)
[08:27:50.697]                           for (restart in restarts) {
[08:27:50.697]                             name <- restart$name
[08:27:50.697]                             if (is.null(name)) 
[08:27:50.697]                               next
[08:27:50.697]                             if (!grepl(pattern, name)) 
[08:27:50.697]                               next
[08:27:50.697]                             invokeRestart(restart)
[08:27:50.697]                             muffled <- TRUE
[08:27:50.697]                             break
[08:27:50.697]                           }
[08:27:50.697]                         }
[08:27:50.697]                       }
[08:27:50.697]                       invisible(muffled)
[08:27:50.697]                     }
[08:27:50.697]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.697]                   }
[08:27:50.697]                 }
[08:27:50.697]                 else {
[08:27:50.697]                   if (TRUE) {
[08:27:50.697]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.697]                     {
[08:27:50.697]                       inherits <- base::inherits
[08:27:50.697]                       invokeRestart <- base::invokeRestart
[08:27:50.697]                       is.null <- base::is.null
[08:27:50.697]                       muffled <- FALSE
[08:27:50.697]                       if (inherits(cond, "message")) {
[08:27:50.697]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.697]                         if (muffled) 
[08:27:50.697]                           invokeRestart("muffleMessage")
[08:27:50.697]                       }
[08:27:50.697]                       else if (inherits(cond, "warning")) {
[08:27:50.697]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.697]                         if (muffled) 
[08:27:50.697]                           invokeRestart("muffleWarning")
[08:27:50.697]                       }
[08:27:50.697]                       else if (inherits(cond, "condition")) {
[08:27:50.697]                         if (!is.null(pattern)) {
[08:27:50.697]                           computeRestarts <- base::computeRestarts
[08:27:50.697]                           grepl <- base::grepl
[08:27:50.697]                           restarts <- computeRestarts(cond)
[08:27:50.697]                           for (restart in restarts) {
[08:27:50.697]                             name <- restart$name
[08:27:50.697]                             if (is.null(name)) 
[08:27:50.697]                               next
[08:27:50.697]                             if (!grepl(pattern, name)) 
[08:27:50.697]                               next
[08:27:50.697]                             invokeRestart(restart)
[08:27:50.697]                             muffled <- TRUE
[08:27:50.697]                             break
[08:27:50.697]                           }
[08:27:50.697]                         }
[08:27:50.697]                       }
[08:27:50.697]                       invisible(muffled)
[08:27:50.697]                     }
[08:27:50.697]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.697]                   }
[08:27:50.697]                 }
[08:27:50.697]             }
[08:27:50.697]         }))
[08:27:50.697]     }, error = function(ex) {
[08:27:50.697]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.697]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.697]                 ...future.rng), started = ...future.startTime, 
[08:27:50.697]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.697]             version = "1.8"), class = "FutureResult")
[08:27:50.697]     }, finally = {
[08:27:50.697]         if (!identical(...future.workdir, getwd())) 
[08:27:50.697]             setwd(...future.workdir)
[08:27:50.697]         {
[08:27:50.697]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.697]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.697]             }
[08:27:50.697]             base::options(...future.oldOptions)
[08:27:50.697]             if (.Platform$OS.type == "windows") {
[08:27:50.697]                 old_names <- names(...future.oldEnvVars)
[08:27:50.697]                 envs <- base::Sys.getenv()
[08:27:50.697]                 names <- names(envs)
[08:27:50.697]                 common <- intersect(names, old_names)
[08:27:50.697]                 added <- setdiff(names, old_names)
[08:27:50.697]                 removed <- setdiff(old_names, names)
[08:27:50.697]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.697]                   envs[common]]
[08:27:50.697]                 NAMES <- toupper(changed)
[08:27:50.697]                 args <- list()
[08:27:50.697]                 for (kk in seq_along(NAMES)) {
[08:27:50.697]                   name <- changed[[kk]]
[08:27:50.697]                   NAME <- NAMES[[kk]]
[08:27:50.697]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.697]                     next
[08:27:50.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.697]                 }
[08:27:50.697]                 NAMES <- toupper(added)
[08:27:50.697]                 for (kk in seq_along(NAMES)) {
[08:27:50.697]                   name <- added[[kk]]
[08:27:50.697]                   NAME <- NAMES[[kk]]
[08:27:50.697]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.697]                     next
[08:27:50.697]                   args[[name]] <- ""
[08:27:50.697]                 }
[08:27:50.697]                 NAMES <- toupper(removed)
[08:27:50.697]                 for (kk in seq_along(NAMES)) {
[08:27:50.697]                   name <- removed[[kk]]
[08:27:50.697]                   NAME <- NAMES[[kk]]
[08:27:50.697]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.697]                     next
[08:27:50.697]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.697]                 }
[08:27:50.697]                 if (length(args) > 0) 
[08:27:50.697]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.697]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.697]             }
[08:27:50.697]             else {
[08:27:50.697]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.697]             }
[08:27:50.697]             {
[08:27:50.697]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.697]                   0L) {
[08:27:50.697]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.697]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.697]                   base::options(opts)
[08:27:50.697]                 }
[08:27:50.697]                 {
[08:27:50.697]                   {
[08:27:50.697]                     NULL
[08:27:50.697]                     RNGkind("Mersenne-Twister")
[08:27:50.697]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.697]                       inherits = FALSE)
[08:27:50.697]                   }
[08:27:50.697]                   options(future.plan = NULL)
[08:27:50.697]                   if (is.na(NA_character_)) 
[08:27:50.697]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.697]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.697]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.697]                     .init = FALSE)
[08:27:50.697]                 }
[08:27:50.697]             }
[08:27:50.697]         }
[08:27:50.697]     })
[08:27:50.697]     if (TRUE) {
[08:27:50.697]         base::sink(type = "output", split = FALSE)
[08:27:50.697]         if (TRUE) {
[08:27:50.697]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.697]         }
[08:27:50.697]         else {
[08:27:50.697]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.697]         }
[08:27:50.697]         base::close(...future.stdout)
[08:27:50.697]         ...future.stdout <- NULL
[08:27:50.697]     }
[08:27:50.697]     ...future.result$conditions <- ...future.conditions
[08:27:50.697]     ...future.result$finished <- base::Sys.time()
[08:27:50.697]     ...future.result
[08:27:50.697] }
[08:27:50.699] plan(): Setting new future strategy stack:
[08:27:50.699] List of future strategies:
[08:27:50.699] 1. sequential:
[08:27:50.699]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.699]    - tweaked: FALSE
[08:27:50.699]    - call: NULL
[08:27:50.699] plan(): nbrOfWorkers() = 1
[08:27:50.700] plan(): Setting new future strategy stack:
[08:27:50.700] List of future strategies:
[08:27:50.700] 1. sequential:
[08:27:50.700]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.700]    - tweaked: FALSE
[08:27:50.700]    - call: plan(strategy)
[08:27:50.700] plan(): nbrOfWorkers() = 1
[08:27:50.701] SequentialFuture started (and completed)
[08:27:50.701] - Launch lazy future ... done
[08:27:50.701] run() for ‘SequentialFuture’ ... done
[08:27:50.701] getGlobalsAndPackages() ...
[08:27:50.701] Searching for globals...
[08:27:50.702] - globals found: [1] ‘{’
[08:27:50.702] Searching for globals ... DONE
[08:27:50.702] Resolving globals: FALSE
[08:27:50.702] 
[08:27:50.702] 
[08:27:50.702] getGlobalsAndPackages() ... DONE
[08:27:50.703] run() for ‘Future’ ...
[08:27:50.703] - state: ‘created’
[08:27:50.703] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.703] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.703] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.703]   - Field: ‘label’
[08:27:50.703]   - Field: ‘local’
[08:27:50.703]   - Field: ‘owner’
[08:27:50.704]   - Field: ‘envir’
[08:27:50.704]   - Field: ‘packages’
[08:27:50.704]   - Field: ‘gc’
[08:27:50.704]   - Field: ‘conditions’
[08:27:50.704]   - Field: ‘expr’
[08:27:50.704]   - Field: ‘uuid’
[08:27:50.704]   - Field: ‘seed’
[08:27:50.704]   - Field: ‘version’
[08:27:50.704]   - Field: ‘result’
[08:27:50.704]   - Field: ‘asynchronous’
[08:27:50.704]   - Field: ‘calls’
[08:27:50.705]   - Field: ‘globals’
[08:27:50.705]   - Field: ‘stdout’
[08:27:50.705]   - Field: ‘earlySignal’
[08:27:50.705]   - Field: ‘lazy’
[08:27:50.705]   - Field: ‘state’
[08:27:50.705] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.705] - Launch lazy future ...
[08:27:50.705] Packages needed by the future expression (n = 0): <none>
[08:27:50.705] Packages needed by future strategies (n = 0): <none>
[08:27:50.706] {
[08:27:50.706]     {
[08:27:50.706]         {
[08:27:50.706]             ...future.startTime <- base::Sys.time()
[08:27:50.706]             {
[08:27:50.706]                 {
[08:27:50.706]                   {
[08:27:50.706]                     base::local({
[08:27:50.706]                       has_future <- base::requireNamespace("future", 
[08:27:50.706]                         quietly = TRUE)
[08:27:50.706]                       if (has_future) {
[08:27:50.706]                         ns <- base::getNamespace("future")
[08:27:50.706]                         version <- ns[[".package"]][["version"]]
[08:27:50.706]                         if (is.null(version)) 
[08:27:50.706]                           version <- utils::packageVersion("future")
[08:27:50.706]                       }
[08:27:50.706]                       else {
[08:27:50.706]                         version <- NULL
[08:27:50.706]                       }
[08:27:50.706]                       if (!has_future || version < "1.8.0") {
[08:27:50.706]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.706]                           "", base::R.version$version.string), 
[08:27:50.706]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.706]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.706]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.706]                             "release", "version")], collapse = " "), 
[08:27:50.706]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.706]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.706]                           info)
[08:27:50.706]                         info <- base::paste(info, collapse = "; ")
[08:27:50.706]                         if (!has_future) {
[08:27:50.706]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.706]                             info)
[08:27:50.706]                         }
[08:27:50.706]                         else {
[08:27:50.706]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.706]                             info, version)
[08:27:50.706]                         }
[08:27:50.706]                         base::stop(msg)
[08:27:50.706]                       }
[08:27:50.706]                     })
[08:27:50.706]                   }
[08:27:50.706]                   ...future.strategy.old <- future::plan("list")
[08:27:50.706]                   options(future.plan = NULL)
[08:27:50.706]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.706]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.706]                 }
[08:27:50.706]                 ...future.workdir <- getwd()
[08:27:50.706]             }
[08:27:50.706]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.706]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.706]         }
[08:27:50.706]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.706]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.706]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.706]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.706]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.706]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.706]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.706]             base::names(...future.oldOptions))
[08:27:50.706]     }
[08:27:50.706]     if (FALSE) {
[08:27:50.706]     }
[08:27:50.706]     else {
[08:27:50.706]         if (TRUE) {
[08:27:50.706]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.706]                 open = "w")
[08:27:50.706]         }
[08:27:50.706]         else {
[08:27:50.706]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.706]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.706]         }
[08:27:50.706]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.706]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.706]             base::sink(type = "output", split = FALSE)
[08:27:50.706]             base::close(...future.stdout)
[08:27:50.706]         }, add = TRUE)
[08:27:50.706]     }
[08:27:50.706]     ...future.frame <- base::sys.nframe()
[08:27:50.706]     ...future.conditions <- base::list()
[08:27:50.706]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.706]     if (FALSE) {
[08:27:50.706]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.706]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.706]     }
[08:27:50.706]     ...future.result <- base::tryCatch({
[08:27:50.706]         base::withCallingHandlers({
[08:27:50.706]             ...future.value <- base::withVisible(base::local({
[08:27:50.706]                 4
[08:27:50.706]             }))
[08:27:50.706]             future::FutureResult(value = ...future.value$value, 
[08:27:50.706]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.706]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.706]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.706]                     ...future.globalenv.names))
[08:27:50.706]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.706]         }, condition = base::local({
[08:27:50.706]             c <- base::c
[08:27:50.706]             inherits <- base::inherits
[08:27:50.706]             invokeRestart <- base::invokeRestart
[08:27:50.706]             length <- base::length
[08:27:50.706]             list <- base::list
[08:27:50.706]             seq.int <- base::seq.int
[08:27:50.706]             signalCondition <- base::signalCondition
[08:27:50.706]             sys.calls <- base::sys.calls
[08:27:50.706]             `[[` <- base::`[[`
[08:27:50.706]             `+` <- base::`+`
[08:27:50.706]             `<<-` <- base::`<<-`
[08:27:50.706]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.706]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.706]                   3L)]
[08:27:50.706]             }
[08:27:50.706]             function(cond) {
[08:27:50.706]                 is_error <- inherits(cond, "error")
[08:27:50.706]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.706]                   NULL)
[08:27:50.706]                 if (is_error) {
[08:27:50.706]                   sessionInformation <- function() {
[08:27:50.706]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.706]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.706]                       search = base::search(), system = base::Sys.info())
[08:27:50.706]                   }
[08:27:50.706]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.706]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.706]                     cond$call), session = sessionInformation(), 
[08:27:50.706]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.706]                   signalCondition(cond)
[08:27:50.706]                 }
[08:27:50.706]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.706]                 "immediateCondition"))) {
[08:27:50.706]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.706]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.706]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.706]                   if (TRUE && !signal) {
[08:27:50.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.706]                     {
[08:27:50.706]                       inherits <- base::inherits
[08:27:50.706]                       invokeRestart <- base::invokeRestart
[08:27:50.706]                       is.null <- base::is.null
[08:27:50.706]                       muffled <- FALSE
[08:27:50.706]                       if (inherits(cond, "message")) {
[08:27:50.706]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.706]                         if (muffled) 
[08:27:50.706]                           invokeRestart("muffleMessage")
[08:27:50.706]                       }
[08:27:50.706]                       else if (inherits(cond, "warning")) {
[08:27:50.706]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.706]                         if (muffled) 
[08:27:50.706]                           invokeRestart("muffleWarning")
[08:27:50.706]                       }
[08:27:50.706]                       else if (inherits(cond, "condition")) {
[08:27:50.706]                         if (!is.null(pattern)) {
[08:27:50.706]                           computeRestarts <- base::computeRestarts
[08:27:50.706]                           grepl <- base::grepl
[08:27:50.706]                           restarts <- computeRestarts(cond)
[08:27:50.706]                           for (restart in restarts) {
[08:27:50.706]                             name <- restart$name
[08:27:50.706]                             if (is.null(name)) 
[08:27:50.706]                               next
[08:27:50.706]                             if (!grepl(pattern, name)) 
[08:27:50.706]                               next
[08:27:50.706]                             invokeRestart(restart)
[08:27:50.706]                             muffled <- TRUE
[08:27:50.706]                             break
[08:27:50.706]                           }
[08:27:50.706]                         }
[08:27:50.706]                       }
[08:27:50.706]                       invisible(muffled)
[08:27:50.706]                     }
[08:27:50.706]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.706]                   }
[08:27:50.706]                 }
[08:27:50.706]                 else {
[08:27:50.706]                   if (TRUE) {
[08:27:50.706]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.706]                     {
[08:27:50.706]                       inherits <- base::inherits
[08:27:50.706]                       invokeRestart <- base::invokeRestart
[08:27:50.706]                       is.null <- base::is.null
[08:27:50.706]                       muffled <- FALSE
[08:27:50.706]                       if (inherits(cond, "message")) {
[08:27:50.706]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.706]                         if (muffled) 
[08:27:50.706]                           invokeRestart("muffleMessage")
[08:27:50.706]                       }
[08:27:50.706]                       else if (inherits(cond, "warning")) {
[08:27:50.706]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.706]                         if (muffled) 
[08:27:50.706]                           invokeRestart("muffleWarning")
[08:27:50.706]                       }
[08:27:50.706]                       else if (inherits(cond, "condition")) {
[08:27:50.706]                         if (!is.null(pattern)) {
[08:27:50.706]                           computeRestarts <- base::computeRestarts
[08:27:50.706]                           grepl <- base::grepl
[08:27:50.706]                           restarts <- computeRestarts(cond)
[08:27:50.706]                           for (restart in restarts) {
[08:27:50.706]                             name <- restart$name
[08:27:50.706]                             if (is.null(name)) 
[08:27:50.706]                               next
[08:27:50.706]                             if (!grepl(pattern, name)) 
[08:27:50.706]                               next
[08:27:50.706]                             invokeRestart(restart)
[08:27:50.706]                             muffled <- TRUE
[08:27:50.706]                             break
[08:27:50.706]                           }
[08:27:50.706]                         }
[08:27:50.706]                       }
[08:27:50.706]                       invisible(muffled)
[08:27:50.706]                     }
[08:27:50.706]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.706]                   }
[08:27:50.706]                 }
[08:27:50.706]             }
[08:27:50.706]         }))
[08:27:50.706]     }, error = function(ex) {
[08:27:50.706]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.706]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.706]                 ...future.rng), started = ...future.startTime, 
[08:27:50.706]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.706]             version = "1.8"), class = "FutureResult")
[08:27:50.706]     }, finally = {
[08:27:50.706]         if (!identical(...future.workdir, getwd())) 
[08:27:50.706]             setwd(...future.workdir)
[08:27:50.706]         {
[08:27:50.706]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.706]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.706]             }
[08:27:50.706]             base::options(...future.oldOptions)
[08:27:50.706]             if (.Platform$OS.type == "windows") {
[08:27:50.706]                 old_names <- names(...future.oldEnvVars)
[08:27:50.706]                 envs <- base::Sys.getenv()
[08:27:50.706]                 names <- names(envs)
[08:27:50.706]                 common <- intersect(names, old_names)
[08:27:50.706]                 added <- setdiff(names, old_names)
[08:27:50.706]                 removed <- setdiff(old_names, names)
[08:27:50.706]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.706]                   envs[common]]
[08:27:50.706]                 NAMES <- toupper(changed)
[08:27:50.706]                 args <- list()
[08:27:50.706]                 for (kk in seq_along(NAMES)) {
[08:27:50.706]                   name <- changed[[kk]]
[08:27:50.706]                   NAME <- NAMES[[kk]]
[08:27:50.706]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.706]                     next
[08:27:50.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.706]                 }
[08:27:50.706]                 NAMES <- toupper(added)
[08:27:50.706]                 for (kk in seq_along(NAMES)) {
[08:27:50.706]                   name <- added[[kk]]
[08:27:50.706]                   NAME <- NAMES[[kk]]
[08:27:50.706]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.706]                     next
[08:27:50.706]                   args[[name]] <- ""
[08:27:50.706]                 }
[08:27:50.706]                 NAMES <- toupper(removed)
[08:27:50.706]                 for (kk in seq_along(NAMES)) {
[08:27:50.706]                   name <- removed[[kk]]
[08:27:50.706]                   NAME <- NAMES[[kk]]
[08:27:50.706]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.706]                     next
[08:27:50.706]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.706]                 }
[08:27:50.706]                 if (length(args) > 0) 
[08:27:50.706]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.706]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.706]             }
[08:27:50.706]             else {
[08:27:50.706]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.706]             }
[08:27:50.706]             {
[08:27:50.706]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.706]                   0L) {
[08:27:50.706]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.706]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.706]                   base::options(opts)
[08:27:50.706]                 }
[08:27:50.706]                 {
[08:27:50.706]                   {
[08:27:50.706]                     NULL
[08:27:50.706]                     RNGkind("Mersenne-Twister")
[08:27:50.706]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.706]                       inherits = FALSE)
[08:27:50.706]                   }
[08:27:50.706]                   options(future.plan = NULL)
[08:27:50.706]                   if (is.na(NA_character_)) 
[08:27:50.706]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.706]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.706]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.706]                     .init = FALSE)
[08:27:50.706]                 }
[08:27:50.706]             }
[08:27:50.706]         }
[08:27:50.706]     })
[08:27:50.706]     if (TRUE) {
[08:27:50.706]         base::sink(type = "output", split = FALSE)
[08:27:50.706]         if (TRUE) {
[08:27:50.706]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.706]         }
[08:27:50.706]         else {
[08:27:50.706]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.706]         }
[08:27:50.706]         base::close(...future.stdout)
[08:27:50.706]         ...future.stdout <- NULL
[08:27:50.706]     }
[08:27:50.706]     ...future.result$conditions <- ...future.conditions
[08:27:50.706]     ...future.result$finished <- base::Sys.time()
[08:27:50.706]     ...future.result
[08:27:50.706] }
[08:27:50.707] plan(): Setting new future strategy stack:
[08:27:50.708] List of future strategies:
[08:27:50.708] 1. sequential:
[08:27:50.708]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.708]    - tweaked: FALSE
[08:27:50.708]    - call: NULL
[08:27:50.708] plan(): nbrOfWorkers() = 1
[08:27:50.709] plan(): Setting new future strategy stack:
[08:27:50.709] List of future strategies:
[08:27:50.709] 1. sequential:
[08:27:50.709]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.709]    - tweaked: FALSE
[08:27:50.709]    - call: plan(strategy)
[08:27:50.709] plan(): nbrOfWorkers() = 1
[08:27:50.709] SequentialFuture started (and completed)
[08:27:50.710] - Launch lazy future ... done
[08:27:50.710] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d85f24e708> 
Classes 'listenv', 'environment' <environment: 0x55d860edf018> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[08:27:50.715] resolved() for ‘SequentialFuture’ ...
[08:27:50.715] - state: ‘finished’
[08:27:50.715] - run: TRUE
[08:27:50.715] - result: ‘FutureResult’
[08:27:50.715] resolved() for ‘SequentialFuture’ ... done
[08:27:50.715] resolved() for ‘SequentialFuture’ ...
[08:27:50.715] - state: ‘finished’
[08:27:50.715] - run: TRUE
[08:27:50.716] - result: ‘FutureResult’
[08:27:50.716] resolved() for ‘SequentialFuture’ ... done
[08:27:50.716] resolved() for ‘SequentialFuture’ ...
[08:27:50.716] - state: ‘finished’
[08:27:50.716] - run: TRUE
[08:27:50.716] - result: ‘FutureResult’
[08:27:50.716] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:50.718] resolve() on list environment ...
[08:27:50.718]  recursive: 0
[08:27:50.719]  length: 6
[08:27:50.719]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:50.719] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.720] - nx: 6
[08:27:50.720] - relay: TRUE
[08:27:50.720] - stdout: TRUE
[08:27:50.720] - signal: TRUE
[08:27:50.720] - resignal: FALSE
[08:27:50.720] - force: TRUE
[08:27:50.720] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.720] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.720]  - until=2
[08:27:50.720]  - relaying element #2
[08:27:50.720] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.720] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.721] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.721]  length: 5 (resolved future 1)
[08:27:50.721] resolved() for ‘SequentialFuture’ ...
[08:27:50.721] - state: ‘finished’
[08:27:50.721] - run: TRUE
[08:27:50.721] - result: ‘FutureResult’
[08:27:50.721] resolved() for ‘SequentialFuture’ ... done
[08:27:50.721] Future #2
[08:27:50.721] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.721] - nx: 6
[08:27:50.722] - relay: TRUE
[08:27:50.722] - stdout: TRUE
[08:27:50.722] - signal: TRUE
[08:27:50.722] - resignal: FALSE
[08:27:50.722] - force: TRUE
[08:27:50.722] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.722] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.722]  - until=2
[08:27:50.722]  - relaying element #2
[08:27:50.722] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.722] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.723] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.723]  length: 4 (resolved future 2)
[08:27:50.723] resolved() for ‘SequentialFuture’ ...
[08:27:50.723] - state: ‘finished’
[08:27:50.723] - run: TRUE
[08:27:50.723] - result: ‘FutureResult’
[08:27:50.723] resolved() for ‘SequentialFuture’ ... done
[08:27:50.723] Future #3
[08:27:50.723] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.723] - nx: 6
[08:27:50.723] - relay: TRUE
[08:27:50.724] - stdout: TRUE
[08:27:50.724] - signal: TRUE
[08:27:50.724] - resignal: FALSE
[08:27:50.724] - force: TRUE
[08:27:50.724] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.724] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.724]  - until=3
[08:27:50.724]  - relaying element #3
[08:27:50.724] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.724] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.724] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.725]  length: 3 (resolved future 3)
[08:27:50.725] resolved() for ‘SequentialFuture’ ...
[08:27:50.725] - state: ‘finished’
[08:27:50.725] - run: TRUE
[08:27:50.725] - result: ‘FutureResult’
[08:27:50.725] resolved() for ‘SequentialFuture’ ... done
[08:27:50.725] Future #4
[08:27:50.725] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.725] - nx: 6
[08:27:50.725] - relay: TRUE
[08:27:50.725] - stdout: TRUE
[08:27:50.726] - signal: TRUE
[08:27:50.726] - resignal: FALSE
[08:27:50.726] - force: TRUE
[08:27:50.726] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.726] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.726]  - until=4
[08:27:50.726]  - relaying element #4
[08:27:50.726] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.726] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.726] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.726]  length: 2 (resolved future 4)
[08:27:50.727] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.727] - nx: 6
[08:27:50.727] - relay: TRUE
[08:27:50.727] - stdout: TRUE
[08:27:50.727] - signal: TRUE
[08:27:50.727] - resignal: FALSE
[08:27:50.727] - force: TRUE
[08:27:50.727] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.727] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.727]  - until=6
[08:27:50.727]  - relaying element #6
[08:27:50.727] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.727] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.728] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.728]  length: 1 (resolved future 5)
[08:27:50.728] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.728] - nx: 6
[08:27:50.728] - relay: TRUE
[08:27:50.728] - stdout: TRUE
[08:27:50.728] - signal: TRUE
[08:27:50.728] - resignal: FALSE
[08:27:50.728] - force: TRUE
[08:27:50.728] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.728] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.728]  - until=6
[08:27:50.729] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.729] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.729] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.729]  length: 0 (resolved future 6)
[08:27:50.729] Relaying remaining futures
[08:27:50.729] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.729] - nx: 6
[08:27:50.729] - relay: TRUE
[08:27:50.729] - stdout: TRUE
[08:27:50.729] - signal: TRUE
[08:27:50.729] - resignal: FALSE
[08:27:50.729] - force: TRUE
[08:27:50.729] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.730] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:50.730] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.730] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.730] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.730] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55d85f152b08> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[08:27:50.732] getGlobalsAndPackages() ...
[08:27:50.732] Searching for globals...
[08:27:50.732] 
[08:27:50.732] Searching for globals ... DONE
[08:27:50.732] - globals: [0] <none>
[08:27:50.732] getGlobalsAndPackages() ... DONE
[08:27:50.733] run() for ‘Future’ ...
[08:27:50.733] - state: ‘created’
[08:27:50.733] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.733] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.733] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.733]   - Field: ‘label’
[08:27:50.733]   - Field: ‘local’
[08:27:50.734]   - Field: ‘owner’
[08:27:50.734]   - Field: ‘envir’
[08:27:50.734]   - Field: ‘packages’
[08:27:50.734]   - Field: ‘gc’
[08:27:50.734]   - Field: ‘conditions’
[08:27:50.734]   - Field: ‘expr’
[08:27:50.735]   - Field: ‘uuid’
[08:27:50.735]   - Field: ‘seed’
[08:27:50.736]   - Field: ‘version’
[08:27:50.736]   - Field: ‘result’
[08:27:50.736]   - Field: ‘asynchronous’
[08:27:50.736]   - Field: ‘calls’
[08:27:50.736]   - Field: ‘globals’
[08:27:50.736]   - Field: ‘stdout’
[08:27:50.736]   - Field: ‘earlySignal’
[08:27:50.736]   - Field: ‘lazy’
[08:27:50.736]   - Field: ‘state’
[08:27:50.737] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.737] - Launch lazy future ...
[08:27:50.737] Packages needed by the future expression (n = 0): <none>
[08:27:50.737] Packages needed by future strategies (n = 0): <none>
[08:27:50.737] {
[08:27:50.737]     {
[08:27:50.737]         {
[08:27:50.737]             ...future.startTime <- base::Sys.time()
[08:27:50.737]             {
[08:27:50.737]                 {
[08:27:50.737]                   {
[08:27:50.737]                     base::local({
[08:27:50.737]                       has_future <- base::requireNamespace("future", 
[08:27:50.737]                         quietly = TRUE)
[08:27:50.737]                       if (has_future) {
[08:27:50.737]                         ns <- base::getNamespace("future")
[08:27:50.737]                         version <- ns[[".package"]][["version"]]
[08:27:50.737]                         if (is.null(version)) 
[08:27:50.737]                           version <- utils::packageVersion("future")
[08:27:50.737]                       }
[08:27:50.737]                       else {
[08:27:50.737]                         version <- NULL
[08:27:50.737]                       }
[08:27:50.737]                       if (!has_future || version < "1.8.0") {
[08:27:50.737]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.737]                           "", base::R.version$version.string), 
[08:27:50.737]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.737]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.737]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.737]                             "release", "version")], collapse = " "), 
[08:27:50.737]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.737]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.737]                           info)
[08:27:50.737]                         info <- base::paste(info, collapse = "; ")
[08:27:50.737]                         if (!has_future) {
[08:27:50.737]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.737]                             info)
[08:27:50.737]                         }
[08:27:50.737]                         else {
[08:27:50.737]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.737]                             info, version)
[08:27:50.737]                         }
[08:27:50.737]                         base::stop(msg)
[08:27:50.737]                       }
[08:27:50.737]                     })
[08:27:50.737]                   }
[08:27:50.737]                   ...future.strategy.old <- future::plan("list")
[08:27:50.737]                   options(future.plan = NULL)
[08:27:50.737]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.737]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.737]                 }
[08:27:50.737]                 ...future.workdir <- getwd()
[08:27:50.737]             }
[08:27:50.737]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.737]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.737]         }
[08:27:50.737]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.737]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.737]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.737]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.737]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.737]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.737]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.737]             base::names(...future.oldOptions))
[08:27:50.737]     }
[08:27:50.737]     if (FALSE) {
[08:27:50.737]     }
[08:27:50.737]     else {
[08:27:50.737]         if (TRUE) {
[08:27:50.737]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.737]                 open = "w")
[08:27:50.737]         }
[08:27:50.737]         else {
[08:27:50.737]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.737]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.737]         }
[08:27:50.737]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.737]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.737]             base::sink(type = "output", split = FALSE)
[08:27:50.737]             base::close(...future.stdout)
[08:27:50.737]         }, add = TRUE)
[08:27:50.737]     }
[08:27:50.737]     ...future.frame <- base::sys.nframe()
[08:27:50.737]     ...future.conditions <- base::list()
[08:27:50.737]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.737]     if (FALSE) {
[08:27:50.737]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.737]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.737]     }
[08:27:50.737]     ...future.result <- base::tryCatch({
[08:27:50.737]         base::withCallingHandlers({
[08:27:50.737]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.737]             future::FutureResult(value = ...future.value$value, 
[08:27:50.737]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.737]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.737]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.737]                     ...future.globalenv.names))
[08:27:50.737]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.737]         }, condition = base::local({
[08:27:50.737]             c <- base::c
[08:27:50.737]             inherits <- base::inherits
[08:27:50.737]             invokeRestart <- base::invokeRestart
[08:27:50.737]             length <- base::length
[08:27:50.737]             list <- base::list
[08:27:50.737]             seq.int <- base::seq.int
[08:27:50.737]             signalCondition <- base::signalCondition
[08:27:50.737]             sys.calls <- base::sys.calls
[08:27:50.737]             `[[` <- base::`[[`
[08:27:50.737]             `+` <- base::`+`
[08:27:50.737]             `<<-` <- base::`<<-`
[08:27:50.737]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.737]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.737]                   3L)]
[08:27:50.737]             }
[08:27:50.737]             function(cond) {
[08:27:50.737]                 is_error <- inherits(cond, "error")
[08:27:50.737]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.737]                   NULL)
[08:27:50.737]                 if (is_error) {
[08:27:50.737]                   sessionInformation <- function() {
[08:27:50.737]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.737]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.737]                       search = base::search(), system = base::Sys.info())
[08:27:50.737]                   }
[08:27:50.737]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.737]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.737]                     cond$call), session = sessionInformation(), 
[08:27:50.737]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.737]                   signalCondition(cond)
[08:27:50.737]                 }
[08:27:50.737]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.737]                 "immediateCondition"))) {
[08:27:50.737]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.737]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.737]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.737]                   if (TRUE && !signal) {
[08:27:50.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.737]                     {
[08:27:50.737]                       inherits <- base::inherits
[08:27:50.737]                       invokeRestart <- base::invokeRestart
[08:27:50.737]                       is.null <- base::is.null
[08:27:50.737]                       muffled <- FALSE
[08:27:50.737]                       if (inherits(cond, "message")) {
[08:27:50.737]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.737]                         if (muffled) 
[08:27:50.737]                           invokeRestart("muffleMessage")
[08:27:50.737]                       }
[08:27:50.737]                       else if (inherits(cond, "warning")) {
[08:27:50.737]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.737]                         if (muffled) 
[08:27:50.737]                           invokeRestart("muffleWarning")
[08:27:50.737]                       }
[08:27:50.737]                       else if (inherits(cond, "condition")) {
[08:27:50.737]                         if (!is.null(pattern)) {
[08:27:50.737]                           computeRestarts <- base::computeRestarts
[08:27:50.737]                           grepl <- base::grepl
[08:27:50.737]                           restarts <- computeRestarts(cond)
[08:27:50.737]                           for (restart in restarts) {
[08:27:50.737]                             name <- restart$name
[08:27:50.737]                             if (is.null(name)) 
[08:27:50.737]                               next
[08:27:50.737]                             if (!grepl(pattern, name)) 
[08:27:50.737]                               next
[08:27:50.737]                             invokeRestart(restart)
[08:27:50.737]                             muffled <- TRUE
[08:27:50.737]                             break
[08:27:50.737]                           }
[08:27:50.737]                         }
[08:27:50.737]                       }
[08:27:50.737]                       invisible(muffled)
[08:27:50.737]                     }
[08:27:50.737]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.737]                   }
[08:27:50.737]                 }
[08:27:50.737]                 else {
[08:27:50.737]                   if (TRUE) {
[08:27:50.737]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.737]                     {
[08:27:50.737]                       inherits <- base::inherits
[08:27:50.737]                       invokeRestart <- base::invokeRestart
[08:27:50.737]                       is.null <- base::is.null
[08:27:50.737]                       muffled <- FALSE
[08:27:50.737]                       if (inherits(cond, "message")) {
[08:27:50.737]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.737]                         if (muffled) 
[08:27:50.737]                           invokeRestart("muffleMessage")
[08:27:50.737]                       }
[08:27:50.737]                       else if (inherits(cond, "warning")) {
[08:27:50.737]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.737]                         if (muffled) 
[08:27:50.737]                           invokeRestart("muffleWarning")
[08:27:50.737]                       }
[08:27:50.737]                       else if (inherits(cond, "condition")) {
[08:27:50.737]                         if (!is.null(pattern)) {
[08:27:50.737]                           computeRestarts <- base::computeRestarts
[08:27:50.737]                           grepl <- base::grepl
[08:27:50.737]                           restarts <- computeRestarts(cond)
[08:27:50.737]                           for (restart in restarts) {
[08:27:50.737]                             name <- restart$name
[08:27:50.737]                             if (is.null(name)) 
[08:27:50.737]                               next
[08:27:50.737]                             if (!grepl(pattern, name)) 
[08:27:50.737]                               next
[08:27:50.737]                             invokeRestart(restart)
[08:27:50.737]                             muffled <- TRUE
[08:27:50.737]                             break
[08:27:50.737]                           }
[08:27:50.737]                         }
[08:27:50.737]                       }
[08:27:50.737]                       invisible(muffled)
[08:27:50.737]                     }
[08:27:50.737]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.737]                   }
[08:27:50.737]                 }
[08:27:50.737]             }
[08:27:50.737]         }))
[08:27:50.737]     }, error = function(ex) {
[08:27:50.737]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.737]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.737]                 ...future.rng), started = ...future.startTime, 
[08:27:50.737]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.737]             version = "1.8"), class = "FutureResult")
[08:27:50.737]     }, finally = {
[08:27:50.737]         if (!identical(...future.workdir, getwd())) 
[08:27:50.737]             setwd(...future.workdir)
[08:27:50.737]         {
[08:27:50.737]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.737]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.737]             }
[08:27:50.737]             base::options(...future.oldOptions)
[08:27:50.737]             if (.Platform$OS.type == "windows") {
[08:27:50.737]                 old_names <- names(...future.oldEnvVars)
[08:27:50.737]                 envs <- base::Sys.getenv()
[08:27:50.737]                 names <- names(envs)
[08:27:50.737]                 common <- intersect(names, old_names)
[08:27:50.737]                 added <- setdiff(names, old_names)
[08:27:50.737]                 removed <- setdiff(old_names, names)
[08:27:50.737]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.737]                   envs[common]]
[08:27:50.737]                 NAMES <- toupper(changed)
[08:27:50.737]                 args <- list()
[08:27:50.737]                 for (kk in seq_along(NAMES)) {
[08:27:50.737]                   name <- changed[[kk]]
[08:27:50.737]                   NAME <- NAMES[[kk]]
[08:27:50.737]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.737]                     next
[08:27:50.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.737]                 }
[08:27:50.737]                 NAMES <- toupper(added)
[08:27:50.737]                 for (kk in seq_along(NAMES)) {
[08:27:50.737]                   name <- added[[kk]]
[08:27:50.737]                   NAME <- NAMES[[kk]]
[08:27:50.737]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.737]                     next
[08:27:50.737]                   args[[name]] <- ""
[08:27:50.737]                 }
[08:27:50.737]                 NAMES <- toupper(removed)
[08:27:50.737]                 for (kk in seq_along(NAMES)) {
[08:27:50.737]                   name <- removed[[kk]]
[08:27:50.737]                   NAME <- NAMES[[kk]]
[08:27:50.737]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.737]                     next
[08:27:50.737]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.737]                 }
[08:27:50.737]                 if (length(args) > 0) 
[08:27:50.737]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.737]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.737]             }
[08:27:50.737]             else {
[08:27:50.737]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.737]             }
[08:27:50.737]             {
[08:27:50.737]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.737]                   0L) {
[08:27:50.737]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.737]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.737]                   base::options(opts)
[08:27:50.737]                 }
[08:27:50.737]                 {
[08:27:50.737]                   {
[08:27:50.737]                     NULL
[08:27:50.737]                     RNGkind("Mersenne-Twister")
[08:27:50.737]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.737]                       inherits = FALSE)
[08:27:50.737]                   }
[08:27:50.737]                   options(future.plan = NULL)
[08:27:50.737]                   if (is.na(NA_character_)) 
[08:27:50.737]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.737]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.737]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.737]                     .init = FALSE)
[08:27:50.737]                 }
[08:27:50.737]             }
[08:27:50.737]         }
[08:27:50.737]     })
[08:27:50.737]     if (TRUE) {
[08:27:50.737]         base::sink(type = "output", split = FALSE)
[08:27:50.737]         if (TRUE) {
[08:27:50.737]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.737]         }
[08:27:50.737]         else {
[08:27:50.737]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.737]         }
[08:27:50.737]         base::close(...future.stdout)
[08:27:50.737]         ...future.stdout <- NULL
[08:27:50.737]     }
[08:27:50.737]     ...future.result$conditions <- ...future.conditions
[08:27:50.737]     ...future.result$finished <- base::Sys.time()
[08:27:50.737]     ...future.result
[08:27:50.737] }
[08:27:50.739] plan(): Setting new future strategy stack:
[08:27:50.739] List of future strategies:
[08:27:50.739] 1. sequential:
[08:27:50.739]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.739]    - tweaked: FALSE
[08:27:50.739]    - call: NULL
[08:27:50.740] plan(): nbrOfWorkers() = 1
[08:27:50.741] plan(): Setting new future strategy stack:
[08:27:50.741] List of future strategies:
[08:27:50.741] 1. sequential:
[08:27:50.741]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.741]    - tweaked: FALSE
[08:27:50.741]    - call: plan(strategy)
[08:27:50.741] plan(): nbrOfWorkers() = 1
[08:27:50.741] SequentialFuture started (and completed)
[08:27:50.741] - Launch lazy future ... done
[08:27:50.741] run() for ‘SequentialFuture’ ... done
[08:27:50.742] getGlobalsAndPackages() ...
[08:27:50.742] Searching for globals...
[08:27:50.742] 
[08:27:50.742] Searching for globals ... DONE
[08:27:50.742] - globals: [0] <none>
[08:27:50.742] getGlobalsAndPackages() ... DONE
[08:27:50.743] run() for ‘Future’ ...
[08:27:50.743] - state: ‘created’
[08:27:50.743] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.743] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.743] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.743]   - Field: ‘label’
[08:27:50.743]   - Field: ‘local’
[08:27:50.743]   - Field: ‘owner’
[08:27:50.743]   - Field: ‘envir’
[08:27:50.744]   - Field: ‘packages’
[08:27:50.744]   - Field: ‘gc’
[08:27:50.744]   - Field: ‘conditions’
[08:27:50.744]   - Field: ‘expr’
[08:27:50.744]   - Field: ‘uuid’
[08:27:50.744]   - Field: ‘seed’
[08:27:50.744]   - Field: ‘version’
[08:27:50.744]   - Field: ‘result’
[08:27:50.744]   - Field: ‘asynchronous’
[08:27:50.744]   - Field: ‘calls’
[08:27:50.744]   - Field: ‘globals’
[08:27:50.744]   - Field: ‘stdout’
[08:27:50.745]   - Field: ‘earlySignal’
[08:27:50.745]   - Field: ‘lazy’
[08:27:50.745]   - Field: ‘state’
[08:27:50.745] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.745] - Launch lazy future ...
[08:27:50.745] Packages needed by the future expression (n = 0): <none>
[08:27:50.745] Packages needed by future strategies (n = 0): <none>
[08:27:50.746] {
[08:27:50.746]     {
[08:27:50.746]         {
[08:27:50.746]             ...future.startTime <- base::Sys.time()
[08:27:50.746]             {
[08:27:50.746]                 {
[08:27:50.746]                   {
[08:27:50.746]                     base::local({
[08:27:50.746]                       has_future <- base::requireNamespace("future", 
[08:27:50.746]                         quietly = TRUE)
[08:27:50.746]                       if (has_future) {
[08:27:50.746]                         ns <- base::getNamespace("future")
[08:27:50.746]                         version <- ns[[".package"]][["version"]]
[08:27:50.746]                         if (is.null(version)) 
[08:27:50.746]                           version <- utils::packageVersion("future")
[08:27:50.746]                       }
[08:27:50.746]                       else {
[08:27:50.746]                         version <- NULL
[08:27:50.746]                       }
[08:27:50.746]                       if (!has_future || version < "1.8.0") {
[08:27:50.746]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.746]                           "", base::R.version$version.string), 
[08:27:50.746]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.746]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.746]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.746]                             "release", "version")], collapse = " "), 
[08:27:50.746]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.746]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.746]                           info)
[08:27:50.746]                         info <- base::paste(info, collapse = "; ")
[08:27:50.746]                         if (!has_future) {
[08:27:50.746]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.746]                             info)
[08:27:50.746]                         }
[08:27:50.746]                         else {
[08:27:50.746]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.746]                             info, version)
[08:27:50.746]                         }
[08:27:50.746]                         base::stop(msg)
[08:27:50.746]                       }
[08:27:50.746]                     })
[08:27:50.746]                   }
[08:27:50.746]                   ...future.strategy.old <- future::plan("list")
[08:27:50.746]                   options(future.plan = NULL)
[08:27:50.746]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.746]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.746]                 }
[08:27:50.746]                 ...future.workdir <- getwd()
[08:27:50.746]             }
[08:27:50.746]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.746]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.746]         }
[08:27:50.746]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.746]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.746]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.746]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.746]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.746]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.746]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.746]             base::names(...future.oldOptions))
[08:27:50.746]     }
[08:27:50.746]     if (FALSE) {
[08:27:50.746]     }
[08:27:50.746]     else {
[08:27:50.746]         if (TRUE) {
[08:27:50.746]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.746]                 open = "w")
[08:27:50.746]         }
[08:27:50.746]         else {
[08:27:50.746]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.746]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.746]         }
[08:27:50.746]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.746]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.746]             base::sink(type = "output", split = FALSE)
[08:27:50.746]             base::close(...future.stdout)
[08:27:50.746]         }, add = TRUE)
[08:27:50.746]     }
[08:27:50.746]     ...future.frame <- base::sys.nframe()
[08:27:50.746]     ...future.conditions <- base::list()
[08:27:50.746]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.746]     if (FALSE) {
[08:27:50.746]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.746]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.746]     }
[08:27:50.746]     ...future.result <- base::tryCatch({
[08:27:50.746]         base::withCallingHandlers({
[08:27:50.746]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.746]             future::FutureResult(value = ...future.value$value, 
[08:27:50.746]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.746]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.746]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.746]                     ...future.globalenv.names))
[08:27:50.746]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.746]         }, condition = base::local({
[08:27:50.746]             c <- base::c
[08:27:50.746]             inherits <- base::inherits
[08:27:50.746]             invokeRestart <- base::invokeRestart
[08:27:50.746]             length <- base::length
[08:27:50.746]             list <- base::list
[08:27:50.746]             seq.int <- base::seq.int
[08:27:50.746]             signalCondition <- base::signalCondition
[08:27:50.746]             sys.calls <- base::sys.calls
[08:27:50.746]             `[[` <- base::`[[`
[08:27:50.746]             `+` <- base::`+`
[08:27:50.746]             `<<-` <- base::`<<-`
[08:27:50.746]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.746]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.746]                   3L)]
[08:27:50.746]             }
[08:27:50.746]             function(cond) {
[08:27:50.746]                 is_error <- inherits(cond, "error")
[08:27:50.746]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.746]                   NULL)
[08:27:50.746]                 if (is_error) {
[08:27:50.746]                   sessionInformation <- function() {
[08:27:50.746]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.746]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.746]                       search = base::search(), system = base::Sys.info())
[08:27:50.746]                   }
[08:27:50.746]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.746]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.746]                     cond$call), session = sessionInformation(), 
[08:27:50.746]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.746]                   signalCondition(cond)
[08:27:50.746]                 }
[08:27:50.746]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.746]                 "immediateCondition"))) {
[08:27:50.746]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.746]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.746]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.746]                   if (TRUE && !signal) {
[08:27:50.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.746]                     {
[08:27:50.746]                       inherits <- base::inherits
[08:27:50.746]                       invokeRestart <- base::invokeRestart
[08:27:50.746]                       is.null <- base::is.null
[08:27:50.746]                       muffled <- FALSE
[08:27:50.746]                       if (inherits(cond, "message")) {
[08:27:50.746]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.746]                         if (muffled) 
[08:27:50.746]                           invokeRestart("muffleMessage")
[08:27:50.746]                       }
[08:27:50.746]                       else if (inherits(cond, "warning")) {
[08:27:50.746]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.746]                         if (muffled) 
[08:27:50.746]                           invokeRestart("muffleWarning")
[08:27:50.746]                       }
[08:27:50.746]                       else if (inherits(cond, "condition")) {
[08:27:50.746]                         if (!is.null(pattern)) {
[08:27:50.746]                           computeRestarts <- base::computeRestarts
[08:27:50.746]                           grepl <- base::grepl
[08:27:50.746]                           restarts <- computeRestarts(cond)
[08:27:50.746]                           for (restart in restarts) {
[08:27:50.746]                             name <- restart$name
[08:27:50.746]                             if (is.null(name)) 
[08:27:50.746]                               next
[08:27:50.746]                             if (!grepl(pattern, name)) 
[08:27:50.746]                               next
[08:27:50.746]                             invokeRestart(restart)
[08:27:50.746]                             muffled <- TRUE
[08:27:50.746]                             break
[08:27:50.746]                           }
[08:27:50.746]                         }
[08:27:50.746]                       }
[08:27:50.746]                       invisible(muffled)
[08:27:50.746]                     }
[08:27:50.746]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.746]                   }
[08:27:50.746]                 }
[08:27:50.746]                 else {
[08:27:50.746]                   if (TRUE) {
[08:27:50.746]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.746]                     {
[08:27:50.746]                       inherits <- base::inherits
[08:27:50.746]                       invokeRestart <- base::invokeRestart
[08:27:50.746]                       is.null <- base::is.null
[08:27:50.746]                       muffled <- FALSE
[08:27:50.746]                       if (inherits(cond, "message")) {
[08:27:50.746]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.746]                         if (muffled) 
[08:27:50.746]                           invokeRestart("muffleMessage")
[08:27:50.746]                       }
[08:27:50.746]                       else if (inherits(cond, "warning")) {
[08:27:50.746]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.746]                         if (muffled) 
[08:27:50.746]                           invokeRestart("muffleWarning")
[08:27:50.746]                       }
[08:27:50.746]                       else if (inherits(cond, "condition")) {
[08:27:50.746]                         if (!is.null(pattern)) {
[08:27:50.746]                           computeRestarts <- base::computeRestarts
[08:27:50.746]                           grepl <- base::grepl
[08:27:50.746]                           restarts <- computeRestarts(cond)
[08:27:50.746]                           for (restart in restarts) {
[08:27:50.746]                             name <- restart$name
[08:27:50.746]                             if (is.null(name)) 
[08:27:50.746]                               next
[08:27:50.746]                             if (!grepl(pattern, name)) 
[08:27:50.746]                               next
[08:27:50.746]                             invokeRestart(restart)
[08:27:50.746]                             muffled <- TRUE
[08:27:50.746]                             break
[08:27:50.746]                           }
[08:27:50.746]                         }
[08:27:50.746]                       }
[08:27:50.746]                       invisible(muffled)
[08:27:50.746]                     }
[08:27:50.746]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.746]                   }
[08:27:50.746]                 }
[08:27:50.746]             }
[08:27:50.746]         }))
[08:27:50.746]     }, error = function(ex) {
[08:27:50.746]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.746]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.746]                 ...future.rng), started = ...future.startTime, 
[08:27:50.746]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.746]             version = "1.8"), class = "FutureResult")
[08:27:50.746]     }, finally = {
[08:27:50.746]         if (!identical(...future.workdir, getwd())) 
[08:27:50.746]             setwd(...future.workdir)
[08:27:50.746]         {
[08:27:50.746]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.746]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.746]             }
[08:27:50.746]             base::options(...future.oldOptions)
[08:27:50.746]             if (.Platform$OS.type == "windows") {
[08:27:50.746]                 old_names <- names(...future.oldEnvVars)
[08:27:50.746]                 envs <- base::Sys.getenv()
[08:27:50.746]                 names <- names(envs)
[08:27:50.746]                 common <- intersect(names, old_names)
[08:27:50.746]                 added <- setdiff(names, old_names)
[08:27:50.746]                 removed <- setdiff(old_names, names)
[08:27:50.746]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.746]                   envs[common]]
[08:27:50.746]                 NAMES <- toupper(changed)
[08:27:50.746]                 args <- list()
[08:27:50.746]                 for (kk in seq_along(NAMES)) {
[08:27:50.746]                   name <- changed[[kk]]
[08:27:50.746]                   NAME <- NAMES[[kk]]
[08:27:50.746]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.746]                     next
[08:27:50.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.746]                 }
[08:27:50.746]                 NAMES <- toupper(added)
[08:27:50.746]                 for (kk in seq_along(NAMES)) {
[08:27:50.746]                   name <- added[[kk]]
[08:27:50.746]                   NAME <- NAMES[[kk]]
[08:27:50.746]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.746]                     next
[08:27:50.746]                   args[[name]] <- ""
[08:27:50.746]                 }
[08:27:50.746]                 NAMES <- toupper(removed)
[08:27:50.746]                 for (kk in seq_along(NAMES)) {
[08:27:50.746]                   name <- removed[[kk]]
[08:27:50.746]                   NAME <- NAMES[[kk]]
[08:27:50.746]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.746]                     next
[08:27:50.746]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.746]                 }
[08:27:50.746]                 if (length(args) > 0) 
[08:27:50.746]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.746]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.746]             }
[08:27:50.746]             else {
[08:27:50.746]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.746]             }
[08:27:50.746]             {
[08:27:50.746]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.746]                   0L) {
[08:27:50.746]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.746]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.746]                   base::options(opts)
[08:27:50.746]                 }
[08:27:50.746]                 {
[08:27:50.746]                   {
[08:27:50.746]                     NULL
[08:27:50.746]                     RNGkind("Mersenne-Twister")
[08:27:50.746]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.746]                       inherits = FALSE)
[08:27:50.746]                   }
[08:27:50.746]                   options(future.plan = NULL)
[08:27:50.746]                   if (is.na(NA_character_)) 
[08:27:50.746]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.746]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.746]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.746]                     .init = FALSE)
[08:27:50.746]                 }
[08:27:50.746]             }
[08:27:50.746]         }
[08:27:50.746]     })
[08:27:50.746]     if (TRUE) {
[08:27:50.746]         base::sink(type = "output", split = FALSE)
[08:27:50.746]         if (TRUE) {
[08:27:50.746]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.746]         }
[08:27:50.746]         else {
[08:27:50.746]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.746]         }
[08:27:50.746]         base::close(...future.stdout)
[08:27:50.746]         ...future.stdout <- NULL
[08:27:50.746]     }
[08:27:50.746]     ...future.result$conditions <- ...future.conditions
[08:27:50.746]     ...future.result$finished <- base::Sys.time()
[08:27:50.746]     ...future.result
[08:27:50.746] }
[08:27:50.747] plan(): Setting new future strategy stack:
[08:27:50.747] List of future strategies:
[08:27:50.747] 1. sequential:
[08:27:50.747]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.747]    - tweaked: FALSE
[08:27:50.747]    - call: NULL
[08:27:50.748] plan(): nbrOfWorkers() = 1
[08:27:50.749] plan(): Setting new future strategy stack:
[08:27:50.749] List of future strategies:
[08:27:50.749] 1. sequential:
[08:27:50.749]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.749]    - tweaked: FALSE
[08:27:50.749]    - call: plan(strategy)
[08:27:50.749] plan(): nbrOfWorkers() = 1
[08:27:50.749] SequentialFuture started (and completed)
[08:27:50.749] - Launch lazy future ... done
[08:27:50.750] run() for ‘SequentialFuture’ ... done
[08:27:50.750] getGlobalsAndPackages() ...
[08:27:50.750] Searching for globals...
[08:27:50.751] - globals found: [1] ‘{’
[08:27:50.751] Searching for globals ... DONE
[08:27:50.751] Resolving globals: FALSE
[08:27:50.751] 
[08:27:50.751] 
[08:27:50.751] getGlobalsAndPackages() ... DONE
[08:27:50.751] run() for ‘Future’ ...
[08:27:50.752] - state: ‘created’
[08:27:50.752] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.752] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.752] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.752]   - Field: ‘label’
[08:27:50.752]   - Field: ‘local’
[08:27:50.752]   - Field: ‘owner’
[08:27:50.752]   - Field: ‘envir’
[08:27:50.753]   - Field: ‘packages’
[08:27:50.753]   - Field: ‘gc’
[08:27:50.753]   - Field: ‘conditions’
[08:27:50.753]   - Field: ‘expr’
[08:27:50.753]   - Field: ‘uuid’
[08:27:50.753]   - Field: ‘seed’
[08:27:50.753]   - Field: ‘version’
[08:27:50.753]   - Field: ‘result’
[08:27:50.753]   - Field: ‘asynchronous’
[08:27:50.753]   - Field: ‘calls’
[08:27:50.753]   - Field: ‘globals’
[08:27:50.753]   - Field: ‘stdout’
[08:27:50.754]   - Field: ‘earlySignal’
[08:27:50.754]   - Field: ‘lazy’
[08:27:50.754]   - Field: ‘state’
[08:27:50.754] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.754] - Launch lazy future ...
[08:27:50.754] Packages needed by the future expression (n = 0): <none>
[08:27:50.754] Packages needed by future strategies (n = 0): <none>
[08:27:50.755] {
[08:27:50.755]     {
[08:27:50.755]         {
[08:27:50.755]             ...future.startTime <- base::Sys.time()
[08:27:50.755]             {
[08:27:50.755]                 {
[08:27:50.755]                   {
[08:27:50.755]                     base::local({
[08:27:50.755]                       has_future <- base::requireNamespace("future", 
[08:27:50.755]                         quietly = TRUE)
[08:27:50.755]                       if (has_future) {
[08:27:50.755]                         ns <- base::getNamespace("future")
[08:27:50.755]                         version <- ns[[".package"]][["version"]]
[08:27:50.755]                         if (is.null(version)) 
[08:27:50.755]                           version <- utils::packageVersion("future")
[08:27:50.755]                       }
[08:27:50.755]                       else {
[08:27:50.755]                         version <- NULL
[08:27:50.755]                       }
[08:27:50.755]                       if (!has_future || version < "1.8.0") {
[08:27:50.755]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.755]                           "", base::R.version$version.string), 
[08:27:50.755]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.755]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.755]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.755]                             "release", "version")], collapse = " "), 
[08:27:50.755]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.755]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.755]                           info)
[08:27:50.755]                         info <- base::paste(info, collapse = "; ")
[08:27:50.755]                         if (!has_future) {
[08:27:50.755]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.755]                             info)
[08:27:50.755]                         }
[08:27:50.755]                         else {
[08:27:50.755]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.755]                             info, version)
[08:27:50.755]                         }
[08:27:50.755]                         base::stop(msg)
[08:27:50.755]                       }
[08:27:50.755]                     })
[08:27:50.755]                   }
[08:27:50.755]                   ...future.strategy.old <- future::plan("list")
[08:27:50.755]                   options(future.plan = NULL)
[08:27:50.755]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.755]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.755]                 }
[08:27:50.755]                 ...future.workdir <- getwd()
[08:27:50.755]             }
[08:27:50.755]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.755]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.755]         }
[08:27:50.755]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.755]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.755]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.755]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.755]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.755]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.755]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.755]             base::names(...future.oldOptions))
[08:27:50.755]     }
[08:27:50.755]     if (FALSE) {
[08:27:50.755]     }
[08:27:50.755]     else {
[08:27:50.755]         if (TRUE) {
[08:27:50.755]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.755]                 open = "w")
[08:27:50.755]         }
[08:27:50.755]         else {
[08:27:50.755]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.755]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.755]         }
[08:27:50.755]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.755]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.755]             base::sink(type = "output", split = FALSE)
[08:27:50.755]             base::close(...future.stdout)
[08:27:50.755]         }, add = TRUE)
[08:27:50.755]     }
[08:27:50.755]     ...future.frame <- base::sys.nframe()
[08:27:50.755]     ...future.conditions <- base::list()
[08:27:50.755]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.755]     if (FALSE) {
[08:27:50.755]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.755]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.755]     }
[08:27:50.755]     ...future.result <- base::tryCatch({
[08:27:50.755]         base::withCallingHandlers({
[08:27:50.755]             ...future.value <- base::withVisible(base::local({
[08:27:50.755]                 4
[08:27:50.755]             }))
[08:27:50.755]             future::FutureResult(value = ...future.value$value, 
[08:27:50.755]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.755]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.755]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.755]                     ...future.globalenv.names))
[08:27:50.755]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.755]         }, condition = base::local({
[08:27:50.755]             c <- base::c
[08:27:50.755]             inherits <- base::inherits
[08:27:50.755]             invokeRestart <- base::invokeRestart
[08:27:50.755]             length <- base::length
[08:27:50.755]             list <- base::list
[08:27:50.755]             seq.int <- base::seq.int
[08:27:50.755]             signalCondition <- base::signalCondition
[08:27:50.755]             sys.calls <- base::sys.calls
[08:27:50.755]             `[[` <- base::`[[`
[08:27:50.755]             `+` <- base::`+`
[08:27:50.755]             `<<-` <- base::`<<-`
[08:27:50.755]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.755]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.755]                   3L)]
[08:27:50.755]             }
[08:27:50.755]             function(cond) {
[08:27:50.755]                 is_error <- inherits(cond, "error")
[08:27:50.755]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.755]                   NULL)
[08:27:50.755]                 if (is_error) {
[08:27:50.755]                   sessionInformation <- function() {
[08:27:50.755]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.755]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.755]                       search = base::search(), system = base::Sys.info())
[08:27:50.755]                   }
[08:27:50.755]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.755]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.755]                     cond$call), session = sessionInformation(), 
[08:27:50.755]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.755]                   signalCondition(cond)
[08:27:50.755]                 }
[08:27:50.755]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.755]                 "immediateCondition"))) {
[08:27:50.755]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.755]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.755]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.755]                   if (TRUE && !signal) {
[08:27:50.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.755]                     {
[08:27:50.755]                       inherits <- base::inherits
[08:27:50.755]                       invokeRestart <- base::invokeRestart
[08:27:50.755]                       is.null <- base::is.null
[08:27:50.755]                       muffled <- FALSE
[08:27:50.755]                       if (inherits(cond, "message")) {
[08:27:50.755]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.755]                         if (muffled) 
[08:27:50.755]                           invokeRestart("muffleMessage")
[08:27:50.755]                       }
[08:27:50.755]                       else if (inherits(cond, "warning")) {
[08:27:50.755]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.755]                         if (muffled) 
[08:27:50.755]                           invokeRestart("muffleWarning")
[08:27:50.755]                       }
[08:27:50.755]                       else if (inherits(cond, "condition")) {
[08:27:50.755]                         if (!is.null(pattern)) {
[08:27:50.755]                           computeRestarts <- base::computeRestarts
[08:27:50.755]                           grepl <- base::grepl
[08:27:50.755]                           restarts <- computeRestarts(cond)
[08:27:50.755]                           for (restart in restarts) {
[08:27:50.755]                             name <- restart$name
[08:27:50.755]                             if (is.null(name)) 
[08:27:50.755]                               next
[08:27:50.755]                             if (!grepl(pattern, name)) 
[08:27:50.755]                               next
[08:27:50.755]                             invokeRestart(restart)
[08:27:50.755]                             muffled <- TRUE
[08:27:50.755]                             break
[08:27:50.755]                           }
[08:27:50.755]                         }
[08:27:50.755]                       }
[08:27:50.755]                       invisible(muffled)
[08:27:50.755]                     }
[08:27:50.755]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.755]                   }
[08:27:50.755]                 }
[08:27:50.755]                 else {
[08:27:50.755]                   if (TRUE) {
[08:27:50.755]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.755]                     {
[08:27:50.755]                       inherits <- base::inherits
[08:27:50.755]                       invokeRestart <- base::invokeRestart
[08:27:50.755]                       is.null <- base::is.null
[08:27:50.755]                       muffled <- FALSE
[08:27:50.755]                       if (inherits(cond, "message")) {
[08:27:50.755]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.755]                         if (muffled) 
[08:27:50.755]                           invokeRestart("muffleMessage")
[08:27:50.755]                       }
[08:27:50.755]                       else if (inherits(cond, "warning")) {
[08:27:50.755]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.755]                         if (muffled) 
[08:27:50.755]                           invokeRestart("muffleWarning")
[08:27:50.755]                       }
[08:27:50.755]                       else if (inherits(cond, "condition")) {
[08:27:50.755]                         if (!is.null(pattern)) {
[08:27:50.755]                           computeRestarts <- base::computeRestarts
[08:27:50.755]                           grepl <- base::grepl
[08:27:50.755]                           restarts <- computeRestarts(cond)
[08:27:50.755]                           for (restart in restarts) {
[08:27:50.755]                             name <- restart$name
[08:27:50.755]                             if (is.null(name)) 
[08:27:50.755]                               next
[08:27:50.755]                             if (!grepl(pattern, name)) 
[08:27:50.755]                               next
[08:27:50.755]                             invokeRestart(restart)
[08:27:50.755]                             muffled <- TRUE
[08:27:50.755]                             break
[08:27:50.755]                           }
[08:27:50.755]                         }
[08:27:50.755]                       }
[08:27:50.755]                       invisible(muffled)
[08:27:50.755]                     }
[08:27:50.755]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.755]                   }
[08:27:50.755]                 }
[08:27:50.755]             }
[08:27:50.755]         }))
[08:27:50.755]     }, error = function(ex) {
[08:27:50.755]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.755]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.755]                 ...future.rng), started = ...future.startTime, 
[08:27:50.755]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.755]             version = "1.8"), class = "FutureResult")
[08:27:50.755]     }, finally = {
[08:27:50.755]         if (!identical(...future.workdir, getwd())) 
[08:27:50.755]             setwd(...future.workdir)
[08:27:50.755]         {
[08:27:50.755]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.755]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.755]             }
[08:27:50.755]             base::options(...future.oldOptions)
[08:27:50.755]             if (.Platform$OS.type == "windows") {
[08:27:50.755]                 old_names <- names(...future.oldEnvVars)
[08:27:50.755]                 envs <- base::Sys.getenv()
[08:27:50.755]                 names <- names(envs)
[08:27:50.755]                 common <- intersect(names, old_names)
[08:27:50.755]                 added <- setdiff(names, old_names)
[08:27:50.755]                 removed <- setdiff(old_names, names)
[08:27:50.755]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.755]                   envs[common]]
[08:27:50.755]                 NAMES <- toupper(changed)
[08:27:50.755]                 args <- list()
[08:27:50.755]                 for (kk in seq_along(NAMES)) {
[08:27:50.755]                   name <- changed[[kk]]
[08:27:50.755]                   NAME <- NAMES[[kk]]
[08:27:50.755]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.755]                     next
[08:27:50.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.755]                 }
[08:27:50.755]                 NAMES <- toupper(added)
[08:27:50.755]                 for (kk in seq_along(NAMES)) {
[08:27:50.755]                   name <- added[[kk]]
[08:27:50.755]                   NAME <- NAMES[[kk]]
[08:27:50.755]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.755]                     next
[08:27:50.755]                   args[[name]] <- ""
[08:27:50.755]                 }
[08:27:50.755]                 NAMES <- toupper(removed)
[08:27:50.755]                 for (kk in seq_along(NAMES)) {
[08:27:50.755]                   name <- removed[[kk]]
[08:27:50.755]                   NAME <- NAMES[[kk]]
[08:27:50.755]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.755]                     next
[08:27:50.755]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.755]                 }
[08:27:50.755]                 if (length(args) > 0) 
[08:27:50.755]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.755]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.755]             }
[08:27:50.755]             else {
[08:27:50.755]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.755]             }
[08:27:50.755]             {
[08:27:50.755]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.755]                   0L) {
[08:27:50.755]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.755]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.755]                   base::options(opts)
[08:27:50.755]                 }
[08:27:50.755]                 {
[08:27:50.755]                   {
[08:27:50.755]                     NULL
[08:27:50.755]                     RNGkind("Mersenne-Twister")
[08:27:50.755]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.755]                       inherits = FALSE)
[08:27:50.755]                   }
[08:27:50.755]                   options(future.plan = NULL)
[08:27:50.755]                   if (is.na(NA_character_)) 
[08:27:50.755]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.755]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.755]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.755]                     .init = FALSE)
[08:27:50.755]                 }
[08:27:50.755]             }
[08:27:50.755]         }
[08:27:50.755]     })
[08:27:50.755]     if (TRUE) {
[08:27:50.755]         base::sink(type = "output", split = FALSE)
[08:27:50.755]         if (TRUE) {
[08:27:50.755]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.755]         }
[08:27:50.755]         else {
[08:27:50.755]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.755]         }
[08:27:50.755]         base::close(...future.stdout)
[08:27:50.755]         ...future.stdout <- NULL
[08:27:50.755]     }
[08:27:50.755]     ...future.result$conditions <- ...future.conditions
[08:27:50.755]     ...future.result$finished <- base::Sys.time()
[08:27:50.755]     ...future.result
[08:27:50.755] }
[08:27:50.756] plan(): Setting new future strategy stack:
[08:27:50.756] List of future strategies:
[08:27:50.756] 1. sequential:
[08:27:50.756]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.756]    - tweaked: FALSE
[08:27:50.756]    - call: NULL
[08:27:50.757] plan(): nbrOfWorkers() = 1
[08:27:50.758] plan(): Setting new future strategy stack:
[08:27:50.758] List of future strategies:
[08:27:50.758] 1. sequential:
[08:27:50.758]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.758]    - tweaked: FALSE
[08:27:50.758]    - call: plan(strategy)
[08:27:50.758] plan(): nbrOfWorkers() = 1
[08:27:50.758] SequentialFuture started (and completed)
[08:27:50.758] - Launch lazy future ... done
[08:27:50.758] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d8610e5790> 
Classes 'listenv', 'environment' <environment: 0x55d860e69350> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[08:27:50.762] resolved() for ‘SequentialFuture’ ...
[08:27:50.762] - state: ‘finished’
[08:27:50.762] - run: TRUE
[08:27:50.762] - result: ‘FutureResult’
[08:27:50.763] resolved() for ‘SequentialFuture’ ... done
[08:27:50.763] resolved() for ‘SequentialFuture’ ...
[08:27:50.763] - state: ‘finished’
[08:27:50.763] - run: TRUE
[08:27:50.763] - result: ‘FutureResult’
[08:27:50.763] resolved() for ‘SequentialFuture’ ... done
[08:27:50.763] resolved() for ‘SequentialFuture’ ...
[08:27:50.763] - state: ‘finished’
[08:27:50.763] - run: TRUE
[08:27:50.763] - result: ‘FutureResult’
[08:27:50.763] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:50.768] resolve() on list environment ...
[08:27:50.768]  recursive: 0
[08:27:50.769]  length: 6
[08:27:50.769]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:50.769] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.769] - nx: 6
[08:27:50.769] - relay: TRUE
[08:27:50.769] - stdout: TRUE
[08:27:50.769] - signal: TRUE
[08:27:50.769] - resignal: FALSE
[08:27:50.769] - force: TRUE
[08:27:50.770] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.770] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.770]  - until=2
[08:27:50.770]  - relaying element #2
[08:27:50.770] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.770] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.770] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.770]  length: 5 (resolved future 1)
[08:27:50.770] resolved() for ‘SequentialFuture’ ...
[08:27:50.770] - state: ‘finished’
[08:27:50.770] - run: TRUE
[08:27:50.771] - result: ‘FutureResult’
[08:27:50.771] resolved() for ‘SequentialFuture’ ... done
[08:27:50.771] Future #2
[08:27:50.771] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.771] - nx: 6
[08:27:50.771] - relay: TRUE
[08:27:50.771] - stdout: TRUE
[08:27:50.771] - signal: TRUE
[08:27:50.771] - resignal: FALSE
[08:27:50.771] - force: TRUE
[08:27:50.771] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.771] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.772]  - until=2
[08:27:50.772]  - relaying element #2
[08:27:50.772] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.772] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.772] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.772]  length: 4 (resolved future 2)
[08:27:50.772] resolved() for ‘SequentialFuture’ ...
[08:27:50.772] - state: ‘finished’
[08:27:50.772] - run: TRUE
[08:27:50.772] - result: ‘FutureResult’
[08:27:50.773] resolved() for ‘SequentialFuture’ ... done
[08:27:50.773] Future #3
[08:27:50.773] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.773] - nx: 6
[08:27:50.773] - relay: TRUE
[08:27:50.773] - stdout: TRUE
[08:27:50.773] - signal: TRUE
[08:27:50.773] - resignal: FALSE
[08:27:50.773] - force: TRUE
[08:27:50.773] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.773] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.773]  - until=3
[08:27:50.774]  - relaying element #3
[08:27:50.774] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.774] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.774] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.774]  length: 3 (resolved future 3)
[08:27:50.774] resolved() for ‘SequentialFuture’ ...
[08:27:50.774] - state: ‘finished’
[08:27:50.774] - run: TRUE
[08:27:50.774] - result: ‘FutureResult’
[08:27:50.774] resolved() for ‘SequentialFuture’ ... done
[08:27:50.775] Future #4
[08:27:50.775] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.775] - nx: 6
[08:27:50.775] - relay: TRUE
[08:27:50.775] - stdout: TRUE
[08:27:50.775] - signal: TRUE
[08:27:50.775] - resignal: FALSE
[08:27:50.775] - force: TRUE
[08:27:50.775] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.775] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.775]  - until=4
[08:27:50.775]  - relaying element #4
[08:27:50.776] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.776] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.776] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.776]  length: 2 (resolved future 4)
[08:27:50.776] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.776] - nx: 6
[08:27:50.776] - relay: TRUE
[08:27:50.776] - stdout: TRUE
[08:27:50.776] - signal: TRUE
[08:27:50.776] - resignal: FALSE
[08:27:50.776] - force: TRUE
[08:27:50.777] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.777] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.777]  - until=6
[08:27:50.777]  - relaying element #6
[08:27:50.777] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.777] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.777] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.777]  length: 1 (resolved future 5)
[08:27:50.777] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.777] - nx: 6
[08:27:50.777] - relay: TRUE
[08:27:50.777] - stdout: TRUE
[08:27:50.778] - signal: TRUE
[08:27:50.778] - resignal: FALSE
[08:27:50.778] - force: TRUE
[08:27:50.778] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.778] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.778]  - until=6
[08:27:50.778] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.778] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.778] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.778]  length: 0 (resolved future 6)
[08:27:50.778] Relaying remaining futures
[08:27:50.778] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.778] - nx: 6
[08:27:50.779] - relay: TRUE
[08:27:50.779] - stdout: TRUE
[08:27:50.779] - signal: TRUE
[08:27:50.779] - resignal: FALSE
[08:27:50.779] - force: TRUE
[08:27:50.779] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.779] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:50.779] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.779] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.779] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.779] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55d860a3f8d0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[08:27:50.782] getGlobalsAndPackages() ...
[08:27:50.782] Searching for globals...
[08:27:50.782] 
[08:27:50.782] Searching for globals ... DONE
[08:27:50.782] - globals: [0] <none>
[08:27:50.782] getGlobalsAndPackages() ... DONE
[08:27:50.783] run() for ‘Future’ ...
[08:27:50.783] - state: ‘created’
[08:27:50.783] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.783] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.783] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.783]   - Field: ‘label’
[08:27:50.783]   - Field: ‘local’
[08:27:50.783]   - Field: ‘owner’
[08:27:50.783]   - Field: ‘envir’
[08:27:50.784]   - Field: ‘packages’
[08:27:50.784]   - Field: ‘gc’
[08:27:50.784]   - Field: ‘conditions’
[08:27:50.784]   - Field: ‘expr’
[08:27:50.784]   - Field: ‘uuid’
[08:27:50.784]   - Field: ‘seed’
[08:27:50.784]   - Field: ‘version’
[08:27:50.784]   - Field: ‘result’
[08:27:50.784]   - Field: ‘asynchronous’
[08:27:50.784]   - Field: ‘calls’
[08:27:50.784]   - Field: ‘globals’
[08:27:50.785]   - Field: ‘stdout’
[08:27:50.785]   - Field: ‘earlySignal’
[08:27:50.785]   - Field: ‘lazy’
[08:27:50.785]   - Field: ‘state’
[08:27:50.785] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.785] - Launch lazy future ...
[08:27:50.785] Packages needed by the future expression (n = 0): <none>
[08:27:50.785] Packages needed by future strategies (n = 0): <none>
[08:27:50.786] {
[08:27:50.786]     {
[08:27:50.786]         {
[08:27:50.786]             ...future.startTime <- base::Sys.time()
[08:27:50.786]             {
[08:27:50.786]                 {
[08:27:50.786]                   {
[08:27:50.786]                     base::local({
[08:27:50.786]                       has_future <- base::requireNamespace("future", 
[08:27:50.786]                         quietly = TRUE)
[08:27:50.786]                       if (has_future) {
[08:27:50.786]                         ns <- base::getNamespace("future")
[08:27:50.786]                         version <- ns[[".package"]][["version"]]
[08:27:50.786]                         if (is.null(version)) 
[08:27:50.786]                           version <- utils::packageVersion("future")
[08:27:50.786]                       }
[08:27:50.786]                       else {
[08:27:50.786]                         version <- NULL
[08:27:50.786]                       }
[08:27:50.786]                       if (!has_future || version < "1.8.0") {
[08:27:50.786]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.786]                           "", base::R.version$version.string), 
[08:27:50.786]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.786]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.786]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.786]                             "release", "version")], collapse = " "), 
[08:27:50.786]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.786]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.786]                           info)
[08:27:50.786]                         info <- base::paste(info, collapse = "; ")
[08:27:50.786]                         if (!has_future) {
[08:27:50.786]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.786]                             info)
[08:27:50.786]                         }
[08:27:50.786]                         else {
[08:27:50.786]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.786]                             info, version)
[08:27:50.786]                         }
[08:27:50.786]                         base::stop(msg)
[08:27:50.786]                       }
[08:27:50.786]                     })
[08:27:50.786]                   }
[08:27:50.786]                   ...future.strategy.old <- future::plan("list")
[08:27:50.786]                   options(future.plan = NULL)
[08:27:50.786]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.786]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.786]                 }
[08:27:50.786]                 ...future.workdir <- getwd()
[08:27:50.786]             }
[08:27:50.786]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.786]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.786]         }
[08:27:50.786]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.786]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.786]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.786]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.786]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.786]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.786]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.786]             base::names(...future.oldOptions))
[08:27:50.786]     }
[08:27:50.786]     if (FALSE) {
[08:27:50.786]     }
[08:27:50.786]     else {
[08:27:50.786]         if (TRUE) {
[08:27:50.786]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.786]                 open = "w")
[08:27:50.786]         }
[08:27:50.786]         else {
[08:27:50.786]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.786]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.786]         }
[08:27:50.786]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.786]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.786]             base::sink(type = "output", split = FALSE)
[08:27:50.786]             base::close(...future.stdout)
[08:27:50.786]         }, add = TRUE)
[08:27:50.786]     }
[08:27:50.786]     ...future.frame <- base::sys.nframe()
[08:27:50.786]     ...future.conditions <- base::list()
[08:27:50.786]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.786]     if (FALSE) {
[08:27:50.786]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.786]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.786]     }
[08:27:50.786]     ...future.result <- base::tryCatch({
[08:27:50.786]         base::withCallingHandlers({
[08:27:50.786]             ...future.value <- base::withVisible(base::local(2))
[08:27:50.786]             future::FutureResult(value = ...future.value$value, 
[08:27:50.786]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.786]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.786]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.786]                     ...future.globalenv.names))
[08:27:50.786]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.786]         }, condition = base::local({
[08:27:50.786]             c <- base::c
[08:27:50.786]             inherits <- base::inherits
[08:27:50.786]             invokeRestart <- base::invokeRestart
[08:27:50.786]             length <- base::length
[08:27:50.786]             list <- base::list
[08:27:50.786]             seq.int <- base::seq.int
[08:27:50.786]             signalCondition <- base::signalCondition
[08:27:50.786]             sys.calls <- base::sys.calls
[08:27:50.786]             `[[` <- base::`[[`
[08:27:50.786]             `+` <- base::`+`
[08:27:50.786]             `<<-` <- base::`<<-`
[08:27:50.786]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.786]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.786]                   3L)]
[08:27:50.786]             }
[08:27:50.786]             function(cond) {
[08:27:50.786]                 is_error <- inherits(cond, "error")
[08:27:50.786]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.786]                   NULL)
[08:27:50.786]                 if (is_error) {
[08:27:50.786]                   sessionInformation <- function() {
[08:27:50.786]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.786]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.786]                       search = base::search(), system = base::Sys.info())
[08:27:50.786]                   }
[08:27:50.786]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.786]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.786]                     cond$call), session = sessionInformation(), 
[08:27:50.786]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.786]                   signalCondition(cond)
[08:27:50.786]                 }
[08:27:50.786]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.786]                 "immediateCondition"))) {
[08:27:50.786]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.786]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.786]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.786]                   if (TRUE && !signal) {
[08:27:50.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.786]                     {
[08:27:50.786]                       inherits <- base::inherits
[08:27:50.786]                       invokeRestart <- base::invokeRestart
[08:27:50.786]                       is.null <- base::is.null
[08:27:50.786]                       muffled <- FALSE
[08:27:50.786]                       if (inherits(cond, "message")) {
[08:27:50.786]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.786]                         if (muffled) 
[08:27:50.786]                           invokeRestart("muffleMessage")
[08:27:50.786]                       }
[08:27:50.786]                       else if (inherits(cond, "warning")) {
[08:27:50.786]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.786]                         if (muffled) 
[08:27:50.786]                           invokeRestart("muffleWarning")
[08:27:50.786]                       }
[08:27:50.786]                       else if (inherits(cond, "condition")) {
[08:27:50.786]                         if (!is.null(pattern)) {
[08:27:50.786]                           computeRestarts <- base::computeRestarts
[08:27:50.786]                           grepl <- base::grepl
[08:27:50.786]                           restarts <- computeRestarts(cond)
[08:27:50.786]                           for (restart in restarts) {
[08:27:50.786]                             name <- restart$name
[08:27:50.786]                             if (is.null(name)) 
[08:27:50.786]                               next
[08:27:50.786]                             if (!grepl(pattern, name)) 
[08:27:50.786]                               next
[08:27:50.786]                             invokeRestart(restart)
[08:27:50.786]                             muffled <- TRUE
[08:27:50.786]                             break
[08:27:50.786]                           }
[08:27:50.786]                         }
[08:27:50.786]                       }
[08:27:50.786]                       invisible(muffled)
[08:27:50.786]                     }
[08:27:50.786]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.786]                   }
[08:27:50.786]                 }
[08:27:50.786]                 else {
[08:27:50.786]                   if (TRUE) {
[08:27:50.786]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.786]                     {
[08:27:50.786]                       inherits <- base::inherits
[08:27:50.786]                       invokeRestart <- base::invokeRestart
[08:27:50.786]                       is.null <- base::is.null
[08:27:50.786]                       muffled <- FALSE
[08:27:50.786]                       if (inherits(cond, "message")) {
[08:27:50.786]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.786]                         if (muffled) 
[08:27:50.786]                           invokeRestart("muffleMessage")
[08:27:50.786]                       }
[08:27:50.786]                       else if (inherits(cond, "warning")) {
[08:27:50.786]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.786]                         if (muffled) 
[08:27:50.786]                           invokeRestart("muffleWarning")
[08:27:50.786]                       }
[08:27:50.786]                       else if (inherits(cond, "condition")) {
[08:27:50.786]                         if (!is.null(pattern)) {
[08:27:50.786]                           computeRestarts <- base::computeRestarts
[08:27:50.786]                           grepl <- base::grepl
[08:27:50.786]                           restarts <- computeRestarts(cond)
[08:27:50.786]                           for (restart in restarts) {
[08:27:50.786]                             name <- restart$name
[08:27:50.786]                             if (is.null(name)) 
[08:27:50.786]                               next
[08:27:50.786]                             if (!grepl(pattern, name)) 
[08:27:50.786]                               next
[08:27:50.786]                             invokeRestart(restart)
[08:27:50.786]                             muffled <- TRUE
[08:27:50.786]                             break
[08:27:50.786]                           }
[08:27:50.786]                         }
[08:27:50.786]                       }
[08:27:50.786]                       invisible(muffled)
[08:27:50.786]                     }
[08:27:50.786]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.786]                   }
[08:27:50.786]                 }
[08:27:50.786]             }
[08:27:50.786]         }))
[08:27:50.786]     }, error = function(ex) {
[08:27:50.786]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.786]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.786]                 ...future.rng), started = ...future.startTime, 
[08:27:50.786]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.786]             version = "1.8"), class = "FutureResult")
[08:27:50.786]     }, finally = {
[08:27:50.786]         if (!identical(...future.workdir, getwd())) 
[08:27:50.786]             setwd(...future.workdir)
[08:27:50.786]         {
[08:27:50.786]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.786]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.786]             }
[08:27:50.786]             base::options(...future.oldOptions)
[08:27:50.786]             if (.Platform$OS.type == "windows") {
[08:27:50.786]                 old_names <- names(...future.oldEnvVars)
[08:27:50.786]                 envs <- base::Sys.getenv()
[08:27:50.786]                 names <- names(envs)
[08:27:50.786]                 common <- intersect(names, old_names)
[08:27:50.786]                 added <- setdiff(names, old_names)
[08:27:50.786]                 removed <- setdiff(old_names, names)
[08:27:50.786]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.786]                   envs[common]]
[08:27:50.786]                 NAMES <- toupper(changed)
[08:27:50.786]                 args <- list()
[08:27:50.786]                 for (kk in seq_along(NAMES)) {
[08:27:50.786]                   name <- changed[[kk]]
[08:27:50.786]                   NAME <- NAMES[[kk]]
[08:27:50.786]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.786]                     next
[08:27:50.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.786]                 }
[08:27:50.786]                 NAMES <- toupper(added)
[08:27:50.786]                 for (kk in seq_along(NAMES)) {
[08:27:50.786]                   name <- added[[kk]]
[08:27:50.786]                   NAME <- NAMES[[kk]]
[08:27:50.786]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.786]                     next
[08:27:50.786]                   args[[name]] <- ""
[08:27:50.786]                 }
[08:27:50.786]                 NAMES <- toupper(removed)
[08:27:50.786]                 for (kk in seq_along(NAMES)) {
[08:27:50.786]                   name <- removed[[kk]]
[08:27:50.786]                   NAME <- NAMES[[kk]]
[08:27:50.786]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.786]                     next
[08:27:50.786]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.786]                 }
[08:27:50.786]                 if (length(args) > 0) 
[08:27:50.786]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.786]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.786]             }
[08:27:50.786]             else {
[08:27:50.786]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.786]             }
[08:27:50.786]             {
[08:27:50.786]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.786]                   0L) {
[08:27:50.786]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.786]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.786]                   base::options(opts)
[08:27:50.786]                 }
[08:27:50.786]                 {
[08:27:50.786]                   {
[08:27:50.786]                     NULL
[08:27:50.786]                     RNGkind("Mersenne-Twister")
[08:27:50.786]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.786]                       inherits = FALSE)
[08:27:50.786]                   }
[08:27:50.786]                   options(future.plan = NULL)
[08:27:50.786]                   if (is.na(NA_character_)) 
[08:27:50.786]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.786]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.786]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.786]                     .init = FALSE)
[08:27:50.786]                 }
[08:27:50.786]             }
[08:27:50.786]         }
[08:27:50.786]     })
[08:27:50.786]     if (TRUE) {
[08:27:50.786]         base::sink(type = "output", split = FALSE)
[08:27:50.786]         if (TRUE) {
[08:27:50.786]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.786]         }
[08:27:50.786]         else {
[08:27:50.786]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.786]         }
[08:27:50.786]         base::close(...future.stdout)
[08:27:50.786]         ...future.stdout <- NULL
[08:27:50.786]     }
[08:27:50.786]     ...future.result$conditions <- ...future.conditions
[08:27:50.786]     ...future.result$finished <- base::Sys.time()
[08:27:50.786]     ...future.result
[08:27:50.786] }
[08:27:50.788] plan(): Setting new future strategy stack:
[08:27:50.788] List of future strategies:
[08:27:50.788] 1. sequential:
[08:27:50.788]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.788]    - tweaked: FALSE
[08:27:50.788]    - call: NULL
[08:27:50.788] plan(): nbrOfWorkers() = 1
[08:27:50.789] plan(): Setting new future strategy stack:
[08:27:50.789] List of future strategies:
[08:27:50.789] 1. sequential:
[08:27:50.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.789]    - tweaked: FALSE
[08:27:50.789]    - call: plan(strategy)
[08:27:50.789] plan(): nbrOfWorkers() = 1
[08:27:50.790] SequentialFuture started (and completed)
[08:27:50.790] - Launch lazy future ... done
[08:27:50.790] run() for ‘SequentialFuture’ ... done
[08:27:50.790] getGlobalsAndPackages() ...
[08:27:50.790] Searching for globals...
[08:27:50.790] 
[08:27:50.790] Searching for globals ... DONE
[08:27:50.791] - globals: [0] <none>
[08:27:50.791] getGlobalsAndPackages() ... DONE
[08:27:50.792] run() for ‘Future’ ...
[08:27:50.792] - state: ‘created’
[08:27:50.793] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.793] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.793] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.793]   - Field: ‘label’
[08:27:50.793]   - Field: ‘local’
[08:27:50.793]   - Field: ‘owner’
[08:27:50.793]   - Field: ‘envir’
[08:27:50.794]   - Field: ‘packages’
[08:27:50.794]   - Field: ‘gc’
[08:27:50.794]   - Field: ‘conditions’
[08:27:50.794]   - Field: ‘expr’
[08:27:50.794]   - Field: ‘uuid’
[08:27:50.794]   - Field: ‘seed’
[08:27:50.794]   - Field: ‘version’
[08:27:50.794]   - Field: ‘result’
[08:27:50.794]   - Field: ‘asynchronous’
[08:27:50.794]   - Field: ‘calls’
[08:27:50.794]   - Field: ‘globals’
[08:27:50.795]   - Field: ‘stdout’
[08:27:50.795]   - Field: ‘earlySignal’
[08:27:50.795]   - Field: ‘lazy’
[08:27:50.795]   - Field: ‘state’
[08:27:50.795] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.795] - Launch lazy future ...
[08:27:50.795] Packages needed by the future expression (n = 0): <none>
[08:27:50.795] Packages needed by future strategies (n = 0): <none>
[08:27:50.796] {
[08:27:50.796]     {
[08:27:50.796]         {
[08:27:50.796]             ...future.startTime <- base::Sys.time()
[08:27:50.796]             {
[08:27:50.796]                 {
[08:27:50.796]                   {
[08:27:50.796]                     base::local({
[08:27:50.796]                       has_future <- base::requireNamespace("future", 
[08:27:50.796]                         quietly = TRUE)
[08:27:50.796]                       if (has_future) {
[08:27:50.796]                         ns <- base::getNamespace("future")
[08:27:50.796]                         version <- ns[[".package"]][["version"]]
[08:27:50.796]                         if (is.null(version)) 
[08:27:50.796]                           version <- utils::packageVersion("future")
[08:27:50.796]                       }
[08:27:50.796]                       else {
[08:27:50.796]                         version <- NULL
[08:27:50.796]                       }
[08:27:50.796]                       if (!has_future || version < "1.8.0") {
[08:27:50.796]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.796]                           "", base::R.version$version.string), 
[08:27:50.796]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.796]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.796]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.796]                             "release", "version")], collapse = " "), 
[08:27:50.796]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.796]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.796]                           info)
[08:27:50.796]                         info <- base::paste(info, collapse = "; ")
[08:27:50.796]                         if (!has_future) {
[08:27:50.796]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.796]                             info)
[08:27:50.796]                         }
[08:27:50.796]                         else {
[08:27:50.796]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.796]                             info, version)
[08:27:50.796]                         }
[08:27:50.796]                         base::stop(msg)
[08:27:50.796]                       }
[08:27:50.796]                     })
[08:27:50.796]                   }
[08:27:50.796]                   ...future.strategy.old <- future::plan("list")
[08:27:50.796]                   options(future.plan = NULL)
[08:27:50.796]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.796]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.796]                 }
[08:27:50.796]                 ...future.workdir <- getwd()
[08:27:50.796]             }
[08:27:50.796]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.796]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.796]         }
[08:27:50.796]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.796]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.796]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.796]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.796]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.796]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.796]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.796]             base::names(...future.oldOptions))
[08:27:50.796]     }
[08:27:50.796]     if (FALSE) {
[08:27:50.796]     }
[08:27:50.796]     else {
[08:27:50.796]         if (TRUE) {
[08:27:50.796]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.796]                 open = "w")
[08:27:50.796]         }
[08:27:50.796]         else {
[08:27:50.796]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.796]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.796]         }
[08:27:50.796]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.796]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.796]             base::sink(type = "output", split = FALSE)
[08:27:50.796]             base::close(...future.stdout)
[08:27:50.796]         }, add = TRUE)
[08:27:50.796]     }
[08:27:50.796]     ...future.frame <- base::sys.nframe()
[08:27:50.796]     ...future.conditions <- base::list()
[08:27:50.796]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.796]     if (FALSE) {
[08:27:50.796]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.796]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.796]     }
[08:27:50.796]     ...future.result <- base::tryCatch({
[08:27:50.796]         base::withCallingHandlers({
[08:27:50.796]             ...future.value <- base::withVisible(base::local(NULL))
[08:27:50.796]             future::FutureResult(value = ...future.value$value, 
[08:27:50.796]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.796]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.796]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.796]                     ...future.globalenv.names))
[08:27:50.796]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.796]         }, condition = base::local({
[08:27:50.796]             c <- base::c
[08:27:50.796]             inherits <- base::inherits
[08:27:50.796]             invokeRestart <- base::invokeRestart
[08:27:50.796]             length <- base::length
[08:27:50.796]             list <- base::list
[08:27:50.796]             seq.int <- base::seq.int
[08:27:50.796]             signalCondition <- base::signalCondition
[08:27:50.796]             sys.calls <- base::sys.calls
[08:27:50.796]             `[[` <- base::`[[`
[08:27:50.796]             `+` <- base::`+`
[08:27:50.796]             `<<-` <- base::`<<-`
[08:27:50.796]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.796]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.796]                   3L)]
[08:27:50.796]             }
[08:27:50.796]             function(cond) {
[08:27:50.796]                 is_error <- inherits(cond, "error")
[08:27:50.796]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.796]                   NULL)
[08:27:50.796]                 if (is_error) {
[08:27:50.796]                   sessionInformation <- function() {
[08:27:50.796]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.796]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.796]                       search = base::search(), system = base::Sys.info())
[08:27:50.796]                   }
[08:27:50.796]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.796]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.796]                     cond$call), session = sessionInformation(), 
[08:27:50.796]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.796]                   signalCondition(cond)
[08:27:50.796]                 }
[08:27:50.796]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.796]                 "immediateCondition"))) {
[08:27:50.796]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.796]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.796]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.796]                   if (TRUE && !signal) {
[08:27:50.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.796]                     {
[08:27:50.796]                       inherits <- base::inherits
[08:27:50.796]                       invokeRestart <- base::invokeRestart
[08:27:50.796]                       is.null <- base::is.null
[08:27:50.796]                       muffled <- FALSE
[08:27:50.796]                       if (inherits(cond, "message")) {
[08:27:50.796]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.796]                         if (muffled) 
[08:27:50.796]                           invokeRestart("muffleMessage")
[08:27:50.796]                       }
[08:27:50.796]                       else if (inherits(cond, "warning")) {
[08:27:50.796]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.796]                         if (muffled) 
[08:27:50.796]                           invokeRestart("muffleWarning")
[08:27:50.796]                       }
[08:27:50.796]                       else if (inherits(cond, "condition")) {
[08:27:50.796]                         if (!is.null(pattern)) {
[08:27:50.796]                           computeRestarts <- base::computeRestarts
[08:27:50.796]                           grepl <- base::grepl
[08:27:50.796]                           restarts <- computeRestarts(cond)
[08:27:50.796]                           for (restart in restarts) {
[08:27:50.796]                             name <- restart$name
[08:27:50.796]                             if (is.null(name)) 
[08:27:50.796]                               next
[08:27:50.796]                             if (!grepl(pattern, name)) 
[08:27:50.796]                               next
[08:27:50.796]                             invokeRestart(restart)
[08:27:50.796]                             muffled <- TRUE
[08:27:50.796]                             break
[08:27:50.796]                           }
[08:27:50.796]                         }
[08:27:50.796]                       }
[08:27:50.796]                       invisible(muffled)
[08:27:50.796]                     }
[08:27:50.796]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.796]                   }
[08:27:50.796]                 }
[08:27:50.796]                 else {
[08:27:50.796]                   if (TRUE) {
[08:27:50.796]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.796]                     {
[08:27:50.796]                       inherits <- base::inherits
[08:27:50.796]                       invokeRestart <- base::invokeRestart
[08:27:50.796]                       is.null <- base::is.null
[08:27:50.796]                       muffled <- FALSE
[08:27:50.796]                       if (inherits(cond, "message")) {
[08:27:50.796]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.796]                         if (muffled) 
[08:27:50.796]                           invokeRestart("muffleMessage")
[08:27:50.796]                       }
[08:27:50.796]                       else if (inherits(cond, "warning")) {
[08:27:50.796]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.796]                         if (muffled) 
[08:27:50.796]                           invokeRestart("muffleWarning")
[08:27:50.796]                       }
[08:27:50.796]                       else if (inherits(cond, "condition")) {
[08:27:50.796]                         if (!is.null(pattern)) {
[08:27:50.796]                           computeRestarts <- base::computeRestarts
[08:27:50.796]                           grepl <- base::grepl
[08:27:50.796]                           restarts <- computeRestarts(cond)
[08:27:50.796]                           for (restart in restarts) {
[08:27:50.796]                             name <- restart$name
[08:27:50.796]                             if (is.null(name)) 
[08:27:50.796]                               next
[08:27:50.796]                             if (!grepl(pattern, name)) 
[08:27:50.796]                               next
[08:27:50.796]                             invokeRestart(restart)
[08:27:50.796]                             muffled <- TRUE
[08:27:50.796]                             break
[08:27:50.796]                           }
[08:27:50.796]                         }
[08:27:50.796]                       }
[08:27:50.796]                       invisible(muffled)
[08:27:50.796]                     }
[08:27:50.796]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.796]                   }
[08:27:50.796]                 }
[08:27:50.796]             }
[08:27:50.796]         }))
[08:27:50.796]     }, error = function(ex) {
[08:27:50.796]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.796]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.796]                 ...future.rng), started = ...future.startTime, 
[08:27:50.796]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.796]             version = "1.8"), class = "FutureResult")
[08:27:50.796]     }, finally = {
[08:27:50.796]         if (!identical(...future.workdir, getwd())) 
[08:27:50.796]             setwd(...future.workdir)
[08:27:50.796]         {
[08:27:50.796]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.796]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.796]             }
[08:27:50.796]             base::options(...future.oldOptions)
[08:27:50.796]             if (.Platform$OS.type == "windows") {
[08:27:50.796]                 old_names <- names(...future.oldEnvVars)
[08:27:50.796]                 envs <- base::Sys.getenv()
[08:27:50.796]                 names <- names(envs)
[08:27:50.796]                 common <- intersect(names, old_names)
[08:27:50.796]                 added <- setdiff(names, old_names)
[08:27:50.796]                 removed <- setdiff(old_names, names)
[08:27:50.796]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.796]                   envs[common]]
[08:27:50.796]                 NAMES <- toupper(changed)
[08:27:50.796]                 args <- list()
[08:27:50.796]                 for (kk in seq_along(NAMES)) {
[08:27:50.796]                   name <- changed[[kk]]
[08:27:50.796]                   NAME <- NAMES[[kk]]
[08:27:50.796]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.796]                     next
[08:27:50.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.796]                 }
[08:27:50.796]                 NAMES <- toupper(added)
[08:27:50.796]                 for (kk in seq_along(NAMES)) {
[08:27:50.796]                   name <- added[[kk]]
[08:27:50.796]                   NAME <- NAMES[[kk]]
[08:27:50.796]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.796]                     next
[08:27:50.796]                   args[[name]] <- ""
[08:27:50.796]                 }
[08:27:50.796]                 NAMES <- toupper(removed)
[08:27:50.796]                 for (kk in seq_along(NAMES)) {
[08:27:50.796]                   name <- removed[[kk]]
[08:27:50.796]                   NAME <- NAMES[[kk]]
[08:27:50.796]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.796]                     next
[08:27:50.796]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.796]                 }
[08:27:50.796]                 if (length(args) > 0) 
[08:27:50.796]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.796]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.796]             }
[08:27:50.796]             else {
[08:27:50.796]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.796]             }
[08:27:50.796]             {
[08:27:50.796]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.796]                   0L) {
[08:27:50.796]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.796]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.796]                   base::options(opts)
[08:27:50.796]                 }
[08:27:50.796]                 {
[08:27:50.796]                   {
[08:27:50.796]                     NULL
[08:27:50.796]                     RNGkind("Mersenne-Twister")
[08:27:50.796]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.796]                       inherits = FALSE)
[08:27:50.796]                   }
[08:27:50.796]                   options(future.plan = NULL)
[08:27:50.796]                   if (is.na(NA_character_)) 
[08:27:50.796]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.796]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.796]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.796]                     .init = FALSE)
[08:27:50.796]                 }
[08:27:50.796]             }
[08:27:50.796]         }
[08:27:50.796]     })
[08:27:50.796]     if (TRUE) {
[08:27:50.796]         base::sink(type = "output", split = FALSE)
[08:27:50.796]         if (TRUE) {
[08:27:50.796]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.796]         }
[08:27:50.796]         else {
[08:27:50.796]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.796]         }
[08:27:50.796]         base::close(...future.stdout)
[08:27:50.796]         ...future.stdout <- NULL
[08:27:50.796]     }
[08:27:50.796]     ...future.result$conditions <- ...future.conditions
[08:27:50.796]     ...future.result$finished <- base::Sys.time()
[08:27:50.796]     ...future.result
[08:27:50.796] }
[08:27:50.798] plan(): Setting new future strategy stack:
[08:27:50.798] List of future strategies:
[08:27:50.798] 1. sequential:
[08:27:50.798]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.798]    - tweaked: FALSE
[08:27:50.798]    - call: NULL
[08:27:50.798] plan(): nbrOfWorkers() = 1
[08:27:50.799] plan(): Setting new future strategy stack:
[08:27:50.799] List of future strategies:
[08:27:50.799] 1. sequential:
[08:27:50.799]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.799]    - tweaked: FALSE
[08:27:50.799]    - call: plan(strategy)
[08:27:50.799] plan(): nbrOfWorkers() = 1
[08:27:50.799] SequentialFuture started (and completed)
[08:27:50.800] - Launch lazy future ... done
[08:27:50.800] run() for ‘SequentialFuture’ ... done
[08:27:50.800] getGlobalsAndPackages() ...
[08:27:50.800] Searching for globals...
[08:27:50.801] - globals found: [1] ‘{’
[08:27:50.801] Searching for globals ... DONE
[08:27:50.801] Resolving globals: FALSE
[08:27:50.801] 
[08:27:50.801] 
[08:27:50.801] getGlobalsAndPackages() ... DONE
[08:27:50.802] run() for ‘Future’ ...
[08:27:50.802] - state: ‘created’
[08:27:50.802] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:27:50.802] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:27:50.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:27:50.802]   - Field: ‘label’
[08:27:50.802]   - Field: ‘local’
[08:27:50.802]   - Field: ‘owner’
[08:27:50.803]   - Field: ‘envir’
[08:27:50.803]   - Field: ‘packages’
[08:27:50.803]   - Field: ‘gc’
[08:27:50.803]   - Field: ‘conditions’
[08:27:50.803]   - Field: ‘expr’
[08:27:50.803]   - Field: ‘uuid’
[08:27:50.803]   - Field: ‘seed’
[08:27:50.803]   - Field: ‘version’
[08:27:50.803]   - Field: ‘result’
[08:27:50.803]   - Field: ‘asynchronous’
[08:27:50.803]   - Field: ‘calls’
[08:27:50.803]   - Field: ‘globals’
[08:27:50.804]   - Field: ‘stdout’
[08:27:50.804]   - Field: ‘earlySignal’
[08:27:50.804]   - Field: ‘lazy’
[08:27:50.804]   - Field: ‘state’
[08:27:50.804] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:27:50.804] - Launch lazy future ...
[08:27:50.804] Packages needed by the future expression (n = 0): <none>
[08:27:50.804] Packages needed by future strategies (n = 0): <none>
[08:27:50.805] {
[08:27:50.805]     {
[08:27:50.805]         {
[08:27:50.805]             ...future.startTime <- base::Sys.time()
[08:27:50.805]             {
[08:27:50.805]                 {
[08:27:50.805]                   {
[08:27:50.805]                     base::local({
[08:27:50.805]                       has_future <- base::requireNamespace("future", 
[08:27:50.805]                         quietly = TRUE)
[08:27:50.805]                       if (has_future) {
[08:27:50.805]                         ns <- base::getNamespace("future")
[08:27:50.805]                         version <- ns[[".package"]][["version"]]
[08:27:50.805]                         if (is.null(version)) 
[08:27:50.805]                           version <- utils::packageVersion("future")
[08:27:50.805]                       }
[08:27:50.805]                       else {
[08:27:50.805]                         version <- NULL
[08:27:50.805]                       }
[08:27:50.805]                       if (!has_future || version < "1.8.0") {
[08:27:50.805]                         info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.805]                           "", base::R.version$version.string), 
[08:27:50.805]                           platform = base::sprintf("%s (%s-bit)", 
[08:27:50.805]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.805]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.805]                             "release", "version")], collapse = " "), 
[08:27:50.805]                           hostname = base::Sys.info()[["nodename"]])
[08:27:50.805]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.805]                           info)
[08:27:50.805]                         info <- base::paste(info, collapse = "; ")
[08:27:50.805]                         if (!has_future) {
[08:27:50.805]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.805]                             info)
[08:27:50.805]                         }
[08:27:50.805]                         else {
[08:27:50.805]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.805]                             info, version)
[08:27:50.805]                         }
[08:27:50.805]                         base::stop(msg)
[08:27:50.805]                       }
[08:27:50.805]                     })
[08:27:50.805]                   }
[08:27:50.805]                   ...future.strategy.old <- future::plan("list")
[08:27:50.805]                   options(future.plan = NULL)
[08:27:50.805]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.805]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.805]                 }
[08:27:50.805]                 ...future.workdir <- getwd()
[08:27:50.805]             }
[08:27:50.805]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.805]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.805]         }
[08:27:50.805]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.805]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.805]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.805]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.805]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.805]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.805]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.805]             base::names(...future.oldOptions))
[08:27:50.805]     }
[08:27:50.805]     if (FALSE) {
[08:27:50.805]     }
[08:27:50.805]     else {
[08:27:50.805]         if (TRUE) {
[08:27:50.805]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.805]                 open = "w")
[08:27:50.805]         }
[08:27:50.805]         else {
[08:27:50.805]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.805]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.805]         }
[08:27:50.805]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.805]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.805]             base::sink(type = "output", split = FALSE)
[08:27:50.805]             base::close(...future.stdout)
[08:27:50.805]         }, add = TRUE)
[08:27:50.805]     }
[08:27:50.805]     ...future.frame <- base::sys.nframe()
[08:27:50.805]     ...future.conditions <- base::list()
[08:27:50.805]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.805]     if (FALSE) {
[08:27:50.805]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.805]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.805]     }
[08:27:50.805]     ...future.result <- base::tryCatch({
[08:27:50.805]         base::withCallingHandlers({
[08:27:50.805]             ...future.value <- base::withVisible(base::local({
[08:27:50.805]                 4
[08:27:50.805]             }))
[08:27:50.805]             future::FutureResult(value = ...future.value$value, 
[08:27:50.805]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.805]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.805]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.805]                     ...future.globalenv.names))
[08:27:50.805]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.805]         }, condition = base::local({
[08:27:50.805]             c <- base::c
[08:27:50.805]             inherits <- base::inherits
[08:27:50.805]             invokeRestart <- base::invokeRestart
[08:27:50.805]             length <- base::length
[08:27:50.805]             list <- base::list
[08:27:50.805]             seq.int <- base::seq.int
[08:27:50.805]             signalCondition <- base::signalCondition
[08:27:50.805]             sys.calls <- base::sys.calls
[08:27:50.805]             `[[` <- base::`[[`
[08:27:50.805]             `+` <- base::`+`
[08:27:50.805]             `<<-` <- base::`<<-`
[08:27:50.805]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.805]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.805]                   3L)]
[08:27:50.805]             }
[08:27:50.805]             function(cond) {
[08:27:50.805]                 is_error <- inherits(cond, "error")
[08:27:50.805]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.805]                   NULL)
[08:27:50.805]                 if (is_error) {
[08:27:50.805]                   sessionInformation <- function() {
[08:27:50.805]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.805]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.805]                       search = base::search(), system = base::Sys.info())
[08:27:50.805]                   }
[08:27:50.805]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.805]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.805]                     cond$call), session = sessionInformation(), 
[08:27:50.805]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.805]                   signalCondition(cond)
[08:27:50.805]                 }
[08:27:50.805]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.805]                 "immediateCondition"))) {
[08:27:50.805]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.805]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.805]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.805]                   if (TRUE && !signal) {
[08:27:50.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.805]                     {
[08:27:50.805]                       inherits <- base::inherits
[08:27:50.805]                       invokeRestart <- base::invokeRestart
[08:27:50.805]                       is.null <- base::is.null
[08:27:50.805]                       muffled <- FALSE
[08:27:50.805]                       if (inherits(cond, "message")) {
[08:27:50.805]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.805]                         if (muffled) 
[08:27:50.805]                           invokeRestart("muffleMessage")
[08:27:50.805]                       }
[08:27:50.805]                       else if (inherits(cond, "warning")) {
[08:27:50.805]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.805]                         if (muffled) 
[08:27:50.805]                           invokeRestart("muffleWarning")
[08:27:50.805]                       }
[08:27:50.805]                       else if (inherits(cond, "condition")) {
[08:27:50.805]                         if (!is.null(pattern)) {
[08:27:50.805]                           computeRestarts <- base::computeRestarts
[08:27:50.805]                           grepl <- base::grepl
[08:27:50.805]                           restarts <- computeRestarts(cond)
[08:27:50.805]                           for (restart in restarts) {
[08:27:50.805]                             name <- restart$name
[08:27:50.805]                             if (is.null(name)) 
[08:27:50.805]                               next
[08:27:50.805]                             if (!grepl(pattern, name)) 
[08:27:50.805]                               next
[08:27:50.805]                             invokeRestart(restart)
[08:27:50.805]                             muffled <- TRUE
[08:27:50.805]                             break
[08:27:50.805]                           }
[08:27:50.805]                         }
[08:27:50.805]                       }
[08:27:50.805]                       invisible(muffled)
[08:27:50.805]                     }
[08:27:50.805]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.805]                   }
[08:27:50.805]                 }
[08:27:50.805]                 else {
[08:27:50.805]                   if (TRUE) {
[08:27:50.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.805]                     {
[08:27:50.805]                       inherits <- base::inherits
[08:27:50.805]                       invokeRestart <- base::invokeRestart
[08:27:50.805]                       is.null <- base::is.null
[08:27:50.805]                       muffled <- FALSE
[08:27:50.805]                       if (inherits(cond, "message")) {
[08:27:50.805]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.805]                         if (muffled) 
[08:27:50.805]                           invokeRestart("muffleMessage")
[08:27:50.805]                       }
[08:27:50.805]                       else if (inherits(cond, "warning")) {
[08:27:50.805]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.805]                         if (muffled) 
[08:27:50.805]                           invokeRestart("muffleWarning")
[08:27:50.805]                       }
[08:27:50.805]                       else if (inherits(cond, "condition")) {
[08:27:50.805]                         if (!is.null(pattern)) {
[08:27:50.805]                           computeRestarts <- base::computeRestarts
[08:27:50.805]                           grepl <- base::grepl
[08:27:50.805]                           restarts <- computeRestarts(cond)
[08:27:50.805]                           for (restart in restarts) {
[08:27:50.805]                             name <- restart$name
[08:27:50.805]                             if (is.null(name)) 
[08:27:50.805]                               next
[08:27:50.805]                             if (!grepl(pattern, name)) 
[08:27:50.805]                               next
[08:27:50.805]                             invokeRestart(restart)
[08:27:50.805]                             muffled <- TRUE
[08:27:50.805]                             break
[08:27:50.805]                           }
[08:27:50.805]                         }
[08:27:50.805]                       }
[08:27:50.805]                       invisible(muffled)
[08:27:50.805]                     }
[08:27:50.805]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.805]                   }
[08:27:50.805]                 }
[08:27:50.805]             }
[08:27:50.805]         }))
[08:27:50.805]     }, error = function(ex) {
[08:27:50.805]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.805]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.805]                 ...future.rng), started = ...future.startTime, 
[08:27:50.805]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.805]             version = "1.8"), class = "FutureResult")
[08:27:50.805]     }, finally = {
[08:27:50.805]         if (!identical(...future.workdir, getwd())) 
[08:27:50.805]             setwd(...future.workdir)
[08:27:50.805]         {
[08:27:50.805]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.805]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.805]             }
[08:27:50.805]             base::options(...future.oldOptions)
[08:27:50.805]             if (.Platform$OS.type == "windows") {
[08:27:50.805]                 old_names <- names(...future.oldEnvVars)
[08:27:50.805]                 envs <- base::Sys.getenv()
[08:27:50.805]                 names <- names(envs)
[08:27:50.805]                 common <- intersect(names, old_names)
[08:27:50.805]                 added <- setdiff(names, old_names)
[08:27:50.805]                 removed <- setdiff(old_names, names)
[08:27:50.805]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.805]                   envs[common]]
[08:27:50.805]                 NAMES <- toupper(changed)
[08:27:50.805]                 args <- list()
[08:27:50.805]                 for (kk in seq_along(NAMES)) {
[08:27:50.805]                   name <- changed[[kk]]
[08:27:50.805]                   NAME <- NAMES[[kk]]
[08:27:50.805]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.805]                     next
[08:27:50.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.805]                 }
[08:27:50.805]                 NAMES <- toupper(added)
[08:27:50.805]                 for (kk in seq_along(NAMES)) {
[08:27:50.805]                   name <- added[[kk]]
[08:27:50.805]                   NAME <- NAMES[[kk]]
[08:27:50.805]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.805]                     next
[08:27:50.805]                   args[[name]] <- ""
[08:27:50.805]                 }
[08:27:50.805]                 NAMES <- toupper(removed)
[08:27:50.805]                 for (kk in seq_along(NAMES)) {
[08:27:50.805]                   name <- removed[[kk]]
[08:27:50.805]                   NAME <- NAMES[[kk]]
[08:27:50.805]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.805]                     next
[08:27:50.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.805]                 }
[08:27:50.805]                 if (length(args) > 0) 
[08:27:50.805]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.805]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.805]             }
[08:27:50.805]             else {
[08:27:50.805]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.805]             }
[08:27:50.805]             {
[08:27:50.805]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.805]                   0L) {
[08:27:50.805]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.805]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.805]                   base::options(opts)
[08:27:50.805]                 }
[08:27:50.805]                 {
[08:27:50.805]                   {
[08:27:50.805]                     NULL
[08:27:50.805]                     RNGkind("Mersenne-Twister")
[08:27:50.805]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:27:50.805]                       inherits = FALSE)
[08:27:50.805]                   }
[08:27:50.805]                   options(future.plan = NULL)
[08:27:50.805]                   if (is.na(NA_character_)) 
[08:27:50.805]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.805]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.805]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.805]                     .init = FALSE)
[08:27:50.805]                 }
[08:27:50.805]             }
[08:27:50.805]         }
[08:27:50.805]     })
[08:27:50.805]     if (TRUE) {
[08:27:50.805]         base::sink(type = "output", split = FALSE)
[08:27:50.805]         if (TRUE) {
[08:27:50.805]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.805]         }
[08:27:50.805]         else {
[08:27:50.805]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.805]         }
[08:27:50.805]         base::close(...future.stdout)
[08:27:50.805]         ...future.stdout <- NULL
[08:27:50.805]     }
[08:27:50.805]     ...future.result$conditions <- ...future.conditions
[08:27:50.805]     ...future.result$finished <- base::Sys.time()
[08:27:50.805]     ...future.result
[08:27:50.805] }
[08:27:50.806] plan(): Setting new future strategy stack:
[08:27:50.807] List of future strategies:
[08:27:50.807] 1. sequential:
[08:27:50.807]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.807]    - tweaked: FALSE
[08:27:50.807]    - call: NULL
[08:27:50.807] plan(): nbrOfWorkers() = 1
[08:27:50.808] plan(): Setting new future strategy stack:
[08:27:50.808] List of future strategies:
[08:27:50.808] 1. sequential:
[08:27:50.808]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.808]    - tweaked: FALSE
[08:27:50.808]    - call: plan(strategy)
[08:27:50.808] plan(): nbrOfWorkers() = 1
[08:27:50.808] SequentialFuture started (and completed)
[08:27:50.809] - Launch lazy future ... done
[08:27:50.809] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d860c72180> 
Classes 'listenv', 'environment' <environment: 0x55d860a65100> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[08:27:50.813] resolved() for ‘SequentialFuture’ ...
[08:27:50.813] - state: ‘finished’
[08:27:50.813] - run: TRUE
[08:27:50.813] - result: ‘FutureResult’
[08:27:50.813] resolved() for ‘SequentialFuture’ ... done
[08:27:50.813] resolved() for ‘SequentialFuture’ ...
[08:27:50.813] - state: ‘finished’
[08:27:50.813] - run: TRUE
[08:27:50.813] - result: ‘FutureResult’
[08:27:50.813] resolved() for ‘SequentialFuture’ ... done
[08:27:50.813] resolved() for ‘SequentialFuture’ ...
[08:27:50.814] - state: ‘finished’
[08:27:50.814] - run: TRUE
[08:27:50.814] - result: ‘FutureResult’
[08:27:50.814] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:50.817] resolve() on list environment ...
[08:27:50.817]  recursive: 0
[08:27:50.818]  length: 6
[08:27:50.818]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:50.818] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.818] - nx: 6
[08:27:50.818] - relay: TRUE
[08:27:50.818] - stdout: TRUE
[08:27:50.818] - signal: TRUE
[08:27:50.818] - resignal: FALSE
[08:27:50.818] - force: TRUE
[08:27:50.818] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.818] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.819]  - until=2
[08:27:50.819]  - relaying element #2
[08:27:50.820] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.820] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.821] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.821]  length: 5 (resolved future 1)
[08:27:50.821] resolved() for ‘SequentialFuture’ ...
[08:27:50.821] - state: ‘finished’
[08:27:50.821] - run: TRUE
[08:27:50.821] - result: ‘FutureResult’
[08:27:50.821] resolved() for ‘SequentialFuture’ ... done
[08:27:50.821] Future #2
[08:27:50.822] signalConditionsASAP(SequentialFuture, pos=2) ...
[08:27:50.822] - nx: 6
[08:27:50.822] - relay: TRUE
[08:27:50.822] - stdout: TRUE
[08:27:50.822] - signal: TRUE
[08:27:50.822] - resignal: FALSE
[08:27:50.822] - force: TRUE
[08:27:50.822] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.822] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.822]  - until=2
[08:27:50.822]  - relaying element #2
[08:27:50.823] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.823] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.823] signalConditionsASAP(SequentialFuture, pos=2) ... done
[08:27:50.823]  length: 4 (resolved future 2)
[08:27:50.823] resolved() for ‘SequentialFuture’ ...
[08:27:50.823] - state: ‘finished’
[08:27:50.823] - run: TRUE
[08:27:50.823] - result: ‘FutureResult’
[08:27:50.823] resolved() for ‘SequentialFuture’ ... done
[08:27:50.824] Future #3
[08:27:50.824] signalConditionsASAP(SequentialFuture, pos=3) ...
[08:27:50.824] - nx: 6
[08:27:50.824] - relay: TRUE
[08:27:50.824] - stdout: TRUE
[08:27:50.824] - signal: TRUE
[08:27:50.824] - resignal: FALSE
[08:27:50.824] - force: TRUE
[08:27:50.824] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.824] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.824]  - until=3
[08:27:50.824]  - relaying element #3
[08:27:50.825] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.825] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.825] signalConditionsASAP(SequentialFuture, pos=3) ... done
[08:27:50.825]  length: 3 (resolved future 3)
[08:27:50.825] resolved() for ‘SequentialFuture’ ...
[08:27:50.825] - state: ‘finished’
[08:27:50.825] - run: TRUE
[08:27:50.825] - result: ‘FutureResult’
[08:27:50.825] resolved() for ‘SequentialFuture’ ... done
[08:27:50.825] Future #4
[08:27:50.826] signalConditionsASAP(SequentialFuture, pos=4) ...
[08:27:50.826] - nx: 6
[08:27:50.826] - relay: TRUE
[08:27:50.826] - stdout: TRUE
[08:27:50.826] - signal: TRUE
[08:27:50.826] - resignal: FALSE
[08:27:50.826] - force: TRUE
[08:27:50.826] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.826] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.826]  - until=4
[08:27:50.826]  - relaying element #4
[08:27:50.827] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.827] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.827] signalConditionsASAP(SequentialFuture, pos=4) ... done
[08:27:50.827]  length: 2 (resolved future 4)
[08:27:50.827] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.827] - nx: 6
[08:27:50.827] - relay: TRUE
[08:27:50.827] - stdout: TRUE
[08:27:50.827] - signal: TRUE
[08:27:50.827] - resignal: FALSE
[08:27:50.827] - force: TRUE
[08:27:50.827] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.828] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.828]  - until=6
[08:27:50.828]  - relaying element #6
[08:27:50.828] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.828] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.828] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.828]  length: 1 (resolved future 5)
[08:27:50.828] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.828] - nx: 6
[08:27:50.828] - relay: TRUE
[08:27:50.828] - stdout: TRUE
[08:27:50.829] - signal: TRUE
[08:27:50.829] - resignal: FALSE
[08:27:50.829] - force: TRUE
[08:27:50.829] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.829] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.829]  - until=6
[08:27:50.829] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.829] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.829] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.829]  length: 0 (resolved future 6)
[08:27:50.829] Relaying remaining futures
[08:27:50.829] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.829] - nx: 6
[08:27:50.830] - relay: TRUE
[08:27:50.830] - stdout: TRUE
[08:27:50.830] - signal: TRUE
[08:27:50.830] - resignal: FALSE
[08:27:50.830] - force: TRUE
[08:27:50.830] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.830] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:50.830] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.830] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.830] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.830] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55d86103c7c0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[08:27:50.833] plan(): Setting new future strategy stack:
[08:27:50.833] List of future strategies:
[08:27:50.833] 1. multicore:
[08:27:50.833]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:50.833]    - tweaked: FALSE
[08:27:50.833]    - call: plan(strategy)
[08:27:50.835] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[08:27:50.835] getGlobalsAndPackages() ...
[08:27:50.836] Searching for globals...
[08:27:50.836] 
[08:27:50.836] Searching for globals ... DONE
[08:27:50.836] - globals: [0] <none>
[08:27:50.836] getGlobalsAndPackages() ... DONE
[08:27:50.836] run() for ‘Future’ ...
[08:27:50.837] - state: ‘created’
[08:27:50.837] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:50.838] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:50.838] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:50.839]   - Field: ‘label’
[08:27:50.839]   - Field: ‘local’
[08:27:50.839]   - Field: ‘owner’
[08:27:50.839]   - Field: ‘envir’
[08:27:50.839]   - Field: ‘workers’
[08:27:50.839]   - Field: ‘packages’
[08:27:50.839]   - Field: ‘gc’
[08:27:50.839]   - Field: ‘job’
[08:27:50.839]   - Field: ‘conditions’
[08:27:50.839]   - Field: ‘expr’
[08:27:50.839]   - Field: ‘uuid’
[08:27:50.839]   - Field: ‘seed’
[08:27:50.840]   - Field: ‘version’
[08:27:50.840]   - Field: ‘result’
[08:27:50.840]   - Field: ‘asynchronous’
[08:27:50.840]   - Field: ‘calls’
[08:27:50.840]   - Field: ‘globals’
[08:27:50.840]   - Field: ‘stdout’
[08:27:50.840]   - Field: ‘earlySignal’
[08:27:50.840]   - Field: ‘lazy’
[08:27:50.840]   - Field: ‘state’
[08:27:50.840] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:50.841] - Launch lazy future ...
[08:27:50.842] Packages needed by the future expression (n = 0): <none>
[08:27:50.842] Packages needed by future strategies (n = 0): <none>
[08:27:50.842] {
[08:27:50.842]     {
[08:27:50.842]         {
[08:27:50.842]             ...future.startTime <- base::Sys.time()
[08:27:50.842]             {
[08:27:50.842]                 {
[08:27:50.842]                   {
[08:27:50.842]                     {
[08:27:50.842]                       base::local({
[08:27:50.842]                         has_future <- base::requireNamespace("future", 
[08:27:50.842]                           quietly = TRUE)
[08:27:50.842]                         if (has_future) {
[08:27:50.842]                           ns <- base::getNamespace("future")
[08:27:50.842]                           version <- ns[[".package"]][["version"]]
[08:27:50.842]                           if (is.null(version)) 
[08:27:50.842]                             version <- utils::packageVersion("future")
[08:27:50.842]                         }
[08:27:50.842]                         else {
[08:27:50.842]                           version <- NULL
[08:27:50.842]                         }
[08:27:50.842]                         if (!has_future || version < "1.8.0") {
[08:27:50.842]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.842]                             "", base::R.version$version.string), 
[08:27:50.842]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:50.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.842]                               "release", "version")], collapse = " "), 
[08:27:50.842]                             hostname = base::Sys.info()[["nodename"]])
[08:27:50.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.842]                             info)
[08:27:50.842]                           info <- base::paste(info, collapse = "; ")
[08:27:50.842]                           if (!has_future) {
[08:27:50.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.842]                               info)
[08:27:50.842]                           }
[08:27:50.842]                           else {
[08:27:50.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.842]                               info, version)
[08:27:50.842]                           }
[08:27:50.842]                           base::stop(msg)
[08:27:50.842]                         }
[08:27:50.842]                       })
[08:27:50.842]                     }
[08:27:50.842]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:50.842]                     base::options(mc.cores = 1L)
[08:27:50.842]                   }
[08:27:50.842]                   ...future.strategy.old <- future::plan("list")
[08:27:50.842]                   options(future.plan = NULL)
[08:27:50.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.842]                 }
[08:27:50.842]                 ...future.workdir <- getwd()
[08:27:50.842]             }
[08:27:50.842]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.842]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.842]         }
[08:27:50.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.842]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.842]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.842]             base::names(...future.oldOptions))
[08:27:50.842]     }
[08:27:50.842]     if (FALSE) {
[08:27:50.842]     }
[08:27:50.842]     else {
[08:27:50.842]         if (TRUE) {
[08:27:50.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.842]                 open = "w")
[08:27:50.842]         }
[08:27:50.842]         else {
[08:27:50.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.842]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.842]         }
[08:27:50.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.842]             base::sink(type = "output", split = FALSE)
[08:27:50.842]             base::close(...future.stdout)
[08:27:50.842]         }, add = TRUE)
[08:27:50.842]     }
[08:27:50.842]     ...future.frame <- base::sys.nframe()
[08:27:50.842]     ...future.conditions <- base::list()
[08:27:50.842]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.842]     if (FALSE) {
[08:27:50.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.842]     }
[08:27:50.842]     ...future.result <- base::tryCatch({
[08:27:50.842]         base::withCallingHandlers({
[08:27:50.842]             ...future.value <- base::withVisible(base::local({
[08:27:50.842]                 withCallingHandlers({
[08:27:50.842]                   2
[08:27:50.842]                 }, immediateCondition = function(cond) {
[08:27:50.842]                   save_rds <- function (object, pathname, ...) 
[08:27:50.842]                   {
[08:27:50.842]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:50.842]                     if (file_test("-f", pathname_tmp)) {
[08:27:50.842]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.842]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:50.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.842]                         fi_tmp[["mtime"]])
[08:27:50.842]                     }
[08:27:50.842]                     tryCatch({
[08:27:50.842]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:50.842]                     }, error = function(ex) {
[08:27:50.842]                       msg <- conditionMessage(ex)
[08:27:50.842]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.842]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:50.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.842]                         fi_tmp[["mtime"]], msg)
[08:27:50.842]                       ex$message <- msg
[08:27:50.842]                       stop(ex)
[08:27:50.842]                     })
[08:27:50.842]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:50.842]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:50.842]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:50.842]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.842]                       fi <- file.info(pathname)
[08:27:50.842]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:50.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.842]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:50.842]                         fi[["size"]], fi[["mtime"]])
[08:27:50.842]                       stop(msg)
[08:27:50.842]                     }
[08:27:50.842]                     invisible(pathname)
[08:27:50.842]                   }
[08:27:50.842]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:50.842]                     rootPath = tempdir()) 
[08:27:50.842]                   {
[08:27:50.842]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:50.842]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:50.842]                       tmpdir = path, fileext = ".rds")
[08:27:50.842]                     save_rds(obj, file)
[08:27:50.842]                   }
[08:27:50.842]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:50.842]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.842]                   {
[08:27:50.842]                     inherits <- base::inherits
[08:27:50.842]                     invokeRestart <- base::invokeRestart
[08:27:50.842]                     is.null <- base::is.null
[08:27:50.842]                     muffled <- FALSE
[08:27:50.842]                     if (inherits(cond, "message")) {
[08:27:50.842]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:50.842]                       if (muffled) 
[08:27:50.842]                         invokeRestart("muffleMessage")
[08:27:50.842]                     }
[08:27:50.842]                     else if (inherits(cond, "warning")) {
[08:27:50.842]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:50.842]                       if (muffled) 
[08:27:50.842]                         invokeRestart("muffleWarning")
[08:27:50.842]                     }
[08:27:50.842]                     else if (inherits(cond, "condition")) {
[08:27:50.842]                       if (!is.null(pattern)) {
[08:27:50.842]                         computeRestarts <- base::computeRestarts
[08:27:50.842]                         grepl <- base::grepl
[08:27:50.842]                         restarts <- computeRestarts(cond)
[08:27:50.842]                         for (restart in restarts) {
[08:27:50.842]                           name <- restart$name
[08:27:50.842]                           if (is.null(name)) 
[08:27:50.842]                             next
[08:27:50.842]                           if (!grepl(pattern, name)) 
[08:27:50.842]                             next
[08:27:50.842]                           invokeRestart(restart)
[08:27:50.842]                           muffled <- TRUE
[08:27:50.842]                           break
[08:27:50.842]                         }
[08:27:50.842]                       }
[08:27:50.842]                     }
[08:27:50.842]                     invisible(muffled)
[08:27:50.842]                   }
[08:27:50.842]                   muffleCondition(cond)
[08:27:50.842]                 })
[08:27:50.842]             }))
[08:27:50.842]             future::FutureResult(value = ...future.value$value, 
[08:27:50.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.842]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.842]                     ...future.globalenv.names))
[08:27:50.842]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.842]         }, condition = base::local({
[08:27:50.842]             c <- base::c
[08:27:50.842]             inherits <- base::inherits
[08:27:50.842]             invokeRestart <- base::invokeRestart
[08:27:50.842]             length <- base::length
[08:27:50.842]             list <- base::list
[08:27:50.842]             seq.int <- base::seq.int
[08:27:50.842]             signalCondition <- base::signalCondition
[08:27:50.842]             sys.calls <- base::sys.calls
[08:27:50.842]             `[[` <- base::`[[`
[08:27:50.842]             `+` <- base::`+`
[08:27:50.842]             `<<-` <- base::`<<-`
[08:27:50.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.842]                   3L)]
[08:27:50.842]             }
[08:27:50.842]             function(cond) {
[08:27:50.842]                 is_error <- inherits(cond, "error")
[08:27:50.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.842]                   NULL)
[08:27:50.842]                 if (is_error) {
[08:27:50.842]                   sessionInformation <- function() {
[08:27:50.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.842]                       search = base::search(), system = base::Sys.info())
[08:27:50.842]                   }
[08:27:50.842]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.842]                     cond$call), session = sessionInformation(), 
[08:27:50.842]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.842]                   signalCondition(cond)
[08:27:50.842]                 }
[08:27:50.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.842]                 "immediateCondition"))) {
[08:27:50.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.842]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.842]                   if (TRUE && !signal) {
[08:27:50.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.842]                     {
[08:27:50.842]                       inherits <- base::inherits
[08:27:50.842]                       invokeRestart <- base::invokeRestart
[08:27:50.842]                       is.null <- base::is.null
[08:27:50.842]                       muffled <- FALSE
[08:27:50.842]                       if (inherits(cond, "message")) {
[08:27:50.842]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.842]                         if (muffled) 
[08:27:50.842]                           invokeRestart("muffleMessage")
[08:27:50.842]                       }
[08:27:50.842]                       else if (inherits(cond, "warning")) {
[08:27:50.842]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.842]                         if (muffled) 
[08:27:50.842]                           invokeRestart("muffleWarning")
[08:27:50.842]                       }
[08:27:50.842]                       else if (inherits(cond, "condition")) {
[08:27:50.842]                         if (!is.null(pattern)) {
[08:27:50.842]                           computeRestarts <- base::computeRestarts
[08:27:50.842]                           grepl <- base::grepl
[08:27:50.842]                           restarts <- computeRestarts(cond)
[08:27:50.842]                           for (restart in restarts) {
[08:27:50.842]                             name <- restart$name
[08:27:50.842]                             if (is.null(name)) 
[08:27:50.842]                               next
[08:27:50.842]                             if (!grepl(pattern, name)) 
[08:27:50.842]                               next
[08:27:50.842]                             invokeRestart(restart)
[08:27:50.842]                             muffled <- TRUE
[08:27:50.842]                             break
[08:27:50.842]                           }
[08:27:50.842]                         }
[08:27:50.842]                       }
[08:27:50.842]                       invisible(muffled)
[08:27:50.842]                     }
[08:27:50.842]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.842]                   }
[08:27:50.842]                 }
[08:27:50.842]                 else {
[08:27:50.842]                   if (TRUE) {
[08:27:50.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.842]                     {
[08:27:50.842]                       inherits <- base::inherits
[08:27:50.842]                       invokeRestart <- base::invokeRestart
[08:27:50.842]                       is.null <- base::is.null
[08:27:50.842]                       muffled <- FALSE
[08:27:50.842]                       if (inherits(cond, "message")) {
[08:27:50.842]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.842]                         if (muffled) 
[08:27:50.842]                           invokeRestart("muffleMessage")
[08:27:50.842]                       }
[08:27:50.842]                       else if (inherits(cond, "warning")) {
[08:27:50.842]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.842]                         if (muffled) 
[08:27:50.842]                           invokeRestart("muffleWarning")
[08:27:50.842]                       }
[08:27:50.842]                       else if (inherits(cond, "condition")) {
[08:27:50.842]                         if (!is.null(pattern)) {
[08:27:50.842]                           computeRestarts <- base::computeRestarts
[08:27:50.842]                           grepl <- base::grepl
[08:27:50.842]                           restarts <- computeRestarts(cond)
[08:27:50.842]                           for (restart in restarts) {
[08:27:50.842]                             name <- restart$name
[08:27:50.842]                             if (is.null(name)) 
[08:27:50.842]                               next
[08:27:50.842]                             if (!grepl(pattern, name)) 
[08:27:50.842]                               next
[08:27:50.842]                             invokeRestart(restart)
[08:27:50.842]                             muffled <- TRUE
[08:27:50.842]                             break
[08:27:50.842]                           }
[08:27:50.842]                         }
[08:27:50.842]                       }
[08:27:50.842]                       invisible(muffled)
[08:27:50.842]                     }
[08:27:50.842]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.842]                   }
[08:27:50.842]                 }
[08:27:50.842]             }
[08:27:50.842]         }))
[08:27:50.842]     }, error = function(ex) {
[08:27:50.842]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.842]                 ...future.rng), started = ...future.startTime, 
[08:27:50.842]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.842]             version = "1.8"), class = "FutureResult")
[08:27:50.842]     }, finally = {
[08:27:50.842]         if (!identical(...future.workdir, getwd())) 
[08:27:50.842]             setwd(...future.workdir)
[08:27:50.842]         {
[08:27:50.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.842]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.842]             }
[08:27:50.842]             base::options(...future.oldOptions)
[08:27:50.842]             if (.Platform$OS.type == "windows") {
[08:27:50.842]                 old_names <- names(...future.oldEnvVars)
[08:27:50.842]                 envs <- base::Sys.getenv()
[08:27:50.842]                 names <- names(envs)
[08:27:50.842]                 common <- intersect(names, old_names)
[08:27:50.842]                 added <- setdiff(names, old_names)
[08:27:50.842]                 removed <- setdiff(old_names, names)
[08:27:50.842]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.842]                   envs[common]]
[08:27:50.842]                 NAMES <- toupper(changed)
[08:27:50.842]                 args <- list()
[08:27:50.842]                 for (kk in seq_along(NAMES)) {
[08:27:50.842]                   name <- changed[[kk]]
[08:27:50.842]                   NAME <- NAMES[[kk]]
[08:27:50.842]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.842]                     next
[08:27:50.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.842]                 }
[08:27:50.842]                 NAMES <- toupper(added)
[08:27:50.842]                 for (kk in seq_along(NAMES)) {
[08:27:50.842]                   name <- added[[kk]]
[08:27:50.842]                   NAME <- NAMES[[kk]]
[08:27:50.842]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.842]                     next
[08:27:50.842]                   args[[name]] <- ""
[08:27:50.842]                 }
[08:27:50.842]                 NAMES <- toupper(removed)
[08:27:50.842]                 for (kk in seq_along(NAMES)) {
[08:27:50.842]                   name <- removed[[kk]]
[08:27:50.842]                   NAME <- NAMES[[kk]]
[08:27:50.842]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.842]                     next
[08:27:50.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.842]                 }
[08:27:50.842]                 if (length(args) > 0) 
[08:27:50.842]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.842]             }
[08:27:50.842]             else {
[08:27:50.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.842]             }
[08:27:50.842]             {
[08:27:50.842]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.842]                   0L) {
[08:27:50.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.842]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.842]                   base::options(opts)
[08:27:50.842]                 }
[08:27:50.842]                 {
[08:27:50.842]                   {
[08:27:50.842]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:50.842]                     NULL
[08:27:50.842]                   }
[08:27:50.842]                   options(future.plan = NULL)
[08:27:50.842]                   if (is.na(NA_character_)) 
[08:27:50.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.842]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.842]                     .init = FALSE)
[08:27:50.842]                 }
[08:27:50.842]             }
[08:27:50.842]         }
[08:27:50.842]     })
[08:27:50.842]     if (TRUE) {
[08:27:50.842]         base::sink(type = "output", split = FALSE)
[08:27:50.842]         if (TRUE) {
[08:27:50.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.842]         }
[08:27:50.842]         else {
[08:27:50.842]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.842]         }
[08:27:50.842]         base::close(...future.stdout)
[08:27:50.842]         ...future.stdout <- NULL
[08:27:50.842]     }
[08:27:50.842]     ...future.result$conditions <- ...future.conditions
[08:27:50.842]     ...future.result$finished <- base::Sys.time()
[08:27:50.842]     ...future.result
[08:27:50.842] }
[08:27:50.844] requestCore(): workers = 2
[08:27:50.847] MulticoreFuture started
[08:27:50.848] - Launch lazy future ... done
[08:27:50.848] plan(): Setting new future strategy stack:
[08:27:50.848] run() for ‘MulticoreFuture’ ... done
[08:27:50.849] getGlobalsAndPackages() ...
[08:27:50.849] Searching for globals...
[08:27:50.848] List of future strategies:
[08:27:50.848] 1. sequential:
[08:27:50.848]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.848]    - tweaked: FALSE
[08:27:50.848]    - call: NULL
[08:27:50.850] plan(): nbrOfWorkers() = 1
[08:27:50.850] 
[08:27:50.850] Searching for globals ... DONE
[08:27:50.850] - globals: [0] <none>
[08:27:50.851] getGlobalsAndPackages() ... DONE
[08:27:50.851] run() for ‘Future’ ...
[08:27:50.851] - state: ‘created’
[08:27:50.852] plan(): Setting new future strategy stack:
[08:27:50.852] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:50.852] List of future strategies:
[08:27:50.852] 1. multicore:
[08:27:50.852]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:50.852]    - tweaked: FALSE
[08:27:50.852]    - call: plan(strategy)
[08:27:50.855] plan(): nbrOfWorkers() = 2
[08:27:50.855] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:50.855] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:50.856]   - Field: ‘label’
[08:27:50.856]   - Field: ‘local’
[08:27:50.861]   - Field: ‘owner’
[08:27:50.862]   - Field: ‘envir’
[08:27:50.862]   - Field: ‘workers’
[08:27:50.863]   - Field: ‘packages’
[08:27:50.863]   - Field: ‘gc’
[08:27:50.864]   - Field: ‘job’
[08:27:50.864]   - Field: ‘conditions’
[08:27:50.865]   - Field: ‘expr’
[08:27:50.865]   - Field: ‘uuid’
[08:27:50.866]   - Field: ‘seed’
[08:27:50.866]   - Field: ‘version’
[08:27:50.867]   - Field: ‘result’
[08:27:50.867]   - Field: ‘asynchronous’
[08:27:50.868]   - Field: ‘calls’
[08:27:50.868]   - Field: ‘globals’
[08:27:50.868]   - Field: ‘stdout’
[08:27:50.869]   - Field: ‘earlySignal’
[08:27:50.869]   - Field: ‘lazy’
[08:27:50.869]   - Field: ‘state’
[08:27:50.869] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:50.869] - Launch lazy future ...
[08:27:50.870] Packages needed by the future expression (n = 0): <none>
[08:27:50.870] Packages needed by future strategies (n = 0): <none>
[08:27:50.871] {
[08:27:50.871]     {
[08:27:50.871]         {
[08:27:50.871]             ...future.startTime <- base::Sys.time()
[08:27:50.871]             {
[08:27:50.871]                 {
[08:27:50.871]                   {
[08:27:50.871]                     {
[08:27:50.871]                       base::local({
[08:27:50.871]                         has_future <- base::requireNamespace("future", 
[08:27:50.871]                           quietly = TRUE)
[08:27:50.871]                         if (has_future) {
[08:27:50.871]                           ns <- base::getNamespace("future")
[08:27:50.871]                           version <- ns[[".package"]][["version"]]
[08:27:50.871]                           if (is.null(version)) 
[08:27:50.871]                             version <- utils::packageVersion("future")
[08:27:50.871]                         }
[08:27:50.871]                         else {
[08:27:50.871]                           version <- NULL
[08:27:50.871]                         }
[08:27:50.871]                         if (!has_future || version < "1.8.0") {
[08:27:50.871]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.871]                             "", base::R.version$version.string), 
[08:27:50.871]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:50.871]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.871]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.871]                               "release", "version")], collapse = " "), 
[08:27:50.871]                             hostname = base::Sys.info()[["nodename"]])
[08:27:50.871]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.871]                             info)
[08:27:50.871]                           info <- base::paste(info, collapse = "; ")
[08:27:50.871]                           if (!has_future) {
[08:27:50.871]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.871]                               info)
[08:27:50.871]                           }
[08:27:50.871]                           else {
[08:27:50.871]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.871]                               info, version)
[08:27:50.871]                           }
[08:27:50.871]                           base::stop(msg)
[08:27:50.871]                         }
[08:27:50.871]                       })
[08:27:50.871]                     }
[08:27:50.871]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:50.871]                     base::options(mc.cores = 1L)
[08:27:50.871]                   }
[08:27:50.871]                   ...future.strategy.old <- future::plan("list")
[08:27:50.871]                   options(future.plan = NULL)
[08:27:50.871]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.871]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.871]                 }
[08:27:50.871]                 ...future.workdir <- getwd()
[08:27:50.871]             }
[08:27:50.871]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.871]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.871]         }
[08:27:50.871]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.871]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.871]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.871]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.871]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.871]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.871]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.871]             base::names(...future.oldOptions))
[08:27:50.871]     }
[08:27:50.871]     if (FALSE) {
[08:27:50.871]     }
[08:27:50.871]     else {
[08:27:50.871]         if (TRUE) {
[08:27:50.871]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.871]                 open = "w")
[08:27:50.871]         }
[08:27:50.871]         else {
[08:27:50.871]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.871]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.871]         }
[08:27:50.871]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.871]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.871]             base::sink(type = "output", split = FALSE)
[08:27:50.871]             base::close(...future.stdout)
[08:27:50.871]         }, add = TRUE)
[08:27:50.871]     }
[08:27:50.871]     ...future.frame <- base::sys.nframe()
[08:27:50.871]     ...future.conditions <- base::list()
[08:27:50.871]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.871]     if (FALSE) {
[08:27:50.871]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.871]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.871]     }
[08:27:50.871]     ...future.result <- base::tryCatch({
[08:27:50.871]         base::withCallingHandlers({
[08:27:50.871]             ...future.value <- base::withVisible(base::local({
[08:27:50.871]                 withCallingHandlers({
[08:27:50.871]                   NULL
[08:27:50.871]                 }, immediateCondition = function(cond) {
[08:27:50.871]                   save_rds <- function (object, pathname, ...) 
[08:27:50.871]                   {
[08:27:50.871]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:50.871]                     if (file_test("-f", pathname_tmp)) {
[08:27:50.871]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.871]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:50.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.871]                         fi_tmp[["mtime"]])
[08:27:50.871]                     }
[08:27:50.871]                     tryCatch({
[08:27:50.871]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:50.871]                     }, error = function(ex) {
[08:27:50.871]                       msg <- conditionMessage(ex)
[08:27:50.871]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.871]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:50.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.871]                         fi_tmp[["mtime"]], msg)
[08:27:50.871]                       ex$message <- msg
[08:27:50.871]                       stop(ex)
[08:27:50.871]                     })
[08:27:50.871]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:50.871]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:50.871]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:50.871]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.871]                       fi <- file.info(pathname)
[08:27:50.871]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:50.871]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.871]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:50.871]                         fi[["size"]], fi[["mtime"]])
[08:27:50.871]                       stop(msg)
[08:27:50.871]                     }
[08:27:50.871]                     invisible(pathname)
[08:27:50.871]                   }
[08:27:50.871]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:50.871]                     rootPath = tempdir()) 
[08:27:50.871]                   {
[08:27:50.871]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:50.871]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:50.871]                       tmpdir = path, fileext = ".rds")
[08:27:50.871]                     save_rds(obj, file)
[08:27:50.871]                   }
[08:27:50.871]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:50.871]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.871]                   {
[08:27:50.871]                     inherits <- base::inherits
[08:27:50.871]                     invokeRestart <- base::invokeRestart
[08:27:50.871]                     is.null <- base::is.null
[08:27:50.871]                     muffled <- FALSE
[08:27:50.871]                     if (inherits(cond, "message")) {
[08:27:50.871]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:50.871]                       if (muffled) 
[08:27:50.871]                         invokeRestart("muffleMessage")
[08:27:50.871]                     }
[08:27:50.871]                     else if (inherits(cond, "warning")) {
[08:27:50.871]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:50.871]                       if (muffled) 
[08:27:50.871]                         invokeRestart("muffleWarning")
[08:27:50.871]                     }
[08:27:50.871]                     else if (inherits(cond, "condition")) {
[08:27:50.871]                       if (!is.null(pattern)) {
[08:27:50.871]                         computeRestarts <- base::computeRestarts
[08:27:50.871]                         grepl <- base::grepl
[08:27:50.871]                         restarts <- computeRestarts(cond)
[08:27:50.871]                         for (restart in restarts) {
[08:27:50.871]                           name <- restart$name
[08:27:50.871]                           if (is.null(name)) 
[08:27:50.871]                             next
[08:27:50.871]                           if (!grepl(pattern, name)) 
[08:27:50.871]                             next
[08:27:50.871]                           invokeRestart(restart)
[08:27:50.871]                           muffled <- TRUE
[08:27:50.871]                           break
[08:27:50.871]                         }
[08:27:50.871]                       }
[08:27:50.871]                     }
[08:27:50.871]                     invisible(muffled)
[08:27:50.871]                   }
[08:27:50.871]                   muffleCondition(cond)
[08:27:50.871]                 })
[08:27:50.871]             }))
[08:27:50.871]             future::FutureResult(value = ...future.value$value, 
[08:27:50.871]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.871]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.871]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.871]                     ...future.globalenv.names))
[08:27:50.871]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.871]         }, condition = base::local({
[08:27:50.871]             c <- base::c
[08:27:50.871]             inherits <- base::inherits
[08:27:50.871]             invokeRestart <- base::invokeRestart
[08:27:50.871]             length <- base::length
[08:27:50.871]             list <- base::list
[08:27:50.871]             seq.int <- base::seq.int
[08:27:50.871]             signalCondition <- base::signalCondition
[08:27:50.871]             sys.calls <- base::sys.calls
[08:27:50.871]             `[[` <- base::`[[`
[08:27:50.871]             `+` <- base::`+`
[08:27:50.871]             `<<-` <- base::`<<-`
[08:27:50.871]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.871]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.871]                   3L)]
[08:27:50.871]             }
[08:27:50.871]             function(cond) {
[08:27:50.871]                 is_error <- inherits(cond, "error")
[08:27:50.871]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.871]                   NULL)
[08:27:50.871]                 if (is_error) {
[08:27:50.871]                   sessionInformation <- function() {
[08:27:50.871]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.871]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.871]                       search = base::search(), system = base::Sys.info())
[08:27:50.871]                   }
[08:27:50.871]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.871]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.871]                     cond$call), session = sessionInformation(), 
[08:27:50.871]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.871]                   signalCondition(cond)
[08:27:50.871]                 }
[08:27:50.871]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.871]                 "immediateCondition"))) {
[08:27:50.871]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.871]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.871]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.871]                   if (TRUE && !signal) {
[08:27:50.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.871]                     {
[08:27:50.871]                       inherits <- base::inherits
[08:27:50.871]                       invokeRestart <- base::invokeRestart
[08:27:50.871]                       is.null <- base::is.null
[08:27:50.871]                       muffled <- FALSE
[08:27:50.871]                       if (inherits(cond, "message")) {
[08:27:50.871]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.871]                         if (muffled) 
[08:27:50.871]                           invokeRestart("muffleMessage")
[08:27:50.871]                       }
[08:27:50.871]                       else if (inherits(cond, "warning")) {
[08:27:50.871]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.871]                         if (muffled) 
[08:27:50.871]                           invokeRestart("muffleWarning")
[08:27:50.871]                       }
[08:27:50.871]                       else if (inherits(cond, "condition")) {
[08:27:50.871]                         if (!is.null(pattern)) {
[08:27:50.871]                           computeRestarts <- base::computeRestarts
[08:27:50.871]                           grepl <- base::grepl
[08:27:50.871]                           restarts <- computeRestarts(cond)
[08:27:50.871]                           for (restart in restarts) {
[08:27:50.871]                             name <- restart$name
[08:27:50.871]                             if (is.null(name)) 
[08:27:50.871]                               next
[08:27:50.871]                             if (!grepl(pattern, name)) 
[08:27:50.871]                               next
[08:27:50.871]                             invokeRestart(restart)
[08:27:50.871]                             muffled <- TRUE
[08:27:50.871]                             break
[08:27:50.871]                           }
[08:27:50.871]                         }
[08:27:50.871]                       }
[08:27:50.871]                       invisible(muffled)
[08:27:50.871]                     }
[08:27:50.871]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.871]                   }
[08:27:50.871]                 }
[08:27:50.871]                 else {
[08:27:50.871]                   if (TRUE) {
[08:27:50.871]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.871]                     {
[08:27:50.871]                       inherits <- base::inherits
[08:27:50.871]                       invokeRestart <- base::invokeRestart
[08:27:50.871]                       is.null <- base::is.null
[08:27:50.871]                       muffled <- FALSE
[08:27:50.871]                       if (inherits(cond, "message")) {
[08:27:50.871]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.871]                         if (muffled) 
[08:27:50.871]                           invokeRestart("muffleMessage")
[08:27:50.871]                       }
[08:27:50.871]                       else if (inherits(cond, "warning")) {
[08:27:50.871]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.871]                         if (muffled) 
[08:27:50.871]                           invokeRestart("muffleWarning")
[08:27:50.871]                       }
[08:27:50.871]                       else if (inherits(cond, "condition")) {
[08:27:50.871]                         if (!is.null(pattern)) {
[08:27:50.871]                           computeRestarts <- base::computeRestarts
[08:27:50.871]                           grepl <- base::grepl
[08:27:50.871]                           restarts <- computeRestarts(cond)
[08:27:50.871]                           for (restart in restarts) {
[08:27:50.871]                             name <- restart$name
[08:27:50.871]                             if (is.null(name)) 
[08:27:50.871]                               next
[08:27:50.871]                             if (!grepl(pattern, name)) 
[08:27:50.871]                               next
[08:27:50.871]                             invokeRestart(restart)
[08:27:50.871]                             muffled <- TRUE
[08:27:50.871]                             break
[08:27:50.871]                           }
[08:27:50.871]                         }
[08:27:50.871]                       }
[08:27:50.871]                       invisible(muffled)
[08:27:50.871]                     }
[08:27:50.871]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.871]                   }
[08:27:50.871]                 }
[08:27:50.871]             }
[08:27:50.871]         }))
[08:27:50.871]     }, error = function(ex) {
[08:27:50.871]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.871]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.871]                 ...future.rng), started = ...future.startTime, 
[08:27:50.871]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.871]             version = "1.8"), class = "FutureResult")
[08:27:50.871]     }, finally = {
[08:27:50.871]         if (!identical(...future.workdir, getwd())) 
[08:27:50.871]             setwd(...future.workdir)
[08:27:50.871]         {
[08:27:50.871]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.871]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.871]             }
[08:27:50.871]             base::options(...future.oldOptions)
[08:27:50.871]             if (.Platform$OS.type == "windows") {
[08:27:50.871]                 old_names <- names(...future.oldEnvVars)
[08:27:50.871]                 envs <- base::Sys.getenv()
[08:27:50.871]                 names <- names(envs)
[08:27:50.871]                 common <- intersect(names, old_names)
[08:27:50.871]                 added <- setdiff(names, old_names)
[08:27:50.871]                 removed <- setdiff(old_names, names)
[08:27:50.871]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.871]                   envs[common]]
[08:27:50.871]                 NAMES <- toupper(changed)
[08:27:50.871]                 args <- list()
[08:27:50.871]                 for (kk in seq_along(NAMES)) {
[08:27:50.871]                   name <- changed[[kk]]
[08:27:50.871]                   NAME <- NAMES[[kk]]
[08:27:50.871]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.871]                     next
[08:27:50.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.871]                 }
[08:27:50.871]                 NAMES <- toupper(added)
[08:27:50.871]                 for (kk in seq_along(NAMES)) {
[08:27:50.871]                   name <- added[[kk]]
[08:27:50.871]                   NAME <- NAMES[[kk]]
[08:27:50.871]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.871]                     next
[08:27:50.871]                   args[[name]] <- ""
[08:27:50.871]                 }
[08:27:50.871]                 NAMES <- toupper(removed)
[08:27:50.871]                 for (kk in seq_along(NAMES)) {
[08:27:50.871]                   name <- removed[[kk]]
[08:27:50.871]                   NAME <- NAMES[[kk]]
[08:27:50.871]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.871]                     next
[08:27:50.871]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.871]                 }
[08:27:50.871]                 if (length(args) > 0) 
[08:27:50.871]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.871]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.871]             }
[08:27:50.871]             else {
[08:27:50.871]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.871]             }
[08:27:50.871]             {
[08:27:50.871]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.871]                   0L) {
[08:27:50.871]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.871]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.871]                   base::options(opts)
[08:27:50.871]                 }
[08:27:50.871]                 {
[08:27:50.871]                   {
[08:27:50.871]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:50.871]                     NULL
[08:27:50.871]                   }
[08:27:50.871]                   options(future.plan = NULL)
[08:27:50.871]                   if (is.na(NA_character_)) 
[08:27:50.871]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.871]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.871]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.871]                     .init = FALSE)
[08:27:50.871]                 }
[08:27:50.871]             }
[08:27:50.871]         }
[08:27:50.871]     })
[08:27:50.871]     if (TRUE) {
[08:27:50.871]         base::sink(type = "output", split = FALSE)
[08:27:50.871]         if (TRUE) {
[08:27:50.871]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.871]         }
[08:27:50.871]         else {
[08:27:50.871]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.871]         }
[08:27:50.871]         base::close(...future.stdout)
[08:27:50.871]         ...future.stdout <- NULL
[08:27:50.871]     }
[08:27:50.871]     ...future.result$conditions <- ...future.conditions
[08:27:50.871]     ...future.result$finished <- base::Sys.time()
[08:27:50.871]     ...future.result
[08:27:50.871] }
[08:27:50.875] requestCore(): workers = 2
[08:27:50.883] MulticoreFuture started
[08:27:50.883] - Launch lazy future ... done
[08:27:50.884] run() for ‘MulticoreFuture’ ... done
[08:27:50.884] plan(): Setting new future strategy stack:
List of 6
 $ a:[08:27:50.884] List of future strategies:
[08:27:50.884] 1. sequential:
[08:27:50.884]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.884]    - tweaked: FALSE
[08:27:50.884]    - call: NULL
[08:27:50.885] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860b8e8d0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d8610ab568> 
 $  :[08:27:50.887] plan(): Setting new future strategy stack:
 NULL
 $  : NULL
 $  :[08:27:50.888] List of future strategies:
[08:27:50.888] 1. multicore:
[08:27:50.888]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:50.888]    - tweaked: FALSE
[08:27:50.888]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860b8e8d0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d8610ab568> 
 $  :[08:27:50.891] plan(): nbrOfWorkers() = 2
 NULL
 $  : NULL
 $  : num 6
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:50.895] resolve() on list ...
[08:27:50.896]  recursive: 0
[08:27:50.896]  length: 6
[08:27:50.896]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:50.896] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.897] - nx: 6
[08:27:50.897] - relay: TRUE
[08:27:50.897] - stdout: TRUE
[08:27:50.897] - signal: TRUE
[08:27:50.897] - resignal: FALSE
[08:27:50.897] - force: TRUE
[08:27:50.897] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.898] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.898]  - until=2
[08:27:50.898]  - relaying element #2
[08:27:50.898] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.898] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.899] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.899]  length: 5 (resolved future 1)
[08:27:50.899] Future #2
[08:27:50.900] result() for MulticoreFuture ...
[08:27:50.902] result() for MulticoreFuture ...
[08:27:50.902] result() for MulticoreFuture ... done
[08:27:50.902] result() for MulticoreFuture ... done
[08:27:50.903] result() for MulticoreFuture ...
[08:27:50.903] result() for MulticoreFuture ... done
[08:27:50.903] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:50.903] - nx: 6
[08:27:50.903] - relay: TRUE
[08:27:50.904] - stdout: TRUE
[08:27:50.904] - signal: TRUE
[08:27:50.904] - resignal: FALSE
[08:27:50.904] - force: TRUE
[08:27:50.904] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.904] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.904]  - until=2
[08:27:50.905]  - relaying element #2
[08:27:50.905] result() for MulticoreFuture ...
[08:27:50.905] result() for MulticoreFuture ... done
[08:27:50.905] result() for MulticoreFuture ...
[08:27:50.905] result() for MulticoreFuture ... done
[08:27:50.905] result() for MulticoreFuture ...
[08:27:50.906] result() for MulticoreFuture ... done
[08:27:50.906] result() for MulticoreFuture ...
[08:27:50.906] result() for MulticoreFuture ... done
[08:27:50.906] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.906] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.906] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:50.907]  length: 4 (resolved future 2)
[08:27:50.907] Future #3
[08:27:50.907] result() for MulticoreFuture ...
[08:27:50.908] result() for MulticoreFuture ...
[08:27:50.908] result() for MulticoreFuture ... done
[08:27:50.908] result() for MulticoreFuture ... done
[08:27:50.908] result() for MulticoreFuture ...
[08:27:50.909] result() for MulticoreFuture ... done
[08:27:50.909] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:50.909] - nx: 6
[08:27:50.909] - relay: TRUE
[08:27:50.909] - stdout: TRUE
[08:27:50.909] - signal: TRUE
[08:27:50.909] - resignal: FALSE
[08:27:50.910] - force: TRUE
[08:27:50.910] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.910] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.910]  - until=3
[08:27:50.910]  - relaying element #3
[08:27:50.910] result() for MulticoreFuture ...
[08:27:50.910] result() for MulticoreFuture ... done
[08:27:50.911] result() for MulticoreFuture ...
[08:27:50.911] result() for MulticoreFuture ... done
[08:27:50.911] result() for MulticoreFuture ...
[08:27:50.911] result() for MulticoreFuture ... done
[08:27:50.911] result() for MulticoreFuture ...
[08:27:50.911] result() for MulticoreFuture ... done
[08:27:50.911] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.911] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.912] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:50.912]  length: 3 (resolved future 3)
[08:27:50.912] signalConditionsASAP(NULL, pos=4) ...
[08:27:50.912] - nx: 6
[08:27:50.912] - relay: TRUE
[08:27:50.912] - stdout: TRUE
[08:27:50.912] - signal: TRUE
[08:27:50.912] - resignal: FALSE
[08:27:50.912] - force: TRUE
[08:27:50.912] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.913] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.913]  - until=5
[08:27:50.913]  - relaying element #5
[08:27:50.913] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.913] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.913] signalConditionsASAP(NULL, pos=4) ... done
[08:27:50.913]  length: 2 (resolved future 4)
[08:27:50.913] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.913] - nx: 6
[08:27:50.913] - relay: TRUE
[08:27:50.914] - stdout: TRUE
[08:27:50.914] - signal: TRUE
[08:27:50.914] - resignal: FALSE
[08:27:50.914] - force: TRUE
[08:27:50.914] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.914] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.914]  - until=6
[08:27:50.914]  - relaying element #6
[08:27:50.914] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.914] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.915] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.915]  length: 1 (resolved future 5)
[08:27:50.915] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.915] - nx: 6
[08:27:50.915] - relay: TRUE
[08:27:50.915] - stdout: TRUE
[08:27:50.915] - signal: TRUE
[08:27:50.915] - resignal: FALSE
[08:27:50.915] - force: TRUE
[08:27:50.915] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.916] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.916]  - until=6
[08:27:50.916] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.916] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.916] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.916]  length: 0 (resolved future 6)
[08:27:50.916] Relaying remaining futures
[08:27:50.916] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.916] - nx: 6
[08:27:50.916] - relay: TRUE
[08:27:50.919] - stdout: TRUE
[08:27:50.919] - signal: TRUE
[08:27:50.919] - resignal: FALSE
[08:27:50.919] - force: TRUE
[08:27:50.920] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.920] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:50.920] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.920] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.920] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.920] resolve() on list ... DONE
[08:27:50.921] result() for MulticoreFuture ...
[08:27:50.921] result() for MulticoreFuture ... done
[08:27:50.921] result() for MulticoreFuture ...
[08:27:50.921] result() for MulticoreFuture ... done
[08:27:50.921] result() for MulticoreFuture ...
[08:27:50.921] result() for MulticoreFuture ... done
[08:27:50.921] result() for MulticoreFuture ...
[08:27:50.922] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[08:27:50.924] getGlobalsAndPackages() ...
[08:27:50.924] Searching for globals...
[08:27:50.925] 
[08:27:50.925] Searching for globals ... DONE
[08:27:50.925] - globals: [0] <none>
[08:27:50.925] getGlobalsAndPackages() ... DONE
[08:27:50.926] run() for ‘Future’ ...
[08:27:50.926] - state: ‘created’
[08:27:50.926] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:50.928] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:50.928] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:50.928]   - Field: ‘label’
[08:27:50.928]   - Field: ‘local’
[08:27:50.928]   - Field: ‘owner’
[08:27:50.929]   - Field: ‘envir’
[08:27:50.929]   - Field: ‘workers’
[08:27:50.929]   - Field: ‘packages’
[08:27:50.929]   - Field: ‘gc’
[08:27:50.929]   - Field: ‘job’
[08:27:50.929]   - Field: ‘conditions’
[08:27:50.929]   - Field: ‘expr’
[08:27:50.929]   - Field: ‘uuid’
[08:27:50.929]   - Field: ‘seed’
[08:27:50.929]   - Field: ‘version’
[08:27:50.929]   - Field: ‘result’
[08:27:50.929]   - Field: ‘asynchronous’
[08:27:50.930]   - Field: ‘calls’
[08:27:50.930]   - Field: ‘globals’
[08:27:50.930]   - Field: ‘stdout’
[08:27:50.930]   - Field: ‘earlySignal’
[08:27:50.930]   - Field: ‘lazy’
[08:27:50.930]   - Field: ‘state’
[08:27:50.930] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:50.930] - Launch lazy future ...
[08:27:50.930] Packages needed by the future expression (n = 0): <none>
[08:27:50.931] Packages needed by future strategies (n = 0): <none>
[08:27:50.931] {
[08:27:50.931]     {
[08:27:50.931]         {
[08:27:50.931]             ...future.startTime <- base::Sys.time()
[08:27:50.931]             {
[08:27:50.931]                 {
[08:27:50.931]                   {
[08:27:50.931]                     {
[08:27:50.931]                       base::local({
[08:27:50.931]                         has_future <- base::requireNamespace("future", 
[08:27:50.931]                           quietly = TRUE)
[08:27:50.931]                         if (has_future) {
[08:27:50.931]                           ns <- base::getNamespace("future")
[08:27:50.931]                           version <- ns[[".package"]][["version"]]
[08:27:50.931]                           if (is.null(version)) 
[08:27:50.931]                             version <- utils::packageVersion("future")
[08:27:50.931]                         }
[08:27:50.931]                         else {
[08:27:50.931]                           version <- NULL
[08:27:50.931]                         }
[08:27:50.931]                         if (!has_future || version < "1.8.0") {
[08:27:50.931]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.931]                             "", base::R.version$version.string), 
[08:27:50.931]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:50.931]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.931]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.931]                               "release", "version")], collapse = " "), 
[08:27:50.931]                             hostname = base::Sys.info()[["nodename"]])
[08:27:50.931]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.931]                             info)
[08:27:50.931]                           info <- base::paste(info, collapse = "; ")
[08:27:50.931]                           if (!has_future) {
[08:27:50.931]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.931]                               info)
[08:27:50.931]                           }
[08:27:50.931]                           else {
[08:27:50.931]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.931]                               info, version)
[08:27:50.931]                           }
[08:27:50.931]                           base::stop(msg)
[08:27:50.931]                         }
[08:27:50.931]                       })
[08:27:50.931]                     }
[08:27:50.931]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:50.931]                     base::options(mc.cores = 1L)
[08:27:50.931]                   }
[08:27:50.931]                   ...future.strategy.old <- future::plan("list")
[08:27:50.931]                   options(future.plan = NULL)
[08:27:50.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.931]                 }
[08:27:50.931]                 ...future.workdir <- getwd()
[08:27:50.931]             }
[08:27:50.931]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.931]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.931]         }
[08:27:50.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.931]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.931]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.931]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.931]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.931]             base::names(...future.oldOptions))
[08:27:50.931]     }
[08:27:50.931]     if (FALSE) {
[08:27:50.931]     }
[08:27:50.931]     else {
[08:27:50.931]         if (TRUE) {
[08:27:50.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.931]                 open = "w")
[08:27:50.931]         }
[08:27:50.931]         else {
[08:27:50.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.931]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.931]         }
[08:27:50.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.931]             base::sink(type = "output", split = FALSE)
[08:27:50.931]             base::close(...future.stdout)
[08:27:50.931]         }, add = TRUE)
[08:27:50.931]     }
[08:27:50.931]     ...future.frame <- base::sys.nframe()
[08:27:50.931]     ...future.conditions <- base::list()
[08:27:50.931]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.931]     if (FALSE) {
[08:27:50.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.931]     }
[08:27:50.931]     ...future.result <- base::tryCatch({
[08:27:50.931]         base::withCallingHandlers({
[08:27:50.931]             ...future.value <- base::withVisible(base::local({
[08:27:50.931]                 withCallingHandlers({
[08:27:50.931]                   2
[08:27:50.931]                 }, immediateCondition = function(cond) {
[08:27:50.931]                   save_rds <- function (object, pathname, ...) 
[08:27:50.931]                   {
[08:27:50.931]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:50.931]                     if (file_test("-f", pathname_tmp)) {
[08:27:50.931]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.931]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:50.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.931]                         fi_tmp[["mtime"]])
[08:27:50.931]                     }
[08:27:50.931]                     tryCatch({
[08:27:50.931]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:50.931]                     }, error = function(ex) {
[08:27:50.931]                       msg <- conditionMessage(ex)
[08:27:50.931]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.931]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:50.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.931]                         fi_tmp[["mtime"]], msg)
[08:27:50.931]                       ex$message <- msg
[08:27:50.931]                       stop(ex)
[08:27:50.931]                     })
[08:27:50.931]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:50.931]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:50.931]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:50.931]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.931]                       fi <- file.info(pathname)
[08:27:50.931]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:50.931]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.931]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:50.931]                         fi[["size"]], fi[["mtime"]])
[08:27:50.931]                       stop(msg)
[08:27:50.931]                     }
[08:27:50.931]                     invisible(pathname)
[08:27:50.931]                   }
[08:27:50.931]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:50.931]                     rootPath = tempdir()) 
[08:27:50.931]                   {
[08:27:50.931]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:50.931]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:50.931]                       tmpdir = path, fileext = ".rds")
[08:27:50.931]                     save_rds(obj, file)
[08:27:50.931]                   }
[08:27:50.931]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:50.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.931]                   {
[08:27:50.931]                     inherits <- base::inherits
[08:27:50.931]                     invokeRestart <- base::invokeRestart
[08:27:50.931]                     is.null <- base::is.null
[08:27:50.931]                     muffled <- FALSE
[08:27:50.931]                     if (inherits(cond, "message")) {
[08:27:50.931]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:50.931]                       if (muffled) 
[08:27:50.931]                         invokeRestart("muffleMessage")
[08:27:50.931]                     }
[08:27:50.931]                     else if (inherits(cond, "warning")) {
[08:27:50.931]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:50.931]                       if (muffled) 
[08:27:50.931]                         invokeRestart("muffleWarning")
[08:27:50.931]                     }
[08:27:50.931]                     else if (inherits(cond, "condition")) {
[08:27:50.931]                       if (!is.null(pattern)) {
[08:27:50.931]                         computeRestarts <- base::computeRestarts
[08:27:50.931]                         grepl <- base::grepl
[08:27:50.931]                         restarts <- computeRestarts(cond)
[08:27:50.931]                         for (restart in restarts) {
[08:27:50.931]                           name <- restart$name
[08:27:50.931]                           if (is.null(name)) 
[08:27:50.931]                             next
[08:27:50.931]                           if (!grepl(pattern, name)) 
[08:27:50.931]                             next
[08:27:50.931]                           invokeRestart(restart)
[08:27:50.931]                           muffled <- TRUE
[08:27:50.931]                           break
[08:27:50.931]                         }
[08:27:50.931]                       }
[08:27:50.931]                     }
[08:27:50.931]                     invisible(muffled)
[08:27:50.931]                   }
[08:27:50.931]                   muffleCondition(cond)
[08:27:50.931]                 })
[08:27:50.931]             }))
[08:27:50.931]             future::FutureResult(value = ...future.value$value, 
[08:27:50.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.931]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.931]                     ...future.globalenv.names))
[08:27:50.931]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.931]         }, condition = base::local({
[08:27:50.931]             c <- base::c
[08:27:50.931]             inherits <- base::inherits
[08:27:50.931]             invokeRestart <- base::invokeRestart
[08:27:50.931]             length <- base::length
[08:27:50.931]             list <- base::list
[08:27:50.931]             seq.int <- base::seq.int
[08:27:50.931]             signalCondition <- base::signalCondition
[08:27:50.931]             sys.calls <- base::sys.calls
[08:27:50.931]             `[[` <- base::`[[`
[08:27:50.931]             `+` <- base::`+`
[08:27:50.931]             `<<-` <- base::`<<-`
[08:27:50.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.931]                   3L)]
[08:27:50.931]             }
[08:27:50.931]             function(cond) {
[08:27:50.931]                 is_error <- inherits(cond, "error")
[08:27:50.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.931]                   NULL)
[08:27:50.931]                 if (is_error) {
[08:27:50.931]                   sessionInformation <- function() {
[08:27:50.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.931]                       search = base::search(), system = base::Sys.info())
[08:27:50.931]                   }
[08:27:50.931]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.931]                     cond$call), session = sessionInformation(), 
[08:27:50.931]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.931]                   signalCondition(cond)
[08:27:50.931]                 }
[08:27:50.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.931]                 "immediateCondition"))) {
[08:27:50.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.931]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.931]                   if (TRUE && !signal) {
[08:27:50.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.931]                     {
[08:27:50.931]                       inherits <- base::inherits
[08:27:50.931]                       invokeRestart <- base::invokeRestart
[08:27:50.931]                       is.null <- base::is.null
[08:27:50.931]                       muffled <- FALSE
[08:27:50.931]                       if (inherits(cond, "message")) {
[08:27:50.931]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.931]                         if (muffled) 
[08:27:50.931]                           invokeRestart("muffleMessage")
[08:27:50.931]                       }
[08:27:50.931]                       else if (inherits(cond, "warning")) {
[08:27:50.931]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.931]                         if (muffled) 
[08:27:50.931]                           invokeRestart("muffleWarning")
[08:27:50.931]                       }
[08:27:50.931]                       else if (inherits(cond, "condition")) {
[08:27:50.931]                         if (!is.null(pattern)) {
[08:27:50.931]                           computeRestarts <- base::computeRestarts
[08:27:50.931]                           grepl <- base::grepl
[08:27:50.931]                           restarts <- computeRestarts(cond)
[08:27:50.931]                           for (restart in restarts) {
[08:27:50.931]                             name <- restart$name
[08:27:50.931]                             if (is.null(name)) 
[08:27:50.931]                               next
[08:27:50.931]                             if (!grepl(pattern, name)) 
[08:27:50.931]                               next
[08:27:50.931]                             invokeRestart(restart)
[08:27:50.931]                             muffled <- TRUE
[08:27:50.931]                             break
[08:27:50.931]                           }
[08:27:50.931]                         }
[08:27:50.931]                       }
[08:27:50.931]                       invisible(muffled)
[08:27:50.931]                     }
[08:27:50.931]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.931]                   }
[08:27:50.931]                 }
[08:27:50.931]                 else {
[08:27:50.931]                   if (TRUE) {
[08:27:50.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.931]                     {
[08:27:50.931]                       inherits <- base::inherits
[08:27:50.931]                       invokeRestart <- base::invokeRestart
[08:27:50.931]                       is.null <- base::is.null
[08:27:50.931]                       muffled <- FALSE
[08:27:50.931]                       if (inherits(cond, "message")) {
[08:27:50.931]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.931]                         if (muffled) 
[08:27:50.931]                           invokeRestart("muffleMessage")
[08:27:50.931]                       }
[08:27:50.931]                       else if (inherits(cond, "warning")) {
[08:27:50.931]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.931]                         if (muffled) 
[08:27:50.931]                           invokeRestart("muffleWarning")
[08:27:50.931]                       }
[08:27:50.931]                       else if (inherits(cond, "condition")) {
[08:27:50.931]                         if (!is.null(pattern)) {
[08:27:50.931]                           computeRestarts <- base::computeRestarts
[08:27:50.931]                           grepl <- base::grepl
[08:27:50.931]                           restarts <- computeRestarts(cond)
[08:27:50.931]                           for (restart in restarts) {
[08:27:50.931]                             name <- restart$name
[08:27:50.931]                             if (is.null(name)) 
[08:27:50.931]                               next
[08:27:50.931]                             if (!grepl(pattern, name)) 
[08:27:50.931]                               next
[08:27:50.931]                             invokeRestart(restart)
[08:27:50.931]                             muffled <- TRUE
[08:27:50.931]                             break
[08:27:50.931]                           }
[08:27:50.931]                         }
[08:27:50.931]                       }
[08:27:50.931]                       invisible(muffled)
[08:27:50.931]                     }
[08:27:50.931]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.931]                   }
[08:27:50.931]                 }
[08:27:50.931]             }
[08:27:50.931]         }))
[08:27:50.931]     }, error = function(ex) {
[08:27:50.931]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.931]                 ...future.rng), started = ...future.startTime, 
[08:27:50.931]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.931]             version = "1.8"), class = "FutureResult")
[08:27:50.931]     }, finally = {
[08:27:50.931]         if (!identical(...future.workdir, getwd())) 
[08:27:50.931]             setwd(...future.workdir)
[08:27:50.931]         {
[08:27:50.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.931]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.931]             }
[08:27:50.931]             base::options(...future.oldOptions)
[08:27:50.931]             if (.Platform$OS.type == "windows") {
[08:27:50.931]                 old_names <- names(...future.oldEnvVars)
[08:27:50.931]                 envs <- base::Sys.getenv()
[08:27:50.931]                 names <- names(envs)
[08:27:50.931]                 common <- intersect(names, old_names)
[08:27:50.931]                 added <- setdiff(names, old_names)
[08:27:50.931]                 removed <- setdiff(old_names, names)
[08:27:50.931]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.931]                   envs[common]]
[08:27:50.931]                 NAMES <- toupper(changed)
[08:27:50.931]                 args <- list()
[08:27:50.931]                 for (kk in seq_along(NAMES)) {
[08:27:50.931]                   name <- changed[[kk]]
[08:27:50.931]                   NAME <- NAMES[[kk]]
[08:27:50.931]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.931]                     next
[08:27:50.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.931]                 }
[08:27:50.931]                 NAMES <- toupper(added)
[08:27:50.931]                 for (kk in seq_along(NAMES)) {
[08:27:50.931]                   name <- added[[kk]]
[08:27:50.931]                   NAME <- NAMES[[kk]]
[08:27:50.931]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.931]                     next
[08:27:50.931]                   args[[name]] <- ""
[08:27:50.931]                 }
[08:27:50.931]                 NAMES <- toupper(removed)
[08:27:50.931]                 for (kk in seq_along(NAMES)) {
[08:27:50.931]                   name <- removed[[kk]]
[08:27:50.931]                   NAME <- NAMES[[kk]]
[08:27:50.931]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.931]                     next
[08:27:50.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.931]                 }
[08:27:50.931]                 if (length(args) > 0) 
[08:27:50.931]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.931]             }
[08:27:50.931]             else {
[08:27:50.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.931]             }
[08:27:50.931]             {
[08:27:50.931]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.931]                   0L) {
[08:27:50.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.931]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.931]                   base::options(opts)
[08:27:50.931]                 }
[08:27:50.931]                 {
[08:27:50.931]                   {
[08:27:50.931]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:50.931]                     NULL
[08:27:50.931]                   }
[08:27:50.931]                   options(future.plan = NULL)
[08:27:50.931]                   if (is.na(NA_character_)) 
[08:27:50.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.931]                     .init = FALSE)
[08:27:50.931]                 }
[08:27:50.931]             }
[08:27:50.931]         }
[08:27:50.931]     })
[08:27:50.931]     if (TRUE) {
[08:27:50.931]         base::sink(type = "output", split = FALSE)
[08:27:50.931]         if (TRUE) {
[08:27:50.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.931]         }
[08:27:50.931]         else {
[08:27:50.931]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.931]         }
[08:27:50.931]         base::close(...future.stdout)
[08:27:50.931]         ...future.stdout <- NULL
[08:27:50.931]     }
[08:27:50.931]     ...future.result$conditions <- ...future.conditions
[08:27:50.931]     ...future.result$finished <- base::Sys.time()
[08:27:50.931]     ...future.result
[08:27:50.931] }
[08:27:50.934] requestCore(): workers = 2
[08:27:50.936] MulticoreFuture started
[08:27:50.937] - Launch lazy future ... done
[08:27:50.937] run() for ‘MulticoreFuture’ ... done
[08:27:50.937] plan(): Setting new future strategy stack:
[08:27:50.937] getGlobalsAndPackages() ...
[08:27:50.938] Searching for globals...
[08:27:50.937] List of future strategies:
[08:27:50.937] 1. sequential:
[08:27:50.937]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.937]    - tweaked: FALSE
[08:27:50.937]    - call: NULL
[08:27:50.939] plan(): nbrOfWorkers() = 1
[08:27:50.939] 
[08:27:50.939] Searching for globals ... DONE
[08:27:50.939] - globals: [0] <none>
[08:27:50.939] getGlobalsAndPackages() ... DONE
[08:27:50.940] run() for ‘Future’ ...
[08:27:50.940] - state: ‘created’
[08:27:50.941] plan(): Setting new future strategy stack:
[08:27:50.941] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:50.941] List of future strategies:
[08:27:50.941] 1. multicore:
[08:27:50.941]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:50.941]    - tweaked: FALSE
[08:27:50.941]    - call: plan(strategy)
[08:27:50.944] plan(): nbrOfWorkers() = 2
[08:27:50.944] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:50.944] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:50.945]   - Field: ‘label’
[08:27:50.945]   - Field: ‘local’
[08:27:50.945]   - Field: ‘owner’
[08:27:50.945]   - Field: ‘envir’
[08:27:50.945]   - Field: ‘workers’
[08:27:50.946]   - Field: ‘packages’
[08:27:50.946]   - Field: ‘gc’
[08:27:50.946]   - Field: ‘job’
[08:27:50.946]   - Field: ‘conditions’
[08:27:50.946]   - Field: ‘expr’
[08:27:50.947]   - Field: ‘uuid’
[08:27:50.947]   - Field: ‘seed’
[08:27:50.947]   - Field: ‘version’
[08:27:50.947]   - Field: ‘result’
[08:27:50.947]   - Field: ‘asynchronous’
[08:27:50.947]   - Field: ‘calls’
[08:27:50.947]   - Field: ‘globals’
[08:27:50.948]   - Field: ‘stdout’
[08:27:50.948]   - Field: ‘earlySignal’
[08:27:50.948]   - Field: ‘lazy’
[08:27:50.948]   - Field: ‘state’
[08:27:50.948] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:50.948] - Launch lazy future ...
[08:27:50.949] Packages needed by the future expression (n = 0): <none>
[08:27:50.949] Packages needed by future strategies (n = 0): <none>
[08:27:50.950] {
[08:27:50.950]     {
[08:27:50.950]         {
[08:27:50.950]             ...future.startTime <- base::Sys.time()
[08:27:50.950]             {
[08:27:50.950]                 {
[08:27:50.950]                   {
[08:27:50.950]                     {
[08:27:50.950]                       base::local({
[08:27:50.950]                         has_future <- base::requireNamespace("future", 
[08:27:50.950]                           quietly = TRUE)
[08:27:50.950]                         if (has_future) {
[08:27:50.950]                           ns <- base::getNamespace("future")
[08:27:50.950]                           version <- ns[[".package"]][["version"]]
[08:27:50.950]                           if (is.null(version)) 
[08:27:50.950]                             version <- utils::packageVersion("future")
[08:27:50.950]                         }
[08:27:50.950]                         else {
[08:27:50.950]                           version <- NULL
[08:27:50.950]                         }
[08:27:50.950]                         if (!has_future || version < "1.8.0") {
[08:27:50.950]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:50.950]                             "", base::R.version$version.string), 
[08:27:50.950]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:50.950]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:50.950]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:50.950]                               "release", "version")], collapse = " "), 
[08:27:50.950]                             hostname = base::Sys.info()[["nodename"]])
[08:27:50.950]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:50.950]                             info)
[08:27:50.950]                           info <- base::paste(info, collapse = "; ")
[08:27:50.950]                           if (!has_future) {
[08:27:50.950]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:50.950]                               info)
[08:27:50.950]                           }
[08:27:50.950]                           else {
[08:27:50.950]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:50.950]                               info, version)
[08:27:50.950]                           }
[08:27:50.950]                           base::stop(msg)
[08:27:50.950]                         }
[08:27:50.950]                       })
[08:27:50.950]                     }
[08:27:50.950]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:50.950]                     base::options(mc.cores = 1L)
[08:27:50.950]                   }
[08:27:50.950]                   ...future.strategy.old <- future::plan("list")
[08:27:50.950]                   options(future.plan = NULL)
[08:27:50.950]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.950]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:50.950]                 }
[08:27:50.950]                 ...future.workdir <- getwd()
[08:27:50.950]             }
[08:27:50.950]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:50.950]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:50.950]         }
[08:27:50.950]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:50.950]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:50.950]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:50.950]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:50.950]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:50.950]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:50.950]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:50.950]             base::names(...future.oldOptions))
[08:27:50.950]     }
[08:27:50.950]     if (FALSE) {
[08:27:50.950]     }
[08:27:50.950]     else {
[08:27:50.950]         if (TRUE) {
[08:27:50.950]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:50.950]                 open = "w")
[08:27:50.950]         }
[08:27:50.950]         else {
[08:27:50.950]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:50.950]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:50.950]         }
[08:27:50.950]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:50.950]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:50.950]             base::sink(type = "output", split = FALSE)
[08:27:50.950]             base::close(...future.stdout)
[08:27:50.950]         }, add = TRUE)
[08:27:50.950]     }
[08:27:50.950]     ...future.frame <- base::sys.nframe()
[08:27:50.950]     ...future.conditions <- base::list()
[08:27:50.950]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:50.950]     if (FALSE) {
[08:27:50.950]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:50.950]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:50.950]     }
[08:27:50.950]     ...future.result <- base::tryCatch({
[08:27:50.950]         base::withCallingHandlers({
[08:27:50.950]             ...future.value <- base::withVisible(base::local({
[08:27:50.950]                 withCallingHandlers({
[08:27:50.950]                   NULL
[08:27:50.950]                 }, immediateCondition = function(cond) {
[08:27:50.950]                   save_rds <- function (object, pathname, ...) 
[08:27:50.950]                   {
[08:27:50.950]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:50.950]                     if (file_test("-f", pathname_tmp)) {
[08:27:50.950]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.950]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:50.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.950]                         fi_tmp[["mtime"]])
[08:27:50.950]                     }
[08:27:50.950]                     tryCatch({
[08:27:50.950]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:50.950]                     }, error = function(ex) {
[08:27:50.950]                       msg <- conditionMessage(ex)
[08:27:50.950]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.950]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:50.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.950]                         fi_tmp[["mtime"]], msg)
[08:27:50.950]                       ex$message <- msg
[08:27:50.950]                       stop(ex)
[08:27:50.950]                     })
[08:27:50.950]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:50.950]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:50.950]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:50.950]                       fi_tmp <- file.info(pathname_tmp)
[08:27:50.950]                       fi <- file.info(pathname)
[08:27:50.950]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:50.950]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:50.950]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:50.950]                         fi[["size"]], fi[["mtime"]])
[08:27:50.950]                       stop(msg)
[08:27:50.950]                     }
[08:27:50.950]                     invisible(pathname)
[08:27:50.950]                   }
[08:27:50.950]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:50.950]                     rootPath = tempdir()) 
[08:27:50.950]                   {
[08:27:50.950]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:50.950]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:50.950]                       tmpdir = path, fileext = ".rds")
[08:27:50.950]                     save_rds(obj, file)
[08:27:50.950]                   }
[08:27:50.950]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:50.950]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.950]                   {
[08:27:50.950]                     inherits <- base::inherits
[08:27:50.950]                     invokeRestart <- base::invokeRestart
[08:27:50.950]                     is.null <- base::is.null
[08:27:50.950]                     muffled <- FALSE
[08:27:50.950]                     if (inherits(cond, "message")) {
[08:27:50.950]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:50.950]                       if (muffled) 
[08:27:50.950]                         invokeRestart("muffleMessage")
[08:27:50.950]                     }
[08:27:50.950]                     else if (inherits(cond, "warning")) {
[08:27:50.950]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:50.950]                       if (muffled) 
[08:27:50.950]                         invokeRestart("muffleWarning")
[08:27:50.950]                     }
[08:27:50.950]                     else if (inherits(cond, "condition")) {
[08:27:50.950]                       if (!is.null(pattern)) {
[08:27:50.950]                         computeRestarts <- base::computeRestarts
[08:27:50.950]                         grepl <- base::grepl
[08:27:50.950]                         restarts <- computeRestarts(cond)
[08:27:50.950]                         for (restart in restarts) {
[08:27:50.950]                           name <- restart$name
[08:27:50.950]                           if (is.null(name)) 
[08:27:50.950]                             next
[08:27:50.950]                           if (!grepl(pattern, name)) 
[08:27:50.950]                             next
[08:27:50.950]                           invokeRestart(restart)
[08:27:50.950]                           muffled <- TRUE
[08:27:50.950]                           break
[08:27:50.950]                         }
[08:27:50.950]                       }
[08:27:50.950]                     }
[08:27:50.950]                     invisible(muffled)
[08:27:50.950]                   }
[08:27:50.950]                   muffleCondition(cond)
[08:27:50.950]                 })
[08:27:50.950]             }))
[08:27:50.950]             future::FutureResult(value = ...future.value$value, 
[08:27:50.950]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.950]                   ...future.rng), globalenv = if (FALSE) 
[08:27:50.950]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:50.950]                     ...future.globalenv.names))
[08:27:50.950]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:50.950]         }, condition = base::local({
[08:27:50.950]             c <- base::c
[08:27:50.950]             inherits <- base::inherits
[08:27:50.950]             invokeRestart <- base::invokeRestart
[08:27:50.950]             length <- base::length
[08:27:50.950]             list <- base::list
[08:27:50.950]             seq.int <- base::seq.int
[08:27:50.950]             signalCondition <- base::signalCondition
[08:27:50.950]             sys.calls <- base::sys.calls
[08:27:50.950]             `[[` <- base::`[[`
[08:27:50.950]             `+` <- base::`+`
[08:27:50.950]             `<<-` <- base::`<<-`
[08:27:50.950]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:50.950]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:50.950]                   3L)]
[08:27:50.950]             }
[08:27:50.950]             function(cond) {
[08:27:50.950]                 is_error <- inherits(cond, "error")
[08:27:50.950]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:50.950]                   NULL)
[08:27:50.950]                 if (is_error) {
[08:27:50.950]                   sessionInformation <- function() {
[08:27:50.950]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:50.950]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:50.950]                       search = base::search(), system = base::Sys.info())
[08:27:50.950]                   }
[08:27:50.950]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.950]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:50.950]                     cond$call), session = sessionInformation(), 
[08:27:50.950]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:50.950]                   signalCondition(cond)
[08:27:50.950]                 }
[08:27:50.950]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:50.950]                 "immediateCondition"))) {
[08:27:50.950]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:50.950]                   ...future.conditions[[length(...future.conditions) + 
[08:27:50.950]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:50.950]                   if (TRUE && !signal) {
[08:27:50.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.950]                     {
[08:27:50.950]                       inherits <- base::inherits
[08:27:50.950]                       invokeRestart <- base::invokeRestart
[08:27:50.950]                       is.null <- base::is.null
[08:27:50.950]                       muffled <- FALSE
[08:27:50.950]                       if (inherits(cond, "message")) {
[08:27:50.950]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.950]                         if (muffled) 
[08:27:50.950]                           invokeRestart("muffleMessage")
[08:27:50.950]                       }
[08:27:50.950]                       else if (inherits(cond, "warning")) {
[08:27:50.950]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.950]                         if (muffled) 
[08:27:50.950]                           invokeRestart("muffleWarning")
[08:27:50.950]                       }
[08:27:50.950]                       else if (inherits(cond, "condition")) {
[08:27:50.950]                         if (!is.null(pattern)) {
[08:27:50.950]                           computeRestarts <- base::computeRestarts
[08:27:50.950]                           grepl <- base::grepl
[08:27:50.950]                           restarts <- computeRestarts(cond)
[08:27:50.950]                           for (restart in restarts) {
[08:27:50.950]                             name <- restart$name
[08:27:50.950]                             if (is.null(name)) 
[08:27:50.950]                               next
[08:27:50.950]                             if (!grepl(pattern, name)) 
[08:27:50.950]                               next
[08:27:50.950]                             invokeRestart(restart)
[08:27:50.950]                             muffled <- TRUE
[08:27:50.950]                             break
[08:27:50.950]                           }
[08:27:50.950]                         }
[08:27:50.950]                       }
[08:27:50.950]                       invisible(muffled)
[08:27:50.950]                     }
[08:27:50.950]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.950]                   }
[08:27:50.950]                 }
[08:27:50.950]                 else {
[08:27:50.950]                   if (TRUE) {
[08:27:50.950]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:50.950]                     {
[08:27:50.950]                       inherits <- base::inherits
[08:27:50.950]                       invokeRestart <- base::invokeRestart
[08:27:50.950]                       is.null <- base::is.null
[08:27:50.950]                       muffled <- FALSE
[08:27:50.950]                       if (inherits(cond, "message")) {
[08:27:50.950]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:50.950]                         if (muffled) 
[08:27:50.950]                           invokeRestart("muffleMessage")
[08:27:50.950]                       }
[08:27:50.950]                       else if (inherits(cond, "warning")) {
[08:27:50.950]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:50.950]                         if (muffled) 
[08:27:50.950]                           invokeRestart("muffleWarning")
[08:27:50.950]                       }
[08:27:50.950]                       else if (inherits(cond, "condition")) {
[08:27:50.950]                         if (!is.null(pattern)) {
[08:27:50.950]                           computeRestarts <- base::computeRestarts
[08:27:50.950]                           grepl <- base::grepl
[08:27:50.950]                           restarts <- computeRestarts(cond)
[08:27:50.950]                           for (restart in restarts) {
[08:27:50.950]                             name <- restart$name
[08:27:50.950]                             if (is.null(name)) 
[08:27:50.950]                               next
[08:27:50.950]                             if (!grepl(pattern, name)) 
[08:27:50.950]                               next
[08:27:50.950]                             invokeRestart(restart)
[08:27:50.950]                             muffled <- TRUE
[08:27:50.950]                             break
[08:27:50.950]                           }
[08:27:50.950]                         }
[08:27:50.950]                       }
[08:27:50.950]                       invisible(muffled)
[08:27:50.950]                     }
[08:27:50.950]                     muffleCondition(cond, pattern = "^muffle")
[08:27:50.950]                   }
[08:27:50.950]                 }
[08:27:50.950]             }
[08:27:50.950]         }))
[08:27:50.950]     }, error = function(ex) {
[08:27:50.950]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:50.950]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:50.950]                 ...future.rng), started = ...future.startTime, 
[08:27:50.950]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:50.950]             version = "1.8"), class = "FutureResult")
[08:27:50.950]     }, finally = {
[08:27:50.950]         if (!identical(...future.workdir, getwd())) 
[08:27:50.950]             setwd(...future.workdir)
[08:27:50.950]         {
[08:27:50.950]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:50.950]                 ...future.oldOptions$nwarnings <- NULL
[08:27:50.950]             }
[08:27:50.950]             base::options(...future.oldOptions)
[08:27:50.950]             if (.Platform$OS.type == "windows") {
[08:27:50.950]                 old_names <- names(...future.oldEnvVars)
[08:27:50.950]                 envs <- base::Sys.getenv()
[08:27:50.950]                 names <- names(envs)
[08:27:50.950]                 common <- intersect(names, old_names)
[08:27:50.950]                 added <- setdiff(names, old_names)
[08:27:50.950]                 removed <- setdiff(old_names, names)
[08:27:50.950]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:50.950]                   envs[common]]
[08:27:50.950]                 NAMES <- toupper(changed)
[08:27:50.950]                 args <- list()
[08:27:50.950]                 for (kk in seq_along(NAMES)) {
[08:27:50.950]                   name <- changed[[kk]]
[08:27:50.950]                   NAME <- NAMES[[kk]]
[08:27:50.950]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.950]                     next
[08:27:50.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.950]                 }
[08:27:50.950]                 NAMES <- toupper(added)
[08:27:50.950]                 for (kk in seq_along(NAMES)) {
[08:27:50.950]                   name <- added[[kk]]
[08:27:50.950]                   NAME <- NAMES[[kk]]
[08:27:50.950]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.950]                     next
[08:27:50.950]                   args[[name]] <- ""
[08:27:50.950]                 }
[08:27:50.950]                 NAMES <- toupper(removed)
[08:27:50.950]                 for (kk in seq_along(NAMES)) {
[08:27:50.950]                   name <- removed[[kk]]
[08:27:50.950]                   NAME <- NAMES[[kk]]
[08:27:50.950]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:50.950]                     next
[08:27:50.950]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:50.950]                 }
[08:27:50.950]                 if (length(args) > 0) 
[08:27:50.950]                   base::do.call(base::Sys.setenv, args = args)
[08:27:50.950]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:50.950]             }
[08:27:50.950]             else {
[08:27:50.950]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:50.950]             }
[08:27:50.950]             {
[08:27:50.950]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:50.950]                   0L) {
[08:27:50.950]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:50.950]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:50.950]                   base::options(opts)
[08:27:50.950]                 }
[08:27:50.950]                 {
[08:27:50.950]                   {
[08:27:50.950]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:50.950]                     NULL
[08:27:50.950]                   }
[08:27:50.950]                   options(future.plan = NULL)
[08:27:50.950]                   if (is.na(NA_character_)) 
[08:27:50.950]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:50.950]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:50.950]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:50.950]                     .init = FALSE)
[08:27:50.950]                 }
[08:27:50.950]             }
[08:27:50.950]         }
[08:27:50.950]     })
[08:27:50.950]     if (TRUE) {
[08:27:50.950]         base::sink(type = "output", split = FALSE)
[08:27:50.950]         if (TRUE) {
[08:27:50.950]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:50.950]         }
[08:27:50.950]         else {
[08:27:50.950]             ...future.result["stdout"] <- base::list(NULL)
[08:27:50.950]         }
[08:27:50.950]         base::close(...future.stdout)
[08:27:50.950]         ...future.stdout <- NULL
[08:27:50.950]     }
[08:27:50.950]     ...future.result$conditions <- ...future.conditions
[08:27:50.950]     ...future.result$finished <- base::Sys.time()
[08:27:50.950]     ...future.result
[08:27:50.950] }
[08:27:50.953] requestCore(): workers = 2
[08:27:50.956] MulticoreFuture started
[08:27:50.956] - Launch lazy future ... done
[08:27:50.956] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[08:27:50.957] plan(): Setting new future strategy stack:
 num 1
 $ b:[08:27:50.957] List of future strategies:
[08:27:50.957] 1. sequential:
[08:27:50.957]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:50.957]    - tweaked: FALSE
[08:27:50.957]    - call: NULL
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' [08:27:50.958] plan(): nbrOfWorkers() = 1
<environment: 0x55d85f1d4710> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d86070ef50> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a:[08:27:50.961] plan(): Setting new future strategy stack:
 num 1
 $ b:[08:27:50.961] List of future strategies:
[08:27:50.961] 1. multicore:
[08:27:50.961]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:50.961]    - tweaked: FALSE
[08:27:50.961]    - call: plan(strategy)
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d85f1d4710> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d86070ef50> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List[08:27:50.964] plan(): nbrOfWorkers() = 2
 of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:50.968] resolve() on list ...
[08:27:50.968]  recursive: 0
[08:27:50.968]  length: 6
[08:27:50.968]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:50.969] signalConditionsASAP(numeric, pos=1) ...
[08:27:50.969] - nx: 6
[08:27:50.969] - relay: TRUE
[08:27:50.969] - stdout: TRUE
[08:27:50.969] - signal: TRUE
[08:27:50.969] - resignal: FALSE
[08:27:50.973] - force: TRUE
[08:27:50.974] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.974] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.974]  - until=2
[08:27:50.975]  - relaying element #2
[08:27:50.975] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.975] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.975] signalConditionsASAP(NULL, pos=1) ... done
[08:27:50.976]  length: 5 (resolved future 1)
[08:27:50.976] Future #2
[08:27:50.977] result() for MulticoreFuture ...
[08:27:50.978] result() for MulticoreFuture ...
[08:27:50.978] result() for MulticoreFuture ... done
[08:27:50.978] result() for MulticoreFuture ... done
[08:27:50.979] result() for MulticoreFuture ...
[08:27:50.979] result() for MulticoreFuture ... done
[08:27:50.979] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:50.979] - nx: 6
[08:27:50.979] - relay: TRUE
[08:27:50.979] - stdout: TRUE
[08:27:50.980] - signal: TRUE
[08:27:50.980] - resignal: FALSE
[08:27:50.980] - force: TRUE
[08:27:50.980] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.980] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:50.980]  - until=2
[08:27:50.980]  - relaying element #2
[08:27:50.981] result() for MulticoreFuture ...
[08:27:50.981] result() for MulticoreFuture ... done
[08:27:50.981] result() for MulticoreFuture ...
[08:27:50.981] result() for MulticoreFuture ... done
[08:27:50.981] result() for MulticoreFuture ...
[08:27:50.981] result() for MulticoreFuture ... done
[08:27:50.982] result() for MulticoreFuture ...
[08:27:50.982] result() for MulticoreFuture ... done
[08:27:50.982] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.982] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.982] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:50.982]  length: 4 (resolved future 2)
[08:27:50.983] Future #3
[08:27:50.983] result() for MulticoreFuture ...
[08:27:50.984] result() for MulticoreFuture ...
[08:27:50.984] result() for MulticoreFuture ... done
[08:27:50.984] result() for MulticoreFuture ... done
[08:27:50.984] result() for MulticoreFuture ...
[08:27:50.984] result() for MulticoreFuture ... done
[08:27:50.984] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:50.984] - nx: 6
[08:27:50.985] - relay: TRUE
[08:27:50.985] - stdout: TRUE
[08:27:50.985] - signal: TRUE
[08:27:50.985] - resignal: FALSE
[08:27:50.985] - force: TRUE
[08:27:50.985] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.985] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:50.985]  - until=3
[08:27:50.985]  - relaying element #3
[08:27:50.986] result() for MulticoreFuture ...
[08:27:50.986] result() for MulticoreFuture ... done
[08:27:50.986] result() for MulticoreFuture ...
[08:27:50.986] result() for MulticoreFuture ... done
[08:27:50.986] result() for MulticoreFuture ...
[08:27:50.986] result() for MulticoreFuture ... done
[08:27:50.986] result() for MulticoreFuture ...
[08:27:50.986] result() for MulticoreFuture ... done
[08:27:50.987] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.987] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.987] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:50.987]  length: 3 (resolved future 3)
[08:27:50.987] signalConditionsASAP(NULL, pos=4) ...
[08:27:50.987] - nx: 6
[08:27:50.987] - relay: TRUE
[08:27:50.987] - stdout: TRUE
[08:27:50.987] - signal: TRUE
[08:27:50.987] - resignal: FALSE
[08:27:50.988] - force: TRUE
[08:27:50.988] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.988] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.988]  - until=5
[08:27:50.988]  - relaying element #5
[08:27:50.988] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.988] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.988] signalConditionsASAP(NULL, pos=4) ... done
[08:27:50.988]  length: 2 (resolved future 4)
[08:27:50.988] signalConditionsASAP(NULL, pos=5) ...
[08:27:50.989] - nx: 6
[08:27:50.989] - relay: TRUE
[08:27:50.989] - stdout: TRUE
[08:27:50.989] - signal: TRUE
[08:27:50.989] - resignal: FALSE
[08:27:50.989] - force: TRUE
[08:27:50.989] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:50.989] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.989]  - until=6
[08:27:50.989]  - relaying element #6
[08:27:50.989] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.990] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.990] signalConditionsASAP(NULL, pos=5) ... done
[08:27:50.990]  length: 1 (resolved future 5)
[08:27:50.990] signalConditionsASAP(numeric, pos=6) ...
[08:27:50.990] - nx: 6
[08:27:50.990] - relay: TRUE
[08:27:50.990] - stdout: TRUE
[08:27:50.990] - signal: TRUE
[08:27:50.990] - resignal: FALSE
[08:27:50.990] - force: TRUE
[08:27:50.990] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:50.991] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.991]  - until=6
[08:27:50.991] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.991] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.991] signalConditionsASAP(numeric, pos=6) ... done
[08:27:50.991]  length: 0 (resolved future 6)
[08:27:50.991] Relaying remaining futures
[08:27:50.991] signalConditionsASAP(NULL, pos=0) ...
[08:27:50.991] - nx: 6
[08:27:50.991] - relay: TRUE
[08:27:50.992] - stdout: TRUE
[08:27:50.992] - signal: TRUE
[08:27:50.992] - resignal: FALSE
[08:27:50.992] - force: TRUE
[08:27:50.992] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.992] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:50.992] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:50.992] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:50.992] signalConditionsASAP(NULL, pos=0) ... done
[08:27:50.992] resolve() on list ... DONE
[08:27:50.993] result() for MulticoreFuture ...
[08:27:50.993] result() for MulticoreFuture ... done
[08:27:50.993] result() for MulticoreFuture ...
[08:27:50.993] result() for MulticoreFuture ... done
[08:27:50.993] result() for MulticoreFuture ...
[08:27:50.993] result() for MulticoreFuture ... done
[08:27:50.993] result() for MulticoreFuture ...
[08:27:50.993] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[08:27:50.997] getGlobalsAndPackages() ...
[08:27:50.997] Searching for globals...
[08:27:50.997] 
[08:27:50.997] Searching for globals ... DONE
[08:27:50.997] - globals: [0] <none>
[08:27:50.998] getGlobalsAndPackages() ... DONE
[08:27:50.998] run() for ‘Future’ ...
[08:27:50.998] - state: ‘created’
[08:27:50.998] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.000] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.000] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:51.000]   - Field: ‘label’
[08:27:51.000]   - Field: ‘local’
[08:27:51.000]   - Field: ‘owner’
[08:27:51.001]   - Field: ‘envir’
[08:27:51.001]   - Field: ‘workers’
[08:27:51.001]   - Field: ‘packages’
[08:27:51.001]   - Field: ‘gc’
[08:27:51.001]   - Field: ‘job’
[08:27:51.001]   - Field: ‘conditions’
[08:27:51.001]   - Field: ‘expr’
[08:27:51.001]   - Field: ‘uuid’
[08:27:51.001]   - Field: ‘seed’
[08:27:51.001]   - Field: ‘version’
[08:27:51.001]   - Field: ‘result’
[08:27:51.001]   - Field: ‘asynchronous’
[08:27:51.002]   - Field: ‘calls’
[08:27:51.002]   - Field: ‘globals’
[08:27:51.002]   - Field: ‘stdout’
[08:27:51.002]   - Field: ‘earlySignal’
[08:27:51.002]   - Field: ‘lazy’
[08:27:51.002]   - Field: ‘state’
[08:27:51.002] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:51.002] - Launch lazy future ...
[08:27:51.003] Packages needed by the future expression (n = 0): <none>
[08:27:51.003] Packages needed by future strategies (n = 0): <none>
[08:27:51.003] {
[08:27:51.003]     {
[08:27:51.003]         {
[08:27:51.003]             ...future.startTime <- base::Sys.time()
[08:27:51.003]             {
[08:27:51.003]                 {
[08:27:51.003]                   {
[08:27:51.003]                     {
[08:27:51.003]                       base::local({
[08:27:51.003]                         has_future <- base::requireNamespace("future", 
[08:27:51.003]                           quietly = TRUE)
[08:27:51.003]                         if (has_future) {
[08:27:51.003]                           ns <- base::getNamespace("future")
[08:27:51.003]                           version <- ns[[".package"]][["version"]]
[08:27:51.003]                           if (is.null(version)) 
[08:27:51.003]                             version <- utils::packageVersion("future")
[08:27:51.003]                         }
[08:27:51.003]                         else {
[08:27:51.003]                           version <- NULL
[08:27:51.003]                         }
[08:27:51.003]                         if (!has_future || version < "1.8.0") {
[08:27:51.003]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.003]                             "", base::R.version$version.string), 
[08:27:51.003]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.003]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.003]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.003]                               "release", "version")], collapse = " "), 
[08:27:51.003]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.003]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.003]                             info)
[08:27:51.003]                           info <- base::paste(info, collapse = "; ")
[08:27:51.003]                           if (!has_future) {
[08:27:51.003]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.003]                               info)
[08:27:51.003]                           }
[08:27:51.003]                           else {
[08:27:51.003]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.003]                               info, version)
[08:27:51.003]                           }
[08:27:51.003]                           base::stop(msg)
[08:27:51.003]                         }
[08:27:51.003]                       })
[08:27:51.003]                     }
[08:27:51.003]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.003]                     base::options(mc.cores = 1L)
[08:27:51.003]                   }
[08:27:51.003]                   ...future.strategy.old <- future::plan("list")
[08:27:51.003]                   options(future.plan = NULL)
[08:27:51.003]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.003]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.003]                 }
[08:27:51.003]                 ...future.workdir <- getwd()
[08:27:51.003]             }
[08:27:51.003]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.003]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.003]         }
[08:27:51.003]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.003]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.003]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.003]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.003]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.003]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.003]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.003]             base::names(...future.oldOptions))
[08:27:51.003]     }
[08:27:51.003]     if (FALSE) {
[08:27:51.003]     }
[08:27:51.003]     else {
[08:27:51.003]         if (TRUE) {
[08:27:51.003]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.003]                 open = "w")
[08:27:51.003]         }
[08:27:51.003]         else {
[08:27:51.003]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.003]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.003]         }
[08:27:51.003]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.003]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.003]             base::sink(type = "output", split = FALSE)
[08:27:51.003]             base::close(...future.stdout)
[08:27:51.003]         }, add = TRUE)
[08:27:51.003]     }
[08:27:51.003]     ...future.frame <- base::sys.nframe()
[08:27:51.003]     ...future.conditions <- base::list()
[08:27:51.003]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.003]     if (FALSE) {
[08:27:51.003]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.003]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.003]     }
[08:27:51.003]     ...future.result <- base::tryCatch({
[08:27:51.003]         base::withCallingHandlers({
[08:27:51.003]             ...future.value <- base::withVisible(base::local({
[08:27:51.003]                 withCallingHandlers({
[08:27:51.003]                   2
[08:27:51.003]                 }, immediateCondition = function(cond) {
[08:27:51.003]                   save_rds <- function (object, pathname, ...) 
[08:27:51.003]                   {
[08:27:51.003]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:51.003]                     if (file_test("-f", pathname_tmp)) {
[08:27:51.003]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.003]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:51.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.003]                         fi_tmp[["mtime"]])
[08:27:51.003]                     }
[08:27:51.003]                     tryCatch({
[08:27:51.003]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:51.003]                     }, error = function(ex) {
[08:27:51.003]                       msg <- conditionMessage(ex)
[08:27:51.003]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.003]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:51.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.003]                         fi_tmp[["mtime"]], msg)
[08:27:51.003]                       ex$message <- msg
[08:27:51.003]                       stop(ex)
[08:27:51.003]                     })
[08:27:51.003]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:51.003]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:51.003]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:51.003]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.003]                       fi <- file.info(pathname)
[08:27:51.003]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:51.003]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.003]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:51.003]                         fi[["size"]], fi[["mtime"]])
[08:27:51.003]                       stop(msg)
[08:27:51.003]                     }
[08:27:51.003]                     invisible(pathname)
[08:27:51.003]                   }
[08:27:51.003]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:51.003]                     rootPath = tempdir()) 
[08:27:51.003]                   {
[08:27:51.003]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:51.003]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:51.003]                       tmpdir = path, fileext = ".rds")
[08:27:51.003]                     save_rds(obj, file)
[08:27:51.003]                   }
[08:27:51.003]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:51.003]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.003]                   {
[08:27:51.003]                     inherits <- base::inherits
[08:27:51.003]                     invokeRestart <- base::invokeRestart
[08:27:51.003]                     is.null <- base::is.null
[08:27:51.003]                     muffled <- FALSE
[08:27:51.003]                     if (inherits(cond, "message")) {
[08:27:51.003]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.003]                       if (muffled) 
[08:27:51.003]                         invokeRestart("muffleMessage")
[08:27:51.003]                     }
[08:27:51.003]                     else if (inherits(cond, "warning")) {
[08:27:51.003]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.003]                       if (muffled) 
[08:27:51.003]                         invokeRestart("muffleWarning")
[08:27:51.003]                     }
[08:27:51.003]                     else if (inherits(cond, "condition")) {
[08:27:51.003]                       if (!is.null(pattern)) {
[08:27:51.003]                         computeRestarts <- base::computeRestarts
[08:27:51.003]                         grepl <- base::grepl
[08:27:51.003]                         restarts <- computeRestarts(cond)
[08:27:51.003]                         for (restart in restarts) {
[08:27:51.003]                           name <- restart$name
[08:27:51.003]                           if (is.null(name)) 
[08:27:51.003]                             next
[08:27:51.003]                           if (!grepl(pattern, name)) 
[08:27:51.003]                             next
[08:27:51.003]                           invokeRestart(restart)
[08:27:51.003]                           muffled <- TRUE
[08:27:51.003]                           break
[08:27:51.003]                         }
[08:27:51.003]                       }
[08:27:51.003]                     }
[08:27:51.003]                     invisible(muffled)
[08:27:51.003]                   }
[08:27:51.003]                   muffleCondition(cond)
[08:27:51.003]                 })
[08:27:51.003]             }))
[08:27:51.003]             future::FutureResult(value = ...future.value$value, 
[08:27:51.003]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.003]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.003]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.003]                     ...future.globalenv.names))
[08:27:51.003]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.003]         }, condition = base::local({
[08:27:51.003]             c <- base::c
[08:27:51.003]             inherits <- base::inherits
[08:27:51.003]             invokeRestart <- base::invokeRestart
[08:27:51.003]             length <- base::length
[08:27:51.003]             list <- base::list
[08:27:51.003]             seq.int <- base::seq.int
[08:27:51.003]             signalCondition <- base::signalCondition
[08:27:51.003]             sys.calls <- base::sys.calls
[08:27:51.003]             `[[` <- base::`[[`
[08:27:51.003]             `+` <- base::`+`
[08:27:51.003]             `<<-` <- base::`<<-`
[08:27:51.003]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.003]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.003]                   3L)]
[08:27:51.003]             }
[08:27:51.003]             function(cond) {
[08:27:51.003]                 is_error <- inherits(cond, "error")
[08:27:51.003]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.003]                   NULL)
[08:27:51.003]                 if (is_error) {
[08:27:51.003]                   sessionInformation <- function() {
[08:27:51.003]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.003]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.003]                       search = base::search(), system = base::Sys.info())
[08:27:51.003]                   }
[08:27:51.003]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.003]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.003]                     cond$call), session = sessionInformation(), 
[08:27:51.003]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.003]                   signalCondition(cond)
[08:27:51.003]                 }
[08:27:51.003]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.003]                 "immediateCondition"))) {
[08:27:51.003]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.003]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.003]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.003]                   if (TRUE && !signal) {
[08:27:51.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.003]                     {
[08:27:51.003]                       inherits <- base::inherits
[08:27:51.003]                       invokeRestart <- base::invokeRestart
[08:27:51.003]                       is.null <- base::is.null
[08:27:51.003]                       muffled <- FALSE
[08:27:51.003]                       if (inherits(cond, "message")) {
[08:27:51.003]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.003]                         if (muffled) 
[08:27:51.003]                           invokeRestart("muffleMessage")
[08:27:51.003]                       }
[08:27:51.003]                       else if (inherits(cond, "warning")) {
[08:27:51.003]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.003]                         if (muffled) 
[08:27:51.003]                           invokeRestart("muffleWarning")
[08:27:51.003]                       }
[08:27:51.003]                       else if (inherits(cond, "condition")) {
[08:27:51.003]                         if (!is.null(pattern)) {
[08:27:51.003]                           computeRestarts <- base::computeRestarts
[08:27:51.003]                           grepl <- base::grepl
[08:27:51.003]                           restarts <- computeRestarts(cond)
[08:27:51.003]                           for (restart in restarts) {
[08:27:51.003]                             name <- restart$name
[08:27:51.003]                             if (is.null(name)) 
[08:27:51.003]                               next
[08:27:51.003]                             if (!grepl(pattern, name)) 
[08:27:51.003]                               next
[08:27:51.003]                             invokeRestart(restart)
[08:27:51.003]                             muffled <- TRUE
[08:27:51.003]                             break
[08:27:51.003]                           }
[08:27:51.003]                         }
[08:27:51.003]                       }
[08:27:51.003]                       invisible(muffled)
[08:27:51.003]                     }
[08:27:51.003]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.003]                   }
[08:27:51.003]                 }
[08:27:51.003]                 else {
[08:27:51.003]                   if (TRUE) {
[08:27:51.003]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.003]                     {
[08:27:51.003]                       inherits <- base::inherits
[08:27:51.003]                       invokeRestart <- base::invokeRestart
[08:27:51.003]                       is.null <- base::is.null
[08:27:51.003]                       muffled <- FALSE
[08:27:51.003]                       if (inherits(cond, "message")) {
[08:27:51.003]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.003]                         if (muffled) 
[08:27:51.003]                           invokeRestart("muffleMessage")
[08:27:51.003]                       }
[08:27:51.003]                       else if (inherits(cond, "warning")) {
[08:27:51.003]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.003]                         if (muffled) 
[08:27:51.003]                           invokeRestart("muffleWarning")
[08:27:51.003]                       }
[08:27:51.003]                       else if (inherits(cond, "condition")) {
[08:27:51.003]                         if (!is.null(pattern)) {
[08:27:51.003]                           computeRestarts <- base::computeRestarts
[08:27:51.003]                           grepl <- base::grepl
[08:27:51.003]                           restarts <- computeRestarts(cond)
[08:27:51.003]                           for (restart in restarts) {
[08:27:51.003]                             name <- restart$name
[08:27:51.003]                             if (is.null(name)) 
[08:27:51.003]                               next
[08:27:51.003]                             if (!grepl(pattern, name)) 
[08:27:51.003]                               next
[08:27:51.003]                             invokeRestart(restart)
[08:27:51.003]                             muffled <- TRUE
[08:27:51.003]                             break
[08:27:51.003]                           }
[08:27:51.003]                         }
[08:27:51.003]                       }
[08:27:51.003]                       invisible(muffled)
[08:27:51.003]                     }
[08:27:51.003]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.003]                   }
[08:27:51.003]                 }
[08:27:51.003]             }
[08:27:51.003]         }))
[08:27:51.003]     }, error = function(ex) {
[08:27:51.003]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.003]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.003]                 ...future.rng), started = ...future.startTime, 
[08:27:51.003]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.003]             version = "1.8"), class = "FutureResult")
[08:27:51.003]     }, finally = {
[08:27:51.003]         if (!identical(...future.workdir, getwd())) 
[08:27:51.003]             setwd(...future.workdir)
[08:27:51.003]         {
[08:27:51.003]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.003]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.003]             }
[08:27:51.003]             base::options(...future.oldOptions)
[08:27:51.003]             if (.Platform$OS.type == "windows") {
[08:27:51.003]                 old_names <- names(...future.oldEnvVars)
[08:27:51.003]                 envs <- base::Sys.getenv()
[08:27:51.003]                 names <- names(envs)
[08:27:51.003]                 common <- intersect(names, old_names)
[08:27:51.003]                 added <- setdiff(names, old_names)
[08:27:51.003]                 removed <- setdiff(old_names, names)
[08:27:51.003]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.003]                   envs[common]]
[08:27:51.003]                 NAMES <- toupper(changed)
[08:27:51.003]                 args <- list()
[08:27:51.003]                 for (kk in seq_along(NAMES)) {
[08:27:51.003]                   name <- changed[[kk]]
[08:27:51.003]                   NAME <- NAMES[[kk]]
[08:27:51.003]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.003]                     next
[08:27:51.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.003]                 }
[08:27:51.003]                 NAMES <- toupper(added)
[08:27:51.003]                 for (kk in seq_along(NAMES)) {
[08:27:51.003]                   name <- added[[kk]]
[08:27:51.003]                   NAME <- NAMES[[kk]]
[08:27:51.003]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.003]                     next
[08:27:51.003]                   args[[name]] <- ""
[08:27:51.003]                 }
[08:27:51.003]                 NAMES <- toupper(removed)
[08:27:51.003]                 for (kk in seq_along(NAMES)) {
[08:27:51.003]                   name <- removed[[kk]]
[08:27:51.003]                   NAME <- NAMES[[kk]]
[08:27:51.003]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.003]                     next
[08:27:51.003]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.003]                 }
[08:27:51.003]                 if (length(args) > 0) 
[08:27:51.003]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.003]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.003]             }
[08:27:51.003]             else {
[08:27:51.003]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.003]             }
[08:27:51.003]             {
[08:27:51.003]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.003]                   0L) {
[08:27:51.003]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.003]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.003]                   base::options(opts)
[08:27:51.003]                 }
[08:27:51.003]                 {
[08:27:51.003]                   {
[08:27:51.003]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.003]                     NULL
[08:27:51.003]                   }
[08:27:51.003]                   options(future.plan = NULL)
[08:27:51.003]                   if (is.na(NA_character_)) 
[08:27:51.003]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.003]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.003]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.003]                     .init = FALSE)
[08:27:51.003]                 }
[08:27:51.003]             }
[08:27:51.003]         }
[08:27:51.003]     })
[08:27:51.003]     if (TRUE) {
[08:27:51.003]         base::sink(type = "output", split = FALSE)
[08:27:51.003]         if (TRUE) {
[08:27:51.003]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.003]         }
[08:27:51.003]         else {
[08:27:51.003]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.003]         }
[08:27:51.003]         base::close(...future.stdout)
[08:27:51.003]         ...future.stdout <- NULL
[08:27:51.003]     }
[08:27:51.003]     ...future.result$conditions <- ...future.conditions
[08:27:51.003]     ...future.result$finished <- base::Sys.time()
[08:27:51.003]     ...future.result
[08:27:51.003] }
[08:27:51.006] requestCore(): workers = 2
[08:27:51.008] MulticoreFuture started
[08:27:51.008] - Launch lazy future ... done
[08:27:51.008] run() for ‘MulticoreFuture’ ... done
[08:27:51.009] getGlobalsAndPackages() ...
[08:27:51.009] Searching for globals...
[08:27:51.009] plan(): Setting new future strategy stack:
[08:27:51.009] List of future strategies:
[08:27:51.009] 1. sequential:
[08:27:51.009]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:51.009]    - tweaked: FALSE
[08:27:51.009]    - call: NULL
[08:27:51.010] plan(): nbrOfWorkers() = 1
[08:27:51.010] 
[08:27:51.014] Searching for globals ... DONE
[08:27:51.014] - globals: [0] <none>
[08:27:51.015] getGlobalsAndPackages() ... DONE
[08:27:51.016] run() for ‘Future’ ...
[08:27:51.016] plan(): Setting new future strategy stack:
[08:27:51.016] - state: ‘created’
[08:27:51.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.016] List of future strategies:
[08:27:51.016] 1. multicore:
[08:27:51.016]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:51.016]    - tweaked: FALSE
[08:27:51.016]    - call: plan(strategy)
[08:27:51.020] plan(): nbrOfWorkers() = 2
[08:27:51.020] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.021] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:51.021]   - Field: ‘label’
[08:27:51.021]   - Field: ‘local’
[08:27:51.021]   - Field: ‘owner’
[08:27:51.021]   - Field: ‘envir’
[08:27:51.022]   - Field: ‘workers’
[08:27:51.022]   - Field: ‘packages’
[08:27:51.022]   - Field: ‘gc’
[08:27:51.022]   - Field: ‘job’
[08:27:51.022]   - Field: ‘conditions’
[08:27:51.023]   - Field: ‘expr’
[08:27:51.023]   - Field: ‘uuid’
[08:27:51.023]   - Field: ‘seed’
[08:27:51.023]   - Field: ‘version’
[08:27:51.023]   - Field: ‘result’
[08:27:51.023]   - Field: ‘asynchronous’
[08:27:51.023]   - Field: ‘calls’
[08:27:51.024]   - Field: ‘globals’
[08:27:51.024]   - Field: ‘stdout’
[08:27:51.024]   - Field: ‘earlySignal’
[08:27:51.024]   - Field: ‘lazy’
[08:27:51.024]   - Field: ‘state’
[08:27:51.025] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:51.025] - Launch lazy future ...
[08:27:51.025] Packages needed by the future expression (n = 0): <none>
[08:27:51.025] Packages needed by future strategies (n = 0): <none>
[08:27:51.026] {
[08:27:51.026]     {
[08:27:51.026]         {
[08:27:51.026]             ...future.startTime <- base::Sys.time()
[08:27:51.026]             {
[08:27:51.026]                 {
[08:27:51.026]                   {
[08:27:51.026]                     {
[08:27:51.026]                       base::local({
[08:27:51.026]                         has_future <- base::requireNamespace("future", 
[08:27:51.026]                           quietly = TRUE)
[08:27:51.026]                         if (has_future) {
[08:27:51.026]                           ns <- base::getNamespace("future")
[08:27:51.026]                           version <- ns[[".package"]][["version"]]
[08:27:51.026]                           if (is.null(version)) 
[08:27:51.026]                             version <- utils::packageVersion("future")
[08:27:51.026]                         }
[08:27:51.026]                         else {
[08:27:51.026]                           version <- NULL
[08:27:51.026]                         }
[08:27:51.026]                         if (!has_future || version < "1.8.0") {
[08:27:51.026]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.026]                             "", base::R.version$version.string), 
[08:27:51.026]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.026]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.026]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.026]                               "release", "version")], collapse = " "), 
[08:27:51.026]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.026]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.026]                             info)
[08:27:51.026]                           info <- base::paste(info, collapse = "; ")
[08:27:51.026]                           if (!has_future) {
[08:27:51.026]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.026]                               info)
[08:27:51.026]                           }
[08:27:51.026]                           else {
[08:27:51.026]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.026]                               info, version)
[08:27:51.026]                           }
[08:27:51.026]                           base::stop(msg)
[08:27:51.026]                         }
[08:27:51.026]                       })
[08:27:51.026]                     }
[08:27:51.026]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.026]                     base::options(mc.cores = 1L)
[08:27:51.026]                   }
[08:27:51.026]                   ...future.strategy.old <- future::plan("list")
[08:27:51.026]                   options(future.plan = NULL)
[08:27:51.026]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.026]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.026]                 }
[08:27:51.026]                 ...future.workdir <- getwd()
[08:27:51.026]             }
[08:27:51.026]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.026]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.026]         }
[08:27:51.026]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.026]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.026]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.026]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.026]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.026]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.026]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.026]             base::names(...future.oldOptions))
[08:27:51.026]     }
[08:27:51.026]     if (FALSE) {
[08:27:51.026]     }
[08:27:51.026]     else {
[08:27:51.026]         if (TRUE) {
[08:27:51.026]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.026]                 open = "w")
[08:27:51.026]         }
[08:27:51.026]         else {
[08:27:51.026]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.026]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.026]         }
[08:27:51.026]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.026]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.026]             base::sink(type = "output", split = FALSE)
[08:27:51.026]             base::close(...future.stdout)
[08:27:51.026]         }, add = TRUE)
[08:27:51.026]     }
[08:27:51.026]     ...future.frame <- base::sys.nframe()
[08:27:51.026]     ...future.conditions <- base::list()
[08:27:51.026]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.026]     if (FALSE) {
[08:27:51.026]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.026]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.026]     }
[08:27:51.026]     ...future.result <- base::tryCatch({
[08:27:51.026]         base::withCallingHandlers({
[08:27:51.026]             ...future.value <- base::withVisible(base::local({
[08:27:51.026]                 withCallingHandlers({
[08:27:51.026]                   NULL
[08:27:51.026]                 }, immediateCondition = function(cond) {
[08:27:51.026]                   save_rds <- function (object, pathname, ...) 
[08:27:51.026]                   {
[08:27:51.026]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:51.026]                     if (file_test("-f", pathname_tmp)) {
[08:27:51.026]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.026]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:51.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.026]                         fi_tmp[["mtime"]])
[08:27:51.026]                     }
[08:27:51.026]                     tryCatch({
[08:27:51.026]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:51.026]                     }, error = function(ex) {
[08:27:51.026]                       msg <- conditionMessage(ex)
[08:27:51.026]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.026]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:51.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.026]                         fi_tmp[["mtime"]], msg)
[08:27:51.026]                       ex$message <- msg
[08:27:51.026]                       stop(ex)
[08:27:51.026]                     })
[08:27:51.026]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:51.026]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:51.026]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:51.026]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.026]                       fi <- file.info(pathname)
[08:27:51.026]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:51.026]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.026]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:51.026]                         fi[["size"]], fi[["mtime"]])
[08:27:51.026]                       stop(msg)
[08:27:51.026]                     }
[08:27:51.026]                     invisible(pathname)
[08:27:51.026]                   }
[08:27:51.026]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:51.026]                     rootPath = tempdir()) 
[08:27:51.026]                   {
[08:27:51.026]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:51.026]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:51.026]                       tmpdir = path, fileext = ".rds")
[08:27:51.026]                     save_rds(obj, file)
[08:27:51.026]                   }
[08:27:51.026]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:51.026]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.026]                   {
[08:27:51.026]                     inherits <- base::inherits
[08:27:51.026]                     invokeRestart <- base::invokeRestart
[08:27:51.026]                     is.null <- base::is.null
[08:27:51.026]                     muffled <- FALSE
[08:27:51.026]                     if (inherits(cond, "message")) {
[08:27:51.026]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.026]                       if (muffled) 
[08:27:51.026]                         invokeRestart("muffleMessage")
[08:27:51.026]                     }
[08:27:51.026]                     else if (inherits(cond, "warning")) {
[08:27:51.026]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.026]                       if (muffled) 
[08:27:51.026]                         invokeRestart("muffleWarning")
[08:27:51.026]                     }
[08:27:51.026]                     else if (inherits(cond, "condition")) {
[08:27:51.026]                       if (!is.null(pattern)) {
[08:27:51.026]                         computeRestarts <- base::computeRestarts
[08:27:51.026]                         grepl <- base::grepl
[08:27:51.026]                         restarts <- computeRestarts(cond)
[08:27:51.026]                         for (restart in restarts) {
[08:27:51.026]                           name <- restart$name
[08:27:51.026]                           if (is.null(name)) 
[08:27:51.026]                             next
[08:27:51.026]                           if (!grepl(pattern, name)) 
[08:27:51.026]                             next
[08:27:51.026]                           invokeRestart(restart)
[08:27:51.026]                           muffled <- TRUE
[08:27:51.026]                           break
[08:27:51.026]                         }
[08:27:51.026]                       }
[08:27:51.026]                     }
[08:27:51.026]                     invisible(muffled)
[08:27:51.026]                   }
[08:27:51.026]                   muffleCondition(cond)
[08:27:51.026]                 })
[08:27:51.026]             }))
[08:27:51.026]             future::FutureResult(value = ...future.value$value, 
[08:27:51.026]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.026]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.026]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.026]                     ...future.globalenv.names))
[08:27:51.026]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.026]         }, condition = base::local({
[08:27:51.026]             c <- base::c
[08:27:51.026]             inherits <- base::inherits
[08:27:51.026]             invokeRestart <- base::invokeRestart
[08:27:51.026]             length <- base::length
[08:27:51.026]             list <- base::list
[08:27:51.026]             seq.int <- base::seq.int
[08:27:51.026]             signalCondition <- base::signalCondition
[08:27:51.026]             sys.calls <- base::sys.calls
[08:27:51.026]             `[[` <- base::`[[`
[08:27:51.026]             `+` <- base::`+`
[08:27:51.026]             `<<-` <- base::`<<-`
[08:27:51.026]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.026]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.026]                   3L)]
[08:27:51.026]             }
[08:27:51.026]             function(cond) {
[08:27:51.026]                 is_error <- inherits(cond, "error")
[08:27:51.026]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.026]                   NULL)
[08:27:51.026]                 if (is_error) {
[08:27:51.026]                   sessionInformation <- function() {
[08:27:51.026]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.026]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.026]                       search = base::search(), system = base::Sys.info())
[08:27:51.026]                   }
[08:27:51.026]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.026]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.026]                     cond$call), session = sessionInformation(), 
[08:27:51.026]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.026]                   signalCondition(cond)
[08:27:51.026]                 }
[08:27:51.026]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.026]                 "immediateCondition"))) {
[08:27:51.026]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.026]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.026]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.026]                   if (TRUE && !signal) {
[08:27:51.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.026]                     {
[08:27:51.026]                       inherits <- base::inherits
[08:27:51.026]                       invokeRestart <- base::invokeRestart
[08:27:51.026]                       is.null <- base::is.null
[08:27:51.026]                       muffled <- FALSE
[08:27:51.026]                       if (inherits(cond, "message")) {
[08:27:51.026]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.026]                         if (muffled) 
[08:27:51.026]                           invokeRestart("muffleMessage")
[08:27:51.026]                       }
[08:27:51.026]                       else if (inherits(cond, "warning")) {
[08:27:51.026]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.026]                         if (muffled) 
[08:27:51.026]                           invokeRestart("muffleWarning")
[08:27:51.026]                       }
[08:27:51.026]                       else if (inherits(cond, "condition")) {
[08:27:51.026]                         if (!is.null(pattern)) {
[08:27:51.026]                           computeRestarts <- base::computeRestarts
[08:27:51.026]                           grepl <- base::grepl
[08:27:51.026]                           restarts <- computeRestarts(cond)
[08:27:51.026]                           for (restart in restarts) {
[08:27:51.026]                             name <- restart$name
[08:27:51.026]                             if (is.null(name)) 
[08:27:51.026]                               next
[08:27:51.026]                             if (!grepl(pattern, name)) 
[08:27:51.026]                               next
[08:27:51.026]                             invokeRestart(restart)
[08:27:51.026]                             muffled <- TRUE
[08:27:51.026]                             break
[08:27:51.026]                           }
[08:27:51.026]                         }
[08:27:51.026]                       }
[08:27:51.026]                       invisible(muffled)
[08:27:51.026]                     }
[08:27:51.026]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.026]                   }
[08:27:51.026]                 }
[08:27:51.026]                 else {
[08:27:51.026]                   if (TRUE) {
[08:27:51.026]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.026]                     {
[08:27:51.026]                       inherits <- base::inherits
[08:27:51.026]                       invokeRestart <- base::invokeRestart
[08:27:51.026]                       is.null <- base::is.null
[08:27:51.026]                       muffled <- FALSE
[08:27:51.026]                       if (inherits(cond, "message")) {
[08:27:51.026]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.026]                         if (muffled) 
[08:27:51.026]                           invokeRestart("muffleMessage")
[08:27:51.026]                       }
[08:27:51.026]                       else if (inherits(cond, "warning")) {
[08:27:51.026]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.026]                         if (muffled) 
[08:27:51.026]                           invokeRestart("muffleWarning")
[08:27:51.026]                       }
[08:27:51.026]                       else if (inherits(cond, "condition")) {
[08:27:51.026]                         if (!is.null(pattern)) {
[08:27:51.026]                           computeRestarts <- base::computeRestarts
[08:27:51.026]                           grepl <- base::grepl
[08:27:51.026]                           restarts <- computeRestarts(cond)
[08:27:51.026]                           for (restart in restarts) {
[08:27:51.026]                             name <- restart$name
[08:27:51.026]                             if (is.null(name)) 
[08:27:51.026]                               next
[08:27:51.026]                             if (!grepl(pattern, name)) 
[08:27:51.026]                               next
[08:27:51.026]                             invokeRestart(restart)
[08:27:51.026]                             muffled <- TRUE
[08:27:51.026]                             break
[08:27:51.026]                           }
[08:27:51.026]                         }
[08:27:51.026]                       }
[08:27:51.026]                       invisible(muffled)
[08:27:51.026]                     }
[08:27:51.026]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.026]                   }
[08:27:51.026]                 }
[08:27:51.026]             }
[08:27:51.026]         }))
[08:27:51.026]     }, error = function(ex) {
[08:27:51.026]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.026]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.026]                 ...future.rng), started = ...future.startTime, 
[08:27:51.026]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.026]             version = "1.8"), class = "FutureResult")
[08:27:51.026]     }, finally = {
[08:27:51.026]         if (!identical(...future.workdir, getwd())) 
[08:27:51.026]             setwd(...future.workdir)
[08:27:51.026]         {
[08:27:51.026]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.026]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.026]             }
[08:27:51.026]             base::options(...future.oldOptions)
[08:27:51.026]             if (.Platform$OS.type == "windows") {
[08:27:51.026]                 old_names <- names(...future.oldEnvVars)
[08:27:51.026]                 envs <- base::Sys.getenv()
[08:27:51.026]                 names <- names(envs)
[08:27:51.026]                 common <- intersect(names, old_names)
[08:27:51.026]                 added <- setdiff(names, old_names)
[08:27:51.026]                 removed <- setdiff(old_names, names)
[08:27:51.026]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.026]                   envs[common]]
[08:27:51.026]                 NAMES <- toupper(changed)
[08:27:51.026]                 args <- list()
[08:27:51.026]                 for (kk in seq_along(NAMES)) {
[08:27:51.026]                   name <- changed[[kk]]
[08:27:51.026]                   NAME <- NAMES[[kk]]
[08:27:51.026]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.026]                     next
[08:27:51.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.026]                 }
[08:27:51.026]                 NAMES <- toupper(added)
[08:27:51.026]                 for (kk in seq_along(NAMES)) {
[08:27:51.026]                   name <- added[[kk]]
[08:27:51.026]                   NAME <- NAMES[[kk]]
[08:27:51.026]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.026]                     next
[08:27:51.026]                   args[[name]] <- ""
[08:27:51.026]                 }
[08:27:51.026]                 NAMES <- toupper(removed)
[08:27:51.026]                 for (kk in seq_along(NAMES)) {
[08:27:51.026]                   name <- removed[[kk]]
[08:27:51.026]                   NAME <- NAMES[[kk]]
[08:27:51.026]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.026]                     next
[08:27:51.026]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.026]                 }
[08:27:51.026]                 if (length(args) > 0) 
[08:27:51.026]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.026]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.026]             }
[08:27:51.026]             else {
[08:27:51.026]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.026]             }
[08:27:51.026]             {
[08:27:51.026]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.026]                   0L) {
[08:27:51.026]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.026]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.026]                   base::options(opts)
[08:27:51.026]                 }
[08:27:51.026]                 {
[08:27:51.026]                   {
[08:27:51.026]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.026]                     NULL
[08:27:51.026]                   }
[08:27:51.026]                   options(future.plan = NULL)
[08:27:51.026]                   if (is.na(NA_character_)) 
[08:27:51.026]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.026]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.026]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.026]                     .init = FALSE)
[08:27:51.026]                 }
[08:27:51.026]             }
[08:27:51.026]         }
[08:27:51.026]     })
[08:27:51.026]     if (TRUE) {
[08:27:51.026]         base::sink(type = "output", split = FALSE)
[08:27:51.026]         if (TRUE) {
[08:27:51.026]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.026]         }
[08:27:51.026]         else {
[08:27:51.026]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.026]         }
[08:27:51.026]         base::close(...future.stdout)
[08:27:51.026]         ...future.stdout <- NULL
[08:27:51.026]     }
[08:27:51.026]     ...future.result$conditions <- ...future.conditions
[08:27:51.026]     ...future.result$finished <- base::Sys.time()
[08:27:51.026]     ...future.result
[08:27:51.026] }
[08:27:51.029] requestCore(): workers = 2
[08:27:51.032] MulticoreFuture started
[08:27:51.032] - Launch lazy future ... done
[08:27:51.032] run() for ‘MulticoreFuture’ ... done
List of 6
[08:27:51.033] plan(): Setting new future strategy stack:
 $ a: num 1
 [08:27:51.033] List of future strategies:
[08:27:51.033] 1. sequential:
[08:27:51.033]    - args: function (..., envir = parent.$ frame(), workers = "<NULL>")
[08:27:51.033]    - tweaked: FALSE
[08:27:51.033]    - call: NULL
b:[08:27:51.034] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860d04900> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860db0af0> 
 $  : NULL
 $  : NULL
 $  : num 6
[08:27:51.036] plan(): Setting new future strategy stack:
List of 6
 $ a:[08:27:51.037] List of future strategies:
[08:27:51.037] 1. multicore:
[08:27:51.037]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:51.037]    - tweaked: FALSE
[08:27:51.037]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860d04900> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860db0af0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")=[08:27:51.040] plan(): nbrOfWorkers() = 2
 int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:51.044] resolve() on list ...
[08:27:51.044]  recursive: 0
[08:27:51.045]  length: 6
[08:27:51.045]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:51.045] signalConditionsASAP(numeric, pos=1) ...
[08:27:51.045] - nx: 6
[08:27:51.045] - relay: TRUE
[08:27:51.045] - stdout: TRUE
[08:27:51.046] - signal: TRUE
[08:27:51.046] - resignal: FALSE
[08:27:51.046] - force: TRUE
[08:27:51.046] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.046] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.046]  - until=2
[08:27:51.046]  - relaying element #2
[08:27:51.047] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.047] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.047] signalConditionsASAP(NULL, pos=1) ... done
[08:27:51.047]  length: 5 (resolved future 1)
[08:27:51.047] Future #2
[08:27:51.047] result() for MulticoreFuture ...
[08:27:51.048] result() for MulticoreFuture ...
[08:27:51.049] result() for MulticoreFuture ... done
[08:27:51.049] result() for MulticoreFuture ... done
[08:27:51.049] result() for MulticoreFuture ...
[08:27:51.049] result() for MulticoreFuture ... done
[08:27:51.049] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:51.049] - nx: 6
[08:27:51.049] - relay: TRUE
[08:27:51.049] - stdout: TRUE
[08:27:51.050] - signal: TRUE
[08:27:51.050] - resignal: FALSE
[08:27:51.050] - force: TRUE
[08:27:51.050] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.050] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.050]  - until=2
[08:27:51.050]  - relaying element #2
[08:27:51.050] result() for MulticoreFuture ...
[08:27:51.051] result() for MulticoreFuture ... done
[08:27:51.051] result() for MulticoreFuture ...
[08:27:51.051] result() for MulticoreFuture ... done
[08:27:51.051] result() for MulticoreFuture ...
[08:27:51.051] result() for MulticoreFuture ... done
[08:27:51.051] result() for MulticoreFuture ...
[08:27:51.051] result() for MulticoreFuture ... done
[08:27:51.052] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.052] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.052] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:51.052]  length: 4 (resolved future 2)
[08:27:51.052] Future #3
[08:27:51.053] result() for MulticoreFuture ...
[08:27:51.053] result() for MulticoreFuture ...
[08:27:51.053] result() for MulticoreFuture ... done
[08:27:51.053] result() for MulticoreFuture ... done
[08:27:51.054] result() for MulticoreFuture ...
[08:27:51.054] result() for MulticoreFuture ... done
[08:27:51.054] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:51.054] - nx: 6
[08:27:51.054] - relay: TRUE
[08:27:51.054] - stdout: TRUE
[08:27:51.054] - signal: TRUE
[08:27:51.055] - resignal: FALSE
[08:27:51.055] - force: TRUE
[08:27:51.055] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.055] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.055]  - until=3
[08:27:51.055]  - relaying element #3
[08:27:51.055] result() for MulticoreFuture ...
[08:27:51.056] result() for MulticoreFuture ... done
[08:27:51.056] result() for MulticoreFuture ...
[08:27:51.056] result() for MulticoreFuture ... done
[08:27:51.056] result() for MulticoreFuture ...
[08:27:51.056] result() for MulticoreFuture ... done
[08:27:51.056] result() for MulticoreFuture ...
[08:27:51.056] result() for MulticoreFuture ... done
[08:27:51.056] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.057] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.057] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:51.057]  length: 3 (resolved future 3)
[08:27:51.057] signalConditionsASAP(NULL, pos=4) ...
[08:27:51.057] - nx: 6
[08:27:51.057] - relay: TRUE
[08:27:51.057] - stdout: TRUE
[08:27:51.057] - signal: TRUE
[08:27:51.057] - resignal: FALSE
[08:27:51.057] - force: TRUE
[08:27:51.058] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.058] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.058]  - until=5
[08:27:51.058]  - relaying element #5
[08:27:51.058] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:51.058] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.058] signalConditionsASAP(NULL, pos=4) ... done
[08:27:51.058]  length: 2 (resolved future 4)
[08:27:51.058] signalConditionsASAP(NULL, pos=5) ...
[08:27:51.058] - nx: 6
[08:27:51.059] - relay: TRUE
[08:27:51.059] - stdout: TRUE
[08:27:51.059] - signal: TRUE
[08:27:51.059] - resignal: FALSE
[08:27:51.059] - force: TRUE
[08:27:51.059] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:51.059] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.059]  - until=6
[08:27:51.059]  - relaying element #6
[08:27:51.059] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:51.060] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.060] signalConditionsASAP(NULL, pos=5) ... done
[08:27:51.060]  length: 1 (resolved future 5)
[08:27:51.060] signalConditionsASAP(numeric, pos=6) ...
[08:27:51.062] - nx: 6
[08:27:51.062] - relay: TRUE
[08:27:51.063] - stdout: TRUE
[08:27:51.063] - signal: TRUE
[08:27:51.063] - resignal: FALSE
[08:27:51.063] - force: TRUE
[08:27:51.063] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:51.063] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.064]  - until=6
[08:27:51.064] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.064] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.064] signalConditionsASAP(numeric, pos=6) ... done
[08:27:51.064]  length: 0 (resolved future 6)
[08:27:51.064] Relaying remaining futures
[08:27:51.064] signalConditionsASAP(NULL, pos=0) ...
[08:27:51.065] - nx: 6
[08:27:51.065] - relay: TRUE
[08:27:51.065] - stdout: TRUE
[08:27:51.065] - signal: TRUE
[08:27:51.065] - resignal: FALSE
[08:27:51.065] - force: TRUE
[08:27:51.065] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.065] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:51.065] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.065] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.066] signalConditionsASAP(NULL, pos=0) ... done
[08:27:51.066] resolve() on list ... DONE
[08:27:51.066] result() for MulticoreFuture ...
[08:27:51.066] result() for MulticoreFuture ... done
[08:27:51.066] result() for MulticoreFuture ...
[08:27:51.066] result() for MulticoreFuture ... done
[08:27:51.066] result() for MulticoreFuture ...
[08:27:51.066] result() for MulticoreFuture ... done
[08:27:51.067] result() for MulticoreFuture ...
[08:27:51.067] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[08:27:51.070] getGlobalsAndPackages() ...
[08:27:51.071] Searching for globals...
[08:27:51.071] 
[08:27:51.071] Searching for globals ... DONE
[08:27:51.071] - globals: [0] <none>
[08:27:51.071] getGlobalsAndPackages() ... DONE
[08:27:51.072] run() for ‘Future’ ...
[08:27:51.072] - state: ‘created’
[08:27:51.072] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.074] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.074] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:51.074]   - Field: ‘label’
[08:27:51.074]   - Field: ‘local’
[08:27:51.074]   - Field: ‘owner’
[08:27:51.074]   - Field: ‘envir’
[08:27:51.074]   - Field: ‘workers’
[08:27:51.074]   - Field: ‘packages’
[08:27:51.074]   - Field: ‘gc’
[08:27:51.075]   - Field: ‘job’
[08:27:51.075]   - Field: ‘conditions’
[08:27:51.075]   - Field: ‘expr’
[08:27:51.075]   - Field: ‘uuid’
[08:27:51.075]   - Field: ‘seed’
[08:27:51.075]   - Field: ‘version’
[08:27:51.075]   - Field: ‘result’
[08:27:51.075]   - Field: ‘asynchronous’
[08:27:51.075]   - Field: ‘calls’
[08:27:51.075]   - Field: ‘globals’
[08:27:51.075]   - Field: ‘stdout’
[08:27:51.076]   - Field: ‘earlySignal’
[08:27:51.076]   - Field: ‘lazy’
[08:27:51.076]   - Field: ‘state’
[08:27:51.076] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:51.076] - Launch lazy future ...
[08:27:51.076] Packages needed by the future expression (n = 0): <none>
[08:27:51.076] Packages needed by future strategies (n = 0): <none>
[08:27:51.077] {
[08:27:51.077]     {
[08:27:51.077]         {
[08:27:51.077]             ...future.startTime <- base::Sys.time()
[08:27:51.077]             {
[08:27:51.077]                 {
[08:27:51.077]                   {
[08:27:51.077]                     {
[08:27:51.077]                       base::local({
[08:27:51.077]                         has_future <- base::requireNamespace("future", 
[08:27:51.077]                           quietly = TRUE)
[08:27:51.077]                         if (has_future) {
[08:27:51.077]                           ns <- base::getNamespace("future")
[08:27:51.077]                           version <- ns[[".package"]][["version"]]
[08:27:51.077]                           if (is.null(version)) 
[08:27:51.077]                             version <- utils::packageVersion("future")
[08:27:51.077]                         }
[08:27:51.077]                         else {
[08:27:51.077]                           version <- NULL
[08:27:51.077]                         }
[08:27:51.077]                         if (!has_future || version < "1.8.0") {
[08:27:51.077]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.077]                             "", base::R.version$version.string), 
[08:27:51.077]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.077]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.077]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.077]                               "release", "version")], collapse = " "), 
[08:27:51.077]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.077]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.077]                             info)
[08:27:51.077]                           info <- base::paste(info, collapse = "; ")
[08:27:51.077]                           if (!has_future) {
[08:27:51.077]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.077]                               info)
[08:27:51.077]                           }
[08:27:51.077]                           else {
[08:27:51.077]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.077]                               info, version)
[08:27:51.077]                           }
[08:27:51.077]                           base::stop(msg)
[08:27:51.077]                         }
[08:27:51.077]                       })
[08:27:51.077]                     }
[08:27:51.077]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.077]                     base::options(mc.cores = 1L)
[08:27:51.077]                   }
[08:27:51.077]                   ...future.strategy.old <- future::plan("list")
[08:27:51.077]                   options(future.plan = NULL)
[08:27:51.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.077]                 }
[08:27:51.077]                 ...future.workdir <- getwd()
[08:27:51.077]             }
[08:27:51.077]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.077]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.077]         }
[08:27:51.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.077]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.077]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.077]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.077]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.077]             base::names(...future.oldOptions))
[08:27:51.077]     }
[08:27:51.077]     if (FALSE) {
[08:27:51.077]     }
[08:27:51.077]     else {
[08:27:51.077]         if (TRUE) {
[08:27:51.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.077]                 open = "w")
[08:27:51.077]         }
[08:27:51.077]         else {
[08:27:51.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.077]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.077]         }
[08:27:51.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.077]             base::sink(type = "output", split = FALSE)
[08:27:51.077]             base::close(...future.stdout)
[08:27:51.077]         }, add = TRUE)
[08:27:51.077]     }
[08:27:51.077]     ...future.frame <- base::sys.nframe()
[08:27:51.077]     ...future.conditions <- base::list()
[08:27:51.077]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.077]     if (FALSE) {
[08:27:51.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.077]     }
[08:27:51.077]     ...future.result <- base::tryCatch({
[08:27:51.077]         base::withCallingHandlers({
[08:27:51.077]             ...future.value <- base::withVisible(base::local({
[08:27:51.077]                 withCallingHandlers({
[08:27:51.077]                   2
[08:27:51.077]                 }, immediateCondition = function(cond) {
[08:27:51.077]                   save_rds <- function (object, pathname, ...) 
[08:27:51.077]                   {
[08:27:51.077]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:51.077]                     if (file_test("-f", pathname_tmp)) {
[08:27:51.077]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.077]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:51.077]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.077]                         fi_tmp[["mtime"]])
[08:27:51.077]                     }
[08:27:51.077]                     tryCatch({
[08:27:51.077]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:51.077]                     }, error = function(ex) {
[08:27:51.077]                       msg <- conditionMessage(ex)
[08:27:51.077]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.077]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:51.077]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.077]                         fi_tmp[["mtime"]], msg)
[08:27:51.077]                       ex$message <- msg
[08:27:51.077]                       stop(ex)
[08:27:51.077]                     })
[08:27:51.077]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:51.077]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:51.077]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:51.077]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.077]                       fi <- file.info(pathname)
[08:27:51.077]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:51.077]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.077]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:51.077]                         fi[["size"]], fi[["mtime"]])
[08:27:51.077]                       stop(msg)
[08:27:51.077]                     }
[08:27:51.077]                     invisible(pathname)
[08:27:51.077]                   }
[08:27:51.077]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:51.077]                     rootPath = tempdir()) 
[08:27:51.077]                   {
[08:27:51.077]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:51.077]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:51.077]                       tmpdir = path, fileext = ".rds")
[08:27:51.077]                     save_rds(obj, file)
[08:27:51.077]                   }
[08:27:51.077]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:51.077]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.077]                   {
[08:27:51.077]                     inherits <- base::inherits
[08:27:51.077]                     invokeRestart <- base::invokeRestart
[08:27:51.077]                     is.null <- base::is.null
[08:27:51.077]                     muffled <- FALSE
[08:27:51.077]                     if (inherits(cond, "message")) {
[08:27:51.077]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.077]                       if (muffled) 
[08:27:51.077]                         invokeRestart("muffleMessage")
[08:27:51.077]                     }
[08:27:51.077]                     else if (inherits(cond, "warning")) {
[08:27:51.077]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.077]                       if (muffled) 
[08:27:51.077]                         invokeRestart("muffleWarning")
[08:27:51.077]                     }
[08:27:51.077]                     else if (inherits(cond, "condition")) {
[08:27:51.077]                       if (!is.null(pattern)) {
[08:27:51.077]                         computeRestarts <- base::computeRestarts
[08:27:51.077]                         grepl <- base::grepl
[08:27:51.077]                         restarts <- computeRestarts(cond)
[08:27:51.077]                         for (restart in restarts) {
[08:27:51.077]                           name <- restart$name
[08:27:51.077]                           if (is.null(name)) 
[08:27:51.077]                             next
[08:27:51.077]                           if (!grepl(pattern, name)) 
[08:27:51.077]                             next
[08:27:51.077]                           invokeRestart(restart)
[08:27:51.077]                           muffled <- TRUE
[08:27:51.077]                           break
[08:27:51.077]                         }
[08:27:51.077]                       }
[08:27:51.077]                     }
[08:27:51.077]                     invisible(muffled)
[08:27:51.077]                   }
[08:27:51.077]                   muffleCondition(cond)
[08:27:51.077]                 })
[08:27:51.077]             }))
[08:27:51.077]             future::FutureResult(value = ...future.value$value, 
[08:27:51.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.077]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.077]                     ...future.globalenv.names))
[08:27:51.077]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.077]         }, condition = base::local({
[08:27:51.077]             c <- base::c
[08:27:51.077]             inherits <- base::inherits
[08:27:51.077]             invokeRestart <- base::invokeRestart
[08:27:51.077]             length <- base::length
[08:27:51.077]             list <- base::list
[08:27:51.077]             seq.int <- base::seq.int
[08:27:51.077]             signalCondition <- base::signalCondition
[08:27:51.077]             sys.calls <- base::sys.calls
[08:27:51.077]             `[[` <- base::`[[`
[08:27:51.077]             `+` <- base::`+`
[08:27:51.077]             `<<-` <- base::`<<-`
[08:27:51.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.077]                   3L)]
[08:27:51.077]             }
[08:27:51.077]             function(cond) {
[08:27:51.077]                 is_error <- inherits(cond, "error")
[08:27:51.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.077]                   NULL)
[08:27:51.077]                 if (is_error) {
[08:27:51.077]                   sessionInformation <- function() {
[08:27:51.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.077]                       search = base::search(), system = base::Sys.info())
[08:27:51.077]                   }
[08:27:51.077]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.077]                     cond$call), session = sessionInformation(), 
[08:27:51.077]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.077]                   signalCondition(cond)
[08:27:51.077]                 }
[08:27:51.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.077]                 "immediateCondition"))) {
[08:27:51.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.077]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.077]                   if (TRUE && !signal) {
[08:27:51.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.077]                     {
[08:27:51.077]                       inherits <- base::inherits
[08:27:51.077]                       invokeRestart <- base::invokeRestart
[08:27:51.077]                       is.null <- base::is.null
[08:27:51.077]                       muffled <- FALSE
[08:27:51.077]                       if (inherits(cond, "message")) {
[08:27:51.077]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.077]                         if (muffled) 
[08:27:51.077]                           invokeRestart("muffleMessage")
[08:27:51.077]                       }
[08:27:51.077]                       else if (inherits(cond, "warning")) {
[08:27:51.077]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.077]                         if (muffled) 
[08:27:51.077]                           invokeRestart("muffleWarning")
[08:27:51.077]                       }
[08:27:51.077]                       else if (inherits(cond, "condition")) {
[08:27:51.077]                         if (!is.null(pattern)) {
[08:27:51.077]                           computeRestarts <- base::computeRestarts
[08:27:51.077]                           grepl <- base::grepl
[08:27:51.077]                           restarts <- computeRestarts(cond)
[08:27:51.077]                           for (restart in restarts) {
[08:27:51.077]                             name <- restart$name
[08:27:51.077]                             if (is.null(name)) 
[08:27:51.077]                               next
[08:27:51.077]                             if (!grepl(pattern, name)) 
[08:27:51.077]                               next
[08:27:51.077]                             invokeRestart(restart)
[08:27:51.077]                             muffled <- TRUE
[08:27:51.077]                             break
[08:27:51.077]                           }
[08:27:51.077]                         }
[08:27:51.077]                       }
[08:27:51.077]                       invisible(muffled)
[08:27:51.077]                     }
[08:27:51.077]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.077]                   }
[08:27:51.077]                 }
[08:27:51.077]                 else {
[08:27:51.077]                   if (TRUE) {
[08:27:51.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.077]                     {
[08:27:51.077]                       inherits <- base::inherits
[08:27:51.077]                       invokeRestart <- base::invokeRestart
[08:27:51.077]                       is.null <- base::is.null
[08:27:51.077]                       muffled <- FALSE
[08:27:51.077]                       if (inherits(cond, "message")) {
[08:27:51.077]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.077]                         if (muffled) 
[08:27:51.077]                           invokeRestart("muffleMessage")
[08:27:51.077]                       }
[08:27:51.077]                       else if (inherits(cond, "warning")) {
[08:27:51.077]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.077]                         if (muffled) 
[08:27:51.077]                           invokeRestart("muffleWarning")
[08:27:51.077]                       }
[08:27:51.077]                       else if (inherits(cond, "condition")) {
[08:27:51.077]                         if (!is.null(pattern)) {
[08:27:51.077]                           computeRestarts <- base::computeRestarts
[08:27:51.077]                           grepl <- base::grepl
[08:27:51.077]                           restarts <- computeRestarts(cond)
[08:27:51.077]                           for (restart in restarts) {
[08:27:51.077]                             name <- restart$name
[08:27:51.077]                             if (is.null(name)) 
[08:27:51.077]                               next
[08:27:51.077]                             if (!grepl(pattern, name)) 
[08:27:51.077]                               next
[08:27:51.077]                             invokeRestart(restart)
[08:27:51.077]                             muffled <- TRUE
[08:27:51.077]                             break
[08:27:51.077]                           }
[08:27:51.077]                         }
[08:27:51.077]                       }
[08:27:51.077]                       invisible(muffled)
[08:27:51.077]                     }
[08:27:51.077]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.077]                   }
[08:27:51.077]                 }
[08:27:51.077]             }
[08:27:51.077]         }))
[08:27:51.077]     }, error = function(ex) {
[08:27:51.077]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.077]                 ...future.rng), started = ...future.startTime, 
[08:27:51.077]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.077]             version = "1.8"), class = "FutureResult")
[08:27:51.077]     }, finally = {
[08:27:51.077]         if (!identical(...future.workdir, getwd())) 
[08:27:51.077]             setwd(...future.workdir)
[08:27:51.077]         {
[08:27:51.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.077]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.077]             }
[08:27:51.077]             base::options(...future.oldOptions)
[08:27:51.077]             if (.Platform$OS.type == "windows") {
[08:27:51.077]                 old_names <- names(...future.oldEnvVars)
[08:27:51.077]                 envs <- base::Sys.getenv()
[08:27:51.077]                 names <- names(envs)
[08:27:51.077]                 common <- intersect(names, old_names)
[08:27:51.077]                 added <- setdiff(names, old_names)
[08:27:51.077]                 removed <- setdiff(old_names, names)
[08:27:51.077]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.077]                   envs[common]]
[08:27:51.077]                 NAMES <- toupper(changed)
[08:27:51.077]                 args <- list()
[08:27:51.077]                 for (kk in seq_along(NAMES)) {
[08:27:51.077]                   name <- changed[[kk]]
[08:27:51.077]                   NAME <- NAMES[[kk]]
[08:27:51.077]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.077]                     next
[08:27:51.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.077]                 }
[08:27:51.077]                 NAMES <- toupper(added)
[08:27:51.077]                 for (kk in seq_along(NAMES)) {
[08:27:51.077]                   name <- added[[kk]]
[08:27:51.077]                   NAME <- NAMES[[kk]]
[08:27:51.077]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.077]                     next
[08:27:51.077]                   args[[name]] <- ""
[08:27:51.077]                 }
[08:27:51.077]                 NAMES <- toupper(removed)
[08:27:51.077]                 for (kk in seq_along(NAMES)) {
[08:27:51.077]                   name <- removed[[kk]]
[08:27:51.077]                   NAME <- NAMES[[kk]]
[08:27:51.077]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.077]                     next
[08:27:51.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.077]                 }
[08:27:51.077]                 if (length(args) > 0) 
[08:27:51.077]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.077]             }
[08:27:51.077]             else {
[08:27:51.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.077]             }
[08:27:51.077]             {
[08:27:51.077]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.077]                   0L) {
[08:27:51.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.077]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.077]                   base::options(opts)
[08:27:51.077]                 }
[08:27:51.077]                 {
[08:27:51.077]                   {
[08:27:51.077]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.077]                     NULL
[08:27:51.077]                   }
[08:27:51.077]                   options(future.plan = NULL)
[08:27:51.077]                   if (is.na(NA_character_)) 
[08:27:51.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.077]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.077]                     .init = FALSE)
[08:27:51.077]                 }
[08:27:51.077]             }
[08:27:51.077]         }
[08:27:51.077]     })
[08:27:51.077]     if (TRUE) {
[08:27:51.077]         base::sink(type = "output", split = FALSE)
[08:27:51.077]         if (TRUE) {
[08:27:51.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.077]         }
[08:27:51.077]         else {
[08:27:51.077]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.077]         }
[08:27:51.077]         base::close(...future.stdout)
[08:27:51.077]         ...future.stdout <- NULL
[08:27:51.077]     }
[08:27:51.077]     ...future.result$conditions <- ...future.conditions
[08:27:51.077]     ...future.result$finished <- base::Sys.time()
[08:27:51.077]     ...future.result
[08:27:51.077] }
[08:27:51.079] requestCore(): workers = 2
[08:27:51.081] MulticoreFuture started
[08:27:51.082] - Launch lazy future ... done
[08:27:51.082] run() for ‘MulticoreFuture’ ... done
[08:27:51.082] getGlobalsAndPackages() ...
[08:27:51.083] Searching for globals...
[08:27:51.083] plan(): Setting new future strategy stack:
[08:27:51.084] 
[08:27:51.084] Searching for globals ... DONE
[08:27:51.083] List of future strategies:
[08:27:51.083] 1. sequential:
[08:27:51.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:51.083]    - tweaked: FALSE
[08:27:51.083]    - call: NULL
[08:27:51.084] - globals: [0] <none>
[08:27:51.084] plan(): nbrOfWorkers() = 1
[08:27:51.084] getGlobalsAndPackages() ... DONE
[08:27:51.085] run() for ‘Future’ ...
[08:27:51.085] - state: ‘created’
[08:27:51.085] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.086] plan(): Setting new future strategy stack:
[08:27:51.086] List of future strategies:
[08:27:51.086] 1. multicore:
[08:27:51.086]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:51.086]    - tweaked: FALSE
[08:27:51.086]    - call: plan(strategy)
[08:27:51.088] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.089] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:51.089] plan(): nbrOfWorkers() = 2
[08:27:51.089]   - Field: ‘label’
[08:27:51.089]   - Field: ‘local’
[08:27:51.089]   - Field: ‘owner’
[08:27:51.089]   - Field: ‘envir’
[08:27:51.089]   - Field: ‘workers’
[08:27:51.089]   - Field: ‘packages’
[08:27:51.090]   - Field: ‘gc’
[08:27:51.090]   - Field: ‘job’
[08:27:51.090]   - Field: ‘conditions’
[08:27:51.090]   - Field: ‘expr’
[08:27:51.090]   - Field: ‘uuid’
[08:27:51.090]   - Field: ‘seed’
[08:27:51.090]   - Field: ‘version’
[08:27:51.091]   - Field: ‘result’
[08:27:51.091]   - Field: ‘asynchronous’
[08:27:51.091]   - Field: ‘calls’
[08:27:51.091]   - Field: ‘globals’
[08:27:51.091]   - Field: ‘stdout’
[08:27:51.092]   - Field: ‘earlySignal’
[08:27:51.092]   - Field: ‘lazy’
[08:27:51.092]   - Field: ‘state’
[08:27:51.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:51.092] - Launch lazy future ...
[08:27:51.093] Packages needed by the future expression (n = 0): <none>
[08:27:51.093] Packages needed by future strategies (n = 0): <none>
[08:27:51.094] {
[08:27:51.094]     {
[08:27:51.094]         {
[08:27:51.094]             ...future.startTime <- base::Sys.time()
[08:27:51.094]             {
[08:27:51.094]                 {
[08:27:51.094]                   {
[08:27:51.094]                     {
[08:27:51.094]                       base::local({
[08:27:51.094]                         has_future <- base::requireNamespace("future", 
[08:27:51.094]                           quietly = TRUE)
[08:27:51.094]                         if (has_future) {
[08:27:51.094]                           ns <- base::getNamespace("future")
[08:27:51.094]                           version <- ns[[".package"]][["version"]]
[08:27:51.094]                           if (is.null(version)) 
[08:27:51.094]                             version <- utils::packageVersion("future")
[08:27:51.094]                         }
[08:27:51.094]                         else {
[08:27:51.094]                           version <- NULL
[08:27:51.094]                         }
[08:27:51.094]                         if (!has_future || version < "1.8.0") {
[08:27:51.094]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.094]                             "", base::R.version$version.string), 
[08:27:51.094]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.094]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.094]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.094]                               "release", "version")], collapse = " "), 
[08:27:51.094]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.094]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.094]                             info)
[08:27:51.094]                           info <- base::paste(info, collapse = "; ")
[08:27:51.094]                           if (!has_future) {
[08:27:51.094]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.094]                               info)
[08:27:51.094]                           }
[08:27:51.094]                           else {
[08:27:51.094]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.094]                               info, version)
[08:27:51.094]                           }
[08:27:51.094]                           base::stop(msg)
[08:27:51.094]                         }
[08:27:51.094]                       })
[08:27:51.094]                     }
[08:27:51.094]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.094]                     base::options(mc.cores = 1L)
[08:27:51.094]                   }
[08:27:51.094]                   ...future.strategy.old <- future::plan("list")
[08:27:51.094]                   options(future.plan = NULL)
[08:27:51.094]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.094]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.094]                 }
[08:27:51.094]                 ...future.workdir <- getwd()
[08:27:51.094]             }
[08:27:51.094]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.094]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.094]         }
[08:27:51.094]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.094]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.094]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.094]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.094]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.094]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.094]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.094]             base::names(...future.oldOptions))
[08:27:51.094]     }
[08:27:51.094]     if (FALSE) {
[08:27:51.094]     }
[08:27:51.094]     else {
[08:27:51.094]         if (TRUE) {
[08:27:51.094]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.094]                 open = "w")
[08:27:51.094]         }
[08:27:51.094]         else {
[08:27:51.094]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.094]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.094]         }
[08:27:51.094]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.094]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.094]             base::sink(type = "output", split = FALSE)
[08:27:51.094]             base::close(...future.stdout)
[08:27:51.094]         }, add = TRUE)
[08:27:51.094]     }
[08:27:51.094]     ...future.frame <- base::sys.nframe()
[08:27:51.094]     ...future.conditions <- base::list()
[08:27:51.094]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.094]     if (FALSE) {
[08:27:51.094]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.094]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.094]     }
[08:27:51.094]     ...future.result <- base::tryCatch({
[08:27:51.094]         base::withCallingHandlers({
[08:27:51.094]             ...future.value <- base::withVisible(base::local({
[08:27:51.094]                 withCallingHandlers({
[08:27:51.094]                   NULL
[08:27:51.094]                 }, immediateCondition = function(cond) {
[08:27:51.094]                   save_rds <- function (object, pathname, ...) 
[08:27:51.094]                   {
[08:27:51.094]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:51.094]                     if (file_test("-f", pathname_tmp)) {
[08:27:51.094]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.094]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:51.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.094]                         fi_tmp[["mtime"]])
[08:27:51.094]                     }
[08:27:51.094]                     tryCatch({
[08:27:51.094]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:51.094]                     }, error = function(ex) {
[08:27:51.094]                       msg <- conditionMessage(ex)
[08:27:51.094]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.094]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:51.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.094]                         fi_tmp[["mtime"]], msg)
[08:27:51.094]                       ex$message <- msg
[08:27:51.094]                       stop(ex)
[08:27:51.094]                     })
[08:27:51.094]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:51.094]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:51.094]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:51.094]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.094]                       fi <- file.info(pathname)
[08:27:51.094]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:51.094]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.094]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:51.094]                         fi[["size"]], fi[["mtime"]])
[08:27:51.094]                       stop(msg)
[08:27:51.094]                     }
[08:27:51.094]                     invisible(pathname)
[08:27:51.094]                   }
[08:27:51.094]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:51.094]                     rootPath = tempdir()) 
[08:27:51.094]                   {
[08:27:51.094]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:51.094]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:51.094]                       tmpdir = path, fileext = ".rds")
[08:27:51.094]                     save_rds(obj, file)
[08:27:51.094]                   }
[08:27:51.094]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:51.094]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.094]                   {
[08:27:51.094]                     inherits <- base::inherits
[08:27:51.094]                     invokeRestart <- base::invokeRestart
[08:27:51.094]                     is.null <- base::is.null
[08:27:51.094]                     muffled <- FALSE
[08:27:51.094]                     if (inherits(cond, "message")) {
[08:27:51.094]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.094]                       if (muffled) 
[08:27:51.094]                         invokeRestart("muffleMessage")
[08:27:51.094]                     }
[08:27:51.094]                     else if (inherits(cond, "warning")) {
[08:27:51.094]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.094]                       if (muffled) 
[08:27:51.094]                         invokeRestart("muffleWarning")
[08:27:51.094]                     }
[08:27:51.094]                     else if (inherits(cond, "condition")) {
[08:27:51.094]                       if (!is.null(pattern)) {
[08:27:51.094]                         computeRestarts <- base::computeRestarts
[08:27:51.094]                         grepl <- base::grepl
[08:27:51.094]                         restarts <- computeRestarts(cond)
[08:27:51.094]                         for (restart in restarts) {
[08:27:51.094]                           name <- restart$name
[08:27:51.094]                           if (is.null(name)) 
[08:27:51.094]                             next
[08:27:51.094]                           if (!grepl(pattern, name)) 
[08:27:51.094]                             next
[08:27:51.094]                           invokeRestart(restart)
[08:27:51.094]                           muffled <- TRUE
[08:27:51.094]                           break
[08:27:51.094]                         }
[08:27:51.094]                       }
[08:27:51.094]                     }
[08:27:51.094]                     invisible(muffled)
[08:27:51.094]                   }
[08:27:51.094]                   muffleCondition(cond)
[08:27:51.094]                 })
[08:27:51.094]             }))
[08:27:51.094]             future::FutureResult(value = ...future.value$value, 
[08:27:51.094]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.094]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.094]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.094]                     ...future.globalenv.names))
[08:27:51.094]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.094]         }, condition = base::local({
[08:27:51.094]             c <- base::c
[08:27:51.094]             inherits <- base::inherits
[08:27:51.094]             invokeRestart <- base::invokeRestart
[08:27:51.094]             length <- base::length
[08:27:51.094]             list <- base::list
[08:27:51.094]             seq.int <- base::seq.int
[08:27:51.094]             signalCondition <- base::signalCondition
[08:27:51.094]             sys.calls <- base::sys.calls
[08:27:51.094]             `[[` <- base::`[[`
[08:27:51.094]             `+` <- base::`+`
[08:27:51.094]             `<<-` <- base::`<<-`
[08:27:51.094]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.094]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.094]                   3L)]
[08:27:51.094]             }
[08:27:51.094]             function(cond) {
[08:27:51.094]                 is_error <- inherits(cond, "error")
[08:27:51.094]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.094]                   NULL)
[08:27:51.094]                 if (is_error) {
[08:27:51.094]                   sessionInformation <- function() {
[08:27:51.094]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.094]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.094]                       search = base::search(), system = base::Sys.info())
[08:27:51.094]                   }
[08:27:51.094]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.094]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.094]                     cond$call), session = sessionInformation(), 
[08:27:51.094]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.094]                   signalCondition(cond)
[08:27:51.094]                 }
[08:27:51.094]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.094]                 "immediateCondition"))) {
[08:27:51.094]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.094]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.094]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.094]                   if (TRUE && !signal) {
[08:27:51.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.094]                     {
[08:27:51.094]                       inherits <- base::inherits
[08:27:51.094]                       invokeRestart <- base::invokeRestart
[08:27:51.094]                       is.null <- base::is.null
[08:27:51.094]                       muffled <- FALSE
[08:27:51.094]                       if (inherits(cond, "message")) {
[08:27:51.094]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.094]                         if (muffled) 
[08:27:51.094]                           invokeRestart("muffleMessage")
[08:27:51.094]                       }
[08:27:51.094]                       else if (inherits(cond, "warning")) {
[08:27:51.094]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.094]                         if (muffled) 
[08:27:51.094]                           invokeRestart("muffleWarning")
[08:27:51.094]                       }
[08:27:51.094]                       else if (inherits(cond, "condition")) {
[08:27:51.094]                         if (!is.null(pattern)) {
[08:27:51.094]                           computeRestarts <- base::computeRestarts
[08:27:51.094]                           grepl <- base::grepl
[08:27:51.094]                           restarts <- computeRestarts(cond)
[08:27:51.094]                           for (restart in restarts) {
[08:27:51.094]                             name <- restart$name
[08:27:51.094]                             if (is.null(name)) 
[08:27:51.094]                               next
[08:27:51.094]                             if (!grepl(pattern, name)) 
[08:27:51.094]                               next
[08:27:51.094]                             invokeRestart(restart)
[08:27:51.094]                             muffled <- TRUE
[08:27:51.094]                             break
[08:27:51.094]                           }
[08:27:51.094]                         }
[08:27:51.094]                       }
[08:27:51.094]                       invisible(muffled)
[08:27:51.094]                     }
[08:27:51.094]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.094]                   }
[08:27:51.094]                 }
[08:27:51.094]                 else {
[08:27:51.094]                   if (TRUE) {
[08:27:51.094]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.094]                     {
[08:27:51.094]                       inherits <- base::inherits
[08:27:51.094]                       invokeRestart <- base::invokeRestart
[08:27:51.094]                       is.null <- base::is.null
[08:27:51.094]                       muffled <- FALSE
[08:27:51.094]                       if (inherits(cond, "message")) {
[08:27:51.094]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.094]                         if (muffled) 
[08:27:51.094]                           invokeRestart("muffleMessage")
[08:27:51.094]                       }
[08:27:51.094]                       else if (inherits(cond, "warning")) {
[08:27:51.094]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.094]                         if (muffled) 
[08:27:51.094]                           invokeRestart("muffleWarning")
[08:27:51.094]                       }
[08:27:51.094]                       else if (inherits(cond, "condition")) {
[08:27:51.094]                         if (!is.null(pattern)) {
[08:27:51.094]                           computeRestarts <- base::computeRestarts
[08:27:51.094]                           grepl <- base::grepl
[08:27:51.094]                           restarts <- computeRestarts(cond)
[08:27:51.094]                           for (restart in restarts) {
[08:27:51.094]                             name <- restart$name
[08:27:51.094]                             if (is.null(name)) 
[08:27:51.094]                               next
[08:27:51.094]                             if (!grepl(pattern, name)) 
[08:27:51.094]                               next
[08:27:51.094]                             invokeRestart(restart)
[08:27:51.094]                             muffled <- TRUE
[08:27:51.094]                             break
[08:27:51.094]                           }
[08:27:51.094]                         }
[08:27:51.094]                       }
[08:27:51.094]                       invisible(muffled)
[08:27:51.094]                     }
[08:27:51.094]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.094]                   }
[08:27:51.094]                 }
[08:27:51.094]             }
[08:27:51.094]         }))
[08:27:51.094]     }, error = function(ex) {
[08:27:51.094]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.094]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.094]                 ...future.rng), started = ...future.startTime, 
[08:27:51.094]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.094]             version = "1.8"), class = "FutureResult")
[08:27:51.094]     }, finally = {
[08:27:51.094]         if (!identical(...future.workdir, getwd())) 
[08:27:51.094]             setwd(...future.workdir)
[08:27:51.094]         {
[08:27:51.094]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.094]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.094]             }
[08:27:51.094]             base::options(...future.oldOptions)
[08:27:51.094]             if (.Platform$OS.type == "windows") {
[08:27:51.094]                 old_names <- names(...future.oldEnvVars)
[08:27:51.094]                 envs <- base::Sys.getenv()
[08:27:51.094]                 names <- names(envs)
[08:27:51.094]                 common <- intersect(names, old_names)
[08:27:51.094]                 added <- setdiff(names, old_names)
[08:27:51.094]                 removed <- setdiff(old_names, names)
[08:27:51.094]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.094]                   envs[common]]
[08:27:51.094]                 NAMES <- toupper(changed)
[08:27:51.094]                 args <- list()
[08:27:51.094]                 for (kk in seq_along(NAMES)) {
[08:27:51.094]                   name <- changed[[kk]]
[08:27:51.094]                   NAME <- NAMES[[kk]]
[08:27:51.094]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.094]                     next
[08:27:51.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.094]                 }
[08:27:51.094]                 NAMES <- toupper(added)
[08:27:51.094]                 for (kk in seq_along(NAMES)) {
[08:27:51.094]                   name <- added[[kk]]
[08:27:51.094]                   NAME <- NAMES[[kk]]
[08:27:51.094]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.094]                     next
[08:27:51.094]                   args[[name]] <- ""
[08:27:51.094]                 }
[08:27:51.094]                 NAMES <- toupper(removed)
[08:27:51.094]                 for (kk in seq_along(NAMES)) {
[08:27:51.094]                   name <- removed[[kk]]
[08:27:51.094]                   NAME <- NAMES[[kk]]
[08:27:51.094]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.094]                     next
[08:27:51.094]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.094]                 }
[08:27:51.094]                 if (length(args) > 0) 
[08:27:51.094]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.094]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.094]             }
[08:27:51.094]             else {
[08:27:51.094]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.094]             }
[08:27:51.094]             {
[08:27:51.094]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.094]                   0L) {
[08:27:51.094]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.094]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.094]                   base::options(opts)
[08:27:51.094]                 }
[08:27:51.094]                 {
[08:27:51.094]                   {
[08:27:51.094]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.094]                     NULL
[08:27:51.094]                   }
[08:27:51.094]                   options(future.plan = NULL)
[08:27:51.094]                   if (is.na(NA_character_)) 
[08:27:51.094]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.094]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.094]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.094]                     .init = FALSE)
[08:27:51.094]                 }
[08:27:51.094]             }
[08:27:51.094]         }
[08:27:51.094]     })
[08:27:51.094]     if (TRUE) {
[08:27:51.094]         base::sink(type = "output", split = FALSE)
[08:27:51.094]         if (TRUE) {
[08:27:51.094]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.094]         }
[08:27:51.094]         else {
[08:27:51.094]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.094]         }
[08:27:51.094]         base::close(...future.stdout)
[08:27:51.094]         ...future.stdout <- NULL
[08:27:51.094]     }
[08:27:51.094]     ...future.result$conditions <- ...future.conditions
[08:27:51.094]     ...future.result$finished <- base::Sys.time()
[08:27:51.094]     ...future.result
[08:27:51.094] }
[08:27:51.097] requestCore(): workers = 2
[08:27:51.100] MulticoreFuture started
[08:27:51.100] - Launch lazy future ... done
[08:27:51.100] run() for ‘MulticoreFuture’ ... done
List of 6
[08:27:51.101] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[08:27:51.101] List of future strategies:
[08:27:51.101] 1. sequential:
[08:27:51.101]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:51.101]    - tweaked: FALSE
[08:27:51.101]    - call: NULL
[08:27:51.102] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d85ed62568> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860a521b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a:[08:27:51.104] plan(): Setting new future strategy stack:
[08:27:51.105] List of future strategies:
[08:27:51.105] 1. multicore:
[08:27:51.105]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:51.105]    - tweaked: FALSE
[08:27:51.105]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d85ed62568> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860a521b0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=[08:27:51.108] plan(): nbrOfWorkers() = 2
List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:51.120] resolve() on list ...
[08:27:51.120]  recursive: 0
[08:27:51.120]  length: 6
[08:27:51.121]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:51.121] signalConditionsASAP(numeric, pos=1) ...
[08:27:51.121] - nx: 6
[08:27:51.121] - relay: TRUE
[08:27:51.121] - stdout: TRUE
[08:27:51.121] - signal: TRUE
[08:27:51.122] - resignal: FALSE
[08:27:51.122] - force: TRUE
[08:27:51.122] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.122] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.122]  - until=2
[08:27:51.122]  - relaying element #2
[08:27:51.122] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.122] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.123] signalConditionsASAP(NULL, pos=1) ... done
[08:27:51.123]  length: 5 (resolved future 1)
[08:27:51.123] Future #2
[08:27:51.124] result() for MulticoreFuture ...
[08:27:51.124] result() for MulticoreFuture ...
[08:27:51.125] result() for MulticoreFuture ... done
[08:27:51.125] result() for MulticoreFuture ... done
[08:27:51.125] result() for MulticoreFuture ...
[08:27:51.125] result() for MulticoreFuture ... done
[08:27:51.125] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:51.125] - nx: 6
[08:27:51.125] - relay: TRUE
[08:27:51.126] - stdout: TRUE
[08:27:51.126] - signal: TRUE
[08:27:51.126] - resignal: FALSE
[08:27:51.126] - force: TRUE
[08:27:51.126] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.126] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.126]  - until=2
[08:27:51.126]  - relaying element #2
[08:27:51.127] result() for MulticoreFuture ...
[08:27:51.127] result() for MulticoreFuture ... done
[08:27:51.127] result() for MulticoreFuture ...
[08:27:51.127] result() for MulticoreFuture ... done
[08:27:51.127] result() for MulticoreFuture ...
[08:27:51.127] result() for MulticoreFuture ... done
[08:27:51.127] result() for MulticoreFuture ...
[08:27:51.128] result() for MulticoreFuture ... done
[08:27:51.128] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.128] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.128] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:51.128]  length: 4 (resolved future 2)
[08:27:51.128] Future #3
[08:27:51.129] result() for MulticoreFuture ...
[08:27:51.129] result() for MulticoreFuture ...
[08:27:51.129] result() for MulticoreFuture ... done
[08:27:51.129] result() for MulticoreFuture ... done
[08:27:51.130] result() for MulticoreFuture ...
[08:27:51.130] result() for MulticoreFuture ... done
[08:27:51.130] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:51.130] - nx: 6
[08:27:51.130] - relay: TRUE
[08:27:51.130] - stdout: TRUE
[08:27:51.130] - signal: TRUE
[08:27:51.130] - resignal: FALSE
[08:27:51.130] - force: TRUE
[08:27:51.131] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.131] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.131]  - until=3
[08:27:51.131]  - relaying element #3
[08:27:51.131] result() for MulticoreFuture ...
[08:27:51.131] result() for MulticoreFuture ... done
[08:27:51.131] result() for MulticoreFuture ...
[08:27:51.132] result() for MulticoreFuture ... done
[08:27:51.132] result() for MulticoreFuture ...
[08:27:51.132] result() for MulticoreFuture ... done
[08:27:51.132] result() for MulticoreFuture ...
[08:27:51.132] result() for MulticoreFuture ... done
[08:27:51.132] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.132] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.132] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:51.132]  length: 3 (resolved future 3)
[08:27:51.133] signalConditionsASAP(NULL, pos=4) ...
[08:27:51.133] - nx: 6
[08:27:51.133] - relay: TRUE
[08:27:51.133] - stdout: TRUE
[08:27:51.133] - signal: TRUE
[08:27:51.133] - resignal: FALSE
[08:27:51.133] - force: TRUE
[08:27:51.133] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.133] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.133]  - until=5
[08:27:51.133]  - relaying element #5
[08:27:51.134] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:51.134] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.134] signalConditionsASAP(NULL, pos=4) ... done
[08:27:51.134]  length: 2 (resolved future 4)
[08:27:51.134] signalConditionsASAP(NULL, pos=5) ...
[08:27:51.134] - nx: 6
[08:27:51.134] - relay: TRUE
[08:27:51.134] - stdout: TRUE
[08:27:51.134] - signal: TRUE
[08:27:51.134] - resignal: FALSE
[08:27:51.134] - force: TRUE
[08:27:51.135] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:51.135] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.135]  - until=6
[08:27:51.135]  - relaying element #6
[08:27:51.135] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:51.135] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.135] signalConditionsASAP(NULL, pos=5) ... done
[08:27:51.135]  length: 1 (resolved future 5)
[08:27:51.135] signalConditionsASAP(numeric, pos=6) ...
[08:27:51.135] - nx: 6
[08:27:51.136] - relay: TRUE
[08:27:51.136] - stdout: TRUE
[08:27:51.136] - signal: TRUE
[08:27:51.136] - resignal: FALSE
[08:27:51.136] - force: TRUE
[08:27:51.136] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:51.136] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.136]  - until=6
[08:27:51.136] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.136] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.136] signalConditionsASAP(numeric, pos=6) ... done
[08:27:51.137]  length: 0 (resolved future 6)
[08:27:51.137] Relaying remaining futures
[08:27:51.137] signalConditionsASAP(NULL, pos=0) ...
[08:27:51.137] - nx: 6
[08:27:51.137] - relay: TRUE
[08:27:51.137] - stdout: TRUE
[08:27:51.137] - signal: TRUE
[08:27:51.137] - resignal: FALSE
[08:27:51.137] - force: TRUE
[08:27:51.137] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.137] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:51.138] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.138] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.138] signalConditionsASAP(NULL, pos=0) ... done
[08:27:51.138] resolve() on list ... DONE
[08:27:51.138] result() for MulticoreFuture ...
[08:27:51.138] result() for MulticoreFuture ... done
[08:27:51.138] result() for MulticoreFuture ...
[08:27:51.138] result() for MulticoreFuture ... done
[08:27:51.138] result() for MulticoreFuture ...
[08:27:51.138] result() for MulticoreFuture ... done
[08:27:51.139] result() for MulticoreFuture ...
[08:27:51.139] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[08:27:51.142] getGlobalsAndPackages() ...
[08:27:51.142] Searching for globals...
[08:27:51.143] 
[08:27:51.143] Searching for globals ... DONE
[08:27:51.143] - globals: [0] <none>
[08:27:51.143] getGlobalsAndPackages() ... DONE
[08:27:51.143] run() for ‘Future’ ...
[08:27:51.144] - state: ‘created’
[08:27:51.144] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.146] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:51.148]   - Field: ‘label’
[08:27:51.148]   - Field: ‘local’
[08:27:51.148]   - Field: ‘owner’
[08:27:51.148]   - Field: ‘envir’
[08:27:51.148]   - Field: ‘workers’
[08:27:51.148]   - Field: ‘packages’
[08:27:51.148]   - Field: ‘gc’
[08:27:51.149]   - Field: ‘job’
[08:27:51.149]   - Field: ‘conditions’
[08:27:51.149]   - Field: ‘expr’
[08:27:51.149]   - Field: ‘uuid’
[08:27:51.149]   - Field: ‘seed’
[08:27:51.149]   - Field: ‘version’
[08:27:51.149]   - Field: ‘result’
[08:27:51.149]   - Field: ‘asynchronous’
[08:27:51.150]   - Field: ‘calls’
[08:27:51.150]   - Field: ‘globals’
[08:27:51.150]   - Field: ‘stdout’
[08:27:51.150]   - Field: ‘earlySignal’
[08:27:51.150]   - Field: ‘lazy’
[08:27:51.150]   - Field: ‘state’
[08:27:51.150] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:51.150] - Launch lazy future ...
[08:27:51.151] Packages needed by the future expression (n = 0): <none>
[08:27:51.151] Packages needed by future strategies (n = 0): <none>
[08:27:51.151] {
[08:27:51.151]     {
[08:27:51.151]         {
[08:27:51.151]             ...future.startTime <- base::Sys.time()
[08:27:51.151]             {
[08:27:51.151]                 {
[08:27:51.151]                   {
[08:27:51.151]                     {
[08:27:51.151]                       base::local({
[08:27:51.151]                         has_future <- base::requireNamespace("future", 
[08:27:51.151]                           quietly = TRUE)
[08:27:51.151]                         if (has_future) {
[08:27:51.151]                           ns <- base::getNamespace("future")
[08:27:51.151]                           version <- ns[[".package"]][["version"]]
[08:27:51.151]                           if (is.null(version)) 
[08:27:51.151]                             version <- utils::packageVersion("future")
[08:27:51.151]                         }
[08:27:51.151]                         else {
[08:27:51.151]                           version <- NULL
[08:27:51.151]                         }
[08:27:51.151]                         if (!has_future || version < "1.8.0") {
[08:27:51.151]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.151]                             "", base::R.version$version.string), 
[08:27:51.151]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.151]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.151]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.151]                               "release", "version")], collapse = " "), 
[08:27:51.151]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.151]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.151]                             info)
[08:27:51.151]                           info <- base::paste(info, collapse = "; ")
[08:27:51.151]                           if (!has_future) {
[08:27:51.151]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.151]                               info)
[08:27:51.151]                           }
[08:27:51.151]                           else {
[08:27:51.151]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.151]                               info, version)
[08:27:51.151]                           }
[08:27:51.151]                           base::stop(msg)
[08:27:51.151]                         }
[08:27:51.151]                       })
[08:27:51.151]                     }
[08:27:51.151]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.151]                     base::options(mc.cores = 1L)
[08:27:51.151]                   }
[08:27:51.151]                   ...future.strategy.old <- future::plan("list")
[08:27:51.151]                   options(future.plan = NULL)
[08:27:51.151]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.151]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.151]                 }
[08:27:51.151]                 ...future.workdir <- getwd()
[08:27:51.151]             }
[08:27:51.151]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.151]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.151]         }
[08:27:51.151]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.151]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.151]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.151]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.151]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.151]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.151]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.151]             base::names(...future.oldOptions))
[08:27:51.151]     }
[08:27:51.151]     if (FALSE) {
[08:27:51.151]     }
[08:27:51.151]     else {
[08:27:51.151]         if (TRUE) {
[08:27:51.151]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.151]                 open = "w")
[08:27:51.151]         }
[08:27:51.151]         else {
[08:27:51.151]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.151]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.151]         }
[08:27:51.151]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.151]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.151]             base::sink(type = "output", split = FALSE)
[08:27:51.151]             base::close(...future.stdout)
[08:27:51.151]         }, add = TRUE)
[08:27:51.151]     }
[08:27:51.151]     ...future.frame <- base::sys.nframe()
[08:27:51.151]     ...future.conditions <- base::list()
[08:27:51.151]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.151]     if (FALSE) {
[08:27:51.151]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.151]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.151]     }
[08:27:51.151]     ...future.result <- base::tryCatch({
[08:27:51.151]         base::withCallingHandlers({
[08:27:51.151]             ...future.value <- base::withVisible(base::local({
[08:27:51.151]                 withCallingHandlers({
[08:27:51.151]                   2
[08:27:51.151]                 }, immediateCondition = function(cond) {
[08:27:51.151]                   save_rds <- function (object, pathname, ...) 
[08:27:51.151]                   {
[08:27:51.151]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:51.151]                     if (file_test("-f", pathname_tmp)) {
[08:27:51.151]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.151]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:51.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.151]                         fi_tmp[["mtime"]])
[08:27:51.151]                     }
[08:27:51.151]                     tryCatch({
[08:27:51.151]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:51.151]                     }, error = function(ex) {
[08:27:51.151]                       msg <- conditionMessage(ex)
[08:27:51.151]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.151]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:51.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.151]                         fi_tmp[["mtime"]], msg)
[08:27:51.151]                       ex$message <- msg
[08:27:51.151]                       stop(ex)
[08:27:51.151]                     })
[08:27:51.151]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:51.151]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:51.151]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:51.151]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.151]                       fi <- file.info(pathname)
[08:27:51.151]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:51.151]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.151]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:51.151]                         fi[["size"]], fi[["mtime"]])
[08:27:51.151]                       stop(msg)
[08:27:51.151]                     }
[08:27:51.151]                     invisible(pathname)
[08:27:51.151]                   }
[08:27:51.151]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:51.151]                     rootPath = tempdir()) 
[08:27:51.151]                   {
[08:27:51.151]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:51.151]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:51.151]                       tmpdir = path, fileext = ".rds")
[08:27:51.151]                     save_rds(obj, file)
[08:27:51.151]                   }
[08:27:51.151]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:51.151]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.151]                   {
[08:27:51.151]                     inherits <- base::inherits
[08:27:51.151]                     invokeRestart <- base::invokeRestart
[08:27:51.151]                     is.null <- base::is.null
[08:27:51.151]                     muffled <- FALSE
[08:27:51.151]                     if (inherits(cond, "message")) {
[08:27:51.151]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.151]                       if (muffled) 
[08:27:51.151]                         invokeRestart("muffleMessage")
[08:27:51.151]                     }
[08:27:51.151]                     else if (inherits(cond, "warning")) {
[08:27:51.151]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.151]                       if (muffled) 
[08:27:51.151]                         invokeRestart("muffleWarning")
[08:27:51.151]                     }
[08:27:51.151]                     else if (inherits(cond, "condition")) {
[08:27:51.151]                       if (!is.null(pattern)) {
[08:27:51.151]                         computeRestarts <- base::computeRestarts
[08:27:51.151]                         grepl <- base::grepl
[08:27:51.151]                         restarts <- computeRestarts(cond)
[08:27:51.151]                         for (restart in restarts) {
[08:27:51.151]                           name <- restart$name
[08:27:51.151]                           if (is.null(name)) 
[08:27:51.151]                             next
[08:27:51.151]                           if (!grepl(pattern, name)) 
[08:27:51.151]                             next
[08:27:51.151]                           invokeRestart(restart)
[08:27:51.151]                           muffled <- TRUE
[08:27:51.151]                           break
[08:27:51.151]                         }
[08:27:51.151]                       }
[08:27:51.151]                     }
[08:27:51.151]                     invisible(muffled)
[08:27:51.151]                   }
[08:27:51.151]                   muffleCondition(cond)
[08:27:51.151]                 })
[08:27:51.151]             }))
[08:27:51.151]             future::FutureResult(value = ...future.value$value, 
[08:27:51.151]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.151]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.151]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.151]                     ...future.globalenv.names))
[08:27:51.151]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.151]         }, condition = base::local({
[08:27:51.151]             c <- base::c
[08:27:51.151]             inherits <- base::inherits
[08:27:51.151]             invokeRestart <- base::invokeRestart
[08:27:51.151]             length <- base::length
[08:27:51.151]             list <- base::list
[08:27:51.151]             seq.int <- base::seq.int
[08:27:51.151]             signalCondition <- base::signalCondition
[08:27:51.151]             sys.calls <- base::sys.calls
[08:27:51.151]             `[[` <- base::`[[`
[08:27:51.151]             `+` <- base::`+`
[08:27:51.151]             `<<-` <- base::`<<-`
[08:27:51.151]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.151]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.151]                   3L)]
[08:27:51.151]             }
[08:27:51.151]             function(cond) {
[08:27:51.151]                 is_error <- inherits(cond, "error")
[08:27:51.151]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.151]                   NULL)
[08:27:51.151]                 if (is_error) {
[08:27:51.151]                   sessionInformation <- function() {
[08:27:51.151]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.151]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.151]                       search = base::search(), system = base::Sys.info())
[08:27:51.151]                   }
[08:27:51.151]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.151]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.151]                     cond$call), session = sessionInformation(), 
[08:27:51.151]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.151]                   signalCondition(cond)
[08:27:51.151]                 }
[08:27:51.151]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.151]                 "immediateCondition"))) {
[08:27:51.151]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.151]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.151]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.151]                   if (TRUE && !signal) {
[08:27:51.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.151]                     {
[08:27:51.151]                       inherits <- base::inherits
[08:27:51.151]                       invokeRestart <- base::invokeRestart
[08:27:51.151]                       is.null <- base::is.null
[08:27:51.151]                       muffled <- FALSE
[08:27:51.151]                       if (inherits(cond, "message")) {
[08:27:51.151]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.151]                         if (muffled) 
[08:27:51.151]                           invokeRestart("muffleMessage")
[08:27:51.151]                       }
[08:27:51.151]                       else if (inherits(cond, "warning")) {
[08:27:51.151]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.151]                         if (muffled) 
[08:27:51.151]                           invokeRestart("muffleWarning")
[08:27:51.151]                       }
[08:27:51.151]                       else if (inherits(cond, "condition")) {
[08:27:51.151]                         if (!is.null(pattern)) {
[08:27:51.151]                           computeRestarts <- base::computeRestarts
[08:27:51.151]                           grepl <- base::grepl
[08:27:51.151]                           restarts <- computeRestarts(cond)
[08:27:51.151]                           for (restart in restarts) {
[08:27:51.151]                             name <- restart$name
[08:27:51.151]                             if (is.null(name)) 
[08:27:51.151]                               next
[08:27:51.151]                             if (!grepl(pattern, name)) 
[08:27:51.151]                               next
[08:27:51.151]                             invokeRestart(restart)
[08:27:51.151]                             muffled <- TRUE
[08:27:51.151]                             break
[08:27:51.151]                           }
[08:27:51.151]                         }
[08:27:51.151]                       }
[08:27:51.151]                       invisible(muffled)
[08:27:51.151]                     }
[08:27:51.151]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.151]                   }
[08:27:51.151]                 }
[08:27:51.151]                 else {
[08:27:51.151]                   if (TRUE) {
[08:27:51.151]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.151]                     {
[08:27:51.151]                       inherits <- base::inherits
[08:27:51.151]                       invokeRestart <- base::invokeRestart
[08:27:51.151]                       is.null <- base::is.null
[08:27:51.151]                       muffled <- FALSE
[08:27:51.151]                       if (inherits(cond, "message")) {
[08:27:51.151]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.151]                         if (muffled) 
[08:27:51.151]                           invokeRestart("muffleMessage")
[08:27:51.151]                       }
[08:27:51.151]                       else if (inherits(cond, "warning")) {
[08:27:51.151]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.151]                         if (muffled) 
[08:27:51.151]                           invokeRestart("muffleWarning")
[08:27:51.151]                       }
[08:27:51.151]                       else if (inherits(cond, "condition")) {
[08:27:51.151]                         if (!is.null(pattern)) {
[08:27:51.151]                           computeRestarts <- base::computeRestarts
[08:27:51.151]                           grepl <- base::grepl
[08:27:51.151]                           restarts <- computeRestarts(cond)
[08:27:51.151]                           for (restart in restarts) {
[08:27:51.151]                             name <- restart$name
[08:27:51.151]                             if (is.null(name)) 
[08:27:51.151]                               next
[08:27:51.151]                             if (!grepl(pattern, name)) 
[08:27:51.151]                               next
[08:27:51.151]                             invokeRestart(restart)
[08:27:51.151]                             muffled <- TRUE
[08:27:51.151]                             break
[08:27:51.151]                           }
[08:27:51.151]                         }
[08:27:51.151]                       }
[08:27:51.151]                       invisible(muffled)
[08:27:51.151]                     }
[08:27:51.151]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.151]                   }
[08:27:51.151]                 }
[08:27:51.151]             }
[08:27:51.151]         }))
[08:27:51.151]     }, error = function(ex) {
[08:27:51.151]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.151]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.151]                 ...future.rng), started = ...future.startTime, 
[08:27:51.151]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.151]             version = "1.8"), class = "FutureResult")
[08:27:51.151]     }, finally = {
[08:27:51.151]         if (!identical(...future.workdir, getwd())) 
[08:27:51.151]             setwd(...future.workdir)
[08:27:51.151]         {
[08:27:51.151]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.151]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.151]             }
[08:27:51.151]             base::options(...future.oldOptions)
[08:27:51.151]             if (.Platform$OS.type == "windows") {
[08:27:51.151]                 old_names <- names(...future.oldEnvVars)
[08:27:51.151]                 envs <- base::Sys.getenv()
[08:27:51.151]                 names <- names(envs)
[08:27:51.151]                 common <- intersect(names, old_names)
[08:27:51.151]                 added <- setdiff(names, old_names)
[08:27:51.151]                 removed <- setdiff(old_names, names)
[08:27:51.151]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.151]                   envs[common]]
[08:27:51.151]                 NAMES <- toupper(changed)
[08:27:51.151]                 args <- list()
[08:27:51.151]                 for (kk in seq_along(NAMES)) {
[08:27:51.151]                   name <- changed[[kk]]
[08:27:51.151]                   NAME <- NAMES[[kk]]
[08:27:51.151]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.151]                     next
[08:27:51.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.151]                 }
[08:27:51.151]                 NAMES <- toupper(added)
[08:27:51.151]                 for (kk in seq_along(NAMES)) {
[08:27:51.151]                   name <- added[[kk]]
[08:27:51.151]                   NAME <- NAMES[[kk]]
[08:27:51.151]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.151]                     next
[08:27:51.151]                   args[[name]] <- ""
[08:27:51.151]                 }
[08:27:51.151]                 NAMES <- toupper(removed)
[08:27:51.151]                 for (kk in seq_along(NAMES)) {
[08:27:51.151]                   name <- removed[[kk]]
[08:27:51.151]                   NAME <- NAMES[[kk]]
[08:27:51.151]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.151]                     next
[08:27:51.151]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.151]                 }
[08:27:51.151]                 if (length(args) > 0) 
[08:27:51.151]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.151]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.151]             }
[08:27:51.151]             else {
[08:27:51.151]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.151]             }
[08:27:51.151]             {
[08:27:51.151]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.151]                   0L) {
[08:27:51.151]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.151]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.151]                   base::options(opts)
[08:27:51.151]                 }
[08:27:51.151]                 {
[08:27:51.151]                   {
[08:27:51.151]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.151]                     NULL
[08:27:51.151]                   }
[08:27:51.151]                   options(future.plan = NULL)
[08:27:51.151]                   if (is.na(NA_character_)) 
[08:27:51.151]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.151]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.151]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.151]                     .init = FALSE)
[08:27:51.151]                 }
[08:27:51.151]             }
[08:27:51.151]         }
[08:27:51.151]     })
[08:27:51.151]     if (TRUE) {
[08:27:51.151]         base::sink(type = "output", split = FALSE)
[08:27:51.151]         if (TRUE) {
[08:27:51.151]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.151]         }
[08:27:51.151]         else {
[08:27:51.151]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.151]         }
[08:27:51.151]         base::close(...future.stdout)
[08:27:51.151]         ...future.stdout <- NULL
[08:27:51.151]     }
[08:27:51.151]     ...future.result$conditions <- ...future.conditions
[08:27:51.151]     ...future.result$finished <- base::Sys.time()
[08:27:51.151]     ...future.result
[08:27:51.151] }
[08:27:51.154] requestCore(): workers = 2
[08:27:51.156] MulticoreFuture started
[08:27:51.157] - Launch lazy future ... done
[08:27:51.157] run() for ‘MulticoreFuture’ ... done
[08:27:51.157] plan(): Setting new future strategy stack:
[08:27:51.157] getGlobalsAndPackages() ...
[08:27:51.158] Searching for globals...
[08:27:51.158] List of future strategies:
[08:27:51.158] 1. sequential:
[08:27:51.158]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:51.158]    - tweaked: FALSE
[08:27:51.158]    - call: NULL
[08:27:51.159] 
[08:27:51.159] plan(): nbrOfWorkers() = 1
[08:27:51.159] Searching for globals ... DONE
[08:27:51.159] - globals: [0] <none>
[08:27:51.160] getGlobalsAndPackages() ... DONE
[08:27:51.160] run() for ‘Future’ ...
[08:27:51.160] - state: ‘created’
[08:27:51.161] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.161] plan(): Setting new future strategy stack:
[08:27:51.161] List of future strategies:
[08:27:51.161] 1. multicore:
[08:27:51.161]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:51.161]    - tweaked: FALSE
[08:27:51.161]    - call: plan(strategy)
[08:27:51.164] plan(): nbrOfWorkers() = 2
[08:27:51.164] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.164] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:51.164]   - Field: ‘label’
[08:27:51.164]   - Field: ‘local’
[08:27:51.165]   - Field: ‘owner’
[08:27:51.165]   - Field: ‘envir’
[08:27:51.165]   - Field: ‘workers’
[08:27:51.165]   - Field: ‘packages’
[08:27:51.165]   - Field: ‘gc’
[08:27:51.166]   - Field: ‘job’
[08:27:51.166]   - Field: ‘conditions’
[08:27:51.166]   - Field: ‘expr’
[08:27:51.166]   - Field: ‘uuid’
[08:27:51.166]   - Field: ‘seed’
[08:27:51.166]   - Field: ‘version’
[08:27:51.166]   - Field: ‘result’
[08:27:51.167]   - Field: ‘asynchronous’
[08:27:51.167]   - Field: ‘calls’
[08:27:51.167]   - Field: ‘globals’
[08:27:51.167]   - Field: ‘stdout’
[08:27:51.167]   - Field: ‘earlySignal’
[08:27:51.167]   - Field: ‘lazy’
[08:27:51.167]   - Field: ‘state’
[08:27:51.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:51.168] - Launch lazy future ...
[08:27:51.168] Packages needed by the future expression (n = 0): <none>
[08:27:51.168] Packages needed by future strategies (n = 0): <none>
[08:27:51.169] {
[08:27:51.169]     {
[08:27:51.169]         {
[08:27:51.169]             ...future.startTime <- base::Sys.time()
[08:27:51.169]             {
[08:27:51.169]                 {
[08:27:51.169]                   {
[08:27:51.169]                     {
[08:27:51.169]                       base::local({
[08:27:51.169]                         has_future <- base::requireNamespace("future", 
[08:27:51.169]                           quietly = TRUE)
[08:27:51.169]                         if (has_future) {
[08:27:51.169]                           ns <- base::getNamespace("future")
[08:27:51.169]                           version <- ns[[".package"]][["version"]]
[08:27:51.169]                           if (is.null(version)) 
[08:27:51.169]                             version <- utils::packageVersion("future")
[08:27:51.169]                         }
[08:27:51.169]                         else {
[08:27:51.169]                           version <- NULL
[08:27:51.169]                         }
[08:27:51.169]                         if (!has_future || version < "1.8.0") {
[08:27:51.169]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.169]                             "", base::R.version$version.string), 
[08:27:51.169]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.169]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.169]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.169]                               "release", "version")], collapse = " "), 
[08:27:51.169]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.169]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.169]                             info)
[08:27:51.169]                           info <- base::paste(info, collapse = "; ")
[08:27:51.169]                           if (!has_future) {
[08:27:51.169]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.169]                               info)
[08:27:51.169]                           }
[08:27:51.169]                           else {
[08:27:51.169]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.169]                               info, version)
[08:27:51.169]                           }
[08:27:51.169]                           base::stop(msg)
[08:27:51.169]                         }
[08:27:51.169]                       })
[08:27:51.169]                     }
[08:27:51.169]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.169]                     base::options(mc.cores = 1L)
[08:27:51.169]                   }
[08:27:51.169]                   ...future.strategy.old <- future::plan("list")
[08:27:51.169]                   options(future.plan = NULL)
[08:27:51.169]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.169]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.169]                 }
[08:27:51.169]                 ...future.workdir <- getwd()
[08:27:51.169]             }
[08:27:51.169]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.169]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.169]         }
[08:27:51.169]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.169]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.169]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.169]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.169]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.169]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.169]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.169]             base::names(...future.oldOptions))
[08:27:51.169]     }
[08:27:51.169]     if (FALSE) {
[08:27:51.169]     }
[08:27:51.169]     else {
[08:27:51.169]         if (TRUE) {
[08:27:51.169]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.169]                 open = "w")
[08:27:51.169]         }
[08:27:51.169]         else {
[08:27:51.169]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.169]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.169]         }
[08:27:51.169]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.169]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.169]             base::sink(type = "output", split = FALSE)
[08:27:51.169]             base::close(...future.stdout)
[08:27:51.169]         }, add = TRUE)
[08:27:51.169]     }
[08:27:51.169]     ...future.frame <- base::sys.nframe()
[08:27:51.169]     ...future.conditions <- base::list()
[08:27:51.169]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.169]     if (FALSE) {
[08:27:51.169]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.169]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.169]     }
[08:27:51.169]     ...future.result <- base::tryCatch({
[08:27:51.169]         base::withCallingHandlers({
[08:27:51.169]             ...future.value <- base::withVisible(base::local({
[08:27:51.169]                 withCallingHandlers({
[08:27:51.169]                   NULL
[08:27:51.169]                 }, immediateCondition = function(cond) {
[08:27:51.169]                   save_rds <- function (object, pathname, ...) 
[08:27:51.169]                   {
[08:27:51.169]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:51.169]                     if (file_test("-f", pathname_tmp)) {
[08:27:51.169]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.169]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:51.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.169]                         fi_tmp[["mtime"]])
[08:27:51.169]                     }
[08:27:51.169]                     tryCatch({
[08:27:51.169]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:51.169]                     }, error = function(ex) {
[08:27:51.169]                       msg <- conditionMessage(ex)
[08:27:51.169]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.169]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:51.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.169]                         fi_tmp[["mtime"]], msg)
[08:27:51.169]                       ex$message <- msg
[08:27:51.169]                       stop(ex)
[08:27:51.169]                     })
[08:27:51.169]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:51.169]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:51.169]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:51.169]                       fi_tmp <- file.info(pathname_tmp)
[08:27:51.169]                       fi <- file.info(pathname)
[08:27:51.169]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:51.169]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:51.169]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:51.169]                         fi[["size"]], fi[["mtime"]])
[08:27:51.169]                       stop(msg)
[08:27:51.169]                     }
[08:27:51.169]                     invisible(pathname)
[08:27:51.169]                   }
[08:27:51.169]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:51.169]                     rootPath = tempdir()) 
[08:27:51.169]                   {
[08:27:51.169]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:51.169]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:51.169]                       tmpdir = path, fileext = ".rds")
[08:27:51.169]                     save_rds(obj, file)
[08:27:51.169]                   }
[08:27:51.169]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:51.169]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.169]                   {
[08:27:51.169]                     inherits <- base::inherits
[08:27:51.169]                     invokeRestart <- base::invokeRestart
[08:27:51.169]                     is.null <- base::is.null
[08:27:51.169]                     muffled <- FALSE
[08:27:51.169]                     if (inherits(cond, "message")) {
[08:27:51.169]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.169]                       if (muffled) 
[08:27:51.169]                         invokeRestart("muffleMessage")
[08:27:51.169]                     }
[08:27:51.169]                     else if (inherits(cond, "warning")) {
[08:27:51.169]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.169]                       if (muffled) 
[08:27:51.169]                         invokeRestart("muffleWarning")
[08:27:51.169]                     }
[08:27:51.169]                     else if (inherits(cond, "condition")) {
[08:27:51.169]                       if (!is.null(pattern)) {
[08:27:51.169]                         computeRestarts <- base::computeRestarts
[08:27:51.169]                         grepl <- base::grepl
[08:27:51.169]                         restarts <- computeRestarts(cond)
[08:27:51.169]                         for (restart in restarts) {
[08:27:51.169]                           name <- restart$name
[08:27:51.169]                           if (is.null(name)) 
[08:27:51.169]                             next
[08:27:51.169]                           if (!grepl(pattern, name)) 
[08:27:51.169]                             next
[08:27:51.169]                           invokeRestart(restart)
[08:27:51.169]                           muffled <- TRUE
[08:27:51.169]                           break
[08:27:51.169]                         }
[08:27:51.169]                       }
[08:27:51.169]                     }
[08:27:51.169]                     invisible(muffled)
[08:27:51.169]                   }
[08:27:51.169]                   muffleCondition(cond)
[08:27:51.169]                 })
[08:27:51.169]             }))
[08:27:51.169]             future::FutureResult(value = ...future.value$value, 
[08:27:51.169]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.169]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.169]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.169]                     ...future.globalenv.names))
[08:27:51.169]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.169]         }, condition = base::local({
[08:27:51.169]             c <- base::c
[08:27:51.169]             inherits <- base::inherits
[08:27:51.169]             invokeRestart <- base::invokeRestart
[08:27:51.169]             length <- base::length
[08:27:51.169]             list <- base::list
[08:27:51.169]             seq.int <- base::seq.int
[08:27:51.169]             signalCondition <- base::signalCondition
[08:27:51.169]             sys.calls <- base::sys.calls
[08:27:51.169]             `[[` <- base::`[[`
[08:27:51.169]             `+` <- base::`+`
[08:27:51.169]             `<<-` <- base::`<<-`
[08:27:51.169]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.169]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.169]                   3L)]
[08:27:51.169]             }
[08:27:51.169]             function(cond) {
[08:27:51.169]                 is_error <- inherits(cond, "error")
[08:27:51.169]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.169]                   NULL)
[08:27:51.169]                 if (is_error) {
[08:27:51.169]                   sessionInformation <- function() {
[08:27:51.169]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.169]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.169]                       search = base::search(), system = base::Sys.info())
[08:27:51.169]                   }
[08:27:51.169]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.169]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.169]                     cond$call), session = sessionInformation(), 
[08:27:51.169]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.169]                   signalCondition(cond)
[08:27:51.169]                 }
[08:27:51.169]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.169]                 "immediateCondition"))) {
[08:27:51.169]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.169]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.169]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.169]                   if (TRUE && !signal) {
[08:27:51.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.169]                     {
[08:27:51.169]                       inherits <- base::inherits
[08:27:51.169]                       invokeRestart <- base::invokeRestart
[08:27:51.169]                       is.null <- base::is.null
[08:27:51.169]                       muffled <- FALSE
[08:27:51.169]                       if (inherits(cond, "message")) {
[08:27:51.169]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.169]                         if (muffled) 
[08:27:51.169]                           invokeRestart("muffleMessage")
[08:27:51.169]                       }
[08:27:51.169]                       else if (inherits(cond, "warning")) {
[08:27:51.169]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.169]                         if (muffled) 
[08:27:51.169]                           invokeRestart("muffleWarning")
[08:27:51.169]                       }
[08:27:51.169]                       else if (inherits(cond, "condition")) {
[08:27:51.169]                         if (!is.null(pattern)) {
[08:27:51.169]                           computeRestarts <- base::computeRestarts
[08:27:51.169]                           grepl <- base::grepl
[08:27:51.169]                           restarts <- computeRestarts(cond)
[08:27:51.169]                           for (restart in restarts) {
[08:27:51.169]                             name <- restart$name
[08:27:51.169]                             if (is.null(name)) 
[08:27:51.169]                               next
[08:27:51.169]                             if (!grepl(pattern, name)) 
[08:27:51.169]                               next
[08:27:51.169]                             invokeRestart(restart)
[08:27:51.169]                             muffled <- TRUE
[08:27:51.169]                             break
[08:27:51.169]                           }
[08:27:51.169]                         }
[08:27:51.169]                       }
[08:27:51.169]                       invisible(muffled)
[08:27:51.169]                     }
[08:27:51.169]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.169]                   }
[08:27:51.169]                 }
[08:27:51.169]                 else {
[08:27:51.169]                   if (TRUE) {
[08:27:51.169]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.169]                     {
[08:27:51.169]                       inherits <- base::inherits
[08:27:51.169]                       invokeRestart <- base::invokeRestart
[08:27:51.169]                       is.null <- base::is.null
[08:27:51.169]                       muffled <- FALSE
[08:27:51.169]                       if (inherits(cond, "message")) {
[08:27:51.169]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.169]                         if (muffled) 
[08:27:51.169]                           invokeRestart("muffleMessage")
[08:27:51.169]                       }
[08:27:51.169]                       else if (inherits(cond, "warning")) {
[08:27:51.169]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.169]                         if (muffled) 
[08:27:51.169]                           invokeRestart("muffleWarning")
[08:27:51.169]                       }
[08:27:51.169]                       else if (inherits(cond, "condition")) {
[08:27:51.169]                         if (!is.null(pattern)) {
[08:27:51.169]                           computeRestarts <- base::computeRestarts
[08:27:51.169]                           grepl <- base::grepl
[08:27:51.169]                           restarts <- computeRestarts(cond)
[08:27:51.169]                           for (restart in restarts) {
[08:27:51.169]                             name <- restart$name
[08:27:51.169]                             if (is.null(name)) 
[08:27:51.169]                               next
[08:27:51.169]                             if (!grepl(pattern, name)) 
[08:27:51.169]                               next
[08:27:51.169]                             invokeRestart(restart)
[08:27:51.169]                             muffled <- TRUE
[08:27:51.169]                             break
[08:27:51.169]                           }
[08:27:51.169]                         }
[08:27:51.169]                       }
[08:27:51.169]                       invisible(muffled)
[08:27:51.169]                     }
[08:27:51.169]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.169]                   }
[08:27:51.169]                 }
[08:27:51.169]             }
[08:27:51.169]         }))
[08:27:51.169]     }, error = function(ex) {
[08:27:51.169]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.169]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.169]                 ...future.rng), started = ...future.startTime, 
[08:27:51.169]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.169]             version = "1.8"), class = "FutureResult")
[08:27:51.169]     }, finally = {
[08:27:51.169]         if (!identical(...future.workdir, getwd())) 
[08:27:51.169]             setwd(...future.workdir)
[08:27:51.169]         {
[08:27:51.169]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.169]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.169]             }
[08:27:51.169]             base::options(...future.oldOptions)
[08:27:51.169]             if (.Platform$OS.type == "windows") {
[08:27:51.169]                 old_names <- names(...future.oldEnvVars)
[08:27:51.169]                 envs <- base::Sys.getenv()
[08:27:51.169]                 names <- names(envs)
[08:27:51.169]                 common <- intersect(names, old_names)
[08:27:51.169]                 added <- setdiff(names, old_names)
[08:27:51.169]                 removed <- setdiff(old_names, names)
[08:27:51.169]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.169]                   envs[common]]
[08:27:51.169]                 NAMES <- toupper(changed)
[08:27:51.169]                 args <- list()
[08:27:51.169]                 for (kk in seq_along(NAMES)) {
[08:27:51.169]                   name <- changed[[kk]]
[08:27:51.169]                   NAME <- NAMES[[kk]]
[08:27:51.169]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.169]                     next
[08:27:51.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.169]                 }
[08:27:51.169]                 NAMES <- toupper(added)
[08:27:51.169]                 for (kk in seq_along(NAMES)) {
[08:27:51.169]                   name <- added[[kk]]
[08:27:51.169]                   NAME <- NAMES[[kk]]
[08:27:51.169]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.169]                     next
[08:27:51.169]                   args[[name]] <- ""
[08:27:51.169]                 }
[08:27:51.169]                 NAMES <- toupper(removed)
[08:27:51.169]                 for (kk in seq_along(NAMES)) {
[08:27:51.169]                   name <- removed[[kk]]
[08:27:51.169]                   NAME <- NAMES[[kk]]
[08:27:51.169]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.169]                     next
[08:27:51.169]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.169]                 }
[08:27:51.169]                 if (length(args) > 0) 
[08:27:51.169]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.169]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.169]             }
[08:27:51.169]             else {
[08:27:51.169]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.169]             }
[08:27:51.169]             {
[08:27:51.169]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.169]                   0L) {
[08:27:51.169]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.169]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.169]                   base::options(opts)
[08:27:51.169]                 }
[08:27:51.169]                 {
[08:27:51.169]                   {
[08:27:51.169]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.169]                     NULL
[08:27:51.169]                   }
[08:27:51.169]                   options(future.plan = NULL)
[08:27:51.169]                   if (is.na(NA_character_)) 
[08:27:51.169]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.169]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.169]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.169]                     .init = FALSE)
[08:27:51.169]                 }
[08:27:51.169]             }
[08:27:51.169]         }
[08:27:51.169]     })
[08:27:51.169]     if (TRUE) {
[08:27:51.169]         base::sink(type = "output", split = FALSE)
[08:27:51.169]         if (TRUE) {
[08:27:51.169]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.169]         }
[08:27:51.169]         else {
[08:27:51.169]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.169]         }
[08:27:51.169]         base::close(...future.stdout)
[08:27:51.169]         ...future.stdout <- NULL
[08:27:51.169]     }
[08:27:51.169]     ...future.result$conditions <- ...future.conditions
[08:27:51.169]     ...future.result$finished <- base::Sys.time()
[08:27:51.169]     ...future.result
[08:27:51.169] }
[08:27:51.173] requestCore(): workers = 2
[08:27:51.175] MulticoreFuture started
[08:27:51.176] - Launch lazy future ... done
[08:27:51.176] run() for ‘MulticoreFuture’ ... done
List of 6
 $ a:[08:27:51.177] plan(): Setting new future strategy stack:
 num 1
 $ b:[08:27:51.177] List of future strategies:
[08:27:51.177] 1. sequential:
[08:27:51.177]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:51.177]    - tweaked: FALSE
[08:27:51.177]    - call: NULL
[08:27:51.178] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d861094a30> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d85f1e6e90> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
[08:27:51.180] plan(): Setting new future strategy stack:
 $ a: num 1
[08:27:51.180] List of future strategies:
[08:27:51.180] 1. multicore:
[08:27:51.180]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:51.180]    - tweaked: FALSE
[08:27:51.180]    - call: plan(strategy)
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d861094a30> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d85f1e6e90> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ :[08:27:51.184] plan(): nbrOfWorkers() = 2
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:51.189] resolve() on list ...
[08:27:51.189]  recursive: 0
[08:27:51.189]  length: 6
[08:27:51.189]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:51.189] signalConditionsASAP(numeric, pos=1) ...
[08:27:51.190] - nx: 6
[08:27:51.190] - relay: TRUE
[08:27:51.190] - stdout: TRUE
[08:27:51.190] - signal: TRUE
[08:27:51.190] - resignal: FALSE
[08:27:51.190] - force: TRUE
[08:27:51.190] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.190] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.191]  - until=2
[08:27:51.191]  - relaying element #2
[08:27:51.191] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.191] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.191] signalConditionsASAP(NULL, pos=1) ... done
[08:27:51.191]  length: 5 (resolved future 1)
[08:27:51.192] Future #2
[08:27:51.192] result() for MulticoreFuture ...
[08:27:51.193] result() for MulticoreFuture ...
[08:27:51.193] result() for MulticoreFuture ... done
[08:27:51.193] result() for MulticoreFuture ... done
[08:27:51.193] result() for MulticoreFuture ...
[08:27:51.194] result() for MulticoreFuture ... done
[08:27:51.194] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:51.194] - nx: 6
[08:27:51.194] - relay: TRUE
[08:27:51.194] - stdout: TRUE
[08:27:51.194] - signal: TRUE
[08:27:51.194] - resignal: FALSE
[08:27:51.194] - force: TRUE
[08:27:51.195] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.195] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.195]  - until=2
[08:27:51.195]  - relaying element #2
[08:27:51.195] result() for MulticoreFuture ...
[08:27:51.195] result() for MulticoreFuture ... done
[08:27:51.195] result() for MulticoreFuture ...
[08:27:51.196] result() for MulticoreFuture ... done
[08:27:51.196] result() for MulticoreFuture ...
[08:27:51.196] result() for MulticoreFuture ... done
[08:27:51.196] result() for MulticoreFuture ...
[08:27:51.196] result() for MulticoreFuture ... done
[08:27:51.196] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.196] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.197] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:51.197]  length: 4 (resolved future 2)
[08:27:51.197] Future #3
[08:27:51.197] result() for MulticoreFuture ...
[08:27:51.202] result() for MulticoreFuture ...
[08:27:51.202] result() for MulticoreFuture ... done
[08:27:51.202] result() for MulticoreFuture ... done
[08:27:51.203] result() for MulticoreFuture ...
[08:27:51.203] result() for MulticoreFuture ... done
[08:27:51.203] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:51.203] - nx: 6
[08:27:51.204] - relay: TRUE
[08:27:51.204] - stdout: TRUE
[08:27:51.204] - signal: TRUE
[08:27:51.204] - resignal: FALSE
[08:27:51.204] - force: TRUE
[08:27:51.204] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.204] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.205]  - until=3
[08:27:51.205]  - relaying element #3
[08:27:51.205] result() for MulticoreFuture ...
[08:27:51.205] result() for MulticoreFuture ... done
[08:27:51.205] result() for MulticoreFuture ...
[08:27:51.205] result() for MulticoreFuture ... done
[08:27:51.205] result() for MulticoreFuture ...
[08:27:51.206] result() for MulticoreFuture ... done
[08:27:51.206] result() for MulticoreFuture ...
[08:27:51.206] result() for MulticoreFuture ... done
[08:27:51.206] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.206] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.206] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:51.206]  length: 3 (resolved future 3)
[08:27:51.206] signalConditionsASAP(NULL, pos=4) ...
[08:27:51.207] - nx: 6
[08:27:51.207] - relay: TRUE
[08:27:51.207] - stdout: TRUE
[08:27:51.207] - signal: TRUE
[08:27:51.207] - resignal: FALSE
[08:27:51.207] - force: TRUE
[08:27:51.207] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.207] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.207]  - until=5
[08:27:51.208]  - relaying element #5
[08:27:51.208] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:51.208] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.208] signalConditionsASAP(NULL, pos=4) ... done
[08:27:51.208]  length: 2 (resolved future 4)
[08:27:51.208] signalConditionsASAP(NULL, pos=5) ...
[08:27:51.208] - nx: 6
[08:27:51.208] - relay: TRUE
[08:27:51.208] - stdout: TRUE
[08:27:51.208] - signal: TRUE
[08:27:51.209] - resignal: FALSE
[08:27:51.209] - force: TRUE
[08:27:51.209] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:51.209] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.209]  - until=6
[08:27:51.209]  - relaying element #6
[08:27:51.209] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:51.209] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.209] signalConditionsASAP(NULL, pos=5) ... done
[08:27:51.209]  length: 1 (resolved future 5)
[08:27:51.210] signalConditionsASAP(numeric, pos=6) ...
[08:27:51.210] - nx: 6
[08:27:51.210] - relay: TRUE
[08:27:51.210] - stdout: TRUE
[08:27:51.210] - signal: TRUE
[08:27:51.210] - resignal: FALSE
[08:27:51.210] - force: TRUE
[08:27:51.210] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:51.210] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.211]  - until=6
[08:27:51.211] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.211] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.211] signalConditionsASAP(numeric, pos=6) ... done
[08:27:51.211]  length: 0 (resolved future 6)
[08:27:51.211] Relaying remaining futures
[08:27:51.211] signalConditionsASAP(NULL, pos=0) ...
[08:27:51.211] - nx: 6
[08:27:51.211] - relay: TRUE
[08:27:51.211] - stdout: TRUE
[08:27:51.212] - signal: TRUE
[08:27:51.212] - resignal: FALSE
[08:27:51.212] - force: TRUE
[08:27:51.212] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.212] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:51.212] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.212] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.212] signalConditionsASAP(NULL, pos=0) ... done
[08:27:51.212] resolve() on list ... DONE
[08:27:51.212] result() for MulticoreFuture ...
[08:27:51.213] result() for MulticoreFuture ... done
[08:27:51.213] result() for MulticoreFuture ...
[08:27:51.213] result() for MulticoreFuture ... done
[08:27:51.213] result() for MulticoreFuture ...
[08:27:51.213] result() for MulticoreFuture ... done
[08:27:51.213] result() for MulticoreFuture ...
[08:27:51.213] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[08:27:51.217] plan(): Setting new future strategy stack:
[08:27:51.217] List of future strategies:
[08:27:51.217] 1. multisession:
[08:27:51.217]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:51.217]    - tweaked: FALSE
[08:27:51.217]    - call: plan(strategy)
[08:27:51.218] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:27:51.218] multisession:
[08:27:51.218] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:51.218] - tweaked: FALSE
[08:27:51.218] - call: plan(strategy)
[08:27:51.222] getGlobalsAndPackages() ...
[08:27:51.222] Not searching for globals
[08:27:51.222] - globals: [0] <none>
[08:27:51.222] getGlobalsAndPackages() ... DONE
[08:27:51.708] Packages needed by the future expression (n = 0): <none>
[08:27:51.708] Packages needed by future strategies (n = 0): <none>
[08:27:51.709] {
[08:27:51.709]     {
[08:27:51.709]         {
[08:27:51.709]             ...future.startTime <- base::Sys.time()
[08:27:51.709]             {
[08:27:51.709]                 {
[08:27:51.709]                   {
[08:27:51.709]                     {
[08:27:51.709]                       base::local({
[08:27:51.709]                         has_future <- base::requireNamespace("future", 
[08:27:51.709]                           quietly = TRUE)
[08:27:51.709]                         if (has_future) {
[08:27:51.709]                           ns <- base::getNamespace("future")
[08:27:51.709]                           version <- ns[[".package"]][["version"]]
[08:27:51.709]                           if (is.null(version)) 
[08:27:51.709]                             version <- utils::packageVersion("future")
[08:27:51.709]                         }
[08:27:51.709]                         else {
[08:27:51.709]                           version <- NULL
[08:27:51.709]                         }
[08:27:51.709]                         if (!has_future || version < "1.8.0") {
[08:27:51.709]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.709]                             "", base::R.version$version.string), 
[08:27:51.709]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.709]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.709]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.709]                               "release", "version")], collapse = " "), 
[08:27:51.709]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.709]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.709]                             info)
[08:27:51.709]                           info <- base::paste(info, collapse = "; ")
[08:27:51.709]                           if (!has_future) {
[08:27:51.709]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.709]                               info)
[08:27:51.709]                           }
[08:27:51.709]                           else {
[08:27:51.709]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.709]                               info, version)
[08:27:51.709]                           }
[08:27:51.709]                           base::stop(msg)
[08:27:51.709]                         }
[08:27:51.709]                       })
[08:27:51.709]                     }
[08:27:51.709]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.709]                     base::options(mc.cores = 1L)
[08:27:51.709]                   }
[08:27:51.709]                   ...future.strategy.old <- future::plan("list")
[08:27:51.709]                   options(future.plan = NULL)
[08:27:51.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.709]                 }
[08:27:51.709]                 ...future.workdir <- getwd()
[08:27:51.709]             }
[08:27:51.709]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.709]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.709]         }
[08:27:51.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.709]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.709]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.709]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.709]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.709]             base::names(...future.oldOptions))
[08:27:51.709]     }
[08:27:51.709]     if (FALSE) {
[08:27:51.709]     }
[08:27:51.709]     else {
[08:27:51.709]         if (TRUE) {
[08:27:51.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.709]                 open = "w")
[08:27:51.709]         }
[08:27:51.709]         else {
[08:27:51.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.709]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.709]         }
[08:27:51.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.709]             base::sink(type = "output", split = FALSE)
[08:27:51.709]             base::close(...future.stdout)
[08:27:51.709]         }, add = TRUE)
[08:27:51.709]     }
[08:27:51.709]     ...future.frame <- base::sys.nframe()
[08:27:51.709]     ...future.conditions <- base::list()
[08:27:51.709]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.709]     if (FALSE) {
[08:27:51.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.709]     }
[08:27:51.709]     ...future.result <- base::tryCatch({
[08:27:51.709]         base::withCallingHandlers({
[08:27:51.709]             ...future.value <- base::withVisible(base::local({
[08:27:51.709]                 ...future.makeSendCondition <- base::local({
[08:27:51.709]                   sendCondition <- NULL
[08:27:51.709]                   function(frame = 1L) {
[08:27:51.709]                     if (is.function(sendCondition)) 
[08:27:51.709]                       return(sendCondition)
[08:27:51.709]                     ns <- getNamespace("parallel")
[08:27:51.709]                     if (exists("sendData", mode = "function", 
[08:27:51.709]                       envir = ns)) {
[08:27:51.709]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:51.709]                         envir = ns)
[08:27:51.709]                       envir <- sys.frame(frame)
[08:27:51.709]                       master <- NULL
[08:27:51.709]                       while (!identical(envir, .GlobalEnv) && 
[08:27:51.709]                         !identical(envir, emptyenv())) {
[08:27:51.709]                         if (exists("master", mode = "list", envir = envir, 
[08:27:51.709]                           inherits = FALSE)) {
[08:27:51.709]                           master <- get("master", mode = "list", 
[08:27:51.709]                             envir = envir, inherits = FALSE)
[08:27:51.709]                           if (inherits(master, c("SOCKnode", 
[08:27:51.709]                             "SOCK0node"))) {
[08:27:51.709]                             sendCondition <<- function(cond) {
[08:27:51.709]                               data <- list(type = "VALUE", value = cond, 
[08:27:51.709]                                 success = TRUE)
[08:27:51.709]                               parallel_sendData(master, data)
[08:27:51.709]                             }
[08:27:51.709]                             return(sendCondition)
[08:27:51.709]                           }
[08:27:51.709]                         }
[08:27:51.709]                         frame <- frame + 1L
[08:27:51.709]                         envir <- sys.frame(frame)
[08:27:51.709]                       }
[08:27:51.709]                     }
[08:27:51.709]                     sendCondition <<- function(cond) NULL
[08:27:51.709]                   }
[08:27:51.709]                 })
[08:27:51.709]                 withCallingHandlers({
[08:27:51.709]                   NA
[08:27:51.709]                 }, immediateCondition = function(cond) {
[08:27:51.709]                   sendCondition <- ...future.makeSendCondition()
[08:27:51.709]                   sendCondition(cond)
[08:27:51.709]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.709]                   {
[08:27:51.709]                     inherits <- base::inherits
[08:27:51.709]                     invokeRestart <- base::invokeRestart
[08:27:51.709]                     is.null <- base::is.null
[08:27:51.709]                     muffled <- FALSE
[08:27:51.709]                     if (inherits(cond, "message")) {
[08:27:51.709]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.709]                       if (muffled) 
[08:27:51.709]                         invokeRestart("muffleMessage")
[08:27:51.709]                     }
[08:27:51.709]                     else if (inherits(cond, "warning")) {
[08:27:51.709]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.709]                       if (muffled) 
[08:27:51.709]                         invokeRestart("muffleWarning")
[08:27:51.709]                     }
[08:27:51.709]                     else if (inherits(cond, "condition")) {
[08:27:51.709]                       if (!is.null(pattern)) {
[08:27:51.709]                         computeRestarts <- base::computeRestarts
[08:27:51.709]                         grepl <- base::grepl
[08:27:51.709]                         restarts <- computeRestarts(cond)
[08:27:51.709]                         for (restart in restarts) {
[08:27:51.709]                           name <- restart$name
[08:27:51.709]                           if (is.null(name)) 
[08:27:51.709]                             next
[08:27:51.709]                           if (!grepl(pattern, name)) 
[08:27:51.709]                             next
[08:27:51.709]                           invokeRestart(restart)
[08:27:51.709]                           muffled <- TRUE
[08:27:51.709]                           break
[08:27:51.709]                         }
[08:27:51.709]                       }
[08:27:51.709]                     }
[08:27:51.709]                     invisible(muffled)
[08:27:51.709]                   }
[08:27:51.709]                   muffleCondition(cond)
[08:27:51.709]                 })
[08:27:51.709]             }))
[08:27:51.709]             future::FutureResult(value = ...future.value$value, 
[08:27:51.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.709]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.709]                     ...future.globalenv.names))
[08:27:51.709]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.709]         }, condition = base::local({
[08:27:51.709]             c <- base::c
[08:27:51.709]             inherits <- base::inherits
[08:27:51.709]             invokeRestart <- base::invokeRestart
[08:27:51.709]             length <- base::length
[08:27:51.709]             list <- base::list
[08:27:51.709]             seq.int <- base::seq.int
[08:27:51.709]             signalCondition <- base::signalCondition
[08:27:51.709]             sys.calls <- base::sys.calls
[08:27:51.709]             `[[` <- base::`[[`
[08:27:51.709]             `+` <- base::`+`
[08:27:51.709]             `<<-` <- base::`<<-`
[08:27:51.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.709]                   3L)]
[08:27:51.709]             }
[08:27:51.709]             function(cond) {
[08:27:51.709]                 is_error <- inherits(cond, "error")
[08:27:51.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.709]                   NULL)
[08:27:51.709]                 if (is_error) {
[08:27:51.709]                   sessionInformation <- function() {
[08:27:51.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.709]                       search = base::search(), system = base::Sys.info())
[08:27:51.709]                   }
[08:27:51.709]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.709]                     cond$call), session = sessionInformation(), 
[08:27:51.709]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.709]                   signalCondition(cond)
[08:27:51.709]                 }
[08:27:51.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.709]                 "immediateCondition"))) {
[08:27:51.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.709]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.709]                   if (TRUE && !signal) {
[08:27:51.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.709]                     {
[08:27:51.709]                       inherits <- base::inherits
[08:27:51.709]                       invokeRestart <- base::invokeRestart
[08:27:51.709]                       is.null <- base::is.null
[08:27:51.709]                       muffled <- FALSE
[08:27:51.709]                       if (inherits(cond, "message")) {
[08:27:51.709]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.709]                         if (muffled) 
[08:27:51.709]                           invokeRestart("muffleMessage")
[08:27:51.709]                       }
[08:27:51.709]                       else if (inherits(cond, "warning")) {
[08:27:51.709]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.709]                         if (muffled) 
[08:27:51.709]                           invokeRestart("muffleWarning")
[08:27:51.709]                       }
[08:27:51.709]                       else if (inherits(cond, "condition")) {
[08:27:51.709]                         if (!is.null(pattern)) {
[08:27:51.709]                           computeRestarts <- base::computeRestarts
[08:27:51.709]                           grepl <- base::grepl
[08:27:51.709]                           restarts <- computeRestarts(cond)
[08:27:51.709]                           for (restart in restarts) {
[08:27:51.709]                             name <- restart$name
[08:27:51.709]                             if (is.null(name)) 
[08:27:51.709]                               next
[08:27:51.709]                             if (!grepl(pattern, name)) 
[08:27:51.709]                               next
[08:27:51.709]                             invokeRestart(restart)
[08:27:51.709]                             muffled <- TRUE
[08:27:51.709]                             break
[08:27:51.709]                           }
[08:27:51.709]                         }
[08:27:51.709]                       }
[08:27:51.709]                       invisible(muffled)
[08:27:51.709]                     }
[08:27:51.709]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.709]                   }
[08:27:51.709]                 }
[08:27:51.709]                 else {
[08:27:51.709]                   if (TRUE) {
[08:27:51.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.709]                     {
[08:27:51.709]                       inherits <- base::inherits
[08:27:51.709]                       invokeRestart <- base::invokeRestart
[08:27:51.709]                       is.null <- base::is.null
[08:27:51.709]                       muffled <- FALSE
[08:27:51.709]                       if (inherits(cond, "message")) {
[08:27:51.709]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.709]                         if (muffled) 
[08:27:51.709]                           invokeRestart("muffleMessage")
[08:27:51.709]                       }
[08:27:51.709]                       else if (inherits(cond, "warning")) {
[08:27:51.709]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.709]                         if (muffled) 
[08:27:51.709]                           invokeRestart("muffleWarning")
[08:27:51.709]                       }
[08:27:51.709]                       else if (inherits(cond, "condition")) {
[08:27:51.709]                         if (!is.null(pattern)) {
[08:27:51.709]                           computeRestarts <- base::computeRestarts
[08:27:51.709]                           grepl <- base::grepl
[08:27:51.709]                           restarts <- computeRestarts(cond)
[08:27:51.709]                           for (restart in restarts) {
[08:27:51.709]                             name <- restart$name
[08:27:51.709]                             if (is.null(name)) 
[08:27:51.709]                               next
[08:27:51.709]                             if (!grepl(pattern, name)) 
[08:27:51.709]                               next
[08:27:51.709]                             invokeRestart(restart)
[08:27:51.709]                             muffled <- TRUE
[08:27:51.709]                             break
[08:27:51.709]                           }
[08:27:51.709]                         }
[08:27:51.709]                       }
[08:27:51.709]                       invisible(muffled)
[08:27:51.709]                     }
[08:27:51.709]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.709]                   }
[08:27:51.709]                 }
[08:27:51.709]             }
[08:27:51.709]         }))
[08:27:51.709]     }, error = function(ex) {
[08:27:51.709]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.709]                 ...future.rng), started = ...future.startTime, 
[08:27:51.709]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.709]             version = "1.8"), class = "FutureResult")
[08:27:51.709]     }, finally = {
[08:27:51.709]         if (!identical(...future.workdir, getwd())) 
[08:27:51.709]             setwd(...future.workdir)
[08:27:51.709]         {
[08:27:51.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.709]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.709]             }
[08:27:51.709]             base::options(...future.oldOptions)
[08:27:51.709]             if (.Platform$OS.type == "windows") {
[08:27:51.709]                 old_names <- names(...future.oldEnvVars)
[08:27:51.709]                 envs <- base::Sys.getenv()
[08:27:51.709]                 names <- names(envs)
[08:27:51.709]                 common <- intersect(names, old_names)
[08:27:51.709]                 added <- setdiff(names, old_names)
[08:27:51.709]                 removed <- setdiff(old_names, names)
[08:27:51.709]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.709]                   envs[common]]
[08:27:51.709]                 NAMES <- toupper(changed)
[08:27:51.709]                 args <- list()
[08:27:51.709]                 for (kk in seq_along(NAMES)) {
[08:27:51.709]                   name <- changed[[kk]]
[08:27:51.709]                   NAME <- NAMES[[kk]]
[08:27:51.709]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.709]                     next
[08:27:51.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.709]                 }
[08:27:51.709]                 NAMES <- toupper(added)
[08:27:51.709]                 for (kk in seq_along(NAMES)) {
[08:27:51.709]                   name <- added[[kk]]
[08:27:51.709]                   NAME <- NAMES[[kk]]
[08:27:51.709]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.709]                     next
[08:27:51.709]                   args[[name]] <- ""
[08:27:51.709]                 }
[08:27:51.709]                 NAMES <- toupper(removed)
[08:27:51.709]                 for (kk in seq_along(NAMES)) {
[08:27:51.709]                   name <- removed[[kk]]
[08:27:51.709]                   NAME <- NAMES[[kk]]
[08:27:51.709]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.709]                     next
[08:27:51.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.709]                 }
[08:27:51.709]                 if (length(args) > 0) 
[08:27:51.709]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.709]             }
[08:27:51.709]             else {
[08:27:51.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.709]             }
[08:27:51.709]             {
[08:27:51.709]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.709]                   0L) {
[08:27:51.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.709]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.709]                   base::options(opts)
[08:27:51.709]                 }
[08:27:51.709]                 {
[08:27:51.709]                   {
[08:27:51.709]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.709]                     NULL
[08:27:51.709]                   }
[08:27:51.709]                   options(future.plan = NULL)
[08:27:51.709]                   if (is.na(NA_character_)) 
[08:27:51.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.709]                     .init = FALSE)
[08:27:51.709]                 }
[08:27:51.709]             }
[08:27:51.709]         }
[08:27:51.709]     })
[08:27:51.709]     if (TRUE) {
[08:27:51.709]         base::sink(type = "output", split = FALSE)
[08:27:51.709]         if (TRUE) {
[08:27:51.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.709]         }
[08:27:51.709]         else {
[08:27:51.709]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.709]         }
[08:27:51.709]         base::close(...future.stdout)
[08:27:51.709]         ...future.stdout <- NULL
[08:27:51.709]     }
[08:27:51.709]     ...future.result$conditions <- ...future.conditions
[08:27:51.709]     ...future.result$finished <- base::Sys.time()
[08:27:51.709]     ...future.result
[08:27:51.709] }
[08:27:51.763] MultisessionFuture started
[08:27:51.763] result() for ClusterFuture ...
[08:27:51.764] receiveMessageFromWorker() for ClusterFuture ...
[08:27:51.764] - Validating connection of MultisessionFuture
[08:27:51.795] - received message: FutureResult
[08:27:51.795] - Received FutureResult
[08:27:51.796] - Erased future from FutureRegistry
[08:27:51.796] result() for ClusterFuture ...
[08:27:51.796] - result already collected: FutureResult
[08:27:51.796] result() for ClusterFuture ... done
[08:27:51.796] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:51.796] result() for ClusterFuture ... done
[08:27:51.796] result() for ClusterFuture ...
[08:27:51.796] - result already collected: FutureResult
[08:27:51.796] result() for ClusterFuture ... done
[08:27:51.796] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:27:51.798] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[08:27:51.798] getGlobalsAndPackages() ...
[08:27:51.798] Searching for globals...
[08:27:51.799] 
[08:27:51.799] Searching for globals ... DONE
[08:27:51.799] - globals: [0] <none>
[08:27:51.799] getGlobalsAndPackages() ... DONE
[08:27:51.799] run() for ‘Future’ ...
[08:27:51.799] - state: ‘created’
[08:27:51.799] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.814] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.814] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:51.814]   - Field: ‘node’
[08:27:51.814]   - Field: ‘label’
[08:27:51.814]   - Field: ‘local’
[08:27:51.814]   - Field: ‘owner’
[08:27:51.814]   - Field: ‘envir’
[08:27:51.814]   - Field: ‘workers’
[08:27:51.814]   - Field: ‘packages’
[08:27:51.814]   - Field: ‘gc’
[08:27:51.815]   - Field: ‘conditions’
[08:27:51.815]   - Field: ‘persistent’
[08:27:51.815]   - Field: ‘expr’
[08:27:51.815]   - Field: ‘uuid’
[08:27:51.815]   - Field: ‘seed’
[08:27:51.815]   - Field: ‘version’
[08:27:51.815]   - Field: ‘result’
[08:27:51.815]   - Field: ‘asynchronous’
[08:27:51.815]   - Field: ‘calls’
[08:27:51.815]   - Field: ‘globals’
[08:27:51.815]   - Field: ‘stdout’
[08:27:51.816]   - Field: ‘earlySignal’
[08:27:51.816]   - Field: ‘lazy’
[08:27:51.816]   - Field: ‘state’
[08:27:51.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:51.816] - Launch lazy future ...
[08:27:51.816] Packages needed by the future expression (n = 0): <none>
[08:27:51.816] Packages needed by future strategies (n = 0): <none>
[08:27:51.817] {
[08:27:51.817]     {
[08:27:51.817]         {
[08:27:51.817]             ...future.startTime <- base::Sys.time()
[08:27:51.817]             {
[08:27:51.817]                 {
[08:27:51.817]                   {
[08:27:51.817]                     {
[08:27:51.817]                       base::local({
[08:27:51.817]                         has_future <- base::requireNamespace("future", 
[08:27:51.817]                           quietly = TRUE)
[08:27:51.817]                         if (has_future) {
[08:27:51.817]                           ns <- base::getNamespace("future")
[08:27:51.817]                           version <- ns[[".package"]][["version"]]
[08:27:51.817]                           if (is.null(version)) 
[08:27:51.817]                             version <- utils::packageVersion("future")
[08:27:51.817]                         }
[08:27:51.817]                         else {
[08:27:51.817]                           version <- NULL
[08:27:51.817]                         }
[08:27:51.817]                         if (!has_future || version < "1.8.0") {
[08:27:51.817]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.817]                             "", base::R.version$version.string), 
[08:27:51.817]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.817]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.817]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.817]                               "release", "version")], collapse = " "), 
[08:27:51.817]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.817]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.817]                             info)
[08:27:51.817]                           info <- base::paste(info, collapse = "; ")
[08:27:51.817]                           if (!has_future) {
[08:27:51.817]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.817]                               info)
[08:27:51.817]                           }
[08:27:51.817]                           else {
[08:27:51.817]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.817]                               info, version)
[08:27:51.817]                           }
[08:27:51.817]                           base::stop(msg)
[08:27:51.817]                         }
[08:27:51.817]                       })
[08:27:51.817]                     }
[08:27:51.817]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.817]                     base::options(mc.cores = 1L)
[08:27:51.817]                   }
[08:27:51.817]                   ...future.strategy.old <- future::plan("list")
[08:27:51.817]                   options(future.plan = NULL)
[08:27:51.817]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.817]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.817]                 }
[08:27:51.817]                 ...future.workdir <- getwd()
[08:27:51.817]             }
[08:27:51.817]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.817]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.817]         }
[08:27:51.817]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.817]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.817]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.817]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.817]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.817]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.817]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.817]             base::names(...future.oldOptions))
[08:27:51.817]     }
[08:27:51.817]     if (FALSE) {
[08:27:51.817]     }
[08:27:51.817]     else {
[08:27:51.817]         if (TRUE) {
[08:27:51.817]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.817]                 open = "w")
[08:27:51.817]         }
[08:27:51.817]         else {
[08:27:51.817]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.817]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.817]         }
[08:27:51.817]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.817]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.817]             base::sink(type = "output", split = FALSE)
[08:27:51.817]             base::close(...future.stdout)
[08:27:51.817]         }, add = TRUE)
[08:27:51.817]     }
[08:27:51.817]     ...future.frame <- base::sys.nframe()
[08:27:51.817]     ...future.conditions <- base::list()
[08:27:51.817]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.817]     if (FALSE) {
[08:27:51.817]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.817]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.817]     }
[08:27:51.817]     ...future.result <- base::tryCatch({
[08:27:51.817]         base::withCallingHandlers({
[08:27:51.817]             ...future.value <- base::withVisible(base::local({
[08:27:51.817]                 ...future.makeSendCondition <- base::local({
[08:27:51.817]                   sendCondition <- NULL
[08:27:51.817]                   function(frame = 1L) {
[08:27:51.817]                     if (is.function(sendCondition)) 
[08:27:51.817]                       return(sendCondition)
[08:27:51.817]                     ns <- getNamespace("parallel")
[08:27:51.817]                     if (exists("sendData", mode = "function", 
[08:27:51.817]                       envir = ns)) {
[08:27:51.817]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:51.817]                         envir = ns)
[08:27:51.817]                       envir <- sys.frame(frame)
[08:27:51.817]                       master <- NULL
[08:27:51.817]                       while (!identical(envir, .GlobalEnv) && 
[08:27:51.817]                         !identical(envir, emptyenv())) {
[08:27:51.817]                         if (exists("master", mode = "list", envir = envir, 
[08:27:51.817]                           inherits = FALSE)) {
[08:27:51.817]                           master <- get("master", mode = "list", 
[08:27:51.817]                             envir = envir, inherits = FALSE)
[08:27:51.817]                           if (inherits(master, c("SOCKnode", 
[08:27:51.817]                             "SOCK0node"))) {
[08:27:51.817]                             sendCondition <<- function(cond) {
[08:27:51.817]                               data <- list(type = "VALUE", value = cond, 
[08:27:51.817]                                 success = TRUE)
[08:27:51.817]                               parallel_sendData(master, data)
[08:27:51.817]                             }
[08:27:51.817]                             return(sendCondition)
[08:27:51.817]                           }
[08:27:51.817]                         }
[08:27:51.817]                         frame <- frame + 1L
[08:27:51.817]                         envir <- sys.frame(frame)
[08:27:51.817]                       }
[08:27:51.817]                     }
[08:27:51.817]                     sendCondition <<- function(cond) NULL
[08:27:51.817]                   }
[08:27:51.817]                 })
[08:27:51.817]                 withCallingHandlers({
[08:27:51.817]                   2
[08:27:51.817]                 }, immediateCondition = function(cond) {
[08:27:51.817]                   sendCondition <- ...future.makeSendCondition()
[08:27:51.817]                   sendCondition(cond)
[08:27:51.817]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.817]                   {
[08:27:51.817]                     inherits <- base::inherits
[08:27:51.817]                     invokeRestart <- base::invokeRestart
[08:27:51.817]                     is.null <- base::is.null
[08:27:51.817]                     muffled <- FALSE
[08:27:51.817]                     if (inherits(cond, "message")) {
[08:27:51.817]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.817]                       if (muffled) 
[08:27:51.817]                         invokeRestart("muffleMessage")
[08:27:51.817]                     }
[08:27:51.817]                     else if (inherits(cond, "warning")) {
[08:27:51.817]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.817]                       if (muffled) 
[08:27:51.817]                         invokeRestart("muffleWarning")
[08:27:51.817]                     }
[08:27:51.817]                     else if (inherits(cond, "condition")) {
[08:27:51.817]                       if (!is.null(pattern)) {
[08:27:51.817]                         computeRestarts <- base::computeRestarts
[08:27:51.817]                         grepl <- base::grepl
[08:27:51.817]                         restarts <- computeRestarts(cond)
[08:27:51.817]                         for (restart in restarts) {
[08:27:51.817]                           name <- restart$name
[08:27:51.817]                           if (is.null(name)) 
[08:27:51.817]                             next
[08:27:51.817]                           if (!grepl(pattern, name)) 
[08:27:51.817]                             next
[08:27:51.817]                           invokeRestart(restart)
[08:27:51.817]                           muffled <- TRUE
[08:27:51.817]                           break
[08:27:51.817]                         }
[08:27:51.817]                       }
[08:27:51.817]                     }
[08:27:51.817]                     invisible(muffled)
[08:27:51.817]                   }
[08:27:51.817]                   muffleCondition(cond)
[08:27:51.817]                 })
[08:27:51.817]             }))
[08:27:51.817]             future::FutureResult(value = ...future.value$value, 
[08:27:51.817]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.817]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.817]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.817]                     ...future.globalenv.names))
[08:27:51.817]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.817]         }, condition = base::local({
[08:27:51.817]             c <- base::c
[08:27:51.817]             inherits <- base::inherits
[08:27:51.817]             invokeRestart <- base::invokeRestart
[08:27:51.817]             length <- base::length
[08:27:51.817]             list <- base::list
[08:27:51.817]             seq.int <- base::seq.int
[08:27:51.817]             signalCondition <- base::signalCondition
[08:27:51.817]             sys.calls <- base::sys.calls
[08:27:51.817]             `[[` <- base::`[[`
[08:27:51.817]             `+` <- base::`+`
[08:27:51.817]             `<<-` <- base::`<<-`
[08:27:51.817]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.817]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.817]                   3L)]
[08:27:51.817]             }
[08:27:51.817]             function(cond) {
[08:27:51.817]                 is_error <- inherits(cond, "error")
[08:27:51.817]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.817]                   NULL)
[08:27:51.817]                 if (is_error) {
[08:27:51.817]                   sessionInformation <- function() {
[08:27:51.817]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.817]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.817]                       search = base::search(), system = base::Sys.info())
[08:27:51.817]                   }
[08:27:51.817]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.817]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.817]                     cond$call), session = sessionInformation(), 
[08:27:51.817]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.817]                   signalCondition(cond)
[08:27:51.817]                 }
[08:27:51.817]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.817]                 "immediateCondition"))) {
[08:27:51.817]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.817]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.817]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.817]                   if (TRUE && !signal) {
[08:27:51.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.817]                     {
[08:27:51.817]                       inherits <- base::inherits
[08:27:51.817]                       invokeRestart <- base::invokeRestart
[08:27:51.817]                       is.null <- base::is.null
[08:27:51.817]                       muffled <- FALSE
[08:27:51.817]                       if (inherits(cond, "message")) {
[08:27:51.817]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.817]                         if (muffled) 
[08:27:51.817]                           invokeRestart("muffleMessage")
[08:27:51.817]                       }
[08:27:51.817]                       else if (inherits(cond, "warning")) {
[08:27:51.817]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.817]                         if (muffled) 
[08:27:51.817]                           invokeRestart("muffleWarning")
[08:27:51.817]                       }
[08:27:51.817]                       else if (inherits(cond, "condition")) {
[08:27:51.817]                         if (!is.null(pattern)) {
[08:27:51.817]                           computeRestarts <- base::computeRestarts
[08:27:51.817]                           grepl <- base::grepl
[08:27:51.817]                           restarts <- computeRestarts(cond)
[08:27:51.817]                           for (restart in restarts) {
[08:27:51.817]                             name <- restart$name
[08:27:51.817]                             if (is.null(name)) 
[08:27:51.817]                               next
[08:27:51.817]                             if (!grepl(pattern, name)) 
[08:27:51.817]                               next
[08:27:51.817]                             invokeRestart(restart)
[08:27:51.817]                             muffled <- TRUE
[08:27:51.817]                             break
[08:27:51.817]                           }
[08:27:51.817]                         }
[08:27:51.817]                       }
[08:27:51.817]                       invisible(muffled)
[08:27:51.817]                     }
[08:27:51.817]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.817]                   }
[08:27:51.817]                 }
[08:27:51.817]                 else {
[08:27:51.817]                   if (TRUE) {
[08:27:51.817]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.817]                     {
[08:27:51.817]                       inherits <- base::inherits
[08:27:51.817]                       invokeRestart <- base::invokeRestart
[08:27:51.817]                       is.null <- base::is.null
[08:27:51.817]                       muffled <- FALSE
[08:27:51.817]                       if (inherits(cond, "message")) {
[08:27:51.817]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.817]                         if (muffled) 
[08:27:51.817]                           invokeRestart("muffleMessage")
[08:27:51.817]                       }
[08:27:51.817]                       else if (inherits(cond, "warning")) {
[08:27:51.817]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.817]                         if (muffled) 
[08:27:51.817]                           invokeRestart("muffleWarning")
[08:27:51.817]                       }
[08:27:51.817]                       else if (inherits(cond, "condition")) {
[08:27:51.817]                         if (!is.null(pattern)) {
[08:27:51.817]                           computeRestarts <- base::computeRestarts
[08:27:51.817]                           grepl <- base::grepl
[08:27:51.817]                           restarts <- computeRestarts(cond)
[08:27:51.817]                           for (restart in restarts) {
[08:27:51.817]                             name <- restart$name
[08:27:51.817]                             if (is.null(name)) 
[08:27:51.817]                               next
[08:27:51.817]                             if (!grepl(pattern, name)) 
[08:27:51.817]                               next
[08:27:51.817]                             invokeRestart(restart)
[08:27:51.817]                             muffled <- TRUE
[08:27:51.817]                             break
[08:27:51.817]                           }
[08:27:51.817]                         }
[08:27:51.817]                       }
[08:27:51.817]                       invisible(muffled)
[08:27:51.817]                     }
[08:27:51.817]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.817]                   }
[08:27:51.817]                 }
[08:27:51.817]             }
[08:27:51.817]         }))
[08:27:51.817]     }, error = function(ex) {
[08:27:51.817]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.817]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.817]                 ...future.rng), started = ...future.startTime, 
[08:27:51.817]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.817]             version = "1.8"), class = "FutureResult")
[08:27:51.817]     }, finally = {
[08:27:51.817]         if (!identical(...future.workdir, getwd())) 
[08:27:51.817]             setwd(...future.workdir)
[08:27:51.817]         {
[08:27:51.817]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.817]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.817]             }
[08:27:51.817]             base::options(...future.oldOptions)
[08:27:51.817]             if (.Platform$OS.type == "windows") {
[08:27:51.817]                 old_names <- names(...future.oldEnvVars)
[08:27:51.817]                 envs <- base::Sys.getenv()
[08:27:51.817]                 names <- names(envs)
[08:27:51.817]                 common <- intersect(names, old_names)
[08:27:51.817]                 added <- setdiff(names, old_names)
[08:27:51.817]                 removed <- setdiff(old_names, names)
[08:27:51.817]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.817]                   envs[common]]
[08:27:51.817]                 NAMES <- toupper(changed)
[08:27:51.817]                 args <- list()
[08:27:51.817]                 for (kk in seq_along(NAMES)) {
[08:27:51.817]                   name <- changed[[kk]]
[08:27:51.817]                   NAME <- NAMES[[kk]]
[08:27:51.817]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.817]                     next
[08:27:51.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.817]                 }
[08:27:51.817]                 NAMES <- toupper(added)
[08:27:51.817]                 for (kk in seq_along(NAMES)) {
[08:27:51.817]                   name <- added[[kk]]
[08:27:51.817]                   NAME <- NAMES[[kk]]
[08:27:51.817]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.817]                     next
[08:27:51.817]                   args[[name]] <- ""
[08:27:51.817]                 }
[08:27:51.817]                 NAMES <- toupper(removed)
[08:27:51.817]                 for (kk in seq_along(NAMES)) {
[08:27:51.817]                   name <- removed[[kk]]
[08:27:51.817]                   NAME <- NAMES[[kk]]
[08:27:51.817]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.817]                     next
[08:27:51.817]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.817]                 }
[08:27:51.817]                 if (length(args) > 0) 
[08:27:51.817]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.817]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.817]             }
[08:27:51.817]             else {
[08:27:51.817]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.817]             }
[08:27:51.817]             {
[08:27:51.817]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.817]                   0L) {
[08:27:51.817]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.817]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.817]                   base::options(opts)
[08:27:51.817]                 }
[08:27:51.817]                 {
[08:27:51.817]                   {
[08:27:51.817]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.817]                     NULL
[08:27:51.817]                   }
[08:27:51.817]                   options(future.plan = NULL)
[08:27:51.817]                   if (is.na(NA_character_)) 
[08:27:51.817]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.817]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.817]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.817]                     .init = FALSE)
[08:27:51.817]                 }
[08:27:51.817]             }
[08:27:51.817]         }
[08:27:51.817]     })
[08:27:51.817]     if (TRUE) {
[08:27:51.817]         base::sink(type = "output", split = FALSE)
[08:27:51.817]         if (TRUE) {
[08:27:51.817]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.817]         }
[08:27:51.817]         else {
[08:27:51.817]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.817]         }
[08:27:51.817]         base::close(...future.stdout)
[08:27:51.817]         ...future.stdout <- NULL
[08:27:51.817]     }
[08:27:51.817]     ...future.result$conditions <- ...future.conditions
[08:27:51.817]     ...future.result$finished <- base::Sys.time()
[08:27:51.817]     ...future.result
[08:27:51.817] }
[08:27:51.820] MultisessionFuture started
[08:27:51.820] - Launch lazy future ... done
[08:27:51.820] run() for ‘MultisessionFuture’ ... done
[08:27:51.820] getGlobalsAndPackages() ...
[08:27:51.820] Searching for globals...
[08:27:51.821] 
[08:27:51.821] Searching for globals ... DONE
[08:27:51.821] - globals: [0] <none>
[08:27:51.821] getGlobalsAndPackages() ... DONE
[08:27:51.821] run() for ‘Future’ ...
[08:27:51.821] - state: ‘created’
[08:27:51.821] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.836] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.837] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:51.837]   - Field: ‘node’
[08:27:51.837]   - Field: ‘label’
[08:27:51.837]   - Field: ‘local’
[08:27:51.837]   - Field: ‘owner’
[08:27:51.837]   - Field: ‘envir’
[08:27:51.837]   - Field: ‘workers’
[08:27:51.837]   - Field: ‘packages’
[08:27:51.837]   - Field: ‘gc’
[08:27:51.837]   - Field: ‘conditions’
[08:27:51.838]   - Field: ‘persistent’
[08:27:51.838]   - Field: ‘expr’
[08:27:51.838]   - Field: ‘uuid’
[08:27:51.838]   - Field: ‘seed’
[08:27:51.838]   - Field: ‘version’
[08:27:51.838]   - Field: ‘result’
[08:27:51.838]   - Field: ‘asynchronous’
[08:27:51.838]   - Field: ‘calls’
[08:27:51.838]   - Field: ‘globals’
[08:27:51.838]   - Field: ‘stdout’
[08:27:51.838]   - Field: ‘earlySignal’
[08:27:51.838]   - Field: ‘lazy’
[08:27:51.839]   - Field: ‘state’
[08:27:51.839] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:51.839] - Launch lazy future ...
[08:27:51.839] Packages needed by the future expression (n = 0): <none>
[08:27:51.839] Packages needed by future strategies (n = 0): <none>
[08:27:51.840] {
[08:27:51.840]     {
[08:27:51.840]         {
[08:27:51.840]             ...future.startTime <- base::Sys.time()
[08:27:51.840]             {
[08:27:51.840]                 {
[08:27:51.840]                   {
[08:27:51.840]                     {
[08:27:51.840]                       base::local({
[08:27:51.840]                         has_future <- base::requireNamespace("future", 
[08:27:51.840]                           quietly = TRUE)
[08:27:51.840]                         if (has_future) {
[08:27:51.840]                           ns <- base::getNamespace("future")
[08:27:51.840]                           version <- ns[[".package"]][["version"]]
[08:27:51.840]                           if (is.null(version)) 
[08:27:51.840]                             version <- utils::packageVersion("future")
[08:27:51.840]                         }
[08:27:51.840]                         else {
[08:27:51.840]                           version <- NULL
[08:27:51.840]                         }
[08:27:51.840]                         if (!has_future || version < "1.8.0") {
[08:27:51.840]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.840]                             "", base::R.version$version.string), 
[08:27:51.840]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.840]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.840]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.840]                               "release", "version")], collapse = " "), 
[08:27:51.840]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.840]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.840]                             info)
[08:27:51.840]                           info <- base::paste(info, collapse = "; ")
[08:27:51.840]                           if (!has_future) {
[08:27:51.840]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.840]                               info)
[08:27:51.840]                           }
[08:27:51.840]                           else {
[08:27:51.840]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.840]                               info, version)
[08:27:51.840]                           }
[08:27:51.840]                           base::stop(msg)
[08:27:51.840]                         }
[08:27:51.840]                       })
[08:27:51.840]                     }
[08:27:51.840]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.840]                     base::options(mc.cores = 1L)
[08:27:51.840]                   }
[08:27:51.840]                   ...future.strategy.old <- future::plan("list")
[08:27:51.840]                   options(future.plan = NULL)
[08:27:51.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.840]                 }
[08:27:51.840]                 ...future.workdir <- getwd()
[08:27:51.840]             }
[08:27:51.840]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.840]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.840]         }
[08:27:51.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.840]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.840]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.840]             base::names(...future.oldOptions))
[08:27:51.840]     }
[08:27:51.840]     if (FALSE) {
[08:27:51.840]     }
[08:27:51.840]     else {
[08:27:51.840]         if (TRUE) {
[08:27:51.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.840]                 open = "w")
[08:27:51.840]         }
[08:27:51.840]         else {
[08:27:51.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.840]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.840]         }
[08:27:51.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.840]             base::sink(type = "output", split = FALSE)
[08:27:51.840]             base::close(...future.stdout)
[08:27:51.840]         }, add = TRUE)
[08:27:51.840]     }
[08:27:51.840]     ...future.frame <- base::sys.nframe()
[08:27:51.840]     ...future.conditions <- base::list()
[08:27:51.840]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.840]     if (FALSE) {
[08:27:51.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.840]     }
[08:27:51.840]     ...future.result <- base::tryCatch({
[08:27:51.840]         base::withCallingHandlers({
[08:27:51.840]             ...future.value <- base::withVisible(base::local({
[08:27:51.840]                 ...future.makeSendCondition <- base::local({
[08:27:51.840]                   sendCondition <- NULL
[08:27:51.840]                   function(frame = 1L) {
[08:27:51.840]                     if (is.function(sendCondition)) 
[08:27:51.840]                       return(sendCondition)
[08:27:51.840]                     ns <- getNamespace("parallel")
[08:27:51.840]                     if (exists("sendData", mode = "function", 
[08:27:51.840]                       envir = ns)) {
[08:27:51.840]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:51.840]                         envir = ns)
[08:27:51.840]                       envir <- sys.frame(frame)
[08:27:51.840]                       master <- NULL
[08:27:51.840]                       while (!identical(envir, .GlobalEnv) && 
[08:27:51.840]                         !identical(envir, emptyenv())) {
[08:27:51.840]                         if (exists("master", mode = "list", envir = envir, 
[08:27:51.840]                           inherits = FALSE)) {
[08:27:51.840]                           master <- get("master", mode = "list", 
[08:27:51.840]                             envir = envir, inherits = FALSE)
[08:27:51.840]                           if (inherits(master, c("SOCKnode", 
[08:27:51.840]                             "SOCK0node"))) {
[08:27:51.840]                             sendCondition <<- function(cond) {
[08:27:51.840]                               data <- list(type = "VALUE", value = cond, 
[08:27:51.840]                                 success = TRUE)
[08:27:51.840]                               parallel_sendData(master, data)
[08:27:51.840]                             }
[08:27:51.840]                             return(sendCondition)
[08:27:51.840]                           }
[08:27:51.840]                         }
[08:27:51.840]                         frame <- frame + 1L
[08:27:51.840]                         envir <- sys.frame(frame)
[08:27:51.840]                       }
[08:27:51.840]                     }
[08:27:51.840]                     sendCondition <<- function(cond) NULL
[08:27:51.840]                   }
[08:27:51.840]                 })
[08:27:51.840]                 withCallingHandlers({
[08:27:51.840]                   NULL
[08:27:51.840]                 }, immediateCondition = function(cond) {
[08:27:51.840]                   sendCondition <- ...future.makeSendCondition()
[08:27:51.840]                   sendCondition(cond)
[08:27:51.840]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.840]                   {
[08:27:51.840]                     inherits <- base::inherits
[08:27:51.840]                     invokeRestart <- base::invokeRestart
[08:27:51.840]                     is.null <- base::is.null
[08:27:51.840]                     muffled <- FALSE
[08:27:51.840]                     if (inherits(cond, "message")) {
[08:27:51.840]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.840]                       if (muffled) 
[08:27:51.840]                         invokeRestart("muffleMessage")
[08:27:51.840]                     }
[08:27:51.840]                     else if (inherits(cond, "warning")) {
[08:27:51.840]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.840]                       if (muffled) 
[08:27:51.840]                         invokeRestart("muffleWarning")
[08:27:51.840]                     }
[08:27:51.840]                     else if (inherits(cond, "condition")) {
[08:27:51.840]                       if (!is.null(pattern)) {
[08:27:51.840]                         computeRestarts <- base::computeRestarts
[08:27:51.840]                         grepl <- base::grepl
[08:27:51.840]                         restarts <- computeRestarts(cond)
[08:27:51.840]                         for (restart in restarts) {
[08:27:51.840]                           name <- restart$name
[08:27:51.840]                           if (is.null(name)) 
[08:27:51.840]                             next
[08:27:51.840]                           if (!grepl(pattern, name)) 
[08:27:51.840]                             next
[08:27:51.840]                           invokeRestart(restart)
[08:27:51.840]                           muffled <- TRUE
[08:27:51.840]                           break
[08:27:51.840]                         }
[08:27:51.840]                       }
[08:27:51.840]                     }
[08:27:51.840]                     invisible(muffled)
[08:27:51.840]                   }
[08:27:51.840]                   muffleCondition(cond)
[08:27:51.840]                 })
[08:27:51.840]             }))
[08:27:51.840]             future::FutureResult(value = ...future.value$value, 
[08:27:51.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.840]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.840]                     ...future.globalenv.names))
[08:27:51.840]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.840]         }, condition = base::local({
[08:27:51.840]             c <- base::c
[08:27:51.840]             inherits <- base::inherits
[08:27:51.840]             invokeRestart <- base::invokeRestart
[08:27:51.840]             length <- base::length
[08:27:51.840]             list <- base::list
[08:27:51.840]             seq.int <- base::seq.int
[08:27:51.840]             signalCondition <- base::signalCondition
[08:27:51.840]             sys.calls <- base::sys.calls
[08:27:51.840]             `[[` <- base::`[[`
[08:27:51.840]             `+` <- base::`+`
[08:27:51.840]             `<<-` <- base::`<<-`
[08:27:51.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.840]                   3L)]
[08:27:51.840]             }
[08:27:51.840]             function(cond) {
[08:27:51.840]                 is_error <- inherits(cond, "error")
[08:27:51.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.840]                   NULL)
[08:27:51.840]                 if (is_error) {
[08:27:51.840]                   sessionInformation <- function() {
[08:27:51.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.840]                       search = base::search(), system = base::Sys.info())
[08:27:51.840]                   }
[08:27:51.840]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.840]                     cond$call), session = sessionInformation(), 
[08:27:51.840]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.840]                   signalCondition(cond)
[08:27:51.840]                 }
[08:27:51.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.840]                 "immediateCondition"))) {
[08:27:51.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.840]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.840]                   if (TRUE && !signal) {
[08:27:51.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.840]                     {
[08:27:51.840]                       inherits <- base::inherits
[08:27:51.840]                       invokeRestart <- base::invokeRestart
[08:27:51.840]                       is.null <- base::is.null
[08:27:51.840]                       muffled <- FALSE
[08:27:51.840]                       if (inherits(cond, "message")) {
[08:27:51.840]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.840]                         if (muffled) 
[08:27:51.840]                           invokeRestart("muffleMessage")
[08:27:51.840]                       }
[08:27:51.840]                       else if (inherits(cond, "warning")) {
[08:27:51.840]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.840]                         if (muffled) 
[08:27:51.840]                           invokeRestart("muffleWarning")
[08:27:51.840]                       }
[08:27:51.840]                       else if (inherits(cond, "condition")) {
[08:27:51.840]                         if (!is.null(pattern)) {
[08:27:51.840]                           computeRestarts <- base::computeRestarts
[08:27:51.840]                           grepl <- base::grepl
[08:27:51.840]                           restarts <- computeRestarts(cond)
[08:27:51.840]                           for (restart in restarts) {
[08:27:51.840]                             name <- restart$name
[08:27:51.840]                             if (is.null(name)) 
[08:27:51.840]                               next
[08:27:51.840]                             if (!grepl(pattern, name)) 
[08:27:51.840]                               next
[08:27:51.840]                             invokeRestart(restart)
[08:27:51.840]                             muffled <- TRUE
[08:27:51.840]                             break
[08:27:51.840]                           }
[08:27:51.840]                         }
[08:27:51.840]                       }
[08:27:51.840]                       invisible(muffled)
[08:27:51.840]                     }
[08:27:51.840]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.840]                   }
[08:27:51.840]                 }
[08:27:51.840]                 else {
[08:27:51.840]                   if (TRUE) {
[08:27:51.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.840]                     {
[08:27:51.840]                       inherits <- base::inherits
[08:27:51.840]                       invokeRestart <- base::invokeRestart
[08:27:51.840]                       is.null <- base::is.null
[08:27:51.840]                       muffled <- FALSE
[08:27:51.840]                       if (inherits(cond, "message")) {
[08:27:51.840]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.840]                         if (muffled) 
[08:27:51.840]                           invokeRestart("muffleMessage")
[08:27:51.840]                       }
[08:27:51.840]                       else if (inherits(cond, "warning")) {
[08:27:51.840]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.840]                         if (muffled) 
[08:27:51.840]                           invokeRestart("muffleWarning")
[08:27:51.840]                       }
[08:27:51.840]                       else if (inherits(cond, "condition")) {
[08:27:51.840]                         if (!is.null(pattern)) {
[08:27:51.840]                           computeRestarts <- base::computeRestarts
[08:27:51.840]                           grepl <- base::grepl
[08:27:51.840]                           restarts <- computeRestarts(cond)
[08:27:51.840]                           for (restart in restarts) {
[08:27:51.840]                             name <- restart$name
[08:27:51.840]                             if (is.null(name)) 
[08:27:51.840]                               next
[08:27:51.840]                             if (!grepl(pattern, name)) 
[08:27:51.840]                               next
[08:27:51.840]                             invokeRestart(restart)
[08:27:51.840]                             muffled <- TRUE
[08:27:51.840]                             break
[08:27:51.840]                           }
[08:27:51.840]                         }
[08:27:51.840]                       }
[08:27:51.840]                       invisible(muffled)
[08:27:51.840]                     }
[08:27:51.840]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.840]                   }
[08:27:51.840]                 }
[08:27:51.840]             }
[08:27:51.840]         }))
[08:27:51.840]     }, error = function(ex) {
[08:27:51.840]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.840]                 ...future.rng), started = ...future.startTime, 
[08:27:51.840]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.840]             version = "1.8"), class = "FutureResult")
[08:27:51.840]     }, finally = {
[08:27:51.840]         if (!identical(...future.workdir, getwd())) 
[08:27:51.840]             setwd(...future.workdir)
[08:27:51.840]         {
[08:27:51.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.840]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.840]             }
[08:27:51.840]             base::options(...future.oldOptions)
[08:27:51.840]             if (.Platform$OS.type == "windows") {
[08:27:51.840]                 old_names <- names(...future.oldEnvVars)
[08:27:51.840]                 envs <- base::Sys.getenv()
[08:27:51.840]                 names <- names(envs)
[08:27:51.840]                 common <- intersect(names, old_names)
[08:27:51.840]                 added <- setdiff(names, old_names)
[08:27:51.840]                 removed <- setdiff(old_names, names)
[08:27:51.840]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.840]                   envs[common]]
[08:27:51.840]                 NAMES <- toupper(changed)
[08:27:51.840]                 args <- list()
[08:27:51.840]                 for (kk in seq_along(NAMES)) {
[08:27:51.840]                   name <- changed[[kk]]
[08:27:51.840]                   NAME <- NAMES[[kk]]
[08:27:51.840]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.840]                     next
[08:27:51.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.840]                 }
[08:27:51.840]                 NAMES <- toupper(added)
[08:27:51.840]                 for (kk in seq_along(NAMES)) {
[08:27:51.840]                   name <- added[[kk]]
[08:27:51.840]                   NAME <- NAMES[[kk]]
[08:27:51.840]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.840]                     next
[08:27:51.840]                   args[[name]] <- ""
[08:27:51.840]                 }
[08:27:51.840]                 NAMES <- toupper(removed)
[08:27:51.840]                 for (kk in seq_along(NAMES)) {
[08:27:51.840]                   name <- removed[[kk]]
[08:27:51.840]                   NAME <- NAMES[[kk]]
[08:27:51.840]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.840]                     next
[08:27:51.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.840]                 }
[08:27:51.840]                 if (length(args) > 0) 
[08:27:51.840]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.840]             }
[08:27:51.840]             else {
[08:27:51.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.840]             }
[08:27:51.840]             {
[08:27:51.840]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.840]                   0L) {
[08:27:51.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.840]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.840]                   base::options(opts)
[08:27:51.840]                 }
[08:27:51.840]                 {
[08:27:51.840]                   {
[08:27:51.840]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.840]                     NULL
[08:27:51.840]                   }
[08:27:51.840]                   options(future.plan = NULL)
[08:27:51.840]                   if (is.na(NA_character_)) 
[08:27:51.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.840]                     .init = FALSE)
[08:27:51.840]                 }
[08:27:51.840]             }
[08:27:51.840]         }
[08:27:51.840]     })
[08:27:51.840]     if (TRUE) {
[08:27:51.840]         base::sink(type = "output", split = FALSE)
[08:27:51.840]         if (TRUE) {
[08:27:51.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.840]         }
[08:27:51.840]         else {
[08:27:51.840]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.840]         }
[08:27:51.840]         base::close(...future.stdout)
[08:27:51.840]         ...future.stdout <- NULL
[08:27:51.840]     }
[08:27:51.840]     ...future.result$conditions <- ...future.conditions
[08:27:51.840]     ...future.result$finished <- base::Sys.time()
[08:27:51.840]     ...future.result
[08:27:51.840] }
[08:27:51.893] MultisessionFuture started
[08:27:51.894] - Launch lazy future ... done
[08:27:51.894] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860af6488> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d85ef168b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d860af6488> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d85ef168b0> 
 $  : NULL
 $  : NULL
 $  : num 6
[08:27:51.899] receiveMessageFromWorker() for ClusterFuture ...
[08:27:51.900] - Validating connection of MultisessionFuture
[08:27:51.900] - received message: FutureResult
[08:27:51.900] - Received FutureResult
[08:27:51.900] - Erased future from FutureRegistry
[08:27:51.900] result() for ClusterFuture ...
[08:27:51.900] - result already collected: FutureResult
[08:27:51.900] result() for ClusterFuture ... done
[08:27:51.900] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:51.912] resolve() on list ...
[08:27:51.912]  recursive: 0
[08:27:51.912]  length: 6
[08:27:51.912]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:51.912] signalConditionsASAP(numeric, pos=1) ...
[08:27:51.913] - nx: 6
[08:27:51.913] - relay: TRUE
[08:27:51.913] - stdout: TRUE
[08:27:51.913] - signal: TRUE
[08:27:51.913] - resignal: FALSE
[08:27:51.913] - force: TRUE
[08:27:51.913] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.913] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.913]  - until=2
[08:27:51.914]  - relaying element #2
[08:27:51.914] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.914] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.914] signalConditionsASAP(NULL, pos=1) ... done
[08:27:51.914]  length: 5 (resolved future 1)
[08:27:51.914] Future #2
[08:27:51.914] result() for ClusterFuture ...
[08:27:51.914] - result already collected: FutureResult
[08:27:51.914] result() for ClusterFuture ... done
[08:27:51.915] result() for ClusterFuture ...
[08:27:51.915] - result already collected: FutureResult
[08:27:51.915] result() for ClusterFuture ... done
[08:27:51.915] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:51.915] - nx: 6
[08:27:51.915] - relay: TRUE
[08:27:51.915] - stdout: TRUE
[08:27:51.915] - signal: TRUE
[08:27:51.915] - resignal: FALSE
[08:27:51.915] - force: TRUE
[08:27:51.916] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.916] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:51.916]  - until=2
[08:27:51.916]  - relaying element #2
[08:27:51.916] result() for ClusterFuture ...
[08:27:51.916] - result already collected: FutureResult
[08:27:51.916] result() for ClusterFuture ... done
[08:27:51.916] result() for ClusterFuture ...
[08:27:51.916] - result already collected: FutureResult
[08:27:51.917] result() for ClusterFuture ... done
[08:27:51.917] result() for ClusterFuture ...
[08:27:51.917] - result already collected: FutureResult
[08:27:51.917] result() for ClusterFuture ... done
[08:27:51.917] result() for ClusterFuture ...
[08:27:51.917] - result already collected: FutureResult
[08:27:51.917] result() for ClusterFuture ... done
[08:27:51.917] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.917] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.917] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:51.918]  length: 4 (resolved future 2)
[08:27:51.926] receiveMessageFromWorker() for ClusterFuture ...
[08:27:51.926] - Validating connection of MultisessionFuture
[08:27:51.926] - received message: FutureResult
[08:27:51.926] - Received FutureResult
[08:27:51.926] - Erased future from FutureRegistry
[08:27:51.927] result() for ClusterFuture ...
[08:27:51.927] - result already collected: FutureResult
[08:27:51.927] result() for ClusterFuture ... done
[08:27:51.927] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:51.927] Future #3
[08:27:51.927] result() for ClusterFuture ...
[08:27:51.927] - result already collected: FutureResult
[08:27:51.927] result() for ClusterFuture ... done
[08:27:51.927] result() for ClusterFuture ...
[08:27:51.927] - result already collected: FutureResult
[08:27:51.928] result() for ClusterFuture ... done
[08:27:51.928] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:51.928] - nx: 6
[08:27:51.928] - relay: TRUE
[08:27:51.928] - stdout: TRUE
[08:27:51.928] - signal: TRUE
[08:27:51.928] - resignal: FALSE
[08:27:51.928] - force: TRUE
[08:27:51.928] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.928] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:51.929]  - until=3
[08:27:51.929]  - relaying element #3
[08:27:51.929] result() for ClusterFuture ...
[08:27:51.929] - result already collected: FutureResult
[08:27:51.929] result() for ClusterFuture ... done
[08:27:51.929] result() for ClusterFuture ...
[08:27:51.929] - result already collected: FutureResult
[08:27:51.929] result() for ClusterFuture ... done
[08:27:51.929] result() for ClusterFuture ...
[08:27:51.930] - result already collected: FutureResult
[08:27:51.930] result() for ClusterFuture ... done
[08:27:51.930] result() for ClusterFuture ...
[08:27:51.930] - result already collected: FutureResult
[08:27:51.930] result() for ClusterFuture ... done
[08:27:51.930] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.930] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.930] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:51.930]  length: 3 (resolved future 3)
[08:27:51.930] signalConditionsASAP(NULL, pos=4) ...
[08:27:51.931] - nx: 6
[08:27:51.931] - relay: TRUE
[08:27:51.931] - stdout: TRUE
[08:27:51.931] - signal: TRUE
[08:27:51.931] - resignal: FALSE
[08:27:51.931] - force: TRUE
[08:27:51.931] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.931]  - until=5
[08:27:51.931]  - relaying element #5
[08:27:51.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:51.932] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.932] signalConditionsASAP(NULL, pos=4) ... done
[08:27:51.932]  length: 2 (resolved future 4)
[08:27:51.932] signalConditionsASAP(NULL, pos=5) ...
[08:27:51.932] - nx: 6
[08:27:51.932] - relay: TRUE
[08:27:51.932] - stdout: TRUE
[08:27:51.932] - signal: TRUE
[08:27:51.932] - resignal: FALSE
[08:27:51.933] - force: TRUE
[08:27:51.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:51.933] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.933]  - until=6
[08:27:51.933]  - relaying element #6
[08:27:51.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:51.933] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.933] signalConditionsASAP(NULL, pos=5) ... done
[08:27:51.933]  length: 1 (resolved future 5)
[08:27:51.933] signalConditionsASAP(numeric, pos=6) ...
[08:27:51.934] - nx: 6
[08:27:51.934] - relay: TRUE
[08:27:51.934] - stdout: TRUE
[08:27:51.934] - signal: TRUE
[08:27:51.934] - resignal: FALSE
[08:27:51.934] - force: TRUE
[08:27:51.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:51.934] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.934]  - until=6
[08:27:51.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.935] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.935] signalConditionsASAP(numeric, pos=6) ... done
[08:27:51.935]  length: 0 (resolved future 6)
[08:27:51.935] Relaying remaining futures
[08:27:51.935] signalConditionsASAP(NULL, pos=0) ...
[08:27:51.935] - nx: 6
[08:27:51.935] - relay: TRUE
[08:27:51.935] - stdout: TRUE
[08:27:51.935] - signal: TRUE
[08:27:51.935] - resignal: FALSE
[08:27:51.935] - force: TRUE
[08:27:51.936] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.936] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:51.936] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:51.936] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:51.936] signalConditionsASAP(NULL, pos=0) ... done
[08:27:51.936] resolve() on list ... DONE
[08:27:51.936] result() for ClusterFuture ...
[08:27:51.936] - result already collected: FutureResult
[08:27:51.937] result() for ClusterFuture ... done
[08:27:51.937] result() for ClusterFuture ...
[08:27:51.937] - result already collected: FutureResult
[08:27:51.937] result() for ClusterFuture ... done
[08:27:51.937] result() for ClusterFuture ...
[08:27:51.937] - result already collected: FutureResult
[08:27:51.937] result() for ClusterFuture ... done
[08:27:51.937] result() for ClusterFuture ...
[08:27:51.937] - result already collected: FutureResult
[08:27:51.937] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[08:27:51.940] getGlobalsAndPackages() ...
[08:27:51.940] Searching for globals...
[08:27:51.941] 
[08:27:51.941] Searching for globals ... DONE
[08:27:51.941] - globals: [0] <none>
[08:27:51.941] getGlobalsAndPackages() ... DONE
[08:27:51.941] run() for ‘Future’ ...
[08:27:51.941] - state: ‘created’
[08:27:51.942] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.957] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.957] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:51.957]   - Field: ‘node’
[08:27:51.957]   - Field: ‘label’
[08:27:51.957]   - Field: ‘local’
[08:27:51.957]   - Field: ‘owner’
[08:27:51.957]   - Field: ‘envir’
[08:27:51.958]   - Field: ‘workers’
[08:27:51.958]   - Field: ‘packages’
[08:27:51.958]   - Field: ‘gc’
[08:27:51.958]   - Field: ‘conditions’
[08:27:51.958]   - Field: ‘persistent’
[08:27:51.958]   - Field: ‘expr’
[08:27:51.958]   - Field: ‘uuid’
[08:27:51.958]   - Field: ‘seed’
[08:27:51.958]   - Field: ‘version’
[08:27:51.958]   - Field: ‘result’
[08:27:51.959]   - Field: ‘asynchronous’
[08:27:51.959]   - Field: ‘calls’
[08:27:51.959]   - Field: ‘globals’
[08:27:51.959]   - Field: ‘stdout’
[08:27:51.959]   - Field: ‘earlySignal’
[08:27:51.959]   - Field: ‘lazy’
[08:27:51.959]   - Field: ‘state’
[08:27:51.959] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:51.959] - Launch lazy future ...
[08:27:51.960] Packages needed by the future expression (n = 0): <none>
[08:27:51.960] Packages needed by future strategies (n = 0): <none>
[08:27:51.960] {
[08:27:51.960]     {
[08:27:51.960]         {
[08:27:51.960]             ...future.startTime <- base::Sys.time()
[08:27:51.960]             {
[08:27:51.960]                 {
[08:27:51.960]                   {
[08:27:51.960]                     {
[08:27:51.960]                       base::local({
[08:27:51.960]                         has_future <- base::requireNamespace("future", 
[08:27:51.960]                           quietly = TRUE)
[08:27:51.960]                         if (has_future) {
[08:27:51.960]                           ns <- base::getNamespace("future")
[08:27:51.960]                           version <- ns[[".package"]][["version"]]
[08:27:51.960]                           if (is.null(version)) 
[08:27:51.960]                             version <- utils::packageVersion("future")
[08:27:51.960]                         }
[08:27:51.960]                         else {
[08:27:51.960]                           version <- NULL
[08:27:51.960]                         }
[08:27:51.960]                         if (!has_future || version < "1.8.0") {
[08:27:51.960]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.960]                             "", base::R.version$version.string), 
[08:27:51.960]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.960]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.960]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.960]                               "release", "version")], collapse = " "), 
[08:27:51.960]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.960]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.960]                             info)
[08:27:51.960]                           info <- base::paste(info, collapse = "; ")
[08:27:51.960]                           if (!has_future) {
[08:27:51.960]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.960]                               info)
[08:27:51.960]                           }
[08:27:51.960]                           else {
[08:27:51.960]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.960]                               info, version)
[08:27:51.960]                           }
[08:27:51.960]                           base::stop(msg)
[08:27:51.960]                         }
[08:27:51.960]                       })
[08:27:51.960]                     }
[08:27:51.960]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.960]                     base::options(mc.cores = 1L)
[08:27:51.960]                   }
[08:27:51.960]                   ...future.strategy.old <- future::plan("list")
[08:27:51.960]                   options(future.plan = NULL)
[08:27:51.960]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.960]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.960]                 }
[08:27:51.960]                 ...future.workdir <- getwd()
[08:27:51.960]             }
[08:27:51.960]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.960]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.960]         }
[08:27:51.960]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.960]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.960]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.960]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.960]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.960]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.960]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.960]             base::names(...future.oldOptions))
[08:27:51.960]     }
[08:27:51.960]     if (FALSE) {
[08:27:51.960]     }
[08:27:51.960]     else {
[08:27:51.960]         if (TRUE) {
[08:27:51.960]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.960]                 open = "w")
[08:27:51.960]         }
[08:27:51.960]         else {
[08:27:51.960]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.960]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.960]         }
[08:27:51.960]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.960]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.960]             base::sink(type = "output", split = FALSE)
[08:27:51.960]             base::close(...future.stdout)
[08:27:51.960]         }, add = TRUE)
[08:27:51.960]     }
[08:27:51.960]     ...future.frame <- base::sys.nframe()
[08:27:51.960]     ...future.conditions <- base::list()
[08:27:51.960]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.960]     if (FALSE) {
[08:27:51.960]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.960]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.960]     }
[08:27:51.960]     ...future.result <- base::tryCatch({
[08:27:51.960]         base::withCallingHandlers({
[08:27:51.960]             ...future.value <- base::withVisible(base::local({
[08:27:51.960]                 ...future.makeSendCondition <- base::local({
[08:27:51.960]                   sendCondition <- NULL
[08:27:51.960]                   function(frame = 1L) {
[08:27:51.960]                     if (is.function(sendCondition)) 
[08:27:51.960]                       return(sendCondition)
[08:27:51.960]                     ns <- getNamespace("parallel")
[08:27:51.960]                     if (exists("sendData", mode = "function", 
[08:27:51.960]                       envir = ns)) {
[08:27:51.960]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:51.960]                         envir = ns)
[08:27:51.960]                       envir <- sys.frame(frame)
[08:27:51.960]                       master <- NULL
[08:27:51.960]                       while (!identical(envir, .GlobalEnv) && 
[08:27:51.960]                         !identical(envir, emptyenv())) {
[08:27:51.960]                         if (exists("master", mode = "list", envir = envir, 
[08:27:51.960]                           inherits = FALSE)) {
[08:27:51.960]                           master <- get("master", mode = "list", 
[08:27:51.960]                             envir = envir, inherits = FALSE)
[08:27:51.960]                           if (inherits(master, c("SOCKnode", 
[08:27:51.960]                             "SOCK0node"))) {
[08:27:51.960]                             sendCondition <<- function(cond) {
[08:27:51.960]                               data <- list(type = "VALUE", value = cond, 
[08:27:51.960]                                 success = TRUE)
[08:27:51.960]                               parallel_sendData(master, data)
[08:27:51.960]                             }
[08:27:51.960]                             return(sendCondition)
[08:27:51.960]                           }
[08:27:51.960]                         }
[08:27:51.960]                         frame <- frame + 1L
[08:27:51.960]                         envir <- sys.frame(frame)
[08:27:51.960]                       }
[08:27:51.960]                     }
[08:27:51.960]                     sendCondition <<- function(cond) NULL
[08:27:51.960]                   }
[08:27:51.960]                 })
[08:27:51.960]                 withCallingHandlers({
[08:27:51.960]                   2
[08:27:51.960]                 }, immediateCondition = function(cond) {
[08:27:51.960]                   sendCondition <- ...future.makeSendCondition()
[08:27:51.960]                   sendCondition(cond)
[08:27:51.960]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.960]                   {
[08:27:51.960]                     inherits <- base::inherits
[08:27:51.960]                     invokeRestart <- base::invokeRestart
[08:27:51.960]                     is.null <- base::is.null
[08:27:51.960]                     muffled <- FALSE
[08:27:51.960]                     if (inherits(cond, "message")) {
[08:27:51.960]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.960]                       if (muffled) 
[08:27:51.960]                         invokeRestart("muffleMessage")
[08:27:51.960]                     }
[08:27:51.960]                     else if (inherits(cond, "warning")) {
[08:27:51.960]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.960]                       if (muffled) 
[08:27:51.960]                         invokeRestart("muffleWarning")
[08:27:51.960]                     }
[08:27:51.960]                     else if (inherits(cond, "condition")) {
[08:27:51.960]                       if (!is.null(pattern)) {
[08:27:51.960]                         computeRestarts <- base::computeRestarts
[08:27:51.960]                         grepl <- base::grepl
[08:27:51.960]                         restarts <- computeRestarts(cond)
[08:27:51.960]                         for (restart in restarts) {
[08:27:51.960]                           name <- restart$name
[08:27:51.960]                           if (is.null(name)) 
[08:27:51.960]                             next
[08:27:51.960]                           if (!grepl(pattern, name)) 
[08:27:51.960]                             next
[08:27:51.960]                           invokeRestart(restart)
[08:27:51.960]                           muffled <- TRUE
[08:27:51.960]                           break
[08:27:51.960]                         }
[08:27:51.960]                       }
[08:27:51.960]                     }
[08:27:51.960]                     invisible(muffled)
[08:27:51.960]                   }
[08:27:51.960]                   muffleCondition(cond)
[08:27:51.960]                 })
[08:27:51.960]             }))
[08:27:51.960]             future::FutureResult(value = ...future.value$value, 
[08:27:51.960]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.960]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.960]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.960]                     ...future.globalenv.names))
[08:27:51.960]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.960]         }, condition = base::local({
[08:27:51.960]             c <- base::c
[08:27:51.960]             inherits <- base::inherits
[08:27:51.960]             invokeRestart <- base::invokeRestart
[08:27:51.960]             length <- base::length
[08:27:51.960]             list <- base::list
[08:27:51.960]             seq.int <- base::seq.int
[08:27:51.960]             signalCondition <- base::signalCondition
[08:27:51.960]             sys.calls <- base::sys.calls
[08:27:51.960]             `[[` <- base::`[[`
[08:27:51.960]             `+` <- base::`+`
[08:27:51.960]             `<<-` <- base::`<<-`
[08:27:51.960]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.960]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.960]                   3L)]
[08:27:51.960]             }
[08:27:51.960]             function(cond) {
[08:27:51.960]                 is_error <- inherits(cond, "error")
[08:27:51.960]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.960]                   NULL)
[08:27:51.960]                 if (is_error) {
[08:27:51.960]                   sessionInformation <- function() {
[08:27:51.960]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.960]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.960]                       search = base::search(), system = base::Sys.info())
[08:27:51.960]                   }
[08:27:51.960]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.960]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.960]                     cond$call), session = sessionInformation(), 
[08:27:51.960]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.960]                   signalCondition(cond)
[08:27:51.960]                 }
[08:27:51.960]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.960]                 "immediateCondition"))) {
[08:27:51.960]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.960]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.960]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.960]                   if (TRUE && !signal) {
[08:27:51.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.960]                     {
[08:27:51.960]                       inherits <- base::inherits
[08:27:51.960]                       invokeRestart <- base::invokeRestart
[08:27:51.960]                       is.null <- base::is.null
[08:27:51.960]                       muffled <- FALSE
[08:27:51.960]                       if (inherits(cond, "message")) {
[08:27:51.960]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.960]                         if (muffled) 
[08:27:51.960]                           invokeRestart("muffleMessage")
[08:27:51.960]                       }
[08:27:51.960]                       else if (inherits(cond, "warning")) {
[08:27:51.960]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.960]                         if (muffled) 
[08:27:51.960]                           invokeRestart("muffleWarning")
[08:27:51.960]                       }
[08:27:51.960]                       else if (inherits(cond, "condition")) {
[08:27:51.960]                         if (!is.null(pattern)) {
[08:27:51.960]                           computeRestarts <- base::computeRestarts
[08:27:51.960]                           grepl <- base::grepl
[08:27:51.960]                           restarts <- computeRestarts(cond)
[08:27:51.960]                           for (restart in restarts) {
[08:27:51.960]                             name <- restart$name
[08:27:51.960]                             if (is.null(name)) 
[08:27:51.960]                               next
[08:27:51.960]                             if (!grepl(pattern, name)) 
[08:27:51.960]                               next
[08:27:51.960]                             invokeRestart(restart)
[08:27:51.960]                             muffled <- TRUE
[08:27:51.960]                             break
[08:27:51.960]                           }
[08:27:51.960]                         }
[08:27:51.960]                       }
[08:27:51.960]                       invisible(muffled)
[08:27:51.960]                     }
[08:27:51.960]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.960]                   }
[08:27:51.960]                 }
[08:27:51.960]                 else {
[08:27:51.960]                   if (TRUE) {
[08:27:51.960]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.960]                     {
[08:27:51.960]                       inherits <- base::inherits
[08:27:51.960]                       invokeRestart <- base::invokeRestart
[08:27:51.960]                       is.null <- base::is.null
[08:27:51.960]                       muffled <- FALSE
[08:27:51.960]                       if (inherits(cond, "message")) {
[08:27:51.960]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.960]                         if (muffled) 
[08:27:51.960]                           invokeRestart("muffleMessage")
[08:27:51.960]                       }
[08:27:51.960]                       else if (inherits(cond, "warning")) {
[08:27:51.960]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.960]                         if (muffled) 
[08:27:51.960]                           invokeRestart("muffleWarning")
[08:27:51.960]                       }
[08:27:51.960]                       else if (inherits(cond, "condition")) {
[08:27:51.960]                         if (!is.null(pattern)) {
[08:27:51.960]                           computeRestarts <- base::computeRestarts
[08:27:51.960]                           grepl <- base::grepl
[08:27:51.960]                           restarts <- computeRestarts(cond)
[08:27:51.960]                           for (restart in restarts) {
[08:27:51.960]                             name <- restart$name
[08:27:51.960]                             if (is.null(name)) 
[08:27:51.960]                               next
[08:27:51.960]                             if (!grepl(pattern, name)) 
[08:27:51.960]                               next
[08:27:51.960]                             invokeRestart(restart)
[08:27:51.960]                             muffled <- TRUE
[08:27:51.960]                             break
[08:27:51.960]                           }
[08:27:51.960]                         }
[08:27:51.960]                       }
[08:27:51.960]                       invisible(muffled)
[08:27:51.960]                     }
[08:27:51.960]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.960]                   }
[08:27:51.960]                 }
[08:27:51.960]             }
[08:27:51.960]         }))
[08:27:51.960]     }, error = function(ex) {
[08:27:51.960]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.960]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.960]                 ...future.rng), started = ...future.startTime, 
[08:27:51.960]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.960]             version = "1.8"), class = "FutureResult")
[08:27:51.960]     }, finally = {
[08:27:51.960]         if (!identical(...future.workdir, getwd())) 
[08:27:51.960]             setwd(...future.workdir)
[08:27:51.960]         {
[08:27:51.960]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.960]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.960]             }
[08:27:51.960]             base::options(...future.oldOptions)
[08:27:51.960]             if (.Platform$OS.type == "windows") {
[08:27:51.960]                 old_names <- names(...future.oldEnvVars)
[08:27:51.960]                 envs <- base::Sys.getenv()
[08:27:51.960]                 names <- names(envs)
[08:27:51.960]                 common <- intersect(names, old_names)
[08:27:51.960]                 added <- setdiff(names, old_names)
[08:27:51.960]                 removed <- setdiff(old_names, names)
[08:27:51.960]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.960]                   envs[common]]
[08:27:51.960]                 NAMES <- toupper(changed)
[08:27:51.960]                 args <- list()
[08:27:51.960]                 for (kk in seq_along(NAMES)) {
[08:27:51.960]                   name <- changed[[kk]]
[08:27:51.960]                   NAME <- NAMES[[kk]]
[08:27:51.960]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.960]                     next
[08:27:51.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.960]                 }
[08:27:51.960]                 NAMES <- toupper(added)
[08:27:51.960]                 for (kk in seq_along(NAMES)) {
[08:27:51.960]                   name <- added[[kk]]
[08:27:51.960]                   NAME <- NAMES[[kk]]
[08:27:51.960]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.960]                     next
[08:27:51.960]                   args[[name]] <- ""
[08:27:51.960]                 }
[08:27:51.960]                 NAMES <- toupper(removed)
[08:27:51.960]                 for (kk in seq_along(NAMES)) {
[08:27:51.960]                   name <- removed[[kk]]
[08:27:51.960]                   NAME <- NAMES[[kk]]
[08:27:51.960]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.960]                     next
[08:27:51.960]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.960]                 }
[08:27:51.960]                 if (length(args) > 0) 
[08:27:51.960]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.960]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.960]             }
[08:27:51.960]             else {
[08:27:51.960]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.960]             }
[08:27:51.960]             {
[08:27:51.960]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.960]                   0L) {
[08:27:51.960]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.960]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.960]                   base::options(opts)
[08:27:51.960]                 }
[08:27:51.960]                 {
[08:27:51.960]                   {
[08:27:51.960]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.960]                     NULL
[08:27:51.960]                   }
[08:27:51.960]                   options(future.plan = NULL)
[08:27:51.960]                   if (is.na(NA_character_)) 
[08:27:51.960]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.960]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.960]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.960]                     .init = FALSE)
[08:27:51.960]                 }
[08:27:51.960]             }
[08:27:51.960]         }
[08:27:51.960]     })
[08:27:51.960]     if (TRUE) {
[08:27:51.960]         base::sink(type = "output", split = FALSE)
[08:27:51.960]         if (TRUE) {
[08:27:51.960]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.960]         }
[08:27:51.960]         else {
[08:27:51.960]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.960]         }
[08:27:51.960]         base::close(...future.stdout)
[08:27:51.960]         ...future.stdout <- NULL
[08:27:51.960]     }
[08:27:51.960]     ...future.result$conditions <- ...future.conditions
[08:27:51.960]     ...future.result$finished <- base::Sys.time()
[08:27:51.960]     ...future.result
[08:27:51.960] }
[08:27:51.964] MultisessionFuture started
[08:27:51.964] - Launch lazy future ... done
[08:27:51.965] run() for ‘MultisessionFuture’ ... done
[08:27:51.965] getGlobalsAndPackages() ...
[08:27:51.965] Searching for globals...
[08:27:51.966] 
[08:27:51.966] Searching for globals ... DONE
[08:27:51.966] - globals: [0] <none>
[08:27:51.966] getGlobalsAndPackages() ... DONE
[08:27:51.967] run() for ‘Future’ ...
[08:27:51.967] - state: ‘created’
[08:27:51.967] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:51.983] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:51.983] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:51.983]   - Field: ‘node’
[08:27:51.983]   - Field: ‘label’
[08:27:51.983]   - Field: ‘local’
[08:27:51.983]   - Field: ‘owner’
[08:27:51.983]   - Field: ‘envir’
[08:27:51.983]   - Field: ‘workers’
[08:27:51.984]   - Field: ‘packages’
[08:27:51.984]   - Field: ‘gc’
[08:27:51.984]   - Field: ‘conditions’
[08:27:51.984]   - Field: ‘persistent’
[08:27:51.984]   - Field: ‘expr’
[08:27:51.984]   - Field: ‘uuid’
[08:27:51.984]   - Field: ‘seed’
[08:27:51.984]   - Field: ‘version’
[08:27:51.984]   - Field: ‘result’
[08:27:51.985]   - Field: ‘asynchronous’
[08:27:51.985]   - Field: ‘calls’
[08:27:51.985]   - Field: ‘globals’
[08:27:51.985]   - Field: ‘stdout’
[08:27:51.985]   - Field: ‘earlySignal’
[08:27:51.985]   - Field: ‘lazy’
[08:27:51.985]   - Field: ‘state’
[08:27:51.985] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:51.985] - Launch lazy future ...
[08:27:51.986] Packages needed by the future expression (n = 0): <none>
[08:27:51.986] Packages needed by future strategies (n = 0): <none>
[08:27:51.986] {
[08:27:51.986]     {
[08:27:51.986]         {
[08:27:51.986]             ...future.startTime <- base::Sys.time()
[08:27:51.986]             {
[08:27:51.986]                 {
[08:27:51.986]                   {
[08:27:51.986]                     {
[08:27:51.986]                       base::local({
[08:27:51.986]                         has_future <- base::requireNamespace("future", 
[08:27:51.986]                           quietly = TRUE)
[08:27:51.986]                         if (has_future) {
[08:27:51.986]                           ns <- base::getNamespace("future")
[08:27:51.986]                           version <- ns[[".package"]][["version"]]
[08:27:51.986]                           if (is.null(version)) 
[08:27:51.986]                             version <- utils::packageVersion("future")
[08:27:51.986]                         }
[08:27:51.986]                         else {
[08:27:51.986]                           version <- NULL
[08:27:51.986]                         }
[08:27:51.986]                         if (!has_future || version < "1.8.0") {
[08:27:51.986]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:51.986]                             "", base::R.version$version.string), 
[08:27:51.986]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:51.986]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:51.986]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:51.986]                               "release", "version")], collapse = " "), 
[08:27:51.986]                             hostname = base::Sys.info()[["nodename"]])
[08:27:51.986]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:51.986]                             info)
[08:27:51.986]                           info <- base::paste(info, collapse = "; ")
[08:27:51.986]                           if (!has_future) {
[08:27:51.986]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:51.986]                               info)
[08:27:51.986]                           }
[08:27:51.986]                           else {
[08:27:51.986]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:51.986]                               info, version)
[08:27:51.986]                           }
[08:27:51.986]                           base::stop(msg)
[08:27:51.986]                         }
[08:27:51.986]                       })
[08:27:51.986]                     }
[08:27:51.986]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:51.986]                     base::options(mc.cores = 1L)
[08:27:51.986]                   }
[08:27:51.986]                   ...future.strategy.old <- future::plan("list")
[08:27:51.986]                   options(future.plan = NULL)
[08:27:51.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:51.986]                 }
[08:27:51.986]                 ...future.workdir <- getwd()
[08:27:51.986]             }
[08:27:51.986]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:51.986]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:51.986]         }
[08:27:51.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:51.986]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:51.986]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:51.986]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:51.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:51.986]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:51.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:51.986]             base::names(...future.oldOptions))
[08:27:51.986]     }
[08:27:51.986]     if (FALSE) {
[08:27:51.986]     }
[08:27:51.986]     else {
[08:27:51.986]         if (TRUE) {
[08:27:51.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:51.986]                 open = "w")
[08:27:51.986]         }
[08:27:51.986]         else {
[08:27:51.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:51.986]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:51.986]         }
[08:27:51.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:51.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:51.986]             base::sink(type = "output", split = FALSE)
[08:27:51.986]             base::close(...future.stdout)
[08:27:51.986]         }, add = TRUE)
[08:27:51.986]     }
[08:27:51.986]     ...future.frame <- base::sys.nframe()
[08:27:51.986]     ...future.conditions <- base::list()
[08:27:51.986]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:51.986]     if (FALSE) {
[08:27:51.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:51.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:51.986]     }
[08:27:51.986]     ...future.result <- base::tryCatch({
[08:27:51.986]         base::withCallingHandlers({
[08:27:51.986]             ...future.value <- base::withVisible(base::local({
[08:27:51.986]                 ...future.makeSendCondition <- base::local({
[08:27:51.986]                   sendCondition <- NULL
[08:27:51.986]                   function(frame = 1L) {
[08:27:51.986]                     if (is.function(sendCondition)) 
[08:27:51.986]                       return(sendCondition)
[08:27:51.986]                     ns <- getNamespace("parallel")
[08:27:51.986]                     if (exists("sendData", mode = "function", 
[08:27:51.986]                       envir = ns)) {
[08:27:51.986]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:51.986]                         envir = ns)
[08:27:51.986]                       envir <- sys.frame(frame)
[08:27:51.986]                       master <- NULL
[08:27:51.986]                       while (!identical(envir, .GlobalEnv) && 
[08:27:51.986]                         !identical(envir, emptyenv())) {
[08:27:51.986]                         if (exists("master", mode = "list", envir = envir, 
[08:27:51.986]                           inherits = FALSE)) {
[08:27:51.986]                           master <- get("master", mode = "list", 
[08:27:51.986]                             envir = envir, inherits = FALSE)
[08:27:51.986]                           if (inherits(master, c("SOCKnode", 
[08:27:51.986]                             "SOCK0node"))) {
[08:27:51.986]                             sendCondition <<- function(cond) {
[08:27:51.986]                               data <- list(type = "VALUE", value = cond, 
[08:27:51.986]                                 success = TRUE)
[08:27:51.986]                               parallel_sendData(master, data)
[08:27:51.986]                             }
[08:27:51.986]                             return(sendCondition)
[08:27:51.986]                           }
[08:27:51.986]                         }
[08:27:51.986]                         frame <- frame + 1L
[08:27:51.986]                         envir <- sys.frame(frame)
[08:27:51.986]                       }
[08:27:51.986]                     }
[08:27:51.986]                     sendCondition <<- function(cond) NULL
[08:27:51.986]                   }
[08:27:51.986]                 })
[08:27:51.986]                 withCallingHandlers({
[08:27:51.986]                   NULL
[08:27:51.986]                 }, immediateCondition = function(cond) {
[08:27:51.986]                   sendCondition <- ...future.makeSendCondition()
[08:27:51.986]                   sendCondition(cond)
[08:27:51.986]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.986]                   {
[08:27:51.986]                     inherits <- base::inherits
[08:27:51.986]                     invokeRestart <- base::invokeRestart
[08:27:51.986]                     is.null <- base::is.null
[08:27:51.986]                     muffled <- FALSE
[08:27:51.986]                     if (inherits(cond, "message")) {
[08:27:51.986]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:51.986]                       if (muffled) 
[08:27:51.986]                         invokeRestart("muffleMessage")
[08:27:51.986]                     }
[08:27:51.986]                     else if (inherits(cond, "warning")) {
[08:27:51.986]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:51.986]                       if (muffled) 
[08:27:51.986]                         invokeRestart("muffleWarning")
[08:27:51.986]                     }
[08:27:51.986]                     else if (inherits(cond, "condition")) {
[08:27:51.986]                       if (!is.null(pattern)) {
[08:27:51.986]                         computeRestarts <- base::computeRestarts
[08:27:51.986]                         grepl <- base::grepl
[08:27:51.986]                         restarts <- computeRestarts(cond)
[08:27:51.986]                         for (restart in restarts) {
[08:27:51.986]                           name <- restart$name
[08:27:51.986]                           if (is.null(name)) 
[08:27:51.986]                             next
[08:27:51.986]                           if (!grepl(pattern, name)) 
[08:27:51.986]                             next
[08:27:51.986]                           invokeRestart(restart)
[08:27:51.986]                           muffled <- TRUE
[08:27:51.986]                           break
[08:27:51.986]                         }
[08:27:51.986]                       }
[08:27:51.986]                     }
[08:27:51.986]                     invisible(muffled)
[08:27:51.986]                   }
[08:27:51.986]                   muffleCondition(cond)
[08:27:51.986]                 })
[08:27:51.986]             }))
[08:27:51.986]             future::FutureResult(value = ...future.value$value, 
[08:27:51.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.986]                   ...future.rng), globalenv = if (FALSE) 
[08:27:51.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:51.986]                     ...future.globalenv.names))
[08:27:51.986]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:51.986]         }, condition = base::local({
[08:27:51.986]             c <- base::c
[08:27:51.986]             inherits <- base::inherits
[08:27:51.986]             invokeRestart <- base::invokeRestart
[08:27:51.986]             length <- base::length
[08:27:51.986]             list <- base::list
[08:27:51.986]             seq.int <- base::seq.int
[08:27:51.986]             signalCondition <- base::signalCondition
[08:27:51.986]             sys.calls <- base::sys.calls
[08:27:51.986]             `[[` <- base::`[[`
[08:27:51.986]             `+` <- base::`+`
[08:27:51.986]             `<<-` <- base::`<<-`
[08:27:51.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:51.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:51.986]                   3L)]
[08:27:51.986]             }
[08:27:51.986]             function(cond) {
[08:27:51.986]                 is_error <- inherits(cond, "error")
[08:27:51.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:51.986]                   NULL)
[08:27:51.986]                 if (is_error) {
[08:27:51.986]                   sessionInformation <- function() {
[08:27:51.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:51.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:51.986]                       search = base::search(), system = base::Sys.info())
[08:27:51.986]                   }
[08:27:51.986]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:51.986]                     cond$call), session = sessionInformation(), 
[08:27:51.986]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:51.986]                   signalCondition(cond)
[08:27:51.986]                 }
[08:27:51.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:51.986]                 "immediateCondition"))) {
[08:27:51.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:51.986]                   ...future.conditions[[length(...future.conditions) + 
[08:27:51.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:51.986]                   if (TRUE && !signal) {
[08:27:51.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.986]                     {
[08:27:51.986]                       inherits <- base::inherits
[08:27:51.986]                       invokeRestart <- base::invokeRestart
[08:27:51.986]                       is.null <- base::is.null
[08:27:51.986]                       muffled <- FALSE
[08:27:51.986]                       if (inherits(cond, "message")) {
[08:27:51.986]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.986]                         if (muffled) 
[08:27:51.986]                           invokeRestart("muffleMessage")
[08:27:51.986]                       }
[08:27:51.986]                       else if (inherits(cond, "warning")) {
[08:27:51.986]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.986]                         if (muffled) 
[08:27:51.986]                           invokeRestart("muffleWarning")
[08:27:51.986]                       }
[08:27:51.986]                       else if (inherits(cond, "condition")) {
[08:27:51.986]                         if (!is.null(pattern)) {
[08:27:51.986]                           computeRestarts <- base::computeRestarts
[08:27:51.986]                           grepl <- base::grepl
[08:27:51.986]                           restarts <- computeRestarts(cond)
[08:27:51.986]                           for (restart in restarts) {
[08:27:51.986]                             name <- restart$name
[08:27:51.986]                             if (is.null(name)) 
[08:27:51.986]                               next
[08:27:51.986]                             if (!grepl(pattern, name)) 
[08:27:51.986]                               next
[08:27:51.986]                             invokeRestart(restart)
[08:27:51.986]                             muffled <- TRUE
[08:27:51.986]                             break
[08:27:51.986]                           }
[08:27:51.986]                         }
[08:27:51.986]                       }
[08:27:51.986]                       invisible(muffled)
[08:27:51.986]                     }
[08:27:51.986]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.986]                   }
[08:27:51.986]                 }
[08:27:51.986]                 else {
[08:27:51.986]                   if (TRUE) {
[08:27:51.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:51.986]                     {
[08:27:51.986]                       inherits <- base::inherits
[08:27:51.986]                       invokeRestart <- base::invokeRestart
[08:27:51.986]                       is.null <- base::is.null
[08:27:51.986]                       muffled <- FALSE
[08:27:51.986]                       if (inherits(cond, "message")) {
[08:27:51.986]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:51.986]                         if (muffled) 
[08:27:51.986]                           invokeRestart("muffleMessage")
[08:27:51.986]                       }
[08:27:51.986]                       else if (inherits(cond, "warning")) {
[08:27:51.986]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:51.986]                         if (muffled) 
[08:27:51.986]                           invokeRestart("muffleWarning")
[08:27:51.986]                       }
[08:27:51.986]                       else if (inherits(cond, "condition")) {
[08:27:51.986]                         if (!is.null(pattern)) {
[08:27:51.986]                           computeRestarts <- base::computeRestarts
[08:27:51.986]                           grepl <- base::grepl
[08:27:51.986]                           restarts <- computeRestarts(cond)
[08:27:51.986]                           for (restart in restarts) {
[08:27:51.986]                             name <- restart$name
[08:27:51.986]                             if (is.null(name)) 
[08:27:51.986]                               next
[08:27:51.986]                             if (!grepl(pattern, name)) 
[08:27:51.986]                               next
[08:27:51.986]                             invokeRestart(restart)
[08:27:51.986]                             muffled <- TRUE
[08:27:51.986]                             break
[08:27:51.986]                           }
[08:27:51.986]                         }
[08:27:51.986]                       }
[08:27:51.986]                       invisible(muffled)
[08:27:51.986]                     }
[08:27:51.986]                     muffleCondition(cond, pattern = "^muffle")
[08:27:51.986]                   }
[08:27:51.986]                 }
[08:27:51.986]             }
[08:27:51.986]         }))
[08:27:51.986]     }, error = function(ex) {
[08:27:51.986]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:51.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:51.986]                 ...future.rng), started = ...future.startTime, 
[08:27:51.986]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:51.986]             version = "1.8"), class = "FutureResult")
[08:27:51.986]     }, finally = {
[08:27:51.986]         if (!identical(...future.workdir, getwd())) 
[08:27:51.986]             setwd(...future.workdir)
[08:27:51.986]         {
[08:27:51.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:51.986]                 ...future.oldOptions$nwarnings <- NULL
[08:27:51.986]             }
[08:27:51.986]             base::options(...future.oldOptions)
[08:27:51.986]             if (.Platform$OS.type == "windows") {
[08:27:51.986]                 old_names <- names(...future.oldEnvVars)
[08:27:51.986]                 envs <- base::Sys.getenv()
[08:27:51.986]                 names <- names(envs)
[08:27:51.986]                 common <- intersect(names, old_names)
[08:27:51.986]                 added <- setdiff(names, old_names)
[08:27:51.986]                 removed <- setdiff(old_names, names)
[08:27:51.986]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:51.986]                   envs[common]]
[08:27:51.986]                 NAMES <- toupper(changed)
[08:27:51.986]                 args <- list()
[08:27:51.986]                 for (kk in seq_along(NAMES)) {
[08:27:51.986]                   name <- changed[[kk]]
[08:27:51.986]                   NAME <- NAMES[[kk]]
[08:27:51.986]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.986]                     next
[08:27:51.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.986]                 }
[08:27:51.986]                 NAMES <- toupper(added)
[08:27:51.986]                 for (kk in seq_along(NAMES)) {
[08:27:51.986]                   name <- added[[kk]]
[08:27:51.986]                   NAME <- NAMES[[kk]]
[08:27:51.986]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.986]                     next
[08:27:51.986]                   args[[name]] <- ""
[08:27:51.986]                 }
[08:27:51.986]                 NAMES <- toupper(removed)
[08:27:51.986]                 for (kk in seq_along(NAMES)) {
[08:27:51.986]                   name <- removed[[kk]]
[08:27:51.986]                   NAME <- NAMES[[kk]]
[08:27:51.986]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:51.986]                     next
[08:27:51.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:51.986]                 }
[08:27:51.986]                 if (length(args) > 0) 
[08:27:51.986]                   base::do.call(base::Sys.setenv, args = args)
[08:27:51.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:51.986]             }
[08:27:51.986]             else {
[08:27:51.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:51.986]             }
[08:27:51.986]             {
[08:27:51.986]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:51.986]                   0L) {
[08:27:51.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:51.986]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:51.986]                   base::options(opts)
[08:27:51.986]                 }
[08:27:51.986]                 {
[08:27:51.986]                   {
[08:27:51.986]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:51.986]                     NULL
[08:27:51.986]                   }
[08:27:51.986]                   options(future.plan = NULL)
[08:27:51.986]                   if (is.na(NA_character_)) 
[08:27:51.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:51.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:51.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:51.986]                     .init = FALSE)
[08:27:51.986]                 }
[08:27:51.986]             }
[08:27:51.986]         }
[08:27:51.986]     })
[08:27:51.986]     if (TRUE) {
[08:27:51.986]         base::sink(type = "output", split = FALSE)
[08:27:51.986]         if (TRUE) {
[08:27:51.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:51.986]         }
[08:27:51.986]         else {
[08:27:51.986]             ...future.result["stdout"] <- base::list(NULL)
[08:27:51.986]         }
[08:27:51.986]         base::close(...future.stdout)
[08:27:51.986]         ...future.stdout <- NULL
[08:27:51.986]     }
[08:27:51.986]     ...future.result$conditions <- ...future.conditions
[08:27:51.986]     ...future.result$finished <- base::Sys.time()
[08:27:51.986]     ...future.result
[08:27:51.986] }
[08:27:51.990] MultisessionFuture started
[08:27:51.990] - Launch lazy future ... done
[08:27:51.990] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d862913f78> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d862d9b358> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d862913f78> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d862d9b358> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[08:27:52.006] receiveMessageFromWorker() for ClusterFuture ...
[08:27:52.007] - Validating connection of MultisessionFuture
[08:27:52.009] - received message: FutureResult
[08:27:52.009] - Received FutureResult
[08:27:52.010] - Erased future from FutureRegistry
[08:27:52.010] result() for ClusterFuture ...
[08:27:52.010] - result already collected: FutureResult
[08:27:52.010] result() for ClusterFuture ... done
[08:27:52.010] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:52.022] resolve() on list ...
[08:27:52.022]  recursive: 0
[08:27:52.023]  length: 6
[08:27:52.023]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:52.023] signalConditionsASAP(numeric, pos=1) ...
[08:27:52.023] - nx: 6
[08:27:52.023] - relay: TRUE
[08:27:52.023] - stdout: TRUE
[08:27:52.023] - signal: TRUE
[08:27:52.023] - resignal: FALSE
[08:27:52.023] - force: TRUE
[08:27:52.023] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.023] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.023]  - until=2
[08:27:52.024]  - relaying element #2
[08:27:52.024] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.024] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.024] signalConditionsASAP(NULL, pos=1) ... done
[08:27:52.024]  length: 5 (resolved future 1)
[08:27:52.024] Future #2
[08:27:52.024] result() for ClusterFuture ...
[08:27:52.024] - result already collected: FutureResult
[08:27:52.024] result() for ClusterFuture ... done
[08:27:52.024] result() for ClusterFuture ...
[08:27:52.024] - result already collected: FutureResult
[08:27:52.024] result() for ClusterFuture ... done
[08:27:52.025] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:52.025] - nx: 6
[08:27:52.025] - relay: TRUE
[08:27:52.025] - stdout: TRUE
[08:27:52.025] - signal: TRUE
[08:27:52.025] - resignal: FALSE
[08:27:52.025] - force: TRUE
[08:27:52.025] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.025] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.025]  - until=2
[08:27:52.025]  - relaying element #2
[08:27:52.025] result() for ClusterFuture ...
[08:27:52.025] - result already collected: FutureResult
[08:27:52.026] result() for ClusterFuture ... done
[08:27:52.026] result() for ClusterFuture ...
[08:27:52.026] - result already collected: FutureResult
[08:27:52.026] result() for ClusterFuture ... done
[08:27:52.026] result() for ClusterFuture ...
[08:27:52.026] - result already collected: FutureResult
[08:27:52.026] result() for ClusterFuture ... done
[08:27:52.026] result() for ClusterFuture ...
[08:27:52.026] - result already collected: FutureResult
[08:27:52.026] result() for ClusterFuture ... done
[08:27:52.026] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.026] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.027] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:52.027]  length: 4 (resolved future 2)
[08:27:52.032] receiveMessageFromWorker() for ClusterFuture ...
[08:27:52.032] - Validating connection of MultisessionFuture
[08:27:52.033] - received message: FutureResult
[08:27:52.033] - Received FutureResult
[08:27:52.033] - Erased future from FutureRegistry
[08:27:52.033] result() for ClusterFuture ...
[08:27:52.033] - result already collected: FutureResult
[08:27:52.033] result() for ClusterFuture ... done
[08:27:52.033] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:52.033] Future #3
[08:27:52.033] result() for ClusterFuture ...
[08:27:52.033] - result already collected: FutureResult
[08:27:52.033] result() for ClusterFuture ... done
[08:27:52.034] result() for ClusterFuture ...
[08:27:52.034] - result already collected: FutureResult
[08:27:52.034] result() for ClusterFuture ... done
[08:27:52.034] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:52.034] - nx: 6
[08:27:52.034] - relay: TRUE
[08:27:52.034] - stdout: TRUE
[08:27:52.034] - signal: TRUE
[08:27:52.034] - resignal: FALSE
[08:27:52.034] - force: TRUE
[08:27:52.034] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.034] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.034]  - until=3
[08:27:52.035]  - relaying element #3
[08:27:52.035] result() for ClusterFuture ...
[08:27:52.035] - result already collected: FutureResult
[08:27:52.035] result() for ClusterFuture ... done
[08:27:52.035] result() for ClusterFuture ...
[08:27:52.035] - result already collected: FutureResult
[08:27:52.035] result() for ClusterFuture ... done
[08:27:52.035] result() for ClusterFuture ...
[08:27:52.035] - result already collected: FutureResult
[08:27:52.035] result() for ClusterFuture ... done
[08:27:52.035] result() for ClusterFuture ...
[08:27:52.035] - result already collected: FutureResult
[08:27:52.036] result() for ClusterFuture ... done
[08:27:52.036] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.036] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.036] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:52.036]  length: 3 (resolved future 3)
[08:27:52.036] signalConditionsASAP(NULL, pos=4) ...
[08:27:52.036] - nx: 6
[08:27:52.036] - relay: TRUE
[08:27:52.036] - stdout: TRUE
[08:27:52.036] - signal: TRUE
[08:27:52.036] - resignal: FALSE
[08:27:52.036] - force: TRUE
[08:27:52.036] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.037] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.037]  - until=5
[08:27:52.037]  - relaying element #5
[08:27:52.037] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:52.037] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.037] signalConditionsASAP(NULL, pos=4) ... done
[08:27:52.037]  length: 2 (resolved future 4)
[08:27:52.037] signalConditionsASAP(NULL, pos=5) ...
[08:27:52.037] - nx: 6
[08:27:52.037] - relay: TRUE
[08:27:52.037] - stdout: TRUE
[08:27:52.037] - signal: TRUE
[08:27:52.037] - resignal: FALSE
[08:27:52.038] - force: TRUE
[08:27:52.038] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:52.038] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.038]  - until=6
[08:27:52.038]  - relaying element #6
[08:27:52.038] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:52.038] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.038] signalConditionsASAP(NULL, pos=5) ... done
[08:27:52.038]  length: 1 (resolved future 5)
[08:27:52.038] signalConditionsASAP(numeric, pos=6) ...
[08:27:52.038] - nx: 6
[08:27:52.038] - relay: TRUE
[08:27:52.039] - stdout: TRUE
[08:27:52.039] - signal: TRUE
[08:27:52.039] - resignal: FALSE
[08:27:52.039] - force: TRUE
[08:27:52.039] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:52.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.039]  - until=6
[08:27:52.039] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.039] signalConditionsASAP(numeric, pos=6) ... done
[08:27:52.039]  length: 0 (resolved future 6)
[08:27:52.039] Relaying remaining futures
[08:27:52.039] signalConditionsASAP(NULL, pos=0) ...
[08:27:52.040] - nx: 6
[08:27:52.040] - relay: TRUE
[08:27:52.040] - stdout: TRUE
[08:27:52.040] - signal: TRUE
[08:27:52.040] - resignal: FALSE
[08:27:52.040] - force: TRUE
[08:27:52.040] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.040] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:52.040] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.040] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.040] signalConditionsASAP(NULL, pos=0) ... done
[08:27:52.040] resolve() on list ... DONE
[08:27:52.040] result() for ClusterFuture ...
[08:27:52.041] - result already collected: FutureResult
[08:27:52.041] result() for ClusterFuture ... done
[08:27:52.041] result() for ClusterFuture ...
[08:27:52.041] - result already collected: FutureResult
[08:27:52.041] result() for ClusterFuture ... done
[08:27:52.041] result() for ClusterFuture ...
[08:27:52.041] - result already collected: FutureResult
[08:27:52.041] result() for ClusterFuture ... done
[08:27:52.041] result() for ClusterFuture ...
[08:27:52.041] - result already collected: FutureResult
[08:27:52.041] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[08:27:52.045] getGlobalsAndPackages() ...
[08:27:52.045] Searching for globals...
[08:27:52.045] 
[08:27:52.045] Searching for globals ... DONE
[08:27:52.045] - globals: [0] <none>
[08:27:52.045] getGlobalsAndPackages() ... DONE
[08:27:52.046] run() for ‘Future’ ...
[08:27:52.046] - state: ‘created’
[08:27:52.046] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:52.061]   - Field: ‘node’
[08:27:52.061]   - Field: ‘label’
[08:27:52.062]   - Field: ‘local’
[08:27:52.062]   - Field: ‘owner’
[08:27:52.062]   - Field: ‘envir’
[08:27:52.062]   - Field: ‘workers’
[08:27:52.062]   - Field: ‘packages’
[08:27:52.062]   - Field: ‘gc’
[08:27:52.062]   - Field: ‘conditions’
[08:27:52.062]   - Field: ‘persistent’
[08:27:52.062]   - Field: ‘expr’
[08:27:52.062]   - Field: ‘uuid’
[08:27:52.062]   - Field: ‘seed’
[08:27:52.063]   - Field: ‘version’
[08:27:52.063]   - Field: ‘result’
[08:27:52.063]   - Field: ‘asynchronous’
[08:27:52.063]   - Field: ‘calls’
[08:27:52.063]   - Field: ‘globals’
[08:27:52.063]   - Field: ‘stdout’
[08:27:52.063]   - Field: ‘earlySignal’
[08:27:52.063]   - Field: ‘lazy’
[08:27:52.063]   - Field: ‘state’
[08:27:52.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:52.063] - Launch lazy future ...
[08:27:52.064] Packages needed by the future expression (n = 0): <none>
[08:27:52.064] Packages needed by future strategies (n = 0): <none>
[08:27:52.064] {
[08:27:52.064]     {
[08:27:52.064]         {
[08:27:52.064]             ...future.startTime <- base::Sys.time()
[08:27:52.064]             {
[08:27:52.064]                 {
[08:27:52.064]                   {
[08:27:52.064]                     {
[08:27:52.064]                       base::local({
[08:27:52.064]                         has_future <- base::requireNamespace("future", 
[08:27:52.064]                           quietly = TRUE)
[08:27:52.064]                         if (has_future) {
[08:27:52.064]                           ns <- base::getNamespace("future")
[08:27:52.064]                           version <- ns[[".package"]][["version"]]
[08:27:52.064]                           if (is.null(version)) 
[08:27:52.064]                             version <- utils::packageVersion("future")
[08:27:52.064]                         }
[08:27:52.064]                         else {
[08:27:52.064]                           version <- NULL
[08:27:52.064]                         }
[08:27:52.064]                         if (!has_future || version < "1.8.0") {
[08:27:52.064]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.064]                             "", base::R.version$version.string), 
[08:27:52.064]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.064]                               "release", "version")], collapse = " "), 
[08:27:52.064]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.064]                             info)
[08:27:52.064]                           info <- base::paste(info, collapse = "; ")
[08:27:52.064]                           if (!has_future) {
[08:27:52.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.064]                               info)
[08:27:52.064]                           }
[08:27:52.064]                           else {
[08:27:52.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.064]                               info, version)
[08:27:52.064]                           }
[08:27:52.064]                           base::stop(msg)
[08:27:52.064]                         }
[08:27:52.064]                       })
[08:27:52.064]                     }
[08:27:52.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.064]                     base::options(mc.cores = 1L)
[08:27:52.064]                   }
[08:27:52.064]                   ...future.strategy.old <- future::plan("list")
[08:27:52.064]                   options(future.plan = NULL)
[08:27:52.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.064]                 }
[08:27:52.064]                 ...future.workdir <- getwd()
[08:27:52.064]             }
[08:27:52.064]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.064]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.064]         }
[08:27:52.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.064]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.064]             base::names(...future.oldOptions))
[08:27:52.064]     }
[08:27:52.064]     if (FALSE) {
[08:27:52.064]     }
[08:27:52.064]     else {
[08:27:52.064]         if (TRUE) {
[08:27:52.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.064]                 open = "w")
[08:27:52.064]         }
[08:27:52.064]         else {
[08:27:52.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.064]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.064]         }
[08:27:52.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.064]             base::sink(type = "output", split = FALSE)
[08:27:52.064]             base::close(...future.stdout)
[08:27:52.064]         }, add = TRUE)
[08:27:52.064]     }
[08:27:52.064]     ...future.frame <- base::sys.nframe()
[08:27:52.064]     ...future.conditions <- base::list()
[08:27:52.064]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.064]     if (FALSE) {
[08:27:52.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.064]     }
[08:27:52.064]     ...future.result <- base::tryCatch({
[08:27:52.064]         base::withCallingHandlers({
[08:27:52.064]             ...future.value <- base::withVisible(base::local({
[08:27:52.064]                 ...future.makeSendCondition <- base::local({
[08:27:52.064]                   sendCondition <- NULL
[08:27:52.064]                   function(frame = 1L) {
[08:27:52.064]                     if (is.function(sendCondition)) 
[08:27:52.064]                       return(sendCondition)
[08:27:52.064]                     ns <- getNamespace("parallel")
[08:27:52.064]                     if (exists("sendData", mode = "function", 
[08:27:52.064]                       envir = ns)) {
[08:27:52.064]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:52.064]                         envir = ns)
[08:27:52.064]                       envir <- sys.frame(frame)
[08:27:52.064]                       master <- NULL
[08:27:52.064]                       while (!identical(envir, .GlobalEnv) && 
[08:27:52.064]                         !identical(envir, emptyenv())) {
[08:27:52.064]                         if (exists("master", mode = "list", envir = envir, 
[08:27:52.064]                           inherits = FALSE)) {
[08:27:52.064]                           master <- get("master", mode = "list", 
[08:27:52.064]                             envir = envir, inherits = FALSE)
[08:27:52.064]                           if (inherits(master, c("SOCKnode", 
[08:27:52.064]                             "SOCK0node"))) {
[08:27:52.064]                             sendCondition <<- function(cond) {
[08:27:52.064]                               data <- list(type = "VALUE", value = cond, 
[08:27:52.064]                                 success = TRUE)
[08:27:52.064]                               parallel_sendData(master, data)
[08:27:52.064]                             }
[08:27:52.064]                             return(sendCondition)
[08:27:52.064]                           }
[08:27:52.064]                         }
[08:27:52.064]                         frame <- frame + 1L
[08:27:52.064]                         envir <- sys.frame(frame)
[08:27:52.064]                       }
[08:27:52.064]                     }
[08:27:52.064]                     sendCondition <<- function(cond) NULL
[08:27:52.064]                   }
[08:27:52.064]                 })
[08:27:52.064]                 withCallingHandlers({
[08:27:52.064]                   2
[08:27:52.064]                 }, immediateCondition = function(cond) {
[08:27:52.064]                   sendCondition <- ...future.makeSendCondition()
[08:27:52.064]                   sendCondition(cond)
[08:27:52.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.064]                   {
[08:27:52.064]                     inherits <- base::inherits
[08:27:52.064]                     invokeRestart <- base::invokeRestart
[08:27:52.064]                     is.null <- base::is.null
[08:27:52.064]                     muffled <- FALSE
[08:27:52.064]                     if (inherits(cond, "message")) {
[08:27:52.064]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.064]                       if (muffled) 
[08:27:52.064]                         invokeRestart("muffleMessage")
[08:27:52.064]                     }
[08:27:52.064]                     else if (inherits(cond, "warning")) {
[08:27:52.064]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.064]                       if (muffled) 
[08:27:52.064]                         invokeRestart("muffleWarning")
[08:27:52.064]                     }
[08:27:52.064]                     else if (inherits(cond, "condition")) {
[08:27:52.064]                       if (!is.null(pattern)) {
[08:27:52.064]                         computeRestarts <- base::computeRestarts
[08:27:52.064]                         grepl <- base::grepl
[08:27:52.064]                         restarts <- computeRestarts(cond)
[08:27:52.064]                         for (restart in restarts) {
[08:27:52.064]                           name <- restart$name
[08:27:52.064]                           if (is.null(name)) 
[08:27:52.064]                             next
[08:27:52.064]                           if (!grepl(pattern, name)) 
[08:27:52.064]                             next
[08:27:52.064]                           invokeRestart(restart)
[08:27:52.064]                           muffled <- TRUE
[08:27:52.064]                           break
[08:27:52.064]                         }
[08:27:52.064]                       }
[08:27:52.064]                     }
[08:27:52.064]                     invisible(muffled)
[08:27:52.064]                   }
[08:27:52.064]                   muffleCondition(cond)
[08:27:52.064]                 })
[08:27:52.064]             }))
[08:27:52.064]             future::FutureResult(value = ...future.value$value, 
[08:27:52.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.064]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.064]                     ...future.globalenv.names))
[08:27:52.064]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.064]         }, condition = base::local({
[08:27:52.064]             c <- base::c
[08:27:52.064]             inherits <- base::inherits
[08:27:52.064]             invokeRestart <- base::invokeRestart
[08:27:52.064]             length <- base::length
[08:27:52.064]             list <- base::list
[08:27:52.064]             seq.int <- base::seq.int
[08:27:52.064]             signalCondition <- base::signalCondition
[08:27:52.064]             sys.calls <- base::sys.calls
[08:27:52.064]             `[[` <- base::`[[`
[08:27:52.064]             `+` <- base::`+`
[08:27:52.064]             `<<-` <- base::`<<-`
[08:27:52.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.064]                   3L)]
[08:27:52.064]             }
[08:27:52.064]             function(cond) {
[08:27:52.064]                 is_error <- inherits(cond, "error")
[08:27:52.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.064]                   NULL)
[08:27:52.064]                 if (is_error) {
[08:27:52.064]                   sessionInformation <- function() {
[08:27:52.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.064]                       search = base::search(), system = base::Sys.info())
[08:27:52.064]                   }
[08:27:52.064]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.064]                     cond$call), session = sessionInformation(), 
[08:27:52.064]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.064]                   signalCondition(cond)
[08:27:52.064]                 }
[08:27:52.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.064]                 "immediateCondition"))) {
[08:27:52.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.064]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.064]                   if (TRUE && !signal) {
[08:27:52.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.064]                     {
[08:27:52.064]                       inherits <- base::inherits
[08:27:52.064]                       invokeRestart <- base::invokeRestart
[08:27:52.064]                       is.null <- base::is.null
[08:27:52.064]                       muffled <- FALSE
[08:27:52.064]                       if (inherits(cond, "message")) {
[08:27:52.064]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.064]                         if (muffled) 
[08:27:52.064]                           invokeRestart("muffleMessage")
[08:27:52.064]                       }
[08:27:52.064]                       else if (inherits(cond, "warning")) {
[08:27:52.064]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.064]                         if (muffled) 
[08:27:52.064]                           invokeRestart("muffleWarning")
[08:27:52.064]                       }
[08:27:52.064]                       else if (inherits(cond, "condition")) {
[08:27:52.064]                         if (!is.null(pattern)) {
[08:27:52.064]                           computeRestarts <- base::computeRestarts
[08:27:52.064]                           grepl <- base::grepl
[08:27:52.064]                           restarts <- computeRestarts(cond)
[08:27:52.064]                           for (restart in restarts) {
[08:27:52.064]                             name <- restart$name
[08:27:52.064]                             if (is.null(name)) 
[08:27:52.064]                               next
[08:27:52.064]                             if (!grepl(pattern, name)) 
[08:27:52.064]                               next
[08:27:52.064]                             invokeRestart(restart)
[08:27:52.064]                             muffled <- TRUE
[08:27:52.064]                             break
[08:27:52.064]                           }
[08:27:52.064]                         }
[08:27:52.064]                       }
[08:27:52.064]                       invisible(muffled)
[08:27:52.064]                     }
[08:27:52.064]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.064]                   }
[08:27:52.064]                 }
[08:27:52.064]                 else {
[08:27:52.064]                   if (TRUE) {
[08:27:52.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.064]                     {
[08:27:52.064]                       inherits <- base::inherits
[08:27:52.064]                       invokeRestart <- base::invokeRestart
[08:27:52.064]                       is.null <- base::is.null
[08:27:52.064]                       muffled <- FALSE
[08:27:52.064]                       if (inherits(cond, "message")) {
[08:27:52.064]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.064]                         if (muffled) 
[08:27:52.064]                           invokeRestart("muffleMessage")
[08:27:52.064]                       }
[08:27:52.064]                       else if (inherits(cond, "warning")) {
[08:27:52.064]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.064]                         if (muffled) 
[08:27:52.064]                           invokeRestart("muffleWarning")
[08:27:52.064]                       }
[08:27:52.064]                       else if (inherits(cond, "condition")) {
[08:27:52.064]                         if (!is.null(pattern)) {
[08:27:52.064]                           computeRestarts <- base::computeRestarts
[08:27:52.064]                           grepl <- base::grepl
[08:27:52.064]                           restarts <- computeRestarts(cond)
[08:27:52.064]                           for (restart in restarts) {
[08:27:52.064]                             name <- restart$name
[08:27:52.064]                             if (is.null(name)) 
[08:27:52.064]                               next
[08:27:52.064]                             if (!grepl(pattern, name)) 
[08:27:52.064]                               next
[08:27:52.064]                             invokeRestart(restart)
[08:27:52.064]                             muffled <- TRUE
[08:27:52.064]                             break
[08:27:52.064]                           }
[08:27:52.064]                         }
[08:27:52.064]                       }
[08:27:52.064]                       invisible(muffled)
[08:27:52.064]                     }
[08:27:52.064]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.064]                   }
[08:27:52.064]                 }
[08:27:52.064]             }
[08:27:52.064]         }))
[08:27:52.064]     }, error = function(ex) {
[08:27:52.064]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.064]                 ...future.rng), started = ...future.startTime, 
[08:27:52.064]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.064]             version = "1.8"), class = "FutureResult")
[08:27:52.064]     }, finally = {
[08:27:52.064]         if (!identical(...future.workdir, getwd())) 
[08:27:52.064]             setwd(...future.workdir)
[08:27:52.064]         {
[08:27:52.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.064]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.064]             }
[08:27:52.064]             base::options(...future.oldOptions)
[08:27:52.064]             if (.Platform$OS.type == "windows") {
[08:27:52.064]                 old_names <- names(...future.oldEnvVars)
[08:27:52.064]                 envs <- base::Sys.getenv()
[08:27:52.064]                 names <- names(envs)
[08:27:52.064]                 common <- intersect(names, old_names)
[08:27:52.064]                 added <- setdiff(names, old_names)
[08:27:52.064]                 removed <- setdiff(old_names, names)
[08:27:52.064]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.064]                   envs[common]]
[08:27:52.064]                 NAMES <- toupper(changed)
[08:27:52.064]                 args <- list()
[08:27:52.064]                 for (kk in seq_along(NAMES)) {
[08:27:52.064]                   name <- changed[[kk]]
[08:27:52.064]                   NAME <- NAMES[[kk]]
[08:27:52.064]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.064]                     next
[08:27:52.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.064]                 }
[08:27:52.064]                 NAMES <- toupper(added)
[08:27:52.064]                 for (kk in seq_along(NAMES)) {
[08:27:52.064]                   name <- added[[kk]]
[08:27:52.064]                   NAME <- NAMES[[kk]]
[08:27:52.064]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.064]                     next
[08:27:52.064]                   args[[name]] <- ""
[08:27:52.064]                 }
[08:27:52.064]                 NAMES <- toupper(removed)
[08:27:52.064]                 for (kk in seq_along(NAMES)) {
[08:27:52.064]                   name <- removed[[kk]]
[08:27:52.064]                   NAME <- NAMES[[kk]]
[08:27:52.064]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.064]                     next
[08:27:52.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.064]                 }
[08:27:52.064]                 if (length(args) > 0) 
[08:27:52.064]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.064]             }
[08:27:52.064]             else {
[08:27:52.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.064]             }
[08:27:52.064]             {
[08:27:52.064]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.064]                   0L) {
[08:27:52.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.064]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.064]                   base::options(opts)
[08:27:52.064]                 }
[08:27:52.064]                 {
[08:27:52.064]                   {
[08:27:52.064]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.064]                     NULL
[08:27:52.064]                   }
[08:27:52.064]                   options(future.plan = NULL)
[08:27:52.064]                   if (is.na(NA_character_)) 
[08:27:52.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.064]                     .init = FALSE)
[08:27:52.064]                 }
[08:27:52.064]             }
[08:27:52.064]         }
[08:27:52.064]     })
[08:27:52.064]     if (TRUE) {
[08:27:52.064]         base::sink(type = "output", split = FALSE)
[08:27:52.064]         if (TRUE) {
[08:27:52.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.064]         }
[08:27:52.064]         else {
[08:27:52.064]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.064]         }
[08:27:52.064]         base::close(...future.stdout)
[08:27:52.064]         ...future.stdout <- NULL
[08:27:52.064]     }
[08:27:52.064]     ...future.result$conditions <- ...future.conditions
[08:27:52.064]     ...future.result$finished <- base::Sys.time()
[08:27:52.064]     ...future.result
[08:27:52.064] }
[08:27:52.068] MultisessionFuture started
[08:27:52.068] - Launch lazy future ... done
[08:27:52.068] run() for ‘MultisessionFuture’ ... done
[08:27:52.068] getGlobalsAndPackages() ...
[08:27:52.068] Searching for globals...
[08:27:52.068] 
[08:27:52.068] Searching for globals ... DONE
[08:27:52.069] - globals: [0] <none>
[08:27:52.069] getGlobalsAndPackages() ... DONE
[08:27:52.069] run() for ‘Future’ ...
[08:27:52.069] - state: ‘created’
[08:27:52.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.083] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:52.083]   - Field: ‘node’
[08:27:52.084]   - Field: ‘label’
[08:27:52.084]   - Field: ‘local’
[08:27:52.084]   - Field: ‘owner’
[08:27:52.084]   - Field: ‘envir’
[08:27:52.084]   - Field: ‘workers’
[08:27:52.084]   - Field: ‘packages’
[08:27:52.084]   - Field: ‘gc’
[08:27:52.084]   - Field: ‘conditions’
[08:27:52.084]   - Field: ‘persistent’
[08:27:52.084]   - Field: ‘expr’
[08:27:52.084]   - Field: ‘uuid’
[08:27:52.085]   - Field: ‘seed’
[08:27:52.085]   - Field: ‘version’
[08:27:52.085]   - Field: ‘result’
[08:27:52.085]   - Field: ‘asynchronous’
[08:27:52.085]   - Field: ‘calls’
[08:27:52.085]   - Field: ‘globals’
[08:27:52.085]   - Field: ‘stdout’
[08:27:52.085]   - Field: ‘earlySignal’
[08:27:52.085]   - Field: ‘lazy’
[08:27:52.085]   - Field: ‘state’
[08:27:52.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:52.085] - Launch lazy future ...
[08:27:52.086] Packages needed by the future expression (n = 0): <none>
[08:27:52.086] Packages needed by future strategies (n = 0): <none>
[08:27:52.086] {
[08:27:52.086]     {
[08:27:52.086]         {
[08:27:52.086]             ...future.startTime <- base::Sys.time()
[08:27:52.086]             {
[08:27:52.086]                 {
[08:27:52.086]                   {
[08:27:52.086]                     {
[08:27:52.086]                       base::local({
[08:27:52.086]                         has_future <- base::requireNamespace("future", 
[08:27:52.086]                           quietly = TRUE)
[08:27:52.086]                         if (has_future) {
[08:27:52.086]                           ns <- base::getNamespace("future")
[08:27:52.086]                           version <- ns[[".package"]][["version"]]
[08:27:52.086]                           if (is.null(version)) 
[08:27:52.086]                             version <- utils::packageVersion("future")
[08:27:52.086]                         }
[08:27:52.086]                         else {
[08:27:52.086]                           version <- NULL
[08:27:52.086]                         }
[08:27:52.086]                         if (!has_future || version < "1.8.0") {
[08:27:52.086]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.086]                             "", base::R.version$version.string), 
[08:27:52.086]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.086]                               "release", "version")], collapse = " "), 
[08:27:52.086]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.086]                             info)
[08:27:52.086]                           info <- base::paste(info, collapse = "; ")
[08:27:52.086]                           if (!has_future) {
[08:27:52.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.086]                               info)
[08:27:52.086]                           }
[08:27:52.086]                           else {
[08:27:52.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.086]                               info, version)
[08:27:52.086]                           }
[08:27:52.086]                           base::stop(msg)
[08:27:52.086]                         }
[08:27:52.086]                       })
[08:27:52.086]                     }
[08:27:52.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.086]                     base::options(mc.cores = 1L)
[08:27:52.086]                   }
[08:27:52.086]                   ...future.strategy.old <- future::plan("list")
[08:27:52.086]                   options(future.plan = NULL)
[08:27:52.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.086]                 }
[08:27:52.086]                 ...future.workdir <- getwd()
[08:27:52.086]             }
[08:27:52.086]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.086]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.086]         }
[08:27:52.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.086]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.086]             base::names(...future.oldOptions))
[08:27:52.086]     }
[08:27:52.086]     if (FALSE) {
[08:27:52.086]     }
[08:27:52.086]     else {
[08:27:52.086]         if (TRUE) {
[08:27:52.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.086]                 open = "w")
[08:27:52.086]         }
[08:27:52.086]         else {
[08:27:52.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.086]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.086]         }
[08:27:52.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.086]             base::sink(type = "output", split = FALSE)
[08:27:52.086]             base::close(...future.stdout)
[08:27:52.086]         }, add = TRUE)
[08:27:52.086]     }
[08:27:52.086]     ...future.frame <- base::sys.nframe()
[08:27:52.086]     ...future.conditions <- base::list()
[08:27:52.086]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.086]     if (FALSE) {
[08:27:52.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.086]     }
[08:27:52.086]     ...future.result <- base::tryCatch({
[08:27:52.086]         base::withCallingHandlers({
[08:27:52.086]             ...future.value <- base::withVisible(base::local({
[08:27:52.086]                 ...future.makeSendCondition <- base::local({
[08:27:52.086]                   sendCondition <- NULL
[08:27:52.086]                   function(frame = 1L) {
[08:27:52.086]                     if (is.function(sendCondition)) 
[08:27:52.086]                       return(sendCondition)
[08:27:52.086]                     ns <- getNamespace("parallel")
[08:27:52.086]                     if (exists("sendData", mode = "function", 
[08:27:52.086]                       envir = ns)) {
[08:27:52.086]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:52.086]                         envir = ns)
[08:27:52.086]                       envir <- sys.frame(frame)
[08:27:52.086]                       master <- NULL
[08:27:52.086]                       while (!identical(envir, .GlobalEnv) && 
[08:27:52.086]                         !identical(envir, emptyenv())) {
[08:27:52.086]                         if (exists("master", mode = "list", envir = envir, 
[08:27:52.086]                           inherits = FALSE)) {
[08:27:52.086]                           master <- get("master", mode = "list", 
[08:27:52.086]                             envir = envir, inherits = FALSE)
[08:27:52.086]                           if (inherits(master, c("SOCKnode", 
[08:27:52.086]                             "SOCK0node"))) {
[08:27:52.086]                             sendCondition <<- function(cond) {
[08:27:52.086]                               data <- list(type = "VALUE", value = cond, 
[08:27:52.086]                                 success = TRUE)
[08:27:52.086]                               parallel_sendData(master, data)
[08:27:52.086]                             }
[08:27:52.086]                             return(sendCondition)
[08:27:52.086]                           }
[08:27:52.086]                         }
[08:27:52.086]                         frame <- frame + 1L
[08:27:52.086]                         envir <- sys.frame(frame)
[08:27:52.086]                       }
[08:27:52.086]                     }
[08:27:52.086]                     sendCondition <<- function(cond) NULL
[08:27:52.086]                   }
[08:27:52.086]                 })
[08:27:52.086]                 withCallingHandlers({
[08:27:52.086]                   NULL
[08:27:52.086]                 }, immediateCondition = function(cond) {
[08:27:52.086]                   sendCondition <- ...future.makeSendCondition()
[08:27:52.086]                   sendCondition(cond)
[08:27:52.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.086]                   {
[08:27:52.086]                     inherits <- base::inherits
[08:27:52.086]                     invokeRestart <- base::invokeRestart
[08:27:52.086]                     is.null <- base::is.null
[08:27:52.086]                     muffled <- FALSE
[08:27:52.086]                     if (inherits(cond, "message")) {
[08:27:52.086]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.086]                       if (muffled) 
[08:27:52.086]                         invokeRestart("muffleMessage")
[08:27:52.086]                     }
[08:27:52.086]                     else if (inherits(cond, "warning")) {
[08:27:52.086]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.086]                       if (muffled) 
[08:27:52.086]                         invokeRestart("muffleWarning")
[08:27:52.086]                     }
[08:27:52.086]                     else if (inherits(cond, "condition")) {
[08:27:52.086]                       if (!is.null(pattern)) {
[08:27:52.086]                         computeRestarts <- base::computeRestarts
[08:27:52.086]                         grepl <- base::grepl
[08:27:52.086]                         restarts <- computeRestarts(cond)
[08:27:52.086]                         for (restart in restarts) {
[08:27:52.086]                           name <- restart$name
[08:27:52.086]                           if (is.null(name)) 
[08:27:52.086]                             next
[08:27:52.086]                           if (!grepl(pattern, name)) 
[08:27:52.086]                             next
[08:27:52.086]                           invokeRestart(restart)
[08:27:52.086]                           muffled <- TRUE
[08:27:52.086]                           break
[08:27:52.086]                         }
[08:27:52.086]                       }
[08:27:52.086]                     }
[08:27:52.086]                     invisible(muffled)
[08:27:52.086]                   }
[08:27:52.086]                   muffleCondition(cond)
[08:27:52.086]                 })
[08:27:52.086]             }))
[08:27:52.086]             future::FutureResult(value = ...future.value$value, 
[08:27:52.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.086]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.086]                     ...future.globalenv.names))
[08:27:52.086]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.086]         }, condition = base::local({
[08:27:52.086]             c <- base::c
[08:27:52.086]             inherits <- base::inherits
[08:27:52.086]             invokeRestart <- base::invokeRestart
[08:27:52.086]             length <- base::length
[08:27:52.086]             list <- base::list
[08:27:52.086]             seq.int <- base::seq.int
[08:27:52.086]             signalCondition <- base::signalCondition
[08:27:52.086]             sys.calls <- base::sys.calls
[08:27:52.086]             `[[` <- base::`[[`
[08:27:52.086]             `+` <- base::`+`
[08:27:52.086]             `<<-` <- base::`<<-`
[08:27:52.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.086]                   3L)]
[08:27:52.086]             }
[08:27:52.086]             function(cond) {
[08:27:52.086]                 is_error <- inherits(cond, "error")
[08:27:52.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.086]                   NULL)
[08:27:52.086]                 if (is_error) {
[08:27:52.086]                   sessionInformation <- function() {
[08:27:52.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.086]                       search = base::search(), system = base::Sys.info())
[08:27:52.086]                   }
[08:27:52.086]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.086]                     cond$call), session = sessionInformation(), 
[08:27:52.086]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.086]                   signalCondition(cond)
[08:27:52.086]                 }
[08:27:52.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.086]                 "immediateCondition"))) {
[08:27:52.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.086]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.086]                   if (TRUE && !signal) {
[08:27:52.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.086]                     {
[08:27:52.086]                       inherits <- base::inherits
[08:27:52.086]                       invokeRestart <- base::invokeRestart
[08:27:52.086]                       is.null <- base::is.null
[08:27:52.086]                       muffled <- FALSE
[08:27:52.086]                       if (inherits(cond, "message")) {
[08:27:52.086]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.086]                         if (muffled) 
[08:27:52.086]                           invokeRestart("muffleMessage")
[08:27:52.086]                       }
[08:27:52.086]                       else if (inherits(cond, "warning")) {
[08:27:52.086]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.086]                         if (muffled) 
[08:27:52.086]                           invokeRestart("muffleWarning")
[08:27:52.086]                       }
[08:27:52.086]                       else if (inherits(cond, "condition")) {
[08:27:52.086]                         if (!is.null(pattern)) {
[08:27:52.086]                           computeRestarts <- base::computeRestarts
[08:27:52.086]                           grepl <- base::grepl
[08:27:52.086]                           restarts <- computeRestarts(cond)
[08:27:52.086]                           for (restart in restarts) {
[08:27:52.086]                             name <- restart$name
[08:27:52.086]                             if (is.null(name)) 
[08:27:52.086]                               next
[08:27:52.086]                             if (!grepl(pattern, name)) 
[08:27:52.086]                               next
[08:27:52.086]                             invokeRestart(restart)
[08:27:52.086]                             muffled <- TRUE
[08:27:52.086]                             break
[08:27:52.086]                           }
[08:27:52.086]                         }
[08:27:52.086]                       }
[08:27:52.086]                       invisible(muffled)
[08:27:52.086]                     }
[08:27:52.086]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.086]                   }
[08:27:52.086]                 }
[08:27:52.086]                 else {
[08:27:52.086]                   if (TRUE) {
[08:27:52.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.086]                     {
[08:27:52.086]                       inherits <- base::inherits
[08:27:52.086]                       invokeRestart <- base::invokeRestart
[08:27:52.086]                       is.null <- base::is.null
[08:27:52.086]                       muffled <- FALSE
[08:27:52.086]                       if (inherits(cond, "message")) {
[08:27:52.086]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.086]                         if (muffled) 
[08:27:52.086]                           invokeRestart("muffleMessage")
[08:27:52.086]                       }
[08:27:52.086]                       else if (inherits(cond, "warning")) {
[08:27:52.086]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.086]                         if (muffled) 
[08:27:52.086]                           invokeRestart("muffleWarning")
[08:27:52.086]                       }
[08:27:52.086]                       else if (inherits(cond, "condition")) {
[08:27:52.086]                         if (!is.null(pattern)) {
[08:27:52.086]                           computeRestarts <- base::computeRestarts
[08:27:52.086]                           grepl <- base::grepl
[08:27:52.086]                           restarts <- computeRestarts(cond)
[08:27:52.086]                           for (restart in restarts) {
[08:27:52.086]                             name <- restart$name
[08:27:52.086]                             if (is.null(name)) 
[08:27:52.086]                               next
[08:27:52.086]                             if (!grepl(pattern, name)) 
[08:27:52.086]                               next
[08:27:52.086]                             invokeRestart(restart)
[08:27:52.086]                             muffled <- TRUE
[08:27:52.086]                             break
[08:27:52.086]                           }
[08:27:52.086]                         }
[08:27:52.086]                       }
[08:27:52.086]                       invisible(muffled)
[08:27:52.086]                     }
[08:27:52.086]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.086]                   }
[08:27:52.086]                 }
[08:27:52.086]             }
[08:27:52.086]         }))
[08:27:52.086]     }, error = function(ex) {
[08:27:52.086]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.086]                 ...future.rng), started = ...future.startTime, 
[08:27:52.086]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.086]             version = "1.8"), class = "FutureResult")
[08:27:52.086]     }, finally = {
[08:27:52.086]         if (!identical(...future.workdir, getwd())) 
[08:27:52.086]             setwd(...future.workdir)
[08:27:52.086]         {
[08:27:52.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.086]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.086]             }
[08:27:52.086]             base::options(...future.oldOptions)
[08:27:52.086]             if (.Platform$OS.type == "windows") {
[08:27:52.086]                 old_names <- names(...future.oldEnvVars)
[08:27:52.086]                 envs <- base::Sys.getenv()
[08:27:52.086]                 names <- names(envs)
[08:27:52.086]                 common <- intersect(names, old_names)
[08:27:52.086]                 added <- setdiff(names, old_names)
[08:27:52.086]                 removed <- setdiff(old_names, names)
[08:27:52.086]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.086]                   envs[common]]
[08:27:52.086]                 NAMES <- toupper(changed)
[08:27:52.086]                 args <- list()
[08:27:52.086]                 for (kk in seq_along(NAMES)) {
[08:27:52.086]                   name <- changed[[kk]]
[08:27:52.086]                   NAME <- NAMES[[kk]]
[08:27:52.086]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.086]                     next
[08:27:52.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.086]                 }
[08:27:52.086]                 NAMES <- toupper(added)
[08:27:52.086]                 for (kk in seq_along(NAMES)) {
[08:27:52.086]                   name <- added[[kk]]
[08:27:52.086]                   NAME <- NAMES[[kk]]
[08:27:52.086]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.086]                     next
[08:27:52.086]                   args[[name]] <- ""
[08:27:52.086]                 }
[08:27:52.086]                 NAMES <- toupper(removed)
[08:27:52.086]                 for (kk in seq_along(NAMES)) {
[08:27:52.086]                   name <- removed[[kk]]
[08:27:52.086]                   NAME <- NAMES[[kk]]
[08:27:52.086]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.086]                     next
[08:27:52.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.086]                 }
[08:27:52.086]                 if (length(args) > 0) 
[08:27:52.086]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.086]             }
[08:27:52.086]             else {
[08:27:52.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.086]             }
[08:27:52.086]             {
[08:27:52.086]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.086]                   0L) {
[08:27:52.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.086]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.086]                   base::options(opts)
[08:27:52.086]                 }
[08:27:52.086]                 {
[08:27:52.086]                   {
[08:27:52.086]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.086]                     NULL
[08:27:52.086]                   }
[08:27:52.086]                   options(future.plan = NULL)
[08:27:52.086]                   if (is.na(NA_character_)) 
[08:27:52.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.086]                     .init = FALSE)
[08:27:52.086]                 }
[08:27:52.086]             }
[08:27:52.086]         }
[08:27:52.086]     })
[08:27:52.086]     if (TRUE) {
[08:27:52.086]         base::sink(type = "output", split = FALSE)
[08:27:52.086]         if (TRUE) {
[08:27:52.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.086]         }
[08:27:52.086]         else {
[08:27:52.086]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.086]         }
[08:27:52.086]         base::close(...future.stdout)
[08:27:52.086]         ...future.stdout <- NULL
[08:27:52.086]     }
[08:27:52.086]     ...future.result$conditions <- ...future.conditions
[08:27:52.086]     ...future.result$finished <- base::Sys.time()
[08:27:52.086]     ...future.result
[08:27:52.086] }
[08:27:52.089] MultisessionFuture started
[08:27:52.089] - Launch lazy future ... done
[08:27:52.090] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d85f26fd20> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d8620837b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d85f26fd20> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d8620837b0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:52.117] resolve() on list ...
[08:27:52.117]  recursive: 0
[08:27:52.117]  length: 6
[08:27:52.117]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:52.118] signalConditionsASAP(numeric, pos=1) ...
[08:27:52.118] - nx: 6
[08:27:52.118] - relay: TRUE
[08:27:52.118] - stdout: TRUE
[08:27:52.118] - signal: TRUE
[08:27:52.118] - resignal: FALSE
[08:27:52.118] - force: TRUE
[08:27:52.118] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.118] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.118]  - until=2
[08:27:52.118]  - relaying element #2
[08:27:52.118] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.119] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.119] signalConditionsASAP(NULL, pos=1) ... done
[08:27:52.119]  length: 5 (resolved future 1)
[08:27:52.119] receiveMessageFromWorker() for ClusterFuture ...
[08:27:52.119] - Validating connection of MultisessionFuture
[08:27:52.120] - received message: FutureResult
[08:27:52.120] - Received FutureResult
[08:27:52.120] - Erased future from FutureRegistry
[08:27:52.120] result() for ClusterFuture ...
[08:27:52.120] - result already collected: FutureResult
[08:27:52.120] result() for ClusterFuture ... done
[08:27:52.120] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:52.120] Future #2
[08:27:52.120] result() for ClusterFuture ...
[08:27:52.120] - result already collected: FutureResult
[08:27:52.120] result() for ClusterFuture ... done
[08:27:52.121] result() for ClusterFuture ...
[08:27:52.121] - result already collected: FutureResult
[08:27:52.121] result() for ClusterFuture ... done
[08:27:52.121] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:52.121] - nx: 6
[08:27:52.121] - relay: TRUE
[08:27:52.121] - stdout: TRUE
[08:27:52.121] - signal: TRUE
[08:27:52.121] - resignal: FALSE
[08:27:52.121] - force: TRUE
[08:27:52.121] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.121] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.121]  - until=2
[08:27:52.122]  - relaying element #2
[08:27:52.122] result() for ClusterFuture ...
[08:27:52.122] - result already collected: FutureResult
[08:27:52.122] result() for ClusterFuture ... done
[08:27:52.122] result() for ClusterFuture ...
[08:27:52.122] - result already collected: FutureResult
[08:27:52.122] result() for ClusterFuture ... done
[08:27:52.122] result() for ClusterFuture ...
[08:27:52.122] - result already collected: FutureResult
[08:27:52.122] result() for ClusterFuture ... done
[08:27:52.122] result() for ClusterFuture ...
[08:27:52.123] - result already collected: FutureResult
[08:27:52.123] result() for ClusterFuture ... done
[08:27:52.123] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.123] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.123] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:52.123]  length: 4 (resolved future 2)
[08:27:52.131] receiveMessageFromWorker() for ClusterFuture ...
[08:27:52.131] - Validating connection of MultisessionFuture
[08:27:52.132] - received message: FutureResult
[08:27:52.132] - Received FutureResult
[08:27:52.132] - Erased future from FutureRegistry
[08:27:52.132] result() for ClusterFuture ...
[08:27:52.132] - result already collected: FutureResult
[08:27:52.132] result() for ClusterFuture ... done
[08:27:52.132] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:52.132] Future #3
[08:27:52.132] result() for ClusterFuture ...
[08:27:52.133] - result already collected: FutureResult
[08:27:52.133] result() for ClusterFuture ... done
[08:27:52.133] result() for ClusterFuture ...
[08:27:52.133] - result already collected: FutureResult
[08:27:52.133] result() for ClusterFuture ... done
[08:27:52.133] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:52.133] - nx: 6
[08:27:52.133] - relay: TRUE
[08:27:52.133] - stdout: TRUE
[08:27:52.133] - signal: TRUE
[08:27:52.133] - resignal: FALSE
[08:27:52.133] - force: TRUE
[08:27:52.134] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.134] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.134]  - until=3
[08:27:52.134]  - relaying element #3
[08:27:52.134] result() for ClusterFuture ...
[08:27:52.134] - result already collected: FutureResult
[08:27:52.134] result() for ClusterFuture ... done
[08:27:52.134] result() for ClusterFuture ...
[08:27:52.134] - result already collected: FutureResult
[08:27:52.134] result() for ClusterFuture ... done
[08:27:52.134] result() for ClusterFuture ...
[08:27:52.134] - result already collected: FutureResult
[08:27:52.135] result() for ClusterFuture ... done
[08:27:52.135] result() for ClusterFuture ...
[08:27:52.135] - result already collected: FutureResult
[08:27:52.135] result() for ClusterFuture ... done
[08:27:52.135] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.135] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.135] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:52.135]  length: 3 (resolved future 3)
[08:27:52.135] signalConditionsASAP(NULL, pos=4) ...
[08:27:52.135] - nx: 6
[08:27:52.135] - relay: TRUE
[08:27:52.135] - stdout: TRUE
[08:27:52.136] - signal: TRUE
[08:27:52.136] - resignal: FALSE
[08:27:52.136] - force: TRUE
[08:27:52.136] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.136] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.136]  - until=5
[08:27:52.136]  - relaying element #5
[08:27:52.136] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:52.136] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.136] signalConditionsASAP(NULL, pos=4) ... done
[08:27:52.136]  length: 2 (resolved future 4)
[08:27:52.136] signalConditionsASAP(NULL, pos=5) ...
[08:27:52.137] - nx: 6
[08:27:52.137] - relay: TRUE
[08:27:52.137] - stdout: TRUE
[08:27:52.137] - signal: TRUE
[08:27:52.137] - resignal: FALSE
[08:27:52.137] - force: TRUE
[08:27:52.137] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:52.137] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.137]  - until=6
[08:27:52.137]  - relaying element #6
[08:27:52.137] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:52.137] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.137] signalConditionsASAP(NULL, pos=5) ... done
[08:27:52.138]  length: 1 (resolved future 5)
[08:27:52.138] signalConditionsASAP(numeric, pos=6) ...
[08:27:52.138] - nx: 6
[08:27:52.138] - relay: TRUE
[08:27:52.138] - stdout: TRUE
[08:27:52.138] - signal: TRUE
[08:27:52.138] - resignal: FALSE
[08:27:52.138] - force: TRUE
[08:27:52.138] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:52.138] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.138]  - until=6
[08:27:52.138] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.138] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.139] signalConditionsASAP(numeric, pos=6) ... done
[08:27:52.139]  length: 0 (resolved future 6)
[08:27:52.139] Relaying remaining futures
[08:27:52.139] signalConditionsASAP(NULL, pos=0) ...
[08:27:52.139] - nx: 6
[08:27:52.139] - relay: TRUE
[08:27:52.139] - stdout: TRUE
[08:27:52.139] - signal: TRUE
[08:27:52.139] - resignal: FALSE
[08:27:52.139] - force: TRUE
[08:27:52.139] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.139] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:52.140] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.140] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.140] signalConditionsASAP(NULL, pos=0) ... done
[08:27:52.140] resolve() on list ... DONE
[08:27:52.140] result() for ClusterFuture ...
[08:27:52.140] - result already collected: FutureResult
[08:27:52.140] result() for ClusterFuture ... done
[08:27:52.140] result() for ClusterFuture ...
[08:27:52.140] - result already collected: FutureResult
[08:27:52.140] result() for ClusterFuture ... done
[08:27:52.140] result() for ClusterFuture ...
[08:27:52.140] - result already collected: FutureResult
[08:27:52.141] result() for ClusterFuture ... done
[08:27:52.141] result() for ClusterFuture ...
[08:27:52.141] - result already collected: FutureResult
[08:27:52.141] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[08:27:52.144] getGlobalsAndPackages() ...
[08:27:52.144] Searching for globals...
[08:27:52.144] 
[08:27:52.145] Searching for globals ... DONE
[08:27:52.145] - globals: [0] <none>
[08:27:52.145] getGlobalsAndPackages() ... DONE
[08:27:52.145] run() for ‘Future’ ...
[08:27:52.145] - state: ‘created’
[08:27:52.145] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.160] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.160] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:52.160]   - Field: ‘node’
[08:27:52.160]   - Field: ‘label’
[08:27:52.160]   - Field: ‘local’
[08:27:52.160]   - Field: ‘owner’
[08:27:52.160]   - Field: ‘envir’
[08:27:52.160]   - Field: ‘workers’
[08:27:52.161]   - Field: ‘packages’
[08:27:52.161]   - Field: ‘gc’
[08:27:52.161]   - Field: ‘conditions’
[08:27:52.161]   - Field: ‘persistent’
[08:27:52.161]   - Field: ‘expr’
[08:27:52.161]   - Field: ‘uuid’
[08:27:52.161]   - Field: ‘seed’
[08:27:52.161]   - Field: ‘version’
[08:27:52.161]   - Field: ‘result’
[08:27:52.161]   - Field: ‘asynchronous’
[08:27:52.161]   - Field: ‘calls’
[08:27:52.161]   - Field: ‘globals’
[08:27:52.162]   - Field: ‘stdout’
[08:27:52.162]   - Field: ‘earlySignal’
[08:27:52.162]   - Field: ‘lazy’
[08:27:52.162]   - Field: ‘state’
[08:27:52.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:52.164] - Launch lazy future ...
[08:27:52.164] Packages needed by the future expression (n = 0): <none>
[08:27:52.164] Packages needed by future strategies (n = 0): <none>
[08:27:52.165] {
[08:27:52.165]     {
[08:27:52.165]         {
[08:27:52.165]             ...future.startTime <- base::Sys.time()
[08:27:52.165]             {
[08:27:52.165]                 {
[08:27:52.165]                   {
[08:27:52.165]                     {
[08:27:52.165]                       base::local({
[08:27:52.165]                         has_future <- base::requireNamespace("future", 
[08:27:52.165]                           quietly = TRUE)
[08:27:52.165]                         if (has_future) {
[08:27:52.165]                           ns <- base::getNamespace("future")
[08:27:52.165]                           version <- ns[[".package"]][["version"]]
[08:27:52.165]                           if (is.null(version)) 
[08:27:52.165]                             version <- utils::packageVersion("future")
[08:27:52.165]                         }
[08:27:52.165]                         else {
[08:27:52.165]                           version <- NULL
[08:27:52.165]                         }
[08:27:52.165]                         if (!has_future || version < "1.8.0") {
[08:27:52.165]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.165]                             "", base::R.version$version.string), 
[08:27:52.165]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.165]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.165]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.165]                               "release", "version")], collapse = " "), 
[08:27:52.165]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.165]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.165]                             info)
[08:27:52.165]                           info <- base::paste(info, collapse = "; ")
[08:27:52.165]                           if (!has_future) {
[08:27:52.165]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.165]                               info)
[08:27:52.165]                           }
[08:27:52.165]                           else {
[08:27:52.165]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.165]                               info, version)
[08:27:52.165]                           }
[08:27:52.165]                           base::stop(msg)
[08:27:52.165]                         }
[08:27:52.165]                       })
[08:27:52.165]                     }
[08:27:52.165]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.165]                     base::options(mc.cores = 1L)
[08:27:52.165]                   }
[08:27:52.165]                   ...future.strategy.old <- future::plan("list")
[08:27:52.165]                   options(future.plan = NULL)
[08:27:52.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.165]                 }
[08:27:52.165]                 ...future.workdir <- getwd()
[08:27:52.165]             }
[08:27:52.165]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.165]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.165]         }
[08:27:52.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.165]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.165]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.165]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.165]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.165]             base::names(...future.oldOptions))
[08:27:52.165]     }
[08:27:52.165]     if (FALSE) {
[08:27:52.165]     }
[08:27:52.165]     else {
[08:27:52.165]         if (TRUE) {
[08:27:52.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.165]                 open = "w")
[08:27:52.165]         }
[08:27:52.165]         else {
[08:27:52.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.165]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.165]         }
[08:27:52.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.165]             base::sink(type = "output", split = FALSE)
[08:27:52.165]             base::close(...future.stdout)
[08:27:52.165]         }, add = TRUE)
[08:27:52.165]     }
[08:27:52.165]     ...future.frame <- base::sys.nframe()
[08:27:52.165]     ...future.conditions <- base::list()
[08:27:52.165]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.165]     if (FALSE) {
[08:27:52.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.165]     }
[08:27:52.165]     ...future.result <- base::tryCatch({
[08:27:52.165]         base::withCallingHandlers({
[08:27:52.165]             ...future.value <- base::withVisible(base::local({
[08:27:52.165]                 ...future.makeSendCondition <- base::local({
[08:27:52.165]                   sendCondition <- NULL
[08:27:52.165]                   function(frame = 1L) {
[08:27:52.165]                     if (is.function(sendCondition)) 
[08:27:52.165]                       return(sendCondition)
[08:27:52.165]                     ns <- getNamespace("parallel")
[08:27:52.165]                     if (exists("sendData", mode = "function", 
[08:27:52.165]                       envir = ns)) {
[08:27:52.165]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:52.165]                         envir = ns)
[08:27:52.165]                       envir <- sys.frame(frame)
[08:27:52.165]                       master <- NULL
[08:27:52.165]                       while (!identical(envir, .GlobalEnv) && 
[08:27:52.165]                         !identical(envir, emptyenv())) {
[08:27:52.165]                         if (exists("master", mode = "list", envir = envir, 
[08:27:52.165]                           inherits = FALSE)) {
[08:27:52.165]                           master <- get("master", mode = "list", 
[08:27:52.165]                             envir = envir, inherits = FALSE)
[08:27:52.165]                           if (inherits(master, c("SOCKnode", 
[08:27:52.165]                             "SOCK0node"))) {
[08:27:52.165]                             sendCondition <<- function(cond) {
[08:27:52.165]                               data <- list(type = "VALUE", value = cond, 
[08:27:52.165]                                 success = TRUE)
[08:27:52.165]                               parallel_sendData(master, data)
[08:27:52.165]                             }
[08:27:52.165]                             return(sendCondition)
[08:27:52.165]                           }
[08:27:52.165]                         }
[08:27:52.165]                         frame <- frame + 1L
[08:27:52.165]                         envir <- sys.frame(frame)
[08:27:52.165]                       }
[08:27:52.165]                     }
[08:27:52.165]                     sendCondition <<- function(cond) NULL
[08:27:52.165]                   }
[08:27:52.165]                 })
[08:27:52.165]                 withCallingHandlers({
[08:27:52.165]                   2
[08:27:52.165]                 }, immediateCondition = function(cond) {
[08:27:52.165]                   sendCondition <- ...future.makeSendCondition()
[08:27:52.165]                   sendCondition(cond)
[08:27:52.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.165]                   {
[08:27:52.165]                     inherits <- base::inherits
[08:27:52.165]                     invokeRestart <- base::invokeRestart
[08:27:52.165]                     is.null <- base::is.null
[08:27:52.165]                     muffled <- FALSE
[08:27:52.165]                     if (inherits(cond, "message")) {
[08:27:52.165]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.165]                       if (muffled) 
[08:27:52.165]                         invokeRestart("muffleMessage")
[08:27:52.165]                     }
[08:27:52.165]                     else if (inherits(cond, "warning")) {
[08:27:52.165]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.165]                       if (muffled) 
[08:27:52.165]                         invokeRestart("muffleWarning")
[08:27:52.165]                     }
[08:27:52.165]                     else if (inherits(cond, "condition")) {
[08:27:52.165]                       if (!is.null(pattern)) {
[08:27:52.165]                         computeRestarts <- base::computeRestarts
[08:27:52.165]                         grepl <- base::grepl
[08:27:52.165]                         restarts <- computeRestarts(cond)
[08:27:52.165]                         for (restart in restarts) {
[08:27:52.165]                           name <- restart$name
[08:27:52.165]                           if (is.null(name)) 
[08:27:52.165]                             next
[08:27:52.165]                           if (!grepl(pattern, name)) 
[08:27:52.165]                             next
[08:27:52.165]                           invokeRestart(restart)
[08:27:52.165]                           muffled <- TRUE
[08:27:52.165]                           break
[08:27:52.165]                         }
[08:27:52.165]                       }
[08:27:52.165]                     }
[08:27:52.165]                     invisible(muffled)
[08:27:52.165]                   }
[08:27:52.165]                   muffleCondition(cond)
[08:27:52.165]                 })
[08:27:52.165]             }))
[08:27:52.165]             future::FutureResult(value = ...future.value$value, 
[08:27:52.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.165]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.165]                     ...future.globalenv.names))
[08:27:52.165]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.165]         }, condition = base::local({
[08:27:52.165]             c <- base::c
[08:27:52.165]             inherits <- base::inherits
[08:27:52.165]             invokeRestart <- base::invokeRestart
[08:27:52.165]             length <- base::length
[08:27:52.165]             list <- base::list
[08:27:52.165]             seq.int <- base::seq.int
[08:27:52.165]             signalCondition <- base::signalCondition
[08:27:52.165]             sys.calls <- base::sys.calls
[08:27:52.165]             `[[` <- base::`[[`
[08:27:52.165]             `+` <- base::`+`
[08:27:52.165]             `<<-` <- base::`<<-`
[08:27:52.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.165]                   3L)]
[08:27:52.165]             }
[08:27:52.165]             function(cond) {
[08:27:52.165]                 is_error <- inherits(cond, "error")
[08:27:52.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.165]                   NULL)
[08:27:52.165]                 if (is_error) {
[08:27:52.165]                   sessionInformation <- function() {
[08:27:52.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.165]                       search = base::search(), system = base::Sys.info())
[08:27:52.165]                   }
[08:27:52.165]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.165]                     cond$call), session = sessionInformation(), 
[08:27:52.165]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.165]                   signalCondition(cond)
[08:27:52.165]                 }
[08:27:52.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.165]                 "immediateCondition"))) {
[08:27:52.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.165]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.165]                   if (TRUE && !signal) {
[08:27:52.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.165]                     {
[08:27:52.165]                       inherits <- base::inherits
[08:27:52.165]                       invokeRestart <- base::invokeRestart
[08:27:52.165]                       is.null <- base::is.null
[08:27:52.165]                       muffled <- FALSE
[08:27:52.165]                       if (inherits(cond, "message")) {
[08:27:52.165]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.165]                         if (muffled) 
[08:27:52.165]                           invokeRestart("muffleMessage")
[08:27:52.165]                       }
[08:27:52.165]                       else if (inherits(cond, "warning")) {
[08:27:52.165]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.165]                         if (muffled) 
[08:27:52.165]                           invokeRestart("muffleWarning")
[08:27:52.165]                       }
[08:27:52.165]                       else if (inherits(cond, "condition")) {
[08:27:52.165]                         if (!is.null(pattern)) {
[08:27:52.165]                           computeRestarts <- base::computeRestarts
[08:27:52.165]                           grepl <- base::grepl
[08:27:52.165]                           restarts <- computeRestarts(cond)
[08:27:52.165]                           for (restart in restarts) {
[08:27:52.165]                             name <- restart$name
[08:27:52.165]                             if (is.null(name)) 
[08:27:52.165]                               next
[08:27:52.165]                             if (!grepl(pattern, name)) 
[08:27:52.165]                               next
[08:27:52.165]                             invokeRestart(restart)
[08:27:52.165]                             muffled <- TRUE
[08:27:52.165]                             break
[08:27:52.165]                           }
[08:27:52.165]                         }
[08:27:52.165]                       }
[08:27:52.165]                       invisible(muffled)
[08:27:52.165]                     }
[08:27:52.165]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.165]                   }
[08:27:52.165]                 }
[08:27:52.165]                 else {
[08:27:52.165]                   if (TRUE) {
[08:27:52.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.165]                     {
[08:27:52.165]                       inherits <- base::inherits
[08:27:52.165]                       invokeRestart <- base::invokeRestart
[08:27:52.165]                       is.null <- base::is.null
[08:27:52.165]                       muffled <- FALSE
[08:27:52.165]                       if (inherits(cond, "message")) {
[08:27:52.165]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.165]                         if (muffled) 
[08:27:52.165]                           invokeRestart("muffleMessage")
[08:27:52.165]                       }
[08:27:52.165]                       else if (inherits(cond, "warning")) {
[08:27:52.165]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.165]                         if (muffled) 
[08:27:52.165]                           invokeRestart("muffleWarning")
[08:27:52.165]                       }
[08:27:52.165]                       else if (inherits(cond, "condition")) {
[08:27:52.165]                         if (!is.null(pattern)) {
[08:27:52.165]                           computeRestarts <- base::computeRestarts
[08:27:52.165]                           grepl <- base::grepl
[08:27:52.165]                           restarts <- computeRestarts(cond)
[08:27:52.165]                           for (restart in restarts) {
[08:27:52.165]                             name <- restart$name
[08:27:52.165]                             if (is.null(name)) 
[08:27:52.165]                               next
[08:27:52.165]                             if (!grepl(pattern, name)) 
[08:27:52.165]                               next
[08:27:52.165]                             invokeRestart(restart)
[08:27:52.165]                             muffled <- TRUE
[08:27:52.165]                             break
[08:27:52.165]                           }
[08:27:52.165]                         }
[08:27:52.165]                       }
[08:27:52.165]                       invisible(muffled)
[08:27:52.165]                     }
[08:27:52.165]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.165]                   }
[08:27:52.165]                 }
[08:27:52.165]             }
[08:27:52.165]         }))
[08:27:52.165]     }, error = function(ex) {
[08:27:52.165]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.165]                 ...future.rng), started = ...future.startTime, 
[08:27:52.165]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.165]             version = "1.8"), class = "FutureResult")
[08:27:52.165]     }, finally = {
[08:27:52.165]         if (!identical(...future.workdir, getwd())) 
[08:27:52.165]             setwd(...future.workdir)
[08:27:52.165]         {
[08:27:52.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.165]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.165]             }
[08:27:52.165]             base::options(...future.oldOptions)
[08:27:52.165]             if (.Platform$OS.type == "windows") {
[08:27:52.165]                 old_names <- names(...future.oldEnvVars)
[08:27:52.165]                 envs <- base::Sys.getenv()
[08:27:52.165]                 names <- names(envs)
[08:27:52.165]                 common <- intersect(names, old_names)
[08:27:52.165]                 added <- setdiff(names, old_names)
[08:27:52.165]                 removed <- setdiff(old_names, names)
[08:27:52.165]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.165]                   envs[common]]
[08:27:52.165]                 NAMES <- toupper(changed)
[08:27:52.165]                 args <- list()
[08:27:52.165]                 for (kk in seq_along(NAMES)) {
[08:27:52.165]                   name <- changed[[kk]]
[08:27:52.165]                   NAME <- NAMES[[kk]]
[08:27:52.165]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.165]                     next
[08:27:52.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.165]                 }
[08:27:52.165]                 NAMES <- toupper(added)
[08:27:52.165]                 for (kk in seq_along(NAMES)) {
[08:27:52.165]                   name <- added[[kk]]
[08:27:52.165]                   NAME <- NAMES[[kk]]
[08:27:52.165]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.165]                     next
[08:27:52.165]                   args[[name]] <- ""
[08:27:52.165]                 }
[08:27:52.165]                 NAMES <- toupper(removed)
[08:27:52.165]                 for (kk in seq_along(NAMES)) {
[08:27:52.165]                   name <- removed[[kk]]
[08:27:52.165]                   NAME <- NAMES[[kk]]
[08:27:52.165]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.165]                     next
[08:27:52.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.165]                 }
[08:27:52.165]                 if (length(args) > 0) 
[08:27:52.165]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.165]             }
[08:27:52.165]             else {
[08:27:52.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.165]             }
[08:27:52.165]             {
[08:27:52.165]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.165]                   0L) {
[08:27:52.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.165]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.165]                   base::options(opts)
[08:27:52.165]                 }
[08:27:52.165]                 {
[08:27:52.165]                   {
[08:27:52.165]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.165]                     NULL
[08:27:52.165]                   }
[08:27:52.165]                   options(future.plan = NULL)
[08:27:52.165]                   if (is.na(NA_character_)) 
[08:27:52.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.165]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.165]                     .init = FALSE)
[08:27:52.165]                 }
[08:27:52.165]             }
[08:27:52.165]         }
[08:27:52.165]     })
[08:27:52.165]     if (TRUE) {
[08:27:52.165]         base::sink(type = "output", split = FALSE)
[08:27:52.165]         if (TRUE) {
[08:27:52.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.165]         }
[08:27:52.165]         else {
[08:27:52.165]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.165]         }
[08:27:52.165]         base::close(...future.stdout)
[08:27:52.165]         ...future.stdout <- NULL
[08:27:52.165]     }
[08:27:52.165]     ...future.result$conditions <- ...future.conditions
[08:27:52.165]     ...future.result$finished <- base::Sys.time()
[08:27:52.165]     ...future.result
[08:27:52.165] }
[08:27:52.168] MultisessionFuture started
[08:27:52.168] - Launch lazy future ... done
[08:27:52.168] run() for ‘MultisessionFuture’ ... done
[08:27:52.168] getGlobalsAndPackages() ...
[08:27:52.169] Searching for globals...
[08:27:52.169] 
[08:27:52.169] Searching for globals ... DONE
[08:27:52.169] - globals: [0] <none>
[08:27:52.169] getGlobalsAndPackages() ... DONE
[08:27:52.169] run() for ‘Future’ ...
[08:27:52.169] - state: ‘created’
[08:27:52.170] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.184] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.184] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:52.184]   - Field: ‘node’
[08:27:52.184]   - Field: ‘label’
[08:27:52.185]   - Field: ‘local’
[08:27:52.185]   - Field: ‘owner’
[08:27:52.185]   - Field: ‘envir’
[08:27:52.185]   - Field: ‘workers’
[08:27:52.185]   - Field: ‘packages’
[08:27:52.185]   - Field: ‘gc’
[08:27:52.185]   - Field: ‘conditions’
[08:27:52.185]   - Field: ‘persistent’
[08:27:52.185]   - Field: ‘expr’
[08:27:52.185]   - Field: ‘uuid’
[08:27:52.185]   - Field: ‘seed’
[08:27:52.185]   - Field: ‘version’
[08:27:52.186]   - Field: ‘result’
[08:27:52.186]   - Field: ‘asynchronous’
[08:27:52.186]   - Field: ‘calls’
[08:27:52.186]   - Field: ‘globals’
[08:27:52.186]   - Field: ‘stdout’
[08:27:52.186]   - Field: ‘earlySignal’
[08:27:52.186]   - Field: ‘lazy’
[08:27:52.186]   - Field: ‘state’
[08:27:52.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:52.186] - Launch lazy future ...
[08:27:52.187] Packages needed by the future expression (n = 0): <none>
[08:27:52.187] Packages needed by future strategies (n = 0): <none>
[08:27:52.187] {
[08:27:52.187]     {
[08:27:52.187]         {
[08:27:52.187]             ...future.startTime <- base::Sys.time()
[08:27:52.187]             {
[08:27:52.187]                 {
[08:27:52.187]                   {
[08:27:52.187]                     {
[08:27:52.187]                       base::local({
[08:27:52.187]                         has_future <- base::requireNamespace("future", 
[08:27:52.187]                           quietly = TRUE)
[08:27:52.187]                         if (has_future) {
[08:27:52.187]                           ns <- base::getNamespace("future")
[08:27:52.187]                           version <- ns[[".package"]][["version"]]
[08:27:52.187]                           if (is.null(version)) 
[08:27:52.187]                             version <- utils::packageVersion("future")
[08:27:52.187]                         }
[08:27:52.187]                         else {
[08:27:52.187]                           version <- NULL
[08:27:52.187]                         }
[08:27:52.187]                         if (!has_future || version < "1.8.0") {
[08:27:52.187]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.187]                             "", base::R.version$version.string), 
[08:27:52.187]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.187]                               "release", "version")], collapse = " "), 
[08:27:52.187]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.187]                             info)
[08:27:52.187]                           info <- base::paste(info, collapse = "; ")
[08:27:52.187]                           if (!has_future) {
[08:27:52.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.187]                               info)
[08:27:52.187]                           }
[08:27:52.187]                           else {
[08:27:52.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.187]                               info, version)
[08:27:52.187]                           }
[08:27:52.187]                           base::stop(msg)
[08:27:52.187]                         }
[08:27:52.187]                       })
[08:27:52.187]                     }
[08:27:52.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.187]                     base::options(mc.cores = 1L)
[08:27:52.187]                   }
[08:27:52.187]                   ...future.strategy.old <- future::plan("list")
[08:27:52.187]                   options(future.plan = NULL)
[08:27:52.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.187]                 }
[08:27:52.187]                 ...future.workdir <- getwd()
[08:27:52.187]             }
[08:27:52.187]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.187]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.187]         }
[08:27:52.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.187]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.187]             base::names(...future.oldOptions))
[08:27:52.187]     }
[08:27:52.187]     if (FALSE) {
[08:27:52.187]     }
[08:27:52.187]     else {
[08:27:52.187]         if (TRUE) {
[08:27:52.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.187]                 open = "w")
[08:27:52.187]         }
[08:27:52.187]         else {
[08:27:52.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.187]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.187]         }
[08:27:52.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.187]             base::sink(type = "output", split = FALSE)
[08:27:52.187]             base::close(...future.stdout)
[08:27:52.187]         }, add = TRUE)
[08:27:52.187]     }
[08:27:52.187]     ...future.frame <- base::sys.nframe()
[08:27:52.187]     ...future.conditions <- base::list()
[08:27:52.187]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.187]     if (FALSE) {
[08:27:52.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.187]     }
[08:27:52.187]     ...future.result <- base::tryCatch({
[08:27:52.187]         base::withCallingHandlers({
[08:27:52.187]             ...future.value <- base::withVisible(base::local({
[08:27:52.187]                 ...future.makeSendCondition <- base::local({
[08:27:52.187]                   sendCondition <- NULL
[08:27:52.187]                   function(frame = 1L) {
[08:27:52.187]                     if (is.function(sendCondition)) 
[08:27:52.187]                       return(sendCondition)
[08:27:52.187]                     ns <- getNamespace("parallel")
[08:27:52.187]                     if (exists("sendData", mode = "function", 
[08:27:52.187]                       envir = ns)) {
[08:27:52.187]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:52.187]                         envir = ns)
[08:27:52.187]                       envir <- sys.frame(frame)
[08:27:52.187]                       master <- NULL
[08:27:52.187]                       while (!identical(envir, .GlobalEnv) && 
[08:27:52.187]                         !identical(envir, emptyenv())) {
[08:27:52.187]                         if (exists("master", mode = "list", envir = envir, 
[08:27:52.187]                           inherits = FALSE)) {
[08:27:52.187]                           master <- get("master", mode = "list", 
[08:27:52.187]                             envir = envir, inherits = FALSE)
[08:27:52.187]                           if (inherits(master, c("SOCKnode", 
[08:27:52.187]                             "SOCK0node"))) {
[08:27:52.187]                             sendCondition <<- function(cond) {
[08:27:52.187]                               data <- list(type = "VALUE", value = cond, 
[08:27:52.187]                                 success = TRUE)
[08:27:52.187]                               parallel_sendData(master, data)
[08:27:52.187]                             }
[08:27:52.187]                             return(sendCondition)
[08:27:52.187]                           }
[08:27:52.187]                         }
[08:27:52.187]                         frame <- frame + 1L
[08:27:52.187]                         envir <- sys.frame(frame)
[08:27:52.187]                       }
[08:27:52.187]                     }
[08:27:52.187]                     sendCondition <<- function(cond) NULL
[08:27:52.187]                   }
[08:27:52.187]                 })
[08:27:52.187]                 withCallingHandlers({
[08:27:52.187]                   NULL
[08:27:52.187]                 }, immediateCondition = function(cond) {
[08:27:52.187]                   sendCondition <- ...future.makeSendCondition()
[08:27:52.187]                   sendCondition(cond)
[08:27:52.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.187]                   {
[08:27:52.187]                     inherits <- base::inherits
[08:27:52.187]                     invokeRestart <- base::invokeRestart
[08:27:52.187]                     is.null <- base::is.null
[08:27:52.187]                     muffled <- FALSE
[08:27:52.187]                     if (inherits(cond, "message")) {
[08:27:52.187]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.187]                       if (muffled) 
[08:27:52.187]                         invokeRestart("muffleMessage")
[08:27:52.187]                     }
[08:27:52.187]                     else if (inherits(cond, "warning")) {
[08:27:52.187]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.187]                       if (muffled) 
[08:27:52.187]                         invokeRestart("muffleWarning")
[08:27:52.187]                     }
[08:27:52.187]                     else if (inherits(cond, "condition")) {
[08:27:52.187]                       if (!is.null(pattern)) {
[08:27:52.187]                         computeRestarts <- base::computeRestarts
[08:27:52.187]                         grepl <- base::grepl
[08:27:52.187]                         restarts <- computeRestarts(cond)
[08:27:52.187]                         for (restart in restarts) {
[08:27:52.187]                           name <- restart$name
[08:27:52.187]                           if (is.null(name)) 
[08:27:52.187]                             next
[08:27:52.187]                           if (!grepl(pattern, name)) 
[08:27:52.187]                             next
[08:27:52.187]                           invokeRestart(restart)
[08:27:52.187]                           muffled <- TRUE
[08:27:52.187]                           break
[08:27:52.187]                         }
[08:27:52.187]                       }
[08:27:52.187]                     }
[08:27:52.187]                     invisible(muffled)
[08:27:52.187]                   }
[08:27:52.187]                   muffleCondition(cond)
[08:27:52.187]                 })
[08:27:52.187]             }))
[08:27:52.187]             future::FutureResult(value = ...future.value$value, 
[08:27:52.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.187]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.187]                     ...future.globalenv.names))
[08:27:52.187]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.187]         }, condition = base::local({
[08:27:52.187]             c <- base::c
[08:27:52.187]             inherits <- base::inherits
[08:27:52.187]             invokeRestart <- base::invokeRestart
[08:27:52.187]             length <- base::length
[08:27:52.187]             list <- base::list
[08:27:52.187]             seq.int <- base::seq.int
[08:27:52.187]             signalCondition <- base::signalCondition
[08:27:52.187]             sys.calls <- base::sys.calls
[08:27:52.187]             `[[` <- base::`[[`
[08:27:52.187]             `+` <- base::`+`
[08:27:52.187]             `<<-` <- base::`<<-`
[08:27:52.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.187]                   3L)]
[08:27:52.187]             }
[08:27:52.187]             function(cond) {
[08:27:52.187]                 is_error <- inherits(cond, "error")
[08:27:52.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.187]                   NULL)
[08:27:52.187]                 if (is_error) {
[08:27:52.187]                   sessionInformation <- function() {
[08:27:52.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.187]                       search = base::search(), system = base::Sys.info())
[08:27:52.187]                   }
[08:27:52.187]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.187]                     cond$call), session = sessionInformation(), 
[08:27:52.187]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.187]                   signalCondition(cond)
[08:27:52.187]                 }
[08:27:52.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.187]                 "immediateCondition"))) {
[08:27:52.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.187]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.187]                   if (TRUE && !signal) {
[08:27:52.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.187]                     {
[08:27:52.187]                       inherits <- base::inherits
[08:27:52.187]                       invokeRestart <- base::invokeRestart
[08:27:52.187]                       is.null <- base::is.null
[08:27:52.187]                       muffled <- FALSE
[08:27:52.187]                       if (inherits(cond, "message")) {
[08:27:52.187]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.187]                         if (muffled) 
[08:27:52.187]                           invokeRestart("muffleMessage")
[08:27:52.187]                       }
[08:27:52.187]                       else if (inherits(cond, "warning")) {
[08:27:52.187]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.187]                         if (muffled) 
[08:27:52.187]                           invokeRestart("muffleWarning")
[08:27:52.187]                       }
[08:27:52.187]                       else if (inherits(cond, "condition")) {
[08:27:52.187]                         if (!is.null(pattern)) {
[08:27:52.187]                           computeRestarts <- base::computeRestarts
[08:27:52.187]                           grepl <- base::grepl
[08:27:52.187]                           restarts <- computeRestarts(cond)
[08:27:52.187]                           for (restart in restarts) {
[08:27:52.187]                             name <- restart$name
[08:27:52.187]                             if (is.null(name)) 
[08:27:52.187]                               next
[08:27:52.187]                             if (!grepl(pattern, name)) 
[08:27:52.187]                               next
[08:27:52.187]                             invokeRestart(restart)
[08:27:52.187]                             muffled <- TRUE
[08:27:52.187]                             break
[08:27:52.187]                           }
[08:27:52.187]                         }
[08:27:52.187]                       }
[08:27:52.187]                       invisible(muffled)
[08:27:52.187]                     }
[08:27:52.187]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.187]                   }
[08:27:52.187]                 }
[08:27:52.187]                 else {
[08:27:52.187]                   if (TRUE) {
[08:27:52.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.187]                     {
[08:27:52.187]                       inherits <- base::inherits
[08:27:52.187]                       invokeRestart <- base::invokeRestart
[08:27:52.187]                       is.null <- base::is.null
[08:27:52.187]                       muffled <- FALSE
[08:27:52.187]                       if (inherits(cond, "message")) {
[08:27:52.187]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.187]                         if (muffled) 
[08:27:52.187]                           invokeRestart("muffleMessage")
[08:27:52.187]                       }
[08:27:52.187]                       else if (inherits(cond, "warning")) {
[08:27:52.187]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.187]                         if (muffled) 
[08:27:52.187]                           invokeRestart("muffleWarning")
[08:27:52.187]                       }
[08:27:52.187]                       else if (inherits(cond, "condition")) {
[08:27:52.187]                         if (!is.null(pattern)) {
[08:27:52.187]                           computeRestarts <- base::computeRestarts
[08:27:52.187]                           grepl <- base::grepl
[08:27:52.187]                           restarts <- computeRestarts(cond)
[08:27:52.187]                           for (restart in restarts) {
[08:27:52.187]                             name <- restart$name
[08:27:52.187]                             if (is.null(name)) 
[08:27:52.187]                               next
[08:27:52.187]                             if (!grepl(pattern, name)) 
[08:27:52.187]                               next
[08:27:52.187]                             invokeRestart(restart)
[08:27:52.187]                             muffled <- TRUE
[08:27:52.187]                             break
[08:27:52.187]                           }
[08:27:52.187]                         }
[08:27:52.187]                       }
[08:27:52.187]                       invisible(muffled)
[08:27:52.187]                     }
[08:27:52.187]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.187]                   }
[08:27:52.187]                 }
[08:27:52.187]             }
[08:27:52.187]         }))
[08:27:52.187]     }, error = function(ex) {
[08:27:52.187]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.187]                 ...future.rng), started = ...future.startTime, 
[08:27:52.187]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.187]             version = "1.8"), class = "FutureResult")
[08:27:52.187]     }, finally = {
[08:27:52.187]         if (!identical(...future.workdir, getwd())) 
[08:27:52.187]             setwd(...future.workdir)
[08:27:52.187]         {
[08:27:52.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.187]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.187]             }
[08:27:52.187]             base::options(...future.oldOptions)
[08:27:52.187]             if (.Platform$OS.type == "windows") {
[08:27:52.187]                 old_names <- names(...future.oldEnvVars)
[08:27:52.187]                 envs <- base::Sys.getenv()
[08:27:52.187]                 names <- names(envs)
[08:27:52.187]                 common <- intersect(names, old_names)
[08:27:52.187]                 added <- setdiff(names, old_names)
[08:27:52.187]                 removed <- setdiff(old_names, names)
[08:27:52.187]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.187]                   envs[common]]
[08:27:52.187]                 NAMES <- toupper(changed)
[08:27:52.187]                 args <- list()
[08:27:52.187]                 for (kk in seq_along(NAMES)) {
[08:27:52.187]                   name <- changed[[kk]]
[08:27:52.187]                   NAME <- NAMES[[kk]]
[08:27:52.187]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.187]                     next
[08:27:52.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.187]                 }
[08:27:52.187]                 NAMES <- toupper(added)
[08:27:52.187]                 for (kk in seq_along(NAMES)) {
[08:27:52.187]                   name <- added[[kk]]
[08:27:52.187]                   NAME <- NAMES[[kk]]
[08:27:52.187]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.187]                     next
[08:27:52.187]                   args[[name]] <- ""
[08:27:52.187]                 }
[08:27:52.187]                 NAMES <- toupper(removed)
[08:27:52.187]                 for (kk in seq_along(NAMES)) {
[08:27:52.187]                   name <- removed[[kk]]
[08:27:52.187]                   NAME <- NAMES[[kk]]
[08:27:52.187]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.187]                     next
[08:27:52.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.187]                 }
[08:27:52.187]                 if (length(args) > 0) 
[08:27:52.187]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.187]             }
[08:27:52.187]             else {
[08:27:52.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.187]             }
[08:27:52.187]             {
[08:27:52.187]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.187]                   0L) {
[08:27:52.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.187]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.187]                   base::options(opts)
[08:27:52.187]                 }
[08:27:52.187]                 {
[08:27:52.187]                   {
[08:27:52.187]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.187]                     NULL
[08:27:52.187]                   }
[08:27:52.187]                   options(future.plan = NULL)
[08:27:52.187]                   if (is.na(NA_character_)) 
[08:27:52.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.187]                     .init = FALSE)
[08:27:52.187]                 }
[08:27:52.187]             }
[08:27:52.187]         }
[08:27:52.187]     })
[08:27:52.187]     if (TRUE) {
[08:27:52.187]         base::sink(type = "output", split = FALSE)
[08:27:52.187]         if (TRUE) {
[08:27:52.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.187]         }
[08:27:52.187]         else {
[08:27:52.187]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.187]         }
[08:27:52.187]         base::close(...future.stdout)
[08:27:52.187]         ...future.stdout <- NULL
[08:27:52.187]     }
[08:27:52.187]     ...future.result$conditions <- ...future.conditions
[08:27:52.187]     ...future.result$finished <- base::Sys.time()
[08:27:52.187]     ...future.result
[08:27:52.187] }
[08:27:52.190] MultisessionFuture started
[08:27:52.190] - Launch lazy future ... done
[08:27:52.190] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d86322d0b0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d86151d5e0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d86322d0b0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d86151d5e0> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:52.218] resolve() on list ...
[08:27:52.218]  recursive: 0
[08:27:52.218]  length: 6
[08:27:52.218]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:52.219] signalConditionsASAP(numeric, pos=1) ...
[08:27:52.219] - nx: 6
[08:27:52.219] - relay: TRUE
[08:27:52.219] - stdout: TRUE
[08:27:52.219] - signal: TRUE
[08:27:52.219] - resignal: FALSE
[08:27:52.219] - force: TRUE
[08:27:52.219] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.219] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.219]  - until=2
[08:27:52.219]  - relaying element #2
[08:27:52.219] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.220] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.220] signalConditionsASAP(NULL, pos=1) ... done
[08:27:52.220]  length: 5 (resolved future 1)
[08:27:52.220] receiveMessageFromWorker() for ClusterFuture ...
[08:27:52.220] - Validating connection of MultisessionFuture
[08:27:52.221] - received message: FutureResult
[08:27:52.221] - Received FutureResult
[08:27:52.221] - Erased future from FutureRegistry
[08:27:52.221] result() for ClusterFuture ...
[08:27:52.221] - result already collected: FutureResult
[08:27:52.221] result() for ClusterFuture ... done
[08:27:52.221] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:52.221] Future #2
[08:27:52.221] result() for ClusterFuture ...
[08:27:52.221] - result already collected: FutureResult
[08:27:52.221] result() for ClusterFuture ... done
[08:27:52.222] result() for ClusterFuture ...
[08:27:52.222] - result already collected: FutureResult
[08:27:52.222] result() for ClusterFuture ... done
[08:27:52.222] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:52.222] - nx: 6
[08:27:52.222] - relay: TRUE
[08:27:52.222] - stdout: TRUE
[08:27:52.222] - signal: TRUE
[08:27:52.222] - resignal: FALSE
[08:27:52.222] - force: TRUE
[08:27:52.222] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.223] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.223]  - until=2
[08:27:52.223]  - relaying element #2
[08:27:52.223] result() for ClusterFuture ...
[08:27:52.223] - result already collected: FutureResult
[08:27:52.223] result() for ClusterFuture ... done
[08:27:52.223] result() for ClusterFuture ...
[08:27:52.223] - result already collected: FutureResult
[08:27:52.223] result() for ClusterFuture ... done
[08:27:52.223] result() for ClusterFuture ...
[08:27:52.223] - result already collected: FutureResult
[08:27:52.224] result() for ClusterFuture ... done
[08:27:52.224] result() for ClusterFuture ...
[08:27:52.224] - result already collected: FutureResult
[08:27:52.224] result() for ClusterFuture ... done
[08:27:52.224] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.224] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.224] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:52.224]  length: 4 (resolved future 2)
[08:27:52.232] receiveMessageFromWorker() for ClusterFuture ...
[08:27:52.232] - Validating connection of MultisessionFuture
[08:27:52.233] - received message: FutureResult
[08:27:52.233] - Received FutureResult
[08:27:52.233] - Erased future from FutureRegistry
[08:27:52.233] result() for ClusterFuture ...
[08:27:52.233] - result already collected: FutureResult
[08:27:52.233] result() for ClusterFuture ... done
[08:27:52.233] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:52.233] Future #3
[08:27:52.233] result() for ClusterFuture ...
[08:27:52.233] - result already collected: FutureResult
[08:27:52.234] result() for ClusterFuture ... done
[08:27:52.234] result() for ClusterFuture ...
[08:27:52.234] - result already collected: FutureResult
[08:27:52.234] result() for ClusterFuture ... done
[08:27:52.234] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:52.234] - nx: 6
[08:27:52.234] - relay: TRUE
[08:27:52.234] - stdout: TRUE
[08:27:52.234] - signal: TRUE
[08:27:52.234] - resignal: FALSE
[08:27:52.234] - force: TRUE
[08:27:52.234] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.235] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.235]  - until=3
[08:27:52.235]  - relaying element #3
[08:27:52.235] result() for ClusterFuture ...
[08:27:52.235] - result already collected: FutureResult
[08:27:52.235] result() for ClusterFuture ... done
[08:27:52.235] result() for ClusterFuture ...
[08:27:52.235] - result already collected: FutureResult
[08:27:52.235] result() for ClusterFuture ... done
[08:27:52.235] result() for ClusterFuture ...
[08:27:52.235] - result already collected: FutureResult
[08:27:52.236] result() for ClusterFuture ... done
[08:27:52.236] result() for ClusterFuture ...
[08:27:52.236] - result already collected: FutureResult
[08:27:52.236] result() for ClusterFuture ... done
[08:27:52.236] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.236] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.236] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:52.236]  length: 3 (resolved future 3)
[08:27:52.236] signalConditionsASAP(NULL, pos=4) ...
[08:27:52.236] - nx: 6
[08:27:52.236] - relay: TRUE
[08:27:52.236] - stdout: TRUE
[08:27:52.236] - signal: TRUE
[08:27:52.237] - resignal: FALSE
[08:27:52.237] - force: TRUE
[08:27:52.237] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.237] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.237]  - until=5
[08:27:52.237]  - relaying element #5
[08:27:52.237] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:52.237] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.237] signalConditionsASAP(NULL, pos=4) ... done
[08:27:52.237]  length: 2 (resolved future 4)
[08:27:52.237] signalConditionsASAP(NULL, pos=5) ...
[08:27:52.237] - nx: 6
[08:27:52.238] - relay: TRUE
[08:27:52.238] - stdout: TRUE
[08:27:52.238] - signal: TRUE
[08:27:52.238] - resignal: FALSE
[08:27:52.238] - force: TRUE
[08:27:52.238] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:52.238] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.238]  - until=6
[08:27:52.238]  - relaying element #6
[08:27:52.238] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:52.238] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.238] signalConditionsASAP(NULL, pos=5) ... done
[08:27:52.238]  length: 1 (resolved future 5)
[08:27:52.239] signalConditionsASAP(numeric, pos=6) ...
[08:27:52.239] - nx: 6
[08:27:52.239] - relay: TRUE
[08:27:52.239] - stdout: TRUE
[08:27:52.239] - signal: TRUE
[08:27:52.239] - resignal: FALSE
[08:27:52.239] - force: TRUE
[08:27:52.239] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:52.239] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.239]  - until=6
[08:27:52.239] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.239] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.240] signalConditionsASAP(numeric, pos=6) ... done
[08:27:52.240]  length: 0 (resolved future 6)
[08:27:52.240] Relaying remaining futures
[08:27:52.240] signalConditionsASAP(NULL, pos=0) ...
[08:27:52.240] - nx: 6
[08:27:52.240] - relay: TRUE
[08:27:52.240] - stdout: TRUE
[08:27:52.240] - signal: TRUE
[08:27:52.240] - resignal: FALSE
[08:27:52.240] - force: TRUE
[08:27:52.240] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.240] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:52.240] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.241] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.241] signalConditionsASAP(NULL, pos=0) ... done
[08:27:52.241] resolve() on list ... DONE
[08:27:52.241] result() for ClusterFuture ...
[08:27:52.241] - result already collected: FutureResult
[08:27:52.241] result() for ClusterFuture ... done
[08:27:52.241] result() for ClusterFuture ...
[08:27:52.241] - result already collected: FutureResult
[08:27:52.241] result() for ClusterFuture ... done
[08:27:52.241] result() for ClusterFuture ...
[08:27:52.241] - result already collected: FutureResult
[08:27:52.241] result() for ClusterFuture ... done
[08:27:52.242] result() for ClusterFuture ...
[08:27:52.242] - result already collected: FutureResult
[08:27:52.242] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[08:27:52.245] getGlobalsAndPackages() ...
[08:27:52.245] Searching for globals...
[08:27:52.245] 
[08:27:52.246] Searching for globals ... DONE
[08:27:52.246] - globals: [0] <none>
[08:27:52.246] getGlobalsAndPackages() ... DONE
[08:27:52.246] run() for ‘Future’ ...
[08:27:52.246] - state: ‘created’
[08:27:52.246] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.260] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.261] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:52.261]   - Field: ‘node’
[08:27:52.261]   - Field: ‘label’
[08:27:52.261]   - Field: ‘local’
[08:27:52.261]   - Field: ‘owner’
[08:27:52.261]   - Field: ‘envir’
[08:27:52.261]   - Field: ‘workers’
[08:27:52.261]   - Field: ‘packages’
[08:27:52.261]   - Field: ‘gc’
[08:27:52.261]   - Field: ‘conditions’
[08:27:52.261]   - Field: ‘persistent’
[08:27:52.262]   - Field: ‘expr’
[08:27:52.262]   - Field: ‘uuid’
[08:27:52.262]   - Field: ‘seed’
[08:27:52.262]   - Field: ‘version’
[08:27:52.262]   - Field: ‘result’
[08:27:52.262]   - Field: ‘asynchronous’
[08:27:52.262]   - Field: ‘calls’
[08:27:52.262]   - Field: ‘globals’
[08:27:52.262]   - Field: ‘stdout’
[08:27:52.262]   - Field: ‘earlySignal’
[08:27:52.262]   - Field: ‘lazy’
[08:27:52.262]   - Field: ‘state’
[08:27:52.263] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:52.263] - Launch lazy future ...
[08:27:52.263] Packages needed by the future expression (n = 0): <none>
[08:27:52.263] Packages needed by future strategies (n = 0): <none>
[08:27:52.263] {
[08:27:52.263]     {
[08:27:52.263]         {
[08:27:52.263]             ...future.startTime <- base::Sys.time()
[08:27:52.263]             {
[08:27:52.263]                 {
[08:27:52.263]                   {
[08:27:52.263]                     {
[08:27:52.263]                       base::local({
[08:27:52.263]                         has_future <- base::requireNamespace("future", 
[08:27:52.263]                           quietly = TRUE)
[08:27:52.263]                         if (has_future) {
[08:27:52.263]                           ns <- base::getNamespace("future")
[08:27:52.263]                           version <- ns[[".package"]][["version"]]
[08:27:52.263]                           if (is.null(version)) 
[08:27:52.263]                             version <- utils::packageVersion("future")
[08:27:52.263]                         }
[08:27:52.263]                         else {
[08:27:52.263]                           version <- NULL
[08:27:52.263]                         }
[08:27:52.263]                         if (!has_future || version < "1.8.0") {
[08:27:52.263]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.263]                             "", base::R.version$version.string), 
[08:27:52.263]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.263]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.263]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.263]                               "release", "version")], collapse = " "), 
[08:27:52.263]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.263]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.263]                             info)
[08:27:52.263]                           info <- base::paste(info, collapse = "; ")
[08:27:52.263]                           if (!has_future) {
[08:27:52.263]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.263]                               info)
[08:27:52.263]                           }
[08:27:52.263]                           else {
[08:27:52.263]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.263]                               info, version)
[08:27:52.263]                           }
[08:27:52.263]                           base::stop(msg)
[08:27:52.263]                         }
[08:27:52.263]                       })
[08:27:52.263]                     }
[08:27:52.263]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.263]                     base::options(mc.cores = 1L)
[08:27:52.263]                   }
[08:27:52.263]                   ...future.strategy.old <- future::plan("list")
[08:27:52.263]                   options(future.plan = NULL)
[08:27:52.263]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.263]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.263]                 }
[08:27:52.263]                 ...future.workdir <- getwd()
[08:27:52.263]             }
[08:27:52.263]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.263]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.263]         }
[08:27:52.263]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.263]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.263]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.263]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.263]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.263]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.263]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.263]             base::names(...future.oldOptions))
[08:27:52.263]     }
[08:27:52.263]     if (FALSE) {
[08:27:52.263]     }
[08:27:52.263]     else {
[08:27:52.263]         if (TRUE) {
[08:27:52.263]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.263]                 open = "w")
[08:27:52.263]         }
[08:27:52.263]         else {
[08:27:52.263]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.263]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.263]         }
[08:27:52.263]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.263]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.263]             base::sink(type = "output", split = FALSE)
[08:27:52.263]             base::close(...future.stdout)
[08:27:52.263]         }, add = TRUE)
[08:27:52.263]     }
[08:27:52.263]     ...future.frame <- base::sys.nframe()
[08:27:52.263]     ...future.conditions <- base::list()
[08:27:52.263]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.263]     if (FALSE) {
[08:27:52.263]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.263]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.263]     }
[08:27:52.263]     ...future.result <- base::tryCatch({
[08:27:52.263]         base::withCallingHandlers({
[08:27:52.263]             ...future.value <- base::withVisible(base::local({
[08:27:52.263]                 ...future.makeSendCondition <- base::local({
[08:27:52.263]                   sendCondition <- NULL
[08:27:52.263]                   function(frame = 1L) {
[08:27:52.263]                     if (is.function(sendCondition)) 
[08:27:52.263]                       return(sendCondition)
[08:27:52.263]                     ns <- getNamespace("parallel")
[08:27:52.263]                     if (exists("sendData", mode = "function", 
[08:27:52.263]                       envir = ns)) {
[08:27:52.263]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:52.263]                         envir = ns)
[08:27:52.263]                       envir <- sys.frame(frame)
[08:27:52.263]                       master <- NULL
[08:27:52.263]                       while (!identical(envir, .GlobalEnv) && 
[08:27:52.263]                         !identical(envir, emptyenv())) {
[08:27:52.263]                         if (exists("master", mode = "list", envir = envir, 
[08:27:52.263]                           inherits = FALSE)) {
[08:27:52.263]                           master <- get("master", mode = "list", 
[08:27:52.263]                             envir = envir, inherits = FALSE)
[08:27:52.263]                           if (inherits(master, c("SOCKnode", 
[08:27:52.263]                             "SOCK0node"))) {
[08:27:52.263]                             sendCondition <<- function(cond) {
[08:27:52.263]                               data <- list(type = "VALUE", value = cond, 
[08:27:52.263]                                 success = TRUE)
[08:27:52.263]                               parallel_sendData(master, data)
[08:27:52.263]                             }
[08:27:52.263]                             return(sendCondition)
[08:27:52.263]                           }
[08:27:52.263]                         }
[08:27:52.263]                         frame <- frame + 1L
[08:27:52.263]                         envir <- sys.frame(frame)
[08:27:52.263]                       }
[08:27:52.263]                     }
[08:27:52.263]                     sendCondition <<- function(cond) NULL
[08:27:52.263]                   }
[08:27:52.263]                 })
[08:27:52.263]                 withCallingHandlers({
[08:27:52.263]                   2
[08:27:52.263]                 }, immediateCondition = function(cond) {
[08:27:52.263]                   sendCondition <- ...future.makeSendCondition()
[08:27:52.263]                   sendCondition(cond)
[08:27:52.263]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.263]                   {
[08:27:52.263]                     inherits <- base::inherits
[08:27:52.263]                     invokeRestart <- base::invokeRestart
[08:27:52.263]                     is.null <- base::is.null
[08:27:52.263]                     muffled <- FALSE
[08:27:52.263]                     if (inherits(cond, "message")) {
[08:27:52.263]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.263]                       if (muffled) 
[08:27:52.263]                         invokeRestart("muffleMessage")
[08:27:52.263]                     }
[08:27:52.263]                     else if (inherits(cond, "warning")) {
[08:27:52.263]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.263]                       if (muffled) 
[08:27:52.263]                         invokeRestart("muffleWarning")
[08:27:52.263]                     }
[08:27:52.263]                     else if (inherits(cond, "condition")) {
[08:27:52.263]                       if (!is.null(pattern)) {
[08:27:52.263]                         computeRestarts <- base::computeRestarts
[08:27:52.263]                         grepl <- base::grepl
[08:27:52.263]                         restarts <- computeRestarts(cond)
[08:27:52.263]                         for (restart in restarts) {
[08:27:52.263]                           name <- restart$name
[08:27:52.263]                           if (is.null(name)) 
[08:27:52.263]                             next
[08:27:52.263]                           if (!grepl(pattern, name)) 
[08:27:52.263]                             next
[08:27:52.263]                           invokeRestart(restart)
[08:27:52.263]                           muffled <- TRUE
[08:27:52.263]                           break
[08:27:52.263]                         }
[08:27:52.263]                       }
[08:27:52.263]                     }
[08:27:52.263]                     invisible(muffled)
[08:27:52.263]                   }
[08:27:52.263]                   muffleCondition(cond)
[08:27:52.263]                 })
[08:27:52.263]             }))
[08:27:52.263]             future::FutureResult(value = ...future.value$value, 
[08:27:52.263]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.263]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.263]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.263]                     ...future.globalenv.names))
[08:27:52.263]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.263]         }, condition = base::local({
[08:27:52.263]             c <- base::c
[08:27:52.263]             inherits <- base::inherits
[08:27:52.263]             invokeRestart <- base::invokeRestart
[08:27:52.263]             length <- base::length
[08:27:52.263]             list <- base::list
[08:27:52.263]             seq.int <- base::seq.int
[08:27:52.263]             signalCondition <- base::signalCondition
[08:27:52.263]             sys.calls <- base::sys.calls
[08:27:52.263]             `[[` <- base::`[[`
[08:27:52.263]             `+` <- base::`+`
[08:27:52.263]             `<<-` <- base::`<<-`
[08:27:52.263]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.263]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.263]                   3L)]
[08:27:52.263]             }
[08:27:52.263]             function(cond) {
[08:27:52.263]                 is_error <- inherits(cond, "error")
[08:27:52.263]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.263]                   NULL)
[08:27:52.263]                 if (is_error) {
[08:27:52.263]                   sessionInformation <- function() {
[08:27:52.263]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.263]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.263]                       search = base::search(), system = base::Sys.info())
[08:27:52.263]                   }
[08:27:52.263]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.263]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.263]                     cond$call), session = sessionInformation(), 
[08:27:52.263]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.263]                   signalCondition(cond)
[08:27:52.263]                 }
[08:27:52.263]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.263]                 "immediateCondition"))) {
[08:27:52.263]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.263]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.263]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.263]                   if (TRUE && !signal) {
[08:27:52.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.263]                     {
[08:27:52.263]                       inherits <- base::inherits
[08:27:52.263]                       invokeRestart <- base::invokeRestart
[08:27:52.263]                       is.null <- base::is.null
[08:27:52.263]                       muffled <- FALSE
[08:27:52.263]                       if (inherits(cond, "message")) {
[08:27:52.263]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.263]                         if (muffled) 
[08:27:52.263]                           invokeRestart("muffleMessage")
[08:27:52.263]                       }
[08:27:52.263]                       else if (inherits(cond, "warning")) {
[08:27:52.263]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.263]                         if (muffled) 
[08:27:52.263]                           invokeRestart("muffleWarning")
[08:27:52.263]                       }
[08:27:52.263]                       else if (inherits(cond, "condition")) {
[08:27:52.263]                         if (!is.null(pattern)) {
[08:27:52.263]                           computeRestarts <- base::computeRestarts
[08:27:52.263]                           grepl <- base::grepl
[08:27:52.263]                           restarts <- computeRestarts(cond)
[08:27:52.263]                           for (restart in restarts) {
[08:27:52.263]                             name <- restart$name
[08:27:52.263]                             if (is.null(name)) 
[08:27:52.263]                               next
[08:27:52.263]                             if (!grepl(pattern, name)) 
[08:27:52.263]                               next
[08:27:52.263]                             invokeRestart(restart)
[08:27:52.263]                             muffled <- TRUE
[08:27:52.263]                             break
[08:27:52.263]                           }
[08:27:52.263]                         }
[08:27:52.263]                       }
[08:27:52.263]                       invisible(muffled)
[08:27:52.263]                     }
[08:27:52.263]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.263]                   }
[08:27:52.263]                 }
[08:27:52.263]                 else {
[08:27:52.263]                   if (TRUE) {
[08:27:52.263]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.263]                     {
[08:27:52.263]                       inherits <- base::inherits
[08:27:52.263]                       invokeRestart <- base::invokeRestart
[08:27:52.263]                       is.null <- base::is.null
[08:27:52.263]                       muffled <- FALSE
[08:27:52.263]                       if (inherits(cond, "message")) {
[08:27:52.263]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.263]                         if (muffled) 
[08:27:52.263]                           invokeRestart("muffleMessage")
[08:27:52.263]                       }
[08:27:52.263]                       else if (inherits(cond, "warning")) {
[08:27:52.263]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.263]                         if (muffled) 
[08:27:52.263]                           invokeRestart("muffleWarning")
[08:27:52.263]                       }
[08:27:52.263]                       else if (inherits(cond, "condition")) {
[08:27:52.263]                         if (!is.null(pattern)) {
[08:27:52.263]                           computeRestarts <- base::computeRestarts
[08:27:52.263]                           grepl <- base::grepl
[08:27:52.263]                           restarts <- computeRestarts(cond)
[08:27:52.263]                           for (restart in restarts) {
[08:27:52.263]                             name <- restart$name
[08:27:52.263]                             if (is.null(name)) 
[08:27:52.263]                               next
[08:27:52.263]                             if (!grepl(pattern, name)) 
[08:27:52.263]                               next
[08:27:52.263]                             invokeRestart(restart)
[08:27:52.263]                             muffled <- TRUE
[08:27:52.263]                             break
[08:27:52.263]                           }
[08:27:52.263]                         }
[08:27:52.263]                       }
[08:27:52.263]                       invisible(muffled)
[08:27:52.263]                     }
[08:27:52.263]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.263]                   }
[08:27:52.263]                 }
[08:27:52.263]             }
[08:27:52.263]         }))
[08:27:52.263]     }, error = function(ex) {
[08:27:52.263]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.263]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.263]                 ...future.rng), started = ...future.startTime, 
[08:27:52.263]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.263]             version = "1.8"), class = "FutureResult")
[08:27:52.263]     }, finally = {
[08:27:52.263]         if (!identical(...future.workdir, getwd())) 
[08:27:52.263]             setwd(...future.workdir)
[08:27:52.263]         {
[08:27:52.263]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.263]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.263]             }
[08:27:52.263]             base::options(...future.oldOptions)
[08:27:52.263]             if (.Platform$OS.type == "windows") {
[08:27:52.263]                 old_names <- names(...future.oldEnvVars)
[08:27:52.263]                 envs <- base::Sys.getenv()
[08:27:52.263]                 names <- names(envs)
[08:27:52.263]                 common <- intersect(names, old_names)
[08:27:52.263]                 added <- setdiff(names, old_names)
[08:27:52.263]                 removed <- setdiff(old_names, names)
[08:27:52.263]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.263]                   envs[common]]
[08:27:52.263]                 NAMES <- toupper(changed)
[08:27:52.263]                 args <- list()
[08:27:52.263]                 for (kk in seq_along(NAMES)) {
[08:27:52.263]                   name <- changed[[kk]]
[08:27:52.263]                   NAME <- NAMES[[kk]]
[08:27:52.263]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.263]                     next
[08:27:52.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.263]                 }
[08:27:52.263]                 NAMES <- toupper(added)
[08:27:52.263]                 for (kk in seq_along(NAMES)) {
[08:27:52.263]                   name <- added[[kk]]
[08:27:52.263]                   NAME <- NAMES[[kk]]
[08:27:52.263]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.263]                     next
[08:27:52.263]                   args[[name]] <- ""
[08:27:52.263]                 }
[08:27:52.263]                 NAMES <- toupper(removed)
[08:27:52.263]                 for (kk in seq_along(NAMES)) {
[08:27:52.263]                   name <- removed[[kk]]
[08:27:52.263]                   NAME <- NAMES[[kk]]
[08:27:52.263]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.263]                     next
[08:27:52.263]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.263]                 }
[08:27:52.263]                 if (length(args) > 0) 
[08:27:52.263]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.263]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.263]             }
[08:27:52.263]             else {
[08:27:52.263]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.263]             }
[08:27:52.263]             {
[08:27:52.263]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.263]                   0L) {
[08:27:52.263]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.263]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.263]                   base::options(opts)
[08:27:52.263]                 }
[08:27:52.263]                 {
[08:27:52.263]                   {
[08:27:52.263]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.263]                     NULL
[08:27:52.263]                   }
[08:27:52.263]                   options(future.plan = NULL)
[08:27:52.263]                   if (is.na(NA_character_)) 
[08:27:52.263]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.263]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.263]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.263]                     .init = FALSE)
[08:27:52.263]                 }
[08:27:52.263]             }
[08:27:52.263]         }
[08:27:52.263]     })
[08:27:52.263]     if (TRUE) {
[08:27:52.263]         base::sink(type = "output", split = FALSE)
[08:27:52.263]         if (TRUE) {
[08:27:52.263]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.263]         }
[08:27:52.263]         else {
[08:27:52.263]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.263]         }
[08:27:52.263]         base::close(...future.stdout)
[08:27:52.263]         ...future.stdout <- NULL
[08:27:52.263]     }
[08:27:52.263]     ...future.result$conditions <- ...future.conditions
[08:27:52.263]     ...future.result$finished <- base::Sys.time()
[08:27:52.263]     ...future.result
[08:27:52.263] }
[08:27:52.267] MultisessionFuture started
[08:27:52.267] - Launch lazy future ... done
[08:27:52.267] run() for ‘MultisessionFuture’ ... done
[08:27:52.267] getGlobalsAndPackages() ...
[08:27:52.267] Searching for globals...
[08:27:52.268] 
[08:27:52.268] Searching for globals ... DONE
[08:27:52.268] - globals: [0] <none>
[08:27:52.268] getGlobalsAndPackages() ... DONE
[08:27:52.268] run() for ‘Future’ ...
[08:27:52.268] - state: ‘created’
[08:27:52.268] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.282] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:52.283]   - Field: ‘node’
[08:27:52.283]   - Field: ‘label’
[08:27:52.283]   - Field: ‘local’
[08:27:52.283]   - Field: ‘owner’
[08:27:52.283]   - Field: ‘envir’
[08:27:52.283]   - Field: ‘workers’
[08:27:52.283]   - Field: ‘packages’
[08:27:52.283]   - Field: ‘gc’
[08:27:52.283]   - Field: ‘conditions’
[08:27:52.283]   - Field: ‘persistent’
[08:27:52.284]   - Field: ‘expr’
[08:27:52.284]   - Field: ‘uuid’
[08:27:52.284]   - Field: ‘seed’
[08:27:52.284]   - Field: ‘version’
[08:27:52.284]   - Field: ‘result’
[08:27:52.284]   - Field: ‘asynchronous’
[08:27:52.284]   - Field: ‘calls’
[08:27:52.284]   - Field: ‘globals’
[08:27:52.284]   - Field: ‘stdout’
[08:27:52.284]   - Field: ‘earlySignal’
[08:27:52.284]   - Field: ‘lazy’
[08:27:52.284]   - Field: ‘state’
[08:27:52.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:52.285] - Launch lazy future ...
[08:27:52.285] Packages needed by the future expression (n = 0): <none>
[08:27:52.285] Packages needed by future strategies (n = 0): <none>
[08:27:52.286] {
[08:27:52.286]     {
[08:27:52.286]         {
[08:27:52.286]             ...future.startTime <- base::Sys.time()
[08:27:52.286]             {
[08:27:52.286]                 {
[08:27:52.286]                   {
[08:27:52.286]                     {
[08:27:52.286]                       base::local({
[08:27:52.286]                         has_future <- base::requireNamespace("future", 
[08:27:52.286]                           quietly = TRUE)
[08:27:52.286]                         if (has_future) {
[08:27:52.286]                           ns <- base::getNamespace("future")
[08:27:52.286]                           version <- ns[[".package"]][["version"]]
[08:27:52.286]                           if (is.null(version)) 
[08:27:52.286]                             version <- utils::packageVersion("future")
[08:27:52.286]                         }
[08:27:52.286]                         else {
[08:27:52.286]                           version <- NULL
[08:27:52.286]                         }
[08:27:52.286]                         if (!has_future || version < "1.8.0") {
[08:27:52.286]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.286]                             "", base::R.version$version.string), 
[08:27:52.286]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.286]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.286]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.286]                               "release", "version")], collapse = " "), 
[08:27:52.286]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.286]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.286]                             info)
[08:27:52.286]                           info <- base::paste(info, collapse = "; ")
[08:27:52.286]                           if (!has_future) {
[08:27:52.286]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.286]                               info)
[08:27:52.286]                           }
[08:27:52.286]                           else {
[08:27:52.286]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.286]                               info, version)
[08:27:52.286]                           }
[08:27:52.286]                           base::stop(msg)
[08:27:52.286]                         }
[08:27:52.286]                       })
[08:27:52.286]                     }
[08:27:52.286]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.286]                     base::options(mc.cores = 1L)
[08:27:52.286]                   }
[08:27:52.286]                   ...future.strategy.old <- future::plan("list")
[08:27:52.286]                   options(future.plan = NULL)
[08:27:52.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.286]                 }
[08:27:52.286]                 ...future.workdir <- getwd()
[08:27:52.286]             }
[08:27:52.286]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.286]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.286]         }
[08:27:52.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.286]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.286]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.286]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.286]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.286]             base::names(...future.oldOptions))
[08:27:52.286]     }
[08:27:52.286]     if (FALSE) {
[08:27:52.286]     }
[08:27:52.286]     else {
[08:27:52.286]         if (TRUE) {
[08:27:52.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.286]                 open = "w")
[08:27:52.286]         }
[08:27:52.286]         else {
[08:27:52.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.286]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.286]         }
[08:27:52.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.286]             base::sink(type = "output", split = FALSE)
[08:27:52.286]             base::close(...future.stdout)
[08:27:52.286]         }, add = TRUE)
[08:27:52.286]     }
[08:27:52.286]     ...future.frame <- base::sys.nframe()
[08:27:52.286]     ...future.conditions <- base::list()
[08:27:52.286]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.286]     if (FALSE) {
[08:27:52.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.286]     }
[08:27:52.286]     ...future.result <- base::tryCatch({
[08:27:52.286]         base::withCallingHandlers({
[08:27:52.286]             ...future.value <- base::withVisible(base::local({
[08:27:52.286]                 ...future.makeSendCondition <- base::local({
[08:27:52.286]                   sendCondition <- NULL
[08:27:52.286]                   function(frame = 1L) {
[08:27:52.286]                     if (is.function(sendCondition)) 
[08:27:52.286]                       return(sendCondition)
[08:27:52.286]                     ns <- getNamespace("parallel")
[08:27:52.286]                     if (exists("sendData", mode = "function", 
[08:27:52.286]                       envir = ns)) {
[08:27:52.286]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:52.286]                         envir = ns)
[08:27:52.286]                       envir <- sys.frame(frame)
[08:27:52.286]                       master <- NULL
[08:27:52.286]                       while (!identical(envir, .GlobalEnv) && 
[08:27:52.286]                         !identical(envir, emptyenv())) {
[08:27:52.286]                         if (exists("master", mode = "list", envir = envir, 
[08:27:52.286]                           inherits = FALSE)) {
[08:27:52.286]                           master <- get("master", mode = "list", 
[08:27:52.286]                             envir = envir, inherits = FALSE)
[08:27:52.286]                           if (inherits(master, c("SOCKnode", 
[08:27:52.286]                             "SOCK0node"))) {
[08:27:52.286]                             sendCondition <<- function(cond) {
[08:27:52.286]                               data <- list(type = "VALUE", value = cond, 
[08:27:52.286]                                 success = TRUE)
[08:27:52.286]                               parallel_sendData(master, data)
[08:27:52.286]                             }
[08:27:52.286]                             return(sendCondition)
[08:27:52.286]                           }
[08:27:52.286]                         }
[08:27:52.286]                         frame <- frame + 1L
[08:27:52.286]                         envir <- sys.frame(frame)
[08:27:52.286]                       }
[08:27:52.286]                     }
[08:27:52.286]                     sendCondition <<- function(cond) NULL
[08:27:52.286]                   }
[08:27:52.286]                 })
[08:27:52.286]                 withCallingHandlers({
[08:27:52.286]                   NULL
[08:27:52.286]                 }, immediateCondition = function(cond) {
[08:27:52.286]                   sendCondition <- ...future.makeSendCondition()
[08:27:52.286]                   sendCondition(cond)
[08:27:52.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.286]                   {
[08:27:52.286]                     inherits <- base::inherits
[08:27:52.286]                     invokeRestart <- base::invokeRestart
[08:27:52.286]                     is.null <- base::is.null
[08:27:52.286]                     muffled <- FALSE
[08:27:52.286]                     if (inherits(cond, "message")) {
[08:27:52.286]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.286]                       if (muffled) 
[08:27:52.286]                         invokeRestart("muffleMessage")
[08:27:52.286]                     }
[08:27:52.286]                     else if (inherits(cond, "warning")) {
[08:27:52.286]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.286]                       if (muffled) 
[08:27:52.286]                         invokeRestart("muffleWarning")
[08:27:52.286]                     }
[08:27:52.286]                     else if (inherits(cond, "condition")) {
[08:27:52.286]                       if (!is.null(pattern)) {
[08:27:52.286]                         computeRestarts <- base::computeRestarts
[08:27:52.286]                         grepl <- base::grepl
[08:27:52.286]                         restarts <- computeRestarts(cond)
[08:27:52.286]                         for (restart in restarts) {
[08:27:52.286]                           name <- restart$name
[08:27:52.286]                           if (is.null(name)) 
[08:27:52.286]                             next
[08:27:52.286]                           if (!grepl(pattern, name)) 
[08:27:52.286]                             next
[08:27:52.286]                           invokeRestart(restart)
[08:27:52.286]                           muffled <- TRUE
[08:27:52.286]                           break
[08:27:52.286]                         }
[08:27:52.286]                       }
[08:27:52.286]                     }
[08:27:52.286]                     invisible(muffled)
[08:27:52.286]                   }
[08:27:52.286]                   muffleCondition(cond)
[08:27:52.286]                 })
[08:27:52.286]             }))
[08:27:52.286]             future::FutureResult(value = ...future.value$value, 
[08:27:52.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.286]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.286]                     ...future.globalenv.names))
[08:27:52.286]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.286]         }, condition = base::local({
[08:27:52.286]             c <- base::c
[08:27:52.286]             inherits <- base::inherits
[08:27:52.286]             invokeRestart <- base::invokeRestart
[08:27:52.286]             length <- base::length
[08:27:52.286]             list <- base::list
[08:27:52.286]             seq.int <- base::seq.int
[08:27:52.286]             signalCondition <- base::signalCondition
[08:27:52.286]             sys.calls <- base::sys.calls
[08:27:52.286]             `[[` <- base::`[[`
[08:27:52.286]             `+` <- base::`+`
[08:27:52.286]             `<<-` <- base::`<<-`
[08:27:52.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.286]                   3L)]
[08:27:52.286]             }
[08:27:52.286]             function(cond) {
[08:27:52.286]                 is_error <- inherits(cond, "error")
[08:27:52.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.286]                   NULL)
[08:27:52.286]                 if (is_error) {
[08:27:52.286]                   sessionInformation <- function() {
[08:27:52.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.286]                       search = base::search(), system = base::Sys.info())
[08:27:52.286]                   }
[08:27:52.286]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.286]                     cond$call), session = sessionInformation(), 
[08:27:52.286]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.286]                   signalCondition(cond)
[08:27:52.286]                 }
[08:27:52.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.286]                 "immediateCondition"))) {
[08:27:52.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.286]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.286]                   if (TRUE && !signal) {
[08:27:52.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.286]                     {
[08:27:52.286]                       inherits <- base::inherits
[08:27:52.286]                       invokeRestart <- base::invokeRestart
[08:27:52.286]                       is.null <- base::is.null
[08:27:52.286]                       muffled <- FALSE
[08:27:52.286]                       if (inherits(cond, "message")) {
[08:27:52.286]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.286]                         if (muffled) 
[08:27:52.286]                           invokeRestart("muffleMessage")
[08:27:52.286]                       }
[08:27:52.286]                       else if (inherits(cond, "warning")) {
[08:27:52.286]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.286]                         if (muffled) 
[08:27:52.286]                           invokeRestart("muffleWarning")
[08:27:52.286]                       }
[08:27:52.286]                       else if (inherits(cond, "condition")) {
[08:27:52.286]                         if (!is.null(pattern)) {
[08:27:52.286]                           computeRestarts <- base::computeRestarts
[08:27:52.286]                           grepl <- base::grepl
[08:27:52.286]                           restarts <- computeRestarts(cond)
[08:27:52.286]                           for (restart in restarts) {
[08:27:52.286]                             name <- restart$name
[08:27:52.286]                             if (is.null(name)) 
[08:27:52.286]                               next
[08:27:52.286]                             if (!grepl(pattern, name)) 
[08:27:52.286]                               next
[08:27:52.286]                             invokeRestart(restart)
[08:27:52.286]                             muffled <- TRUE
[08:27:52.286]                             break
[08:27:52.286]                           }
[08:27:52.286]                         }
[08:27:52.286]                       }
[08:27:52.286]                       invisible(muffled)
[08:27:52.286]                     }
[08:27:52.286]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.286]                   }
[08:27:52.286]                 }
[08:27:52.286]                 else {
[08:27:52.286]                   if (TRUE) {
[08:27:52.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.286]                     {
[08:27:52.286]                       inherits <- base::inherits
[08:27:52.286]                       invokeRestart <- base::invokeRestart
[08:27:52.286]                       is.null <- base::is.null
[08:27:52.286]                       muffled <- FALSE
[08:27:52.286]                       if (inherits(cond, "message")) {
[08:27:52.286]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.286]                         if (muffled) 
[08:27:52.286]                           invokeRestart("muffleMessage")
[08:27:52.286]                       }
[08:27:52.286]                       else if (inherits(cond, "warning")) {
[08:27:52.286]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.286]                         if (muffled) 
[08:27:52.286]                           invokeRestart("muffleWarning")
[08:27:52.286]                       }
[08:27:52.286]                       else if (inherits(cond, "condition")) {
[08:27:52.286]                         if (!is.null(pattern)) {
[08:27:52.286]                           computeRestarts <- base::computeRestarts
[08:27:52.286]                           grepl <- base::grepl
[08:27:52.286]                           restarts <- computeRestarts(cond)
[08:27:52.286]                           for (restart in restarts) {
[08:27:52.286]                             name <- restart$name
[08:27:52.286]                             if (is.null(name)) 
[08:27:52.286]                               next
[08:27:52.286]                             if (!grepl(pattern, name)) 
[08:27:52.286]                               next
[08:27:52.286]                             invokeRestart(restart)
[08:27:52.286]                             muffled <- TRUE
[08:27:52.286]                             break
[08:27:52.286]                           }
[08:27:52.286]                         }
[08:27:52.286]                       }
[08:27:52.286]                       invisible(muffled)
[08:27:52.286]                     }
[08:27:52.286]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.286]                   }
[08:27:52.286]                 }
[08:27:52.286]             }
[08:27:52.286]         }))
[08:27:52.286]     }, error = function(ex) {
[08:27:52.286]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.286]                 ...future.rng), started = ...future.startTime, 
[08:27:52.286]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.286]             version = "1.8"), class = "FutureResult")
[08:27:52.286]     }, finally = {
[08:27:52.286]         if (!identical(...future.workdir, getwd())) 
[08:27:52.286]             setwd(...future.workdir)
[08:27:52.286]         {
[08:27:52.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.286]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.286]             }
[08:27:52.286]             base::options(...future.oldOptions)
[08:27:52.286]             if (.Platform$OS.type == "windows") {
[08:27:52.286]                 old_names <- names(...future.oldEnvVars)
[08:27:52.286]                 envs <- base::Sys.getenv()
[08:27:52.286]                 names <- names(envs)
[08:27:52.286]                 common <- intersect(names, old_names)
[08:27:52.286]                 added <- setdiff(names, old_names)
[08:27:52.286]                 removed <- setdiff(old_names, names)
[08:27:52.286]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.286]                   envs[common]]
[08:27:52.286]                 NAMES <- toupper(changed)
[08:27:52.286]                 args <- list()
[08:27:52.286]                 for (kk in seq_along(NAMES)) {
[08:27:52.286]                   name <- changed[[kk]]
[08:27:52.286]                   NAME <- NAMES[[kk]]
[08:27:52.286]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.286]                     next
[08:27:52.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.286]                 }
[08:27:52.286]                 NAMES <- toupper(added)
[08:27:52.286]                 for (kk in seq_along(NAMES)) {
[08:27:52.286]                   name <- added[[kk]]
[08:27:52.286]                   NAME <- NAMES[[kk]]
[08:27:52.286]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.286]                     next
[08:27:52.286]                   args[[name]] <- ""
[08:27:52.286]                 }
[08:27:52.286]                 NAMES <- toupper(removed)
[08:27:52.286]                 for (kk in seq_along(NAMES)) {
[08:27:52.286]                   name <- removed[[kk]]
[08:27:52.286]                   NAME <- NAMES[[kk]]
[08:27:52.286]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.286]                     next
[08:27:52.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.286]                 }
[08:27:52.286]                 if (length(args) > 0) 
[08:27:52.286]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.286]             }
[08:27:52.286]             else {
[08:27:52.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.286]             }
[08:27:52.286]             {
[08:27:52.286]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.286]                   0L) {
[08:27:52.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.286]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.286]                   base::options(opts)
[08:27:52.286]                 }
[08:27:52.286]                 {
[08:27:52.286]                   {
[08:27:52.286]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.286]                     NULL
[08:27:52.286]                   }
[08:27:52.286]                   options(future.plan = NULL)
[08:27:52.286]                   if (is.na(NA_character_)) 
[08:27:52.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.286]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.286]                     .init = FALSE)
[08:27:52.286]                 }
[08:27:52.286]             }
[08:27:52.286]         }
[08:27:52.286]     })
[08:27:52.286]     if (TRUE) {
[08:27:52.286]         base::sink(type = "output", split = FALSE)
[08:27:52.286]         if (TRUE) {
[08:27:52.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.286]         }
[08:27:52.286]         else {
[08:27:52.286]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.286]         }
[08:27:52.286]         base::close(...future.stdout)
[08:27:52.286]         ...future.stdout <- NULL
[08:27:52.286]     }
[08:27:52.286]     ...future.result$conditions <- ...future.conditions
[08:27:52.286]     ...future.result$finished <- base::Sys.time()
[08:27:52.286]     ...future.result
[08:27:52.286] }
[08:27:52.289] MultisessionFuture started
[08:27:52.289] - Launch lazy future ... done
[08:27:52.289] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d862411c60> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d86275cca8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d862411c60> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55d86275cca8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[08:27:52.317] resolve() on list ...
[08:27:52.318]  recursive: 0
[08:27:52.318]  length: 6
[08:27:52.318]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[08:27:52.318] signalConditionsASAP(numeric, pos=1) ...
[08:27:52.318] - nx: 6
[08:27:52.318] - relay: TRUE
[08:27:52.318] - stdout: TRUE
[08:27:52.318] - signal: TRUE
[08:27:52.318] - resignal: FALSE
[08:27:52.318] - force: TRUE
[08:27:52.318] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.318] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.319]  - until=2
[08:27:52.319]  - relaying element #2
[08:27:52.319] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.319] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.319] signalConditionsASAP(NULL, pos=1) ... done
[08:27:52.319]  length: 5 (resolved future 1)
[08:27:52.320] receiveMessageFromWorker() for ClusterFuture ...
[08:27:52.320] - Validating connection of MultisessionFuture
[08:27:52.320] - received message: FutureResult
[08:27:52.320] - Received FutureResult
[08:27:52.320] - Erased future from FutureRegistry
[08:27:52.320] result() for ClusterFuture ...
[08:27:52.320] - result already collected: FutureResult
[08:27:52.320] result() for ClusterFuture ... done
[08:27:52.320] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:52.320] Future #2
[08:27:52.321] result() for ClusterFuture ...
[08:27:52.321] - result already collected: FutureResult
[08:27:52.321] result() for ClusterFuture ... done
[08:27:52.321] result() for ClusterFuture ...
[08:27:52.321] - result already collected: FutureResult
[08:27:52.321] result() for ClusterFuture ... done
[08:27:52.321] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:52.321] - nx: 6
[08:27:52.321] - relay: TRUE
[08:27:52.321] - stdout: TRUE
[08:27:52.321] - signal: TRUE
[08:27:52.321] - resignal: FALSE
[08:27:52.322] - force: TRUE
[08:27:52.322] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.322] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:52.322]  - until=2
[08:27:52.322]  - relaying element #2
[08:27:52.322] result() for ClusterFuture ...
[08:27:52.322] - result already collected: FutureResult
[08:27:52.322] result() for ClusterFuture ... done
[08:27:52.322] result() for ClusterFuture ...
[08:27:52.322] - result already collected: FutureResult
[08:27:52.322] result() for ClusterFuture ... done
[08:27:52.322] result() for ClusterFuture ...
[08:27:52.323] - result already collected: FutureResult
[08:27:52.323] result() for ClusterFuture ... done
[08:27:52.323] result() for ClusterFuture ...
[08:27:52.323] - result already collected: FutureResult
[08:27:52.323] result() for ClusterFuture ... done
[08:27:52.323] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.323] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.323] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:52.323]  length: 4 (resolved future 2)
[08:27:52.331] receiveMessageFromWorker() for ClusterFuture ...
[08:27:52.331] - Validating connection of MultisessionFuture
[08:27:52.332] - received message: FutureResult
[08:27:52.332] - Received FutureResult
[08:27:52.332] - Erased future from FutureRegistry
[08:27:52.332] result() for ClusterFuture ...
[08:27:52.332] - result already collected: FutureResult
[08:27:52.332] result() for ClusterFuture ... done
[08:27:52.332] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:52.332] Future #3
[08:27:52.332] result() for ClusterFuture ...
[08:27:52.332] - result already collected: FutureResult
[08:27:52.333] result() for ClusterFuture ... done
[08:27:52.333] result() for ClusterFuture ...
[08:27:52.333] - result already collected: FutureResult
[08:27:52.333] result() for ClusterFuture ... done
[08:27:52.333] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:52.333] - nx: 6
[08:27:52.333] - relay: TRUE
[08:27:52.333] - stdout: TRUE
[08:27:52.333] - signal: TRUE
[08:27:52.333] - resignal: FALSE
[08:27:52.333] - force: TRUE
[08:27:52.333] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.334] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:52.334]  - until=3
[08:27:52.336]  - relaying element #3
[08:27:52.336] result() for ClusterFuture ...
[08:27:52.336] - result already collected: FutureResult
[08:27:52.336] result() for ClusterFuture ... done
[08:27:52.336] result() for ClusterFuture ...
[08:27:52.336] - result already collected: FutureResult
[08:27:52.336] result() for ClusterFuture ... done
[08:27:52.337] result() for ClusterFuture ...
[08:27:52.337] - result already collected: FutureResult
[08:27:52.337] result() for ClusterFuture ... done
[08:27:52.337] result() for ClusterFuture ...
[08:27:52.337] - result already collected: FutureResult
[08:27:52.337] result() for ClusterFuture ... done
[08:27:52.337] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.337] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.337] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:52.337]  length: 3 (resolved future 3)
[08:27:52.337] signalConditionsASAP(NULL, pos=4) ...
[08:27:52.337] - nx: 6
[08:27:52.338] - relay: TRUE
[08:27:52.338] - stdout: TRUE
[08:27:52.338] - signal: TRUE
[08:27:52.338] - resignal: FALSE
[08:27:52.338] - force: TRUE
[08:27:52.338] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.338] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.338]  - until=5
[08:27:52.338]  - relaying element #5
[08:27:52.338] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:52.338] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.338] signalConditionsASAP(NULL, pos=4) ... done
[08:27:52.338]  length: 2 (resolved future 4)
[08:27:52.339] signalConditionsASAP(NULL, pos=5) ...
[08:27:52.339] - nx: 6
[08:27:52.339] - relay: TRUE
[08:27:52.339] - stdout: TRUE
[08:27:52.339] - signal: TRUE
[08:27:52.339] - resignal: FALSE
[08:27:52.339] - force: TRUE
[08:27:52.339] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:52.339] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.339]  - until=6
[08:27:52.339]  - relaying element #6
[08:27:52.339] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:52.339] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.340] signalConditionsASAP(NULL, pos=5) ... done
[08:27:52.340]  length: 1 (resolved future 5)
[08:27:52.340] signalConditionsASAP(numeric, pos=6) ...
[08:27:52.340] - nx: 6
[08:27:52.340] - relay: TRUE
[08:27:52.340] - stdout: TRUE
[08:27:52.340] - signal: TRUE
[08:27:52.340] - resignal: FALSE
[08:27:52.340] - force: TRUE
[08:27:52.340] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:52.340] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.340]  - until=6
[08:27:52.340] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.341] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.341] signalConditionsASAP(numeric, pos=6) ... done
[08:27:52.341]  length: 0 (resolved future 6)
[08:27:52.341] Relaying remaining futures
[08:27:52.341] signalConditionsASAP(NULL, pos=0) ...
[08:27:52.341] - nx: 6
[08:27:52.341] - relay: TRUE
[08:27:52.341] - stdout: TRUE
[08:27:52.341] - signal: TRUE
[08:27:52.341] - resignal: FALSE
[08:27:52.341] - force: TRUE
[08:27:52.341] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.341] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[08:27:52.342] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:52.342] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:52.342] signalConditionsASAP(NULL, pos=0) ... done
[08:27:52.342] resolve() on list ... DONE
[08:27:52.342] result() for ClusterFuture ...
[08:27:52.342] - result already collected: FutureResult
[08:27:52.342] result() for ClusterFuture ... done
[08:27:52.342] result() for ClusterFuture ...
[08:27:52.342] - result already collected: FutureResult
[08:27:52.342] result() for ClusterFuture ... done
[08:27:52.342] result() for ClusterFuture ...
[08:27:52.342] - result already collected: FutureResult
[08:27:52.343] result() for ClusterFuture ... done
[08:27:52.343] result() for ClusterFuture ...
[08:27:52.343] - result already collected: FutureResult
[08:27:52.343] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[08:27:52.347] plan(): Setting new future strategy stack:
[08:27:52.347] List of future strategies:
[08:27:52.347] 1. multicore:
[08:27:52.347]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.347]    - tweaked: FALSE
[08:27:52.347]    - call: plan(strategy)
[08:27:52.350] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[08:27:52.350] getGlobalsAndPackages() ...
[08:27:52.350] Searching for globals...
[08:27:52.350] 
[08:27:52.351] Searching for globals ... DONE
[08:27:52.351] - globals: [0] <none>
[08:27:52.351] getGlobalsAndPackages() ... DONE
[08:27:52.351] run() for ‘Future’ ...
[08:27:52.351] - state: ‘created’
[08:27:52.352] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.354] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.354] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.354]   - Field: ‘label’
[08:27:52.354]   - Field: ‘local’
[08:27:52.354]   - Field: ‘owner’
[08:27:52.355]   - Field: ‘envir’
[08:27:52.355]   - Field: ‘workers’
[08:27:52.355]   - Field: ‘packages’
[08:27:52.355]   - Field: ‘gc’
[08:27:52.355]   - Field: ‘job’
[08:27:52.355]   - Field: ‘conditions’
[08:27:52.355]   - Field: ‘expr’
[08:27:52.355]   - Field: ‘uuid’
[08:27:52.356]   - Field: ‘seed’
[08:27:52.356]   - Field: ‘version’
[08:27:52.356]   - Field: ‘result’
[08:27:52.356]   - Field: ‘asynchronous’
[08:27:52.356]   - Field: ‘calls’
[08:27:52.356]   - Field: ‘globals’
[08:27:52.356]   - Field: ‘stdout’
[08:27:52.356]   - Field: ‘earlySignal’
[08:27:52.356]   - Field: ‘lazy’
[08:27:52.357]   - Field: ‘state’
[08:27:52.357] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.357] - Launch lazy future ...
[08:27:52.357] Packages needed by the future expression (n = 0): <none>
[08:27:52.357] Packages needed by future strategies (n = 0): <none>
[08:27:52.358] {
[08:27:52.358]     {
[08:27:52.358]         {
[08:27:52.358]             ...future.startTime <- base::Sys.time()
[08:27:52.358]             {
[08:27:52.358]                 {
[08:27:52.358]                   {
[08:27:52.358]                     {
[08:27:52.358]                       base::local({
[08:27:52.358]                         has_future <- base::requireNamespace("future", 
[08:27:52.358]                           quietly = TRUE)
[08:27:52.358]                         if (has_future) {
[08:27:52.358]                           ns <- base::getNamespace("future")
[08:27:52.358]                           version <- ns[[".package"]][["version"]]
[08:27:52.358]                           if (is.null(version)) 
[08:27:52.358]                             version <- utils::packageVersion("future")
[08:27:52.358]                         }
[08:27:52.358]                         else {
[08:27:52.358]                           version <- NULL
[08:27:52.358]                         }
[08:27:52.358]                         if (!has_future || version < "1.8.0") {
[08:27:52.358]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.358]                             "", base::R.version$version.string), 
[08:27:52.358]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.358]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.358]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.358]                               "release", "version")], collapse = " "), 
[08:27:52.358]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.358]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.358]                             info)
[08:27:52.358]                           info <- base::paste(info, collapse = "; ")
[08:27:52.358]                           if (!has_future) {
[08:27:52.358]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.358]                               info)
[08:27:52.358]                           }
[08:27:52.358]                           else {
[08:27:52.358]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.358]                               info, version)
[08:27:52.358]                           }
[08:27:52.358]                           base::stop(msg)
[08:27:52.358]                         }
[08:27:52.358]                       })
[08:27:52.358]                     }
[08:27:52.358]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.358]                     base::options(mc.cores = 1L)
[08:27:52.358]                   }
[08:27:52.358]                   ...future.strategy.old <- future::plan("list")
[08:27:52.358]                   options(future.plan = NULL)
[08:27:52.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.358]                 }
[08:27:52.358]                 ...future.workdir <- getwd()
[08:27:52.358]             }
[08:27:52.358]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.358]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.358]         }
[08:27:52.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.358]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.358]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.358]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.358]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.358]             base::names(...future.oldOptions))
[08:27:52.358]     }
[08:27:52.358]     if (FALSE) {
[08:27:52.358]     }
[08:27:52.358]     else {
[08:27:52.358]         if (TRUE) {
[08:27:52.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.358]                 open = "w")
[08:27:52.358]         }
[08:27:52.358]         else {
[08:27:52.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.358]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.358]         }
[08:27:52.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.358]             base::sink(type = "output", split = FALSE)
[08:27:52.358]             base::close(...future.stdout)
[08:27:52.358]         }, add = TRUE)
[08:27:52.358]     }
[08:27:52.358]     ...future.frame <- base::sys.nframe()
[08:27:52.358]     ...future.conditions <- base::list()
[08:27:52.358]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.358]     if (FALSE) {
[08:27:52.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.358]     }
[08:27:52.358]     ...future.result <- base::tryCatch({
[08:27:52.358]         base::withCallingHandlers({
[08:27:52.358]             ...future.value <- base::withVisible(base::local({
[08:27:52.358]                 withCallingHandlers({
[08:27:52.358]                   2
[08:27:52.358]                 }, immediateCondition = function(cond) {
[08:27:52.358]                   save_rds <- function (object, pathname, ...) 
[08:27:52.358]                   {
[08:27:52.358]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.358]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.358]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.358]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.358]                         fi_tmp[["mtime"]])
[08:27:52.358]                     }
[08:27:52.358]                     tryCatch({
[08:27:52.358]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.358]                     }, error = function(ex) {
[08:27:52.358]                       msg <- conditionMessage(ex)
[08:27:52.358]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.358]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.358]                         fi_tmp[["mtime"]], msg)
[08:27:52.358]                       ex$message <- msg
[08:27:52.358]                       stop(ex)
[08:27:52.358]                     })
[08:27:52.358]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.358]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.358]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.358]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.358]                       fi <- file.info(pathname)
[08:27:52.358]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.358]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.358]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.358]                         fi[["size"]], fi[["mtime"]])
[08:27:52.358]                       stop(msg)
[08:27:52.358]                     }
[08:27:52.358]                     invisible(pathname)
[08:27:52.358]                   }
[08:27:52.358]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.358]                     rootPath = tempdir()) 
[08:27:52.358]                   {
[08:27:52.358]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.358]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.358]                       tmpdir = path, fileext = ".rds")
[08:27:52.358]                     save_rds(obj, file)
[08:27:52.358]                   }
[08:27:52.358]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.358]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.358]                   {
[08:27:52.358]                     inherits <- base::inherits
[08:27:52.358]                     invokeRestart <- base::invokeRestart
[08:27:52.358]                     is.null <- base::is.null
[08:27:52.358]                     muffled <- FALSE
[08:27:52.358]                     if (inherits(cond, "message")) {
[08:27:52.358]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.358]                       if (muffled) 
[08:27:52.358]                         invokeRestart("muffleMessage")
[08:27:52.358]                     }
[08:27:52.358]                     else if (inherits(cond, "warning")) {
[08:27:52.358]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.358]                       if (muffled) 
[08:27:52.358]                         invokeRestart("muffleWarning")
[08:27:52.358]                     }
[08:27:52.358]                     else if (inherits(cond, "condition")) {
[08:27:52.358]                       if (!is.null(pattern)) {
[08:27:52.358]                         computeRestarts <- base::computeRestarts
[08:27:52.358]                         grepl <- base::grepl
[08:27:52.358]                         restarts <- computeRestarts(cond)
[08:27:52.358]                         for (restart in restarts) {
[08:27:52.358]                           name <- restart$name
[08:27:52.358]                           if (is.null(name)) 
[08:27:52.358]                             next
[08:27:52.358]                           if (!grepl(pattern, name)) 
[08:27:52.358]                             next
[08:27:52.358]                           invokeRestart(restart)
[08:27:52.358]                           muffled <- TRUE
[08:27:52.358]                           break
[08:27:52.358]                         }
[08:27:52.358]                       }
[08:27:52.358]                     }
[08:27:52.358]                     invisible(muffled)
[08:27:52.358]                   }
[08:27:52.358]                   muffleCondition(cond)
[08:27:52.358]                 })
[08:27:52.358]             }))
[08:27:52.358]             future::FutureResult(value = ...future.value$value, 
[08:27:52.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.358]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.358]                     ...future.globalenv.names))
[08:27:52.358]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.358]         }, condition = base::local({
[08:27:52.358]             c <- base::c
[08:27:52.358]             inherits <- base::inherits
[08:27:52.358]             invokeRestart <- base::invokeRestart
[08:27:52.358]             length <- base::length
[08:27:52.358]             list <- base::list
[08:27:52.358]             seq.int <- base::seq.int
[08:27:52.358]             signalCondition <- base::signalCondition
[08:27:52.358]             sys.calls <- base::sys.calls
[08:27:52.358]             `[[` <- base::`[[`
[08:27:52.358]             `+` <- base::`+`
[08:27:52.358]             `<<-` <- base::`<<-`
[08:27:52.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.358]                   3L)]
[08:27:52.358]             }
[08:27:52.358]             function(cond) {
[08:27:52.358]                 is_error <- inherits(cond, "error")
[08:27:52.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.358]                   NULL)
[08:27:52.358]                 if (is_error) {
[08:27:52.358]                   sessionInformation <- function() {
[08:27:52.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.358]                       search = base::search(), system = base::Sys.info())
[08:27:52.358]                   }
[08:27:52.358]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.358]                     cond$call), session = sessionInformation(), 
[08:27:52.358]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.358]                   signalCondition(cond)
[08:27:52.358]                 }
[08:27:52.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.358]                 "immediateCondition"))) {
[08:27:52.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.358]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.358]                   if (TRUE && !signal) {
[08:27:52.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.358]                     {
[08:27:52.358]                       inherits <- base::inherits
[08:27:52.358]                       invokeRestart <- base::invokeRestart
[08:27:52.358]                       is.null <- base::is.null
[08:27:52.358]                       muffled <- FALSE
[08:27:52.358]                       if (inherits(cond, "message")) {
[08:27:52.358]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.358]                         if (muffled) 
[08:27:52.358]                           invokeRestart("muffleMessage")
[08:27:52.358]                       }
[08:27:52.358]                       else if (inherits(cond, "warning")) {
[08:27:52.358]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.358]                         if (muffled) 
[08:27:52.358]                           invokeRestart("muffleWarning")
[08:27:52.358]                       }
[08:27:52.358]                       else if (inherits(cond, "condition")) {
[08:27:52.358]                         if (!is.null(pattern)) {
[08:27:52.358]                           computeRestarts <- base::computeRestarts
[08:27:52.358]                           grepl <- base::grepl
[08:27:52.358]                           restarts <- computeRestarts(cond)
[08:27:52.358]                           for (restart in restarts) {
[08:27:52.358]                             name <- restart$name
[08:27:52.358]                             if (is.null(name)) 
[08:27:52.358]                               next
[08:27:52.358]                             if (!grepl(pattern, name)) 
[08:27:52.358]                               next
[08:27:52.358]                             invokeRestart(restart)
[08:27:52.358]                             muffled <- TRUE
[08:27:52.358]                             break
[08:27:52.358]                           }
[08:27:52.358]                         }
[08:27:52.358]                       }
[08:27:52.358]                       invisible(muffled)
[08:27:52.358]                     }
[08:27:52.358]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.358]                   }
[08:27:52.358]                 }
[08:27:52.358]                 else {
[08:27:52.358]                   if (TRUE) {
[08:27:52.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.358]                     {
[08:27:52.358]                       inherits <- base::inherits
[08:27:52.358]                       invokeRestart <- base::invokeRestart
[08:27:52.358]                       is.null <- base::is.null
[08:27:52.358]                       muffled <- FALSE
[08:27:52.358]                       if (inherits(cond, "message")) {
[08:27:52.358]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.358]                         if (muffled) 
[08:27:52.358]                           invokeRestart("muffleMessage")
[08:27:52.358]                       }
[08:27:52.358]                       else if (inherits(cond, "warning")) {
[08:27:52.358]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.358]                         if (muffled) 
[08:27:52.358]                           invokeRestart("muffleWarning")
[08:27:52.358]                       }
[08:27:52.358]                       else if (inherits(cond, "condition")) {
[08:27:52.358]                         if (!is.null(pattern)) {
[08:27:52.358]                           computeRestarts <- base::computeRestarts
[08:27:52.358]                           grepl <- base::grepl
[08:27:52.358]                           restarts <- computeRestarts(cond)
[08:27:52.358]                           for (restart in restarts) {
[08:27:52.358]                             name <- restart$name
[08:27:52.358]                             if (is.null(name)) 
[08:27:52.358]                               next
[08:27:52.358]                             if (!grepl(pattern, name)) 
[08:27:52.358]                               next
[08:27:52.358]                             invokeRestart(restart)
[08:27:52.358]                             muffled <- TRUE
[08:27:52.358]                             break
[08:27:52.358]                           }
[08:27:52.358]                         }
[08:27:52.358]                       }
[08:27:52.358]                       invisible(muffled)
[08:27:52.358]                     }
[08:27:52.358]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.358]                   }
[08:27:52.358]                 }
[08:27:52.358]             }
[08:27:52.358]         }))
[08:27:52.358]     }, error = function(ex) {
[08:27:52.358]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.358]                 ...future.rng), started = ...future.startTime, 
[08:27:52.358]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.358]             version = "1.8"), class = "FutureResult")
[08:27:52.358]     }, finally = {
[08:27:52.358]         if (!identical(...future.workdir, getwd())) 
[08:27:52.358]             setwd(...future.workdir)
[08:27:52.358]         {
[08:27:52.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.358]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.358]             }
[08:27:52.358]             base::options(...future.oldOptions)
[08:27:52.358]             if (.Platform$OS.type == "windows") {
[08:27:52.358]                 old_names <- names(...future.oldEnvVars)
[08:27:52.358]                 envs <- base::Sys.getenv()
[08:27:52.358]                 names <- names(envs)
[08:27:52.358]                 common <- intersect(names, old_names)
[08:27:52.358]                 added <- setdiff(names, old_names)
[08:27:52.358]                 removed <- setdiff(old_names, names)
[08:27:52.358]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.358]                   envs[common]]
[08:27:52.358]                 NAMES <- toupper(changed)
[08:27:52.358]                 args <- list()
[08:27:52.358]                 for (kk in seq_along(NAMES)) {
[08:27:52.358]                   name <- changed[[kk]]
[08:27:52.358]                   NAME <- NAMES[[kk]]
[08:27:52.358]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.358]                     next
[08:27:52.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.358]                 }
[08:27:52.358]                 NAMES <- toupper(added)
[08:27:52.358]                 for (kk in seq_along(NAMES)) {
[08:27:52.358]                   name <- added[[kk]]
[08:27:52.358]                   NAME <- NAMES[[kk]]
[08:27:52.358]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.358]                     next
[08:27:52.358]                   args[[name]] <- ""
[08:27:52.358]                 }
[08:27:52.358]                 NAMES <- toupper(removed)
[08:27:52.358]                 for (kk in seq_along(NAMES)) {
[08:27:52.358]                   name <- removed[[kk]]
[08:27:52.358]                   NAME <- NAMES[[kk]]
[08:27:52.358]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.358]                     next
[08:27:52.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.358]                 }
[08:27:52.358]                 if (length(args) > 0) 
[08:27:52.358]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.358]             }
[08:27:52.358]             else {
[08:27:52.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.358]             }
[08:27:52.358]             {
[08:27:52.358]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.358]                   0L) {
[08:27:52.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.358]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.358]                   base::options(opts)
[08:27:52.358]                 }
[08:27:52.358]                 {
[08:27:52.358]                   {
[08:27:52.358]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.358]                     NULL
[08:27:52.358]                   }
[08:27:52.358]                   options(future.plan = NULL)
[08:27:52.358]                   if (is.na(NA_character_)) 
[08:27:52.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.358]                     .init = FALSE)
[08:27:52.358]                 }
[08:27:52.358]             }
[08:27:52.358]         }
[08:27:52.358]     })
[08:27:52.358]     if (TRUE) {
[08:27:52.358]         base::sink(type = "output", split = FALSE)
[08:27:52.358]         if (TRUE) {
[08:27:52.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.358]         }
[08:27:52.358]         else {
[08:27:52.358]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.358]         }
[08:27:52.358]         base::close(...future.stdout)
[08:27:52.358]         ...future.stdout <- NULL
[08:27:52.358]     }
[08:27:52.358]     ...future.result$conditions <- ...future.conditions
[08:27:52.358]     ...future.result$finished <- base::Sys.time()
[08:27:52.358]     ...future.result
[08:27:52.358] }
[08:27:52.360] requestCore(): workers = 2
[08:27:52.363] MulticoreFuture started
[08:27:52.364] - Launch lazy future ... done
[08:27:52.364] run() for ‘MulticoreFuture’ ... done
[08:27:52.364] getGlobalsAndPackages() ...
[08:27:52.364] Searching for globals...
[08:27:52.364] plan(): Setting new future strategy stack:
[08:27:52.365] 
[08:27:52.364] List of future strategies:
[08:27:52.364] 1. sequential:
[08:27:52.364]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.364]    - tweaked: FALSE
[08:27:52.364]    - call: NULL
[08:27:52.365] Searching for globals ... DONE
[08:27:52.366] plan(): nbrOfWorkers() = 1
[08:27:52.366] - globals: [0] <none>
[08:27:52.366] getGlobalsAndPackages() ... DONE
[08:27:52.366] run() for ‘Future’ ...
[08:27:52.367] - state: ‘created’
[08:27:52.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.368] plan(): Setting new future strategy stack:
[08:27:52.368] List of future strategies:
[08:27:52.368] 1. multicore:
[08:27:52.368]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.368]    - tweaked: FALSE
[08:27:52.368]    - call: plan(strategy)
[08:27:52.371] plan(): nbrOfWorkers() = 2
[08:27:52.371] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.371]   - Field: ‘label’
[08:27:52.372]   - Field: ‘local’
[08:27:52.372]   - Field: ‘owner’
[08:27:52.372]   - Field: ‘envir’
[08:27:52.372]   - Field: ‘workers’
[08:27:52.372]   - Field: ‘packages’
[08:27:52.372]   - Field: ‘gc’
[08:27:52.372]   - Field: ‘job’
[08:27:52.373]   - Field: ‘conditions’
[08:27:52.373]   - Field: ‘expr’
[08:27:52.373]   - Field: ‘uuid’
[08:27:52.373]   - Field: ‘seed’
[08:27:52.373]   - Field: ‘version’
[08:27:52.373]   - Field: ‘result’
[08:27:52.373]   - Field: ‘asynchronous’
[08:27:52.374]   - Field: ‘calls’
[08:27:52.374]   - Field: ‘globals’
[08:27:52.374]   - Field: ‘stdout’
[08:27:52.374]   - Field: ‘earlySignal’
[08:27:52.374]   - Field: ‘lazy’
[08:27:52.374]   - Field: ‘state’
[08:27:52.374] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.375] - Launch lazy future ...
[08:27:52.375] Packages needed by the future expression (n = 0): <none>
[08:27:52.375] Packages needed by future strategies (n = 0): <none>
[08:27:52.376] {
[08:27:52.376]     {
[08:27:52.376]         {
[08:27:52.376]             ...future.startTime <- base::Sys.time()
[08:27:52.376]             {
[08:27:52.376]                 {
[08:27:52.376]                   {
[08:27:52.376]                     {
[08:27:52.376]                       base::local({
[08:27:52.376]                         has_future <- base::requireNamespace("future", 
[08:27:52.376]                           quietly = TRUE)
[08:27:52.376]                         if (has_future) {
[08:27:52.376]                           ns <- base::getNamespace("future")
[08:27:52.376]                           version <- ns[[".package"]][["version"]]
[08:27:52.376]                           if (is.null(version)) 
[08:27:52.376]                             version <- utils::packageVersion("future")
[08:27:52.376]                         }
[08:27:52.376]                         else {
[08:27:52.376]                           version <- NULL
[08:27:52.376]                         }
[08:27:52.376]                         if (!has_future || version < "1.8.0") {
[08:27:52.376]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.376]                             "", base::R.version$version.string), 
[08:27:52.376]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.376]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.376]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.376]                               "release", "version")], collapse = " "), 
[08:27:52.376]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.376]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.376]                             info)
[08:27:52.376]                           info <- base::paste(info, collapse = "; ")
[08:27:52.376]                           if (!has_future) {
[08:27:52.376]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.376]                               info)
[08:27:52.376]                           }
[08:27:52.376]                           else {
[08:27:52.376]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.376]                               info, version)
[08:27:52.376]                           }
[08:27:52.376]                           base::stop(msg)
[08:27:52.376]                         }
[08:27:52.376]                       })
[08:27:52.376]                     }
[08:27:52.376]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.376]                     base::options(mc.cores = 1L)
[08:27:52.376]                   }
[08:27:52.376]                   ...future.strategy.old <- future::plan("list")
[08:27:52.376]                   options(future.plan = NULL)
[08:27:52.376]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.376]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.376]                 }
[08:27:52.376]                 ...future.workdir <- getwd()
[08:27:52.376]             }
[08:27:52.376]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.376]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.376]         }
[08:27:52.376]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.376]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.376]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.376]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.376]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.376]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.376]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.376]             base::names(...future.oldOptions))
[08:27:52.376]     }
[08:27:52.376]     if (FALSE) {
[08:27:52.376]     }
[08:27:52.376]     else {
[08:27:52.376]         if (TRUE) {
[08:27:52.376]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.376]                 open = "w")
[08:27:52.376]         }
[08:27:52.376]         else {
[08:27:52.376]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.376]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.376]         }
[08:27:52.376]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.376]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.376]             base::sink(type = "output", split = FALSE)
[08:27:52.376]             base::close(...future.stdout)
[08:27:52.376]         }, add = TRUE)
[08:27:52.376]     }
[08:27:52.376]     ...future.frame <- base::sys.nframe()
[08:27:52.376]     ...future.conditions <- base::list()
[08:27:52.376]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.376]     if (FALSE) {
[08:27:52.376]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.376]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.376]     }
[08:27:52.376]     ...future.result <- base::tryCatch({
[08:27:52.376]         base::withCallingHandlers({
[08:27:52.376]             ...future.value <- base::withVisible(base::local({
[08:27:52.376]                 withCallingHandlers({
[08:27:52.376]                   NULL
[08:27:52.376]                 }, immediateCondition = function(cond) {
[08:27:52.376]                   save_rds <- function (object, pathname, ...) 
[08:27:52.376]                   {
[08:27:52.376]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.376]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.376]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.376]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.376]                         fi_tmp[["mtime"]])
[08:27:52.376]                     }
[08:27:52.376]                     tryCatch({
[08:27:52.376]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.376]                     }, error = function(ex) {
[08:27:52.376]                       msg <- conditionMessage(ex)
[08:27:52.376]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.376]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.376]                         fi_tmp[["mtime"]], msg)
[08:27:52.376]                       ex$message <- msg
[08:27:52.376]                       stop(ex)
[08:27:52.376]                     })
[08:27:52.376]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.376]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.376]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.376]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.376]                       fi <- file.info(pathname)
[08:27:52.376]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.376]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.376]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.376]                         fi[["size"]], fi[["mtime"]])
[08:27:52.376]                       stop(msg)
[08:27:52.376]                     }
[08:27:52.376]                     invisible(pathname)
[08:27:52.376]                   }
[08:27:52.376]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.376]                     rootPath = tempdir()) 
[08:27:52.376]                   {
[08:27:52.376]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.376]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.376]                       tmpdir = path, fileext = ".rds")
[08:27:52.376]                     save_rds(obj, file)
[08:27:52.376]                   }
[08:27:52.376]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.376]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.376]                   {
[08:27:52.376]                     inherits <- base::inherits
[08:27:52.376]                     invokeRestart <- base::invokeRestart
[08:27:52.376]                     is.null <- base::is.null
[08:27:52.376]                     muffled <- FALSE
[08:27:52.376]                     if (inherits(cond, "message")) {
[08:27:52.376]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.376]                       if (muffled) 
[08:27:52.376]                         invokeRestart("muffleMessage")
[08:27:52.376]                     }
[08:27:52.376]                     else if (inherits(cond, "warning")) {
[08:27:52.376]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.376]                       if (muffled) 
[08:27:52.376]                         invokeRestart("muffleWarning")
[08:27:52.376]                     }
[08:27:52.376]                     else if (inherits(cond, "condition")) {
[08:27:52.376]                       if (!is.null(pattern)) {
[08:27:52.376]                         computeRestarts <- base::computeRestarts
[08:27:52.376]                         grepl <- base::grepl
[08:27:52.376]                         restarts <- computeRestarts(cond)
[08:27:52.376]                         for (restart in restarts) {
[08:27:52.376]                           name <- restart$name
[08:27:52.376]                           if (is.null(name)) 
[08:27:52.376]                             next
[08:27:52.376]                           if (!grepl(pattern, name)) 
[08:27:52.376]                             next
[08:27:52.376]                           invokeRestart(restart)
[08:27:52.376]                           muffled <- TRUE
[08:27:52.376]                           break
[08:27:52.376]                         }
[08:27:52.376]                       }
[08:27:52.376]                     }
[08:27:52.376]                     invisible(muffled)
[08:27:52.376]                   }
[08:27:52.376]                   muffleCondition(cond)
[08:27:52.376]                 })
[08:27:52.376]             }))
[08:27:52.376]             future::FutureResult(value = ...future.value$value, 
[08:27:52.376]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.376]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.376]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.376]                     ...future.globalenv.names))
[08:27:52.376]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.376]         }, condition = base::local({
[08:27:52.376]             c <- base::c
[08:27:52.376]             inherits <- base::inherits
[08:27:52.376]             invokeRestart <- base::invokeRestart
[08:27:52.376]             length <- base::length
[08:27:52.376]             list <- base::list
[08:27:52.376]             seq.int <- base::seq.int
[08:27:52.376]             signalCondition <- base::signalCondition
[08:27:52.376]             sys.calls <- base::sys.calls
[08:27:52.376]             `[[` <- base::`[[`
[08:27:52.376]             `+` <- base::`+`
[08:27:52.376]             `<<-` <- base::`<<-`
[08:27:52.376]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.376]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.376]                   3L)]
[08:27:52.376]             }
[08:27:52.376]             function(cond) {
[08:27:52.376]                 is_error <- inherits(cond, "error")
[08:27:52.376]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.376]                   NULL)
[08:27:52.376]                 if (is_error) {
[08:27:52.376]                   sessionInformation <- function() {
[08:27:52.376]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.376]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.376]                       search = base::search(), system = base::Sys.info())
[08:27:52.376]                   }
[08:27:52.376]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.376]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.376]                     cond$call), session = sessionInformation(), 
[08:27:52.376]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.376]                   signalCondition(cond)
[08:27:52.376]                 }
[08:27:52.376]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.376]                 "immediateCondition"))) {
[08:27:52.376]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.376]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.376]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.376]                   if (TRUE && !signal) {
[08:27:52.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.376]                     {
[08:27:52.376]                       inherits <- base::inherits
[08:27:52.376]                       invokeRestart <- base::invokeRestart
[08:27:52.376]                       is.null <- base::is.null
[08:27:52.376]                       muffled <- FALSE
[08:27:52.376]                       if (inherits(cond, "message")) {
[08:27:52.376]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.376]                         if (muffled) 
[08:27:52.376]                           invokeRestart("muffleMessage")
[08:27:52.376]                       }
[08:27:52.376]                       else if (inherits(cond, "warning")) {
[08:27:52.376]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.376]                         if (muffled) 
[08:27:52.376]                           invokeRestart("muffleWarning")
[08:27:52.376]                       }
[08:27:52.376]                       else if (inherits(cond, "condition")) {
[08:27:52.376]                         if (!is.null(pattern)) {
[08:27:52.376]                           computeRestarts <- base::computeRestarts
[08:27:52.376]                           grepl <- base::grepl
[08:27:52.376]                           restarts <- computeRestarts(cond)
[08:27:52.376]                           for (restart in restarts) {
[08:27:52.376]                             name <- restart$name
[08:27:52.376]                             if (is.null(name)) 
[08:27:52.376]                               next
[08:27:52.376]                             if (!grepl(pattern, name)) 
[08:27:52.376]                               next
[08:27:52.376]                             invokeRestart(restart)
[08:27:52.376]                             muffled <- TRUE
[08:27:52.376]                             break
[08:27:52.376]                           }
[08:27:52.376]                         }
[08:27:52.376]                       }
[08:27:52.376]                       invisible(muffled)
[08:27:52.376]                     }
[08:27:52.376]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.376]                   }
[08:27:52.376]                 }
[08:27:52.376]                 else {
[08:27:52.376]                   if (TRUE) {
[08:27:52.376]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.376]                     {
[08:27:52.376]                       inherits <- base::inherits
[08:27:52.376]                       invokeRestart <- base::invokeRestart
[08:27:52.376]                       is.null <- base::is.null
[08:27:52.376]                       muffled <- FALSE
[08:27:52.376]                       if (inherits(cond, "message")) {
[08:27:52.376]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.376]                         if (muffled) 
[08:27:52.376]                           invokeRestart("muffleMessage")
[08:27:52.376]                       }
[08:27:52.376]                       else if (inherits(cond, "warning")) {
[08:27:52.376]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.376]                         if (muffled) 
[08:27:52.376]                           invokeRestart("muffleWarning")
[08:27:52.376]                       }
[08:27:52.376]                       else if (inherits(cond, "condition")) {
[08:27:52.376]                         if (!is.null(pattern)) {
[08:27:52.376]                           computeRestarts <- base::computeRestarts
[08:27:52.376]                           grepl <- base::grepl
[08:27:52.376]                           restarts <- computeRestarts(cond)
[08:27:52.376]                           for (restart in restarts) {
[08:27:52.376]                             name <- restart$name
[08:27:52.376]                             if (is.null(name)) 
[08:27:52.376]                               next
[08:27:52.376]                             if (!grepl(pattern, name)) 
[08:27:52.376]                               next
[08:27:52.376]                             invokeRestart(restart)
[08:27:52.376]                             muffled <- TRUE
[08:27:52.376]                             break
[08:27:52.376]                           }
[08:27:52.376]                         }
[08:27:52.376]                       }
[08:27:52.376]                       invisible(muffled)
[08:27:52.376]                     }
[08:27:52.376]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.376]                   }
[08:27:52.376]                 }
[08:27:52.376]             }
[08:27:52.376]         }))
[08:27:52.376]     }, error = function(ex) {
[08:27:52.376]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.376]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.376]                 ...future.rng), started = ...future.startTime, 
[08:27:52.376]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.376]             version = "1.8"), class = "FutureResult")
[08:27:52.376]     }, finally = {
[08:27:52.376]         if (!identical(...future.workdir, getwd())) 
[08:27:52.376]             setwd(...future.workdir)
[08:27:52.376]         {
[08:27:52.376]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.376]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.376]             }
[08:27:52.376]             base::options(...future.oldOptions)
[08:27:52.376]             if (.Platform$OS.type == "windows") {
[08:27:52.376]                 old_names <- names(...future.oldEnvVars)
[08:27:52.376]                 envs <- base::Sys.getenv()
[08:27:52.376]                 names <- names(envs)
[08:27:52.376]                 common <- intersect(names, old_names)
[08:27:52.376]                 added <- setdiff(names, old_names)
[08:27:52.376]                 removed <- setdiff(old_names, names)
[08:27:52.376]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.376]                   envs[common]]
[08:27:52.376]                 NAMES <- toupper(changed)
[08:27:52.376]                 args <- list()
[08:27:52.376]                 for (kk in seq_along(NAMES)) {
[08:27:52.376]                   name <- changed[[kk]]
[08:27:52.376]                   NAME <- NAMES[[kk]]
[08:27:52.376]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.376]                     next
[08:27:52.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.376]                 }
[08:27:52.376]                 NAMES <- toupper(added)
[08:27:52.376]                 for (kk in seq_along(NAMES)) {
[08:27:52.376]                   name <- added[[kk]]
[08:27:52.376]                   NAME <- NAMES[[kk]]
[08:27:52.376]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.376]                     next
[08:27:52.376]                   args[[name]] <- ""
[08:27:52.376]                 }
[08:27:52.376]                 NAMES <- toupper(removed)
[08:27:52.376]                 for (kk in seq_along(NAMES)) {
[08:27:52.376]                   name <- removed[[kk]]
[08:27:52.376]                   NAME <- NAMES[[kk]]
[08:27:52.376]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.376]                     next
[08:27:52.376]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.376]                 }
[08:27:52.376]                 if (length(args) > 0) 
[08:27:52.376]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.376]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.376]             }
[08:27:52.376]             else {
[08:27:52.376]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.376]             }
[08:27:52.376]             {
[08:27:52.376]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.376]                   0L) {
[08:27:52.376]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.376]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.376]                   base::options(opts)
[08:27:52.376]                 }
[08:27:52.376]                 {
[08:27:52.376]                   {
[08:27:52.376]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.376]                     NULL
[08:27:52.376]                   }
[08:27:52.376]                   options(future.plan = NULL)
[08:27:52.376]                   if (is.na(NA_character_)) 
[08:27:52.376]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.376]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.376]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.376]                     .init = FALSE)
[08:27:52.376]                 }
[08:27:52.376]             }
[08:27:52.376]         }
[08:27:52.376]     })
[08:27:52.376]     if (TRUE) {
[08:27:52.376]         base::sink(type = "output", split = FALSE)
[08:27:52.376]         if (TRUE) {
[08:27:52.376]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.376]         }
[08:27:52.376]         else {
[08:27:52.376]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.376]         }
[08:27:52.376]         base::close(...future.stdout)
[08:27:52.376]         ...future.stdout <- NULL
[08:27:52.376]     }
[08:27:52.376]     ...future.result$conditions <- ...future.conditions
[08:27:52.376]     ...future.result$finished <- base::Sys.time()
[08:27:52.376]     ...future.result
[08:27:52.376] }
[08:27:52.380] requestCore(): workers = 2
[08:27:52.383] MulticoreFuture started
[08:27:52.383] - Launch lazy future ... done
[08:27:52.383] run() for ‘MulticoreFuture’ ... done
[08:27:52.384] plan(): Setting new future strategy stack:
[08:27:52.384] getGlobalsAndPackages() ...
[08:27:52.384] Searching for globals...
[08:27:52.384] List of future strategies:
[08:27:52.384] 1. sequential:
[08:27:52.384]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.384]    - tweaked: FALSE
[08:27:52.384]    - call: NULL
[08:27:52.385] plan(): nbrOfWorkers() = 1
[08:27:52.386] - globals found: [1] ‘{’
[08:27:52.386] Searching for globals ... DONE
[08:27:52.386] Resolving globals: FALSE
[08:27:52.387] 
[08:27:52.387] 
[08:27:52.387] getGlobalsAndPackages() ... DONE
[08:27:52.387] plan(): Setting new future strategy stack:
[08:27:52.387] run() for ‘Future’ ...
[08:27:52.388] - state: ‘created’
[08:27:52.388] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.387] List of future strategies:
[08:27:52.387] 1. multicore:
[08:27:52.387]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.387]    - tweaked: FALSE
[08:27:52.387]    - call: plan(strategy)
[08:27:52.390] plan(): nbrOfWorkers() = 2
[08:27:52.391] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.391] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.391]   - Field: ‘label’
[08:27:52.391]   - Field: ‘local’
[08:27:52.391]   - Field: ‘owner’
[08:27:52.392]   - Field: ‘envir’
[08:27:52.392]   - Field: ‘workers’
[08:27:52.392]   - Field: ‘packages’
[08:27:52.392]   - Field: ‘gc’
[08:27:52.392]   - Field: ‘job’
[08:27:52.392]   - Field: ‘conditions’
[08:27:52.392]   - Field: ‘expr’
[08:27:52.393]   - Field: ‘uuid’
[08:27:52.393]   - Field: ‘seed’
[08:27:52.393]   - Field: ‘version’
[08:27:52.393]   - Field: ‘result’
[08:27:52.393]   - Field: ‘asynchronous’
[08:27:52.393]   - Field: ‘calls’
[08:27:52.393]   - Field: ‘globals’
[08:27:52.393]   - Field: ‘stdout’
[08:27:52.393]   - Field: ‘earlySignal’
[08:27:52.394]   - Field: ‘lazy’
[08:27:52.394]   - Field: ‘state’
[08:27:52.394] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.394] - Launch lazy future ...
[08:27:52.394] Packages needed by the future expression (n = 0): <none>
[08:27:52.395] Packages needed by future strategies (n = 0): <none>
[08:27:52.395] {
[08:27:52.395]     {
[08:27:52.395]         {
[08:27:52.395]             ...future.startTime <- base::Sys.time()
[08:27:52.395]             {
[08:27:52.395]                 {
[08:27:52.395]                   {
[08:27:52.395]                     {
[08:27:52.395]                       base::local({
[08:27:52.395]                         has_future <- base::requireNamespace("future", 
[08:27:52.395]                           quietly = TRUE)
[08:27:52.395]                         if (has_future) {
[08:27:52.395]                           ns <- base::getNamespace("future")
[08:27:52.395]                           version <- ns[[".package"]][["version"]]
[08:27:52.395]                           if (is.null(version)) 
[08:27:52.395]                             version <- utils::packageVersion("future")
[08:27:52.395]                         }
[08:27:52.395]                         else {
[08:27:52.395]                           version <- NULL
[08:27:52.395]                         }
[08:27:52.395]                         if (!has_future || version < "1.8.0") {
[08:27:52.395]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.395]                             "", base::R.version$version.string), 
[08:27:52.395]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.395]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.395]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.395]                               "release", "version")], collapse = " "), 
[08:27:52.395]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.395]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.395]                             info)
[08:27:52.395]                           info <- base::paste(info, collapse = "; ")
[08:27:52.395]                           if (!has_future) {
[08:27:52.395]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.395]                               info)
[08:27:52.395]                           }
[08:27:52.395]                           else {
[08:27:52.395]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.395]                               info, version)
[08:27:52.395]                           }
[08:27:52.395]                           base::stop(msg)
[08:27:52.395]                         }
[08:27:52.395]                       })
[08:27:52.395]                     }
[08:27:52.395]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.395]                     base::options(mc.cores = 1L)
[08:27:52.395]                   }
[08:27:52.395]                   ...future.strategy.old <- future::plan("list")
[08:27:52.395]                   options(future.plan = NULL)
[08:27:52.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.395]                 }
[08:27:52.395]                 ...future.workdir <- getwd()
[08:27:52.395]             }
[08:27:52.395]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.395]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.395]         }
[08:27:52.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.395]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.395]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.395]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.395]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.395]             base::names(...future.oldOptions))
[08:27:52.395]     }
[08:27:52.395]     if (FALSE) {
[08:27:52.395]     }
[08:27:52.395]     else {
[08:27:52.395]         if (TRUE) {
[08:27:52.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.395]                 open = "w")
[08:27:52.395]         }
[08:27:52.395]         else {
[08:27:52.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.395]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.395]         }
[08:27:52.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.395]             base::sink(type = "output", split = FALSE)
[08:27:52.395]             base::close(...future.stdout)
[08:27:52.395]         }, add = TRUE)
[08:27:52.395]     }
[08:27:52.395]     ...future.frame <- base::sys.nframe()
[08:27:52.395]     ...future.conditions <- base::list()
[08:27:52.395]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.395]     if (FALSE) {
[08:27:52.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.395]     }
[08:27:52.395]     ...future.result <- base::tryCatch({
[08:27:52.395]         base::withCallingHandlers({
[08:27:52.395]             ...future.value <- base::withVisible(base::local({
[08:27:52.395]                 withCallingHandlers({
[08:27:52.395]                   {
[08:27:52.395]                     4
[08:27:52.395]                   }
[08:27:52.395]                 }, immediateCondition = function(cond) {
[08:27:52.395]                   save_rds <- function (object, pathname, ...) 
[08:27:52.395]                   {
[08:27:52.395]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.395]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.395]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.395]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.395]                         fi_tmp[["mtime"]])
[08:27:52.395]                     }
[08:27:52.395]                     tryCatch({
[08:27:52.395]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.395]                     }, error = function(ex) {
[08:27:52.395]                       msg <- conditionMessage(ex)
[08:27:52.395]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.395]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.395]                         fi_tmp[["mtime"]], msg)
[08:27:52.395]                       ex$message <- msg
[08:27:52.395]                       stop(ex)
[08:27:52.395]                     })
[08:27:52.395]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.395]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.395]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.395]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.395]                       fi <- file.info(pathname)
[08:27:52.395]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.395]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.395]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.395]                         fi[["size"]], fi[["mtime"]])
[08:27:52.395]                       stop(msg)
[08:27:52.395]                     }
[08:27:52.395]                     invisible(pathname)
[08:27:52.395]                   }
[08:27:52.395]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.395]                     rootPath = tempdir()) 
[08:27:52.395]                   {
[08:27:52.395]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.395]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.395]                       tmpdir = path, fileext = ".rds")
[08:27:52.395]                     save_rds(obj, file)
[08:27:52.395]                   }
[08:27:52.395]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.395]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.395]                   {
[08:27:52.395]                     inherits <- base::inherits
[08:27:52.395]                     invokeRestart <- base::invokeRestart
[08:27:52.395]                     is.null <- base::is.null
[08:27:52.395]                     muffled <- FALSE
[08:27:52.395]                     if (inherits(cond, "message")) {
[08:27:52.395]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.395]                       if (muffled) 
[08:27:52.395]                         invokeRestart("muffleMessage")
[08:27:52.395]                     }
[08:27:52.395]                     else if (inherits(cond, "warning")) {
[08:27:52.395]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.395]                       if (muffled) 
[08:27:52.395]                         invokeRestart("muffleWarning")
[08:27:52.395]                     }
[08:27:52.395]                     else if (inherits(cond, "condition")) {
[08:27:52.395]                       if (!is.null(pattern)) {
[08:27:52.395]                         computeRestarts <- base::computeRestarts
[08:27:52.395]                         grepl <- base::grepl
[08:27:52.395]                         restarts <- computeRestarts(cond)
[08:27:52.395]                         for (restart in restarts) {
[08:27:52.395]                           name <- restart$name
[08:27:52.395]                           if (is.null(name)) 
[08:27:52.395]                             next
[08:27:52.395]                           if (!grepl(pattern, name)) 
[08:27:52.395]                             next
[08:27:52.395]                           invokeRestart(restart)
[08:27:52.395]                           muffled <- TRUE
[08:27:52.395]                           break
[08:27:52.395]                         }
[08:27:52.395]                       }
[08:27:52.395]                     }
[08:27:52.395]                     invisible(muffled)
[08:27:52.395]                   }
[08:27:52.395]                   muffleCondition(cond)
[08:27:52.395]                 })
[08:27:52.395]             }))
[08:27:52.395]             future::FutureResult(value = ...future.value$value, 
[08:27:52.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.395]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.395]                     ...future.globalenv.names))
[08:27:52.395]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.395]         }, condition = base::local({
[08:27:52.395]             c <- base::c
[08:27:52.395]             inherits <- base::inherits
[08:27:52.395]             invokeRestart <- base::invokeRestart
[08:27:52.395]             length <- base::length
[08:27:52.395]             list <- base::list
[08:27:52.395]             seq.int <- base::seq.int
[08:27:52.395]             signalCondition <- base::signalCondition
[08:27:52.395]             sys.calls <- base::sys.calls
[08:27:52.395]             `[[` <- base::`[[`
[08:27:52.395]             `+` <- base::`+`
[08:27:52.395]             `<<-` <- base::`<<-`
[08:27:52.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.395]                   3L)]
[08:27:52.395]             }
[08:27:52.395]             function(cond) {
[08:27:52.395]                 is_error <- inherits(cond, "error")
[08:27:52.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.395]                   NULL)
[08:27:52.395]                 if (is_error) {
[08:27:52.395]                   sessionInformation <- function() {
[08:27:52.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.395]                       search = base::search(), system = base::Sys.info())
[08:27:52.395]                   }
[08:27:52.395]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.395]                     cond$call), session = sessionInformation(), 
[08:27:52.395]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.395]                   signalCondition(cond)
[08:27:52.395]                 }
[08:27:52.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.395]                 "immediateCondition"))) {
[08:27:52.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.395]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.395]                   if (TRUE && !signal) {
[08:27:52.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.395]                     {
[08:27:52.395]                       inherits <- base::inherits
[08:27:52.395]                       invokeRestart <- base::invokeRestart
[08:27:52.395]                       is.null <- base::is.null
[08:27:52.395]                       muffled <- FALSE
[08:27:52.395]                       if (inherits(cond, "message")) {
[08:27:52.395]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.395]                         if (muffled) 
[08:27:52.395]                           invokeRestart("muffleMessage")
[08:27:52.395]                       }
[08:27:52.395]                       else if (inherits(cond, "warning")) {
[08:27:52.395]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.395]                         if (muffled) 
[08:27:52.395]                           invokeRestart("muffleWarning")
[08:27:52.395]                       }
[08:27:52.395]                       else if (inherits(cond, "condition")) {
[08:27:52.395]                         if (!is.null(pattern)) {
[08:27:52.395]                           computeRestarts <- base::computeRestarts
[08:27:52.395]                           grepl <- base::grepl
[08:27:52.395]                           restarts <- computeRestarts(cond)
[08:27:52.395]                           for (restart in restarts) {
[08:27:52.395]                             name <- restart$name
[08:27:52.395]                             if (is.null(name)) 
[08:27:52.395]                               next
[08:27:52.395]                             if (!grepl(pattern, name)) 
[08:27:52.395]                               next
[08:27:52.395]                             invokeRestart(restart)
[08:27:52.395]                             muffled <- TRUE
[08:27:52.395]                             break
[08:27:52.395]                           }
[08:27:52.395]                         }
[08:27:52.395]                       }
[08:27:52.395]                       invisible(muffled)
[08:27:52.395]                     }
[08:27:52.395]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.395]                   }
[08:27:52.395]                 }
[08:27:52.395]                 else {
[08:27:52.395]                   if (TRUE) {
[08:27:52.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.395]                     {
[08:27:52.395]                       inherits <- base::inherits
[08:27:52.395]                       invokeRestart <- base::invokeRestart
[08:27:52.395]                       is.null <- base::is.null
[08:27:52.395]                       muffled <- FALSE
[08:27:52.395]                       if (inherits(cond, "message")) {
[08:27:52.395]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.395]                         if (muffled) 
[08:27:52.395]                           invokeRestart("muffleMessage")
[08:27:52.395]                       }
[08:27:52.395]                       else if (inherits(cond, "warning")) {
[08:27:52.395]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.395]                         if (muffled) 
[08:27:52.395]                           invokeRestart("muffleWarning")
[08:27:52.395]                       }
[08:27:52.395]                       else if (inherits(cond, "condition")) {
[08:27:52.395]                         if (!is.null(pattern)) {
[08:27:52.395]                           computeRestarts <- base::computeRestarts
[08:27:52.395]                           grepl <- base::grepl
[08:27:52.395]                           restarts <- computeRestarts(cond)
[08:27:52.395]                           for (restart in restarts) {
[08:27:52.395]                             name <- restart$name
[08:27:52.395]                             if (is.null(name)) 
[08:27:52.395]                               next
[08:27:52.395]                             if (!grepl(pattern, name)) 
[08:27:52.395]                               next
[08:27:52.395]                             invokeRestart(restart)
[08:27:52.395]                             muffled <- TRUE
[08:27:52.395]                             break
[08:27:52.395]                           }
[08:27:52.395]                         }
[08:27:52.395]                       }
[08:27:52.395]                       invisible(muffled)
[08:27:52.395]                     }
[08:27:52.395]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.395]                   }
[08:27:52.395]                 }
[08:27:52.395]             }
[08:27:52.395]         }))
[08:27:52.395]     }, error = function(ex) {
[08:27:52.395]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.395]                 ...future.rng), started = ...future.startTime, 
[08:27:52.395]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.395]             version = "1.8"), class = "FutureResult")
[08:27:52.395]     }, finally = {
[08:27:52.395]         if (!identical(...future.workdir, getwd())) 
[08:27:52.395]             setwd(...future.workdir)
[08:27:52.395]         {
[08:27:52.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.395]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.395]             }
[08:27:52.395]             base::options(...future.oldOptions)
[08:27:52.395]             if (.Platform$OS.type == "windows") {
[08:27:52.395]                 old_names <- names(...future.oldEnvVars)
[08:27:52.395]                 envs <- base::Sys.getenv()
[08:27:52.395]                 names <- names(envs)
[08:27:52.395]                 common <- intersect(names, old_names)
[08:27:52.395]                 added <- setdiff(names, old_names)
[08:27:52.395]                 removed <- setdiff(old_names, names)
[08:27:52.395]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.395]                   envs[common]]
[08:27:52.395]                 NAMES <- toupper(changed)
[08:27:52.395]                 args <- list()
[08:27:52.395]                 for (kk in seq_along(NAMES)) {
[08:27:52.395]                   name <- changed[[kk]]
[08:27:52.395]                   NAME <- NAMES[[kk]]
[08:27:52.395]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.395]                     next
[08:27:52.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.395]                 }
[08:27:52.395]                 NAMES <- toupper(added)
[08:27:52.395]                 for (kk in seq_along(NAMES)) {
[08:27:52.395]                   name <- added[[kk]]
[08:27:52.395]                   NAME <- NAMES[[kk]]
[08:27:52.395]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.395]                     next
[08:27:52.395]                   args[[name]] <- ""
[08:27:52.395]                 }
[08:27:52.395]                 NAMES <- toupper(removed)
[08:27:52.395]                 for (kk in seq_along(NAMES)) {
[08:27:52.395]                   name <- removed[[kk]]
[08:27:52.395]                   NAME <- NAMES[[kk]]
[08:27:52.395]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.395]                     next
[08:27:52.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.395]                 }
[08:27:52.395]                 if (length(args) > 0) 
[08:27:52.395]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.395]             }
[08:27:52.395]             else {
[08:27:52.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.395]             }
[08:27:52.395]             {
[08:27:52.395]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.395]                   0L) {
[08:27:52.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.395]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.395]                   base::options(opts)
[08:27:52.395]                 }
[08:27:52.395]                 {
[08:27:52.395]                   {
[08:27:52.395]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.395]                     NULL
[08:27:52.395]                   }
[08:27:52.395]                   options(future.plan = NULL)
[08:27:52.395]                   if (is.na(NA_character_)) 
[08:27:52.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.395]                     .init = FALSE)
[08:27:52.395]                 }
[08:27:52.395]             }
[08:27:52.395]         }
[08:27:52.395]     })
[08:27:52.395]     if (TRUE) {
[08:27:52.395]         base::sink(type = "output", split = FALSE)
[08:27:52.395]         if (TRUE) {
[08:27:52.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.395]         }
[08:27:52.395]         else {
[08:27:52.395]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.395]         }
[08:27:52.395]         base::close(...future.stdout)
[08:27:52.395]         ...future.stdout <- NULL
[08:27:52.395]     }
[08:27:52.395]     ...future.result$conditions <- ...future.conditions
[08:27:52.395]     ...future.result$finished <- base::Sys.time()
[08:27:52.395]     ...future.result
[08:27:52.395] }
[08:27:52.399] requestCore(): workers = 2
[08:27:52.399] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:52.410] result() for MulticoreFuture ...
[08:27:52.411] result() for MulticoreFuture ...
[08:27:52.411] result() for MulticoreFuture ... done
[08:27:52.411] result() for MulticoreFuture ... done
[08:27:52.411] result() for MulticoreFuture ...
[08:27:52.411] result() for MulticoreFuture ... done
[08:27:52.414] MulticoreFuture started
[08:27:52.415] - Launch lazy future ... done
[08:27:52.415] run() for ‘MulticoreFuture’ ... done
[08:27:52.416] plan(): Setting new future strategy stack:
<environment: 0x55d8607fe998> 
[08:27:52.416] List of future strategies:
[08:27:52.416] 1. sequential:
[08:27:52.416]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.416]    - tweaked: FALSE
[08:27:52.416]    - call: NULL
[08:27:52.418] plan(): nbrOfWorkers() = 1
<environment: 0x55d862294100> 
[08:27:52.421] plan(): Setting new future strategy stack:
[08:27:52.421] List of future strategies:
[08:27:52.421] 1. multicore:
[08:27:52.421]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.421]    - tweaked: FALSE
[08:27:52.421]    - call: plan(strategy)
[08:27:52.424] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:52.426] resolve() on environment ...
[08:27:52.426]  recursive: 0
[08:27:52.427]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:52.427] signalConditionsASAP(numeric, pos=1) ...
[08:27:52.427] - nx: 4
[08:27:52.427] - relay: TRUE
[08:27:52.428] - stdout: TRUE
[08:27:52.428] - signal: TRUE
[08:27:52.428] - resignal: FALSE
[08:27:52.428] - force: TRUE
[08:27:52.428] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.428] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.428]  - until=2
[08:27:52.428]  - relaying element #2
[08:27:52.429] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.429] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.429] signalConditionsASAP(NULL, pos=1) ... done
[08:27:52.429]  length: 3 (resolved future 1)
[08:27:52.429] Future #2
[08:27:52.429] result() for MulticoreFuture ...
[08:27:52.429] result() for MulticoreFuture ... done
[08:27:52.430] result() for MulticoreFuture ...
[08:27:52.430] result() for MulticoreFuture ... done
[08:27:52.430] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:52.430] - nx: 4
[08:27:52.430] - relay: TRUE
[08:27:52.430] - stdout: TRUE
[08:27:52.430] - signal: TRUE
[08:27:52.430] - resignal: FALSE
[08:27:52.430] - force: TRUE
[08:27:52.431] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.431] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.431]  - until=2
[08:27:52.431]  - relaying element #2
[08:27:52.431] result() for MulticoreFuture ...
[08:27:52.431] result() for MulticoreFuture ... done
[08:27:52.431] result() for MulticoreFuture ...
[08:27:52.431] result() for MulticoreFuture ... done
[08:27:52.432] result() for MulticoreFuture ...
[08:27:52.432] result() for MulticoreFuture ... done
[08:27:52.432] result() for MulticoreFuture ...
[08:27:52.432] result() for MulticoreFuture ... done
[08:27:52.432] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.432] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.432] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:52.432]  length: 2 (resolved future 2)
[08:27:52.433] Future #3
[08:27:52.433] result() for MulticoreFuture ...
[08:27:52.434] result() for MulticoreFuture ...
[08:27:52.434] result() for MulticoreFuture ... done
[08:27:52.434] result() for MulticoreFuture ... done
[08:27:52.434] result() for MulticoreFuture ...
[08:27:52.434] result() for MulticoreFuture ... done
[08:27:52.434] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:52.435] - nx: 4
[08:27:52.435] - relay: TRUE
[08:27:52.435] - stdout: TRUE
[08:27:52.435] - signal: TRUE
[08:27:52.435] - resignal: FALSE
[08:27:52.435] - force: TRUE
[08:27:52.435] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.435] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.436]  - until=3
[08:27:52.436]  - relaying element #3
[08:27:52.436] result() for MulticoreFuture ...
[08:27:52.436] result() for MulticoreFuture ... done
[08:27:52.436] result() for MulticoreFuture ...
[08:27:52.436] result() for MulticoreFuture ... done
[08:27:52.436] result() for MulticoreFuture ...
[08:27:52.436] result() for MulticoreFuture ... done
[08:27:52.436] result() for MulticoreFuture ...
[08:27:52.437] result() for MulticoreFuture ... done
[08:27:52.437] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.437] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.437] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:52.437]  length: 1 (resolved future 3)
[08:27:52.437] Future #4
[08:27:52.438] result() for MulticoreFuture ...
[08:27:52.438] result() for MulticoreFuture ...
[08:27:52.438] result() for MulticoreFuture ... done
[08:27:52.439] result() for MulticoreFuture ... done
[08:27:52.439] result() for MulticoreFuture ...
[08:27:52.439] result() for MulticoreFuture ... done
[08:27:52.439] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:52.439] - nx: 4
[08:27:52.440] - relay: TRUE
[08:27:52.440] - stdout: TRUE
[08:27:52.440] - signal: TRUE
[08:27:52.440] - resignal: FALSE
[08:27:52.440] - force: TRUE
[08:27:52.440] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.440] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.441]  - until=4
[08:27:52.441]  - relaying element #4
[08:27:52.441] result() for MulticoreFuture ...
[08:27:52.441] result() for MulticoreFuture ... done
[08:27:52.441] result() for MulticoreFuture ...
[08:27:52.441] result() for MulticoreFuture ... done
[08:27:52.442] result() for MulticoreFuture ...
[08:27:52.442] result() for MulticoreFuture ... done
[08:27:52.442] result() for MulticoreFuture ...
[08:27:52.442] result() for MulticoreFuture ... done
[08:27:52.442] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.442] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.443] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:52.443]  length: 0 (resolved future 4)
[08:27:52.443] Relaying remaining futures
[08:27:52.443] signalConditionsASAP(NULL, pos=0) ...
[08:27:52.443] - nx: 4
[08:27:52.443] - relay: TRUE
[08:27:52.443] - stdout: TRUE
[08:27:52.443] - signal: TRUE
[08:27:52.443] - resignal: FALSE
[08:27:52.443] - force: TRUE
[08:27:52.443] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.444] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:52.444] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.444] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.444] signalConditionsASAP(NULL, pos=0) ... done
[08:27:52.444] resolve() on environment ... DONE
[08:27:52.444] result() for MulticoreFuture ...
[08:27:52.444] result() for MulticoreFuture ... done
[08:27:52.444] result() for MulticoreFuture ...
[08:27:52.444] result() for MulticoreFuture ... done
[08:27:52.445] result() for MulticoreFuture ...
[08:27:52.445] result() for MulticoreFuture ... done
[08:27:52.445] result() for MulticoreFuture ...
[08:27:52.445] result() for MulticoreFuture ... done
[08:27:52.445] result() for MulticoreFuture ...
[08:27:52.445] result() for MulticoreFuture ... done
[08:27:52.445] result() for MulticoreFuture ...
[08:27:52.445] result() for MulticoreFuture ... done
<environment: 0x55d8623496d8> 
Dimensions: c(1, 6)
[08:27:52.446] getGlobalsAndPackages() ...
[08:27:52.446] Searching for globals...
[08:27:52.446] 
[08:27:52.447] Searching for globals ... DONE
[08:27:52.447] - globals: [0] <none>
[08:27:52.447] getGlobalsAndPackages() ... DONE
[08:27:52.447] run() for ‘Future’ ...
[08:27:52.447] - state: ‘created’
[08:27:52.447] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.450] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.450] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.450]   - Field: ‘label’
[08:27:52.450]   - Field: ‘local’
[08:27:52.450]   - Field: ‘owner’
[08:27:52.450]   - Field: ‘envir’
[08:27:52.450]   - Field: ‘workers’
[08:27:52.451]   - Field: ‘packages’
[08:27:52.451]   - Field: ‘gc’
[08:27:52.451]   - Field: ‘job’
[08:27:52.451]   - Field: ‘conditions’
[08:27:52.451]   - Field: ‘expr’
[08:27:52.451]   - Field: ‘uuid’
[08:27:52.451]   - Field: ‘seed’
[08:27:52.451]   - Field: ‘version’
[08:27:52.451]   - Field: ‘result’
[08:27:52.451]   - Field: ‘asynchronous’
[08:27:52.452]   - Field: ‘calls’
[08:27:52.452]   - Field: ‘globals’
[08:27:52.452]   - Field: ‘stdout’
[08:27:52.452]   - Field: ‘earlySignal’
[08:27:52.452]   - Field: ‘lazy’
[08:27:52.452]   - Field: ‘state’
[08:27:52.452] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.452] - Launch lazy future ...
[08:27:52.453] Packages needed by the future expression (n = 0): <none>
[08:27:52.453] Packages needed by future strategies (n = 0): <none>
[08:27:52.453] {
[08:27:52.453]     {
[08:27:52.453]         {
[08:27:52.453]             ...future.startTime <- base::Sys.time()
[08:27:52.453]             {
[08:27:52.453]                 {
[08:27:52.453]                   {
[08:27:52.453]                     {
[08:27:52.453]                       base::local({
[08:27:52.453]                         has_future <- base::requireNamespace("future", 
[08:27:52.453]                           quietly = TRUE)
[08:27:52.453]                         if (has_future) {
[08:27:52.453]                           ns <- base::getNamespace("future")
[08:27:52.453]                           version <- ns[[".package"]][["version"]]
[08:27:52.453]                           if (is.null(version)) 
[08:27:52.453]                             version <- utils::packageVersion("future")
[08:27:52.453]                         }
[08:27:52.453]                         else {
[08:27:52.453]                           version <- NULL
[08:27:52.453]                         }
[08:27:52.453]                         if (!has_future || version < "1.8.0") {
[08:27:52.453]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.453]                             "", base::R.version$version.string), 
[08:27:52.453]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.453]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.453]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.453]                               "release", "version")], collapse = " "), 
[08:27:52.453]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.453]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.453]                             info)
[08:27:52.453]                           info <- base::paste(info, collapse = "; ")
[08:27:52.453]                           if (!has_future) {
[08:27:52.453]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.453]                               info)
[08:27:52.453]                           }
[08:27:52.453]                           else {
[08:27:52.453]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.453]                               info, version)
[08:27:52.453]                           }
[08:27:52.453]                           base::stop(msg)
[08:27:52.453]                         }
[08:27:52.453]                       })
[08:27:52.453]                     }
[08:27:52.453]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.453]                     base::options(mc.cores = 1L)
[08:27:52.453]                   }
[08:27:52.453]                   ...future.strategy.old <- future::plan("list")
[08:27:52.453]                   options(future.plan = NULL)
[08:27:52.453]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.453]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.453]                 }
[08:27:52.453]                 ...future.workdir <- getwd()
[08:27:52.453]             }
[08:27:52.453]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.453]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.453]         }
[08:27:52.453]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.453]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.453]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.453]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.453]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.453]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.453]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.453]             base::names(...future.oldOptions))
[08:27:52.453]     }
[08:27:52.453]     if (FALSE) {
[08:27:52.453]     }
[08:27:52.453]     else {
[08:27:52.453]         if (TRUE) {
[08:27:52.453]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.453]                 open = "w")
[08:27:52.453]         }
[08:27:52.453]         else {
[08:27:52.453]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.453]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.453]         }
[08:27:52.453]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.453]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.453]             base::sink(type = "output", split = FALSE)
[08:27:52.453]             base::close(...future.stdout)
[08:27:52.453]         }, add = TRUE)
[08:27:52.453]     }
[08:27:52.453]     ...future.frame <- base::sys.nframe()
[08:27:52.453]     ...future.conditions <- base::list()
[08:27:52.453]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.453]     if (FALSE) {
[08:27:52.453]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.453]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.453]     }
[08:27:52.453]     ...future.result <- base::tryCatch({
[08:27:52.453]         base::withCallingHandlers({
[08:27:52.453]             ...future.value <- base::withVisible(base::local({
[08:27:52.453]                 withCallingHandlers({
[08:27:52.453]                   2
[08:27:52.453]                 }, immediateCondition = function(cond) {
[08:27:52.453]                   save_rds <- function (object, pathname, ...) 
[08:27:52.453]                   {
[08:27:52.453]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.453]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.453]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.453]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.453]                         fi_tmp[["mtime"]])
[08:27:52.453]                     }
[08:27:52.453]                     tryCatch({
[08:27:52.453]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.453]                     }, error = function(ex) {
[08:27:52.453]                       msg <- conditionMessage(ex)
[08:27:52.453]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.453]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.453]                         fi_tmp[["mtime"]], msg)
[08:27:52.453]                       ex$message <- msg
[08:27:52.453]                       stop(ex)
[08:27:52.453]                     })
[08:27:52.453]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.453]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.453]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.453]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.453]                       fi <- file.info(pathname)
[08:27:52.453]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.453]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.453]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.453]                         fi[["size"]], fi[["mtime"]])
[08:27:52.453]                       stop(msg)
[08:27:52.453]                     }
[08:27:52.453]                     invisible(pathname)
[08:27:52.453]                   }
[08:27:52.453]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.453]                     rootPath = tempdir()) 
[08:27:52.453]                   {
[08:27:52.453]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.453]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.453]                       tmpdir = path, fileext = ".rds")
[08:27:52.453]                     save_rds(obj, file)
[08:27:52.453]                   }
[08:27:52.453]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.453]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.453]                   {
[08:27:52.453]                     inherits <- base::inherits
[08:27:52.453]                     invokeRestart <- base::invokeRestart
[08:27:52.453]                     is.null <- base::is.null
[08:27:52.453]                     muffled <- FALSE
[08:27:52.453]                     if (inherits(cond, "message")) {
[08:27:52.453]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.453]                       if (muffled) 
[08:27:52.453]                         invokeRestart("muffleMessage")
[08:27:52.453]                     }
[08:27:52.453]                     else if (inherits(cond, "warning")) {
[08:27:52.453]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.453]                       if (muffled) 
[08:27:52.453]                         invokeRestart("muffleWarning")
[08:27:52.453]                     }
[08:27:52.453]                     else if (inherits(cond, "condition")) {
[08:27:52.453]                       if (!is.null(pattern)) {
[08:27:52.453]                         computeRestarts <- base::computeRestarts
[08:27:52.453]                         grepl <- base::grepl
[08:27:52.453]                         restarts <- computeRestarts(cond)
[08:27:52.453]                         for (restart in restarts) {
[08:27:52.453]                           name <- restart$name
[08:27:52.453]                           if (is.null(name)) 
[08:27:52.453]                             next
[08:27:52.453]                           if (!grepl(pattern, name)) 
[08:27:52.453]                             next
[08:27:52.453]                           invokeRestart(restart)
[08:27:52.453]                           muffled <- TRUE
[08:27:52.453]                           break
[08:27:52.453]                         }
[08:27:52.453]                       }
[08:27:52.453]                     }
[08:27:52.453]                     invisible(muffled)
[08:27:52.453]                   }
[08:27:52.453]                   muffleCondition(cond)
[08:27:52.453]                 })
[08:27:52.453]             }))
[08:27:52.453]             future::FutureResult(value = ...future.value$value, 
[08:27:52.453]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.453]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.453]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.453]                     ...future.globalenv.names))
[08:27:52.453]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.453]         }, condition = base::local({
[08:27:52.453]             c <- base::c
[08:27:52.453]             inherits <- base::inherits
[08:27:52.453]             invokeRestart <- base::invokeRestart
[08:27:52.453]             length <- base::length
[08:27:52.453]             list <- base::list
[08:27:52.453]             seq.int <- base::seq.int
[08:27:52.453]             signalCondition <- base::signalCondition
[08:27:52.453]             sys.calls <- base::sys.calls
[08:27:52.453]             `[[` <- base::`[[`
[08:27:52.453]             `+` <- base::`+`
[08:27:52.453]             `<<-` <- base::`<<-`
[08:27:52.453]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.453]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.453]                   3L)]
[08:27:52.453]             }
[08:27:52.453]             function(cond) {
[08:27:52.453]                 is_error <- inherits(cond, "error")
[08:27:52.453]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.453]                   NULL)
[08:27:52.453]                 if (is_error) {
[08:27:52.453]                   sessionInformation <- function() {
[08:27:52.453]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.453]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.453]                       search = base::search(), system = base::Sys.info())
[08:27:52.453]                   }
[08:27:52.453]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.453]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.453]                     cond$call), session = sessionInformation(), 
[08:27:52.453]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.453]                   signalCondition(cond)
[08:27:52.453]                 }
[08:27:52.453]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.453]                 "immediateCondition"))) {
[08:27:52.453]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.453]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.453]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.453]                   if (TRUE && !signal) {
[08:27:52.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.453]                     {
[08:27:52.453]                       inherits <- base::inherits
[08:27:52.453]                       invokeRestart <- base::invokeRestart
[08:27:52.453]                       is.null <- base::is.null
[08:27:52.453]                       muffled <- FALSE
[08:27:52.453]                       if (inherits(cond, "message")) {
[08:27:52.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.453]                         if (muffled) 
[08:27:52.453]                           invokeRestart("muffleMessage")
[08:27:52.453]                       }
[08:27:52.453]                       else if (inherits(cond, "warning")) {
[08:27:52.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.453]                         if (muffled) 
[08:27:52.453]                           invokeRestart("muffleWarning")
[08:27:52.453]                       }
[08:27:52.453]                       else if (inherits(cond, "condition")) {
[08:27:52.453]                         if (!is.null(pattern)) {
[08:27:52.453]                           computeRestarts <- base::computeRestarts
[08:27:52.453]                           grepl <- base::grepl
[08:27:52.453]                           restarts <- computeRestarts(cond)
[08:27:52.453]                           for (restart in restarts) {
[08:27:52.453]                             name <- restart$name
[08:27:52.453]                             if (is.null(name)) 
[08:27:52.453]                               next
[08:27:52.453]                             if (!grepl(pattern, name)) 
[08:27:52.453]                               next
[08:27:52.453]                             invokeRestart(restart)
[08:27:52.453]                             muffled <- TRUE
[08:27:52.453]                             break
[08:27:52.453]                           }
[08:27:52.453]                         }
[08:27:52.453]                       }
[08:27:52.453]                       invisible(muffled)
[08:27:52.453]                     }
[08:27:52.453]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.453]                   }
[08:27:52.453]                 }
[08:27:52.453]                 else {
[08:27:52.453]                   if (TRUE) {
[08:27:52.453]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.453]                     {
[08:27:52.453]                       inherits <- base::inherits
[08:27:52.453]                       invokeRestart <- base::invokeRestart
[08:27:52.453]                       is.null <- base::is.null
[08:27:52.453]                       muffled <- FALSE
[08:27:52.453]                       if (inherits(cond, "message")) {
[08:27:52.453]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.453]                         if (muffled) 
[08:27:52.453]                           invokeRestart("muffleMessage")
[08:27:52.453]                       }
[08:27:52.453]                       else if (inherits(cond, "warning")) {
[08:27:52.453]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.453]                         if (muffled) 
[08:27:52.453]                           invokeRestart("muffleWarning")
[08:27:52.453]                       }
[08:27:52.453]                       else if (inherits(cond, "condition")) {
[08:27:52.453]                         if (!is.null(pattern)) {
[08:27:52.453]                           computeRestarts <- base::computeRestarts
[08:27:52.453]                           grepl <- base::grepl
[08:27:52.453]                           restarts <- computeRestarts(cond)
[08:27:52.453]                           for (restart in restarts) {
[08:27:52.453]                             name <- restart$name
[08:27:52.453]                             if (is.null(name)) 
[08:27:52.453]                               next
[08:27:52.453]                             if (!grepl(pattern, name)) 
[08:27:52.453]                               next
[08:27:52.453]                             invokeRestart(restart)
[08:27:52.453]                             muffled <- TRUE
[08:27:52.453]                             break
[08:27:52.453]                           }
[08:27:52.453]                         }
[08:27:52.453]                       }
[08:27:52.453]                       invisible(muffled)
[08:27:52.453]                     }
[08:27:52.453]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.453]                   }
[08:27:52.453]                 }
[08:27:52.453]             }
[08:27:52.453]         }))
[08:27:52.453]     }, error = function(ex) {
[08:27:52.453]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.453]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.453]                 ...future.rng), started = ...future.startTime, 
[08:27:52.453]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.453]             version = "1.8"), class = "FutureResult")
[08:27:52.453]     }, finally = {
[08:27:52.453]         if (!identical(...future.workdir, getwd())) 
[08:27:52.453]             setwd(...future.workdir)
[08:27:52.453]         {
[08:27:52.453]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.453]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.453]             }
[08:27:52.453]             base::options(...future.oldOptions)
[08:27:52.453]             if (.Platform$OS.type == "windows") {
[08:27:52.453]                 old_names <- names(...future.oldEnvVars)
[08:27:52.453]                 envs <- base::Sys.getenv()
[08:27:52.453]                 names <- names(envs)
[08:27:52.453]                 common <- intersect(names, old_names)
[08:27:52.453]                 added <- setdiff(names, old_names)
[08:27:52.453]                 removed <- setdiff(old_names, names)
[08:27:52.453]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.453]                   envs[common]]
[08:27:52.453]                 NAMES <- toupper(changed)
[08:27:52.453]                 args <- list()
[08:27:52.453]                 for (kk in seq_along(NAMES)) {
[08:27:52.453]                   name <- changed[[kk]]
[08:27:52.453]                   NAME <- NAMES[[kk]]
[08:27:52.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.453]                     next
[08:27:52.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.453]                 }
[08:27:52.453]                 NAMES <- toupper(added)
[08:27:52.453]                 for (kk in seq_along(NAMES)) {
[08:27:52.453]                   name <- added[[kk]]
[08:27:52.453]                   NAME <- NAMES[[kk]]
[08:27:52.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.453]                     next
[08:27:52.453]                   args[[name]] <- ""
[08:27:52.453]                 }
[08:27:52.453]                 NAMES <- toupper(removed)
[08:27:52.453]                 for (kk in seq_along(NAMES)) {
[08:27:52.453]                   name <- removed[[kk]]
[08:27:52.453]                   NAME <- NAMES[[kk]]
[08:27:52.453]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.453]                     next
[08:27:52.453]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.453]                 }
[08:27:52.453]                 if (length(args) > 0) 
[08:27:52.453]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.453]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.453]             }
[08:27:52.453]             else {
[08:27:52.453]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.453]             }
[08:27:52.453]             {
[08:27:52.453]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.453]                   0L) {
[08:27:52.453]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.453]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.453]                   base::options(opts)
[08:27:52.453]                 }
[08:27:52.453]                 {
[08:27:52.453]                   {
[08:27:52.453]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.453]                     NULL
[08:27:52.453]                   }
[08:27:52.453]                   options(future.plan = NULL)
[08:27:52.453]                   if (is.na(NA_character_)) 
[08:27:52.453]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.453]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.453]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.453]                     .init = FALSE)
[08:27:52.453]                 }
[08:27:52.453]             }
[08:27:52.453]         }
[08:27:52.453]     })
[08:27:52.453]     if (TRUE) {
[08:27:52.453]         base::sink(type = "output", split = FALSE)
[08:27:52.453]         if (TRUE) {
[08:27:52.453]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.453]         }
[08:27:52.453]         else {
[08:27:52.453]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.453]         }
[08:27:52.453]         base::close(...future.stdout)
[08:27:52.453]         ...future.stdout <- NULL
[08:27:52.453]     }
[08:27:52.453]     ...future.result$conditions <- ...future.conditions
[08:27:52.453]     ...future.result$finished <- base::Sys.time()
[08:27:52.453]     ...future.result
[08:27:52.453] }
[08:27:52.456] requestCore(): workers = 2
[08:27:52.459] MulticoreFuture started
[08:27:52.459] - Launch lazy future ... done
[08:27:52.459] run() for ‘MulticoreFuture’ ... done
[08:27:52.459] getGlobalsAndPackages() ...
[08:27:52.460] Searching for globals...
[08:27:52.460] plan(): Setting new future strategy stack:
[08:27:52.460] 
[08:27:52.461] Searching for globals ... DONE
[08:27:52.460] List of future strategies:
[08:27:52.460] 1. sequential:
[08:27:52.460]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.460]    - tweaked: FALSE
[08:27:52.460]    - call: NULL
[08:27:52.461] - globals: [0] <none>
[08:27:52.461] getGlobalsAndPackages() ... DONE
[08:27:52.461] plan(): nbrOfWorkers() = 1
[08:27:52.461] run() for ‘Future’ ...
[08:27:52.461] - state: ‘created’
[08:27:52.462] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.463] plan(): Setting new future strategy stack:
[08:27:52.463] List of future strategies:
[08:27:52.463] 1. multicore:
[08:27:52.463]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.463]    - tweaked: FALSE
[08:27:52.463]    - call: plan(strategy)
[08:27:52.465] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.465] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.465] plan(): nbrOfWorkers() = 2
[08:27:52.465]   - Field: ‘label’
[08:27:52.466]   - Field: ‘local’
[08:27:52.466]   - Field: ‘owner’
[08:27:52.466]   - Field: ‘envir’
[08:27:52.466]   - Field: ‘workers’
[08:27:52.466]   - Field: ‘packages’
[08:27:52.466]   - Field: ‘gc’
[08:27:52.466]   - Field: ‘job’
[08:27:52.466]   - Field: ‘conditions’
[08:27:52.467]   - Field: ‘expr’
[08:27:52.467]   - Field: ‘uuid’
[08:27:52.467]   - Field: ‘seed’
[08:27:52.467]   - Field: ‘version’
[08:27:52.467]   - Field: ‘result’
[08:27:52.467]   - Field: ‘asynchronous’
[08:27:52.467]   - Field: ‘calls’
[08:27:52.467]   - Field: ‘globals’
[08:27:52.468]   - Field: ‘stdout’
[08:27:52.468]   - Field: ‘earlySignal’
[08:27:52.468]   - Field: ‘lazy’
[08:27:52.468]   - Field: ‘state’
[08:27:52.468] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.468] - Launch lazy future ...
[08:27:52.469] Packages needed by the future expression (n = 0): <none>
[08:27:52.469] Packages needed by future strategies (n = 0): <none>
[08:27:52.470] {
[08:27:52.470]     {
[08:27:52.470]         {
[08:27:52.470]             ...future.startTime <- base::Sys.time()
[08:27:52.470]             {
[08:27:52.470]                 {
[08:27:52.470]                   {
[08:27:52.470]                     {
[08:27:52.470]                       base::local({
[08:27:52.470]                         has_future <- base::requireNamespace("future", 
[08:27:52.470]                           quietly = TRUE)
[08:27:52.470]                         if (has_future) {
[08:27:52.470]                           ns <- base::getNamespace("future")
[08:27:52.470]                           version <- ns[[".package"]][["version"]]
[08:27:52.470]                           if (is.null(version)) 
[08:27:52.470]                             version <- utils::packageVersion("future")
[08:27:52.470]                         }
[08:27:52.470]                         else {
[08:27:52.470]                           version <- NULL
[08:27:52.470]                         }
[08:27:52.470]                         if (!has_future || version < "1.8.0") {
[08:27:52.470]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.470]                             "", base::R.version$version.string), 
[08:27:52.470]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.470]                               "release", "version")], collapse = " "), 
[08:27:52.470]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.470]                             info)
[08:27:52.470]                           info <- base::paste(info, collapse = "; ")
[08:27:52.470]                           if (!has_future) {
[08:27:52.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.470]                               info)
[08:27:52.470]                           }
[08:27:52.470]                           else {
[08:27:52.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.470]                               info, version)
[08:27:52.470]                           }
[08:27:52.470]                           base::stop(msg)
[08:27:52.470]                         }
[08:27:52.470]                       })
[08:27:52.470]                     }
[08:27:52.470]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.470]                     base::options(mc.cores = 1L)
[08:27:52.470]                   }
[08:27:52.470]                   ...future.strategy.old <- future::plan("list")
[08:27:52.470]                   options(future.plan = NULL)
[08:27:52.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.470]                 }
[08:27:52.470]                 ...future.workdir <- getwd()
[08:27:52.470]             }
[08:27:52.470]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.470]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.470]         }
[08:27:52.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.470]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.470]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.470]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.470]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.470]             base::names(...future.oldOptions))
[08:27:52.470]     }
[08:27:52.470]     if (FALSE) {
[08:27:52.470]     }
[08:27:52.470]     else {
[08:27:52.470]         if (TRUE) {
[08:27:52.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.470]                 open = "w")
[08:27:52.470]         }
[08:27:52.470]         else {
[08:27:52.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.470]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.470]         }
[08:27:52.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.470]             base::sink(type = "output", split = FALSE)
[08:27:52.470]             base::close(...future.stdout)
[08:27:52.470]         }, add = TRUE)
[08:27:52.470]     }
[08:27:52.470]     ...future.frame <- base::sys.nframe()
[08:27:52.470]     ...future.conditions <- base::list()
[08:27:52.470]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.470]     if (FALSE) {
[08:27:52.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.470]     }
[08:27:52.470]     ...future.result <- base::tryCatch({
[08:27:52.470]         base::withCallingHandlers({
[08:27:52.470]             ...future.value <- base::withVisible(base::local({
[08:27:52.470]                 withCallingHandlers({
[08:27:52.470]                   NULL
[08:27:52.470]                 }, immediateCondition = function(cond) {
[08:27:52.470]                   save_rds <- function (object, pathname, ...) 
[08:27:52.470]                   {
[08:27:52.470]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.470]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.470]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.470]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.470]                         fi_tmp[["mtime"]])
[08:27:52.470]                     }
[08:27:52.470]                     tryCatch({
[08:27:52.470]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.470]                     }, error = function(ex) {
[08:27:52.470]                       msg <- conditionMessage(ex)
[08:27:52.470]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.470]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.470]                         fi_tmp[["mtime"]], msg)
[08:27:52.470]                       ex$message <- msg
[08:27:52.470]                       stop(ex)
[08:27:52.470]                     })
[08:27:52.470]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.470]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.470]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.470]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.470]                       fi <- file.info(pathname)
[08:27:52.470]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.470]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.470]                         fi[["size"]], fi[["mtime"]])
[08:27:52.470]                       stop(msg)
[08:27:52.470]                     }
[08:27:52.470]                     invisible(pathname)
[08:27:52.470]                   }
[08:27:52.470]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.470]                     rootPath = tempdir()) 
[08:27:52.470]                   {
[08:27:52.470]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.470]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.470]                       tmpdir = path, fileext = ".rds")
[08:27:52.470]                     save_rds(obj, file)
[08:27:52.470]                   }
[08:27:52.470]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.470]                   {
[08:27:52.470]                     inherits <- base::inherits
[08:27:52.470]                     invokeRestart <- base::invokeRestart
[08:27:52.470]                     is.null <- base::is.null
[08:27:52.470]                     muffled <- FALSE
[08:27:52.470]                     if (inherits(cond, "message")) {
[08:27:52.470]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.470]                       if (muffled) 
[08:27:52.470]                         invokeRestart("muffleMessage")
[08:27:52.470]                     }
[08:27:52.470]                     else if (inherits(cond, "warning")) {
[08:27:52.470]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.470]                       if (muffled) 
[08:27:52.470]                         invokeRestart("muffleWarning")
[08:27:52.470]                     }
[08:27:52.470]                     else if (inherits(cond, "condition")) {
[08:27:52.470]                       if (!is.null(pattern)) {
[08:27:52.470]                         computeRestarts <- base::computeRestarts
[08:27:52.470]                         grepl <- base::grepl
[08:27:52.470]                         restarts <- computeRestarts(cond)
[08:27:52.470]                         for (restart in restarts) {
[08:27:52.470]                           name <- restart$name
[08:27:52.470]                           if (is.null(name)) 
[08:27:52.470]                             next
[08:27:52.470]                           if (!grepl(pattern, name)) 
[08:27:52.470]                             next
[08:27:52.470]                           invokeRestart(restart)
[08:27:52.470]                           muffled <- TRUE
[08:27:52.470]                           break
[08:27:52.470]                         }
[08:27:52.470]                       }
[08:27:52.470]                     }
[08:27:52.470]                     invisible(muffled)
[08:27:52.470]                   }
[08:27:52.470]                   muffleCondition(cond)
[08:27:52.470]                 })
[08:27:52.470]             }))
[08:27:52.470]             future::FutureResult(value = ...future.value$value, 
[08:27:52.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.470]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.470]                     ...future.globalenv.names))
[08:27:52.470]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.470]         }, condition = base::local({
[08:27:52.470]             c <- base::c
[08:27:52.470]             inherits <- base::inherits
[08:27:52.470]             invokeRestart <- base::invokeRestart
[08:27:52.470]             length <- base::length
[08:27:52.470]             list <- base::list
[08:27:52.470]             seq.int <- base::seq.int
[08:27:52.470]             signalCondition <- base::signalCondition
[08:27:52.470]             sys.calls <- base::sys.calls
[08:27:52.470]             `[[` <- base::`[[`
[08:27:52.470]             `+` <- base::`+`
[08:27:52.470]             `<<-` <- base::`<<-`
[08:27:52.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.470]                   3L)]
[08:27:52.470]             }
[08:27:52.470]             function(cond) {
[08:27:52.470]                 is_error <- inherits(cond, "error")
[08:27:52.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.470]                   NULL)
[08:27:52.470]                 if (is_error) {
[08:27:52.470]                   sessionInformation <- function() {
[08:27:52.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.470]                       search = base::search(), system = base::Sys.info())
[08:27:52.470]                   }
[08:27:52.470]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.470]                     cond$call), session = sessionInformation(), 
[08:27:52.470]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.470]                   signalCondition(cond)
[08:27:52.470]                 }
[08:27:52.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.470]                 "immediateCondition"))) {
[08:27:52.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.470]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.470]                   if (TRUE && !signal) {
[08:27:52.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.470]                     {
[08:27:52.470]                       inherits <- base::inherits
[08:27:52.470]                       invokeRestart <- base::invokeRestart
[08:27:52.470]                       is.null <- base::is.null
[08:27:52.470]                       muffled <- FALSE
[08:27:52.470]                       if (inherits(cond, "message")) {
[08:27:52.470]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.470]                         if (muffled) 
[08:27:52.470]                           invokeRestart("muffleMessage")
[08:27:52.470]                       }
[08:27:52.470]                       else if (inherits(cond, "warning")) {
[08:27:52.470]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.470]                         if (muffled) 
[08:27:52.470]                           invokeRestart("muffleWarning")
[08:27:52.470]                       }
[08:27:52.470]                       else if (inherits(cond, "condition")) {
[08:27:52.470]                         if (!is.null(pattern)) {
[08:27:52.470]                           computeRestarts <- base::computeRestarts
[08:27:52.470]                           grepl <- base::grepl
[08:27:52.470]                           restarts <- computeRestarts(cond)
[08:27:52.470]                           for (restart in restarts) {
[08:27:52.470]                             name <- restart$name
[08:27:52.470]                             if (is.null(name)) 
[08:27:52.470]                               next
[08:27:52.470]                             if (!grepl(pattern, name)) 
[08:27:52.470]                               next
[08:27:52.470]                             invokeRestart(restart)
[08:27:52.470]                             muffled <- TRUE
[08:27:52.470]                             break
[08:27:52.470]                           }
[08:27:52.470]                         }
[08:27:52.470]                       }
[08:27:52.470]                       invisible(muffled)
[08:27:52.470]                     }
[08:27:52.470]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.470]                   }
[08:27:52.470]                 }
[08:27:52.470]                 else {
[08:27:52.470]                   if (TRUE) {
[08:27:52.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.470]                     {
[08:27:52.470]                       inherits <- base::inherits
[08:27:52.470]                       invokeRestart <- base::invokeRestart
[08:27:52.470]                       is.null <- base::is.null
[08:27:52.470]                       muffled <- FALSE
[08:27:52.470]                       if (inherits(cond, "message")) {
[08:27:52.470]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.470]                         if (muffled) 
[08:27:52.470]                           invokeRestart("muffleMessage")
[08:27:52.470]                       }
[08:27:52.470]                       else if (inherits(cond, "warning")) {
[08:27:52.470]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.470]                         if (muffled) 
[08:27:52.470]                           invokeRestart("muffleWarning")
[08:27:52.470]                       }
[08:27:52.470]                       else if (inherits(cond, "condition")) {
[08:27:52.470]                         if (!is.null(pattern)) {
[08:27:52.470]                           computeRestarts <- base::computeRestarts
[08:27:52.470]                           grepl <- base::grepl
[08:27:52.470]                           restarts <- computeRestarts(cond)
[08:27:52.470]                           for (restart in restarts) {
[08:27:52.470]                             name <- restart$name
[08:27:52.470]                             if (is.null(name)) 
[08:27:52.470]                               next
[08:27:52.470]                             if (!grepl(pattern, name)) 
[08:27:52.470]                               next
[08:27:52.470]                             invokeRestart(restart)
[08:27:52.470]                             muffled <- TRUE
[08:27:52.470]                             break
[08:27:52.470]                           }
[08:27:52.470]                         }
[08:27:52.470]                       }
[08:27:52.470]                       invisible(muffled)
[08:27:52.470]                     }
[08:27:52.470]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.470]                   }
[08:27:52.470]                 }
[08:27:52.470]             }
[08:27:52.470]         }))
[08:27:52.470]     }, error = function(ex) {
[08:27:52.470]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.470]                 ...future.rng), started = ...future.startTime, 
[08:27:52.470]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.470]             version = "1.8"), class = "FutureResult")
[08:27:52.470]     }, finally = {
[08:27:52.470]         if (!identical(...future.workdir, getwd())) 
[08:27:52.470]             setwd(...future.workdir)
[08:27:52.470]         {
[08:27:52.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.470]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.470]             }
[08:27:52.470]             base::options(...future.oldOptions)
[08:27:52.470]             if (.Platform$OS.type == "windows") {
[08:27:52.470]                 old_names <- names(...future.oldEnvVars)
[08:27:52.470]                 envs <- base::Sys.getenv()
[08:27:52.470]                 names <- names(envs)
[08:27:52.470]                 common <- intersect(names, old_names)
[08:27:52.470]                 added <- setdiff(names, old_names)
[08:27:52.470]                 removed <- setdiff(old_names, names)
[08:27:52.470]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.470]                   envs[common]]
[08:27:52.470]                 NAMES <- toupper(changed)
[08:27:52.470]                 args <- list()
[08:27:52.470]                 for (kk in seq_along(NAMES)) {
[08:27:52.470]                   name <- changed[[kk]]
[08:27:52.470]                   NAME <- NAMES[[kk]]
[08:27:52.470]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.470]                     next
[08:27:52.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.470]                 }
[08:27:52.470]                 NAMES <- toupper(added)
[08:27:52.470]                 for (kk in seq_along(NAMES)) {
[08:27:52.470]                   name <- added[[kk]]
[08:27:52.470]                   NAME <- NAMES[[kk]]
[08:27:52.470]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.470]                     next
[08:27:52.470]                   args[[name]] <- ""
[08:27:52.470]                 }
[08:27:52.470]                 NAMES <- toupper(removed)
[08:27:52.470]                 for (kk in seq_along(NAMES)) {
[08:27:52.470]                   name <- removed[[kk]]
[08:27:52.470]                   NAME <- NAMES[[kk]]
[08:27:52.470]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.470]                     next
[08:27:52.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.470]                 }
[08:27:52.470]                 if (length(args) > 0) 
[08:27:52.470]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.470]             }
[08:27:52.470]             else {
[08:27:52.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.470]             }
[08:27:52.470]             {
[08:27:52.470]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.470]                   0L) {
[08:27:52.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.470]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.470]                   base::options(opts)
[08:27:52.470]                 }
[08:27:52.470]                 {
[08:27:52.470]                   {
[08:27:52.470]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.470]                     NULL
[08:27:52.470]                   }
[08:27:52.470]                   options(future.plan = NULL)
[08:27:52.470]                   if (is.na(NA_character_)) 
[08:27:52.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.470]                     .init = FALSE)
[08:27:52.470]                 }
[08:27:52.470]             }
[08:27:52.470]         }
[08:27:52.470]     })
[08:27:52.470]     if (TRUE) {
[08:27:52.470]         base::sink(type = "output", split = FALSE)
[08:27:52.470]         if (TRUE) {
[08:27:52.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.470]         }
[08:27:52.470]         else {
[08:27:52.470]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.470]         }
[08:27:52.470]         base::close(...future.stdout)
[08:27:52.470]         ...future.stdout <- NULL
[08:27:52.470]     }
[08:27:52.470]     ...future.result$conditions <- ...future.conditions
[08:27:52.470]     ...future.result$finished <- base::Sys.time()
[08:27:52.470]     ...future.result
[08:27:52.470] }
[08:27:52.473] requestCore(): workers = 2
[08:27:52.476] MulticoreFuture started
[08:27:52.476] - Launch lazy future ... done
[08:27:52.476] run() for ‘MulticoreFuture’ ... done
[08:27:52.477] plan(): Setting new future strategy stack:
[08:27:52.477] getGlobalsAndPackages() ...
[08:27:52.478] Searching for globals...
[08:27:52.477] List of future strategies:
[08:27:52.477] 1. sequential:
[08:27:52.477]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.477]    - tweaked: FALSE
[08:27:52.477]    - call: NULL
[08:27:52.478] plan(): nbrOfWorkers() = 1
[08:27:52.479] - globals found: [1] ‘{’
[08:27:52.479] Searching for globals ... DONE
[08:27:52.479] Resolving globals: FALSE
[08:27:52.480] 
[08:27:52.480] 
[08:27:52.480] getGlobalsAndPackages() ... DONE
[08:27:52.480] plan(): Setting new future strategy stack:
[08:27:52.480] run() for ‘Future’ ...
[08:27:52.481] - state: ‘created’
[08:27:52.480] List of future strategies:
[08:27:52.480] 1. multicore:
[08:27:52.480]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.480]    - tweaked: FALSE
[08:27:52.480]    - call: plan(strategy)
[08:27:52.481] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.483] plan(): nbrOfWorkers() = 2
[08:27:52.484] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.484] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.484]   - Field: ‘label’
[08:27:52.484]   - Field: ‘local’
[08:27:52.484]   - Field: ‘owner’
[08:27:52.484]   - Field: ‘envir’
[08:27:52.485]   - Field: ‘workers’
[08:27:52.485]   - Field: ‘packages’
[08:27:52.485]   - Field: ‘gc’
[08:27:52.485]   - Field: ‘job’
[08:27:52.485]   - Field: ‘conditions’
[08:27:52.485]   - Field: ‘expr’
[08:27:52.485]   - Field: ‘uuid’
[08:27:52.485]   - Field: ‘seed’
[08:27:52.486]   - Field: ‘version’
[08:27:52.486]   - Field: ‘result’
[08:27:52.486]   - Field: ‘asynchronous’
[08:27:52.486]   - Field: ‘calls’
[08:27:52.486]   - Field: ‘globals’
[08:27:52.486]   - Field: ‘stdout’
[08:27:52.486]   - Field: ‘earlySignal’
[08:27:52.486]   - Field: ‘lazy’
[08:27:52.487]   - Field: ‘state’
[08:27:52.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.487] - Launch lazy future ...
[08:27:52.487] Packages needed by the future expression (n = 0): <none>
[08:27:52.487] Packages needed by future strategies (n = 0): <none>
[08:27:52.495] {
[08:27:52.495]     {
[08:27:52.495]         {
[08:27:52.495]             ...future.startTime <- base::Sys.time()
[08:27:52.495]             {
[08:27:52.495]                 {
[08:27:52.495]                   {
[08:27:52.495]                     {
[08:27:52.495]                       base::local({
[08:27:52.495]                         has_future <- base::requireNamespace("future", 
[08:27:52.495]                           quietly = TRUE)
[08:27:52.495]                         if (has_future) {
[08:27:52.495]                           ns <- base::getNamespace("future")
[08:27:52.495]                           version <- ns[[".package"]][["version"]]
[08:27:52.495]                           if (is.null(version)) 
[08:27:52.495]                             version <- utils::packageVersion("future")
[08:27:52.495]                         }
[08:27:52.495]                         else {
[08:27:52.495]                           version <- NULL
[08:27:52.495]                         }
[08:27:52.495]                         if (!has_future || version < "1.8.0") {
[08:27:52.495]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.495]                             "", base::R.version$version.string), 
[08:27:52.495]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.495]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.495]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.495]                               "release", "version")], collapse = " "), 
[08:27:52.495]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.495]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.495]                             info)
[08:27:52.495]                           info <- base::paste(info, collapse = "; ")
[08:27:52.495]                           if (!has_future) {
[08:27:52.495]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.495]                               info)
[08:27:52.495]                           }
[08:27:52.495]                           else {
[08:27:52.495]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.495]                               info, version)
[08:27:52.495]                           }
[08:27:52.495]                           base::stop(msg)
[08:27:52.495]                         }
[08:27:52.495]                       })
[08:27:52.495]                     }
[08:27:52.495]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.495]                     base::options(mc.cores = 1L)
[08:27:52.495]                   }
[08:27:52.495]                   ...future.strategy.old <- future::plan("list")
[08:27:52.495]                   options(future.plan = NULL)
[08:27:52.495]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.495]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.495]                 }
[08:27:52.495]                 ...future.workdir <- getwd()
[08:27:52.495]             }
[08:27:52.495]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.495]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.495]         }
[08:27:52.495]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.495]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.495]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.495]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.495]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.495]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.495]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.495]             base::names(...future.oldOptions))
[08:27:52.495]     }
[08:27:52.495]     if (FALSE) {
[08:27:52.495]     }
[08:27:52.495]     else {
[08:27:52.495]         if (TRUE) {
[08:27:52.495]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.495]                 open = "w")
[08:27:52.495]         }
[08:27:52.495]         else {
[08:27:52.495]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.495]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.495]         }
[08:27:52.495]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.495]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.495]             base::sink(type = "output", split = FALSE)
[08:27:52.495]             base::close(...future.stdout)
[08:27:52.495]         }, add = TRUE)
[08:27:52.495]     }
[08:27:52.495]     ...future.frame <- base::sys.nframe()
[08:27:52.495]     ...future.conditions <- base::list()
[08:27:52.495]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.495]     if (FALSE) {
[08:27:52.495]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.495]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.495]     }
[08:27:52.495]     ...future.result <- base::tryCatch({
[08:27:52.495]         base::withCallingHandlers({
[08:27:52.495]             ...future.value <- base::withVisible(base::local({
[08:27:52.495]                 withCallingHandlers({
[08:27:52.495]                   {
[08:27:52.495]                     4
[08:27:52.495]                   }
[08:27:52.495]                 }, immediateCondition = function(cond) {
[08:27:52.495]                   save_rds <- function (object, pathname, ...) 
[08:27:52.495]                   {
[08:27:52.495]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.495]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.495]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.495]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.495]                         fi_tmp[["mtime"]])
[08:27:52.495]                     }
[08:27:52.495]                     tryCatch({
[08:27:52.495]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.495]                     }, error = function(ex) {
[08:27:52.495]                       msg <- conditionMessage(ex)
[08:27:52.495]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.495]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.495]                         fi_tmp[["mtime"]], msg)
[08:27:52.495]                       ex$message <- msg
[08:27:52.495]                       stop(ex)
[08:27:52.495]                     })
[08:27:52.495]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.495]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.495]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.495]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.495]                       fi <- file.info(pathname)
[08:27:52.495]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.495]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.495]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.495]                         fi[["size"]], fi[["mtime"]])
[08:27:52.495]                       stop(msg)
[08:27:52.495]                     }
[08:27:52.495]                     invisible(pathname)
[08:27:52.495]                   }
[08:27:52.495]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.495]                     rootPath = tempdir()) 
[08:27:52.495]                   {
[08:27:52.495]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.495]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.495]                       tmpdir = path, fileext = ".rds")
[08:27:52.495]                     save_rds(obj, file)
[08:27:52.495]                   }
[08:27:52.495]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.495]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.495]                   {
[08:27:52.495]                     inherits <- base::inherits
[08:27:52.495]                     invokeRestart <- base::invokeRestart
[08:27:52.495]                     is.null <- base::is.null
[08:27:52.495]                     muffled <- FALSE
[08:27:52.495]                     if (inherits(cond, "message")) {
[08:27:52.495]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.495]                       if (muffled) 
[08:27:52.495]                         invokeRestart("muffleMessage")
[08:27:52.495]                     }
[08:27:52.495]                     else if (inherits(cond, "warning")) {
[08:27:52.495]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.495]                       if (muffled) 
[08:27:52.495]                         invokeRestart("muffleWarning")
[08:27:52.495]                     }
[08:27:52.495]                     else if (inherits(cond, "condition")) {
[08:27:52.495]                       if (!is.null(pattern)) {
[08:27:52.495]                         computeRestarts <- base::computeRestarts
[08:27:52.495]                         grepl <- base::grepl
[08:27:52.495]                         restarts <- computeRestarts(cond)
[08:27:52.495]                         for (restart in restarts) {
[08:27:52.495]                           name <- restart$name
[08:27:52.495]                           if (is.null(name)) 
[08:27:52.495]                             next
[08:27:52.495]                           if (!grepl(pattern, name)) 
[08:27:52.495]                             next
[08:27:52.495]                           invokeRestart(restart)
[08:27:52.495]                           muffled <- TRUE
[08:27:52.495]                           break
[08:27:52.495]                         }
[08:27:52.495]                       }
[08:27:52.495]                     }
[08:27:52.495]                     invisible(muffled)
[08:27:52.495]                   }
[08:27:52.495]                   muffleCondition(cond)
[08:27:52.495]                 })
[08:27:52.495]             }))
[08:27:52.495]             future::FutureResult(value = ...future.value$value, 
[08:27:52.495]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.495]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.495]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.495]                     ...future.globalenv.names))
[08:27:52.495]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.495]         }, condition = base::local({
[08:27:52.495]             c <- base::c
[08:27:52.495]             inherits <- base::inherits
[08:27:52.495]             invokeRestart <- base::invokeRestart
[08:27:52.495]             length <- base::length
[08:27:52.495]             list <- base::list
[08:27:52.495]             seq.int <- base::seq.int
[08:27:52.495]             signalCondition <- base::signalCondition
[08:27:52.495]             sys.calls <- base::sys.calls
[08:27:52.495]             `[[` <- base::`[[`
[08:27:52.495]             `+` <- base::`+`
[08:27:52.495]             `<<-` <- base::`<<-`
[08:27:52.495]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.495]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.495]                   3L)]
[08:27:52.495]             }
[08:27:52.495]             function(cond) {
[08:27:52.495]                 is_error <- inherits(cond, "error")
[08:27:52.495]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.495]                   NULL)
[08:27:52.495]                 if (is_error) {
[08:27:52.495]                   sessionInformation <- function() {
[08:27:52.495]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.495]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.495]                       search = base::search(), system = base::Sys.info())
[08:27:52.495]                   }
[08:27:52.495]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.495]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.495]                     cond$call), session = sessionInformation(), 
[08:27:52.495]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.495]                   signalCondition(cond)
[08:27:52.495]                 }
[08:27:52.495]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.495]                 "immediateCondition"))) {
[08:27:52.495]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.495]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.495]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.495]                   if (TRUE && !signal) {
[08:27:52.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.495]                     {
[08:27:52.495]                       inherits <- base::inherits
[08:27:52.495]                       invokeRestart <- base::invokeRestart
[08:27:52.495]                       is.null <- base::is.null
[08:27:52.495]                       muffled <- FALSE
[08:27:52.495]                       if (inherits(cond, "message")) {
[08:27:52.495]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.495]                         if (muffled) 
[08:27:52.495]                           invokeRestart("muffleMessage")
[08:27:52.495]                       }
[08:27:52.495]                       else if (inherits(cond, "warning")) {
[08:27:52.495]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.495]                         if (muffled) 
[08:27:52.495]                           invokeRestart("muffleWarning")
[08:27:52.495]                       }
[08:27:52.495]                       else if (inherits(cond, "condition")) {
[08:27:52.495]                         if (!is.null(pattern)) {
[08:27:52.495]                           computeRestarts <- base::computeRestarts
[08:27:52.495]                           grepl <- base::grepl
[08:27:52.495]                           restarts <- computeRestarts(cond)
[08:27:52.495]                           for (restart in restarts) {
[08:27:52.495]                             name <- restart$name
[08:27:52.495]                             if (is.null(name)) 
[08:27:52.495]                               next
[08:27:52.495]                             if (!grepl(pattern, name)) 
[08:27:52.495]                               next
[08:27:52.495]                             invokeRestart(restart)
[08:27:52.495]                             muffled <- TRUE
[08:27:52.495]                             break
[08:27:52.495]                           }
[08:27:52.495]                         }
[08:27:52.495]                       }
[08:27:52.495]                       invisible(muffled)
[08:27:52.495]                     }
[08:27:52.495]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.495]                   }
[08:27:52.495]                 }
[08:27:52.495]                 else {
[08:27:52.495]                   if (TRUE) {
[08:27:52.495]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.495]                     {
[08:27:52.495]                       inherits <- base::inherits
[08:27:52.495]                       invokeRestart <- base::invokeRestart
[08:27:52.495]                       is.null <- base::is.null
[08:27:52.495]                       muffled <- FALSE
[08:27:52.495]                       if (inherits(cond, "message")) {
[08:27:52.495]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.495]                         if (muffled) 
[08:27:52.495]                           invokeRestart("muffleMessage")
[08:27:52.495]                       }
[08:27:52.495]                       else if (inherits(cond, "warning")) {
[08:27:52.495]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.495]                         if (muffled) 
[08:27:52.495]                           invokeRestart("muffleWarning")
[08:27:52.495]                       }
[08:27:52.495]                       else if (inherits(cond, "condition")) {
[08:27:52.495]                         if (!is.null(pattern)) {
[08:27:52.495]                           computeRestarts <- base::computeRestarts
[08:27:52.495]                           grepl <- base::grepl
[08:27:52.495]                           restarts <- computeRestarts(cond)
[08:27:52.495]                           for (restart in restarts) {
[08:27:52.495]                             name <- restart$name
[08:27:52.495]                             if (is.null(name)) 
[08:27:52.495]                               next
[08:27:52.495]                             if (!grepl(pattern, name)) 
[08:27:52.495]                               next
[08:27:52.495]                             invokeRestart(restart)
[08:27:52.495]                             muffled <- TRUE
[08:27:52.495]                             break
[08:27:52.495]                           }
[08:27:52.495]                         }
[08:27:52.495]                       }
[08:27:52.495]                       invisible(muffled)
[08:27:52.495]                     }
[08:27:52.495]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.495]                   }
[08:27:52.495]                 }
[08:27:52.495]             }
[08:27:52.495]         }))
[08:27:52.495]     }, error = function(ex) {
[08:27:52.495]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.495]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.495]                 ...future.rng), started = ...future.startTime, 
[08:27:52.495]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.495]             version = "1.8"), class = "FutureResult")
[08:27:52.495]     }, finally = {
[08:27:52.495]         if (!identical(...future.workdir, getwd())) 
[08:27:52.495]             setwd(...future.workdir)
[08:27:52.495]         {
[08:27:52.495]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.495]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.495]             }
[08:27:52.495]             base::options(...future.oldOptions)
[08:27:52.495]             if (.Platform$OS.type == "windows") {
[08:27:52.495]                 old_names <- names(...future.oldEnvVars)
[08:27:52.495]                 envs <- base::Sys.getenv()
[08:27:52.495]                 names <- names(envs)
[08:27:52.495]                 common <- intersect(names, old_names)
[08:27:52.495]                 added <- setdiff(names, old_names)
[08:27:52.495]                 removed <- setdiff(old_names, names)
[08:27:52.495]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.495]                   envs[common]]
[08:27:52.495]                 NAMES <- toupper(changed)
[08:27:52.495]                 args <- list()
[08:27:52.495]                 for (kk in seq_along(NAMES)) {
[08:27:52.495]                   name <- changed[[kk]]
[08:27:52.495]                   NAME <- NAMES[[kk]]
[08:27:52.495]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.495]                     next
[08:27:52.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.495]                 }
[08:27:52.495]                 NAMES <- toupper(added)
[08:27:52.495]                 for (kk in seq_along(NAMES)) {
[08:27:52.495]                   name <- added[[kk]]
[08:27:52.495]                   NAME <- NAMES[[kk]]
[08:27:52.495]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.495]                     next
[08:27:52.495]                   args[[name]] <- ""
[08:27:52.495]                 }
[08:27:52.495]                 NAMES <- toupper(removed)
[08:27:52.495]                 for (kk in seq_along(NAMES)) {
[08:27:52.495]                   name <- removed[[kk]]
[08:27:52.495]                   NAME <- NAMES[[kk]]
[08:27:52.495]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.495]                     next
[08:27:52.495]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.495]                 }
[08:27:52.495]                 if (length(args) > 0) 
[08:27:52.495]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.495]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.495]             }
[08:27:52.495]             else {
[08:27:52.495]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.495]             }
[08:27:52.495]             {
[08:27:52.495]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.495]                   0L) {
[08:27:52.495]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.495]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.495]                   base::options(opts)
[08:27:52.495]                 }
[08:27:52.495]                 {
[08:27:52.495]                   {
[08:27:52.495]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.495]                     NULL
[08:27:52.495]                   }
[08:27:52.495]                   options(future.plan = NULL)
[08:27:52.495]                   if (is.na(NA_character_)) 
[08:27:52.495]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.495]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.495]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.495]                     .init = FALSE)
[08:27:52.495]                 }
[08:27:52.495]             }
[08:27:52.495]         }
[08:27:52.495]     })
[08:27:52.495]     if (TRUE) {
[08:27:52.495]         base::sink(type = "output", split = FALSE)
[08:27:52.495]         if (TRUE) {
[08:27:52.495]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.495]         }
[08:27:52.495]         else {
[08:27:52.495]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.495]         }
[08:27:52.495]         base::close(...future.stdout)
[08:27:52.495]         ...future.stdout <- NULL
[08:27:52.495]     }
[08:27:52.495]     ...future.result$conditions <- ...future.conditions
[08:27:52.495]     ...future.result$finished <- base::Sys.time()
[08:27:52.495]     ...future.result
[08:27:52.495] }
[08:27:52.498] requestCore(): workers = 2
[08:27:52.498] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:52.522] result() for MulticoreFuture ...
[08:27:52.523] result() for MulticoreFuture ...
[08:27:52.524] result() for MulticoreFuture ... done
[08:27:52.524] result() for MulticoreFuture ... done
[08:27:52.524] result() for MulticoreFuture ...
[08:27:52.524] result() for MulticoreFuture ... done
[08:27:52.527] MulticoreFuture started
[08:27:52.527] - Launch lazy future ... done
[08:27:52.528] run() for ‘MulticoreFuture’ ... done
[08:27:52.528] plan(): Setting new future strategy stack:
<environment: 0x55d8629740b0> 
[08:27:52.529] List of future strategies:
[08:27:52.529] 1. sequential:
[08:27:52.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.529]    - tweaked: FALSE
[08:27:52.529]    - call: NULL
[08:27:52.530] plan(): nbrOfWorkers() = 1
<environment: 0x55d86099f1b8> 
[08:27:52.533] plan(): Setting new future strategy stack:
[08:27:52.533] List of future strategies:
[08:27:52.533] 1. multicore:
[08:27:52.533]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.533]    - tweaked: FALSE
[08:27:52.533]    - call: plan(strategy)
[08:27:52.537] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:52.539] resolve() on environment ...
[08:27:52.539]  recursive: 0
[08:27:52.540]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:52.540] signalConditionsASAP(numeric, pos=1) ...
[08:27:52.540] - nx: 4
[08:27:52.541] - relay: TRUE
[08:27:52.541] - stdout: TRUE
[08:27:52.541] - signal: TRUE
[08:27:52.541] - resignal: FALSE
[08:27:52.541] - force: TRUE
[08:27:52.541] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.541] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.542]  - until=2
[08:27:52.542]  - relaying element #2
[08:27:52.542] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.542] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.542] signalConditionsASAP(NULL, pos=1) ... done
[08:27:52.542]  length: 3 (resolved future 1)
[08:27:52.542] Future #2
[08:27:52.543] result() for MulticoreFuture ...
[08:27:52.543] result() for MulticoreFuture ... done
[08:27:52.543] result() for MulticoreFuture ...
[08:27:52.543] result() for MulticoreFuture ... done
[08:27:52.543] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:52.543] - nx: 4
[08:27:52.544] - relay: TRUE
[08:27:52.544] - stdout: TRUE
[08:27:52.544] - signal: TRUE
[08:27:52.544] - resignal: FALSE
[08:27:52.544] - force: TRUE
[08:27:52.544] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.544] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.544]  - until=2
[08:27:52.544]  - relaying element #2
[08:27:52.545] result() for MulticoreFuture ...
[08:27:52.545] result() for MulticoreFuture ... done
[08:27:52.545] result() for MulticoreFuture ...
[08:27:52.545] result() for MulticoreFuture ... done
[08:27:52.545] result() for MulticoreFuture ...
[08:27:52.545] result() for MulticoreFuture ... done
[08:27:52.545] result() for MulticoreFuture ...
[08:27:52.546] result() for MulticoreFuture ... done
[08:27:52.546] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.546] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.546] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:52.546]  length: 2 (resolved future 2)
[08:27:52.547] Future #3
[08:27:52.547] result() for MulticoreFuture ...
[08:27:52.548] result() for MulticoreFuture ...
[08:27:52.548] result() for MulticoreFuture ... done
[08:27:52.548] result() for MulticoreFuture ... done
[08:27:52.548] result() for MulticoreFuture ...
[08:27:52.548] result() for MulticoreFuture ... done
[08:27:52.548] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:52.549] - nx: 4
[08:27:52.549] - relay: TRUE
[08:27:52.549] - stdout: TRUE
[08:27:52.549] - signal: TRUE
[08:27:52.549] - resignal: FALSE
[08:27:52.549] - force: TRUE
[08:27:52.549] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.550] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.550]  - until=3
[08:27:52.550]  - relaying element #3
[08:27:52.550] result() for MulticoreFuture ...
[08:27:52.550] result() for MulticoreFuture ... done
[08:27:52.551] result() for MulticoreFuture ...
[08:27:52.551] result() for MulticoreFuture ... done
[08:27:52.551] result() for MulticoreFuture ...
[08:27:52.551] result() for MulticoreFuture ... done
[08:27:52.551] result() for MulticoreFuture ...
[08:27:52.552] result() for MulticoreFuture ... done
[08:27:52.552] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.552] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.552] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:52.552]  length: 1 (resolved future 3)
[08:27:52.553] Future #4
[08:27:52.553] result() for MulticoreFuture ...
[08:27:52.554] result() for MulticoreFuture ...
[08:27:52.554] result() for MulticoreFuture ... done
[08:27:52.554] result() for MulticoreFuture ... done
[08:27:52.554] result() for MulticoreFuture ...
[08:27:52.554] result() for MulticoreFuture ... done
[08:27:52.555] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:52.555] - nx: 4
[08:27:52.555] - relay: TRUE
[08:27:52.555] - stdout: TRUE
[08:27:52.555] - signal: TRUE
[08:27:52.555] - resignal: FALSE
[08:27:52.556] - force: TRUE
[08:27:52.556] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.556] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.556]  - until=4
[08:27:52.556]  - relaying element #4
[08:27:52.556] result() for MulticoreFuture ...
[08:27:52.557] result() for MulticoreFuture ... done
[08:27:52.557] result() for MulticoreFuture ...
[08:27:52.557] result() for MulticoreFuture ... done
[08:27:52.557] result() for MulticoreFuture ...
[08:27:52.557] result() for MulticoreFuture ... done
[08:27:52.557] result() for MulticoreFuture ...
[08:27:52.558] result() for MulticoreFuture ... done
[08:27:52.558] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.558] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.558] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:52.558]  length: 0 (resolved future 4)
[08:27:52.558] Relaying remaining futures
[08:27:52.558] signalConditionsASAP(NULL, pos=0) ...
[08:27:52.559] - nx: 4
[08:27:52.559] - relay: TRUE
[08:27:52.559] - stdout: TRUE
[08:27:52.559] - signal: TRUE
[08:27:52.559] - resignal: FALSE
[08:27:52.559] - force: TRUE
[08:27:52.559] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.559] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:52.559] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.560] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.560] signalConditionsASAP(NULL, pos=0) ... done
[08:27:52.560] resolve() on environment ... DONE
[08:27:52.560] result() for MulticoreFuture ...
[08:27:52.560] result() for MulticoreFuture ... done
[08:27:52.560] result() for MulticoreFuture ...
[08:27:52.560] result() for MulticoreFuture ... done
[08:27:52.560] result() for MulticoreFuture ...
[08:27:52.560] result() for MulticoreFuture ... done
[08:27:52.561] result() for MulticoreFuture ...
[08:27:52.561] result() for MulticoreFuture ... done
[08:27:52.561] result() for MulticoreFuture ...
[08:27:52.561] result() for MulticoreFuture ... done
[08:27:52.561] result() for MulticoreFuture ...
[08:27:52.561] result() for MulticoreFuture ... done
<environment: 0x55d86073fba0> 
Dimensions: c(2, 3)
[08:27:52.562] getGlobalsAndPackages() ...
[08:27:52.562] Searching for globals...
[08:27:52.562] 
[08:27:52.562] Searching for globals ... DONE
[08:27:52.562] - globals: [0] <none>
[08:27:52.563] getGlobalsAndPackages() ... DONE
[08:27:52.563] run() for ‘Future’ ...
[08:27:52.563] - state: ‘created’
[08:27:52.563] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.565] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.566]   - Field: ‘label’
[08:27:52.566]   - Field: ‘local’
[08:27:52.566]   - Field: ‘owner’
[08:27:52.566]   - Field: ‘envir’
[08:27:52.566]   - Field: ‘workers’
[08:27:52.566]   - Field: ‘packages’
[08:27:52.566]   - Field: ‘gc’
[08:27:52.566]   - Field: ‘job’
[08:27:52.566]   - Field: ‘conditions’
[08:27:52.567]   - Field: ‘expr’
[08:27:52.567]   - Field: ‘uuid’
[08:27:52.567]   - Field: ‘seed’
[08:27:52.567]   - Field: ‘version’
[08:27:52.567]   - Field: ‘result’
[08:27:52.567]   - Field: ‘asynchronous’
[08:27:52.567]   - Field: ‘calls’
[08:27:52.567]   - Field: ‘globals’
[08:27:52.567]   - Field: ‘stdout’
[08:27:52.567]   - Field: ‘earlySignal’
[08:27:52.568]   - Field: ‘lazy’
[08:27:52.568]   - Field: ‘state’
[08:27:52.568] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.568] - Launch lazy future ...
[08:27:52.568] Packages needed by the future expression (n = 0): <none>
[08:27:52.568] Packages needed by future strategies (n = 0): <none>
[08:27:52.569] {
[08:27:52.569]     {
[08:27:52.569]         {
[08:27:52.569]             ...future.startTime <- base::Sys.time()
[08:27:52.569]             {
[08:27:52.569]                 {
[08:27:52.569]                   {
[08:27:52.569]                     {
[08:27:52.569]                       base::local({
[08:27:52.569]                         has_future <- base::requireNamespace("future", 
[08:27:52.569]                           quietly = TRUE)
[08:27:52.569]                         if (has_future) {
[08:27:52.569]                           ns <- base::getNamespace("future")
[08:27:52.569]                           version <- ns[[".package"]][["version"]]
[08:27:52.569]                           if (is.null(version)) 
[08:27:52.569]                             version <- utils::packageVersion("future")
[08:27:52.569]                         }
[08:27:52.569]                         else {
[08:27:52.569]                           version <- NULL
[08:27:52.569]                         }
[08:27:52.569]                         if (!has_future || version < "1.8.0") {
[08:27:52.569]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.569]                             "", base::R.version$version.string), 
[08:27:52.569]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.569]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.569]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.569]                               "release", "version")], collapse = " "), 
[08:27:52.569]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.569]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.569]                             info)
[08:27:52.569]                           info <- base::paste(info, collapse = "; ")
[08:27:52.569]                           if (!has_future) {
[08:27:52.569]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.569]                               info)
[08:27:52.569]                           }
[08:27:52.569]                           else {
[08:27:52.569]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.569]                               info, version)
[08:27:52.569]                           }
[08:27:52.569]                           base::stop(msg)
[08:27:52.569]                         }
[08:27:52.569]                       })
[08:27:52.569]                     }
[08:27:52.569]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.569]                     base::options(mc.cores = 1L)
[08:27:52.569]                   }
[08:27:52.569]                   ...future.strategy.old <- future::plan("list")
[08:27:52.569]                   options(future.plan = NULL)
[08:27:52.569]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.569]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.569]                 }
[08:27:52.569]                 ...future.workdir <- getwd()
[08:27:52.569]             }
[08:27:52.569]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.569]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.569]         }
[08:27:52.569]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.569]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.569]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.569]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.569]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.569]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.569]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.569]             base::names(...future.oldOptions))
[08:27:52.569]     }
[08:27:52.569]     if (FALSE) {
[08:27:52.569]     }
[08:27:52.569]     else {
[08:27:52.569]         if (TRUE) {
[08:27:52.569]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.569]                 open = "w")
[08:27:52.569]         }
[08:27:52.569]         else {
[08:27:52.569]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.569]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.569]         }
[08:27:52.569]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.569]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.569]             base::sink(type = "output", split = FALSE)
[08:27:52.569]             base::close(...future.stdout)
[08:27:52.569]         }, add = TRUE)
[08:27:52.569]     }
[08:27:52.569]     ...future.frame <- base::sys.nframe()
[08:27:52.569]     ...future.conditions <- base::list()
[08:27:52.569]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.569]     if (FALSE) {
[08:27:52.569]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.569]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.569]     }
[08:27:52.569]     ...future.result <- base::tryCatch({
[08:27:52.569]         base::withCallingHandlers({
[08:27:52.569]             ...future.value <- base::withVisible(base::local({
[08:27:52.569]                 withCallingHandlers({
[08:27:52.569]                   2
[08:27:52.569]                 }, immediateCondition = function(cond) {
[08:27:52.569]                   save_rds <- function (object, pathname, ...) 
[08:27:52.569]                   {
[08:27:52.569]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.569]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.569]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.569]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.569]                         fi_tmp[["mtime"]])
[08:27:52.569]                     }
[08:27:52.569]                     tryCatch({
[08:27:52.569]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.569]                     }, error = function(ex) {
[08:27:52.569]                       msg <- conditionMessage(ex)
[08:27:52.569]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.569]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.569]                         fi_tmp[["mtime"]], msg)
[08:27:52.569]                       ex$message <- msg
[08:27:52.569]                       stop(ex)
[08:27:52.569]                     })
[08:27:52.569]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.569]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.569]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.569]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.569]                       fi <- file.info(pathname)
[08:27:52.569]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.569]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.569]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.569]                         fi[["size"]], fi[["mtime"]])
[08:27:52.569]                       stop(msg)
[08:27:52.569]                     }
[08:27:52.569]                     invisible(pathname)
[08:27:52.569]                   }
[08:27:52.569]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.569]                     rootPath = tempdir()) 
[08:27:52.569]                   {
[08:27:52.569]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.569]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.569]                       tmpdir = path, fileext = ".rds")
[08:27:52.569]                     save_rds(obj, file)
[08:27:52.569]                   }
[08:27:52.569]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.569]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.569]                   {
[08:27:52.569]                     inherits <- base::inherits
[08:27:52.569]                     invokeRestart <- base::invokeRestart
[08:27:52.569]                     is.null <- base::is.null
[08:27:52.569]                     muffled <- FALSE
[08:27:52.569]                     if (inherits(cond, "message")) {
[08:27:52.569]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.569]                       if (muffled) 
[08:27:52.569]                         invokeRestart("muffleMessage")
[08:27:52.569]                     }
[08:27:52.569]                     else if (inherits(cond, "warning")) {
[08:27:52.569]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.569]                       if (muffled) 
[08:27:52.569]                         invokeRestart("muffleWarning")
[08:27:52.569]                     }
[08:27:52.569]                     else if (inherits(cond, "condition")) {
[08:27:52.569]                       if (!is.null(pattern)) {
[08:27:52.569]                         computeRestarts <- base::computeRestarts
[08:27:52.569]                         grepl <- base::grepl
[08:27:52.569]                         restarts <- computeRestarts(cond)
[08:27:52.569]                         for (restart in restarts) {
[08:27:52.569]                           name <- restart$name
[08:27:52.569]                           if (is.null(name)) 
[08:27:52.569]                             next
[08:27:52.569]                           if (!grepl(pattern, name)) 
[08:27:52.569]                             next
[08:27:52.569]                           invokeRestart(restart)
[08:27:52.569]                           muffled <- TRUE
[08:27:52.569]                           break
[08:27:52.569]                         }
[08:27:52.569]                       }
[08:27:52.569]                     }
[08:27:52.569]                     invisible(muffled)
[08:27:52.569]                   }
[08:27:52.569]                   muffleCondition(cond)
[08:27:52.569]                 })
[08:27:52.569]             }))
[08:27:52.569]             future::FutureResult(value = ...future.value$value, 
[08:27:52.569]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.569]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.569]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.569]                     ...future.globalenv.names))
[08:27:52.569]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.569]         }, condition = base::local({
[08:27:52.569]             c <- base::c
[08:27:52.569]             inherits <- base::inherits
[08:27:52.569]             invokeRestart <- base::invokeRestart
[08:27:52.569]             length <- base::length
[08:27:52.569]             list <- base::list
[08:27:52.569]             seq.int <- base::seq.int
[08:27:52.569]             signalCondition <- base::signalCondition
[08:27:52.569]             sys.calls <- base::sys.calls
[08:27:52.569]             `[[` <- base::`[[`
[08:27:52.569]             `+` <- base::`+`
[08:27:52.569]             `<<-` <- base::`<<-`
[08:27:52.569]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.569]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.569]                   3L)]
[08:27:52.569]             }
[08:27:52.569]             function(cond) {
[08:27:52.569]                 is_error <- inherits(cond, "error")
[08:27:52.569]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.569]                   NULL)
[08:27:52.569]                 if (is_error) {
[08:27:52.569]                   sessionInformation <- function() {
[08:27:52.569]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.569]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.569]                       search = base::search(), system = base::Sys.info())
[08:27:52.569]                   }
[08:27:52.569]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.569]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.569]                     cond$call), session = sessionInformation(), 
[08:27:52.569]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.569]                   signalCondition(cond)
[08:27:52.569]                 }
[08:27:52.569]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.569]                 "immediateCondition"))) {
[08:27:52.569]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.569]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.569]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.569]                   if (TRUE && !signal) {
[08:27:52.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.569]                     {
[08:27:52.569]                       inherits <- base::inherits
[08:27:52.569]                       invokeRestart <- base::invokeRestart
[08:27:52.569]                       is.null <- base::is.null
[08:27:52.569]                       muffled <- FALSE
[08:27:52.569]                       if (inherits(cond, "message")) {
[08:27:52.569]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.569]                         if (muffled) 
[08:27:52.569]                           invokeRestart("muffleMessage")
[08:27:52.569]                       }
[08:27:52.569]                       else if (inherits(cond, "warning")) {
[08:27:52.569]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.569]                         if (muffled) 
[08:27:52.569]                           invokeRestart("muffleWarning")
[08:27:52.569]                       }
[08:27:52.569]                       else if (inherits(cond, "condition")) {
[08:27:52.569]                         if (!is.null(pattern)) {
[08:27:52.569]                           computeRestarts <- base::computeRestarts
[08:27:52.569]                           grepl <- base::grepl
[08:27:52.569]                           restarts <- computeRestarts(cond)
[08:27:52.569]                           for (restart in restarts) {
[08:27:52.569]                             name <- restart$name
[08:27:52.569]                             if (is.null(name)) 
[08:27:52.569]                               next
[08:27:52.569]                             if (!grepl(pattern, name)) 
[08:27:52.569]                               next
[08:27:52.569]                             invokeRestart(restart)
[08:27:52.569]                             muffled <- TRUE
[08:27:52.569]                             break
[08:27:52.569]                           }
[08:27:52.569]                         }
[08:27:52.569]                       }
[08:27:52.569]                       invisible(muffled)
[08:27:52.569]                     }
[08:27:52.569]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.569]                   }
[08:27:52.569]                 }
[08:27:52.569]                 else {
[08:27:52.569]                   if (TRUE) {
[08:27:52.569]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.569]                     {
[08:27:52.569]                       inherits <- base::inherits
[08:27:52.569]                       invokeRestart <- base::invokeRestart
[08:27:52.569]                       is.null <- base::is.null
[08:27:52.569]                       muffled <- FALSE
[08:27:52.569]                       if (inherits(cond, "message")) {
[08:27:52.569]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.569]                         if (muffled) 
[08:27:52.569]                           invokeRestart("muffleMessage")
[08:27:52.569]                       }
[08:27:52.569]                       else if (inherits(cond, "warning")) {
[08:27:52.569]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.569]                         if (muffled) 
[08:27:52.569]                           invokeRestart("muffleWarning")
[08:27:52.569]                       }
[08:27:52.569]                       else if (inherits(cond, "condition")) {
[08:27:52.569]                         if (!is.null(pattern)) {
[08:27:52.569]                           computeRestarts <- base::computeRestarts
[08:27:52.569]                           grepl <- base::grepl
[08:27:52.569]                           restarts <- computeRestarts(cond)
[08:27:52.569]                           for (restart in restarts) {
[08:27:52.569]                             name <- restart$name
[08:27:52.569]                             if (is.null(name)) 
[08:27:52.569]                               next
[08:27:52.569]                             if (!grepl(pattern, name)) 
[08:27:52.569]                               next
[08:27:52.569]                             invokeRestart(restart)
[08:27:52.569]                             muffled <- TRUE
[08:27:52.569]                             break
[08:27:52.569]                           }
[08:27:52.569]                         }
[08:27:52.569]                       }
[08:27:52.569]                       invisible(muffled)
[08:27:52.569]                     }
[08:27:52.569]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.569]                   }
[08:27:52.569]                 }
[08:27:52.569]             }
[08:27:52.569]         }))
[08:27:52.569]     }, error = function(ex) {
[08:27:52.569]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.569]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.569]                 ...future.rng), started = ...future.startTime, 
[08:27:52.569]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.569]             version = "1.8"), class = "FutureResult")
[08:27:52.569]     }, finally = {
[08:27:52.569]         if (!identical(...future.workdir, getwd())) 
[08:27:52.569]             setwd(...future.workdir)
[08:27:52.569]         {
[08:27:52.569]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.569]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.569]             }
[08:27:52.569]             base::options(...future.oldOptions)
[08:27:52.569]             if (.Platform$OS.type == "windows") {
[08:27:52.569]                 old_names <- names(...future.oldEnvVars)
[08:27:52.569]                 envs <- base::Sys.getenv()
[08:27:52.569]                 names <- names(envs)
[08:27:52.569]                 common <- intersect(names, old_names)
[08:27:52.569]                 added <- setdiff(names, old_names)
[08:27:52.569]                 removed <- setdiff(old_names, names)
[08:27:52.569]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.569]                   envs[common]]
[08:27:52.569]                 NAMES <- toupper(changed)
[08:27:52.569]                 args <- list()
[08:27:52.569]                 for (kk in seq_along(NAMES)) {
[08:27:52.569]                   name <- changed[[kk]]
[08:27:52.569]                   NAME <- NAMES[[kk]]
[08:27:52.569]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.569]                     next
[08:27:52.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.569]                 }
[08:27:52.569]                 NAMES <- toupper(added)
[08:27:52.569]                 for (kk in seq_along(NAMES)) {
[08:27:52.569]                   name <- added[[kk]]
[08:27:52.569]                   NAME <- NAMES[[kk]]
[08:27:52.569]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.569]                     next
[08:27:52.569]                   args[[name]] <- ""
[08:27:52.569]                 }
[08:27:52.569]                 NAMES <- toupper(removed)
[08:27:52.569]                 for (kk in seq_along(NAMES)) {
[08:27:52.569]                   name <- removed[[kk]]
[08:27:52.569]                   NAME <- NAMES[[kk]]
[08:27:52.569]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.569]                     next
[08:27:52.569]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.569]                 }
[08:27:52.569]                 if (length(args) > 0) 
[08:27:52.569]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.569]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.569]             }
[08:27:52.569]             else {
[08:27:52.569]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.569]             }
[08:27:52.569]             {
[08:27:52.569]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.569]                   0L) {
[08:27:52.569]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.569]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.569]                   base::options(opts)
[08:27:52.569]                 }
[08:27:52.569]                 {
[08:27:52.569]                   {
[08:27:52.569]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.569]                     NULL
[08:27:52.569]                   }
[08:27:52.569]                   options(future.plan = NULL)
[08:27:52.569]                   if (is.na(NA_character_)) 
[08:27:52.569]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.569]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.569]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.569]                     .init = FALSE)
[08:27:52.569]                 }
[08:27:52.569]             }
[08:27:52.569]         }
[08:27:52.569]     })
[08:27:52.569]     if (TRUE) {
[08:27:52.569]         base::sink(type = "output", split = FALSE)
[08:27:52.569]         if (TRUE) {
[08:27:52.569]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.569]         }
[08:27:52.569]         else {
[08:27:52.569]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.569]         }
[08:27:52.569]         base::close(...future.stdout)
[08:27:52.569]         ...future.stdout <- NULL
[08:27:52.569]     }
[08:27:52.569]     ...future.result$conditions <- ...future.conditions
[08:27:52.569]     ...future.result$finished <- base::Sys.time()
[08:27:52.569]     ...future.result
[08:27:52.569] }
[08:27:52.572] requestCore(): workers = 2
[08:27:52.575] MulticoreFuture started
[08:27:52.575] - Launch lazy future ... done
[08:27:52.575] run() for ‘MulticoreFuture’ ... done
[08:27:52.575] getGlobalsAndPackages() ...
[08:27:52.576] Searching for globals...
[08:27:52.576] plan(): Setting new future strategy stack:
[08:27:52.576] 
[08:27:52.577] Searching for globals ... DONE
[08:27:52.576] List of future strategies:
[08:27:52.576] 1. sequential:
[08:27:52.576]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.576]    - tweaked: FALSE
[08:27:52.576]    - call: NULL
[08:27:52.577] - globals: [0] <none>
[08:27:52.577] getGlobalsAndPackages() ... DONE
[08:27:52.577] plan(): nbrOfWorkers() = 1
[08:27:52.577] run() for ‘Future’ ...
[08:27:52.578] - state: ‘created’
[08:27:52.578] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.579] plan(): Setting new future strategy stack:
[08:27:52.579] List of future strategies:
[08:27:52.579] 1. multicore:
[08:27:52.579]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.579]    - tweaked: FALSE
[08:27:52.579]    - call: plan(strategy)
[08:27:52.581] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.581] plan(): nbrOfWorkers() = 2
[08:27:52.581] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.582]   - Field: ‘label’
[08:27:52.582]   - Field: ‘local’
[08:27:52.582]   - Field: ‘owner’
[08:27:52.582]   - Field: ‘envir’
[08:27:52.582]   - Field: ‘workers’
[08:27:52.582]   - Field: ‘packages’
[08:27:52.582]   - Field: ‘gc’
[08:27:52.582]   - Field: ‘job’
[08:27:52.583]   - Field: ‘conditions’
[08:27:52.583]   - Field: ‘expr’
[08:27:52.583]   - Field: ‘uuid’
[08:27:52.583]   - Field: ‘seed’
[08:27:52.583]   - Field: ‘version’
[08:27:52.583]   - Field: ‘result’
[08:27:52.583]   - Field: ‘asynchronous’
[08:27:52.583]   - Field: ‘calls’
[08:27:52.584]   - Field: ‘globals’
[08:27:52.584]   - Field: ‘stdout’
[08:27:52.584]   - Field: ‘earlySignal’
[08:27:52.584]   - Field: ‘lazy’
[08:27:52.584]   - Field: ‘state’
[08:27:52.584] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.584] - Launch lazy future ...
[08:27:52.585] Packages needed by the future expression (n = 0): <none>
[08:27:52.585] Packages needed by future strategies (n = 0): <none>
[08:27:52.586] {
[08:27:52.586]     {
[08:27:52.586]         {
[08:27:52.586]             ...future.startTime <- base::Sys.time()
[08:27:52.586]             {
[08:27:52.586]                 {
[08:27:52.586]                   {
[08:27:52.586]                     {
[08:27:52.586]                       base::local({
[08:27:52.586]                         has_future <- base::requireNamespace("future", 
[08:27:52.586]                           quietly = TRUE)
[08:27:52.586]                         if (has_future) {
[08:27:52.586]                           ns <- base::getNamespace("future")
[08:27:52.586]                           version <- ns[[".package"]][["version"]]
[08:27:52.586]                           if (is.null(version)) 
[08:27:52.586]                             version <- utils::packageVersion("future")
[08:27:52.586]                         }
[08:27:52.586]                         else {
[08:27:52.586]                           version <- NULL
[08:27:52.586]                         }
[08:27:52.586]                         if (!has_future || version < "1.8.0") {
[08:27:52.586]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.586]                             "", base::R.version$version.string), 
[08:27:52.586]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.586]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.586]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.586]                               "release", "version")], collapse = " "), 
[08:27:52.586]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.586]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.586]                             info)
[08:27:52.586]                           info <- base::paste(info, collapse = "; ")
[08:27:52.586]                           if (!has_future) {
[08:27:52.586]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.586]                               info)
[08:27:52.586]                           }
[08:27:52.586]                           else {
[08:27:52.586]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.586]                               info, version)
[08:27:52.586]                           }
[08:27:52.586]                           base::stop(msg)
[08:27:52.586]                         }
[08:27:52.586]                       })
[08:27:52.586]                     }
[08:27:52.586]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.586]                     base::options(mc.cores = 1L)
[08:27:52.586]                   }
[08:27:52.586]                   ...future.strategy.old <- future::plan("list")
[08:27:52.586]                   options(future.plan = NULL)
[08:27:52.586]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.586]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.586]                 }
[08:27:52.586]                 ...future.workdir <- getwd()
[08:27:52.586]             }
[08:27:52.586]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.586]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.586]         }
[08:27:52.586]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.586]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.586]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.586]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.586]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.586]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.586]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.586]             base::names(...future.oldOptions))
[08:27:52.586]     }
[08:27:52.586]     if (FALSE) {
[08:27:52.586]     }
[08:27:52.586]     else {
[08:27:52.586]         if (TRUE) {
[08:27:52.586]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.586]                 open = "w")
[08:27:52.586]         }
[08:27:52.586]         else {
[08:27:52.586]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.586]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.586]         }
[08:27:52.586]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.586]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.586]             base::sink(type = "output", split = FALSE)
[08:27:52.586]             base::close(...future.stdout)
[08:27:52.586]         }, add = TRUE)
[08:27:52.586]     }
[08:27:52.586]     ...future.frame <- base::sys.nframe()
[08:27:52.586]     ...future.conditions <- base::list()
[08:27:52.586]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.586]     if (FALSE) {
[08:27:52.586]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.586]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.586]     }
[08:27:52.586]     ...future.result <- base::tryCatch({
[08:27:52.586]         base::withCallingHandlers({
[08:27:52.586]             ...future.value <- base::withVisible(base::local({
[08:27:52.586]                 withCallingHandlers({
[08:27:52.586]                   NULL
[08:27:52.586]                 }, immediateCondition = function(cond) {
[08:27:52.586]                   save_rds <- function (object, pathname, ...) 
[08:27:52.586]                   {
[08:27:52.586]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.586]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.586]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.586]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.586]                         fi_tmp[["mtime"]])
[08:27:52.586]                     }
[08:27:52.586]                     tryCatch({
[08:27:52.586]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.586]                     }, error = function(ex) {
[08:27:52.586]                       msg <- conditionMessage(ex)
[08:27:52.586]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.586]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.586]                         fi_tmp[["mtime"]], msg)
[08:27:52.586]                       ex$message <- msg
[08:27:52.586]                       stop(ex)
[08:27:52.586]                     })
[08:27:52.586]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.586]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.586]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.586]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.586]                       fi <- file.info(pathname)
[08:27:52.586]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.586]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.586]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.586]                         fi[["size"]], fi[["mtime"]])
[08:27:52.586]                       stop(msg)
[08:27:52.586]                     }
[08:27:52.586]                     invisible(pathname)
[08:27:52.586]                   }
[08:27:52.586]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.586]                     rootPath = tempdir()) 
[08:27:52.586]                   {
[08:27:52.586]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.586]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.586]                       tmpdir = path, fileext = ".rds")
[08:27:52.586]                     save_rds(obj, file)
[08:27:52.586]                   }
[08:27:52.586]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.586]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.586]                   {
[08:27:52.586]                     inherits <- base::inherits
[08:27:52.586]                     invokeRestart <- base::invokeRestart
[08:27:52.586]                     is.null <- base::is.null
[08:27:52.586]                     muffled <- FALSE
[08:27:52.586]                     if (inherits(cond, "message")) {
[08:27:52.586]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.586]                       if (muffled) 
[08:27:52.586]                         invokeRestart("muffleMessage")
[08:27:52.586]                     }
[08:27:52.586]                     else if (inherits(cond, "warning")) {
[08:27:52.586]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.586]                       if (muffled) 
[08:27:52.586]                         invokeRestart("muffleWarning")
[08:27:52.586]                     }
[08:27:52.586]                     else if (inherits(cond, "condition")) {
[08:27:52.586]                       if (!is.null(pattern)) {
[08:27:52.586]                         computeRestarts <- base::computeRestarts
[08:27:52.586]                         grepl <- base::grepl
[08:27:52.586]                         restarts <- computeRestarts(cond)
[08:27:52.586]                         for (restart in restarts) {
[08:27:52.586]                           name <- restart$name
[08:27:52.586]                           if (is.null(name)) 
[08:27:52.586]                             next
[08:27:52.586]                           if (!grepl(pattern, name)) 
[08:27:52.586]                             next
[08:27:52.586]                           invokeRestart(restart)
[08:27:52.586]                           muffled <- TRUE
[08:27:52.586]                           break
[08:27:52.586]                         }
[08:27:52.586]                       }
[08:27:52.586]                     }
[08:27:52.586]                     invisible(muffled)
[08:27:52.586]                   }
[08:27:52.586]                   muffleCondition(cond)
[08:27:52.586]                 })
[08:27:52.586]             }))
[08:27:52.586]             future::FutureResult(value = ...future.value$value, 
[08:27:52.586]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.586]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.586]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.586]                     ...future.globalenv.names))
[08:27:52.586]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.586]         }, condition = base::local({
[08:27:52.586]             c <- base::c
[08:27:52.586]             inherits <- base::inherits
[08:27:52.586]             invokeRestart <- base::invokeRestart
[08:27:52.586]             length <- base::length
[08:27:52.586]             list <- base::list
[08:27:52.586]             seq.int <- base::seq.int
[08:27:52.586]             signalCondition <- base::signalCondition
[08:27:52.586]             sys.calls <- base::sys.calls
[08:27:52.586]             `[[` <- base::`[[`
[08:27:52.586]             `+` <- base::`+`
[08:27:52.586]             `<<-` <- base::`<<-`
[08:27:52.586]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.586]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.586]                   3L)]
[08:27:52.586]             }
[08:27:52.586]             function(cond) {
[08:27:52.586]                 is_error <- inherits(cond, "error")
[08:27:52.586]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.586]                   NULL)
[08:27:52.586]                 if (is_error) {
[08:27:52.586]                   sessionInformation <- function() {
[08:27:52.586]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.586]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.586]                       search = base::search(), system = base::Sys.info())
[08:27:52.586]                   }
[08:27:52.586]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.586]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.586]                     cond$call), session = sessionInformation(), 
[08:27:52.586]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.586]                   signalCondition(cond)
[08:27:52.586]                 }
[08:27:52.586]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.586]                 "immediateCondition"))) {
[08:27:52.586]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.586]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.586]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.586]                   if (TRUE && !signal) {
[08:27:52.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.586]                     {
[08:27:52.586]                       inherits <- base::inherits
[08:27:52.586]                       invokeRestart <- base::invokeRestart
[08:27:52.586]                       is.null <- base::is.null
[08:27:52.586]                       muffled <- FALSE
[08:27:52.586]                       if (inherits(cond, "message")) {
[08:27:52.586]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.586]                         if (muffled) 
[08:27:52.586]                           invokeRestart("muffleMessage")
[08:27:52.586]                       }
[08:27:52.586]                       else if (inherits(cond, "warning")) {
[08:27:52.586]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.586]                         if (muffled) 
[08:27:52.586]                           invokeRestart("muffleWarning")
[08:27:52.586]                       }
[08:27:52.586]                       else if (inherits(cond, "condition")) {
[08:27:52.586]                         if (!is.null(pattern)) {
[08:27:52.586]                           computeRestarts <- base::computeRestarts
[08:27:52.586]                           grepl <- base::grepl
[08:27:52.586]                           restarts <- computeRestarts(cond)
[08:27:52.586]                           for (restart in restarts) {
[08:27:52.586]                             name <- restart$name
[08:27:52.586]                             if (is.null(name)) 
[08:27:52.586]                               next
[08:27:52.586]                             if (!grepl(pattern, name)) 
[08:27:52.586]                               next
[08:27:52.586]                             invokeRestart(restart)
[08:27:52.586]                             muffled <- TRUE
[08:27:52.586]                             break
[08:27:52.586]                           }
[08:27:52.586]                         }
[08:27:52.586]                       }
[08:27:52.586]                       invisible(muffled)
[08:27:52.586]                     }
[08:27:52.586]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.586]                   }
[08:27:52.586]                 }
[08:27:52.586]                 else {
[08:27:52.586]                   if (TRUE) {
[08:27:52.586]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.586]                     {
[08:27:52.586]                       inherits <- base::inherits
[08:27:52.586]                       invokeRestart <- base::invokeRestart
[08:27:52.586]                       is.null <- base::is.null
[08:27:52.586]                       muffled <- FALSE
[08:27:52.586]                       if (inherits(cond, "message")) {
[08:27:52.586]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.586]                         if (muffled) 
[08:27:52.586]                           invokeRestart("muffleMessage")
[08:27:52.586]                       }
[08:27:52.586]                       else if (inherits(cond, "warning")) {
[08:27:52.586]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.586]                         if (muffled) 
[08:27:52.586]                           invokeRestart("muffleWarning")
[08:27:52.586]                       }
[08:27:52.586]                       else if (inherits(cond, "condition")) {
[08:27:52.586]                         if (!is.null(pattern)) {
[08:27:52.586]                           computeRestarts <- base::computeRestarts
[08:27:52.586]                           grepl <- base::grepl
[08:27:52.586]                           restarts <- computeRestarts(cond)
[08:27:52.586]                           for (restart in restarts) {
[08:27:52.586]                             name <- restart$name
[08:27:52.586]                             if (is.null(name)) 
[08:27:52.586]                               next
[08:27:52.586]                             if (!grepl(pattern, name)) 
[08:27:52.586]                               next
[08:27:52.586]                             invokeRestart(restart)
[08:27:52.586]                             muffled <- TRUE
[08:27:52.586]                             break
[08:27:52.586]                           }
[08:27:52.586]                         }
[08:27:52.586]                       }
[08:27:52.586]                       invisible(muffled)
[08:27:52.586]                     }
[08:27:52.586]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.586]                   }
[08:27:52.586]                 }
[08:27:52.586]             }
[08:27:52.586]         }))
[08:27:52.586]     }, error = function(ex) {
[08:27:52.586]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.586]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.586]                 ...future.rng), started = ...future.startTime, 
[08:27:52.586]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.586]             version = "1.8"), class = "FutureResult")
[08:27:52.586]     }, finally = {
[08:27:52.586]         if (!identical(...future.workdir, getwd())) 
[08:27:52.586]             setwd(...future.workdir)
[08:27:52.586]         {
[08:27:52.586]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.586]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.586]             }
[08:27:52.586]             base::options(...future.oldOptions)
[08:27:52.586]             if (.Platform$OS.type == "windows") {
[08:27:52.586]                 old_names <- names(...future.oldEnvVars)
[08:27:52.586]                 envs <- base::Sys.getenv()
[08:27:52.586]                 names <- names(envs)
[08:27:52.586]                 common <- intersect(names, old_names)
[08:27:52.586]                 added <- setdiff(names, old_names)
[08:27:52.586]                 removed <- setdiff(old_names, names)
[08:27:52.586]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.586]                   envs[common]]
[08:27:52.586]                 NAMES <- toupper(changed)
[08:27:52.586]                 args <- list()
[08:27:52.586]                 for (kk in seq_along(NAMES)) {
[08:27:52.586]                   name <- changed[[kk]]
[08:27:52.586]                   NAME <- NAMES[[kk]]
[08:27:52.586]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.586]                     next
[08:27:52.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.586]                 }
[08:27:52.586]                 NAMES <- toupper(added)
[08:27:52.586]                 for (kk in seq_along(NAMES)) {
[08:27:52.586]                   name <- added[[kk]]
[08:27:52.586]                   NAME <- NAMES[[kk]]
[08:27:52.586]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.586]                     next
[08:27:52.586]                   args[[name]] <- ""
[08:27:52.586]                 }
[08:27:52.586]                 NAMES <- toupper(removed)
[08:27:52.586]                 for (kk in seq_along(NAMES)) {
[08:27:52.586]                   name <- removed[[kk]]
[08:27:52.586]                   NAME <- NAMES[[kk]]
[08:27:52.586]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.586]                     next
[08:27:52.586]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.586]                 }
[08:27:52.586]                 if (length(args) > 0) 
[08:27:52.586]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.586]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.586]             }
[08:27:52.586]             else {
[08:27:52.586]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.586]             }
[08:27:52.586]             {
[08:27:52.586]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.586]                   0L) {
[08:27:52.586]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.586]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.586]                   base::options(opts)
[08:27:52.586]                 }
[08:27:52.586]                 {
[08:27:52.586]                   {
[08:27:52.586]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.586]                     NULL
[08:27:52.586]                   }
[08:27:52.586]                   options(future.plan = NULL)
[08:27:52.586]                   if (is.na(NA_character_)) 
[08:27:52.586]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.586]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.586]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.586]                     .init = FALSE)
[08:27:52.586]                 }
[08:27:52.586]             }
[08:27:52.586]         }
[08:27:52.586]     })
[08:27:52.586]     if (TRUE) {
[08:27:52.586]         base::sink(type = "output", split = FALSE)
[08:27:52.586]         if (TRUE) {
[08:27:52.586]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.586]         }
[08:27:52.586]         else {
[08:27:52.586]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.586]         }
[08:27:52.586]         base::close(...future.stdout)
[08:27:52.586]         ...future.stdout <- NULL
[08:27:52.586]     }
[08:27:52.586]     ...future.result$conditions <- ...future.conditions
[08:27:52.586]     ...future.result$finished <- base::Sys.time()
[08:27:52.586]     ...future.result
[08:27:52.586] }
[08:27:52.589] requestCore(): workers = 2
[08:27:52.592] MulticoreFuture started
[08:27:52.593] - Launch lazy future ... done
[08:27:52.593] run() for ‘MulticoreFuture’ ... done
[08:27:52.594] plan(): Setting new future strategy stack:
[08:27:52.594] getGlobalsAndPackages() ...
[08:27:52.594] Searching for globals...
[08:27:52.594] List of future strategies:
[08:27:52.594] 1. sequential:
[08:27:52.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.594]    - tweaked: FALSE
[08:27:52.594]    - call: NULL
[08:27:52.595] plan(): nbrOfWorkers() = 1
[08:27:52.596] - globals found: [1] ‘{’
[08:27:52.596] Searching for globals ... DONE
[08:27:52.596] Resolving globals: FALSE
[08:27:52.596] 
[08:27:52.597] 
[08:27:52.597] getGlobalsAndPackages() ... DONE
[08:27:52.597] plan(): Setting new future strategy stack:
[08:27:52.597] run() for ‘Future’ ...
[08:27:52.597] - state: ‘created’
[08:27:52.598] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.597] List of future strategies:
[08:27:52.597] 1. multicore:
[08:27:52.597]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.597]    - tweaked: FALSE
[08:27:52.597]    - call: plan(strategy)
[08:27:52.600] plan(): nbrOfWorkers() = 2
[08:27:52.600] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.601] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.601]   - Field: ‘label’
[08:27:52.601]   - Field: ‘local’
[08:27:52.601]   - Field: ‘owner’
[08:27:52.601]   - Field: ‘envir’
[08:27:52.601]   - Field: ‘workers’
[08:27:52.602]   - Field: ‘packages’
[08:27:52.602]   - Field: ‘gc’
[08:27:52.602]   - Field: ‘job’
[08:27:52.602]   - Field: ‘conditions’
[08:27:52.602]   - Field: ‘expr’
[08:27:52.602]   - Field: ‘uuid’
[08:27:52.602]   - Field: ‘seed’
[08:27:52.602]   - Field: ‘version’
[08:27:52.603]   - Field: ‘result’
[08:27:52.603]   - Field: ‘asynchronous’
[08:27:52.603]   - Field: ‘calls’
[08:27:52.603]   - Field: ‘globals’
[08:27:52.603]   - Field: ‘stdout’
[08:27:52.603]   - Field: ‘earlySignal’
[08:27:52.603]   - Field: ‘lazy’
[08:27:52.603]   - Field: ‘state’
[08:27:52.604] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.604] - Launch lazy future ...
[08:27:52.604] Packages needed by the future expression (n = 0): <none>
[08:27:52.604] Packages needed by future strategies (n = 0): <none>
[08:27:52.605] {
[08:27:52.605]     {
[08:27:52.605]         {
[08:27:52.605]             ...future.startTime <- base::Sys.time()
[08:27:52.605]             {
[08:27:52.605]                 {
[08:27:52.605]                   {
[08:27:52.605]                     {
[08:27:52.605]                       base::local({
[08:27:52.605]                         has_future <- base::requireNamespace("future", 
[08:27:52.605]                           quietly = TRUE)
[08:27:52.605]                         if (has_future) {
[08:27:52.605]                           ns <- base::getNamespace("future")
[08:27:52.605]                           version <- ns[[".package"]][["version"]]
[08:27:52.605]                           if (is.null(version)) 
[08:27:52.605]                             version <- utils::packageVersion("future")
[08:27:52.605]                         }
[08:27:52.605]                         else {
[08:27:52.605]                           version <- NULL
[08:27:52.605]                         }
[08:27:52.605]                         if (!has_future || version < "1.8.0") {
[08:27:52.605]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.605]                             "", base::R.version$version.string), 
[08:27:52.605]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.605]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.605]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.605]                               "release", "version")], collapse = " "), 
[08:27:52.605]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.605]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.605]                             info)
[08:27:52.605]                           info <- base::paste(info, collapse = "; ")
[08:27:52.605]                           if (!has_future) {
[08:27:52.605]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.605]                               info)
[08:27:52.605]                           }
[08:27:52.605]                           else {
[08:27:52.605]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.605]                               info, version)
[08:27:52.605]                           }
[08:27:52.605]                           base::stop(msg)
[08:27:52.605]                         }
[08:27:52.605]                       })
[08:27:52.605]                     }
[08:27:52.605]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.605]                     base::options(mc.cores = 1L)
[08:27:52.605]                   }
[08:27:52.605]                   ...future.strategy.old <- future::plan("list")
[08:27:52.605]                   options(future.plan = NULL)
[08:27:52.605]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.605]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.605]                 }
[08:27:52.605]                 ...future.workdir <- getwd()
[08:27:52.605]             }
[08:27:52.605]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.605]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.605]         }
[08:27:52.605]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.605]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.605]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.605]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.605]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.605]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.605]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.605]             base::names(...future.oldOptions))
[08:27:52.605]     }
[08:27:52.605]     if (FALSE) {
[08:27:52.605]     }
[08:27:52.605]     else {
[08:27:52.605]         if (TRUE) {
[08:27:52.605]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.605]                 open = "w")
[08:27:52.605]         }
[08:27:52.605]         else {
[08:27:52.605]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.605]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.605]         }
[08:27:52.605]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.605]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.605]             base::sink(type = "output", split = FALSE)
[08:27:52.605]             base::close(...future.stdout)
[08:27:52.605]         }, add = TRUE)
[08:27:52.605]     }
[08:27:52.605]     ...future.frame <- base::sys.nframe()
[08:27:52.605]     ...future.conditions <- base::list()
[08:27:52.605]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.605]     if (FALSE) {
[08:27:52.605]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.605]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.605]     }
[08:27:52.605]     ...future.result <- base::tryCatch({
[08:27:52.605]         base::withCallingHandlers({
[08:27:52.605]             ...future.value <- base::withVisible(base::local({
[08:27:52.605]                 withCallingHandlers({
[08:27:52.605]                   {
[08:27:52.605]                     4
[08:27:52.605]                   }
[08:27:52.605]                 }, immediateCondition = function(cond) {
[08:27:52.605]                   save_rds <- function (object, pathname, ...) 
[08:27:52.605]                   {
[08:27:52.605]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.605]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.605]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.605]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.605]                         fi_tmp[["mtime"]])
[08:27:52.605]                     }
[08:27:52.605]                     tryCatch({
[08:27:52.605]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.605]                     }, error = function(ex) {
[08:27:52.605]                       msg <- conditionMessage(ex)
[08:27:52.605]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.605]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.605]                         fi_tmp[["mtime"]], msg)
[08:27:52.605]                       ex$message <- msg
[08:27:52.605]                       stop(ex)
[08:27:52.605]                     })
[08:27:52.605]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.605]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.605]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.605]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.605]                       fi <- file.info(pathname)
[08:27:52.605]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.605]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.605]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.605]                         fi[["size"]], fi[["mtime"]])
[08:27:52.605]                       stop(msg)
[08:27:52.605]                     }
[08:27:52.605]                     invisible(pathname)
[08:27:52.605]                   }
[08:27:52.605]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.605]                     rootPath = tempdir()) 
[08:27:52.605]                   {
[08:27:52.605]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.605]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.605]                       tmpdir = path, fileext = ".rds")
[08:27:52.605]                     save_rds(obj, file)
[08:27:52.605]                   }
[08:27:52.605]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.605]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.605]                   {
[08:27:52.605]                     inherits <- base::inherits
[08:27:52.605]                     invokeRestart <- base::invokeRestart
[08:27:52.605]                     is.null <- base::is.null
[08:27:52.605]                     muffled <- FALSE
[08:27:52.605]                     if (inherits(cond, "message")) {
[08:27:52.605]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.605]                       if (muffled) 
[08:27:52.605]                         invokeRestart("muffleMessage")
[08:27:52.605]                     }
[08:27:52.605]                     else if (inherits(cond, "warning")) {
[08:27:52.605]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.605]                       if (muffled) 
[08:27:52.605]                         invokeRestart("muffleWarning")
[08:27:52.605]                     }
[08:27:52.605]                     else if (inherits(cond, "condition")) {
[08:27:52.605]                       if (!is.null(pattern)) {
[08:27:52.605]                         computeRestarts <- base::computeRestarts
[08:27:52.605]                         grepl <- base::grepl
[08:27:52.605]                         restarts <- computeRestarts(cond)
[08:27:52.605]                         for (restart in restarts) {
[08:27:52.605]                           name <- restart$name
[08:27:52.605]                           if (is.null(name)) 
[08:27:52.605]                             next
[08:27:52.605]                           if (!grepl(pattern, name)) 
[08:27:52.605]                             next
[08:27:52.605]                           invokeRestart(restart)
[08:27:52.605]                           muffled <- TRUE
[08:27:52.605]                           break
[08:27:52.605]                         }
[08:27:52.605]                       }
[08:27:52.605]                     }
[08:27:52.605]                     invisible(muffled)
[08:27:52.605]                   }
[08:27:52.605]                   muffleCondition(cond)
[08:27:52.605]                 })
[08:27:52.605]             }))
[08:27:52.605]             future::FutureResult(value = ...future.value$value, 
[08:27:52.605]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.605]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.605]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.605]                     ...future.globalenv.names))
[08:27:52.605]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.605]         }, condition = base::local({
[08:27:52.605]             c <- base::c
[08:27:52.605]             inherits <- base::inherits
[08:27:52.605]             invokeRestart <- base::invokeRestart
[08:27:52.605]             length <- base::length
[08:27:52.605]             list <- base::list
[08:27:52.605]             seq.int <- base::seq.int
[08:27:52.605]             signalCondition <- base::signalCondition
[08:27:52.605]             sys.calls <- base::sys.calls
[08:27:52.605]             `[[` <- base::`[[`
[08:27:52.605]             `+` <- base::`+`
[08:27:52.605]             `<<-` <- base::`<<-`
[08:27:52.605]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.605]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.605]                   3L)]
[08:27:52.605]             }
[08:27:52.605]             function(cond) {
[08:27:52.605]                 is_error <- inherits(cond, "error")
[08:27:52.605]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.605]                   NULL)
[08:27:52.605]                 if (is_error) {
[08:27:52.605]                   sessionInformation <- function() {
[08:27:52.605]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.605]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.605]                       search = base::search(), system = base::Sys.info())
[08:27:52.605]                   }
[08:27:52.605]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.605]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.605]                     cond$call), session = sessionInformation(), 
[08:27:52.605]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.605]                   signalCondition(cond)
[08:27:52.605]                 }
[08:27:52.605]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.605]                 "immediateCondition"))) {
[08:27:52.605]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.605]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.605]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.605]                   if (TRUE && !signal) {
[08:27:52.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.605]                     {
[08:27:52.605]                       inherits <- base::inherits
[08:27:52.605]                       invokeRestart <- base::invokeRestart
[08:27:52.605]                       is.null <- base::is.null
[08:27:52.605]                       muffled <- FALSE
[08:27:52.605]                       if (inherits(cond, "message")) {
[08:27:52.605]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.605]                         if (muffled) 
[08:27:52.605]                           invokeRestart("muffleMessage")
[08:27:52.605]                       }
[08:27:52.605]                       else if (inherits(cond, "warning")) {
[08:27:52.605]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.605]                         if (muffled) 
[08:27:52.605]                           invokeRestart("muffleWarning")
[08:27:52.605]                       }
[08:27:52.605]                       else if (inherits(cond, "condition")) {
[08:27:52.605]                         if (!is.null(pattern)) {
[08:27:52.605]                           computeRestarts <- base::computeRestarts
[08:27:52.605]                           grepl <- base::grepl
[08:27:52.605]                           restarts <- computeRestarts(cond)
[08:27:52.605]                           for (restart in restarts) {
[08:27:52.605]                             name <- restart$name
[08:27:52.605]                             if (is.null(name)) 
[08:27:52.605]                               next
[08:27:52.605]                             if (!grepl(pattern, name)) 
[08:27:52.605]                               next
[08:27:52.605]                             invokeRestart(restart)
[08:27:52.605]                             muffled <- TRUE
[08:27:52.605]                             break
[08:27:52.605]                           }
[08:27:52.605]                         }
[08:27:52.605]                       }
[08:27:52.605]                       invisible(muffled)
[08:27:52.605]                     }
[08:27:52.605]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.605]                   }
[08:27:52.605]                 }
[08:27:52.605]                 else {
[08:27:52.605]                   if (TRUE) {
[08:27:52.605]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.605]                     {
[08:27:52.605]                       inherits <- base::inherits
[08:27:52.605]                       invokeRestart <- base::invokeRestart
[08:27:52.605]                       is.null <- base::is.null
[08:27:52.605]                       muffled <- FALSE
[08:27:52.605]                       if (inherits(cond, "message")) {
[08:27:52.605]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.605]                         if (muffled) 
[08:27:52.605]                           invokeRestart("muffleMessage")
[08:27:52.605]                       }
[08:27:52.605]                       else if (inherits(cond, "warning")) {
[08:27:52.605]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.605]                         if (muffled) 
[08:27:52.605]                           invokeRestart("muffleWarning")
[08:27:52.605]                       }
[08:27:52.605]                       else if (inherits(cond, "condition")) {
[08:27:52.605]                         if (!is.null(pattern)) {
[08:27:52.605]                           computeRestarts <- base::computeRestarts
[08:27:52.605]                           grepl <- base::grepl
[08:27:52.605]                           restarts <- computeRestarts(cond)
[08:27:52.605]                           for (restart in restarts) {
[08:27:52.605]                             name <- restart$name
[08:27:52.605]                             if (is.null(name)) 
[08:27:52.605]                               next
[08:27:52.605]                             if (!grepl(pattern, name)) 
[08:27:52.605]                               next
[08:27:52.605]                             invokeRestart(restart)
[08:27:52.605]                             muffled <- TRUE
[08:27:52.605]                             break
[08:27:52.605]                           }
[08:27:52.605]                         }
[08:27:52.605]                       }
[08:27:52.605]                       invisible(muffled)
[08:27:52.605]                     }
[08:27:52.605]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.605]                   }
[08:27:52.605]                 }
[08:27:52.605]             }
[08:27:52.605]         }))
[08:27:52.605]     }, error = function(ex) {
[08:27:52.605]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.605]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.605]                 ...future.rng), started = ...future.startTime, 
[08:27:52.605]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.605]             version = "1.8"), class = "FutureResult")
[08:27:52.605]     }, finally = {
[08:27:52.605]         if (!identical(...future.workdir, getwd())) 
[08:27:52.605]             setwd(...future.workdir)
[08:27:52.605]         {
[08:27:52.605]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.605]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.605]             }
[08:27:52.605]             base::options(...future.oldOptions)
[08:27:52.605]             if (.Platform$OS.type == "windows") {
[08:27:52.605]                 old_names <- names(...future.oldEnvVars)
[08:27:52.605]                 envs <- base::Sys.getenv()
[08:27:52.605]                 names <- names(envs)
[08:27:52.605]                 common <- intersect(names, old_names)
[08:27:52.605]                 added <- setdiff(names, old_names)
[08:27:52.605]                 removed <- setdiff(old_names, names)
[08:27:52.605]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.605]                   envs[common]]
[08:27:52.605]                 NAMES <- toupper(changed)
[08:27:52.605]                 args <- list()
[08:27:52.605]                 for (kk in seq_along(NAMES)) {
[08:27:52.605]                   name <- changed[[kk]]
[08:27:52.605]                   NAME <- NAMES[[kk]]
[08:27:52.605]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.605]                     next
[08:27:52.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.605]                 }
[08:27:52.605]                 NAMES <- toupper(added)
[08:27:52.605]                 for (kk in seq_along(NAMES)) {
[08:27:52.605]                   name <- added[[kk]]
[08:27:52.605]                   NAME <- NAMES[[kk]]
[08:27:52.605]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.605]                     next
[08:27:52.605]                   args[[name]] <- ""
[08:27:52.605]                 }
[08:27:52.605]                 NAMES <- toupper(removed)
[08:27:52.605]                 for (kk in seq_along(NAMES)) {
[08:27:52.605]                   name <- removed[[kk]]
[08:27:52.605]                   NAME <- NAMES[[kk]]
[08:27:52.605]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.605]                     next
[08:27:52.605]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.605]                 }
[08:27:52.605]                 if (length(args) > 0) 
[08:27:52.605]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.605]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.605]             }
[08:27:52.605]             else {
[08:27:52.605]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.605]             }
[08:27:52.605]             {
[08:27:52.605]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.605]                   0L) {
[08:27:52.605]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.605]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.605]                   base::options(opts)
[08:27:52.605]                 }
[08:27:52.605]                 {
[08:27:52.605]                   {
[08:27:52.605]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.605]                     NULL
[08:27:52.605]                   }
[08:27:52.605]                   options(future.plan = NULL)
[08:27:52.605]                   if (is.na(NA_character_)) 
[08:27:52.605]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.605]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.605]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.605]                     .init = FALSE)
[08:27:52.605]                 }
[08:27:52.605]             }
[08:27:52.605]         }
[08:27:52.605]     })
[08:27:52.605]     if (TRUE) {
[08:27:52.605]         base::sink(type = "output", split = FALSE)
[08:27:52.605]         if (TRUE) {
[08:27:52.605]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.605]         }
[08:27:52.605]         else {
[08:27:52.605]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.605]         }
[08:27:52.605]         base::close(...future.stdout)
[08:27:52.605]         ...future.stdout <- NULL
[08:27:52.605]     }
[08:27:52.605]     ...future.result$conditions <- ...future.conditions
[08:27:52.605]     ...future.result$finished <- base::Sys.time()
[08:27:52.605]     ...future.result
[08:27:52.605] }
[08:27:52.608] requestCore(): workers = 2
[08:27:52.609] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:52.620] result() for MulticoreFuture ...
[08:27:52.621] result() for MulticoreFuture ...
[08:27:52.621] result() for MulticoreFuture ... done
[08:27:52.621] result() for MulticoreFuture ... done
[08:27:52.621] result() for MulticoreFuture ...
[08:27:52.621] result() for MulticoreFuture ... done
[08:27:52.624] MulticoreFuture started
[08:27:52.625] - Launch lazy future ... done
[08:27:52.625] run() for ‘MulticoreFuture’ ... done
[08:27:52.626] plan(): Setting new future strategy stack:
<environment: 0x55d861fe29a8> 
[08:27:52.626] List of future strategies:
[08:27:52.626] 1. sequential:
[08:27:52.626]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.626]    - tweaked: FALSE
[08:27:52.626]    - call: NULL
[08:27:52.627] plan(): nbrOfWorkers() = 1
<environment: 0x55d86290dfe8> 
[08:27:52.630] plan(): Setting new future strategy stack:
[08:27:52.630] List of future strategies:
[08:27:52.630] 1. multicore:
[08:27:52.630]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.630]    - tweaked: FALSE
[08:27:52.630]    - call: plan(strategy)
[08:27:52.634] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:52.636] resolve() on environment ...
[08:27:52.636]  recursive: 0
[08:27:52.637]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:52.637] signalConditionsASAP(numeric, pos=1) ...
[08:27:52.637] - nx: 4
[08:27:52.637] - relay: TRUE
[08:27:52.638] - stdout: TRUE
[08:27:52.638] - signal: TRUE
[08:27:52.638] - resignal: FALSE
[08:27:52.638] - force: TRUE
[08:27:52.638] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.638] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.638]  - until=2
[08:27:52.638]  - relaying element #2
[08:27:52.638] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.639] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.639] signalConditionsASAP(NULL, pos=1) ... done
[08:27:52.639]  length: 3 (resolved future 1)
[08:27:52.639] Future #2
[08:27:52.639] result() for MulticoreFuture ...
[08:27:52.639] result() for MulticoreFuture ... done
[08:27:52.640] result() for MulticoreFuture ...
[08:27:52.640] result() for MulticoreFuture ... done
[08:27:52.640] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:52.640] - nx: 4
[08:27:52.640] - relay: TRUE
[08:27:52.640] - stdout: TRUE
[08:27:52.640] - signal: TRUE
[08:27:52.640] - resignal: FALSE
[08:27:52.640] - force: TRUE
[08:27:52.641] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.641] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.641]  - until=2
[08:27:52.641]  - relaying element #2
[08:27:52.641] result() for MulticoreFuture ...
[08:27:52.641] result() for MulticoreFuture ... done
[08:27:52.641] result() for MulticoreFuture ...
[08:27:52.641] result() for MulticoreFuture ... done
[08:27:52.642] result() for MulticoreFuture ...
[08:27:52.642] result() for MulticoreFuture ... done
[08:27:52.642] result() for MulticoreFuture ...
[08:27:52.642] result() for MulticoreFuture ... done
[08:27:52.642] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.642] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.642] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:52.643]  length: 2 (resolved future 2)
[08:27:52.643] Future #3
[08:27:52.643] result() for MulticoreFuture ...
[08:27:52.644] result() for MulticoreFuture ...
[08:27:52.644] result() for MulticoreFuture ... done
[08:27:52.644] result() for MulticoreFuture ... done
[08:27:52.644] result() for MulticoreFuture ...
[08:27:52.644] result() for MulticoreFuture ... done
[08:27:52.645] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:52.645] - nx: 4
[08:27:52.645] - relay: TRUE
[08:27:52.645] - stdout: TRUE
[08:27:52.645] - signal: TRUE
[08:27:52.645] - resignal: FALSE
[08:27:52.645] - force: TRUE
[08:27:52.645] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.645] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.646]  - until=3
[08:27:52.646]  - relaying element #3
[08:27:52.646] result() for MulticoreFuture ...
[08:27:52.646] result() for MulticoreFuture ... done
[08:27:52.646] result() for MulticoreFuture ...
[08:27:52.646] result() for MulticoreFuture ... done
[08:27:52.646] result() for MulticoreFuture ...
[08:27:52.646] result() for MulticoreFuture ... done
[08:27:52.647] result() for MulticoreFuture ...
[08:27:52.647] result() for MulticoreFuture ... done
[08:27:52.647] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.647] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.647] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:52.647]  length: 1 (resolved future 3)
[08:27:52.648] Future #4
[08:27:52.648] result() for MulticoreFuture ...
[08:27:52.648] result() for MulticoreFuture ...
[08:27:52.649] result() for MulticoreFuture ... done
[08:27:52.649] result() for MulticoreFuture ... done
[08:27:52.649] result() for MulticoreFuture ...
[08:27:52.649] result() for MulticoreFuture ... done
[08:27:52.649] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:52.650] - nx: 4
[08:27:52.650] - relay: TRUE
[08:27:52.650] - stdout: TRUE
[08:27:52.650] - signal: TRUE
[08:27:52.650] - resignal: FALSE
[08:27:52.650] - force: TRUE
[08:27:52.650] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.651] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.651]  - until=4
[08:27:52.651]  - relaying element #4
[08:27:52.651] result() for MulticoreFuture ...
[08:27:52.651] result() for MulticoreFuture ... done
[08:27:52.651] result() for MulticoreFuture ...
[08:27:52.652] result() for MulticoreFuture ... done
[08:27:52.652] result() for MulticoreFuture ...
[08:27:52.652] result() for MulticoreFuture ... done
[08:27:52.652] result() for MulticoreFuture ...
[08:27:52.652] result() for MulticoreFuture ... done
[08:27:52.652] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.653] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.653] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:52.653]  length: 0 (resolved future 4)
[08:27:52.653] Relaying remaining futures
[08:27:52.653] signalConditionsASAP(NULL, pos=0) ...
[08:27:52.653] - nx: 4
[08:27:52.653] - relay: TRUE
[08:27:52.653] - stdout: TRUE
[08:27:52.653] - signal: TRUE
[08:27:52.653] - resignal: FALSE
[08:27:52.654] - force: TRUE
[08:27:52.654] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.654] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:52.654] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.654] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.654] signalConditionsASAP(NULL, pos=0) ... done
[08:27:52.654] resolve() on environment ... DONE
[08:27:52.654] result() for MulticoreFuture ...
[08:27:52.654] result() for MulticoreFuture ... done
[08:27:52.655] result() for MulticoreFuture ...
[08:27:52.655] result() for MulticoreFuture ... done
[08:27:52.655] result() for MulticoreFuture ...
[08:27:52.655] result() for MulticoreFuture ... done
[08:27:52.655] result() for MulticoreFuture ...
[08:27:52.655] result() for MulticoreFuture ... done
[08:27:52.655] result() for MulticoreFuture ...
[08:27:52.655] result() for MulticoreFuture ... done
[08:27:52.655] result() for MulticoreFuture ...
[08:27:52.655] result() for MulticoreFuture ... done
<environment: 0x55d8629d39e8> 
Dimensions: c(2, 3, 1)
[08:27:52.656] getGlobalsAndPackages() ...
[08:27:52.656] Searching for globals...
[08:27:52.657] 
[08:27:52.657] Searching for globals ... DONE
[08:27:52.657] - globals: [0] <none>
[08:27:52.657] getGlobalsAndPackages() ... DONE
[08:27:52.657] run() for ‘Future’ ...
[08:27:52.657] - state: ‘created’
[08:27:52.658] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.660] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.660] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.660]   - Field: ‘label’
[08:27:52.660]   - Field: ‘local’
[08:27:52.660]   - Field: ‘owner’
[08:27:52.660]   - Field: ‘envir’
[08:27:52.661]   - Field: ‘workers’
[08:27:52.661]   - Field: ‘packages’
[08:27:52.661]   - Field: ‘gc’
[08:27:52.664]   - Field: ‘job’
[08:27:52.664]   - Field: ‘conditions’
[08:27:52.665]   - Field: ‘expr’
[08:27:52.665]   - Field: ‘uuid’
[08:27:52.665]   - Field: ‘seed’
[08:27:52.665]   - Field: ‘version’
[08:27:52.665]   - Field: ‘result’
[08:27:52.665]   - Field: ‘asynchronous’
[08:27:52.665]   - Field: ‘calls’
[08:27:52.665]   - Field: ‘globals’
[08:27:52.665]   - Field: ‘stdout’
[08:27:52.665]   - Field: ‘earlySignal’
[08:27:52.666]   - Field: ‘lazy’
[08:27:52.666]   - Field: ‘state’
[08:27:52.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.666] - Launch lazy future ...
[08:27:52.666] Packages needed by the future expression (n = 0): <none>
[08:27:52.666] Packages needed by future strategies (n = 0): <none>
[08:27:52.667] {
[08:27:52.667]     {
[08:27:52.667]         {
[08:27:52.667]             ...future.startTime <- base::Sys.time()
[08:27:52.667]             {
[08:27:52.667]                 {
[08:27:52.667]                   {
[08:27:52.667]                     {
[08:27:52.667]                       base::local({
[08:27:52.667]                         has_future <- base::requireNamespace("future", 
[08:27:52.667]                           quietly = TRUE)
[08:27:52.667]                         if (has_future) {
[08:27:52.667]                           ns <- base::getNamespace("future")
[08:27:52.667]                           version <- ns[[".package"]][["version"]]
[08:27:52.667]                           if (is.null(version)) 
[08:27:52.667]                             version <- utils::packageVersion("future")
[08:27:52.667]                         }
[08:27:52.667]                         else {
[08:27:52.667]                           version <- NULL
[08:27:52.667]                         }
[08:27:52.667]                         if (!has_future || version < "1.8.0") {
[08:27:52.667]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.667]                             "", base::R.version$version.string), 
[08:27:52.667]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.667]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.667]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.667]                               "release", "version")], collapse = " "), 
[08:27:52.667]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.667]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.667]                             info)
[08:27:52.667]                           info <- base::paste(info, collapse = "; ")
[08:27:52.667]                           if (!has_future) {
[08:27:52.667]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.667]                               info)
[08:27:52.667]                           }
[08:27:52.667]                           else {
[08:27:52.667]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.667]                               info, version)
[08:27:52.667]                           }
[08:27:52.667]                           base::stop(msg)
[08:27:52.667]                         }
[08:27:52.667]                       })
[08:27:52.667]                     }
[08:27:52.667]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.667]                     base::options(mc.cores = 1L)
[08:27:52.667]                   }
[08:27:52.667]                   ...future.strategy.old <- future::plan("list")
[08:27:52.667]                   options(future.plan = NULL)
[08:27:52.667]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.667]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.667]                 }
[08:27:52.667]                 ...future.workdir <- getwd()
[08:27:52.667]             }
[08:27:52.667]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.667]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.667]         }
[08:27:52.667]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.667]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.667]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.667]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.667]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.667]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.667]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.667]             base::names(...future.oldOptions))
[08:27:52.667]     }
[08:27:52.667]     if (FALSE) {
[08:27:52.667]     }
[08:27:52.667]     else {
[08:27:52.667]         if (TRUE) {
[08:27:52.667]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.667]                 open = "w")
[08:27:52.667]         }
[08:27:52.667]         else {
[08:27:52.667]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.667]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.667]         }
[08:27:52.667]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.667]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.667]             base::sink(type = "output", split = FALSE)
[08:27:52.667]             base::close(...future.stdout)
[08:27:52.667]         }, add = TRUE)
[08:27:52.667]     }
[08:27:52.667]     ...future.frame <- base::sys.nframe()
[08:27:52.667]     ...future.conditions <- base::list()
[08:27:52.667]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.667]     if (FALSE) {
[08:27:52.667]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.667]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.667]     }
[08:27:52.667]     ...future.result <- base::tryCatch({
[08:27:52.667]         base::withCallingHandlers({
[08:27:52.667]             ...future.value <- base::withVisible(base::local({
[08:27:52.667]                 withCallingHandlers({
[08:27:52.667]                   2
[08:27:52.667]                 }, immediateCondition = function(cond) {
[08:27:52.667]                   save_rds <- function (object, pathname, ...) 
[08:27:52.667]                   {
[08:27:52.667]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.667]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.667]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.667]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.667]                         fi_tmp[["mtime"]])
[08:27:52.667]                     }
[08:27:52.667]                     tryCatch({
[08:27:52.667]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.667]                     }, error = function(ex) {
[08:27:52.667]                       msg <- conditionMessage(ex)
[08:27:52.667]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.667]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.667]                         fi_tmp[["mtime"]], msg)
[08:27:52.667]                       ex$message <- msg
[08:27:52.667]                       stop(ex)
[08:27:52.667]                     })
[08:27:52.667]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.667]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.667]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.667]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.667]                       fi <- file.info(pathname)
[08:27:52.667]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.667]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.667]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.667]                         fi[["size"]], fi[["mtime"]])
[08:27:52.667]                       stop(msg)
[08:27:52.667]                     }
[08:27:52.667]                     invisible(pathname)
[08:27:52.667]                   }
[08:27:52.667]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.667]                     rootPath = tempdir()) 
[08:27:52.667]                   {
[08:27:52.667]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.667]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.667]                       tmpdir = path, fileext = ".rds")
[08:27:52.667]                     save_rds(obj, file)
[08:27:52.667]                   }
[08:27:52.667]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.667]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.667]                   {
[08:27:52.667]                     inherits <- base::inherits
[08:27:52.667]                     invokeRestart <- base::invokeRestart
[08:27:52.667]                     is.null <- base::is.null
[08:27:52.667]                     muffled <- FALSE
[08:27:52.667]                     if (inherits(cond, "message")) {
[08:27:52.667]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.667]                       if (muffled) 
[08:27:52.667]                         invokeRestart("muffleMessage")
[08:27:52.667]                     }
[08:27:52.667]                     else if (inherits(cond, "warning")) {
[08:27:52.667]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.667]                       if (muffled) 
[08:27:52.667]                         invokeRestart("muffleWarning")
[08:27:52.667]                     }
[08:27:52.667]                     else if (inherits(cond, "condition")) {
[08:27:52.667]                       if (!is.null(pattern)) {
[08:27:52.667]                         computeRestarts <- base::computeRestarts
[08:27:52.667]                         grepl <- base::grepl
[08:27:52.667]                         restarts <- computeRestarts(cond)
[08:27:52.667]                         for (restart in restarts) {
[08:27:52.667]                           name <- restart$name
[08:27:52.667]                           if (is.null(name)) 
[08:27:52.667]                             next
[08:27:52.667]                           if (!grepl(pattern, name)) 
[08:27:52.667]                             next
[08:27:52.667]                           invokeRestart(restart)
[08:27:52.667]                           muffled <- TRUE
[08:27:52.667]                           break
[08:27:52.667]                         }
[08:27:52.667]                       }
[08:27:52.667]                     }
[08:27:52.667]                     invisible(muffled)
[08:27:52.667]                   }
[08:27:52.667]                   muffleCondition(cond)
[08:27:52.667]                 })
[08:27:52.667]             }))
[08:27:52.667]             future::FutureResult(value = ...future.value$value, 
[08:27:52.667]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.667]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.667]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.667]                     ...future.globalenv.names))
[08:27:52.667]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.667]         }, condition = base::local({
[08:27:52.667]             c <- base::c
[08:27:52.667]             inherits <- base::inherits
[08:27:52.667]             invokeRestart <- base::invokeRestart
[08:27:52.667]             length <- base::length
[08:27:52.667]             list <- base::list
[08:27:52.667]             seq.int <- base::seq.int
[08:27:52.667]             signalCondition <- base::signalCondition
[08:27:52.667]             sys.calls <- base::sys.calls
[08:27:52.667]             `[[` <- base::`[[`
[08:27:52.667]             `+` <- base::`+`
[08:27:52.667]             `<<-` <- base::`<<-`
[08:27:52.667]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.667]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.667]                   3L)]
[08:27:52.667]             }
[08:27:52.667]             function(cond) {
[08:27:52.667]                 is_error <- inherits(cond, "error")
[08:27:52.667]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.667]                   NULL)
[08:27:52.667]                 if (is_error) {
[08:27:52.667]                   sessionInformation <- function() {
[08:27:52.667]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.667]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.667]                       search = base::search(), system = base::Sys.info())
[08:27:52.667]                   }
[08:27:52.667]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.667]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.667]                     cond$call), session = sessionInformation(), 
[08:27:52.667]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.667]                   signalCondition(cond)
[08:27:52.667]                 }
[08:27:52.667]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.667]                 "immediateCondition"))) {
[08:27:52.667]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.667]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.667]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.667]                   if (TRUE && !signal) {
[08:27:52.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.667]                     {
[08:27:52.667]                       inherits <- base::inherits
[08:27:52.667]                       invokeRestart <- base::invokeRestart
[08:27:52.667]                       is.null <- base::is.null
[08:27:52.667]                       muffled <- FALSE
[08:27:52.667]                       if (inherits(cond, "message")) {
[08:27:52.667]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.667]                         if (muffled) 
[08:27:52.667]                           invokeRestart("muffleMessage")
[08:27:52.667]                       }
[08:27:52.667]                       else if (inherits(cond, "warning")) {
[08:27:52.667]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.667]                         if (muffled) 
[08:27:52.667]                           invokeRestart("muffleWarning")
[08:27:52.667]                       }
[08:27:52.667]                       else if (inherits(cond, "condition")) {
[08:27:52.667]                         if (!is.null(pattern)) {
[08:27:52.667]                           computeRestarts <- base::computeRestarts
[08:27:52.667]                           grepl <- base::grepl
[08:27:52.667]                           restarts <- computeRestarts(cond)
[08:27:52.667]                           for (restart in restarts) {
[08:27:52.667]                             name <- restart$name
[08:27:52.667]                             if (is.null(name)) 
[08:27:52.667]                               next
[08:27:52.667]                             if (!grepl(pattern, name)) 
[08:27:52.667]                               next
[08:27:52.667]                             invokeRestart(restart)
[08:27:52.667]                             muffled <- TRUE
[08:27:52.667]                             break
[08:27:52.667]                           }
[08:27:52.667]                         }
[08:27:52.667]                       }
[08:27:52.667]                       invisible(muffled)
[08:27:52.667]                     }
[08:27:52.667]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.667]                   }
[08:27:52.667]                 }
[08:27:52.667]                 else {
[08:27:52.667]                   if (TRUE) {
[08:27:52.667]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.667]                     {
[08:27:52.667]                       inherits <- base::inherits
[08:27:52.667]                       invokeRestart <- base::invokeRestart
[08:27:52.667]                       is.null <- base::is.null
[08:27:52.667]                       muffled <- FALSE
[08:27:52.667]                       if (inherits(cond, "message")) {
[08:27:52.667]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.667]                         if (muffled) 
[08:27:52.667]                           invokeRestart("muffleMessage")
[08:27:52.667]                       }
[08:27:52.667]                       else if (inherits(cond, "warning")) {
[08:27:52.667]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.667]                         if (muffled) 
[08:27:52.667]                           invokeRestart("muffleWarning")
[08:27:52.667]                       }
[08:27:52.667]                       else if (inherits(cond, "condition")) {
[08:27:52.667]                         if (!is.null(pattern)) {
[08:27:52.667]                           computeRestarts <- base::computeRestarts
[08:27:52.667]                           grepl <- base::grepl
[08:27:52.667]                           restarts <- computeRestarts(cond)
[08:27:52.667]                           for (restart in restarts) {
[08:27:52.667]                             name <- restart$name
[08:27:52.667]                             if (is.null(name)) 
[08:27:52.667]                               next
[08:27:52.667]                             if (!grepl(pattern, name)) 
[08:27:52.667]                               next
[08:27:52.667]                             invokeRestart(restart)
[08:27:52.667]                             muffled <- TRUE
[08:27:52.667]                             break
[08:27:52.667]                           }
[08:27:52.667]                         }
[08:27:52.667]                       }
[08:27:52.667]                       invisible(muffled)
[08:27:52.667]                     }
[08:27:52.667]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.667]                   }
[08:27:52.667]                 }
[08:27:52.667]             }
[08:27:52.667]         }))
[08:27:52.667]     }, error = function(ex) {
[08:27:52.667]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.667]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.667]                 ...future.rng), started = ...future.startTime, 
[08:27:52.667]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.667]             version = "1.8"), class = "FutureResult")
[08:27:52.667]     }, finally = {
[08:27:52.667]         if (!identical(...future.workdir, getwd())) 
[08:27:52.667]             setwd(...future.workdir)
[08:27:52.667]         {
[08:27:52.667]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.667]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.667]             }
[08:27:52.667]             base::options(...future.oldOptions)
[08:27:52.667]             if (.Platform$OS.type == "windows") {
[08:27:52.667]                 old_names <- names(...future.oldEnvVars)
[08:27:52.667]                 envs <- base::Sys.getenv()
[08:27:52.667]                 names <- names(envs)
[08:27:52.667]                 common <- intersect(names, old_names)
[08:27:52.667]                 added <- setdiff(names, old_names)
[08:27:52.667]                 removed <- setdiff(old_names, names)
[08:27:52.667]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.667]                   envs[common]]
[08:27:52.667]                 NAMES <- toupper(changed)
[08:27:52.667]                 args <- list()
[08:27:52.667]                 for (kk in seq_along(NAMES)) {
[08:27:52.667]                   name <- changed[[kk]]
[08:27:52.667]                   NAME <- NAMES[[kk]]
[08:27:52.667]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.667]                     next
[08:27:52.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.667]                 }
[08:27:52.667]                 NAMES <- toupper(added)
[08:27:52.667]                 for (kk in seq_along(NAMES)) {
[08:27:52.667]                   name <- added[[kk]]
[08:27:52.667]                   NAME <- NAMES[[kk]]
[08:27:52.667]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.667]                     next
[08:27:52.667]                   args[[name]] <- ""
[08:27:52.667]                 }
[08:27:52.667]                 NAMES <- toupper(removed)
[08:27:52.667]                 for (kk in seq_along(NAMES)) {
[08:27:52.667]                   name <- removed[[kk]]
[08:27:52.667]                   NAME <- NAMES[[kk]]
[08:27:52.667]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.667]                     next
[08:27:52.667]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.667]                 }
[08:27:52.667]                 if (length(args) > 0) 
[08:27:52.667]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.667]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.667]             }
[08:27:52.667]             else {
[08:27:52.667]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.667]             }
[08:27:52.667]             {
[08:27:52.667]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.667]                   0L) {
[08:27:52.667]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.667]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.667]                   base::options(opts)
[08:27:52.667]                 }
[08:27:52.667]                 {
[08:27:52.667]                   {
[08:27:52.667]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.667]                     NULL
[08:27:52.667]                   }
[08:27:52.667]                   options(future.plan = NULL)
[08:27:52.667]                   if (is.na(NA_character_)) 
[08:27:52.667]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.667]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.667]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.667]                     .init = FALSE)
[08:27:52.667]                 }
[08:27:52.667]             }
[08:27:52.667]         }
[08:27:52.667]     })
[08:27:52.667]     if (TRUE) {
[08:27:52.667]         base::sink(type = "output", split = FALSE)
[08:27:52.667]         if (TRUE) {
[08:27:52.667]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.667]         }
[08:27:52.667]         else {
[08:27:52.667]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.667]         }
[08:27:52.667]         base::close(...future.stdout)
[08:27:52.667]         ...future.stdout <- NULL
[08:27:52.667]     }
[08:27:52.667]     ...future.result$conditions <- ...future.conditions
[08:27:52.667]     ...future.result$finished <- base::Sys.time()
[08:27:52.667]     ...future.result
[08:27:52.667] }
[08:27:52.669] requestCore(): workers = 2
[08:27:52.672] MulticoreFuture started
[08:27:52.673] - Launch lazy future ... done
[08:27:52.673] run() for ‘MulticoreFuture’ ... done
[08:27:52.673] getGlobalsAndPackages() ...
[08:27:52.673] Searching for globals...
[08:27:52.674] plan(): Setting new future strategy stack:
[08:27:52.674] 
[08:27:52.675] Searching for globals ... DONE
[08:27:52.674] List of future strategies:
[08:27:52.674] 1. sequential:
[08:27:52.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.674]    - tweaked: FALSE
[08:27:52.674]    - call: NULL
[08:27:52.675] - globals: [0] <none>
[08:27:52.675] getGlobalsAndPackages() ... DONE
[08:27:52.675] plan(): nbrOfWorkers() = 1
[08:27:52.675] run() for ‘Future’ ...
[08:27:52.676] - state: ‘created’
[08:27:52.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.677] plan(): Setting new future strategy stack:
[08:27:52.677] List of future strategies:
[08:27:52.677] 1. multicore:
[08:27:52.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.677]    - tweaked: FALSE
[08:27:52.677]    - call: plan(strategy)
[08:27:52.679] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.679] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.680] plan(): nbrOfWorkers() = 2
[08:27:52.680]   - Field: ‘label’
[08:27:52.680]   - Field: ‘local’
[08:27:52.680]   - Field: ‘owner’
[08:27:52.680]   - Field: ‘envir’
[08:27:52.680]   - Field: ‘workers’
[08:27:52.680]   - Field: ‘packages’
[08:27:52.680]   - Field: ‘gc’
[08:27:52.681]   - Field: ‘job’
[08:27:52.681]   - Field: ‘conditions’
[08:27:52.681]   - Field: ‘expr’
[08:27:52.681]   - Field: ‘uuid’
[08:27:52.681]   - Field: ‘seed’
[08:27:52.681]   - Field: ‘version’
[08:27:52.682]   - Field: ‘result’
[08:27:52.682]   - Field: ‘asynchronous’
[08:27:52.682]   - Field: ‘calls’
[08:27:52.682]   - Field: ‘globals’
[08:27:52.682]   - Field: ‘stdout’
[08:27:52.682]   - Field: ‘earlySignal’
[08:27:52.682]   - Field: ‘lazy’
[08:27:52.682]   - Field: ‘state’
[08:27:52.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.683] - Launch lazy future ...
[08:27:52.683] Packages needed by the future expression (n = 0): <none>
[08:27:52.684] Packages needed by future strategies (n = 0): <none>
[08:27:52.684] {
[08:27:52.684]     {
[08:27:52.684]         {
[08:27:52.684]             ...future.startTime <- base::Sys.time()
[08:27:52.684]             {
[08:27:52.684]                 {
[08:27:52.684]                   {
[08:27:52.684]                     {
[08:27:52.684]                       base::local({
[08:27:52.684]                         has_future <- base::requireNamespace("future", 
[08:27:52.684]                           quietly = TRUE)
[08:27:52.684]                         if (has_future) {
[08:27:52.684]                           ns <- base::getNamespace("future")
[08:27:52.684]                           version <- ns[[".package"]][["version"]]
[08:27:52.684]                           if (is.null(version)) 
[08:27:52.684]                             version <- utils::packageVersion("future")
[08:27:52.684]                         }
[08:27:52.684]                         else {
[08:27:52.684]                           version <- NULL
[08:27:52.684]                         }
[08:27:52.684]                         if (!has_future || version < "1.8.0") {
[08:27:52.684]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.684]                             "", base::R.version$version.string), 
[08:27:52.684]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.684]                               "release", "version")], collapse = " "), 
[08:27:52.684]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.684]                             info)
[08:27:52.684]                           info <- base::paste(info, collapse = "; ")
[08:27:52.684]                           if (!has_future) {
[08:27:52.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.684]                               info)
[08:27:52.684]                           }
[08:27:52.684]                           else {
[08:27:52.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.684]                               info, version)
[08:27:52.684]                           }
[08:27:52.684]                           base::stop(msg)
[08:27:52.684]                         }
[08:27:52.684]                       })
[08:27:52.684]                     }
[08:27:52.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.684]                     base::options(mc.cores = 1L)
[08:27:52.684]                   }
[08:27:52.684]                   ...future.strategy.old <- future::plan("list")
[08:27:52.684]                   options(future.plan = NULL)
[08:27:52.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.684]                 }
[08:27:52.684]                 ...future.workdir <- getwd()
[08:27:52.684]             }
[08:27:52.684]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.684]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.684]         }
[08:27:52.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.684]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.684]             base::names(...future.oldOptions))
[08:27:52.684]     }
[08:27:52.684]     if (FALSE) {
[08:27:52.684]     }
[08:27:52.684]     else {
[08:27:52.684]         if (TRUE) {
[08:27:52.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.684]                 open = "w")
[08:27:52.684]         }
[08:27:52.684]         else {
[08:27:52.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.684]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.684]         }
[08:27:52.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.684]             base::sink(type = "output", split = FALSE)
[08:27:52.684]             base::close(...future.stdout)
[08:27:52.684]         }, add = TRUE)
[08:27:52.684]     }
[08:27:52.684]     ...future.frame <- base::sys.nframe()
[08:27:52.684]     ...future.conditions <- base::list()
[08:27:52.684]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.684]     if (FALSE) {
[08:27:52.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.684]     }
[08:27:52.684]     ...future.result <- base::tryCatch({
[08:27:52.684]         base::withCallingHandlers({
[08:27:52.684]             ...future.value <- base::withVisible(base::local({
[08:27:52.684]                 withCallingHandlers({
[08:27:52.684]                   NULL
[08:27:52.684]                 }, immediateCondition = function(cond) {
[08:27:52.684]                   save_rds <- function (object, pathname, ...) 
[08:27:52.684]                   {
[08:27:52.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.684]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.684]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.684]                         fi_tmp[["mtime"]])
[08:27:52.684]                     }
[08:27:52.684]                     tryCatch({
[08:27:52.684]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.684]                     }, error = function(ex) {
[08:27:52.684]                       msg <- conditionMessage(ex)
[08:27:52.684]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.684]                         fi_tmp[["mtime"]], msg)
[08:27:52.684]                       ex$message <- msg
[08:27:52.684]                       stop(ex)
[08:27:52.684]                     })
[08:27:52.684]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.684]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.684]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.684]                       fi <- file.info(pathname)
[08:27:52.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.684]                         fi[["size"]], fi[["mtime"]])
[08:27:52.684]                       stop(msg)
[08:27:52.684]                     }
[08:27:52.684]                     invisible(pathname)
[08:27:52.684]                   }
[08:27:52.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.684]                     rootPath = tempdir()) 
[08:27:52.684]                   {
[08:27:52.684]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.684]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.684]                       tmpdir = path, fileext = ".rds")
[08:27:52.684]                     save_rds(obj, file)
[08:27:52.684]                   }
[08:27:52.684]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.684]                   {
[08:27:52.684]                     inherits <- base::inherits
[08:27:52.684]                     invokeRestart <- base::invokeRestart
[08:27:52.684]                     is.null <- base::is.null
[08:27:52.684]                     muffled <- FALSE
[08:27:52.684]                     if (inherits(cond, "message")) {
[08:27:52.684]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.684]                       if (muffled) 
[08:27:52.684]                         invokeRestart("muffleMessage")
[08:27:52.684]                     }
[08:27:52.684]                     else if (inherits(cond, "warning")) {
[08:27:52.684]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.684]                       if (muffled) 
[08:27:52.684]                         invokeRestart("muffleWarning")
[08:27:52.684]                     }
[08:27:52.684]                     else if (inherits(cond, "condition")) {
[08:27:52.684]                       if (!is.null(pattern)) {
[08:27:52.684]                         computeRestarts <- base::computeRestarts
[08:27:52.684]                         grepl <- base::grepl
[08:27:52.684]                         restarts <- computeRestarts(cond)
[08:27:52.684]                         for (restart in restarts) {
[08:27:52.684]                           name <- restart$name
[08:27:52.684]                           if (is.null(name)) 
[08:27:52.684]                             next
[08:27:52.684]                           if (!grepl(pattern, name)) 
[08:27:52.684]                             next
[08:27:52.684]                           invokeRestart(restart)
[08:27:52.684]                           muffled <- TRUE
[08:27:52.684]                           break
[08:27:52.684]                         }
[08:27:52.684]                       }
[08:27:52.684]                     }
[08:27:52.684]                     invisible(muffled)
[08:27:52.684]                   }
[08:27:52.684]                   muffleCondition(cond)
[08:27:52.684]                 })
[08:27:52.684]             }))
[08:27:52.684]             future::FutureResult(value = ...future.value$value, 
[08:27:52.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.684]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.684]                     ...future.globalenv.names))
[08:27:52.684]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.684]         }, condition = base::local({
[08:27:52.684]             c <- base::c
[08:27:52.684]             inherits <- base::inherits
[08:27:52.684]             invokeRestart <- base::invokeRestart
[08:27:52.684]             length <- base::length
[08:27:52.684]             list <- base::list
[08:27:52.684]             seq.int <- base::seq.int
[08:27:52.684]             signalCondition <- base::signalCondition
[08:27:52.684]             sys.calls <- base::sys.calls
[08:27:52.684]             `[[` <- base::`[[`
[08:27:52.684]             `+` <- base::`+`
[08:27:52.684]             `<<-` <- base::`<<-`
[08:27:52.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.684]                   3L)]
[08:27:52.684]             }
[08:27:52.684]             function(cond) {
[08:27:52.684]                 is_error <- inherits(cond, "error")
[08:27:52.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.684]                   NULL)
[08:27:52.684]                 if (is_error) {
[08:27:52.684]                   sessionInformation <- function() {
[08:27:52.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.684]                       search = base::search(), system = base::Sys.info())
[08:27:52.684]                   }
[08:27:52.684]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.684]                     cond$call), session = sessionInformation(), 
[08:27:52.684]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.684]                   signalCondition(cond)
[08:27:52.684]                 }
[08:27:52.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.684]                 "immediateCondition"))) {
[08:27:52.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.684]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.684]                   if (TRUE && !signal) {
[08:27:52.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.684]                     {
[08:27:52.684]                       inherits <- base::inherits
[08:27:52.684]                       invokeRestart <- base::invokeRestart
[08:27:52.684]                       is.null <- base::is.null
[08:27:52.684]                       muffled <- FALSE
[08:27:52.684]                       if (inherits(cond, "message")) {
[08:27:52.684]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.684]                         if (muffled) 
[08:27:52.684]                           invokeRestart("muffleMessage")
[08:27:52.684]                       }
[08:27:52.684]                       else if (inherits(cond, "warning")) {
[08:27:52.684]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.684]                         if (muffled) 
[08:27:52.684]                           invokeRestart("muffleWarning")
[08:27:52.684]                       }
[08:27:52.684]                       else if (inherits(cond, "condition")) {
[08:27:52.684]                         if (!is.null(pattern)) {
[08:27:52.684]                           computeRestarts <- base::computeRestarts
[08:27:52.684]                           grepl <- base::grepl
[08:27:52.684]                           restarts <- computeRestarts(cond)
[08:27:52.684]                           for (restart in restarts) {
[08:27:52.684]                             name <- restart$name
[08:27:52.684]                             if (is.null(name)) 
[08:27:52.684]                               next
[08:27:52.684]                             if (!grepl(pattern, name)) 
[08:27:52.684]                               next
[08:27:52.684]                             invokeRestart(restart)
[08:27:52.684]                             muffled <- TRUE
[08:27:52.684]                             break
[08:27:52.684]                           }
[08:27:52.684]                         }
[08:27:52.684]                       }
[08:27:52.684]                       invisible(muffled)
[08:27:52.684]                     }
[08:27:52.684]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.684]                   }
[08:27:52.684]                 }
[08:27:52.684]                 else {
[08:27:52.684]                   if (TRUE) {
[08:27:52.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.684]                     {
[08:27:52.684]                       inherits <- base::inherits
[08:27:52.684]                       invokeRestart <- base::invokeRestart
[08:27:52.684]                       is.null <- base::is.null
[08:27:52.684]                       muffled <- FALSE
[08:27:52.684]                       if (inherits(cond, "message")) {
[08:27:52.684]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.684]                         if (muffled) 
[08:27:52.684]                           invokeRestart("muffleMessage")
[08:27:52.684]                       }
[08:27:52.684]                       else if (inherits(cond, "warning")) {
[08:27:52.684]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.684]                         if (muffled) 
[08:27:52.684]                           invokeRestart("muffleWarning")
[08:27:52.684]                       }
[08:27:52.684]                       else if (inherits(cond, "condition")) {
[08:27:52.684]                         if (!is.null(pattern)) {
[08:27:52.684]                           computeRestarts <- base::computeRestarts
[08:27:52.684]                           grepl <- base::grepl
[08:27:52.684]                           restarts <- computeRestarts(cond)
[08:27:52.684]                           for (restart in restarts) {
[08:27:52.684]                             name <- restart$name
[08:27:52.684]                             if (is.null(name)) 
[08:27:52.684]                               next
[08:27:52.684]                             if (!grepl(pattern, name)) 
[08:27:52.684]                               next
[08:27:52.684]                             invokeRestart(restart)
[08:27:52.684]                             muffled <- TRUE
[08:27:52.684]                             break
[08:27:52.684]                           }
[08:27:52.684]                         }
[08:27:52.684]                       }
[08:27:52.684]                       invisible(muffled)
[08:27:52.684]                     }
[08:27:52.684]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.684]                   }
[08:27:52.684]                 }
[08:27:52.684]             }
[08:27:52.684]         }))
[08:27:52.684]     }, error = function(ex) {
[08:27:52.684]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.684]                 ...future.rng), started = ...future.startTime, 
[08:27:52.684]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.684]             version = "1.8"), class = "FutureResult")
[08:27:52.684]     }, finally = {
[08:27:52.684]         if (!identical(...future.workdir, getwd())) 
[08:27:52.684]             setwd(...future.workdir)
[08:27:52.684]         {
[08:27:52.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.684]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.684]             }
[08:27:52.684]             base::options(...future.oldOptions)
[08:27:52.684]             if (.Platform$OS.type == "windows") {
[08:27:52.684]                 old_names <- names(...future.oldEnvVars)
[08:27:52.684]                 envs <- base::Sys.getenv()
[08:27:52.684]                 names <- names(envs)
[08:27:52.684]                 common <- intersect(names, old_names)
[08:27:52.684]                 added <- setdiff(names, old_names)
[08:27:52.684]                 removed <- setdiff(old_names, names)
[08:27:52.684]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.684]                   envs[common]]
[08:27:52.684]                 NAMES <- toupper(changed)
[08:27:52.684]                 args <- list()
[08:27:52.684]                 for (kk in seq_along(NAMES)) {
[08:27:52.684]                   name <- changed[[kk]]
[08:27:52.684]                   NAME <- NAMES[[kk]]
[08:27:52.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.684]                     next
[08:27:52.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.684]                 }
[08:27:52.684]                 NAMES <- toupper(added)
[08:27:52.684]                 for (kk in seq_along(NAMES)) {
[08:27:52.684]                   name <- added[[kk]]
[08:27:52.684]                   NAME <- NAMES[[kk]]
[08:27:52.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.684]                     next
[08:27:52.684]                   args[[name]] <- ""
[08:27:52.684]                 }
[08:27:52.684]                 NAMES <- toupper(removed)
[08:27:52.684]                 for (kk in seq_along(NAMES)) {
[08:27:52.684]                   name <- removed[[kk]]
[08:27:52.684]                   NAME <- NAMES[[kk]]
[08:27:52.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.684]                     next
[08:27:52.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.684]                 }
[08:27:52.684]                 if (length(args) > 0) 
[08:27:52.684]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.684]             }
[08:27:52.684]             else {
[08:27:52.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.684]             }
[08:27:52.684]             {
[08:27:52.684]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.684]                   0L) {
[08:27:52.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.684]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.684]                   base::options(opts)
[08:27:52.684]                 }
[08:27:52.684]                 {
[08:27:52.684]                   {
[08:27:52.684]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.684]                     NULL
[08:27:52.684]                   }
[08:27:52.684]                   options(future.plan = NULL)
[08:27:52.684]                   if (is.na(NA_character_)) 
[08:27:52.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.684]                     .init = FALSE)
[08:27:52.684]                 }
[08:27:52.684]             }
[08:27:52.684]         }
[08:27:52.684]     })
[08:27:52.684]     if (TRUE) {
[08:27:52.684]         base::sink(type = "output", split = FALSE)
[08:27:52.684]         if (TRUE) {
[08:27:52.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.684]         }
[08:27:52.684]         else {
[08:27:52.684]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.684]         }
[08:27:52.684]         base::close(...future.stdout)
[08:27:52.684]         ...future.stdout <- NULL
[08:27:52.684]     }
[08:27:52.684]     ...future.result$conditions <- ...future.conditions
[08:27:52.684]     ...future.result$finished <- base::Sys.time()
[08:27:52.684]     ...future.result
[08:27:52.684] }
[08:27:52.688] requestCore(): workers = 2
[08:27:52.691] MulticoreFuture started
[08:27:52.691] - Launch lazy future ... done
[08:27:52.692] run() for ‘MulticoreFuture’ ... done
[08:27:52.692] plan(): Setting new future strategy stack:
[08:27:52.693] getGlobalsAndPackages() ...
[08:27:52.693] Searching for globals...
[08:27:52.693] List of future strategies:
[08:27:52.693] 1. sequential:
[08:27:52.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.693]    - tweaked: FALSE
[08:27:52.693]    - call: NULL
[08:27:52.694] plan(): nbrOfWorkers() = 1
[08:27:52.694] - globals found: [1] ‘{’
[08:27:52.694] Searching for globals ... DONE
[08:27:52.695] Resolving globals: FALSE
[08:27:52.695] 
[08:27:52.695] 
[08:27:52.695] getGlobalsAndPackages() ... DONE
[08:27:52.696] plan(): Setting new future strategy stack:
[08:27:52.696] run() for ‘Future’ ...
[08:27:52.696] - state: ‘created’
[08:27:52.696] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.696] List of future strategies:
[08:27:52.696] 1. multicore:
[08:27:52.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.696]    - tweaked: FALSE
[08:27:52.696]    - call: plan(strategy)
[08:27:52.699] plan(): nbrOfWorkers() = 2
[08:27:52.699] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.700] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.700]   - Field: ‘label’
[08:27:52.700]   - Field: ‘local’
[08:27:52.700]   - Field: ‘owner’
[08:27:52.700]   - Field: ‘envir’
[08:27:52.700]   - Field: ‘workers’
[08:27:52.701]   - Field: ‘packages’
[08:27:52.701]   - Field: ‘gc’
[08:27:52.701]   - Field: ‘job’
[08:27:52.701]   - Field: ‘conditions’
[08:27:52.701]   - Field: ‘expr’
[08:27:52.701]   - Field: ‘uuid’
[08:27:52.701]   - Field: ‘seed’
[08:27:52.702]   - Field: ‘version’
[08:27:52.702]   - Field: ‘result’
[08:27:52.702]   - Field: ‘asynchronous’
[08:27:52.702]   - Field: ‘calls’
[08:27:52.702]   - Field: ‘globals’
[08:27:52.702]   - Field: ‘stdout’
[08:27:52.702]   - Field: ‘earlySignal’
[08:27:52.702]   - Field: ‘lazy’
[08:27:52.703]   - Field: ‘state’
[08:27:52.703] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.703] - Launch lazy future ...
[08:27:52.703] Packages needed by the future expression (n = 0): <none>
[08:27:52.704] Packages needed by future strategies (n = 0): <none>
[08:27:52.705] {
[08:27:52.705]     {
[08:27:52.705]         {
[08:27:52.705]             ...future.startTime <- base::Sys.time()
[08:27:52.705]             {
[08:27:52.705]                 {
[08:27:52.705]                   {
[08:27:52.705]                     {
[08:27:52.705]                       base::local({
[08:27:52.705]                         has_future <- base::requireNamespace("future", 
[08:27:52.705]                           quietly = TRUE)
[08:27:52.705]                         if (has_future) {
[08:27:52.705]                           ns <- base::getNamespace("future")
[08:27:52.705]                           version <- ns[[".package"]][["version"]]
[08:27:52.705]                           if (is.null(version)) 
[08:27:52.705]                             version <- utils::packageVersion("future")
[08:27:52.705]                         }
[08:27:52.705]                         else {
[08:27:52.705]                           version <- NULL
[08:27:52.705]                         }
[08:27:52.705]                         if (!has_future || version < "1.8.0") {
[08:27:52.705]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.705]                             "", base::R.version$version.string), 
[08:27:52.705]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.705]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.705]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.705]                               "release", "version")], collapse = " "), 
[08:27:52.705]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.705]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.705]                             info)
[08:27:52.705]                           info <- base::paste(info, collapse = "; ")
[08:27:52.705]                           if (!has_future) {
[08:27:52.705]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.705]                               info)
[08:27:52.705]                           }
[08:27:52.705]                           else {
[08:27:52.705]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.705]                               info, version)
[08:27:52.705]                           }
[08:27:52.705]                           base::stop(msg)
[08:27:52.705]                         }
[08:27:52.705]                       })
[08:27:52.705]                     }
[08:27:52.705]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.705]                     base::options(mc.cores = 1L)
[08:27:52.705]                   }
[08:27:52.705]                   ...future.strategy.old <- future::plan("list")
[08:27:52.705]                   options(future.plan = NULL)
[08:27:52.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.705]                 }
[08:27:52.705]                 ...future.workdir <- getwd()
[08:27:52.705]             }
[08:27:52.705]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.705]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.705]         }
[08:27:52.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.705]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.705]             base::names(...future.oldOptions))
[08:27:52.705]     }
[08:27:52.705]     if (FALSE) {
[08:27:52.705]     }
[08:27:52.705]     else {
[08:27:52.705]         if (TRUE) {
[08:27:52.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.705]                 open = "w")
[08:27:52.705]         }
[08:27:52.705]         else {
[08:27:52.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.705]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.705]         }
[08:27:52.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.705]             base::sink(type = "output", split = FALSE)
[08:27:52.705]             base::close(...future.stdout)
[08:27:52.705]         }, add = TRUE)
[08:27:52.705]     }
[08:27:52.705]     ...future.frame <- base::sys.nframe()
[08:27:52.705]     ...future.conditions <- base::list()
[08:27:52.705]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.705]     if (FALSE) {
[08:27:52.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.705]     }
[08:27:52.705]     ...future.result <- base::tryCatch({
[08:27:52.705]         base::withCallingHandlers({
[08:27:52.705]             ...future.value <- base::withVisible(base::local({
[08:27:52.705]                 withCallingHandlers({
[08:27:52.705]                   {
[08:27:52.705]                     4
[08:27:52.705]                   }
[08:27:52.705]                 }, immediateCondition = function(cond) {
[08:27:52.705]                   save_rds <- function (object, pathname, ...) 
[08:27:52.705]                   {
[08:27:52.705]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.705]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.705]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.705]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.705]                         fi_tmp[["mtime"]])
[08:27:52.705]                     }
[08:27:52.705]                     tryCatch({
[08:27:52.705]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.705]                     }, error = function(ex) {
[08:27:52.705]                       msg <- conditionMessage(ex)
[08:27:52.705]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.705]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.705]                         fi_tmp[["mtime"]], msg)
[08:27:52.705]                       ex$message <- msg
[08:27:52.705]                       stop(ex)
[08:27:52.705]                     })
[08:27:52.705]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.705]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.705]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.705]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.705]                       fi <- file.info(pathname)
[08:27:52.705]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.705]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.705]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.705]                         fi[["size"]], fi[["mtime"]])
[08:27:52.705]                       stop(msg)
[08:27:52.705]                     }
[08:27:52.705]                     invisible(pathname)
[08:27:52.705]                   }
[08:27:52.705]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.705]                     rootPath = tempdir()) 
[08:27:52.705]                   {
[08:27:52.705]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.705]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.705]                       tmpdir = path, fileext = ".rds")
[08:27:52.705]                     save_rds(obj, file)
[08:27:52.705]                   }
[08:27:52.705]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.705]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.705]                   {
[08:27:52.705]                     inherits <- base::inherits
[08:27:52.705]                     invokeRestart <- base::invokeRestart
[08:27:52.705]                     is.null <- base::is.null
[08:27:52.705]                     muffled <- FALSE
[08:27:52.705]                     if (inherits(cond, "message")) {
[08:27:52.705]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.705]                       if (muffled) 
[08:27:52.705]                         invokeRestart("muffleMessage")
[08:27:52.705]                     }
[08:27:52.705]                     else if (inherits(cond, "warning")) {
[08:27:52.705]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.705]                       if (muffled) 
[08:27:52.705]                         invokeRestart("muffleWarning")
[08:27:52.705]                     }
[08:27:52.705]                     else if (inherits(cond, "condition")) {
[08:27:52.705]                       if (!is.null(pattern)) {
[08:27:52.705]                         computeRestarts <- base::computeRestarts
[08:27:52.705]                         grepl <- base::grepl
[08:27:52.705]                         restarts <- computeRestarts(cond)
[08:27:52.705]                         for (restart in restarts) {
[08:27:52.705]                           name <- restart$name
[08:27:52.705]                           if (is.null(name)) 
[08:27:52.705]                             next
[08:27:52.705]                           if (!grepl(pattern, name)) 
[08:27:52.705]                             next
[08:27:52.705]                           invokeRestart(restart)
[08:27:52.705]                           muffled <- TRUE
[08:27:52.705]                           break
[08:27:52.705]                         }
[08:27:52.705]                       }
[08:27:52.705]                     }
[08:27:52.705]                     invisible(muffled)
[08:27:52.705]                   }
[08:27:52.705]                   muffleCondition(cond)
[08:27:52.705]                 })
[08:27:52.705]             }))
[08:27:52.705]             future::FutureResult(value = ...future.value$value, 
[08:27:52.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.705]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.705]                     ...future.globalenv.names))
[08:27:52.705]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.705]         }, condition = base::local({
[08:27:52.705]             c <- base::c
[08:27:52.705]             inherits <- base::inherits
[08:27:52.705]             invokeRestart <- base::invokeRestart
[08:27:52.705]             length <- base::length
[08:27:52.705]             list <- base::list
[08:27:52.705]             seq.int <- base::seq.int
[08:27:52.705]             signalCondition <- base::signalCondition
[08:27:52.705]             sys.calls <- base::sys.calls
[08:27:52.705]             `[[` <- base::`[[`
[08:27:52.705]             `+` <- base::`+`
[08:27:52.705]             `<<-` <- base::`<<-`
[08:27:52.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.705]                   3L)]
[08:27:52.705]             }
[08:27:52.705]             function(cond) {
[08:27:52.705]                 is_error <- inherits(cond, "error")
[08:27:52.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.705]                   NULL)
[08:27:52.705]                 if (is_error) {
[08:27:52.705]                   sessionInformation <- function() {
[08:27:52.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.705]                       search = base::search(), system = base::Sys.info())
[08:27:52.705]                   }
[08:27:52.705]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.705]                     cond$call), session = sessionInformation(), 
[08:27:52.705]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.705]                   signalCondition(cond)
[08:27:52.705]                 }
[08:27:52.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.705]                 "immediateCondition"))) {
[08:27:52.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.705]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.705]                   if (TRUE && !signal) {
[08:27:52.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.705]                     {
[08:27:52.705]                       inherits <- base::inherits
[08:27:52.705]                       invokeRestart <- base::invokeRestart
[08:27:52.705]                       is.null <- base::is.null
[08:27:52.705]                       muffled <- FALSE
[08:27:52.705]                       if (inherits(cond, "message")) {
[08:27:52.705]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.705]                         if (muffled) 
[08:27:52.705]                           invokeRestart("muffleMessage")
[08:27:52.705]                       }
[08:27:52.705]                       else if (inherits(cond, "warning")) {
[08:27:52.705]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.705]                         if (muffled) 
[08:27:52.705]                           invokeRestart("muffleWarning")
[08:27:52.705]                       }
[08:27:52.705]                       else if (inherits(cond, "condition")) {
[08:27:52.705]                         if (!is.null(pattern)) {
[08:27:52.705]                           computeRestarts <- base::computeRestarts
[08:27:52.705]                           grepl <- base::grepl
[08:27:52.705]                           restarts <- computeRestarts(cond)
[08:27:52.705]                           for (restart in restarts) {
[08:27:52.705]                             name <- restart$name
[08:27:52.705]                             if (is.null(name)) 
[08:27:52.705]                               next
[08:27:52.705]                             if (!grepl(pattern, name)) 
[08:27:52.705]                               next
[08:27:52.705]                             invokeRestart(restart)
[08:27:52.705]                             muffled <- TRUE
[08:27:52.705]                             break
[08:27:52.705]                           }
[08:27:52.705]                         }
[08:27:52.705]                       }
[08:27:52.705]                       invisible(muffled)
[08:27:52.705]                     }
[08:27:52.705]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.705]                   }
[08:27:52.705]                 }
[08:27:52.705]                 else {
[08:27:52.705]                   if (TRUE) {
[08:27:52.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.705]                     {
[08:27:52.705]                       inherits <- base::inherits
[08:27:52.705]                       invokeRestart <- base::invokeRestart
[08:27:52.705]                       is.null <- base::is.null
[08:27:52.705]                       muffled <- FALSE
[08:27:52.705]                       if (inherits(cond, "message")) {
[08:27:52.705]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.705]                         if (muffled) 
[08:27:52.705]                           invokeRestart("muffleMessage")
[08:27:52.705]                       }
[08:27:52.705]                       else if (inherits(cond, "warning")) {
[08:27:52.705]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.705]                         if (muffled) 
[08:27:52.705]                           invokeRestart("muffleWarning")
[08:27:52.705]                       }
[08:27:52.705]                       else if (inherits(cond, "condition")) {
[08:27:52.705]                         if (!is.null(pattern)) {
[08:27:52.705]                           computeRestarts <- base::computeRestarts
[08:27:52.705]                           grepl <- base::grepl
[08:27:52.705]                           restarts <- computeRestarts(cond)
[08:27:52.705]                           for (restart in restarts) {
[08:27:52.705]                             name <- restart$name
[08:27:52.705]                             if (is.null(name)) 
[08:27:52.705]                               next
[08:27:52.705]                             if (!grepl(pattern, name)) 
[08:27:52.705]                               next
[08:27:52.705]                             invokeRestart(restart)
[08:27:52.705]                             muffled <- TRUE
[08:27:52.705]                             break
[08:27:52.705]                           }
[08:27:52.705]                         }
[08:27:52.705]                       }
[08:27:52.705]                       invisible(muffled)
[08:27:52.705]                     }
[08:27:52.705]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.705]                   }
[08:27:52.705]                 }
[08:27:52.705]             }
[08:27:52.705]         }))
[08:27:52.705]     }, error = function(ex) {
[08:27:52.705]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.705]                 ...future.rng), started = ...future.startTime, 
[08:27:52.705]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.705]             version = "1.8"), class = "FutureResult")
[08:27:52.705]     }, finally = {
[08:27:52.705]         if (!identical(...future.workdir, getwd())) 
[08:27:52.705]             setwd(...future.workdir)
[08:27:52.705]         {
[08:27:52.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.705]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.705]             }
[08:27:52.705]             base::options(...future.oldOptions)
[08:27:52.705]             if (.Platform$OS.type == "windows") {
[08:27:52.705]                 old_names <- names(...future.oldEnvVars)
[08:27:52.705]                 envs <- base::Sys.getenv()
[08:27:52.705]                 names <- names(envs)
[08:27:52.705]                 common <- intersect(names, old_names)
[08:27:52.705]                 added <- setdiff(names, old_names)
[08:27:52.705]                 removed <- setdiff(old_names, names)
[08:27:52.705]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.705]                   envs[common]]
[08:27:52.705]                 NAMES <- toupper(changed)
[08:27:52.705]                 args <- list()
[08:27:52.705]                 for (kk in seq_along(NAMES)) {
[08:27:52.705]                   name <- changed[[kk]]
[08:27:52.705]                   NAME <- NAMES[[kk]]
[08:27:52.705]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.705]                     next
[08:27:52.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.705]                 }
[08:27:52.705]                 NAMES <- toupper(added)
[08:27:52.705]                 for (kk in seq_along(NAMES)) {
[08:27:52.705]                   name <- added[[kk]]
[08:27:52.705]                   NAME <- NAMES[[kk]]
[08:27:52.705]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.705]                     next
[08:27:52.705]                   args[[name]] <- ""
[08:27:52.705]                 }
[08:27:52.705]                 NAMES <- toupper(removed)
[08:27:52.705]                 for (kk in seq_along(NAMES)) {
[08:27:52.705]                   name <- removed[[kk]]
[08:27:52.705]                   NAME <- NAMES[[kk]]
[08:27:52.705]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.705]                     next
[08:27:52.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.705]                 }
[08:27:52.705]                 if (length(args) > 0) 
[08:27:52.705]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.705]             }
[08:27:52.705]             else {
[08:27:52.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.705]             }
[08:27:52.705]             {
[08:27:52.705]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.705]                   0L) {
[08:27:52.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.705]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.705]                   base::options(opts)
[08:27:52.705]                 }
[08:27:52.705]                 {
[08:27:52.705]                   {
[08:27:52.705]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.705]                     NULL
[08:27:52.705]                   }
[08:27:52.705]                   options(future.plan = NULL)
[08:27:52.705]                   if (is.na(NA_character_)) 
[08:27:52.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.705]                     .init = FALSE)
[08:27:52.705]                 }
[08:27:52.705]             }
[08:27:52.705]         }
[08:27:52.705]     })
[08:27:52.705]     if (TRUE) {
[08:27:52.705]         base::sink(type = "output", split = FALSE)
[08:27:52.705]         if (TRUE) {
[08:27:52.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.705]         }
[08:27:52.705]         else {
[08:27:52.705]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.705]         }
[08:27:52.705]         base::close(...future.stdout)
[08:27:52.705]         ...future.stdout <- NULL
[08:27:52.705]     }
[08:27:52.705]     ...future.result$conditions <- ...future.conditions
[08:27:52.705]     ...future.result$finished <- base::Sys.time()
[08:27:52.705]     ...future.result
[08:27:52.705] }
[08:27:52.708] requestCore(): workers = 2
[08:27:52.708] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:52.719] result() for MulticoreFuture ...
[08:27:52.720] result() for MulticoreFuture ...
[08:27:52.720] result() for MulticoreFuture ... done
[08:27:52.721] result() for MulticoreFuture ... done
[08:27:52.721] result() for MulticoreFuture ...
[08:27:52.721] result() for MulticoreFuture ... done
[08:27:52.724] MulticoreFuture started
[08:27:52.724] - Launch lazy future ... done
[08:27:52.725] run() for ‘MulticoreFuture’ ... done
[08:27:52.725] plan(): Setting new future strategy stack:
<environment: 0x55d863283958> 
[08:27:52.726] List of future strategies:
[08:27:52.726] 1. sequential:
[08:27:52.726]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.726]    - tweaked: FALSE
[08:27:52.726]    - call: NULL
[08:27:52.727] plan(): nbrOfWorkers() = 1
<environment: 0x55d85ee4af60> 
[08:27:52.730] plan(): Setting new future strategy stack:
[08:27:52.730] List of future strategies:
[08:27:52.730] 1. multicore:
[08:27:52.730]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.730]    - tweaked: FALSE
[08:27:52.730]    - call: plan(strategy)
[08:27:52.734] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:52.736] resolve() on environment ...
[08:27:52.736]  recursive: 0
[08:27:52.737]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:52.738] signalConditionsASAP(numeric, pos=1) ...
[08:27:52.738] - nx: 4
[08:27:52.738] - relay: TRUE
[08:27:52.738] - stdout: TRUE
[08:27:52.739] - signal: TRUE
[08:27:52.739] - resignal: FALSE
[08:27:52.739] - force: TRUE
[08:27:52.739] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.739] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.739]  - until=2
[08:27:52.740]  - relaying element #2
[08:27:52.740] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.740] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.740] signalConditionsASAP(NULL, pos=1) ... done
[08:27:52.740]  length: 3 (resolved future 1)
[08:27:52.740] Future #2
[08:27:52.741] result() for MulticoreFuture ...
[08:27:52.741] result() for MulticoreFuture ... done
[08:27:52.741] result() for MulticoreFuture ...
[08:27:52.741] result() for MulticoreFuture ... done
[08:27:52.741] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:52.741] - nx: 4
[08:27:52.742] - relay: TRUE
[08:27:52.742] - stdout: TRUE
[08:27:52.742] - signal: TRUE
[08:27:52.742] - resignal: FALSE
[08:27:52.742] - force: TRUE
[08:27:52.742] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.742] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.743]  - until=2
[08:27:52.743]  - relaying element #2
[08:27:52.743] result() for MulticoreFuture ...
[08:27:52.743] result() for MulticoreFuture ... done
[08:27:52.743] result() for MulticoreFuture ...
[08:27:52.743] result() for MulticoreFuture ... done
[08:27:52.743] result() for MulticoreFuture ...
[08:27:52.743] result() for MulticoreFuture ... done
[08:27:52.744] result() for MulticoreFuture ...
[08:27:52.744] result() for MulticoreFuture ... done
[08:27:52.744] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.744] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.744] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:52.744]  length: 2 (resolved future 2)
[08:27:52.745] Future #3
[08:27:52.745] result() for MulticoreFuture ...
[08:27:52.746] result() for MulticoreFuture ...
[08:27:52.746] result() for MulticoreFuture ... done
[08:27:52.746] result() for MulticoreFuture ... done
[08:27:52.746] result() for MulticoreFuture ...
[08:27:52.746] result() for MulticoreFuture ... done
[08:27:52.747] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:52.747] - nx: 4
[08:27:52.747] - relay: TRUE
[08:27:52.747] - stdout: TRUE
[08:27:52.747] - signal: TRUE
[08:27:52.747] - resignal: FALSE
[08:27:52.747] - force: TRUE
[08:27:52.747] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.747] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.748]  - until=3
[08:27:52.748]  - relaying element #3
[08:27:52.748] result() for MulticoreFuture ...
[08:27:52.748] result() for MulticoreFuture ... done
[08:27:52.748] result() for MulticoreFuture ...
[08:27:52.748] result() for MulticoreFuture ... done
[08:27:52.748] result() for MulticoreFuture ...
[08:27:52.748] result() for MulticoreFuture ... done
[08:27:52.749] result() for MulticoreFuture ...
[08:27:52.749] result() for MulticoreFuture ... done
[08:27:52.749] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.749] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.749] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:52.749]  length: 1 (resolved future 3)
[08:27:52.750] Future #4
[08:27:52.750] result() for MulticoreFuture ...
[08:27:52.751] result() for MulticoreFuture ...
[08:27:52.751] result() for MulticoreFuture ... done
[08:27:52.751] result() for MulticoreFuture ... done
[08:27:52.751] result() for MulticoreFuture ...
[08:27:52.751] result() for MulticoreFuture ... done
[08:27:52.752] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:52.752] - nx: 4
[08:27:52.752] - relay: TRUE
[08:27:52.752] - stdout: TRUE
[08:27:52.752] - signal: TRUE
[08:27:52.752] - resignal: FALSE
[08:27:52.753] - force: TRUE
[08:27:52.753] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.753] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.753]  - until=4
[08:27:52.753]  - relaying element #4
[08:27:52.753] result() for MulticoreFuture ...
[08:27:52.754] result() for MulticoreFuture ... done
[08:27:52.754] result() for MulticoreFuture ...
[08:27:52.754] result() for MulticoreFuture ... done
[08:27:52.754] result() for MulticoreFuture ...
[08:27:52.754] result() for MulticoreFuture ... done
[08:27:52.754] result() for MulticoreFuture ...
[08:27:52.754] result() for MulticoreFuture ... done
[08:27:52.755] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.755] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.755] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:52.755]  length: 0 (resolved future 4)
[08:27:52.755] Relaying remaining futures
[08:27:52.755] signalConditionsASAP(NULL, pos=0) ...
[08:27:52.755] - nx: 4
[08:27:52.755] - relay: TRUE
[08:27:52.756] - stdout: TRUE
[08:27:52.756] - signal: TRUE
[08:27:52.756] - resignal: FALSE
[08:27:52.756] - force: TRUE
[08:27:52.756] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.756] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:52.756] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.756] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.756] signalConditionsASAP(NULL, pos=0) ... done
[08:27:52.756] resolve() on environment ... DONE
[08:27:52.757] result() for MulticoreFuture ...
[08:27:52.757] result() for MulticoreFuture ... done
[08:27:52.757] result() for MulticoreFuture ...
[08:27:52.757] result() for MulticoreFuture ... done
[08:27:52.757] result() for MulticoreFuture ...
[08:27:52.757] result() for MulticoreFuture ... done
[08:27:52.757] result() for MulticoreFuture ...
[08:27:52.757] result() for MulticoreFuture ... done
[08:27:52.757] result() for MulticoreFuture ...
[08:27:52.758] result() for MulticoreFuture ... done
[08:27:52.758] result() for MulticoreFuture ...
[08:27:52.758] result() for MulticoreFuture ... done
<environment: 0x55d85f5410e8> 
Dimensions: c(2, 1, 3, 1)
[08:27:52.758] getGlobalsAndPackages() ...
[08:27:52.758] Searching for globals...
[08:27:52.759] 
[08:27:52.759] Searching for globals ... DONE
[08:27:52.759] - globals: [0] <none>
[08:27:52.759] getGlobalsAndPackages() ... DONE
[08:27:52.760] run() for ‘Future’ ...
[08:27:52.760] - state: ‘created’
[08:27:52.760] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.762] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.762]   - Field: ‘label’
[08:27:52.762]   - Field: ‘local’
[08:27:52.763]   - Field: ‘owner’
[08:27:52.763]   - Field: ‘envir’
[08:27:52.763]   - Field: ‘workers’
[08:27:52.763]   - Field: ‘packages’
[08:27:52.763]   - Field: ‘gc’
[08:27:52.763]   - Field: ‘job’
[08:27:52.763]   - Field: ‘conditions’
[08:27:52.763]   - Field: ‘expr’
[08:27:52.763]   - Field: ‘uuid’
[08:27:52.763]   - Field: ‘seed’
[08:27:52.764]   - Field: ‘version’
[08:27:52.764]   - Field: ‘result’
[08:27:52.764]   - Field: ‘asynchronous’
[08:27:52.764]   - Field: ‘calls’
[08:27:52.764]   - Field: ‘globals’
[08:27:52.764]   - Field: ‘stdout’
[08:27:52.764]   - Field: ‘earlySignal’
[08:27:52.764]   - Field: ‘lazy’
[08:27:52.764]   - Field: ‘state’
[08:27:52.765] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.765] - Launch lazy future ...
[08:27:52.765] Packages needed by the future expression (n = 0): <none>
[08:27:52.765] Packages needed by future strategies (n = 0): <none>
[08:27:52.766] {
[08:27:52.766]     {
[08:27:52.766]         {
[08:27:52.766]             ...future.startTime <- base::Sys.time()
[08:27:52.766]             {
[08:27:52.766]                 {
[08:27:52.766]                   {
[08:27:52.766]                     {
[08:27:52.766]                       base::local({
[08:27:52.766]                         has_future <- base::requireNamespace("future", 
[08:27:52.766]                           quietly = TRUE)
[08:27:52.766]                         if (has_future) {
[08:27:52.766]                           ns <- base::getNamespace("future")
[08:27:52.766]                           version <- ns[[".package"]][["version"]]
[08:27:52.766]                           if (is.null(version)) 
[08:27:52.766]                             version <- utils::packageVersion("future")
[08:27:52.766]                         }
[08:27:52.766]                         else {
[08:27:52.766]                           version <- NULL
[08:27:52.766]                         }
[08:27:52.766]                         if (!has_future || version < "1.8.0") {
[08:27:52.766]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.766]                             "", base::R.version$version.string), 
[08:27:52.766]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.766]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.766]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.766]                               "release", "version")], collapse = " "), 
[08:27:52.766]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.766]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.766]                             info)
[08:27:52.766]                           info <- base::paste(info, collapse = "; ")
[08:27:52.766]                           if (!has_future) {
[08:27:52.766]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.766]                               info)
[08:27:52.766]                           }
[08:27:52.766]                           else {
[08:27:52.766]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.766]                               info, version)
[08:27:52.766]                           }
[08:27:52.766]                           base::stop(msg)
[08:27:52.766]                         }
[08:27:52.766]                       })
[08:27:52.766]                     }
[08:27:52.766]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.766]                     base::options(mc.cores = 1L)
[08:27:52.766]                   }
[08:27:52.766]                   ...future.strategy.old <- future::plan("list")
[08:27:52.766]                   options(future.plan = NULL)
[08:27:52.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.766]                 }
[08:27:52.766]                 ...future.workdir <- getwd()
[08:27:52.766]             }
[08:27:52.766]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.766]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.766]         }
[08:27:52.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.766]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.766]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.766]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.766]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.766]             base::names(...future.oldOptions))
[08:27:52.766]     }
[08:27:52.766]     if (FALSE) {
[08:27:52.766]     }
[08:27:52.766]     else {
[08:27:52.766]         if (TRUE) {
[08:27:52.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.766]                 open = "w")
[08:27:52.766]         }
[08:27:52.766]         else {
[08:27:52.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.766]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.766]         }
[08:27:52.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.766]             base::sink(type = "output", split = FALSE)
[08:27:52.766]             base::close(...future.stdout)
[08:27:52.766]         }, add = TRUE)
[08:27:52.766]     }
[08:27:52.766]     ...future.frame <- base::sys.nframe()
[08:27:52.766]     ...future.conditions <- base::list()
[08:27:52.766]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.766]     if (FALSE) {
[08:27:52.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.766]     }
[08:27:52.766]     ...future.result <- base::tryCatch({
[08:27:52.766]         base::withCallingHandlers({
[08:27:52.766]             ...future.value <- base::withVisible(base::local({
[08:27:52.766]                 withCallingHandlers({
[08:27:52.766]                   2
[08:27:52.766]                 }, immediateCondition = function(cond) {
[08:27:52.766]                   save_rds <- function (object, pathname, ...) 
[08:27:52.766]                   {
[08:27:52.766]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.766]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.766]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.766]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.766]                         fi_tmp[["mtime"]])
[08:27:52.766]                     }
[08:27:52.766]                     tryCatch({
[08:27:52.766]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.766]                     }, error = function(ex) {
[08:27:52.766]                       msg <- conditionMessage(ex)
[08:27:52.766]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.766]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.766]                         fi_tmp[["mtime"]], msg)
[08:27:52.766]                       ex$message <- msg
[08:27:52.766]                       stop(ex)
[08:27:52.766]                     })
[08:27:52.766]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.766]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.766]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.766]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.766]                       fi <- file.info(pathname)
[08:27:52.766]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.766]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.766]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.766]                         fi[["size"]], fi[["mtime"]])
[08:27:52.766]                       stop(msg)
[08:27:52.766]                     }
[08:27:52.766]                     invisible(pathname)
[08:27:52.766]                   }
[08:27:52.766]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.766]                     rootPath = tempdir()) 
[08:27:52.766]                   {
[08:27:52.766]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.766]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.766]                       tmpdir = path, fileext = ".rds")
[08:27:52.766]                     save_rds(obj, file)
[08:27:52.766]                   }
[08:27:52.766]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.766]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.766]                   {
[08:27:52.766]                     inherits <- base::inherits
[08:27:52.766]                     invokeRestart <- base::invokeRestart
[08:27:52.766]                     is.null <- base::is.null
[08:27:52.766]                     muffled <- FALSE
[08:27:52.766]                     if (inherits(cond, "message")) {
[08:27:52.766]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.766]                       if (muffled) 
[08:27:52.766]                         invokeRestart("muffleMessage")
[08:27:52.766]                     }
[08:27:52.766]                     else if (inherits(cond, "warning")) {
[08:27:52.766]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.766]                       if (muffled) 
[08:27:52.766]                         invokeRestart("muffleWarning")
[08:27:52.766]                     }
[08:27:52.766]                     else if (inherits(cond, "condition")) {
[08:27:52.766]                       if (!is.null(pattern)) {
[08:27:52.766]                         computeRestarts <- base::computeRestarts
[08:27:52.766]                         grepl <- base::grepl
[08:27:52.766]                         restarts <- computeRestarts(cond)
[08:27:52.766]                         for (restart in restarts) {
[08:27:52.766]                           name <- restart$name
[08:27:52.766]                           if (is.null(name)) 
[08:27:52.766]                             next
[08:27:52.766]                           if (!grepl(pattern, name)) 
[08:27:52.766]                             next
[08:27:52.766]                           invokeRestart(restart)
[08:27:52.766]                           muffled <- TRUE
[08:27:52.766]                           break
[08:27:52.766]                         }
[08:27:52.766]                       }
[08:27:52.766]                     }
[08:27:52.766]                     invisible(muffled)
[08:27:52.766]                   }
[08:27:52.766]                   muffleCondition(cond)
[08:27:52.766]                 })
[08:27:52.766]             }))
[08:27:52.766]             future::FutureResult(value = ...future.value$value, 
[08:27:52.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.766]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.766]                     ...future.globalenv.names))
[08:27:52.766]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.766]         }, condition = base::local({
[08:27:52.766]             c <- base::c
[08:27:52.766]             inherits <- base::inherits
[08:27:52.766]             invokeRestart <- base::invokeRestart
[08:27:52.766]             length <- base::length
[08:27:52.766]             list <- base::list
[08:27:52.766]             seq.int <- base::seq.int
[08:27:52.766]             signalCondition <- base::signalCondition
[08:27:52.766]             sys.calls <- base::sys.calls
[08:27:52.766]             `[[` <- base::`[[`
[08:27:52.766]             `+` <- base::`+`
[08:27:52.766]             `<<-` <- base::`<<-`
[08:27:52.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.766]                   3L)]
[08:27:52.766]             }
[08:27:52.766]             function(cond) {
[08:27:52.766]                 is_error <- inherits(cond, "error")
[08:27:52.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.766]                   NULL)
[08:27:52.766]                 if (is_error) {
[08:27:52.766]                   sessionInformation <- function() {
[08:27:52.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.766]                       search = base::search(), system = base::Sys.info())
[08:27:52.766]                   }
[08:27:52.766]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.766]                     cond$call), session = sessionInformation(), 
[08:27:52.766]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.766]                   signalCondition(cond)
[08:27:52.766]                 }
[08:27:52.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.766]                 "immediateCondition"))) {
[08:27:52.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.766]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.766]                   if (TRUE && !signal) {
[08:27:52.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.766]                     {
[08:27:52.766]                       inherits <- base::inherits
[08:27:52.766]                       invokeRestart <- base::invokeRestart
[08:27:52.766]                       is.null <- base::is.null
[08:27:52.766]                       muffled <- FALSE
[08:27:52.766]                       if (inherits(cond, "message")) {
[08:27:52.766]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.766]                         if (muffled) 
[08:27:52.766]                           invokeRestart("muffleMessage")
[08:27:52.766]                       }
[08:27:52.766]                       else if (inherits(cond, "warning")) {
[08:27:52.766]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.766]                         if (muffled) 
[08:27:52.766]                           invokeRestart("muffleWarning")
[08:27:52.766]                       }
[08:27:52.766]                       else if (inherits(cond, "condition")) {
[08:27:52.766]                         if (!is.null(pattern)) {
[08:27:52.766]                           computeRestarts <- base::computeRestarts
[08:27:52.766]                           grepl <- base::grepl
[08:27:52.766]                           restarts <- computeRestarts(cond)
[08:27:52.766]                           for (restart in restarts) {
[08:27:52.766]                             name <- restart$name
[08:27:52.766]                             if (is.null(name)) 
[08:27:52.766]                               next
[08:27:52.766]                             if (!grepl(pattern, name)) 
[08:27:52.766]                               next
[08:27:52.766]                             invokeRestart(restart)
[08:27:52.766]                             muffled <- TRUE
[08:27:52.766]                             break
[08:27:52.766]                           }
[08:27:52.766]                         }
[08:27:52.766]                       }
[08:27:52.766]                       invisible(muffled)
[08:27:52.766]                     }
[08:27:52.766]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.766]                   }
[08:27:52.766]                 }
[08:27:52.766]                 else {
[08:27:52.766]                   if (TRUE) {
[08:27:52.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.766]                     {
[08:27:52.766]                       inherits <- base::inherits
[08:27:52.766]                       invokeRestart <- base::invokeRestart
[08:27:52.766]                       is.null <- base::is.null
[08:27:52.766]                       muffled <- FALSE
[08:27:52.766]                       if (inherits(cond, "message")) {
[08:27:52.766]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.766]                         if (muffled) 
[08:27:52.766]                           invokeRestart("muffleMessage")
[08:27:52.766]                       }
[08:27:52.766]                       else if (inherits(cond, "warning")) {
[08:27:52.766]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.766]                         if (muffled) 
[08:27:52.766]                           invokeRestart("muffleWarning")
[08:27:52.766]                       }
[08:27:52.766]                       else if (inherits(cond, "condition")) {
[08:27:52.766]                         if (!is.null(pattern)) {
[08:27:52.766]                           computeRestarts <- base::computeRestarts
[08:27:52.766]                           grepl <- base::grepl
[08:27:52.766]                           restarts <- computeRestarts(cond)
[08:27:52.766]                           for (restart in restarts) {
[08:27:52.766]                             name <- restart$name
[08:27:52.766]                             if (is.null(name)) 
[08:27:52.766]                               next
[08:27:52.766]                             if (!grepl(pattern, name)) 
[08:27:52.766]                               next
[08:27:52.766]                             invokeRestart(restart)
[08:27:52.766]                             muffled <- TRUE
[08:27:52.766]                             break
[08:27:52.766]                           }
[08:27:52.766]                         }
[08:27:52.766]                       }
[08:27:52.766]                       invisible(muffled)
[08:27:52.766]                     }
[08:27:52.766]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.766]                   }
[08:27:52.766]                 }
[08:27:52.766]             }
[08:27:52.766]         }))
[08:27:52.766]     }, error = function(ex) {
[08:27:52.766]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.766]                 ...future.rng), started = ...future.startTime, 
[08:27:52.766]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.766]             version = "1.8"), class = "FutureResult")
[08:27:52.766]     }, finally = {
[08:27:52.766]         if (!identical(...future.workdir, getwd())) 
[08:27:52.766]             setwd(...future.workdir)
[08:27:52.766]         {
[08:27:52.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.766]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.766]             }
[08:27:52.766]             base::options(...future.oldOptions)
[08:27:52.766]             if (.Platform$OS.type == "windows") {
[08:27:52.766]                 old_names <- names(...future.oldEnvVars)
[08:27:52.766]                 envs <- base::Sys.getenv()
[08:27:52.766]                 names <- names(envs)
[08:27:52.766]                 common <- intersect(names, old_names)
[08:27:52.766]                 added <- setdiff(names, old_names)
[08:27:52.766]                 removed <- setdiff(old_names, names)
[08:27:52.766]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.766]                   envs[common]]
[08:27:52.766]                 NAMES <- toupper(changed)
[08:27:52.766]                 args <- list()
[08:27:52.766]                 for (kk in seq_along(NAMES)) {
[08:27:52.766]                   name <- changed[[kk]]
[08:27:52.766]                   NAME <- NAMES[[kk]]
[08:27:52.766]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.766]                     next
[08:27:52.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.766]                 }
[08:27:52.766]                 NAMES <- toupper(added)
[08:27:52.766]                 for (kk in seq_along(NAMES)) {
[08:27:52.766]                   name <- added[[kk]]
[08:27:52.766]                   NAME <- NAMES[[kk]]
[08:27:52.766]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.766]                     next
[08:27:52.766]                   args[[name]] <- ""
[08:27:52.766]                 }
[08:27:52.766]                 NAMES <- toupper(removed)
[08:27:52.766]                 for (kk in seq_along(NAMES)) {
[08:27:52.766]                   name <- removed[[kk]]
[08:27:52.766]                   NAME <- NAMES[[kk]]
[08:27:52.766]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.766]                     next
[08:27:52.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.766]                 }
[08:27:52.766]                 if (length(args) > 0) 
[08:27:52.766]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.766]             }
[08:27:52.766]             else {
[08:27:52.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.766]             }
[08:27:52.766]             {
[08:27:52.766]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.766]                   0L) {
[08:27:52.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.766]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.766]                   base::options(opts)
[08:27:52.766]                 }
[08:27:52.766]                 {
[08:27:52.766]                   {
[08:27:52.766]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.766]                     NULL
[08:27:52.766]                   }
[08:27:52.766]                   options(future.plan = NULL)
[08:27:52.766]                   if (is.na(NA_character_)) 
[08:27:52.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.766]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.766]                     .init = FALSE)
[08:27:52.766]                 }
[08:27:52.766]             }
[08:27:52.766]         }
[08:27:52.766]     })
[08:27:52.766]     if (TRUE) {
[08:27:52.766]         base::sink(type = "output", split = FALSE)
[08:27:52.766]         if (TRUE) {
[08:27:52.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.766]         }
[08:27:52.766]         else {
[08:27:52.766]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.766]         }
[08:27:52.766]         base::close(...future.stdout)
[08:27:52.766]         ...future.stdout <- NULL
[08:27:52.766]     }
[08:27:52.766]     ...future.result$conditions <- ...future.conditions
[08:27:52.766]     ...future.result$finished <- base::Sys.time()
[08:27:52.766]     ...future.result
[08:27:52.766] }
[08:27:52.768] requestCore(): workers = 2
[08:27:52.771] MulticoreFuture started
[08:27:52.772] - Launch lazy future ... done
[08:27:52.772] run() for ‘MulticoreFuture’ ... done
[08:27:52.772] getGlobalsAndPackages() ...
[08:27:52.772] Searching for globals...
[08:27:52.773] plan(): Setting new future strategy stack:
[08:27:52.773] 
[08:27:52.773] Searching for globals ... DONE
[08:27:52.773] - globals: [0] <none>
[08:27:52.774] getGlobalsAndPackages() ... DONE
[08:27:52.773] List of future strategies:
[08:27:52.773] 1. sequential:
[08:27:52.773]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.773]    - tweaked: FALSE
[08:27:52.773]    - call: NULL
[08:27:52.774] plan(): nbrOfWorkers() = 1
[08:27:52.774] run() for ‘Future’ ...
[08:27:52.774] - state: ‘created’
[08:27:52.774] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.776] plan(): Setting new future strategy stack:
[08:27:52.776] List of future strategies:
[08:27:52.776] 1. multicore:
[08:27:52.776]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.776]    - tweaked: FALSE
[08:27:52.776]    - call: plan(strategy)
[08:27:52.778] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.778] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.778]   - Field: ‘label’
[08:27:52.778] plan(): nbrOfWorkers() = 2
[08:27:52.778]   - Field: ‘local’
[08:27:52.779]   - Field: ‘owner’
[08:27:52.779]   - Field: ‘envir’
[08:27:52.779]   - Field: ‘workers’
[08:27:52.779]   - Field: ‘packages’
[08:27:52.779]   - Field: ‘gc’
[08:27:52.779]   - Field: ‘job’
[08:27:52.779]   - Field: ‘conditions’
[08:27:52.779]   - Field: ‘expr’
[08:27:52.780]   - Field: ‘uuid’
[08:27:52.780]   - Field: ‘seed’
[08:27:52.780]   - Field: ‘version’
[08:27:52.780]   - Field: ‘result’
[08:27:52.780]   - Field: ‘asynchronous’
[08:27:52.780]   - Field: ‘calls’
[08:27:52.780]   - Field: ‘globals’
[08:27:52.780]   - Field: ‘stdout’
[08:27:52.781]   - Field: ‘earlySignal’
[08:27:52.781]   - Field: ‘lazy’
[08:27:52.781]   - Field: ‘state’
[08:27:52.781] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.781] - Launch lazy future ...
[08:27:52.782] Packages needed by the future expression (n = 0): <none>
[08:27:52.782] Packages needed by future strategies (n = 0): <none>
[08:27:52.782] {
[08:27:52.782]     {
[08:27:52.782]         {
[08:27:52.782]             ...future.startTime <- base::Sys.time()
[08:27:52.782]             {
[08:27:52.782]                 {
[08:27:52.782]                   {
[08:27:52.782]                     {
[08:27:52.782]                       base::local({
[08:27:52.782]                         has_future <- base::requireNamespace("future", 
[08:27:52.782]                           quietly = TRUE)
[08:27:52.782]                         if (has_future) {
[08:27:52.782]                           ns <- base::getNamespace("future")
[08:27:52.782]                           version <- ns[[".package"]][["version"]]
[08:27:52.782]                           if (is.null(version)) 
[08:27:52.782]                             version <- utils::packageVersion("future")
[08:27:52.782]                         }
[08:27:52.782]                         else {
[08:27:52.782]                           version <- NULL
[08:27:52.782]                         }
[08:27:52.782]                         if (!has_future || version < "1.8.0") {
[08:27:52.782]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.782]                             "", base::R.version$version.string), 
[08:27:52.782]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.782]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.782]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.782]                               "release", "version")], collapse = " "), 
[08:27:52.782]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.782]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.782]                             info)
[08:27:52.782]                           info <- base::paste(info, collapse = "; ")
[08:27:52.782]                           if (!has_future) {
[08:27:52.782]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.782]                               info)
[08:27:52.782]                           }
[08:27:52.782]                           else {
[08:27:52.782]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.782]                               info, version)
[08:27:52.782]                           }
[08:27:52.782]                           base::stop(msg)
[08:27:52.782]                         }
[08:27:52.782]                       })
[08:27:52.782]                     }
[08:27:52.782]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.782]                     base::options(mc.cores = 1L)
[08:27:52.782]                   }
[08:27:52.782]                   ...future.strategy.old <- future::plan("list")
[08:27:52.782]                   options(future.plan = NULL)
[08:27:52.782]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.782]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.782]                 }
[08:27:52.782]                 ...future.workdir <- getwd()
[08:27:52.782]             }
[08:27:52.782]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.782]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.782]         }
[08:27:52.782]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.782]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.782]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.782]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.782]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.782]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.782]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.782]             base::names(...future.oldOptions))
[08:27:52.782]     }
[08:27:52.782]     if (FALSE) {
[08:27:52.782]     }
[08:27:52.782]     else {
[08:27:52.782]         if (TRUE) {
[08:27:52.782]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.782]                 open = "w")
[08:27:52.782]         }
[08:27:52.782]         else {
[08:27:52.782]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.782]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.782]         }
[08:27:52.782]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.782]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.782]             base::sink(type = "output", split = FALSE)
[08:27:52.782]             base::close(...future.stdout)
[08:27:52.782]         }, add = TRUE)
[08:27:52.782]     }
[08:27:52.782]     ...future.frame <- base::sys.nframe()
[08:27:52.782]     ...future.conditions <- base::list()
[08:27:52.782]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.782]     if (FALSE) {
[08:27:52.782]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.782]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.782]     }
[08:27:52.782]     ...future.result <- base::tryCatch({
[08:27:52.782]         base::withCallingHandlers({
[08:27:52.782]             ...future.value <- base::withVisible(base::local({
[08:27:52.782]                 withCallingHandlers({
[08:27:52.782]                   NULL
[08:27:52.782]                 }, immediateCondition = function(cond) {
[08:27:52.782]                   save_rds <- function (object, pathname, ...) 
[08:27:52.782]                   {
[08:27:52.782]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.782]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.782]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.782]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.782]                         fi_tmp[["mtime"]])
[08:27:52.782]                     }
[08:27:52.782]                     tryCatch({
[08:27:52.782]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.782]                     }, error = function(ex) {
[08:27:52.782]                       msg <- conditionMessage(ex)
[08:27:52.782]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.782]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.782]                         fi_tmp[["mtime"]], msg)
[08:27:52.782]                       ex$message <- msg
[08:27:52.782]                       stop(ex)
[08:27:52.782]                     })
[08:27:52.782]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.782]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.782]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.782]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.782]                       fi <- file.info(pathname)
[08:27:52.782]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.782]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.782]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.782]                         fi[["size"]], fi[["mtime"]])
[08:27:52.782]                       stop(msg)
[08:27:52.782]                     }
[08:27:52.782]                     invisible(pathname)
[08:27:52.782]                   }
[08:27:52.782]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.782]                     rootPath = tempdir()) 
[08:27:52.782]                   {
[08:27:52.782]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.782]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.782]                       tmpdir = path, fileext = ".rds")
[08:27:52.782]                     save_rds(obj, file)
[08:27:52.782]                   }
[08:27:52.782]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.782]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.782]                   {
[08:27:52.782]                     inherits <- base::inherits
[08:27:52.782]                     invokeRestart <- base::invokeRestart
[08:27:52.782]                     is.null <- base::is.null
[08:27:52.782]                     muffled <- FALSE
[08:27:52.782]                     if (inherits(cond, "message")) {
[08:27:52.782]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.782]                       if (muffled) 
[08:27:52.782]                         invokeRestart("muffleMessage")
[08:27:52.782]                     }
[08:27:52.782]                     else if (inherits(cond, "warning")) {
[08:27:52.782]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.782]                       if (muffled) 
[08:27:52.782]                         invokeRestart("muffleWarning")
[08:27:52.782]                     }
[08:27:52.782]                     else if (inherits(cond, "condition")) {
[08:27:52.782]                       if (!is.null(pattern)) {
[08:27:52.782]                         computeRestarts <- base::computeRestarts
[08:27:52.782]                         grepl <- base::grepl
[08:27:52.782]                         restarts <- computeRestarts(cond)
[08:27:52.782]                         for (restart in restarts) {
[08:27:52.782]                           name <- restart$name
[08:27:52.782]                           if (is.null(name)) 
[08:27:52.782]                             next
[08:27:52.782]                           if (!grepl(pattern, name)) 
[08:27:52.782]                             next
[08:27:52.782]                           invokeRestart(restart)
[08:27:52.782]                           muffled <- TRUE
[08:27:52.782]                           break
[08:27:52.782]                         }
[08:27:52.782]                       }
[08:27:52.782]                     }
[08:27:52.782]                     invisible(muffled)
[08:27:52.782]                   }
[08:27:52.782]                   muffleCondition(cond)
[08:27:52.782]                 })
[08:27:52.782]             }))
[08:27:52.782]             future::FutureResult(value = ...future.value$value, 
[08:27:52.782]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.782]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.782]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.782]                     ...future.globalenv.names))
[08:27:52.782]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.782]         }, condition = base::local({
[08:27:52.782]             c <- base::c
[08:27:52.782]             inherits <- base::inherits
[08:27:52.782]             invokeRestart <- base::invokeRestart
[08:27:52.782]             length <- base::length
[08:27:52.782]             list <- base::list
[08:27:52.782]             seq.int <- base::seq.int
[08:27:52.782]             signalCondition <- base::signalCondition
[08:27:52.782]             sys.calls <- base::sys.calls
[08:27:52.782]             `[[` <- base::`[[`
[08:27:52.782]             `+` <- base::`+`
[08:27:52.782]             `<<-` <- base::`<<-`
[08:27:52.782]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.782]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.782]                   3L)]
[08:27:52.782]             }
[08:27:52.782]             function(cond) {
[08:27:52.782]                 is_error <- inherits(cond, "error")
[08:27:52.782]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.782]                   NULL)
[08:27:52.782]                 if (is_error) {
[08:27:52.782]                   sessionInformation <- function() {
[08:27:52.782]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.782]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.782]                       search = base::search(), system = base::Sys.info())
[08:27:52.782]                   }
[08:27:52.782]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.782]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.782]                     cond$call), session = sessionInformation(), 
[08:27:52.782]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.782]                   signalCondition(cond)
[08:27:52.782]                 }
[08:27:52.782]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.782]                 "immediateCondition"))) {
[08:27:52.782]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.782]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.782]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.782]                   if (TRUE && !signal) {
[08:27:52.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.782]                     {
[08:27:52.782]                       inherits <- base::inherits
[08:27:52.782]                       invokeRestart <- base::invokeRestart
[08:27:52.782]                       is.null <- base::is.null
[08:27:52.782]                       muffled <- FALSE
[08:27:52.782]                       if (inherits(cond, "message")) {
[08:27:52.782]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.782]                         if (muffled) 
[08:27:52.782]                           invokeRestart("muffleMessage")
[08:27:52.782]                       }
[08:27:52.782]                       else if (inherits(cond, "warning")) {
[08:27:52.782]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.782]                         if (muffled) 
[08:27:52.782]                           invokeRestart("muffleWarning")
[08:27:52.782]                       }
[08:27:52.782]                       else if (inherits(cond, "condition")) {
[08:27:52.782]                         if (!is.null(pattern)) {
[08:27:52.782]                           computeRestarts <- base::computeRestarts
[08:27:52.782]                           grepl <- base::grepl
[08:27:52.782]                           restarts <- computeRestarts(cond)
[08:27:52.782]                           for (restart in restarts) {
[08:27:52.782]                             name <- restart$name
[08:27:52.782]                             if (is.null(name)) 
[08:27:52.782]                               next
[08:27:52.782]                             if (!grepl(pattern, name)) 
[08:27:52.782]                               next
[08:27:52.782]                             invokeRestart(restart)
[08:27:52.782]                             muffled <- TRUE
[08:27:52.782]                             break
[08:27:52.782]                           }
[08:27:52.782]                         }
[08:27:52.782]                       }
[08:27:52.782]                       invisible(muffled)
[08:27:52.782]                     }
[08:27:52.782]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.782]                   }
[08:27:52.782]                 }
[08:27:52.782]                 else {
[08:27:52.782]                   if (TRUE) {
[08:27:52.782]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.782]                     {
[08:27:52.782]                       inherits <- base::inherits
[08:27:52.782]                       invokeRestart <- base::invokeRestart
[08:27:52.782]                       is.null <- base::is.null
[08:27:52.782]                       muffled <- FALSE
[08:27:52.782]                       if (inherits(cond, "message")) {
[08:27:52.782]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.782]                         if (muffled) 
[08:27:52.782]                           invokeRestart("muffleMessage")
[08:27:52.782]                       }
[08:27:52.782]                       else if (inherits(cond, "warning")) {
[08:27:52.782]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.782]                         if (muffled) 
[08:27:52.782]                           invokeRestart("muffleWarning")
[08:27:52.782]                       }
[08:27:52.782]                       else if (inherits(cond, "condition")) {
[08:27:52.782]                         if (!is.null(pattern)) {
[08:27:52.782]                           computeRestarts <- base::computeRestarts
[08:27:52.782]                           grepl <- base::grepl
[08:27:52.782]                           restarts <- computeRestarts(cond)
[08:27:52.782]                           for (restart in restarts) {
[08:27:52.782]                             name <- restart$name
[08:27:52.782]                             if (is.null(name)) 
[08:27:52.782]                               next
[08:27:52.782]                             if (!grepl(pattern, name)) 
[08:27:52.782]                               next
[08:27:52.782]                             invokeRestart(restart)
[08:27:52.782]                             muffled <- TRUE
[08:27:52.782]                             break
[08:27:52.782]                           }
[08:27:52.782]                         }
[08:27:52.782]                       }
[08:27:52.782]                       invisible(muffled)
[08:27:52.782]                     }
[08:27:52.782]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.782]                   }
[08:27:52.782]                 }
[08:27:52.782]             }
[08:27:52.782]         }))
[08:27:52.782]     }, error = function(ex) {
[08:27:52.782]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.782]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.782]                 ...future.rng), started = ...future.startTime, 
[08:27:52.782]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.782]             version = "1.8"), class = "FutureResult")
[08:27:52.782]     }, finally = {
[08:27:52.782]         if (!identical(...future.workdir, getwd())) 
[08:27:52.782]             setwd(...future.workdir)
[08:27:52.782]         {
[08:27:52.782]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.782]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.782]             }
[08:27:52.782]             base::options(...future.oldOptions)
[08:27:52.782]             if (.Platform$OS.type == "windows") {
[08:27:52.782]                 old_names <- names(...future.oldEnvVars)
[08:27:52.782]                 envs <- base::Sys.getenv()
[08:27:52.782]                 names <- names(envs)
[08:27:52.782]                 common <- intersect(names, old_names)
[08:27:52.782]                 added <- setdiff(names, old_names)
[08:27:52.782]                 removed <- setdiff(old_names, names)
[08:27:52.782]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.782]                   envs[common]]
[08:27:52.782]                 NAMES <- toupper(changed)
[08:27:52.782]                 args <- list()
[08:27:52.782]                 for (kk in seq_along(NAMES)) {
[08:27:52.782]                   name <- changed[[kk]]
[08:27:52.782]                   NAME <- NAMES[[kk]]
[08:27:52.782]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.782]                     next
[08:27:52.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.782]                 }
[08:27:52.782]                 NAMES <- toupper(added)
[08:27:52.782]                 for (kk in seq_along(NAMES)) {
[08:27:52.782]                   name <- added[[kk]]
[08:27:52.782]                   NAME <- NAMES[[kk]]
[08:27:52.782]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.782]                     next
[08:27:52.782]                   args[[name]] <- ""
[08:27:52.782]                 }
[08:27:52.782]                 NAMES <- toupper(removed)
[08:27:52.782]                 for (kk in seq_along(NAMES)) {
[08:27:52.782]                   name <- removed[[kk]]
[08:27:52.782]                   NAME <- NAMES[[kk]]
[08:27:52.782]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.782]                     next
[08:27:52.782]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.782]                 }
[08:27:52.782]                 if (length(args) > 0) 
[08:27:52.782]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.782]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.782]             }
[08:27:52.782]             else {
[08:27:52.782]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.782]             }
[08:27:52.782]             {
[08:27:52.782]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.782]                   0L) {
[08:27:52.782]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.782]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.782]                   base::options(opts)
[08:27:52.782]                 }
[08:27:52.782]                 {
[08:27:52.782]                   {
[08:27:52.782]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.782]                     NULL
[08:27:52.782]                   }
[08:27:52.782]                   options(future.plan = NULL)
[08:27:52.782]                   if (is.na(NA_character_)) 
[08:27:52.782]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.782]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.782]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.782]                     .init = FALSE)
[08:27:52.782]                 }
[08:27:52.782]             }
[08:27:52.782]         }
[08:27:52.782]     })
[08:27:52.782]     if (TRUE) {
[08:27:52.782]         base::sink(type = "output", split = FALSE)
[08:27:52.782]         if (TRUE) {
[08:27:52.782]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.782]         }
[08:27:52.782]         else {
[08:27:52.782]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.782]         }
[08:27:52.782]         base::close(...future.stdout)
[08:27:52.782]         ...future.stdout <- NULL
[08:27:52.782]     }
[08:27:52.782]     ...future.result$conditions <- ...future.conditions
[08:27:52.782]     ...future.result$finished <- base::Sys.time()
[08:27:52.782]     ...future.result
[08:27:52.782] }
[08:27:52.786] requestCore(): workers = 2
[08:27:52.789] MulticoreFuture started
[08:27:52.789] - Launch lazy future ... done
[08:27:52.789] run() for ‘MulticoreFuture’ ... done
[08:27:52.790] plan(): Setting new future strategy stack:
[08:27:52.790] getGlobalsAndPackages() ...
[08:27:52.790] Searching for globals...
[08:27:52.790] List of future strategies:
[08:27:52.790] 1. sequential:
[08:27:52.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.790]    - tweaked: FALSE
[08:27:52.790]    - call: NULL
[08:27:52.791] plan(): nbrOfWorkers() = 1
[08:27:52.792] - globals found: [1] ‘{’
[08:27:52.792] Searching for globals ... DONE
[08:27:52.792] Resolving globals: FALSE
[08:27:52.792] 
[08:27:52.793] 
[08:27:52.793] getGlobalsAndPackages() ... DONE
[08:27:52.793] plan(): Setting new future strategy stack:
[08:27:52.793] run() for ‘Future’ ...
[08:27:52.793] - state: ‘created’
[08:27:52.793] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:52.793] List of future strategies:
[08:27:52.793] 1. multicore:
[08:27:52.793]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.793]    - tweaked: FALSE
[08:27:52.793]    - call: plan(strategy)
[08:27:52.796] plan(): nbrOfWorkers() = 2
[08:27:52.796] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:52.797] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:52.797]   - Field: ‘label’
[08:27:52.797]   - Field: ‘local’
[08:27:52.797]   - Field: ‘owner’
[08:27:52.797]   - Field: ‘envir’
[08:27:52.797]   - Field: ‘workers’
[08:27:52.797]   - Field: ‘packages’
[08:27:52.797]   - Field: ‘gc’
[08:27:52.798]   - Field: ‘job’
[08:27:52.798]   - Field: ‘conditions’
[08:27:52.798]   - Field: ‘expr’
[08:27:52.798]   - Field: ‘uuid’
[08:27:52.798]   - Field: ‘seed’
[08:27:52.798]   - Field: ‘version’
[08:27:52.798]   - Field: ‘result’
[08:27:52.798]   - Field: ‘asynchronous’
[08:27:52.799]   - Field: ‘calls’
[08:27:52.799]   - Field: ‘globals’
[08:27:52.799]   - Field: ‘stdout’
[08:27:52.799]   - Field: ‘earlySignal’
[08:27:52.799]   - Field: ‘lazy’
[08:27:52.799]   - Field: ‘state’
[08:27:52.799] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:52.799] - Launch lazy future ...
[08:27:52.800] Packages needed by the future expression (n = 0): <none>
[08:27:52.800] Packages needed by future strategies (n = 0): <none>
[08:27:52.801] {
[08:27:52.801]     {
[08:27:52.801]         {
[08:27:52.801]             ...future.startTime <- base::Sys.time()
[08:27:52.801]             {
[08:27:52.801]                 {
[08:27:52.801]                   {
[08:27:52.801]                     {
[08:27:52.801]                       base::local({
[08:27:52.801]                         has_future <- base::requireNamespace("future", 
[08:27:52.801]                           quietly = TRUE)
[08:27:52.801]                         if (has_future) {
[08:27:52.801]                           ns <- base::getNamespace("future")
[08:27:52.801]                           version <- ns[[".package"]][["version"]]
[08:27:52.801]                           if (is.null(version)) 
[08:27:52.801]                             version <- utils::packageVersion("future")
[08:27:52.801]                         }
[08:27:52.801]                         else {
[08:27:52.801]                           version <- NULL
[08:27:52.801]                         }
[08:27:52.801]                         if (!has_future || version < "1.8.0") {
[08:27:52.801]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:52.801]                             "", base::R.version$version.string), 
[08:27:52.801]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:52.801]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:52.801]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:52.801]                               "release", "version")], collapse = " "), 
[08:27:52.801]                             hostname = base::Sys.info()[["nodename"]])
[08:27:52.801]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:52.801]                             info)
[08:27:52.801]                           info <- base::paste(info, collapse = "; ")
[08:27:52.801]                           if (!has_future) {
[08:27:52.801]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:52.801]                               info)
[08:27:52.801]                           }
[08:27:52.801]                           else {
[08:27:52.801]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:52.801]                               info, version)
[08:27:52.801]                           }
[08:27:52.801]                           base::stop(msg)
[08:27:52.801]                         }
[08:27:52.801]                       })
[08:27:52.801]                     }
[08:27:52.801]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:52.801]                     base::options(mc.cores = 1L)
[08:27:52.801]                   }
[08:27:52.801]                   ...future.strategy.old <- future::plan("list")
[08:27:52.801]                   options(future.plan = NULL)
[08:27:52.801]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.801]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:52.801]                 }
[08:27:52.801]                 ...future.workdir <- getwd()
[08:27:52.801]             }
[08:27:52.801]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:52.801]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:52.801]         }
[08:27:52.801]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:52.801]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:52.801]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:52.801]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:52.801]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:52.801]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:52.801]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:52.801]             base::names(...future.oldOptions))
[08:27:52.801]     }
[08:27:52.801]     if (FALSE) {
[08:27:52.801]     }
[08:27:52.801]     else {
[08:27:52.801]         if (TRUE) {
[08:27:52.801]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:52.801]                 open = "w")
[08:27:52.801]         }
[08:27:52.801]         else {
[08:27:52.801]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:52.801]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:52.801]         }
[08:27:52.801]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:52.801]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:52.801]             base::sink(type = "output", split = FALSE)
[08:27:52.801]             base::close(...future.stdout)
[08:27:52.801]         }, add = TRUE)
[08:27:52.801]     }
[08:27:52.801]     ...future.frame <- base::sys.nframe()
[08:27:52.801]     ...future.conditions <- base::list()
[08:27:52.801]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:52.801]     if (FALSE) {
[08:27:52.801]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:52.801]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:52.801]     }
[08:27:52.801]     ...future.result <- base::tryCatch({
[08:27:52.801]         base::withCallingHandlers({
[08:27:52.801]             ...future.value <- base::withVisible(base::local({
[08:27:52.801]                 withCallingHandlers({
[08:27:52.801]                   {
[08:27:52.801]                     4
[08:27:52.801]                   }
[08:27:52.801]                 }, immediateCondition = function(cond) {
[08:27:52.801]                   save_rds <- function (object, pathname, ...) 
[08:27:52.801]                   {
[08:27:52.801]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:52.801]                     if (file_test("-f", pathname_tmp)) {
[08:27:52.801]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.801]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:52.801]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.801]                         fi_tmp[["mtime"]])
[08:27:52.801]                     }
[08:27:52.801]                     tryCatch({
[08:27:52.801]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:52.801]                     }, error = function(ex) {
[08:27:52.801]                       msg <- conditionMessage(ex)
[08:27:52.801]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.801]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:52.801]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.801]                         fi_tmp[["mtime"]], msg)
[08:27:52.801]                       ex$message <- msg
[08:27:52.801]                       stop(ex)
[08:27:52.801]                     })
[08:27:52.801]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:52.801]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:52.801]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:52.801]                       fi_tmp <- file.info(pathname_tmp)
[08:27:52.801]                       fi <- file.info(pathname)
[08:27:52.801]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:52.801]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:52.801]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:52.801]                         fi[["size"]], fi[["mtime"]])
[08:27:52.801]                       stop(msg)
[08:27:52.801]                     }
[08:27:52.801]                     invisible(pathname)
[08:27:52.801]                   }
[08:27:52.801]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:52.801]                     rootPath = tempdir()) 
[08:27:52.801]                   {
[08:27:52.801]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:52.801]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:52.801]                       tmpdir = path, fileext = ".rds")
[08:27:52.801]                     save_rds(obj, file)
[08:27:52.801]                   }
[08:27:52.801]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:52.801]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.801]                   {
[08:27:52.801]                     inherits <- base::inherits
[08:27:52.801]                     invokeRestart <- base::invokeRestart
[08:27:52.801]                     is.null <- base::is.null
[08:27:52.801]                     muffled <- FALSE
[08:27:52.801]                     if (inherits(cond, "message")) {
[08:27:52.801]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:52.801]                       if (muffled) 
[08:27:52.801]                         invokeRestart("muffleMessage")
[08:27:52.801]                     }
[08:27:52.801]                     else if (inherits(cond, "warning")) {
[08:27:52.801]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:52.801]                       if (muffled) 
[08:27:52.801]                         invokeRestart("muffleWarning")
[08:27:52.801]                     }
[08:27:52.801]                     else if (inherits(cond, "condition")) {
[08:27:52.801]                       if (!is.null(pattern)) {
[08:27:52.801]                         computeRestarts <- base::computeRestarts
[08:27:52.801]                         grepl <- base::grepl
[08:27:52.801]                         restarts <- computeRestarts(cond)
[08:27:52.801]                         for (restart in restarts) {
[08:27:52.801]                           name <- restart$name
[08:27:52.801]                           if (is.null(name)) 
[08:27:52.801]                             next
[08:27:52.801]                           if (!grepl(pattern, name)) 
[08:27:52.801]                             next
[08:27:52.801]                           invokeRestart(restart)
[08:27:52.801]                           muffled <- TRUE
[08:27:52.801]                           break
[08:27:52.801]                         }
[08:27:52.801]                       }
[08:27:52.801]                     }
[08:27:52.801]                     invisible(muffled)
[08:27:52.801]                   }
[08:27:52.801]                   muffleCondition(cond)
[08:27:52.801]                 })
[08:27:52.801]             }))
[08:27:52.801]             future::FutureResult(value = ...future.value$value, 
[08:27:52.801]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.801]                   ...future.rng), globalenv = if (FALSE) 
[08:27:52.801]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:52.801]                     ...future.globalenv.names))
[08:27:52.801]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:52.801]         }, condition = base::local({
[08:27:52.801]             c <- base::c
[08:27:52.801]             inherits <- base::inherits
[08:27:52.801]             invokeRestart <- base::invokeRestart
[08:27:52.801]             length <- base::length
[08:27:52.801]             list <- base::list
[08:27:52.801]             seq.int <- base::seq.int
[08:27:52.801]             signalCondition <- base::signalCondition
[08:27:52.801]             sys.calls <- base::sys.calls
[08:27:52.801]             `[[` <- base::`[[`
[08:27:52.801]             `+` <- base::`+`
[08:27:52.801]             `<<-` <- base::`<<-`
[08:27:52.801]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:52.801]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:52.801]                   3L)]
[08:27:52.801]             }
[08:27:52.801]             function(cond) {
[08:27:52.801]                 is_error <- inherits(cond, "error")
[08:27:52.801]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:52.801]                   NULL)
[08:27:52.801]                 if (is_error) {
[08:27:52.801]                   sessionInformation <- function() {
[08:27:52.801]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:52.801]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:52.801]                       search = base::search(), system = base::Sys.info())
[08:27:52.801]                   }
[08:27:52.801]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.801]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:52.801]                     cond$call), session = sessionInformation(), 
[08:27:52.801]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:52.801]                   signalCondition(cond)
[08:27:52.801]                 }
[08:27:52.801]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:52.801]                 "immediateCondition"))) {
[08:27:52.801]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:52.801]                   ...future.conditions[[length(...future.conditions) + 
[08:27:52.801]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:52.801]                   if (TRUE && !signal) {
[08:27:52.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.801]                     {
[08:27:52.801]                       inherits <- base::inherits
[08:27:52.801]                       invokeRestart <- base::invokeRestart
[08:27:52.801]                       is.null <- base::is.null
[08:27:52.801]                       muffled <- FALSE
[08:27:52.801]                       if (inherits(cond, "message")) {
[08:27:52.801]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.801]                         if (muffled) 
[08:27:52.801]                           invokeRestart("muffleMessage")
[08:27:52.801]                       }
[08:27:52.801]                       else if (inherits(cond, "warning")) {
[08:27:52.801]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.801]                         if (muffled) 
[08:27:52.801]                           invokeRestart("muffleWarning")
[08:27:52.801]                       }
[08:27:52.801]                       else if (inherits(cond, "condition")) {
[08:27:52.801]                         if (!is.null(pattern)) {
[08:27:52.801]                           computeRestarts <- base::computeRestarts
[08:27:52.801]                           grepl <- base::grepl
[08:27:52.801]                           restarts <- computeRestarts(cond)
[08:27:52.801]                           for (restart in restarts) {
[08:27:52.801]                             name <- restart$name
[08:27:52.801]                             if (is.null(name)) 
[08:27:52.801]                               next
[08:27:52.801]                             if (!grepl(pattern, name)) 
[08:27:52.801]                               next
[08:27:52.801]                             invokeRestart(restart)
[08:27:52.801]                             muffled <- TRUE
[08:27:52.801]                             break
[08:27:52.801]                           }
[08:27:52.801]                         }
[08:27:52.801]                       }
[08:27:52.801]                       invisible(muffled)
[08:27:52.801]                     }
[08:27:52.801]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.801]                   }
[08:27:52.801]                 }
[08:27:52.801]                 else {
[08:27:52.801]                   if (TRUE) {
[08:27:52.801]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:52.801]                     {
[08:27:52.801]                       inherits <- base::inherits
[08:27:52.801]                       invokeRestart <- base::invokeRestart
[08:27:52.801]                       is.null <- base::is.null
[08:27:52.801]                       muffled <- FALSE
[08:27:52.801]                       if (inherits(cond, "message")) {
[08:27:52.801]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:52.801]                         if (muffled) 
[08:27:52.801]                           invokeRestart("muffleMessage")
[08:27:52.801]                       }
[08:27:52.801]                       else if (inherits(cond, "warning")) {
[08:27:52.801]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:52.801]                         if (muffled) 
[08:27:52.801]                           invokeRestart("muffleWarning")
[08:27:52.801]                       }
[08:27:52.801]                       else if (inherits(cond, "condition")) {
[08:27:52.801]                         if (!is.null(pattern)) {
[08:27:52.801]                           computeRestarts <- base::computeRestarts
[08:27:52.801]                           grepl <- base::grepl
[08:27:52.801]                           restarts <- computeRestarts(cond)
[08:27:52.801]                           for (restart in restarts) {
[08:27:52.801]                             name <- restart$name
[08:27:52.801]                             if (is.null(name)) 
[08:27:52.801]                               next
[08:27:52.801]                             if (!grepl(pattern, name)) 
[08:27:52.801]                               next
[08:27:52.801]                             invokeRestart(restart)
[08:27:52.801]                             muffled <- TRUE
[08:27:52.801]                             break
[08:27:52.801]                           }
[08:27:52.801]                         }
[08:27:52.801]                       }
[08:27:52.801]                       invisible(muffled)
[08:27:52.801]                     }
[08:27:52.801]                     muffleCondition(cond, pattern = "^muffle")
[08:27:52.801]                   }
[08:27:52.801]                 }
[08:27:52.801]             }
[08:27:52.801]         }))
[08:27:52.801]     }, error = function(ex) {
[08:27:52.801]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:52.801]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:52.801]                 ...future.rng), started = ...future.startTime, 
[08:27:52.801]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:52.801]             version = "1.8"), class = "FutureResult")
[08:27:52.801]     }, finally = {
[08:27:52.801]         if (!identical(...future.workdir, getwd())) 
[08:27:52.801]             setwd(...future.workdir)
[08:27:52.801]         {
[08:27:52.801]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:52.801]                 ...future.oldOptions$nwarnings <- NULL
[08:27:52.801]             }
[08:27:52.801]             base::options(...future.oldOptions)
[08:27:52.801]             if (.Platform$OS.type == "windows") {
[08:27:52.801]                 old_names <- names(...future.oldEnvVars)
[08:27:52.801]                 envs <- base::Sys.getenv()
[08:27:52.801]                 names <- names(envs)
[08:27:52.801]                 common <- intersect(names, old_names)
[08:27:52.801]                 added <- setdiff(names, old_names)
[08:27:52.801]                 removed <- setdiff(old_names, names)
[08:27:52.801]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:52.801]                   envs[common]]
[08:27:52.801]                 NAMES <- toupper(changed)
[08:27:52.801]                 args <- list()
[08:27:52.801]                 for (kk in seq_along(NAMES)) {
[08:27:52.801]                   name <- changed[[kk]]
[08:27:52.801]                   NAME <- NAMES[[kk]]
[08:27:52.801]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.801]                     next
[08:27:52.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.801]                 }
[08:27:52.801]                 NAMES <- toupper(added)
[08:27:52.801]                 for (kk in seq_along(NAMES)) {
[08:27:52.801]                   name <- added[[kk]]
[08:27:52.801]                   NAME <- NAMES[[kk]]
[08:27:52.801]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.801]                     next
[08:27:52.801]                   args[[name]] <- ""
[08:27:52.801]                 }
[08:27:52.801]                 NAMES <- toupper(removed)
[08:27:52.801]                 for (kk in seq_along(NAMES)) {
[08:27:52.801]                   name <- removed[[kk]]
[08:27:52.801]                   NAME <- NAMES[[kk]]
[08:27:52.801]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:52.801]                     next
[08:27:52.801]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:52.801]                 }
[08:27:52.801]                 if (length(args) > 0) 
[08:27:52.801]                   base::do.call(base::Sys.setenv, args = args)
[08:27:52.801]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:52.801]             }
[08:27:52.801]             else {
[08:27:52.801]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:52.801]             }
[08:27:52.801]             {
[08:27:52.801]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:52.801]                   0L) {
[08:27:52.801]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:52.801]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:52.801]                   base::options(opts)
[08:27:52.801]                 }
[08:27:52.801]                 {
[08:27:52.801]                   {
[08:27:52.801]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:52.801]                     NULL
[08:27:52.801]                   }
[08:27:52.801]                   options(future.plan = NULL)
[08:27:52.801]                   if (is.na(NA_character_)) 
[08:27:52.801]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:52.801]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:52.801]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:52.801]                     .init = FALSE)
[08:27:52.801]                 }
[08:27:52.801]             }
[08:27:52.801]         }
[08:27:52.801]     })
[08:27:52.801]     if (TRUE) {
[08:27:52.801]         base::sink(type = "output", split = FALSE)
[08:27:52.801]         if (TRUE) {
[08:27:52.801]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:52.801]         }
[08:27:52.801]         else {
[08:27:52.801]             ...future.result["stdout"] <- base::list(NULL)
[08:27:52.801]         }
[08:27:52.801]         base::close(...future.stdout)
[08:27:52.801]         ...future.stdout <- NULL
[08:27:52.801]     }
[08:27:52.801]     ...future.result$conditions <- ...future.conditions
[08:27:52.801]     ...future.result$finished <- base::Sys.time()
[08:27:52.801]     ...future.result
[08:27:52.801] }
[08:27:52.804] requestCore(): workers = 2
[08:27:52.804] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:52.815] result() for MulticoreFuture ...
[08:27:52.816] result() for MulticoreFuture ...
[08:27:52.816] result() for MulticoreFuture ... done
[08:27:52.816] result() for MulticoreFuture ... done
[08:27:52.816] result() for MulticoreFuture ...
[08:27:52.817] result() for MulticoreFuture ... done
[08:27:52.820] MulticoreFuture started
[08:27:52.820] - Launch lazy future ... done
[08:27:52.820] run() for ‘MulticoreFuture’ ... done
[08:27:52.821] plan(): Setting new future strategy stack:
<environment: 0x55d862220dd8> 
[08:27:52.821] List of future strategies:
[08:27:52.821] 1. sequential:
[08:27:52.821]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:52.821]    - tweaked: FALSE
[08:27:52.821]    - call: NULL
[08:27:52.823] plan(): nbrOfWorkers() = 1
<environment: 0x55d862bdbe58> 
[08:27:52.825] plan(): Setting new future strategy stack:
[08:27:52.826] List of future strategies:
[08:27:52.826] 1. multicore:
[08:27:52.826]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:52.826]    - tweaked: FALSE
[08:27:52.826]    - call: plan(strategy)
[08:27:52.829] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:52.831] resolve() on environment ...
[08:27:52.831]  recursive: 0
[08:27:52.832]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:52.832] signalConditionsASAP(numeric, pos=1) ...
[08:27:52.832] - nx: 4
[08:27:52.833] - relay: TRUE
[08:27:52.833] - stdout: TRUE
[08:27:52.833] - signal: TRUE
[08:27:52.833] - resignal: FALSE
[08:27:52.833] - force: TRUE
[08:27:52.833] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.833] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.833]  - until=2
[08:27:52.834]  - relaying element #2
[08:27:52.834] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.834] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.834] signalConditionsASAP(NULL, pos=1) ... done
[08:27:52.834]  length: 3 (resolved future 1)
[08:27:52.834] Future #2
[08:27:52.834] result() for MulticoreFuture ...
[08:27:52.834] result() for MulticoreFuture ... done
[08:27:52.835] result() for MulticoreFuture ...
[08:27:52.835] result() for MulticoreFuture ... done
[08:27:52.835] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:52.835] - nx: 4
[08:27:52.835] - relay: TRUE
[08:27:52.835] - stdout: TRUE
[08:27:52.835] - signal: TRUE
[08:27:52.835] - resignal: FALSE
[08:27:52.836] - force: TRUE
[08:27:52.836] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:52.836] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:52.836]  - until=2
[08:27:52.836]  - relaying element #2
[08:27:52.836] result() for MulticoreFuture ...
[08:27:52.836] result() for MulticoreFuture ... done
[08:27:52.836] result() for MulticoreFuture ...
[08:27:52.837] result() for MulticoreFuture ... done
[08:27:52.837] result() for MulticoreFuture ...
[08:27:52.837] result() for MulticoreFuture ... done
[08:27:52.837] result() for MulticoreFuture ...
[08:27:52.837] result() for MulticoreFuture ... done
[08:27:52.837] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.837] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.838] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:52.838]  length: 2 (resolved future 2)
[08:27:52.838] Future #3
[08:27:52.838] result() for MulticoreFuture ...
[08:27:52.839] result() for MulticoreFuture ...
[08:27:52.839] result() for MulticoreFuture ... done
[08:27:52.839] result() for MulticoreFuture ... done
[08:27:52.840] result() for MulticoreFuture ...
[08:27:52.840] result() for MulticoreFuture ... done
[08:27:52.840] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:52.840] - nx: 4
[08:27:52.840] - relay: TRUE
[08:27:52.840] - stdout: TRUE
[08:27:52.840] - signal: TRUE
[08:27:52.840] - resignal: FALSE
[08:27:52.840] - force: TRUE
[08:27:52.841] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:52.841] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:52.841]  - until=3
[08:27:52.841]  - relaying element #3
[08:27:52.841] result() for MulticoreFuture ...
[08:27:52.841] result() for MulticoreFuture ... done
[08:27:52.841] result() for MulticoreFuture ...
[08:27:52.841] result() for MulticoreFuture ... done
[08:27:52.842] result() for MulticoreFuture ...
[08:27:52.842] result() for MulticoreFuture ... done
[08:27:52.842] result() for MulticoreFuture ...
[08:27:52.842] result() for MulticoreFuture ... done
[08:27:52.842] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.842] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.842] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:52.843]  length: 1 (resolved future 3)
[08:27:52.843] Future #4
[08:27:52.843] result() for MulticoreFuture ...
[08:27:52.844] result() for MulticoreFuture ...
[08:27:52.844] result() for MulticoreFuture ... done
[08:27:52.844] result() for MulticoreFuture ... done
[08:27:52.844] result() for MulticoreFuture ...
[08:27:52.845] result() for MulticoreFuture ... done
[08:27:52.845] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:52.845] - nx: 4
[08:27:52.845] - relay: TRUE
[08:27:52.845] - stdout: TRUE
[08:27:52.845] - signal: TRUE
[08:27:52.846] - resignal: FALSE
[08:27:52.846] - force: TRUE
[08:27:52.846] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:52.846] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:52.846]  - until=4
[08:27:52.846]  - relaying element #4
[08:27:52.846] result() for MulticoreFuture ...
[08:27:52.847] result() for MulticoreFuture ... done
[08:27:52.847] result() for MulticoreFuture ...
[08:27:52.847] result() for MulticoreFuture ... done
[08:27:52.847] result() for MulticoreFuture ...
[08:27:52.847] result() for MulticoreFuture ... done
[08:27:52.848] result() for MulticoreFuture ...
[08:27:52.848] result() for MulticoreFuture ... done
[08:27:52.848] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.848] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.848] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:52.848]  length: 0 (resolved future 4)
[08:27:52.848] Relaying remaining futures
[08:27:52.848] signalConditionsASAP(NULL, pos=0) ...
[08:27:52.853] - nx: 4
[08:27:52.853] - relay: TRUE
[08:27:52.853] - stdout: TRUE
[08:27:52.853] - signal: TRUE
[08:27:52.853] - resignal: FALSE
[08:27:52.853] - force: TRUE
[08:27:52.853] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.853] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:52.853] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:52.854] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:52.854] signalConditionsASAP(NULL, pos=0) ... done
[08:27:52.854] resolve() on environment ... DONE
[08:27:52.854] result() for MulticoreFuture ...
[08:27:52.854] result() for MulticoreFuture ... done
[08:27:52.854] result() for MulticoreFuture ...
[08:27:52.854] result() for MulticoreFuture ... done
[08:27:52.854] result() for MulticoreFuture ...
[08:27:52.854] result() for MulticoreFuture ... done
[08:27:52.855] result() for MulticoreFuture ...
[08:27:52.855] result() for MulticoreFuture ... done
[08:27:52.855] result() for MulticoreFuture ...
[08:27:52.855] result() for MulticoreFuture ... done
[08:27:52.855] result() for MulticoreFuture ...
[08:27:52.855] result() for MulticoreFuture ... done
<environment: 0x55d862d3c3b8> 
Type of future: multisession
[08:27:52.856] plan(): Setting new future strategy stack:
[08:27:52.856] List of future strategies:
[08:27:52.856] 1. multisession:
[08:27:52.856]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:52.856]    - tweaked: FALSE
[08:27:52.856]    - call: plan(strategy)
[08:27:52.856] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:27:52.857] multisession:
[08:27:52.857] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:52.857] - tweaked: FALSE
[08:27:52.857] - call: plan(strategy)
[08:27:52.859] getGlobalsAndPackages() ...
[08:27:52.859] Not searching for globals
[08:27:52.859] - globals: [0] <none>
[08:27:52.859] getGlobalsAndPackages() ... DONE
[08:27:53.119] Packages needed by the future expression (n = 0): <none>
[08:27:53.120] Packages needed by future strategies (n = 0): <none>
[08:27:53.120] {
[08:27:53.120]     {
[08:27:53.120]         {
[08:27:53.120]             ...future.startTime <- base::Sys.time()
[08:27:53.120]             {
[08:27:53.120]                 {
[08:27:53.120]                   {
[08:27:53.120]                     {
[08:27:53.120]                       base::local({
[08:27:53.120]                         has_future <- base::requireNamespace("future", 
[08:27:53.120]                           quietly = TRUE)
[08:27:53.120]                         if (has_future) {
[08:27:53.120]                           ns <- base::getNamespace("future")
[08:27:53.120]                           version <- ns[[".package"]][["version"]]
[08:27:53.120]                           if (is.null(version)) 
[08:27:53.120]                             version <- utils::packageVersion("future")
[08:27:53.120]                         }
[08:27:53.120]                         else {
[08:27:53.120]                           version <- NULL
[08:27:53.120]                         }
[08:27:53.120]                         if (!has_future || version < "1.8.0") {
[08:27:53.120]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.120]                             "", base::R.version$version.string), 
[08:27:53.120]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.120]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.120]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.120]                               "release", "version")], collapse = " "), 
[08:27:53.120]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.120]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.120]                             info)
[08:27:53.120]                           info <- base::paste(info, collapse = "; ")
[08:27:53.120]                           if (!has_future) {
[08:27:53.120]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.120]                               info)
[08:27:53.120]                           }
[08:27:53.120]                           else {
[08:27:53.120]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.120]                               info, version)
[08:27:53.120]                           }
[08:27:53.120]                           base::stop(msg)
[08:27:53.120]                         }
[08:27:53.120]                       })
[08:27:53.120]                     }
[08:27:53.120]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.120]                     base::options(mc.cores = 1L)
[08:27:53.120]                   }
[08:27:53.120]                   ...future.strategy.old <- future::plan("list")
[08:27:53.120]                   options(future.plan = NULL)
[08:27:53.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.120]                 }
[08:27:53.120]                 ...future.workdir <- getwd()
[08:27:53.120]             }
[08:27:53.120]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.120]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.120]         }
[08:27:53.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.120]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.120]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.120]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.120]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.120]             base::names(...future.oldOptions))
[08:27:53.120]     }
[08:27:53.120]     if (FALSE) {
[08:27:53.120]     }
[08:27:53.120]     else {
[08:27:53.120]         if (TRUE) {
[08:27:53.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.120]                 open = "w")
[08:27:53.120]         }
[08:27:53.120]         else {
[08:27:53.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.120]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.120]         }
[08:27:53.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.120]             base::sink(type = "output", split = FALSE)
[08:27:53.120]             base::close(...future.stdout)
[08:27:53.120]         }, add = TRUE)
[08:27:53.120]     }
[08:27:53.120]     ...future.frame <- base::sys.nframe()
[08:27:53.120]     ...future.conditions <- base::list()
[08:27:53.120]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.120]     if (FALSE) {
[08:27:53.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.120]     }
[08:27:53.120]     ...future.result <- base::tryCatch({
[08:27:53.120]         base::withCallingHandlers({
[08:27:53.120]             ...future.value <- base::withVisible(base::local({
[08:27:53.120]                 ...future.makeSendCondition <- base::local({
[08:27:53.120]                   sendCondition <- NULL
[08:27:53.120]                   function(frame = 1L) {
[08:27:53.120]                     if (is.function(sendCondition)) 
[08:27:53.120]                       return(sendCondition)
[08:27:53.120]                     ns <- getNamespace("parallel")
[08:27:53.120]                     if (exists("sendData", mode = "function", 
[08:27:53.120]                       envir = ns)) {
[08:27:53.120]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.120]                         envir = ns)
[08:27:53.120]                       envir <- sys.frame(frame)
[08:27:53.120]                       master <- NULL
[08:27:53.120]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.120]                         !identical(envir, emptyenv())) {
[08:27:53.120]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.120]                           inherits = FALSE)) {
[08:27:53.120]                           master <- get("master", mode = "list", 
[08:27:53.120]                             envir = envir, inherits = FALSE)
[08:27:53.120]                           if (inherits(master, c("SOCKnode", 
[08:27:53.120]                             "SOCK0node"))) {
[08:27:53.120]                             sendCondition <<- function(cond) {
[08:27:53.120]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.120]                                 success = TRUE)
[08:27:53.120]                               parallel_sendData(master, data)
[08:27:53.120]                             }
[08:27:53.120]                             return(sendCondition)
[08:27:53.120]                           }
[08:27:53.120]                         }
[08:27:53.120]                         frame <- frame + 1L
[08:27:53.120]                         envir <- sys.frame(frame)
[08:27:53.120]                       }
[08:27:53.120]                     }
[08:27:53.120]                     sendCondition <<- function(cond) NULL
[08:27:53.120]                   }
[08:27:53.120]                 })
[08:27:53.120]                 withCallingHandlers({
[08:27:53.120]                   NA
[08:27:53.120]                 }, immediateCondition = function(cond) {
[08:27:53.120]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.120]                   sendCondition(cond)
[08:27:53.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.120]                   {
[08:27:53.120]                     inherits <- base::inherits
[08:27:53.120]                     invokeRestart <- base::invokeRestart
[08:27:53.120]                     is.null <- base::is.null
[08:27:53.120]                     muffled <- FALSE
[08:27:53.120]                     if (inherits(cond, "message")) {
[08:27:53.120]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.120]                       if (muffled) 
[08:27:53.120]                         invokeRestart("muffleMessage")
[08:27:53.120]                     }
[08:27:53.120]                     else if (inherits(cond, "warning")) {
[08:27:53.120]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.120]                       if (muffled) 
[08:27:53.120]                         invokeRestart("muffleWarning")
[08:27:53.120]                     }
[08:27:53.120]                     else if (inherits(cond, "condition")) {
[08:27:53.120]                       if (!is.null(pattern)) {
[08:27:53.120]                         computeRestarts <- base::computeRestarts
[08:27:53.120]                         grepl <- base::grepl
[08:27:53.120]                         restarts <- computeRestarts(cond)
[08:27:53.120]                         for (restart in restarts) {
[08:27:53.120]                           name <- restart$name
[08:27:53.120]                           if (is.null(name)) 
[08:27:53.120]                             next
[08:27:53.120]                           if (!grepl(pattern, name)) 
[08:27:53.120]                             next
[08:27:53.120]                           invokeRestart(restart)
[08:27:53.120]                           muffled <- TRUE
[08:27:53.120]                           break
[08:27:53.120]                         }
[08:27:53.120]                       }
[08:27:53.120]                     }
[08:27:53.120]                     invisible(muffled)
[08:27:53.120]                   }
[08:27:53.120]                   muffleCondition(cond)
[08:27:53.120]                 })
[08:27:53.120]             }))
[08:27:53.120]             future::FutureResult(value = ...future.value$value, 
[08:27:53.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.120]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.120]                     ...future.globalenv.names))
[08:27:53.120]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.120]         }, condition = base::local({
[08:27:53.120]             c <- base::c
[08:27:53.120]             inherits <- base::inherits
[08:27:53.120]             invokeRestart <- base::invokeRestart
[08:27:53.120]             length <- base::length
[08:27:53.120]             list <- base::list
[08:27:53.120]             seq.int <- base::seq.int
[08:27:53.120]             signalCondition <- base::signalCondition
[08:27:53.120]             sys.calls <- base::sys.calls
[08:27:53.120]             `[[` <- base::`[[`
[08:27:53.120]             `+` <- base::`+`
[08:27:53.120]             `<<-` <- base::`<<-`
[08:27:53.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.120]                   3L)]
[08:27:53.120]             }
[08:27:53.120]             function(cond) {
[08:27:53.120]                 is_error <- inherits(cond, "error")
[08:27:53.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.120]                   NULL)
[08:27:53.120]                 if (is_error) {
[08:27:53.120]                   sessionInformation <- function() {
[08:27:53.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.120]                       search = base::search(), system = base::Sys.info())
[08:27:53.120]                   }
[08:27:53.120]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.120]                     cond$call), session = sessionInformation(), 
[08:27:53.120]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.120]                   signalCondition(cond)
[08:27:53.120]                 }
[08:27:53.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.120]                 "immediateCondition"))) {
[08:27:53.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.120]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.120]                   if (TRUE && !signal) {
[08:27:53.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.120]                     {
[08:27:53.120]                       inherits <- base::inherits
[08:27:53.120]                       invokeRestart <- base::invokeRestart
[08:27:53.120]                       is.null <- base::is.null
[08:27:53.120]                       muffled <- FALSE
[08:27:53.120]                       if (inherits(cond, "message")) {
[08:27:53.120]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.120]                         if (muffled) 
[08:27:53.120]                           invokeRestart("muffleMessage")
[08:27:53.120]                       }
[08:27:53.120]                       else if (inherits(cond, "warning")) {
[08:27:53.120]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.120]                         if (muffled) 
[08:27:53.120]                           invokeRestart("muffleWarning")
[08:27:53.120]                       }
[08:27:53.120]                       else if (inherits(cond, "condition")) {
[08:27:53.120]                         if (!is.null(pattern)) {
[08:27:53.120]                           computeRestarts <- base::computeRestarts
[08:27:53.120]                           grepl <- base::grepl
[08:27:53.120]                           restarts <- computeRestarts(cond)
[08:27:53.120]                           for (restart in restarts) {
[08:27:53.120]                             name <- restart$name
[08:27:53.120]                             if (is.null(name)) 
[08:27:53.120]                               next
[08:27:53.120]                             if (!grepl(pattern, name)) 
[08:27:53.120]                               next
[08:27:53.120]                             invokeRestart(restart)
[08:27:53.120]                             muffled <- TRUE
[08:27:53.120]                             break
[08:27:53.120]                           }
[08:27:53.120]                         }
[08:27:53.120]                       }
[08:27:53.120]                       invisible(muffled)
[08:27:53.120]                     }
[08:27:53.120]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.120]                   }
[08:27:53.120]                 }
[08:27:53.120]                 else {
[08:27:53.120]                   if (TRUE) {
[08:27:53.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.120]                     {
[08:27:53.120]                       inherits <- base::inherits
[08:27:53.120]                       invokeRestart <- base::invokeRestart
[08:27:53.120]                       is.null <- base::is.null
[08:27:53.120]                       muffled <- FALSE
[08:27:53.120]                       if (inherits(cond, "message")) {
[08:27:53.120]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.120]                         if (muffled) 
[08:27:53.120]                           invokeRestart("muffleMessage")
[08:27:53.120]                       }
[08:27:53.120]                       else if (inherits(cond, "warning")) {
[08:27:53.120]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.120]                         if (muffled) 
[08:27:53.120]                           invokeRestart("muffleWarning")
[08:27:53.120]                       }
[08:27:53.120]                       else if (inherits(cond, "condition")) {
[08:27:53.120]                         if (!is.null(pattern)) {
[08:27:53.120]                           computeRestarts <- base::computeRestarts
[08:27:53.120]                           grepl <- base::grepl
[08:27:53.120]                           restarts <- computeRestarts(cond)
[08:27:53.120]                           for (restart in restarts) {
[08:27:53.120]                             name <- restart$name
[08:27:53.120]                             if (is.null(name)) 
[08:27:53.120]                               next
[08:27:53.120]                             if (!grepl(pattern, name)) 
[08:27:53.120]                               next
[08:27:53.120]                             invokeRestart(restart)
[08:27:53.120]                             muffled <- TRUE
[08:27:53.120]                             break
[08:27:53.120]                           }
[08:27:53.120]                         }
[08:27:53.120]                       }
[08:27:53.120]                       invisible(muffled)
[08:27:53.120]                     }
[08:27:53.120]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.120]                   }
[08:27:53.120]                 }
[08:27:53.120]             }
[08:27:53.120]         }))
[08:27:53.120]     }, error = function(ex) {
[08:27:53.120]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.120]                 ...future.rng), started = ...future.startTime, 
[08:27:53.120]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.120]             version = "1.8"), class = "FutureResult")
[08:27:53.120]     }, finally = {
[08:27:53.120]         if (!identical(...future.workdir, getwd())) 
[08:27:53.120]             setwd(...future.workdir)
[08:27:53.120]         {
[08:27:53.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.120]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.120]             }
[08:27:53.120]             base::options(...future.oldOptions)
[08:27:53.120]             if (.Platform$OS.type == "windows") {
[08:27:53.120]                 old_names <- names(...future.oldEnvVars)
[08:27:53.120]                 envs <- base::Sys.getenv()
[08:27:53.120]                 names <- names(envs)
[08:27:53.120]                 common <- intersect(names, old_names)
[08:27:53.120]                 added <- setdiff(names, old_names)
[08:27:53.120]                 removed <- setdiff(old_names, names)
[08:27:53.120]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.120]                   envs[common]]
[08:27:53.120]                 NAMES <- toupper(changed)
[08:27:53.120]                 args <- list()
[08:27:53.120]                 for (kk in seq_along(NAMES)) {
[08:27:53.120]                   name <- changed[[kk]]
[08:27:53.120]                   NAME <- NAMES[[kk]]
[08:27:53.120]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.120]                     next
[08:27:53.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.120]                 }
[08:27:53.120]                 NAMES <- toupper(added)
[08:27:53.120]                 for (kk in seq_along(NAMES)) {
[08:27:53.120]                   name <- added[[kk]]
[08:27:53.120]                   NAME <- NAMES[[kk]]
[08:27:53.120]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.120]                     next
[08:27:53.120]                   args[[name]] <- ""
[08:27:53.120]                 }
[08:27:53.120]                 NAMES <- toupper(removed)
[08:27:53.120]                 for (kk in seq_along(NAMES)) {
[08:27:53.120]                   name <- removed[[kk]]
[08:27:53.120]                   NAME <- NAMES[[kk]]
[08:27:53.120]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.120]                     next
[08:27:53.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.120]                 }
[08:27:53.120]                 if (length(args) > 0) 
[08:27:53.120]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.120]             }
[08:27:53.120]             else {
[08:27:53.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.120]             }
[08:27:53.120]             {
[08:27:53.120]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.120]                   0L) {
[08:27:53.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.120]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.120]                   base::options(opts)
[08:27:53.120]                 }
[08:27:53.120]                 {
[08:27:53.120]                   {
[08:27:53.120]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.120]                     NULL
[08:27:53.120]                   }
[08:27:53.120]                   options(future.plan = NULL)
[08:27:53.120]                   if (is.na(NA_character_)) 
[08:27:53.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.120]                     .init = FALSE)
[08:27:53.120]                 }
[08:27:53.120]             }
[08:27:53.120]         }
[08:27:53.120]     })
[08:27:53.120]     if (TRUE) {
[08:27:53.120]         base::sink(type = "output", split = FALSE)
[08:27:53.120]         if (TRUE) {
[08:27:53.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.120]         }
[08:27:53.120]         else {
[08:27:53.120]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.120]         }
[08:27:53.120]         base::close(...future.stdout)
[08:27:53.120]         ...future.stdout <- NULL
[08:27:53.120]     }
[08:27:53.120]     ...future.result$conditions <- ...future.conditions
[08:27:53.120]     ...future.result$finished <- base::Sys.time()
[08:27:53.120]     ...future.result
[08:27:53.120] }
[08:27:53.174] MultisessionFuture started
[08:27:53.174] result() for ClusterFuture ...
[08:27:53.175] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.175] - Validating connection of MultisessionFuture
[08:27:53.206] - received message: FutureResult
[08:27:53.207] - Received FutureResult
[08:27:53.207] - Erased future from FutureRegistry
[08:27:53.207] result() for ClusterFuture ...
[08:27:53.207] - result already collected: FutureResult
[08:27:53.207] result() for ClusterFuture ... done
[08:27:53.207] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.207] result() for ClusterFuture ... done
[08:27:53.207] result() for ClusterFuture ...
[08:27:53.207] - result already collected: FutureResult
[08:27:53.208] result() for ClusterFuture ... done
[08:27:53.208] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:27:53.209] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[08:27:53.210] getGlobalsAndPackages() ...
[08:27:53.210] Searching for globals...
[08:27:53.210] 
[08:27:53.210] Searching for globals ... DONE
[08:27:53.210] - globals: [0] <none>
[08:27:53.211] getGlobalsAndPackages() ... DONE
[08:27:53.211] run() for ‘Future’ ...
[08:27:53.211] - state: ‘created’
[08:27:53.211] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.225] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.225]   - Field: ‘node’
[08:27:53.226]   - Field: ‘label’
[08:27:53.226]   - Field: ‘local’
[08:27:53.226]   - Field: ‘owner’
[08:27:53.226]   - Field: ‘envir’
[08:27:53.226]   - Field: ‘workers’
[08:27:53.226]   - Field: ‘packages’
[08:27:53.226]   - Field: ‘gc’
[08:27:53.226]   - Field: ‘conditions’
[08:27:53.226]   - Field: ‘persistent’
[08:27:53.226]   - Field: ‘expr’
[08:27:53.227]   - Field: ‘uuid’
[08:27:53.227]   - Field: ‘seed’
[08:27:53.227]   - Field: ‘version’
[08:27:53.227]   - Field: ‘result’
[08:27:53.227]   - Field: ‘asynchronous’
[08:27:53.227]   - Field: ‘calls’
[08:27:53.227]   - Field: ‘globals’
[08:27:53.227]   - Field: ‘stdout’
[08:27:53.228]   - Field: ‘earlySignal’
[08:27:53.228]   - Field: ‘lazy’
[08:27:53.228]   - Field: ‘state’
[08:27:53.228] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.228] - Launch lazy future ...
[08:27:53.228] Packages needed by the future expression (n = 0): <none>
[08:27:53.228] Packages needed by future strategies (n = 0): <none>
[08:27:53.229] {
[08:27:53.229]     {
[08:27:53.229]         {
[08:27:53.229]             ...future.startTime <- base::Sys.time()
[08:27:53.229]             {
[08:27:53.229]                 {
[08:27:53.229]                   {
[08:27:53.229]                     {
[08:27:53.229]                       base::local({
[08:27:53.229]                         has_future <- base::requireNamespace("future", 
[08:27:53.229]                           quietly = TRUE)
[08:27:53.229]                         if (has_future) {
[08:27:53.229]                           ns <- base::getNamespace("future")
[08:27:53.229]                           version <- ns[[".package"]][["version"]]
[08:27:53.229]                           if (is.null(version)) 
[08:27:53.229]                             version <- utils::packageVersion("future")
[08:27:53.229]                         }
[08:27:53.229]                         else {
[08:27:53.229]                           version <- NULL
[08:27:53.229]                         }
[08:27:53.229]                         if (!has_future || version < "1.8.0") {
[08:27:53.229]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.229]                             "", base::R.version$version.string), 
[08:27:53.229]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.229]                               "release", "version")], collapse = " "), 
[08:27:53.229]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.229]                             info)
[08:27:53.229]                           info <- base::paste(info, collapse = "; ")
[08:27:53.229]                           if (!has_future) {
[08:27:53.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.229]                               info)
[08:27:53.229]                           }
[08:27:53.229]                           else {
[08:27:53.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.229]                               info, version)
[08:27:53.229]                           }
[08:27:53.229]                           base::stop(msg)
[08:27:53.229]                         }
[08:27:53.229]                       })
[08:27:53.229]                     }
[08:27:53.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.229]                     base::options(mc.cores = 1L)
[08:27:53.229]                   }
[08:27:53.229]                   ...future.strategy.old <- future::plan("list")
[08:27:53.229]                   options(future.plan = NULL)
[08:27:53.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.229]                 }
[08:27:53.229]                 ...future.workdir <- getwd()
[08:27:53.229]             }
[08:27:53.229]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.229]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.229]         }
[08:27:53.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.229]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.229]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.229]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.229]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.229]             base::names(...future.oldOptions))
[08:27:53.229]     }
[08:27:53.229]     if (FALSE) {
[08:27:53.229]     }
[08:27:53.229]     else {
[08:27:53.229]         if (TRUE) {
[08:27:53.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.229]                 open = "w")
[08:27:53.229]         }
[08:27:53.229]         else {
[08:27:53.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.229]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.229]         }
[08:27:53.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.229]             base::sink(type = "output", split = FALSE)
[08:27:53.229]             base::close(...future.stdout)
[08:27:53.229]         }, add = TRUE)
[08:27:53.229]     }
[08:27:53.229]     ...future.frame <- base::sys.nframe()
[08:27:53.229]     ...future.conditions <- base::list()
[08:27:53.229]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.229]     if (FALSE) {
[08:27:53.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.229]     }
[08:27:53.229]     ...future.result <- base::tryCatch({
[08:27:53.229]         base::withCallingHandlers({
[08:27:53.229]             ...future.value <- base::withVisible(base::local({
[08:27:53.229]                 ...future.makeSendCondition <- base::local({
[08:27:53.229]                   sendCondition <- NULL
[08:27:53.229]                   function(frame = 1L) {
[08:27:53.229]                     if (is.function(sendCondition)) 
[08:27:53.229]                       return(sendCondition)
[08:27:53.229]                     ns <- getNamespace("parallel")
[08:27:53.229]                     if (exists("sendData", mode = "function", 
[08:27:53.229]                       envir = ns)) {
[08:27:53.229]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.229]                         envir = ns)
[08:27:53.229]                       envir <- sys.frame(frame)
[08:27:53.229]                       master <- NULL
[08:27:53.229]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.229]                         !identical(envir, emptyenv())) {
[08:27:53.229]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.229]                           inherits = FALSE)) {
[08:27:53.229]                           master <- get("master", mode = "list", 
[08:27:53.229]                             envir = envir, inherits = FALSE)
[08:27:53.229]                           if (inherits(master, c("SOCKnode", 
[08:27:53.229]                             "SOCK0node"))) {
[08:27:53.229]                             sendCondition <<- function(cond) {
[08:27:53.229]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.229]                                 success = TRUE)
[08:27:53.229]                               parallel_sendData(master, data)
[08:27:53.229]                             }
[08:27:53.229]                             return(sendCondition)
[08:27:53.229]                           }
[08:27:53.229]                         }
[08:27:53.229]                         frame <- frame + 1L
[08:27:53.229]                         envir <- sys.frame(frame)
[08:27:53.229]                       }
[08:27:53.229]                     }
[08:27:53.229]                     sendCondition <<- function(cond) NULL
[08:27:53.229]                   }
[08:27:53.229]                 })
[08:27:53.229]                 withCallingHandlers({
[08:27:53.229]                   2
[08:27:53.229]                 }, immediateCondition = function(cond) {
[08:27:53.229]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.229]                   sendCondition(cond)
[08:27:53.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.229]                   {
[08:27:53.229]                     inherits <- base::inherits
[08:27:53.229]                     invokeRestart <- base::invokeRestart
[08:27:53.229]                     is.null <- base::is.null
[08:27:53.229]                     muffled <- FALSE
[08:27:53.229]                     if (inherits(cond, "message")) {
[08:27:53.229]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.229]                       if (muffled) 
[08:27:53.229]                         invokeRestart("muffleMessage")
[08:27:53.229]                     }
[08:27:53.229]                     else if (inherits(cond, "warning")) {
[08:27:53.229]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.229]                       if (muffled) 
[08:27:53.229]                         invokeRestart("muffleWarning")
[08:27:53.229]                     }
[08:27:53.229]                     else if (inherits(cond, "condition")) {
[08:27:53.229]                       if (!is.null(pattern)) {
[08:27:53.229]                         computeRestarts <- base::computeRestarts
[08:27:53.229]                         grepl <- base::grepl
[08:27:53.229]                         restarts <- computeRestarts(cond)
[08:27:53.229]                         for (restart in restarts) {
[08:27:53.229]                           name <- restart$name
[08:27:53.229]                           if (is.null(name)) 
[08:27:53.229]                             next
[08:27:53.229]                           if (!grepl(pattern, name)) 
[08:27:53.229]                             next
[08:27:53.229]                           invokeRestart(restart)
[08:27:53.229]                           muffled <- TRUE
[08:27:53.229]                           break
[08:27:53.229]                         }
[08:27:53.229]                       }
[08:27:53.229]                     }
[08:27:53.229]                     invisible(muffled)
[08:27:53.229]                   }
[08:27:53.229]                   muffleCondition(cond)
[08:27:53.229]                 })
[08:27:53.229]             }))
[08:27:53.229]             future::FutureResult(value = ...future.value$value, 
[08:27:53.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.229]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.229]                     ...future.globalenv.names))
[08:27:53.229]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.229]         }, condition = base::local({
[08:27:53.229]             c <- base::c
[08:27:53.229]             inherits <- base::inherits
[08:27:53.229]             invokeRestart <- base::invokeRestart
[08:27:53.229]             length <- base::length
[08:27:53.229]             list <- base::list
[08:27:53.229]             seq.int <- base::seq.int
[08:27:53.229]             signalCondition <- base::signalCondition
[08:27:53.229]             sys.calls <- base::sys.calls
[08:27:53.229]             `[[` <- base::`[[`
[08:27:53.229]             `+` <- base::`+`
[08:27:53.229]             `<<-` <- base::`<<-`
[08:27:53.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.229]                   3L)]
[08:27:53.229]             }
[08:27:53.229]             function(cond) {
[08:27:53.229]                 is_error <- inherits(cond, "error")
[08:27:53.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.229]                   NULL)
[08:27:53.229]                 if (is_error) {
[08:27:53.229]                   sessionInformation <- function() {
[08:27:53.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.229]                       search = base::search(), system = base::Sys.info())
[08:27:53.229]                   }
[08:27:53.229]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.229]                     cond$call), session = sessionInformation(), 
[08:27:53.229]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.229]                   signalCondition(cond)
[08:27:53.229]                 }
[08:27:53.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.229]                 "immediateCondition"))) {
[08:27:53.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.229]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.229]                   if (TRUE && !signal) {
[08:27:53.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.229]                     {
[08:27:53.229]                       inherits <- base::inherits
[08:27:53.229]                       invokeRestart <- base::invokeRestart
[08:27:53.229]                       is.null <- base::is.null
[08:27:53.229]                       muffled <- FALSE
[08:27:53.229]                       if (inherits(cond, "message")) {
[08:27:53.229]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.229]                         if (muffled) 
[08:27:53.229]                           invokeRestart("muffleMessage")
[08:27:53.229]                       }
[08:27:53.229]                       else if (inherits(cond, "warning")) {
[08:27:53.229]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.229]                         if (muffled) 
[08:27:53.229]                           invokeRestart("muffleWarning")
[08:27:53.229]                       }
[08:27:53.229]                       else if (inherits(cond, "condition")) {
[08:27:53.229]                         if (!is.null(pattern)) {
[08:27:53.229]                           computeRestarts <- base::computeRestarts
[08:27:53.229]                           grepl <- base::grepl
[08:27:53.229]                           restarts <- computeRestarts(cond)
[08:27:53.229]                           for (restart in restarts) {
[08:27:53.229]                             name <- restart$name
[08:27:53.229]                             if (is.null(name)) 
[08:27:53.229]                               next
[08:27:53.229]                             if (!grepl(pattern, name)) 
[08:27:53.229]                               next
[08:27:53.229]                             invokeRestart(restart)
[08:27:53.229]                             muffled <- TRUE
[08:27:53.229]                             break
[08:27:53.229]                           }
[08:27:53.229]                         }
[08:27:53.229]                       }
[08:27:53.229]                       invisible(muffled)
[08:27:53.229]                     }
[08:27:53.229]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.229]                   }
[08:27:53.229]                 }
[08:27:53.229]                 else {
[08:27:53.229]                   if (TRUE) {
[08:27:53.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.229]                     {
[08:27:53.229]                       inherits <- base::inherits
[08:27:53.229]                       invokeRestart <- base::invokeRestart
[08:27:53.229]                       is.null <- base::is.null
[08:27:53.229]                       muffled <- FALSE
[08:27:53.229]                       if (inherits(cond, "message")) {
[08:27:53.229]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.229]                         if (muffled) 
[08:27:53.229]                           invokeRestart("muffleMessage")
[08:27:53.229]                       }
[08:27:53.229]                       else if (inherits(cond, "warning")) {
[08:27:53.229]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.229]                         if (muffled) 
[08:27:53.229]                           invokeRestart("muffleWarning")
[08:27:53.229]                       }
[08:27:53.229]                       else if (inherits(cond, "condition")) {
[08:27:53.229]                         if (!is.null(pattern)) {
[08:27:53.229]                           computeRestarts <- base::computeRestarts
[08:27:53.229]                           grepl <- base::grepl
[08:27:53.229]                           restarts <- computeRestarts(cond)
[08:27:53.229]                           for (restart in restarts) {
[08:27:53.229]                             name <- restart$name
[08:27:53.229]                             if (is.null(name)) 
[08:27:53.229]                               next
[08:27:53.229]                             if (!grepl(pattern, name)) 
[08:27:53.229]                               next
[08:27:53.229]                             invokeRestart(restart)
[08:27:53.229]                             muffled <- TRUE
[08:27:53.229]                             break
[08:27:53.229]                           }
[08:27:53.229]                         }
[08:27:53.229]                       }
[08:27:53.229]                       invisible(muffled)
[08:27:53.229]                     }
[08:27:53.229]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.229]                   }
[08:27:53.229]                 }
[08:27:53.229]             }
[08:27:53.229]         }))
[08:27:53.229]     }, error = function(ex) {
[08:27:53.229]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.229]                 ...future.rng), started = ...future.startTime, 
[08:27:53.229]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.229]             version = "1.8"), class = "FutureResult")
[08:27:53.229]     }, finally = {
[08:27:53.229]         if (!identical(...future.workdir, getwd())) 
[08:27:53.229]             setwd(...future.workdir)
[08:27:53.229]         {
[08:27:53.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.229]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.229]             }
[08:27:53.229]             base::options(...future.oldOptions)
[08:27:53.229]             if (.Platform$OS.type == "windows") {
[08:27:53.229]                 old_names <- names(...future.oldEnvVars)
[08:27:53.229]                 envs <- base::Sys.getenv()
[08:27:53.229]                 names <- names(envs)
[08:27:53.229]                 common <- intersect(names, old_names)
[08:27:53.229]                 added <- setdiff(names, old_names)
[08:27:53.229]                 removed <- setdiff(old_names, names)
[08:27:53.229]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.229]                   envs[common]]
[08:27:53.229]                 NAMES <- toupper(changed)
[08:27:53.229]                 args <- list()
[08:27:53.229]                 for (kk in seq_along(NAMES)) {
[08:27:53.229]                   name <- changed[[kk]]
[08:27:53.229]                   NAME <- NAMES[[kk]]
[08:27:53.229]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.229]                     next
[08:27:53.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.229]                 }
[08:27:53.229]                 NAMES <- toupper(added)
[08:27:53.229]                 for (kk in seq_along(NAMES)) {
[08:27:53.229]                   name <- added[[kk]]
[08:27:53.229]                   NAME <- NAMES[[kk]]
[08:27:53.229]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.229]                     next
[08:27:53.229]                   args[[name]] <- ""
[08:27:53.229]                 }
[08:27:53.229]                 NAMES <- toupper(removed)
[08:27:53.229]                 for (kk in seq_along(NAMES)) {
[08:27:53.229]                   name <- removed[[kk]]
[08:27:53.229]                   NAME <- NAMES[[kk]]
[08:27:53.229]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.229]                     next
[08:27:53.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.229]                 }
[08:27:53.229]                 if (length(args) > 0) 
[08:27:53.229]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.229]             }
[08:27:53.229]             else {
[08:27:53.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.229]             }
[08:27:53.229]             {
[08:27:53.229]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.229]                   0L) {
[08:27:53.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.229]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.229]                   base::options(opts)
[08:27:53.229]                 }
[08:27:53.229]                 {
[08:27:53.229]                   {
[08:27:53.229]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.229]                     NULL
[08:27:53.229]                   }
[08:27:53.229]                   options(future.plan = NULL)
[08:27:53.229]                   if (is.na(NA_character_)) 
[08:27:53.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.229]                     .init = FALSE)
[08:27:53.229]                 }
[08:27:53.229]             }
[08:27:53.229]         }
[08:27:53.229]     })
[08:27:53.229]     if (TRUE) {
[08:27:53.229]         base::sink(type = "output", split = FALSE)
[08:27:53.229]         if (TRUE) {
[08:27:53.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.229]         }
[08:27:53.229]         else {
[08:27:53.229]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.229]         }
[08:27:53.229]         base::close(...future.stdout)
[08:27:53.229]         ...future.stdout <- NULL
[08:27:53.229]     }
[08:27:53.229]     ...future.result$conditions <- ...future.conditions
[08:27:53.229]     ...future.result$finished <- base::Sys.time()
[08:27:53.229]     ...future.result
[08:27:53.229] }
[08:27:53.232] MultisessionFuture started
[08:27:53.232] - Launch lazy future ... done
[08:27:53.233] run() for ‘MultisessionFuture’ ... done
[08:27:53.233] getGlobalsAndPackages() ...
[08:27:53.233] Searching for globals...
[08:27:53.233] 
[08:27:53.233] Searching for globals ... DONE
[08:27:53.234] - globals: [0] <none>
[08:27:53.234] getGlobalsAndPackages() ... DONE
[08:27:53.234] run() for ‘Future’ ...
[08:27:53.234] - state: ‘created’
[08:27:53.234] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.249] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.249] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.249]   - Field: ‘node’
[08:27:53.249]   - Field: ‘label’
[08:27:53.249]   - Field: ‘local’
[08:27:53.249]   - Field: ‘owner’
[08:27:53.249]   - Field: ‘envir’
[08:27:53.250]   - Field: ‘workers’
[08:27:53.250]   - Field: ‘packages’
[08:27:53.250]   - Field: ‘gc’
[08:27:53.250]   - Field: ‘conditions’
[08:27:53.250]   - Field: ‘persistent’
[08:27:53.250]   - Field: ‘expr’
[08:27:53.250]   - Field: ‘uuid’
[08:27:53.250]   - Field: ‘seed’
[08:27:53.250]   - Field: ‘version’
[08:27:53.251]   - Field: ‘result’
[08:27:53.251]   - Field: ‘asynchronous’
[08:27:53.251]   - Field: ‘calls’
[08:27:53.251]   - Field: ‘globals’
[08:27:53.251]   - Field: ‘stdout’
[08:27:53.251]   - Field: ‘earlySignal’
[08:27:53.251]   - Field: ‘lazy’
[08:27:53.251]   - Field: ‘state’
[08:27:53.251] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.251] - Launch lazy future ...
[08:27:53.252] Packages needed by the future expression (n = 0): <none>
[08:27:53.252] Packages needed by future strategies (n = 0): <none>
[08:27:53.252] {
[08:27:53.252]     {
[08:27:53.252]         {
[08:27:53.252]             ...future.startTime <- base::Sys.time()
[08:27:53.252]             {
[08:27:53.252]                 {
[08:27:53.252]                   {
[08:27:53.252]                     {
[08:27:53.252]                       base::local({
[08:27:53.252]                         has_future <- base::requireNamespace("future", 
[08:27:53.252]                           quietly = TRUE)
[08:27:53.252]                         if (has_future) {
[08:27:53.252]                           ns <- base::getNamespace("future")
[08:27:53.252]                           version <- ns[[".package"]][["version"]]
[08:27:53.252]                           if (is.null(version)) 
[08:27:53.252]                             version <- utils::packageVersion("future")
[08:27:53.252]                         }
[08:27:53.252]                         else {
[08:27:53.252]                           version <- NULL
[08:27:53.252]                         }
[08:27:53.252]                         if (!has_future || version < "1.8.0") {
[08:27:53.252]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.252]                             "", base::R.version$version.string), 
[08:27:53.252]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.252]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.252]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.252]                               "release", "version")], collapse = " "), 
[08:27:53.252]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.252]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.252]                             info)
[08:27:53.252]                           info <- base::paste(info, collapse = "; ")
[08:27:53.252]                           if (!has_future) {
[08:27:53.252]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.252]                               info)
[08:27:53.252]                           }
[08:27:53.252]                           else {
[08:27:53.252]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.252]                               info, version)
[08:27:53.252]                           }
[08:27:53.252]                           base::stop(msg)
[08:27:53.252]                         }
[08:27:53.252]                       })
[08:27:53.252]                     }
[08:27:53.252]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.252]                     base::options(mc.cores = 1L)
[08:27:53.252]                   }
[08:27:53.252]                   ...future.strategy.old <- future::plan("list")
[08:27:53.252]                   options(future.plan = NULL)
[08:27:53.252]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.252]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.252]                 }
[08:27:53.252]                 ...future.workdir <- getwd()
[08:27:53.252]             }
[08:27:53.252]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.252]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.252]         }
[08:27:53.252]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.252]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.252]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.252]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.252]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.252]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.252]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.252]             base::names(...future.oldOptions))
[08:27:53.252]     }
[08:27:53.252]     if (FALSE) {
[08:27:53.252]     }
[08:27:53.252]     else {
[08:27:53.252]         if (TRUE) {
[08:27:53.252]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.252]                 open = "w")
[08:27:53.252]         }
[08:27:53.252]         else {
[08:27:53.252]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.252]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.252]         }
[08:27:53.252]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.252]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.252]             base::sink(type = "output", split = FALSE)
[08:27:53.252]             base::close(...future.stdout)
[08:27:53.252]         }, add = TRUE)
[08:27:53.252]     }
[08:27:53.252]     ...future.frame <- base::sys.nframe()
[08:27:53.252]     ...future.conditions <- base::list()
[08:27:53.252]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.252]     if (FALSE) {
[08:27:53.252]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.252]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.252]     }
[08:27:53.252]     ...future.result <- base::tryCatch({
[08:27:53.252]         base::withCallingHandlers({
[08:27:53.252]             ...future.value <- base::withVisible(base::local({
[08:27:53.252]                 ...future.makeSendCondition <- base::local({
[08:27:53.252]                   sendCondition <- NULL
[08:27:53.252]                   function(frame = 1L) {
[08:27:53.252]                     if (is.function(sendCondition)) 
[08:27:53.252]                       return(sendCondition)
[08:27:53.252]                     ns <- getNamespace("parallel")
[08:27:53.252]                     if (exists("sendData", mode = "function", 
[08:27:53.252]                       envir = ns)) {
[08:27:53.252]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.252]                         envir = ns)
[08:27:53.252]                       envir <- sys.frame(frame)
[08:27:53.252]                       master <- NULL
[08:27:53.252]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.252]                         !identical(envir, emptyenv())) {
[08:27:53.252]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.252]                           inherits = FALSE)) {
[08:27:53.252]                           master <- get("master", mode = "list", 
[08:27:53.252]                             envir = envir, inherits = FALSE)
[08:27:53.252]                           if (inherits(master, c("SOCKnode", 
[08:27:53.252]                             "SOCK0node"))) {
[08:27:53.252]                             sendCondition <<- function(cond) {
[08:27:53.252]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.252]                                 success = TRUE)
[08:27:53.252]                               parallel_sendData(master, data)
[08:27:53.252]                             }
[08:27:53.252]                             return(sendCondition)
[08:27:53.252]                           }
[08:27:53.252]                         }
[08:27:53.252]                         frame <- frame + 1L
[08:27:53.252]                         envir <- sys.frame(frame)
[08:27:53.252]                       }
[08:27:53.252]                     }
[08:27:53.252]                     sendCondition <<- function(cond) NULL
[08:27:53.252]                   }
[08:27:53.252]                 })
[08:27:53.252]                 withCallingHandlers({
[08:27:53.252]                   NULL
[08:27:53.252]                 }, immediateCondition = function(cond) {
[08:27:53.252]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.252]                   sendCondition(cond)
[08:27:53.252]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.252]                   {
[08:27:53.252]                     inherits <- base::inherits
[08:27:53.252]                     invokeRestart <- base::invokeRestart
[08:27:53.252]                     is.null <- base::is.null
[08:27:53.252]                     muffled <- FALSE
[08:27:53.252]                     if (inherits(cond, "message")) {
[08:27:53.252]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.252]                       if (muffled) 
[08:27:53.252]                         invokeRestart("muffleMessage")
[08:27:53.252]                     }
[08:27:53.252]                     else if (inherits(cond, "warning")) {
[08:27:53.252]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.252]                       if (muffled) 
[08:27:53.252]                         invokeRestart("muffleWarning")
[08:27:53.252]                     }
[08:27:53.252]                     else if (inherits(cond, "condition")) {
[08:27:53.252]                       if (!is.null(pattern)) {
[08:27:53.252]                         computeRestarts <- base::computeRestarts
[08:27:53.252]                         grepl <- base::grepl
[08:27:53.252]                         restarts <- computeRestarts(cond)
[08:27:53.252]                         for (restart in restarts) {
[08:27:53.252]                           name <- restart$name
[08:27:53.252]                           if (is.null(name)) 
[08:27:53.252]                             next
[08:27:53.252]                           if (!grepl(pattern, name)) 
[08:27:53.252]                             next
[08:27:53.252]                           invokeRestart(restart)
[08:27:53.252]                           muffled <- TRUE
[08:27:53.252]                           break
[08:27:53.252]                         }
[08:27:53.252]                       }
[08:27:53.252]                     }
[08:27:53.252]                     invisible(muffled)
[08:27:53.252]                   }
[08:27:53.252]                   muffleCondition(cond)
[08:27:53.252]                 })
[08:27:53.252]             }))
[08:27:53.252]             future::FutureResult(value = ...future.value$value, 
[08:27:53.252]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.252]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.252]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.252]                     ...future.globalenv.names))
[08:27:53.252]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.252]         }, condition = base::local({
[08:27:53.252]             c <- base::c
[08:27:53.252]             inherits <- base::inherits
[08:27:53.252]             invokeRestart <- base::invokeRestart
[08:27:53.252]             length <- base::length
[08:27:53.252]             list <- base::list
[08:27:53.252]             seq.int <- base::seq.int
[08:27:53.252]             signalCondition <- base::signalCondition
[08:27:53.252]             sys.calls <- base::sys.calls
[08:27:53.252]             `[[` <- base::`[[`
[08:27:53.252]             `+` <- base::`+`
[08:27:53.252]             `<<-` <- base::`<<-`
[08:27:53.252]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.252]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.252]                   3L)]
[08:27:53.252]             }
[08:27:53.252]             function(cond) {
[08:27:53.252]                 is_error <- inherits(cond, "error")
[08:27:53.252]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.252]                   NULL)
[08:27:53.252]                 if (is_error) {
[08:27:53.252]                   sessionInformation <- function() {
[08:27:53.252]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.252]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.252]                       search = base::search(), system = base::Sys.info())
[08:27:53.252]                   }
[08:27:53.252]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.252]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.252]                     cond$call), session = sessionInformation(), 
[08:27:53.252]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.252]                   signalCondition(cond)
[08:27:53.252]                 }
[08:27:53.252]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.252]                 "immediateCondition"))) {
[08:27:53.252]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.252]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.252]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.252]                   if (TRUE && !signal) {
[08:27:53.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.252]                     {
[08:27:53.252]                       inherits <- base::inherits
[08:27:53.252]                       invokeRestart <- base::invokeRestart
[08:27:53.252]                       is.null <- base::is.null
[08:27:53.252]                       muffled <- FALSE
[08:27:53.252]                       if (inherits(cond, "message")) {
[08:27:53.252]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.252]                         if (muffled) 
[08:27:53.252]                           invokeRestart("muffleMessage")
[08:27:53.252]                       }
[08:27:53.252]                       else if (inherits(cond, "warning")) {
[08:27:53.252]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.252]                         if (muffled) 
[08:27:53.252]                           invokeRestart("muffleWarning")
[08:27:53.252]                       }
[08:27:53.252]                       else if (inherits(cond, "condition")) {
[08:27:53.252]                         if (!is.null(pattern)) {
[08:27:53.252]                           computeRestarts <- base::computeRestarts
[08:27:53.252]                           grepl <- base::grepl
[08:27:53.252]                           restarts <- computeRestarts(cond)
[08:27:53.252]                           for (restart in restarts) {
[08:27:53.252]                             name <- restart$name
[08:27:53.252]                             if (is.null(name)) 
[08:27:53.252]                               next
[08:27:53.252]                             if (!grepl(pattern, name)) 
[08:27:53.252]                               next
[08:27:53.252]                             invokeRestart(restart)
[08:27:53.252]                             muffled <- TRUE
[08:27:53.252]                             break
[08:27:53.252]                           }
[08:27:53.252]                         }
[08:27:53.252]                       }
[08:27:53.252]                       invisible(muffled)
[08:27:53.252]                     }
[08:27:53.252]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.252]                   }
[08:27:53.252]                 }
[08:27:53.252]                 else {
[08:27:53.252]                   if (TRUE) {
[08:27:53.252]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.252]                     {
[08:27:53.252]                       inherits <- base::inherits
[08:27:53.252]                       invokeRestart <- base::invokeRestart
[08:27:53.252]                       is.null <- base::is.null
[08:27:53.252]                       muffled <- FALSE
[08:27:53.252]                       if (inherits(cond, "message")) {
[08:27:53.252]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.252]                         if (muffled) 
[08:27:53.252]                           invokeRestart("muffleMessage")
[08:27:53.252]                       }
[08:27:53.252]                       else if (inherits(cond, "warning")) {
[08:27:53.252]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.252]                         if (muffled) 
[08:27:53.252]                           invokeRestart("muffleWarning")
[08:27:53.252]                       }
[08:27:53.252]                       else if (inherits(cond, "condition")) {
[08:27:53.252]                         if (!is.null(pattern)) {
[08:27:53.252]                           computeRestarts <- base::computeRestarts
[08:27:53.252]                           grepl <- base::grepl
[08:27:53.252]                           restarts <- computeRestarts(cond)
[08:27:53.252]                           for (restart in restarts) {
[08:27:53.252]                             name <- restart$name
[08:27:53.252]                             if (is.null(name)) 
[08:27:53.252]                               next
[08:27:53.252]                             if (!grepl(pattern, name)) 
[08:27:53.252]                               next
[08:27:53.252]                             invokeRestart(restart)
[08:27:53.252]                             muffled <- TRUE
[08:27:53.252]                             break
[08:27:53.252]                           }
[08:27:53.252]                         }
[08:27:53.252]                       }
[08:27:53.252]                       invisible(muffled)
[08:27:53.252]                     }
[08:27:53.252]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.252]                   }
[08:27:53.252]                 }
[08:27:53.252]             }
[08:27:53.252]         }))
[08:27:53.252]     }, error = function(ex) {
[08:27:53.252]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.252]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.252]                 ...future.rng), started = ...future.startTime, 
[08:27:53.252]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.252]             version = "1.8"), class = "FutureResult")
[08:27:53.252]     }, finally = {
[08:27:53.252]         if (!identical(...future.workdir, getwd())) 
[08:27:53.252]             setwd(...future.workdir)
[08:27:53.252]         {
[08:27:53.252]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.252]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.252]             }
[08:27:53.252]             base::options(...future.oldOptions)
[08:27:53.252]             if (.Platform$OS.type == "windows") {
[08:27:53.252]                 old_names <- names(...future.oldEnvVars)
[08:27:53.252]                 envs <- base::Sys.getenv()
[08:27:53.252]                 names <- names(envs)
[08:27:53.252]                 common <- intersect(names, old_names)
[08:27:53.252]                 added <- setdiff(names, old_names)
[08:27:53.252]                 removed <- setdiff(old_names, names)
[08:27:53.252]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.252]                   envs[common]]
[08:27:53.252]                 NAMES <- toupper(changed)
[08:27:53.252]                 args <- list()
[08:27:53.252]                 for (kk in seq_along(NAMES)) {
[08:27:53.252]                   name <- changed[[kk]]
[08:27:53.252]                   NAME <- NAMES[[kk]]
[08:27:53.252]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.252]                     next
[08:27:53.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.252]                 }
[08:27:53.252]                 NAMES <- toupper(added)
[08:27:53.252]                 for (kk in seq_along(NAMES)) {
[08:27:53.252]                   name <- added[[kk]]
[08:27:53.252]                   NAME <- NAMES[[kk]]
[08:27:53.252]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.252]                     next
[08:27:53.252]                   args[[name]] <- ""
[08:27:53.252]                 }
[08:27:53.252]                 NAMES <- toupper(removed)
[08:27:53.252]                 for (kk in seq_along(NAMES)) {
[08:27:53.252]                   name <- removed[[kk]]
[08:27:53.252]                   NAME <- NAMES[[kk]]
[08:27:53.252]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.252]                     next
[08:27:53.252]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.252]                 }
[08:27:53.252]                 if (length(args) > 0) 
[08:27:53.252]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.252]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.252]             }
[08:27:53.252]             else {
[08:27:53.252]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.252]             }
[08:27:53.252]             {
[08:27:53.252]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.252]                   0L) {
[08:27:53.252]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.252]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.252]                   base::options(opts)
[08:27:53.252]                 }
[08:27:53.252]                 {
[08:27:53.252]                   {
[08:27:53.252]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.252]                     NULL
[08:27:53.252]                   }
[08:27:53.252]                   options(future.plan = NULL)
[08:27:53.252]                   if (is.na(NA_character_)) 
[08:27:53.252]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.252]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.252]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.252]                     .init = FALSE)
[08:27:53.252]                 }
[08:27:53.252]             }
[08:27:53.252]         }
[08:27:53.252]     })
[08:27:53.252]     if (TRUE) {
[08:27:53.252]         base::sink(type = "output", split = FALSE)
[08:27:53.252]         if (TRUE) {
[08:27:53.252]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.252]         }
[08:27:53.252]         else {
[08:27:53.252]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.252]         }
[08:27:53.252]         base::close(...future.stdout)
[08:27:53.252]         ...future.stdout <- NULL
[08:27:53.252]     }
[08:27:53.252]     ...future.result$conditions <- ...future.conditions
[08:27:53.252]     ...future.result$finished <- base::Sys.time()
[08:27:53.252]     ...future.result
[08:27:53.252] }
[08:27:53.306] MultisessionFuture started
[08:27:53.306] - Launch lazy future ... done
[08:27:53.306] run() for ‘MultisessionFuture’ ... done
[08:27:53.307] getGlobalsAndPackages() ...
[08:27:53.307] Searching for globals...
[08:27:53.308] - globals found: [1] ‘{’
[08:27:53.308] Searching for globals ... DONE
[08:27:53.308] Resolving globals: FALSE
[08:27:53.308] 
[08:27:53.309] 
[08:27:53.309] getGlobalsAndPackages() ... DONE
[08:27:53.309] run() for ‘Future’ ...
[08:27:53.309] - state: ‘created’
[08:27:53.309] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.324] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.324] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.325]   - Field: ‘node’
[08:27:53.325]   - Field: ‘label’
[08:27:53.325]   - Field: ‘local’
[08:27:53.325]   - Field: ‘owner’
[08:27:53.325]   - Field: ‘envir’
[08:27:53.325]   - Field: ‘workers’
[08:27:53.325]   - Field: ‘packages’
[08:27:53.325]   - Field: ‘gc’
[08:27:53.325]   - Field: ‘conditions’
[08:27:53.326]   - Field: ‘persistent’
[08:27:53.326]   - Field: ‘expr’
[08:27:53.326]   - Field: ‘uuid’
[08:27:53.326]   - Field: ‘seed’
[08:27:53.326]   - Field: ‘version’
[08:27:53.326]   - Field: ‘result’
[08:27:53.326]   - Field: ‘asynchronous’
[08:27:53.326]   - Field: ‘calls’
[08:27:53.326]   - Field: ‘globals’
[08:27:53.326]   - Field: ‘stdout’
[08:27:53.327]   - Field: ‘earlySignal’
[08:27:53.327]   - Field: ‘lazy’
[08:27:53.327]   - Field: ‘state’
[08:27:53.327] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.327] - Launch lazy future ...
[08:27:53.327] Packages needed by the future expression (n = 0): <none>
[08:27:53.327] Packages needed by future strategies (n = 0): <none>
[08:27:53.328] {
[08:27:53.328]     {
[08:27:53.328]         {
[08:27:53.328]             ...future.startTime <- base::Sys.time()
[08:27:53.328]             {
[08:27:53.328]                 {
[08:27:53.328]                   {
[08:27:53.328]                     {
[08:27:53.328]                       base::local({
[08:27:53.328]                         has_future <- base::requireNamespace("future", 
[08:27:53.328]                           quietly = TRUE)
[08:27:53.328]                         if (has_future) {
[08:27:53.328]                           ns <- base::getNamespace("future")
[08:27:53.328]                           version <- ns[[".package"]][["version"]]
[08:27:53.328]                           if (is.null(version)) 
[08:27:53.328]                             version <- utils::packageVersion("future")
[08:27:53.328]                         }
[08:27:53.328]                         else {
[08:27:53.328]                           version <- NULL
[08:27:53.328]                         }
[08:27:53.328]                         if (!has_future || version < "1.8.0") {
[08:27:53.328]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.328]                             "", base::R.version$version.string), 
[08:27:53.328]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.328]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.328]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.328]                               "release", "version")], collapse = " "), 
[08:27:53.328]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.328]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.328]                             info)
[08:27:53.328]                           info <- base::paste(info, collapse = "; ")
[08:27:53.328]                           if (!has_future) {
[08:27:53.328]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.328]                               info)
[08:27:53.328]                           }
[08:27:53.328]                           else {
[08:27:53.328]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.328]                               info, version)
[08:27:53.328]                           }
[08:27:53.328]                           base::stop(msg)
[08:27:53.328]                         }
[08:27:53.328]                       })
[08:27:53.328]                     }
[08:27:53.328]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.328]                     base::options(mc.cores = 1L)
[08:27:53.328]                   }
[08:27:53.328]                   ...future.strategy.old <- future::plan("list")
[08:27:53.328]                   options(future.plan = NULL)
[08:27:53.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.328]                 }
[08:27:53.328]                 ...future.workdir <- getwd()
[08:27:53.328]             }
[08:27:53.328]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.328]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.328]         }
[08:27:53.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.328]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.328]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.328]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.328]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.328]             base::names(...future.oldOptions))
[08:27:53.328]     }
[08:27:53.328]     if (FALSE) {
[08:27:53.328]     }
[08:27:53.328]     else {
[08:27:53.328]         if (TRUE) {
[08:27:53.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.328]                 open = "w")
[08:27:53.328]         }
[08:27:53.328]         else {
[08:27:53.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.328]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.328]         }
[08:27:53.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.328]             base::sink(type = "output", split = FALSE)
[08:27:53.328]             base::close(...future.stdout)
[08:27:53.328]         }, add = TRUE)
[08:27:53.328]     }
[08:27:53.328]     ...future.frame <- base::sys.nframe()
[08:27:53.328]     ...future.conditions <- base::list()
[08:27:53.328]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.328]     if (FALSE) {
[08:27:53.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.328]     }
[08:27:53.328]     ...future.result <- base::tryCatch({
[08:27:53.328]         base::withCallingHandlers({
[08:27:53.328]             ...future.value <- base::withVisible(base::local({
[08:27:53.328]                 ...future.makeSendCondition <- base::local({
[08:27:53.328]                   sendCondition <- NULL
[08:27:53.328]                   function(frame = 1L) {
[08:27:53.328]                     if (is.function(sendCondition)) 
[08:27:53.328]                       return(sendCondition)
[08:27:53.328]                     ns <- getNamespace("parallel")
[08:27:53.328]                     if (exists("sendData", mode = "function", 
[08:27:53.328]                       envir = ns)) {
[08:27:53.328]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.328]                         envir = ns)
[08:27:53.328]                       envir <- sys.frame(frame)
[08:27:53.328]                       master <- NULL
[08:27:53.328]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.328]                         !identical(envir, emptyenv())) {
[08:27:53.328]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.328]                           inherits = FALSE)) {
[08:27:53.328]                           master <- get("master", mode = "list", 
[08:27:53.328]                             envir = envir, inherits = FALSE)
[08:27:53.328]                           if (inherits(master, c("SOCKnode", 
[08:27:53.328]                             "SOCK0node"))) {
[08:27:53.328]                             sendCondition <<- function(cond) {
[08:27:53.328]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.328]                                 success = TRUE)
[08:27:53.328]                               parallel_sendData(master, data)
[08:27:53.328]                             }
[08:27:53.328]                             return(sendCondition)
[08:27:53.328]                           }
[08:27:53.328]                         }
[08:27:53.328]                         frame <- frame + 1L
[08:27:53.328]                         envir <- sys.frame(frame)
[08:27:53.328]                       }
[08:27:53.328]                     }
[08:27:53.328]                     sendCondition <<- function(cond) NULL
[08:27:53.328]                   }
[08:27:53.328]                 })
[08:27:53.328]                 withCallingHandlers({
[08:27:53.328]                   {
[08:27:53.328]                     4
[08:27:53.328]                   }
[08:27:53.328]                 }, immediateCondition = function(cond) {
[08:27:53.328]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.328]                   sendCondition(cond)
[08:27:53.328]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.328]                   {
[08:27:53.328]                     inherits <- base::inherits
[08:27:53.328]                     invokeRestart <- base::invokeRestart
[08:27:53.328]                     is.null <- base::is.null
[08:27:53.328]                     muffled <- FALSE
[08:27:53.328]                     if (inherits(cond, "message")) {
[08:27:53.328]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.328]                       if (muffled) 
[08:27:53.328]                         invokeRestart("muffleMessage")
[08:27:53.328]                     }
[08:27:53.328]                     else if (inherits(cond, "warning")) {
[08:27:53.328]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.328]                       if (muffled) 
[08:27:53.328]                         invokeRestart("muffleWarning")
[08:27:53.328]                     }
[08:27:53.328]                     else if (inherits(cond, "condition")) {
[08:27:53.328]                       if (!is.null(pattern)) {
[08:27:53.328]                         computeRestarts <- base::computeRestarts
[08:27:53.328]                         grepl <- base::grepl
[08:27:53.328]                         restarts <- computeRestarts(cond)
[08:27:53.328]                         for (restart in restarts) {
[08:27:53.328]                           name <- restart$name
[08:27:53.328]                           if (is.null(name)) 
[08:27:53.328]                             next
[08:27:53.328]                           if (!grepl(pattern, name)) 
[08:27:53.328]                             next
[08:27:53.328]                           invokeRestart(restart)
[08:27:53.328]                           muffled <- TRUE
[08:27:53.328]                           break
[08:27:53.328]                         }
[08:27:53.328]                       }
[08:27:53.328]                     }
[08:27:53.328]                     invisible(muffled)
[08:27:53.328]                   }
[08:27:53.328]                   muffleCondition(cond)
[08:27:53.328]                 })
[08:27:53.328]             }))
[08:27:53.328]             future::FutureResult(value = ...future.value$value, 
[08:27:53.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.328]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.328]                     ...future.globalenv.names))
[08:27:53.328]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.328]         }, condition = base::local({
[08:27:53.328]             c <- base::c
[08:27:53.328]             inherits <- base::inherits
[08:27:53.328]             invokeRestart <- base::invokeRestart
[08:27:53.328]             length <- base::length
[08:27:53.328]             list <- base::list
[08:27:53.328]             seq.int <- base::seq.int
[08:27:53.328]             signalCondition <- base::signalCondition
[08:27:53.328]             sys.calls <- base::sys.calls
[08:27:53.328]             `[[` <- base::`[[`
[08:27:53.328]             `+` <- base::`+`
[08:27:53.328]             `<<-` <- base::`<<-`
[08:27:53.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.328]                   3L)]
[08:27:53.328]             }
[08:27:53.328]             function(cond) {
[08:27:53.328]                 is_error <- inherits(cond, "error")
[08:27:53.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.328]                   NULL)
[08:27:53.328]                 if (is_error) {
[08:27:53.328]                   sessionInformation <- function() {
[08:27:53.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.328]                       search = base::search(), system = base::Sys.info())
[08:27:53.328]                   }
[08:27:53.328]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.328]                     cond$call), session = sessionInformation(), 
[08:27:53.328]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.328]                   signalCondition(cond)
[08:27:53.328]                 }
[08:27:53.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.328]                 "immediateCondition"))) {
[08:27:53.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.328]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.328]                   if (TRUE && !signal) {
[08:27:53.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.328]                     {
[08:27:53.328]                       inherits <- base::inherits
[08:27:53.328]                       invokeRestart <- base::invokeRestart
[08:27:53.328]                       is.null <- base::is.null
[08:27:53.328]                       muffled <- FALSE
[08:27:53.328]                       if (inherits(cond, "message")) {
[08:27:53.328]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.328]                         if (muffled) 
[08:27:53.328]                           invokeRestart("muffleMessage")
[08:27:53.328]                       }
[08:27:53.328]                       else if (inherits(cond, "warning")) {
[08:27:53.328]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.328]                         if (muffled) 
[08:27:53.328]                           invokeRestart("muffleWarning")
[08:27:53.328]                       }
[08:27:53.328]                       else if (inherits(cond, "condition")) {
[08:27:53.328]                         if (!is.null(pattern)) {
[08:27:53.328]                           computeRestarts <- base::computeRestarts
[08:27:53.328]                           grepl <- base::grepl
[08:27:53.328]                           restarts <- computeRestarts(cond)
[08:27:53.328]                           for (restart in restarts) {
[08:27:53.328]                             name <- restart$name
[08:27:53.328]                             if (is.null(name)) 
[08:27:53.328]                               next
[08:27:53.328]                             if (!grepl(pattern, name)) 
[08:27:53.328]                               next
[08:27:53.328]                             invokeRestart(restart)
[08:27:53.328]                             muffled <- TRUE
[08:27:53.328]                             break
[08:27:53.328]                           }
[08:27:53.328]                         }
[08:27:53.328]                       }
[08:27:53.328]                       invisible(muffled)
[08:27:53.328]                     }
[08:27:53.328]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.328]                   }
[08:27:53.328]                 }
[08:27:53.328]                 else {
[08:27:53.328]                   if (TRUE) {
[08:27:53.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.328]                     {
[08:27:53.328]                       inherits <- base::inherits
[08:27:53.328]                       invokeRestart <- base::invokeRestart
[08:27:53.328]                       is.null <- base::is.null
[08:27:53.328]                       muffled <- FALSE
[08:27:53.328]                       if (inherits(cond, "message")) {
[08:27:53.328]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.328]                         if (muffled) 
[08:27:53.328]                           invokeRestart("muffleMessage")
[08:27:53.328]                       }
[08:27:53.328]                       else if (inherits(cond, "warning")) {
[08:27:53.328]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.328]                         if (muffled) 
[08:27:53.328]                           invokeRestart("muffleWarning")
[08:27:53.328]                       }
[08:27:53.328]                       else if (inherits(cond, "condition")) {
[08:27:53.328]                         if (!is.null(pattern)) {
[08:27:53.328]                           computeRestarts <- base::computeRestarts
[08:27:53.328]                           grepl <- base::grepl
[08:27:53.328]                           restarts <- computeRestarts(cond)
[08:27:53.328]                           for (restart in restarts) {
[08:27:53.328]                             name <- restart$name
[08:27:53.328]                             if (is.null(name)) 
[08:27:53.328]                               next
[08:27:53.328]                             if (!grepl(pattern, name)) 
[08:27:53.328]                               next
[08:27:53.328]                             invokeRestart(restart)
[08:27:53.328]                             muffled <- TRUE
[08:27:53.328]                             break
[08:27:53.328]                           }
[08:27:53.328]                         }
[08:27:53.328]                       }
[08:27:53.328]                       invisible(muffled)
[08:27:53.328]                     }
[08:27:53.328]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.328]                   }
[08:27:53.328]                 }
[08:27:53.328]             }
[08:27:53.328]         }))
[08:27:53.328]     }, error = function(ex) {
[08:27:53.328]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.328]                 ...future.rng), started = ...future.startTime, 
[08:27:53.328]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.328]             version = "1.8"), class = "FutureResult")
[08:27:53.328]     }, finally = {
[08:27:53.328]         if (!identical(...future.workdir, getwd())) 
[08:27:53.328]             setwd(...future.workdir)
[08:27:53.328]         {
[08:27:53.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.328]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.328]             }
[08:27:53.328]             base::options(...future.oldOptions)
[08:27:53.328]             if (.Platform$OS.type == "windows") {
[08:27:53.328]                 old_names <- names(...future.oldEnvVars)
[08:27:53.328]                 envs <- base::Sys.getenv()
[08:27:53.328]                 names <- names(envs)
[08:27:53.328]                 common <- intersect(names, old_names)
[08:27:53.328]                 added <- setdiff(names, old_names)
[08:27:53.328]                 removed <- setdiff(old_names, names)
[08:27:53.328]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.328]                   envs[common]]
[08:27:53.328]                 NAMES <- toupper(changed)
[08:27:53.328]                 args <- list()
[08:27:53.328]                 for (kk in seq_along(NAMES)) {
[08:27:53.328]                   name <- changed[[kk]]
[08:27:53.328]                   NAME <- NAMES[[kk]]
[08:27:53.328]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.328]                     next
[08:27:53.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.328]                 }
[08:27:53.328]                 NAMES <- toupper(added)
[08:27:53.328]                 for (kk in seq_along(NAMES)) {
[08:27:53.328]                   name <- added[[kk]]
[08:27:53.328]                   NAME <- NAMES[[kk]]
[08:27:53.328]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.328]                     next
[08:27:53.328]                   args[[name]] <- ""
[08:27:53.328]                 }
[08:27:53.328]                 NAMES <- toupper(removed)
[08:27:53.328]                 for (kk in seq_along(NAMES)) {
[08:27:53.328]                   name <- removed[[kk]]
[08:27:53.328]                   NAME <- NAMES[[kk]]
[08:27:53.328]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.328]                     next
[08:27:53.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.328]                 }
[08:27:53.328]                 if (length(args) > 0) 
[08:27:53.328]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.328]             }
[08:27:53.328]             else {
[08:27:53.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.328]             }
[08:27:53.328]             {
[08:27:53.328]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.328]                   0L) {
[08:27:53.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.328]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.328]                   base::options(opts)
[08:27:53.328]                 }
[08:27:53.328]                 {
[08:27:53.328]                   {
[08:27:53.328]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.328]                     NULL
[08:27:53.328]                   }
[08:27:53.328]                   options(future.plan = NULL)
[08:27:53.328]                   if (is.na(NA_character_)) 
[08:27:53.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.328]                     .init = FALSE)
[08:27:53.328]                 }
[08:27:53.328]             }
[08:27:53.328]         }
[08:27:53.328]     })
[08:27:53.328]     if (TRUE) {
[08:27:53.328]         base::sink(type = "output", split = FALSE)
[08:27:53.328]         if (TRUE) {
[08:27:53.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.328]         }
[08:27:53.328]         else {
[08:27:53.328]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.328]         }
[08:27:53.328]         base::close(...future.stdout)
[08:27:53.328]         ...future.stdout <- NULL
[08:27:53.328]     }
[08:27:53.328]     ...future.result$conditions <- ...future.conditions
[08:27:53.328]     ...future.result$finished <- base::Sys.time()
[08:27:53.328]     ...future.result
[08:27:53.328] }
[08:27:53.330] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:53.341] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.341] - Validating connection of MultisessionFuture
[08:27:53.342] - received message: FutureResult
[08:27:53.342] - Received FutureResult
[08:27:53.342] - Erased future from FutureRegistry
[08:27:53.342] result() for ClusterFuture ...
[08:27:53.342] - result already collected: FutureResult
[08:27:53.342] result() for ClusterFuture ... done
[08:27:53.342] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.342] result() for ClusterFuture ...
[08:27:53.342] - result already collected: FutureResult
[08:27:53.343] result() for ClusterFuture ... done
[08:27:53.343] result() for ClusterFuture ...
[08:27:53.343] - result already collected: FutureResult
[08:27:53.343] result() for ClusterFuture ... done
[08:27:53.344] MultisessionFuture started
[08:27:53.344] - Launch lazy future ... done
[08:27:53.344] run() for ‘MultisessionFuture’ ... done
<environment: 0x55d86096b0a8> 
<environment: 0x55d86248b970> 
[08:27:53.347] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.348] - Validating connection of MultisessionFuture
[08:27:53.348] - received message: FutureResult
[08:27:53.348] - Received FutureResult
[08:27:53.348] - Erased future from FutureRegistry
[08:27:53.348] result() for ClusterFuture ...
[08:27:53.348] - result already collected: FutureResult
[08:27:53.349] result() for ClusterFuture ... done
[08:27:53.349] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:53.361] resolve() on environment ...
[08:27:53.361]  recursive: 0
[08:27:53.361]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:53.362] signalConditionsASAP(numeric, pos=1) ...
[08:27:53.362] - nx: 4
[08:27:53.362] - relay: TRUE
[08:27:53.362] - stdout: TRUE
[08:27:53.362] - signal: TRUE
[08:27:53.362] - resignal: FALSE
[08:27:53.362] - force: TRUE
[08:27:53.362] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.362] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.362]  - until=2
[08:27:53.363]  - relaying element #2
[08:27:53.363] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.363] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.363] signalConditionsASAP(NULL, pos=1) ... done
[08:27:53.363]  length: 3 (resolved future 1)
[08:27:53.363] Future #2
[08:27:53.363] result() for ClusterFuture ...
[08:27:53.363] - result already collected: FutureResult
[08:27:53.363] result() for ClusterFuture ... done
[08:27:53.364] result() for ClusterFuture ...
[08:27:53.364] - result already collected: FutureResult
[08:27:53.364] result() for ClusterFuture ... done
[08:27:53.364] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:53.364] - nx: 4
[08:27:53.364] - relay: TRUE
[08:27:53.364] - stdout: TRUE
[08:27:53.364] - signal: TRUE
[08:27:53.364] - resignal: FALSE
[08:27:53.364] - force: TRUE
[08:27:53.364] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.365] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.365]  - until=2
[08:27:53.365]  - relaying element #2
[08:27:53.365] result() for ClusterFuture ...
[08:27:53.365] - result already collected: FutureResult
[08:27:53.365] result() for ClusterFuture ... done
[08:27:53.365] result() for ClusterFuture ...
[08:27:53.365] - result already collected: FutureResult
[08:27:53.365] result() for ClusterFuture ... done
[08:27:53.365] result() for ClusterFuture ...
[08:27:53.366] - result already collected: FutureResult
[08:27:53.366] result() for ClusterFuture ... done
[08:27:53.366] result() for ClusterFuture ...
[08:27:53.366] - result already collected: FutureResult
[08:27:53.366] result() for ClusterFuture ... done
[08:27:53.366] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.366] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.366] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:53.366]  length: 2 (resolved future 2)
[08:27:53.366] Future #3
[08:27:53.367] result() for ClusterFuture ...
[08:27:53.367] - result already collected: FutureResult
[08:27:53.367] result() for ClusterFuture ... done
[08:27:53.367] result() for ClusterFuture ...
[08:27:53.367] - result already collected: FutureResult
[08:27:53.367] result() for ClusterFuture ... done
[08:27:53.367] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:53.367] - nx: 4
[08:27:53.367] - relay: TRUE
[08:27:53.367] - stdout: TRUE
[08:27:53.367] - signal: TRUE
[08:27:53.368] - resignal: FALSE
[08:27:53.368] - force: TRUE
[08:27:53.368] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.368] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.368]  - until=3
[08:27:53.368]  - relaying element #3
[08:27:53.368] result() for ClusterFuture ...
[08:27:53.368] - result already collected: FutureResult
[08:27:53.368] result() for ClusterFuture ... done
[08:27:53.368] result() for ClusterFuture ...
[08:27:53.368] - result already collected: FutureResult
[08:27:53.369] result() for ClusterFuture ... done
[08:27:53.369] result() for ClusterFuture ...
[08:27:53.369] - result already collected: FutureResult
[08:27:53.369] result() for ClusterFuture ... done
[08:27:53.369] result() for ClusterFuture ...
[08:27:53.369] - result already collected: FutureResult
[08:27:53.369] result() for ClusterFuture ... done
[08:27:53.369] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.369] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.369] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:53.370]  length: 1 (resolved future 3)
[08:27:53.391] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.391] - Validating connection of MultisessionFuture
[08:27:53.391] - received message: FutureResult
[08:27:53.392] - Received FutureResult
[08:27:53.392] - Erased future from FutureRegistry
[08:27:53.392] result() for ClusterFuture ...
[08:27:53.392] - result already collected: FutureResult
[08:27:53.392] result() for ClusterFuture ... done
[08:27:53.392] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.392] Future #4
[08:27:53.392] result() for ClusterFuture ...
[08:27:53.392] - result already collected: FutureResult
[08:27:53.392] result() for ClusterFuture ... done
[08:27:53.393] result() for ClusterFuture ...
[08:27:53.393] - result already collected: FutureResult
[08:27:53.393] result() for ClusterFuture ... done
[08:27:53.393] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:53.393] - nx: 4
[08:27:53.393] - relay: TRUE
[08:27:53.393] - stdout: TRUE
[08:27:53.393] - signal: TRUE
[08:27:53.393] - resignal: FALSE
[08:27:53.393] - force: TRUE
[08:27:53.393] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.394] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.394]  - until=4
[08:27:53.394]  - relaying element #4
[08:27:53.394] result() for ClusterFuture ...
[08:27:53.394] - result already collected: FutureResult
[08:27:53.394] result() for ClusterFuture ... done
[08:27:53.394] result() for ClusterFuture ...
[08:27:53.394] - result already collected: FutureResult
[08:27:53.394] result() for ClusterFuture ... done
[08:27:53.394] result() for ClusterFuture ...
[08:27:53.394] - result already collected: FutureResult
[08:27:53.395] result() for ClusterFuture ... done
[08:27:53.395] result() for ClusterFuture ...
[08:27:53.395] - result already collected: FutureResult
[08:27:53.395] result() for ClusterFuture ... done
[08:27:53.395] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.395] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.395] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:53.395]  length: 0 (resolved future 4)
[08:27:53.395] Relaying remaining futures
[08:27:53.395] signalConditionsASAP(NULL, pos=0) ...
[08:27:53.395] - nx: 4
[08:27:53.395] - relay: TRUE
[08:27:53.396] - stdout: TRUE
[08:27:53.396] - signal: TRUE
[08:27:53.396] - resignal: FALSE
[08:27:53.396] - force: TRUE
[08:27:53.396] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.396] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:53.396] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.396] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.396] signalConditionsASAP(NULL, pos=0) ... done
[08:27:53.396] resolve() on environment ... DONE
[08:27:53.396] result() for ClusterFuture ...
[08:27:53.397] - result already collected: FutureResult
[08:27:53.397] result() for ClusterFuture ... done
[08:27:53.397] result() for ClusterFuture ...
[08:27:53.397] - result already collected: FutureResult
[08:27:53.397] result() for ClusterFuture ... done
[08:27:53.397] result() for ClusterFuture ...
[08:27:53.397] - result already collected: FutureResult
[08:27:53.397] result() for ClusterFuture ... done
[08:27:53.397] result() for ClusterFuture ...
[08:27:53.397] - result already collected: FutureResult
[08:27:53.397] result() for ClusterFuture ... done
[08:27:53.397] result() for ClusterFuture ...
[08:27:53.398] - result already collected: FutureResult
[08:27:53.398] result() for ClusterFuture ... done
[08:27:53.398] result() for ClusterFuture ...
[08:27:53.398] - result already collected: FutureResult
[08:27:53.398] result() for ClusterFuture ... done
<environment: 0x55d8625d48d8> 
Dimensions: c(1, 6)
[08:27:53.398] getGlobalsAndPackages() ...
[08:27:53.398] Searching for globals...
[08:27:53.399] 
[08:27:53.399] Searching for globals ... DONE
[08:27:53.399] - globals: [0] <none>
[08:27:53.399] getGlobalsAndPackages() ... DONE
[08:27:53.399] run() for ‘Future’ ...
[08:27:53.399] - state: ‘created’
[08:27:53.400] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.414] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.414] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.414]   - Field: ‘node’
[08:27:53.414]   - Field: ‘label’
[08:27:53.415]   - Field: ‘local’
[08:27:53.415]   - Field: ‘owner’
[08:27:53.415]   - Field: ‘envir’
[08:27:53.415]   - Field: ‘workers’
[08:27:53.415]   - Field: ‘packages’
[08:27:53.415]   - Field: ‘gc’
[08:27:53.415]   - Field: ‘conditions’
[08:27:53.415]   - Field: ‘persistent’
[08:27:53.415]   - Field: ‘expr’
[08:27:53.415]   - Field: ‘uuid’
[08:27:53.415]   - Field: ‘seed’
[08:27:53.416]   - Field: ‘version’
[08:27:53.416]   - Field: ‘result’
[08:27:53.416]   - Field: ‘asynchronous’
[08:27:53.416]   - Field: ‘calls’
[08:27:53.416]   - Field: ‘globals’
[08:27:53.416]   - Field: ‘stdout’
[08:27:53.416]   - Field: ‘earlySignal’
[08:27:53.416]   - Field: ‘lazy’
[08:27:53.416]   - Field: ‘state’
[08:27:53.416] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.416] - Launch lazy future ...
[08:27:53.417] Packages needed by the future expression (n = 0): <none>
[08:27:53.417] Packages needed by future strategies (n = 0): <none>
[08:27:53.417] {
[08:27:53.417]     {
[08:27:53.417]         {
[08:27:53.417]             ...future.startTime <- base::Sys.time()
[08:27:53.417]             {
[08:27:53.417]                 {
[08:27:53.417]                   {
[08:27:53.417]                     {
[08:27:53.417]                       base::local({
[08:27:53.417]                         has_future <- base::requireNamespace("future", 
[08:27:53.417]                           quietly = TRUE)
[08:27:53.417]                         if (has_future) {
[08:27:53.417]                           ns <- base::getNamespace("future")
[08:27:53.417]                           version <- ns[[".package"]][["version"]]
[08:27:53.417]                           if (is.null(version)) 
[08:27:53.417]                             version <- utils::packageVersion("future")
[08:27:53.417]                         }
[08:27:53.417]                         else {
[08:27:53.417]                           version <- NULL
[08:27:53.417]                         }
[08:27:53.417]                         if (!has_future || version < "1.8.0") {
[08:27:53.417]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.417]                             "", base::R.version$version.string), 
[08:27:53.417]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.417]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.417]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.417]                               "release", "version")], collapse = " "), 
[08:27:53.417]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.417]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.417]                             info)
[08:27:53.417]                           info <- base::paste(info, collapse = "; ")
[08:27:53.417]                           if (!has_future) {
[08:27:53.417]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.417]                               info)
[08:27:53.417]                           }
[08:27:53.417]                           else {
[08:27:53.417]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.417]                               info, version)
[08:27:53.417]                           }
[08:27:53.417]                           base::stop(msg)
[08:27:53.417]                         }
[08:27:53.417]                       })
[08:27:53.417]                     }
[08:27:53.417]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.417]                     base::options(mc.cores = 1L)
[08:27:53.417]                   }
[08:27:53.417]                   ...future.strategy.old <- future::plan("list")
[08:27:53.417]                   options(future.plan = NULL)
[08:27:53.417]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.417]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.417]                 }
[08:27:53.417]                 ...future.workdir <- getwd()
[08:27:53.417]             }
[08:27:53.417]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.417]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.417]         }
[08:27:53.417]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.417]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.417]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.417]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.417]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.417]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.417]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.417]             base::names(...future.oldOptions))
[08:27:53.417]     }
[08:27:53.417]     if (FALSE) {
[08:27:53.417]     }
[08:27:53.417]     else {
[08:27:53.417]         if (TRUE) {
[08:27:53.417]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.417]                 open = "w")
[08:27:53.417]         }
[08:27:53.417]         else {
[08:27:53.417]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.417]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.417]         }
[08:27:53.417]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.417]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.417]             base::sink(type = "output", split = FALSE)
[08:27:53.417]             base::close(...future.stdout)
[08:27:53.417]         }, add = TRUE)
[08:27:53.417]     }
[08:27:53.417]     ...future.frame <- base::sys.nframe()
[08:27:53.417]     ...future.conditions <- base::list()
[08:27:53.417]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.417]     if (FALSE) {
[08:27:53.417]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.417]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.417]     }
[08:27:53.417]     ...future.result <- base::tryCatch({
[08:27:53.417]         base::withCallingHandlers({
[08:27:53.417]             ...future.value <- base::withVisible(base::local({
[08:27:53.417]                 ...future.makeSendCondition <- base::local({
[08:27:53.417]                   sendCondition <- NULL
[08:27:53.417]                   function(frame = 1L) {
[08:27:53.417]                     if (is.function(sendCondition)) 
[08:27:53.417]                       return(sendCondition)
[08:27:53.417]                     ns <- getNamespace("parallel")
[08:27:53.417]                     if (exists("sendData", mode = "function", 
[08:27:53.417]                       envir = ns)) {
[08:27:53.417]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.417]                         envir = ns)
[08:27:53.417]                       envir <- sys.frame(frame)
[08:27:53.417]                       master <- NULL
[08:27:53.417]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.417]                         !identical(envir, emptyenv())) {
[08:27:53.417]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.417]                           inherits = FALSE)) {
[08:27:53.417]                           master <- get("master", mode = "list", 
[08:27:53.417]                             envir = envir, inherits = FALSE)
[08:27:53.417]                           if (inherits(master, c("SOCKnode", 
[08:27:53.417]                             "SOCK0node"))) {
[08:27:53.417]                             sendCondition <<- function(cond) {
[08:27:53.417]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.417]                                 success = TRUE)
[08:27:53.417]                               parallel_sendData(master, data)
[08:27:53.417]                             }
[08:27:53.417]                             return(sendCondition)
[08:27:53.417]                           }
[08:27:53.417]                         }
[08:27:53.417]                         frame <- frame + 1L
[08:27:53.417]                         envir <- sys.frame(frame)
[08:27:53.417]                       }
[08:27:53.417]                     }
[08:27:53.417]                     sendCondition <<- function(cond) NULL
[08:27:53.417]                   }
[08:27:53.417]                 })
[08:27:53.417]                 withCallingHandlers({
[08:27:53.417]                   2
[08:27:53.417]                 }, immediateCondition = function(cond) {
[08:27:53.417]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.417]                   sendCondition(cond)
[08:27:53.417]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.417]                   {
[08:27:53.417]                     inherits <- base::inherits
[08:27:53.417]                     invokeRestart <- base::invokeRestart
[08:27:53.417]                     is.null <- base::is.null
[08:27:53.417]                     muffled <- FALSE
[08:27:53.417]                     if (inherits(cond, "message")) {
[08:27:53.417]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.417]                       if (muffled) 
[08:27:53.417]                         invokeRestart("muffleMessage")
[08:27:53.417]                     }
[08:27:53.417]                     else if (inherits(cond, "warning")) {
[08:27:53.417]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.417]                       if (muffled) 
[08:27:53.417]                         invokeRestart("muffleWarning")
[08:27:53.417]                     }
[08:27:53.417]                     else if (inherits(cond, "condition")) {
[08:27:53.417]                       if (!is.null(pattern)) {
[08:27:53.417]                         computeRestarts <- base::computeRestarts
[08:27:53.417]                         grepl <- base::grepl
[08:27:53.417]                         restarts <- computeRestarts(cond)
[08:27:53.417]                         for (restart in restarts) {
[08:27:53.417]                           name <- restart$name
[08:27:53.417]                           if (is.null(name)) 
[08:27:53.417]                             next
[08:27:53.417]                           if (!grepl(pattern, name)) 
[08:27:53.417]                             next
[08:27:53.417]                           invokeRestart(restart)
[08:27:53.417]                           muffled <- TRUE
[08:27:53.417]                           break
[08:27:53.417]                         }
[08:27:53.417]                       }
[08:27:53.417]                     }
[08:27:53.417]                     invisible(muffled)
[08:27:53.417]                   }
[08:27:53.417]                   muffleCondition(cond)
[08:27:53.417]                 })
[08:27:53.417]             }))
[08:27:53.417]             future::FutureResult(value = ...future.value$value, 
[08:27:53.417]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.417]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.417]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.417]                     ...future.globalenv.names))
[08:27:53.417]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.417]         }, condition = base::local({
[08:27:53.417]             c <- base::c
[08:27:53.417]             inherits <- base::inherits
[08:27:53.417]             invokeRestart <- base::invokeRestart
[08:27:53.417]             length <- base::length
[08:27:53.417]             list <- base::list
[08:27:53.417]             seq.int <- base::seq.int
[08:27:53.417]             signalCondition <- base::signalCondition
[08:27:53.417]             sys.calls <- base::sys.calls
[08:27:53.417]             `[[` <- base::`[[`
[08:27:53.417]             `+` <- base::`+`
[08:27:53.417]             `<<-` <- base::`<<-`
[08:27:53.417]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.417]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.417]                   3L)]
[08:27:53.417]             }
[08:27:53.417]             function(cond) {
[08:27:53.417]                 is_error <- inherits(cond, "error")
[08:27:53.417]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.417]                   NULL)
[08:27:53.417]                 if (is_error) {
[08:27:53.417]                   sessionInformation <- function() {
[08:27:53.417]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.417]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.417]                       search = base::search(), system = base::Sys.info())
[08:27:53.417]                   }
[08:27:53.417]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.417]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.417]                     cond$call), session = sessionInformation(), 
[08:27:53.417]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.417]                   signalCondition(cond)
[08:27:53.417]                 }
[08:27:53.417]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.417]                 "immediateCondition"))) {
[08:27:53.417]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.417]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.417]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.417]                   if (TRUE && !signal) {
[08:27:53.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.417]                     {
[08:27:53.417]                       inherits <- base::inherits
[08:27:53.417]                       invokeRestart <- base::invokeRestart
[08:27:53.417]                       is.null <- base::is.null
[08:27:53.417]                       muffled <- FALSE
[08:27:53.417]                       if (inherits(cond, "message")) {
[08:27:53.417]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.417]                         if (muffled) 
[08:27:53.417]                           invokeRestart("muffleMessage")
[08:27:53.417]                       }
[08:27:53.417]                       else if (inherits(cond, "warning")) {
[08:27:53.417]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.417]                         if (muffled) 
[08:27:53.417]                           invokeRestart("muffleWarning")
[08:27:53.417]                       }
[08:27:53.417]                       else if (inherits(cond, "condition")) {
[08:27:53.417]                         if (!is.null(pattern)) {
[08:27:53.417]                           computeRestarts <- base::computeRestarts
[08:27:53.417]                           grepl <- base::grepl
[08:27:53.417]                           restarts <- computeRestarts(cond)
[08:27:53.417]                           for (restart in restarts) {
[08:27:53.417]                             name <- restart$name
[08:27:53.417]                             if (is.null(name)) 
[08:27:53.417]                               next
[08:27:53.417]                             if (!grepl(pattern, name)) 
[08:27:53.417]                               next
[08:27:53.417]                             invokeRestart(restart)
[08:27:53.417]                             muffled <- TRUE
[08:27:53.417]                             break
[08:27:53.417]                           }
[08:27:53.417]                         }
[08:27:53.417]                       }
[08:27:53.417]                       invisible(muffled)
[08:27:53.417]                     }
[08:27:53.417]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.417]                   }
[08:27:53.417]                 }
[08:27:53.417]                 else {
[08:27:53.417]                   if (TRUE) {
[08:27:53.417]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.417]                     {
[08:27:53.417]                       inherits <- base::inherits
[08:27:53.417]                       invokeRestart <- base::invokeRestart
[08:27:53.417]                       is.null <- base::is.null
[08:27:53.417]                       muffled <- FALSE
[08:27:53.417]                       if (inherits(cond, "message")) {
[08:27:53.417]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.417]                         if (muffled) 
[08:27:53.417]                           invokeRestart("muffleMessage")
[08:27:53.417]                       }
[08:27:53.417]                       else if (inherits(cond, "warning")) {
[08:27:53.417]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.417]                         if (muffled) 
[08:27:53.417]                           invokeRestart("muffleWarning")
[08:27:53.417]                       }
[08:27:53.417]                       else if (inherits(cond, "condition")) {
[08:27:53.417]                         if (!is.null(pattern)) {
[08:27:53.417]                           computeRestarts <- base::computeRestarts
[08:27:53.417]                           grepl <- base::grepl
[08:27:53.417]                           restarts <- computeRestarts(cond)
[08:27:53.417]                           for (restart in restarts) {
[08:27:53.417]                             name <- restart$name
[08:27:53.417]                             if (is.null(name)) 
[08:27:53.417]                               next
[08:27:53.417]                             if (!grepl(pattern, name)) 
[08:27:53.417]                               next
[08:27:53.417]                             invokeRestart(restart)
[08:27:53.417]                             muffled <- TRUE
[08:27:53.417]                             break
[08:27:53.417]                           }
[08:27:53.417]                         }
[08:27:53.417]                       }
[08:27:53.417]                       invisible(muffled)
[08:27:53.417]                     }
[08:27:53.417]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.417]                   }
[08:27:53.417]                 }
[08:27:53.417]             }
[08:27:53.417]         }))
[08:27:53.417]     }, error = function(ex) {
[08:27:53.417]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.417]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.417]                 ...future.rng), started = ...future.startTime, 
[08:27:53.417]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.417]             version = "1.8"), class = "FutureResult")
[08:27:53.417]     }, finally = {
[08:27:53.417]         if (!identical(...future.workdir, getwd())) 
[08:27:53.417]             setwd(...future.workdir)
[08:27:53.417]         {
[08:27:53.417]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.417]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.417]             }
[08:27:53.417]             base::options(...future.oldOptions)
[08:27:53.417]             if (.Platform$OS.type == "windows") {
[08:27:53.417]                 old_names <- names(...future.oldEnvVars)
[08:27:53.417]                 envs <- base::Sys.getenv()
[08:27:53.417]                 names <- names(envs)
[08:27:53.417]                 common <- intersect(names, old_names)
[08:27:53.417]                 added <- setdiff(names, old_names)
[08:27:53.417]                 removed <- setdiff(old_names, names)
[08:27:53.417]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.417]                   envs[common]]
[08:27:53.417]                 NAMES <- toupper(changed)
[08:27:53.417]                 args <- list()
[08:27:53.417]                 for (kk in seq_along(NAMES)) {
[08:27:53.417]                   name <- changed[[kk]]
[08:27:53.417]                   NAME <- NAMES[[kk]]
[08:27:53.417]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.417]                     next
[08:27:53.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.417]                 }
[08:27:53.417]                 NAMES <- toupper(added)
[08:27:53.417]                 for (kk in seq_along(NAMES)) {
[08:27:53.417]                   name <- added[[kk]]
[08:27:53.417]                   NAME <- NAMES[[kk]]
[08:27:53.417]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.417]                     next
[08:27:53.417]                   args[[name]] <- ""
[08:27:53.417]                 }
[08:27:53.417]                 NAMES <- toupper(removed)
[08:27:53.417]                 for (kk in seq_along(NAMES)) {
[08:27:53.417]                   name <- removed[[kk]]
[08:27:53.417]                   NAME <- NAMES[[kk]]
[08:27:53.417]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.417]                     next
[08:27:53.417]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.417]                 }
[08:27:53.417]                 if (length(args) > 0) 
[08:27:53.417]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.417]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.417]             }
[08:27:53.417]             else {
[08:27:53.417]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.417]             }
[08:27:53.417]             {
[08:27:53.417]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.417]                   0L) {
[08:27:53.417]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.417]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.417]                   base::options(opts)
[08:27:53.417]                 }
[08:27:53.417]                 {
[08:27:53.417]                   {
[08:27:53.417]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.417]                     NULL
[08:27:53.417]                   }
[08:27:53.417]                   options(future.plan = NULL)
[08:27:53.417]                   if (is.na(NA_character_)) 
[08:27:53.417]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.417]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.417]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.417]                     .init = FALSE)
[08:27:53.417]                 }
[08:27:53.417]             }
[08:27:53.417]         }
[08:27:53.417]     })
[08:27:53.417]     if (TRUE) {
[08:27:53.417]         base::sink(type = "output", split = FALSE)
[08:27:53.417]         if (TRUE) {
[08:27:53.417]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.417]         }
[08:27:53.417]         else {
[08:27:53.417]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.417]         }
[08:27:53.417]         base::close(...future.stdout)
[08:27:53.417]         ...future.stdout <- NULL
[08:27:53.417]     }
[08:27:53.417]     ...future.result$conditions <- ...future.conditions
[08:27:53.417]     ...future.result$finished <- base::Sys.time()
[08:27:53.417]     ...future.result
[08:27:53.417] }
[08:27:53.421] MultisessionFuture started
[08:27:53.421] - Launch lazy future ... done
[08:27:53.421] run() for ‘MultisessionFuture’ ... done
[08:27:53.421] getGlobalsAndPackages() ...
[08:27:53.421] Searching for globals...
[08:27:53.421] 
[08:27:53.422] Searching for globals ... DONE
[08:27:53.422] - globals: [0] <none>
[08:27:53.428] getGlobalsAndPackages() ... DONE
[08:27:53.428] run() for ‘Future’ ...
[08:27:53.428] - state: ‘created’
[08:27:53.428] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.442] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.442] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.442]   - Field: ‘node’
[08:27:53.442]   - Field: ‘label’
[08:27:53.443]   - Field: ‘local’
[08:27:53.443]   - Field: ‘owner’
[08:27:53.443]   - Field: ‘envir’
[08:27:53.443]   - Field: ‘workers’
[08:27:53.443]   - Field: ‘packages’
[08:27:53.443]   - Field: ‘gc’
[08:27:53.443]   - Field: ‘conditions’
[08:27:53.443]   - Field: ‘persistent’
[08:27:53.443]   - Field: ‘expr’
[08:27:53.443]   - Field: ‘uuid’
[08:27:53.443]   - Field: ‘seed’
[08:27:53.443]   - Field: ‘version’
[08:27:53.444]   - Field: ‘result’
[08:27:53.444]   - Field: ‘asynchronous’
[08:27:53.444]   - Field: ‘calls’
[08:27:53.444]   - Field: ‘globals’
[08:27:53.444]   - Field: ‘stdout’
[08:27:53.444]   - Field: ‘earlySignal’
[08:27:53.444]   - Field: ‘lazy’
[08:27:53.444]   - Field: ‘state’
[08:27:53.444] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.444] - Launch lazy future ...
[08:27:53.445] Packages needed by the future expression (n = 0): <none>
[08:27:53.445] Packages needed by future strategies (n = 0): <none>
[08:27:53.445] {
[08:27:53.445]     {
[08:27:53.445]         {
[08:27:53.445]             ...future.startTime <- base::Sys.time()
[08:27:53.445]             {
[08:27:53.445]                 {
[08:27:53.445]                   {
[08:27:53.445]                     {
[08:27:53.445]                       base::local({
[08:27:53.445]                         has_future <- base::requireNamespace("future", 
[08:27:53.445]                           quietly = TRUE)
[08:27:53.445]                         if (has_future) {
[08:27:53.445]                           ns <- base::getNamespace("future")
[08:27:53.445]                           version <- ns[[".package"]][["version"]]
[08:27:53.445]                           if (is.null(version)) 
[08:27:53.445]                             version <- utils::packageVersion("future")
[08:27:53.445]                         }
[08:27:53.445]                         else {
[08:27:53.445]                           version <- NULL
[08:27:53.445]                         }
[08:27:53.445]                         if (!has_future || version < "1.8.0") {
[08:27:53.445]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.445]                             "", base::R.version$version.string), 
[08:27:53.445]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.445]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.445]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.445]                               "release", "version")], collapse = " "), 
[08:27:53.445]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.445]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.445]                             info)
[08:27:53.445]                           info <- base::paste(info, collapse = "; ")
[08:27:53.445]                           if (!has_future) {
[08:27:53.445]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.445]                               info)
[08:27:53.445]                           }
[08:27:53.445]                           else {
[08:27:53.445]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.445]                               info, version)
[08:27:53.445]                           }
[08:27:53.445]                           base::stop(msg)
[08:27:53.445]                         }
[08:27:53.445]                       })
[08:27:53.445]                     }
[08:27:53.445]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.445]                     base::options(mc.cores = 1L)
[08:27:53.445]                   }
[08:27:53.445]                   ...future.strategy.old <- future::plan("list")
[08:27:53.445]                   options(future.plan = NULL)
[08:27:53.445]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.445]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.445]                 }
[08:27:53.445]                 ...future.workdir <- getwd()
[08:27:53.445]             }
[08:27:53.445]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.445]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.445]         }
[08:27:53.445]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.445]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.445]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.445]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.445]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.445]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.445]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.445]             base::names(...future.oldOptions))
[08:27:53.445]     }
[08:27:53.445]     if (FALSE) {
[08:27:53.445]     }
[08:27:53.445]     else {
[08:27:53.445]         if (TRUE) {
[08:27:53.445]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.445]                 open = "w")
[08:27:53.445]         }
[08:27:53.445]         else {
[08:27:53.445]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.445]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.445]         }
[08:27:53.445]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.445]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.445]             base::sink(type = "output", split = FALSE)
[08:27:53.445]             base::close(...future.stdout)
[08:27:53.445]         }, add = TRUE)
[08:27:53.445]     }
[08:27:53.445]     ...future.frame <- base::sys.nframe()
[08:27:53.445]     ...future.conditions <- base::list()
[08:27:53.445]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.445]     if (FALSE) {
[08:27:53.445]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.445]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.445]     }
[08:27:53.445]     ...future.result <- base::tryCatch({
[08:27:53.445]         base::withCallingHandlers({
[08:27:53.445]             ...future.value <- base::withVisible(base::local({
[08:27:53.445]                 ...future.makeSendCondition <- base::local({
[08:27:53.445]                   sendCondition <- NULL
[08:27:53.445]                   function(frame = 1L) {
[08:27:53.445]                     if (is.function(sendCondition)) 
[08:27:53.445]                       return(sendCondition)
[08:27:53.445]                     ns <- getNamespace("parallel")
[08:27:53.445]                     if (exists("sendData", mode = "function", 
[08:27:53.445]                       envir = ns)) {
[08:27:53.445]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.445]                         envir = ns)
[08:27:53.445]                       envir <- sys.frame(frame)
[08:27:53.445]                       master <- NULL
[08:27:53.445]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.445]                         !identical(envir, emptyenv())) {
[08:27:53.445]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.445]                           inherits = FALSE)) {
[08:27:53.445]                           master <- get("master", mode = "list", 
[08:27:53.445]                             envir = envir, inherits = FALSE)
[08:27:53.445]                           if (inherits(master, c("SOCKnode", 
[08:27:53.445]                             "SOCK0node"))) {
[08:27:53.445]                             sendCondition <<- function(cond) {
[08:27:53.445]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.445]                                 success = TRUE)
[08:27:53.445]                               parallel_sendData(master, data)
[08:27:53.445]                             }
[08:27:53.445]                             return(sendCondition)
[08:27:53.445]                           }
[08:27:53.445]                         }
[08:27:53.445]                         frame <- frame + 1L
[08:27:53.445]                         envir <- sys.frame(frame)
[08:27:53.445]                       }
[08:27:53.445]                     }
[08:27:53.445]                     sendCondition <<- function(cond) NULL
[08:27:53.445]                   }
[08:27:53.445]                 })
[08:27:53.445]                 withCallingHandlers({
[08:27:53.445]                   NULL
[08:27:53.445]                 }, immediateCondition = function(cond) {
[08:27:53.445]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.445]                   sendCondition(cond)
[08:27:53.445]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.445]                   {
[08:27:53.445]                     inherits <- base::inherits
[08:27:53.445]                     invokeRestart <- base::invokeRestart
[08:27:53.445]                     is.null <- base::is.null
[08:27:53.445]                     muffled <- FALSE
[08:27:53.445]                     if (inherits(cond, "message")) {
[08:27:53.445]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.445]                       if (muffled) 
[08:27:53.445]                         invokeRestart("muffleMessage")
[08:27:53.445]                     }
[08:27:53.445]                     else if (inherits(cond, "warning")) {
[08:27:53.445]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.445]                       if (muffled) 
[08:27:53.445]                         invokeRestart("muffleWarning")
[08:27:53.445]                     }
[08:27:53.445]                     else if (inherits(cond, "condition")) {
[08:27:53.445]                       if (!is.null(pattern)) {
[08:27:53.445]                         computeRestarts <- base::computeRestarts
[08:27:53.445]                         grepl <- base::grepl
[08:27:53.445]                         restarts <- computeRestarts(cond)
[08:27:53.445]                         for (restart in restarts) {
[08:27:53.445]                           name <- restart$name
[08:27:53.445]                           if (is.null(name)) 
[08:27:53.445]                             next
[08:27:53.445]                           if (!grepl(pattern, name)) 
[08:27:53.445]                             next
[08:27:53.445]                           invokeRestart(restart)
[08:27:53.445]                           muffled <- TRUE
[08:27:53.445]                           break
[08:27:53.445]                         }
[08:27:53.445]                       }
[08:27:53.445]                     }
[08:27:53.445]                     invisible(muffled)
[08:27:53.445]                   }
[08:27:53.445]                   muffleCondition(cond)
[08:27:53.445]                 })
[08:27:53.445]             }))
[08:27:53.445]             future::FutureResult(value = ...future.value$value, 
[08:27:53.445]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.445]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.445]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.445]                     ...future.globalenv.names))
[08:27:53.445]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.445]         }, condition = base::local({
[08:27:53.445]             c <- base::c
[08:27:53.445]             inherits <- base::inherits
[08:27:53.445]             invokeRestart <- base::invokeRestart
[08:27:53.445]             length <- base::length
[08:27:53.445]             list <- base::list
[08:27:53.445]             seq.int <- base::seq.int
[08:27:53.445]             signalCondition <- base::signalCondition
[08:27:53.445]             sys.calls <- base::sys.calls
[08:27:53.445]             `[[` <- base::`[[`
[08:27:53.445]             `+` <- base::`+`
[08:27:53.445]             `<<-` <- base::`<<-`
[08:27:53.445]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.445]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.445]                   3L)]
[08:27:53.445]             }
[08:27:53.445]             function(cond) {
[08:27:53.445]                 is_error <- inherits(cond, "error")
[08:27:53.445]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.445]                   NULL)
[08:27:53.445]                 if (is_error) {
[08:27:53.445]                   sessionInformation <- function() {
[08:27:53.445]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.445]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.445]                       search = base::search(), system = base::Sys.info())
[08:27:53.445]                   }
[08:27:53.445]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.445]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.445]                     cond$call), session = sessionInformation(), 
[08:27:53.445]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.445]                   signalCondition(cond)
[08:27:53.445]                 }
[08:27:53.445]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.445]                 "immediateCondition"))) {
[08:27:53.445]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.445]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.445]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.445]                   if (TRUE && !signal) {
[08:27:53.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.445]                     {
[08:27:53.445]                       inherits <- base::inherits
[08:27:53.445]                       invokeRestart <- base::invokeRestart
[08:27:53.445]                       is.null <- base::is.null
[08:27:53.445]                       muffled <- FALSE
[08:27:53.445]                       if (inherits(cond, "message")) {
[08:27:53.445]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.445]                         if (muffled) 
[08:27:53.445]                           invokeRestart("muffleMessage")
[08:27:53.445]                       }
[08:27:53.445]                       else if (inherits(cond, "warning")) {
[08:27:53.445]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.445]                         if (muffled) 
[08:27:53.445]                           invokeRestart("muffleWarning")
[08:27:53.445]                       }
[08:27:53.445]                       else if (inherits(cond, "condition")) {
[08:27:53.445]                         if (!is.null(pattern)) {
[08:27:53.445]                           computeRestarts <- base::computeRestarts
[08:27:53.445]                           grepl <- base::grepl
[08:27:53.445]                           restarts <- computeRestarts(cond)
[08:27:53.445]                           for (restart in restarts) {
[08:27:53.445]                             name <- restart$name
[08:27:53.445]                             if (is.null(name)) 
[08:27:53.445]                               next
[08:27:53.445]                             if (!grepl(pattern, name)) 
[08:27:53.445]                               next
[08:27:53.445]                             invokeRestart(restart)
[08:27:53.445]                             muffled <- TRUE
[08:27:53.445]                             break
[08:27:53.445]                           }
[08:27:53.445]                         }
[08:27:53.445]                       }
[08:27:53.445]                       invisible(muffled)
[08:27:53.445]                     }
[08:27:53.445]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.445]                   }
[08:27:53.445]                 }
[08:27:53.445]                 else {
[08:27:53.445]                   if (TRUE) {
[08:27:53.445]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.445]                     {
[08:27:53.445]                       inherits <- base::inherits
[08:27:53.445]                       invokeRestart <- base::invokeRestart
[08:27:53.445]                       is.null <- base::is.null
[08:27:53.445]                       muffled <- FALSE
[08:27:53.445]                       if (inherits(cond, "message")) {
[08:27:53.445]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.445]                         if (muffled) 
[08:27:53.445]                           invokeRestart("muffleMessage")
[08:27:53.445]                       }
[08:27:53.445]                       else if (inherits(cond, "warning")) {
[08:27:53.445]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.445]                         if (muffled) 
[08:27:53.445]                           invokeRestart("muffleWarning")
[08:27:53.445]                       }
[08:27:53.445]                       else if (inherits(cond, "condition")) {
[08:27:53.445]                         if (!is.null(pattern)) {
[08:27:53.445]                           computeRestarts <- base::computeRestarts
[08:27:53.445]                           grepl <- base::grepl
[08:27:53.445]                           restarts <- computeRestarts(cond)
[08:27:53.445]                           for (restart in restarts) {
[08:27:53.445]                             name <- restart$name
[08:27:53.445]                             if (is.null(name)) 
[08:27:53.445]                               next
[08:27:53.445]                             if (!grepl(pattern, name)) 
[08:27:53.445]                               next
[08:27:53.445]                             invokeRestart(restart)
[08:27:53.445]                             muffled <- TRUE
[08:27:53.445]                             break
[08:27:53.445]                           }
[08:27:53.445]                         }
[08:27:53.445]                       }
[08:27:53.445]                       invisible(muffled)
[08:27:53.445]                     }
[08:27:53.445]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.445]                   }
[08:27:53.445]                 }
[08:27:53.445]             }
[08:27:53.445]         }))
[08:27:53.445]     }, error = function(ex) {
[08:27:53.445]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.445]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.445]                 ...future.rng), started = ...future.startTime, 
[08:27:53.445]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.445]             version = "1.8"), class = "FutureResult")
[08:27:53.445]     }, finally = {
[08:27:53.445]         if (!identical(...future.workdir, getwd())) 
[08:27:53.445]             setwd(...future.workdir)
[08:27:53.445]         {
[08:27:53.445]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.445]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.445]             }
[08:27:53.445]             base::options(...future.oldOptions)
[08:27:53.445]             if (.Platform$OS.type == "windows") {
[08:27:53.445]                 old_names <- names(...future.oldEnvVars)
[08:27:53.445]                 envs <- base::Sys.getenv()
[08:27:53.445]                 names <- names(envs)
[08:27:53.445]                 common <- intersect(names, old_names)
[08:27:53.445]                 added <- setdiff(names, old_names)
[08:27:53.445]                 removed <- setdiff(old_names, names)
[08:27:53.445]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.445]                   envs[common]]
[08:27:53.445]                 NAMES <- toupper(changed)
[08:27:53.445]                 args <- list()
[08:27:53.445]                 for (kk in seq_along(NAMES)) {
[08:27:53.445]                   name <- changed[[kk]]
[08:27:53.445]                   NAME <- NAMES[[kk]]
[08:27:53.445]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.445]                     next
[08:27:53.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.445]                 }
[08:27:53.445]                 NAMES <- toupper(added)
[08:27:53.445]                 for (kk in seq_along(NAMES)) {
[08:27:53.445]                   name <- added[[kk]]
[08:27:53.445]                   NAME <- NAMES[[kk]]
[08:27:53.445]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.445]                     next
[08:27:53.445]                   args[[name]] <- ""
[08:27:53.445]                 }
[08:27:53.445]                 NAMES <- toupper(removed)
[08:27:53.445]                 for (kk in seq_along(NAMES)) {
[08:27:53.445]                   name <- removed[[kk]]
[08:27:53.445]                   NAME <- NAMES[[kk]]
[08:27:53.445]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.445]                     next
[08:27:53.445]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.445]                 }
[08:27:53.445]                 if (length(args) > 0) 
[08:27:53.445]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.445]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.445]             }
[08:27:53.445]             else {
[08:27:53.445]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.445]             }
[08:27:53.445]             {
[08:27:53.445]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.445]                   0L) {
[08:27:53.445]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.445]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.445]                   base::options(opts)
[08:27:53.445]                 }
[08:27:53.445]                 {
[08:27:53.445]                   {
[08:27:53.445]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.445]                     NULL
[08:27:53.445]                   }
[08:27:53.445]                   options(future.plan = NULL)
[08:27:53.445]                   if (is.na(NA_character_)) 
[08:27:53.445]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.445]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.445]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.445]                     .init = FALSE)
[08:27:53.445]                 }
[08:27:53.445]             }
[08:27:53.445]         }
[08:27:53.445]     })
[08:27:53.445]     if (TRUE) {
[08:27:53.445]         base::sink(type = "output", split = FALSE)
[08:27:53.445]         if (TRUE) {
[08:27:53.445]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.445]         }
[08:27:53.445]         else {
[08:27:53.445]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.445]         }
[08:27:53.445]         base::close(...future.stdout)
[08:27:53.445]         ...future.stdout <- NULL
[08:27:53.445]     }
[08:27:53.445]     ...future.result$conditions <- ...future.conditions
[08:27:53.445]     ...future.result$finished <- base::Sys.time()
[08:27:53.445]     ...future.result
[08:27:53.445] }
[08:27:53.448] MultisessionFuture started
[08:27:53.448] - Launch lazy future ... done
[08:27:53.448] run() for ‘MultisessionFuture’ ... done
[08:27:53.449] getGlobalsAndPackages() ...
[08:27:53.449] Searching for globals...
[08:27:53.450] - globals found: [1] ‘{’
[08:27:53.450] Searching for globals ... DONE
[08:27:53.450] Resolving globals: FALSE
[08:27:53.450] 
[08:27:53.450] 
[08:27:53.450] getGlobalsAndPackages() ... DONE
[08:27:53.450] run() for ‘Future’ ...
[08:27:53.451] - state: ‘created’
[08:27:53.451] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.465] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.465] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.465]   - Field: ‘node’
[08:27:53.466]   - Field: ‘label’
[08:27:53.466]   - Field: ‘local’
[08:27:53.466]   - Field: ‘owner’
[08:27:53.466]   - Field: ‘envir’
[08:27:53.466]   - Field: ‘workers’
[08:27:53.466]   - Field: ‘packages’
[08:27:53.466]   - Field: ‘gc’
[08:27:53.466]   - Field: ‘conditions’
[08:27:53.466]   - Field: ‘persistent’
[08:27:53.466]   - Field: ‘expr’
[08:27:53.466]   - Field: ‘uuid’
[08:27:53.466]   - Field: ‘seed’
[08:27:53.467]   - Field: ‘version’
[08:27:53.467]   - Field: ‘result’
[08:27:53.467]   - Field: ‘asynchronous’
[08:27:53.467]   - Field: ‘calls’
[08:27:53.467]   - Field: ‘globals’
[08:27:53.467]   - Field: ‘stdout’
[08:27:53.467]   - Field: ‘earlySignal’
[08:27:53.467]   - Field: ‘lazy’
[08:27:53.467]   - Field: ‘state’
[08:27:53.467] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.467] - Launch lazy future ...
[08:27:53.468] Packages needed by the future expression (n = 0): <none>
[08:27:53.468] Packages needed by future strategies (n = 0): <none>
[08:27:53.468] {
[08:27:53.468]     {
[08:27:53.468]         {
[08:27:53.468]             ...future.startTime <- base::Sys.time()
[08:27:53.468]             {
[08:27:53.468]                 {
[08:27:53.468]                   {
[08:27:53.468]                     {
[08:27:53.468]                       base::local({
[08:27:53.468]                         has_future <- base::requireNamespace("future", 
[08:27:53.468]                           quietly = TRUE)
[08:27:53.468]                         if (has_future) {
[08:27:53.468]                           ns <- base::getNamespace("future")
[08:27:53.468]                           version <- ns[[".package"]][["version"]]
[08:27:53.468]                           if (is.null(version)) 
[08:27:53.468]                             version <- utils::packageVersion("future")
[08:27:53.468]                         }
[08:27:53.468]                         else {
[08:27:53.468]                           version <- NULL
[08:27:53.468]                         }
[08:27:53.468]                         if (!has_future || version < "1.8.0") {
[08:27:53.468]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.468]                             "", base::R.version$version.string), 
[08:27:53.468]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.468]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.468]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.468]                               "release", "version")], collapse = " "), 
[08:27:53.468]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.468]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.468]                             info)
[08:27:53.468]                           info <- base::paste(info, collapse = "; ")
[08:27:53.468]                           if (!has_future) {
[08:27:53.468]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.468]                               info)
[08:27:53.468]                           }
[08:27:53.468]                           else {
[08:27:53.468]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.468]                               info, version)
[08:27:53.468]                           }
[08:27:53.468]                           base::stop(msg)
[08:27:53.468]                         }
[08:27:53.468]                       })
[08:27:53.468]                     }
[08:27:53.468]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.468]                     base::options(mc.cores = 1L)
[08:27:53.468]                   }
[08:27:53.468]                   ...future.strategy.old <- future::plan("list")
[08:27:53.468]                   options(future.plan = NULL)
[08:27:53.468]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.468]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.468]                 }
[08:27:53.468]                 ...future.workdir <- getwd()
[08:27:53.468]             }
[08:27:53.468]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.468]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.468]         }
[08:27:53.468]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.468]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.468]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.468]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.468]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.468]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.468]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.468]             base::names(...future.oldOptions))
[08:27:53.468]     }
[08:27:53.468]     if (FALSE) {
[08:27:53.468]     }
[08:27:53.468]     else {
[08:27:53.468]         if (TRUE) {
[08:27:53.468]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.468]                 open = "w")
[08:27:53.468]         }
[08:27:53.468]         else {
[08:27:53.468]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.468]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.468]         }
[08:27:53.468]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.468]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.468]             base::sink(type = "output", split = FALSE)
[08:27:53.468]             base::close(...future.stdout)
[08:27:53.468]         }, add = TRUE)
[08:27:53.468]     }
[08:27:53.468]     ...future.frame <- base::sys.nframe()
[08:27:53.468]     ...future.conditions <- base::list()
[08:27:53.468]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.468]     if (FALSE) {
[08:27:53.468]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.468]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.468]     }
[08:27:53.468]     ...future.result <- base::tryCatch({
[08:27:53.468]         base::withCallingHandlers({
[08:27:53.468]             ...future.value <- base::withVisible(base::local({
[08:27:53.468]                 ...future.makeSendCondition <- base::local({
[08:27:53.468]                   sendCondition <- NULL
[08:27:53.468]                   function(frame = 1L) {
[08:27:53.468]                     if (is.function(sendCondition)) 
[08:27:53.468]                       return(sendCondition)
[08:27:53.468]                     ns <- getNamespace("parallel")
[08:27:53.468]                     if (exists("sendData", mode = "function", 
[08:27:53.468]                       envir = ns)) {
[08:27:53.468]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.468]                         envir = ns)
[08:27:53.468]                       envir <- sys.frame(frame)
[08:27:53.468]                       master <- NULL
[08:27:53.468]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.468]                         !identical(envir, emptyenv())) {
[08:27:53.468]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.468]                           inherits = FALSE)) {
[08:27:53.468]                           master <- get("master", mode = "list", 
[08:27:53.468]                             envir = envir, inherits = FALSE)
[08:27:53.468]                           if (inherits(master, c("SOCKnode", 
[08:27:53.468]                             "SOCK0node"))) {
[08:27:53.468]                             sendCondition <<- function(cond) {
[08:27:53.468]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.468]                                 success = TRUE)
[08:27:53.468]                               parallel_sendData(master, data)
[08:27:53.468]                             }
[08:27:53.468]                             return(sendCondition)
[08:27:53.468]                           }
[08:27:53.468]                         }
[08:27:53.468]                         frame <- frame + 1L
[08:27:53.468]                         envir <- sys.frame(frame)
[08:27:53.468]                       }
[08:27:53.468]                     }
[08:27:53.468]                     sendCondition <<- function(cond) NULL
[08:27:53.468]                   }
[08:27:53.468]                 })
[08:27:53.468]                 withCallingHandlers({
[08:27:53.468]                   {
[08:27:53.468]                     4
[08:27:53.468]                   }
[08:27:53.468]                 }, immediateCondition = function(cond) {
[08:27:53.468]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.468]                   sendCondition(cond)
[08:27:53.468]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.468]                   {
[08:27:53.468]                     inherits <- base::inherits
[08:27:53.468]                     invokeRestart <- base::invokeRestart
[08:27:53.468]                     is.null <- base::is.null
[08:27:53.468]                     muffled <- FALSE
[08:27:53.468]                     if (inherits(cond, "message")) {
[08:27:53.468]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.468]                       if (muffled) 
[08:27:53.468]                         invokeRestart("muffleMessage")
[08:27:53.468]                     }
[08:27:53.468]                     else if (inherits(cond, "warning")) {
[08:27:53.468]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.468]                       if (muffled) 
[08:27:53.468]                         invokeRestart("muffleWarning")
[08:27:53.468]                     }
[08:27:53.468]                     else if (inherits(cond, "condition")) {
[08:27:53.468]                       if (!is.null(pattern)) {
[08:27:53.468]                         computeRestarts <- base::computeRestarts
[08:27:53.468]                         grepl <- base::grepl
[08:27:53.468]                         restarts <- computeRestarts(cond)
[08:27:53.468]                         for (restart in restarts) {
[08:27:53.468]                           name <- restart$name
[08:27:53.468]                           if (is.null(name)) 
[08:27:53.468]                             next
[08:27:53.468]                           if (!grepl(pattern, name)) 
[08:27:53.468]                             next
[08:27:53.468]                           invokeRestart(restart)
[08:27:53.468]                           muffled <- TRUE
[08:27:53.468]                           break
[08:27:53.468]                         }
[08:27:53.468]                       }
[08:27:53.468]                     }
[08:27:53.468]                     invisible(muffled)
[08:27:53.468]                   }
[08:27:53.468]                   muffleCondition(cond)
[08:27:53.468]                 })
[08:27:53.468]             }))
[08:27:53.468]             future::FutureResult(value = ...future.value$value, 
[08:27:53.468]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.468]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.468]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.468]                     ...future.globalenv.names))
[08:27:53.468]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.468]         }, condition = base::local({
[08:27:53.468]             c <- base::c
[08:27:53.468]             inherits <- base::inherits
[08:27:53.468]             invokeRestart <- base::invokeRestart
[08:27:53.468]             length <- base::length
[08:27:53.468]             list <- base::list
[08:27:53.468]             seq.int <- base::seq.int
[08:27:53.468]             signalCondition <- base::signalCondition
[08:27:53.468]             sys.calls <- base::sys.calls
[08:27:53.468]             `[[` <- base::`[[`
[08:27:53.468]             `+` <- base::`+`
[08:27:53.468]             `<<-` <- base::`<<-`
[08:27:53.468]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.468]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.468]                   3L)]
[08:27:53.468]             }
[08:27:53.468]             function(cond) {
[08:27:53.468]                 is_error <- inherits(cond, "error")
[08:27:53.468]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.468]                   NULL)
[08:27:53.468]                 if (is_error) {
[08:27:53.468]                   sessionInformation <- function() {
[08:27:53.468]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.468]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.468]                       search = base::search(), system = base::Sys.info())
[08:27:53.468]                   }
[08:27:53.468]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.468]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.468]                     cond$call), session = sessionInformation(), 
[08:27:53.468]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.468]                   signalCondition(cond)
[08:27:53.468]                 }
[08:27:53.468]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.468]                 "immediateCondition"))) {
[08:27:53.468]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.468]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.468]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.468]                   if (TRUE && !signal) {
[08:27:53.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.468]                     {
[08:27:53.468]                       inherits <- base::inherits
[08:27:53.468]                       invokeRestart <- base::invokeRestart
[08:27:53.468]                       is.null <- base::is.null
[08:27:53.468]                       muffled <- FALSE
[08:27:53.468]                       if (inherits(cond, "message")) {
[08:27:53.468]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.468]                         if (muffled) 
[08:27:53.468]                           invokeRestart("muffleMessage")
[08:27:53.468]                       }
[08:27:53.468]                       else if (inherits(cond, "warning")) {
[08:27:53.468]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.468]                         if (muffled) 
[08:27:53.468]                           invokeRestart("muffleWarning")
[08:27:53.468]                       }
[08:27:53.468]                       else if (inherits(cond, "condition")) {
[08:27:53.468]                         if (!is.null(pattern)) {
[08:27:53.468]                           computeRestarts <- base::computeRestarts
[08:27:53.468]                           grepl <- base::grepl
[08:27:53.468]                           restarts <- computeRestarts(cond)
[08:27:53.468]                           for (restart in restarts) {
[08:27:53.468]                             name <- restart$name
[08:27:53.468]                             if (is.null(name)) 
[08:27:53.468]                               next
[08:27:53.468]                             if (!grepl(pattern, name)) 
[08:27:53.468]                               next
[08:27:53.468]                             invokeRestart(restart)
[08:27:53.468]                             muffled <- TRUE
[08:27:53.468]                             break
[08:27:53.468]                           }
[08:27:53.468]                         }
[08:27:53.468]                       }
[08:27:53.468]                       invisible(muffled)
[08:27:53.468]                     }
[08:27:53.468]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.468]                   }
[08:27:53.468]                 }
[08:27:53.468]                 else {
[08:27:53.468]                   if (TRUE) {
[08:27:53.468]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.468]                     {
[08:27:53.468]                       inherits <- base::inherits
[08:27:53.468]                       invokeRestart <- base::invokeRestart
[08:27:53.468]                       is.null <- base::is.null
[08:27:53.468]                       muffled <- FALSE
[08:27:53.468]                       if (inherits(cond, "message")) {
[08:27:53.468]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.468]                         if (muffled) 
[08:27:53.468]                           invokeRestart("muffleMessage")
[08:27:53.468]                       }
[08:27:53.468]                       else if (inherits(cond, "warning")) {
[08:27:53.468]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.468]                         if (muffled) 
[08:27:53.468]                           invokeRestart("muffleWarning")
[08:27:53.468]                       }
[08:27:53.468]                       else if (inherits(cond, "condition")) {
[08:27:53.468]                         if (!is.null(pattern)) {
[08:27:53.468]                           computeRestarts <- base::computeRestarts
[08:27:53.468]                           grepl <- base::grepl
[08:27:53.468]                           restarts <- computeRestarts(cond)
[08:27:53.468]                           for (restart in restarts) {
[08:27:53.468]                             name <- restart$name
[08:27:53.468]                             if (is.null(name)) 
[08:27:53.468]                               next
[08:27:53.468]                             if (!grepl(pattern, name)) 
[08:27:53.468]                               next
[08:27:53.468]                             invokeRestart(restart)
[08:27:53.468]                             muffled <- TRUE
[08:27:53.468]                             break
[08:27:53.468]                           }
[08:27:53.468]                         }
[08:27:53.468]                       }
[08:27:53.468]                       invisible(muffled)
[08:27:53.468]                     }
[08:27:53.468]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.468]                   }
[08:27:53.468]                 }
[08:27:53.468]             }
[08:27:53.468]         }))
[08:27:53.468]     }, error = function(ex) {
[08:27:53.468]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.468]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.468]                 ...future.rng), started = ...future.startTime, 
[08:27:53.468]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.468]             version = "1.8"), class = "FutureResult")
[08:27:53.468]     }, finally = {
[08:27:53.468]         if (!identical(...future.workdir, getwd())) 
[08:27:53.468]             setwd(...future.workdir)
[08:27:53.468]         {
[08:27:53.468]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.468]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.468]             }
[08:27:53.468]             base::options(...future.oldOptions)
[08:27:53.468]             if (.Platform$OS.type == "windows") {
[08:27:53.468]                 old_names <- names(...future.oldEnvVars)
[08:27:53.468]                 envs <- base::Sys.getenv()
[08:27:53.468]                 names <- names(envs)
[08:27:53.468]                 common <- intersect(names, old_names)
[08:27:53.468]                 added <- setdiff(names, old_names)
[08:27:53.468]                 removed <- setdiff(old_names, names)
[08:27:53.468]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.468]                   envs[common]]
[08:27:53.468]                 NAMES <- toupper(changed)
[08:27:53.468]                 args <- list()
[08:27:53.468]                 for (kk in seq_along(NAMES)) {
[08:27:53.468]                   name <- changed[[kk]]
[08:27:53.468]                   NAME <- NAMES[[kk]]
[08:27:53.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.468]                     next
[08:27:53.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.468]                 }
[08:27:53.468]                 NAMES <- toupper(added)
[08:27:53.468]                 for (kk in seq_along(NAMES)) {
[08:27:53.468]                   name <- added[[kk]]
[08:27:53.468]                   NAME <- NAMES[[kk]]
[08:27:53.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.468]                     next
[08:27:53.468]                   args[[name]] <- ""
[08:27:53.468]                 }
[08:27:53.468]                 NAMES <- toupper(removed)
[08:27:53.468]                 for (kk in seq_along(NAMES)) {
[08:27:53.468]                   name <- removed[[kk]]
[08:27:53.468]                   NAME <- NAMES[[kk]]
[08:27:53.468]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.468]                     next
[08:27:53.468]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.468]                 }
[08:27:53.468]                 if (length(args) > 0) 
[08:27:53.468]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.468]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.468]             }
[08:27:53.468]             else {
[08:27:53.468]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.468]             }
[08:27:53.468]             {
[08:27:53.468]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.468]                   0L) {
[08:27:53.468]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.468]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.468]                   base::options(opts)
[08:27:53.468]                 }
[08:27:53.468]                 {
[08:27:53.468]                   {
[08:27:53.468]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.468]                     NULL
[08:27:53.468]                   }
[08:27:53.468]                   options(future.plan = NULL)
[08:27:53.468]                   if (is.na(NA_character_)) 
[08:27:53.468]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.468]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.468]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.468]                     .init = FALSE)
[08:27:53.468]                 }
[08:27:53.468]             }
[08:27:53.468]         }
[08:27:53.468]     })
[08:27:53.468]     if (TRUE) {
[08:27:53.468]         base::sink(type = "output", split = FALSE)
[08:27:53.468]         if (TRUE) {
[08:27:53.468]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.468]         }
[08:27:53.468]         else {
[08:27:53.468]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.468]         }
[08:27:53.468]         base::close(...future.stdout)
[08:27:53.468]         ...future.stdout <- NULL
[08:27:53.468]     }
[08:27:53.468]     ...future.result$conditions <- ...future.conditions
[08:27:53.468]     ...future.result$finished <- base::Sys.time()
[08:27:53.468]     ...future.result
[08:27:53.468] }
[08:27:53.470] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:53.481] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.482] - Validating connection of MultisessionFuture
[08:27:53.482] - received message: FutureResult
[08:27:53.482] - Received FutureResult
[08:27:53.482] - Erased future from FutureRegistry
[08:27:53.482] result() for ClusterFuture ...
[08:27:53.482] - result already collected: FutureResult
[08:27:53.482] result() for ClusterFuture ... done
[08:27:53.482] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.482] result() for ClusterFuture ...
[08:27:53.482] - result already collected: FutureResult
[08:27:53.483] result() for ClusterFuture ... done
[08:27:53.483] result() for ClusterFuture ...
[08:27:53.483] - result already collected: FutureResult
[08:27:53.483] result() for ClusterFuture ... done
[08:27:53.484] MultisessionFuture started
[08:27:53.484] - Launch lazy future ... done
[08:27:53.484] run() for ‘MultisessionFuture’ ... done
<environment: 0x55d862e59aa8> 
<environment: 0x55d85f455a50> 
[08:27:53.490] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.490] - Validating connection of MultisessionFuture
[08:27:53.490] - received message: FutureResult
[08:27:53.491] - Received FutureResult
[08:27:53.491] - Erased future from FutureRegistry
[08:27:53.491] result() for ClusterFuture ...
[08:27:53.491] - result already collected: FutureResult
[08:27:53.491] result() for ClusterFuture ... done
[08:27:53.491] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:53.503] resolve() on environment ...
[08:27:53.503]  recursive: 0
[08:27:53.503]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:53.504] signalConditionsASAP(numeric, pos=1) ...
[08:27:53.504] - nx: 4
[08:27:53.504] - relay: TRUE
[08:27:53.504] - stdout: TRUE
[08:27:53.504] - signal: TRUE
[08:27:53.504] - resignal: FALSE
[08:27:53.504] - force: TRUE
[08:27:53.504] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.504] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.504]  - until=2
[08:27:53.504]  - relaying element #2
[08:27:53.505] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.505] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.505] signalConditionsASAP(NULL, pos=1) ... done
[08:27:53.505]  length: 3 (resolved future 1)
[08:27:53.505] Future #2
[08:27:53.505] result() for ClusterFuture ...
[08:27:53.505] - result already collected: FutureResult
[08:27:53.505] result() for ClusterFuture ... done
[08:27:53.505] result() for ClusterFuture ...
[08:27:53.505] - result already collected: FutureResult
[08:27:53.505] result() for ClusterFuture ... done
[08:27:53.506] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:53.506] - nx: 4
[08:27:53.506] - relay: TRUE
[08:27:53.506] - stdout: TRUE
[08:27:53.506] - signal: TRUE
[08:27:53.506] - resignal: FALSE
[08:27:53.506] - force: TRUE
[08:27:53.506] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.506] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.506]  - until=2
[08:27:53.506]  - relaying element #2
[08:27:53.506] result() for ClusterFuture ...
[08:27:53.507] - result already collected: FutureResult
[08:27:53.507] result() for ClusterFuture ... done
[08:27:53.507] result() for ClusterFuture ...
[08:27:53.507] - result already collected: FutureResult
[08:27:53.507] result() for ClusterFuture ... done
[08:27:53.507] result() for ClusterFuture ...
[08:27:53.507] - result already collected: FutureResult
[08:27:53.507] result() for ClusterFuture ... done
[08:27:53.507] result() for ClusterFuture ...
[08:27:53.507] - result already collected: FutureResult
[08:27:53.507] result() for ClusterFuture ... done
[08:27:53.507] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.508] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.508] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:53.508]  length: 2 (resolved future 2)
[08:27:53.508] Future #3
[08:27:53.508] result() for ClusterFuture ...
[08:27:53.508] - result already collected: FutureResult
[08:27:53.508] result() for ClusterFuture ... done
[08:27:53.508] result() for ClusterFuture ...
[08:27:53.508] - result already collected: FutureResult
[08:27:53.508] result() for ClusterFuture ... done
[08:27:53.508] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:53.508] - nx: 4
[08:27:53.509] - relay: TRUE
[08:27:53.509] - stdout: TRUE
[08:27:53.509] - signal: TRUE
[08:27:53.509] - resignal: FALSE
[08:27:53.509] - force: TRUE
[08:27:53.509] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.509] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.509]  - until=3
[08:27:53.509]  - relaying element #3
[08:27:53.509] result() for ClusterFuture ...
[08:27:53.509] - result already collected: FutureResult
[08:27:53.509] result() for ClusterFuture ... done
[08:27:53.510] result() for ClusterFuture ...
[08:27:53.510] - result already collected: FutureResult
[08:27:53.510] result() for ClusterFuture ... done
[08:27:53.510] result() for ClusterFuture ...
[08:27:53.510] - result already collected: FutureResult
[08:27:53.510] result() for ClusterFuture ... done
[08:27:53.510] result() for ClusterFuture ...
[08:27:53.510] - result already collected: FutureResult
[08:27:53.510] result() for ClusterFuture ... done
[08:27:53.510] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.510] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.510] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:53.511]  length: 1 (resolved future 3)
[08:27:53.532] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.532] - Validating connection of MultisessionFuture
[08:27:53.532] - received message: FutureResult
[08:27:53.532] - Received FutureResult
[08:27:53.532] - Erased future from FutureRegistry
[08:27:53.533] result() for ClusterFuture ...
[08:27:53.533] - result already collected: FutureResult
[08:27:53.533] result() for ClusterFuture ... done
[08:27:53.533] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.533] Future #4
[08:27:53.533] result() for ClusterFuture ...
[08:27:53.533] - result already collected: FutureResult
[08:27:53.533] result() for ClusterFuture ... done
[08:27:53.533] result() for ClusterFuture ...
[08:27:53.533] - result already collected: FutureResult
[08:27:53.533] result() for ClusterFuture ... done
[08:27:53.533] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:53.534] - nx: 4
[08:27:53.534] - relay: TRUE
[08:27:53.534] - stdout: TRUE
[08:27:53.534] - signal: TRUE
[08:27:53.534] - resignal: FALSE
[08:27:53.534] - force: TRUE
[08:27:53.534] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.534] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.534]  - until=4
[08:27:53.534]  - relaying element #4
[08:27:53.534] result() for ClusterFuture ...
[08:27:53.534] - result already collected: FutureResult
[08:27:53.535] result() for ClusterFuture ... done
[08:27:53.535] result() for ClusterFuture ...
[08:27:53.535] - result already collected: FutureResult
[08:27:53.535] result() for ClusterFuture ... done
[08:27:53.535] result() for ClusterFuture ...
[08:27:53.535] - result already collected: FutureResult
[08:27:53.535] result() for ClusterFuture ... done
[08:27:53.535] result() for ClusterFuture ...
[08:27:53.535] - result already collected: FutureResult
[08:27:53.535] result() for ClusterFuture ... done
[08:27:53.535] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.535] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.536] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:53.536]  length: 0 (resolved future 4)
[08:27:53.536] Relaying remaining futures
[08:27:53.536] signalConditionsASAP(NULL, pos=0) ...
[08:27:53.536] - nx: 4
[08:27:53.536] - relay: TRUE
[08:27:53.536] - stdout: TRUE
[08:27:53.536] - signal: TRUE
[08:27:53.536] - resignal: FALSE
[08:27:53.536] - force: TRUE
[08:27:53.536] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.536] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:53.537] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.537] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.537] signalConditionsASAP(NULL, pos=0) ... done
[08:27:53.537] resolve() on environment ... DONE
[08:27:53.537] result() for ClusterFuture ...
[08:27:53.537] - result already collected: FutureResult
[08:27:53.537] result() for ClusterFuture ... done
[08:27:53.537] result() for ClusterFuture ...
[08:27:53.537] - result already collected: FutureResult
[08:27:53.537] result() for ClusterFuture ... done
[08:27:53.537] result() for ClusterFuture ...
[08:27:53.537] - result already collected: FutureResult
[08:27:53.538] result() for ClusterFuture ... done
[08:27:53.538] result() for ClusterFuture ...
[08:27:53.538] - result already collected: FutureResult
[08:27:53.538] result() for ClusterFuture ... done
[08:27:53.538] result() for ClusterFuture ...
[08:27:53.538] - result already collected: FutureResult
[08:27:53.538] result() for ClusterFuture ... done
[08:27:53.538] result() for ClusterFuture ...
[08:27:53.538] - result already collected: FutureResult
[08:27:53.538] result() for ClusterFuture ... done
<environment: 0x55d8600c69d0> 
Dimensions: c(2, 3)
[08:27:53.539] getGlobalsAndPackages() ...
[08:27:53.539] Searching for globals...
[08:27:53.539] 
[08:27:53.539] Searching for globals ... DONE
[08:27:53.539] - globals: [0] <none>
[08:27:53.539] getGlobalsAndPackages() ... DONE
[08:27:53.540] run() for ‘Future’ ...
[08:27:53.540] - state: ‘created’
[08:27:53.540] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.554] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.554]   - Field: ‘node’
[08:27:53.554]   - Field: ‘label’
[08:27:53.554]   - Field: ‘local’
[08:27:53.555]   - Field: ‘owner’
[08:27:53.555]   - Field: ‘envir’
[08:27:53.555]   - Field: ‘workers’
[08:27:53.555]   - Field: ‘packages’
[08:27:53.555]   - Field: ‘gc’
[08:27:53.555]   - Field: ‘conditions’
[08:27:53.555]   - Field: ‘persistent’
[08:27:53.555]   - Field: ‘expr’
[08:27:53.555]   - Field: ‘uuid’
[08:27:53.555]   - Field: ‘seed’
[08:27:53.555]   - Field: ‘version’
[08:27:53.555]   - Field: ‘result’
[08:27:53.556]   - Field: ‘asynchronous’
[08:27:53.556]   - Field: ‘calls’
[08:27:53.556]   - Field: ‘globals’
[08:27:53.556]   - Field: ‘stdout’
[08:27:53.556]   - Field: ‘earlySignal’
[08:27:53.556]   - Field: ‘lazy’
[08:27:53.556]   - Field: ‘state’
[08:27:53.556] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.556] - Launch lazy future ...
[08:27:53.556] Packages needed by the future expression (n = 0): <none>
[08:27:53.557] Packages needed by future strategies (n = 0): <none>
[08:27:53.557] {
[08:27:53.557]     {
[08:27:53.557]         {
[08:27:53.557]             ...future.startTime <- base::Sys.time()
[08:27:53.557]             {
[08:27:53.557]                 {
[08:27:53.557]                   {
[08:27:53.557]                     {
[08:27:53.557]                       base::local({
[08:27:53.557]                         has_future <- base::requireNamespace("future", 
[08:27:53.557]                           quietly = TRUE)
[08:27:53.557]                         if (has_future) {
[08:27:53.557]                           ns <- base::getNamespace("future")
[08:27:53.557]                           version <- ns[[".package"]][["version"]]
[08:27:53.557]                           if (is.null(version)) 
[08:27:53.557]                             version <- utils::packageVersion("future")
[08:27:53.557]                         }
[08:27:53.557]                         else {
[08:27:53.557]                           version <- NULL
[08:27:53.557]                         }
[08:27:53.557]                         if (!has_future || version < "1.8.0") {
[08:27:53.557]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.557]                             "", base::R.version$version.string), 
[08:27:53.557]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.557]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.557]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.557]                               "release", "version")], collapse = " "), 
[08:27:53.557]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.557]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.557]                             info)
[08:27:53.557]                           info <- base::paste(info, collapse = "; ")
[08:27:53.557]                           if (!has_future) {
[08:27:53.557]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.557]                               info)
[08:27:53.557]                           }
[08:27:53.557]                           else {
[08:27:53.557]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.557]                               info, version)
[08:27:53.557]                           }
[08:27:53.557]                           base::stop(msg)
[08:27:53.557]                         }
[08:27:53.557]                       })
[08:27:53.557]                     }
[08:27:53.557]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.557]                     base::options(mc.cores = 1L)
[08:27:53.557]                   }
[08:27:53.557]                   ...future.strategy.old <- future::plan("list")
[08:27:53.557]                   options(future.plan = NULL)
[08:27:53.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.557]                 }
[08:27:53.557]                 ...future.workdir <- getwd()
[08:27:53.557]             }
[08:27:53.557]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.557]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.557]         }
[08:27:53.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.557]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.557]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.557]             base::names(...future.oldOptions))
[08:27:53.557]     }
[08:27:53.557]     if (FALSE) {
[08:27:53.557]     }
[08:27:53.557]     else {
[08:27:53.557]         if (TRUE) {
[08:27:53.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.557]                 open = "w")
[08:27:53.557]         }
[08:27:53.557]         else {
[08:27:53.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.557]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.557]         }
[08:27:53.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.557]             base::sink(type = "output", split = FALSE)
[08:27:53.557]             base::close(...future.stdout)
[08:27:53.557]         }, add = TRUE)
[08:27:53.557]     }
[08:27:53.557]     ...future.frame <- base::sys.nframe()
[08:27:53.557]     ...future.conditions <- base::list()
[08:27:53.557]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.557]     if (FALSE) {
[08:27:53.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.557]     }
[08:27:53.557]     ...future.result <- base::tryCatch({
[08:27:53.557]         base::withCallingHandlers({
[08:27:53.557]             ...future.value <- base::withVisible(base::local({
[08:27:53.557]                 ...future.makeSendCondition <- base::local({
[08:27:53.557]                   sendCondition <- NULL
[08:27:53.557]                   function(frame = 1L) {
[08:27:53.557]                     if (is.function(sendCondition)) 
[08:27:53.557]                       return(sendCondition)
[08:27:53.557]                     ns <- getNamespace("parallel")
[08:27:53.557]                     if (exists("sendData", mode = "function", 
[08:27:53.557]                       envir = ns)) {
[08:27:53.557]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.557]                         envir = ns)
[08:27:53.557]                       envir <- sys.frame(frame)
[08:27:53.557]                       master <- NULL
[08:27:53.557]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.557]                         !identical(envir, emptyenv())) {
[08:27:53.557]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.557]                           inherits = FALSE)) {
[08:27:53.557]                           master <- get("master", mode = "list", 
[08:27:53.557]                             envir = envir, inherits = FALSE)
[08:27:53.557]                           if (inherits(master, c("SOCKnode", 
[08:27:53.557]                             "SOCK0node"))) {
[08:27:53.557]                             sendCondition <<- function(cond) {
[08:27:53.557]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.557]                                 success = TRUE)
[08:27:53.557]                               parallel_sendData(master, data)
[08:27:53.557]                             }
[08:27:53.557]                             return(sendCondition)
[08:27:53.557]                           }
[08:27:53.557]                         }
[08:27:53.557]                         frame <- frame + 1L
[08:27:53.557]                         envir <- sys.frame(frame)
[08:27:53.557]                       }
[08:27:53.557]                     }
[08:27:53.557]                     sendCondition <<- function(cond) NULL
[08:27:53.557]                   }
[08:27:53.557]                 })
[08:27:53.557]                 withCallingHandlers({
[08:27:53.557]                   2
[08:27:53.557]                 }, immediateCondition = function(cond) {
[08:27:53.557]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.557]                   sendCondition(cond)
[08:27:53.557]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.557]                   {
[08:27:53.557]                     inherits <- base::inherits
[08:27:53.557]                     invokeRestart <- base::invokeRestart
[08:27:53.557]                     is.null <- base::is.null
[08:27:53.557]                     muffled <- FALSE
[08:27:53.557]                     if (inherits(cond, "message")) {
[08:27:53.557]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.557]                       if (muffled) 
[08:27:53.557]                         invokeRestart("muffleMessage")
[08:27:53.557]                     }
[08:27:53.557]                     else if (inherits(cond, "warning")) {
[08:27:53.557]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.557]                       if (muffled) 
[08:27:53.557]                         invokeRestart("muffleWarning")
[08:27:53.557]                     }
[08:27:53.557]                     else if (inherits(cond, "condition")) {
[08:27:53.557]                       if (!is.null(pattern)) {
[08:27:53.557]                         computeRestarts <- base::computeRestarts
[08:27:53.557]                         grepl <- base::grepl
[08:27:53.557]                         restarts <- computeRestarts(cond)
[08:27:53.557]                         for (restart in restarts) {
[08:27:53.557]                           name <- restart$name
[08:27:53.557]                           if (is.null(name)) 
[08:27:53.557]                             next
[08:27:53.557]                           if (!grepl(pattern, name)) 
[08:27:53.557]                             next
[08:27:53.557]                           invokeRestart(restart)
[08:27:53.557]                           muffled <- TRUE
[08:27:53.557]                           break
[08:27:53.557]                         }
[08:27:53.557]                       }
[08:27:53.557]                     }
[08:27:53.557]                     invisible(muffled)
[08:27:53.557]                   }
[08:27:53.557]                   muffleCondition(cond)
[08:27:53.557]                 })
[08:27:53.557]             }))
[08:27:53.557]             future::FutureResult(value = ...future.value$value, 
[08:27:53.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.557]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.557]                     ...future.globalenv.names))
[08:27:53.557]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.557]         }, condition = base::local({
[08:27:53.557]             c <- base::c
[08:27:53.557]             inherits <- base::inherits
[08:27:53.557]             invokeRestart <- base::invokeRestart
[08:27:53.557]             length <- base::length
[08:27:53.557]             list <- base::list
[08:27:53.557]             seq.int <- base::seq.int
[08:27:53.557]             signalCondition <- base::signalCondition
[08:27:53.557]             sys.calls <- base::sys.calls
[08:27:53.557]             `[[` <- base::`[[`
[08:27:53.557]             `+` <- base::`+`
[08:27:53.557]             `<<-` <- base::`<<-`
[08:27:53.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.557]                   3L)]
[08:27:53.557]             }
[08:27:53.557]             function(cond) {
[08:27:53.557]                 is_error <- inherits(cond, "error")
[08:27:53.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.557]                   NULL)
[08:27:53.557]                 if (is_error) {
[08:27:53.557]                   sessionInformation <- function() {
[08:27:53.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.557]                       search = base::search(), system = base::Sys.info())
[08:27:53.557]                   }
[08:27:53.557]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.557]                     cond$call), session = sessionInformation(), 
[08:27:53.557]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.557]                   signalCondition(cond)
[08:27:53.557]                 }
[08:27:53.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.557]                 "immediateCondition"))) {
[08:27:53.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.557]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.557]                   if (TRUE && !signal) {
[08:27:53.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.557]                     {
[08:27:53.557]                       inherits <- base::inherits
[08:27:53.557]                       invokeRestart <- base::invokeRestart
[08:27:53.557]                       is.null <- base::is.null
[08:27:53.557]                       muffled <- FALSE
[08:27:53.557]                       if (inherits(cond, "message")) {
[08:27:53.557]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.557]                         if (muffled) 
[08:27:53.557]                           invokeRestart("muffleMessage")
[08:27:53.557]                       }
[08:27:53.557]                       else if (inherits(cond, "warning")) {
[08:27:53.557]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.557]                         if (muffled) 
[08:27:53.557]                           invokeRestart("muffleWarning")
[08:27:53.557]                       }
[08:27:53.557]                       else if (inherits(cond, "condition")) {
[08:27:53.557]                         if (!is.null(pattern)) {
[08:27:53.557]                           computeRestarts <- base::computeRestarts
[08:27:53.557]                           grepl <- base::grepl
[08:27:53.557]                           restarts <- computeRestarts(cond)
[08:27:53.557]                           for (restart in restarts) {
[08:27:53.557]                             name <- restart$name
[08:27:53.557]                             if (is.null(name)) 
[08:27:53.557]                               next
[08:27:53.557]                             if (!grepl(pattern, name)) 
[08:27:53.557]                               next
[08:27:53.557]                             invokeRestart(restart)
[08:27:53.557]                             muffled <- TRUE
[08:27:53.557]                             break
[08:27:53.557]                           }
[08:27:53.557]                         }
[08:27:53.557]                       }
[08:27:53.557]                       invisible(muffled)
[08:27:53.557]                     }
[08:27:53.557]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.557]                   }
[08:27:53.557]                 }
[08:27:53.557]                 else {
[08:27:53.557]                   if (TRUE) {
[08:27:53.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.557]                     {
[08:27:53.557]                       inherits <- base::inherits
[08:27:53.557]                       invokeRestart <- base::invokeRestart
[08:27:53.557]                       is.null <- base::is.null
[08:27:53.557]                       muffled <- FALSE
[08:27:53.557]                       if (inherits(cond, "message")) {
[08:27:53.557]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.557]                         if (muffled) 
[08:27:53.557]                           invokeRestart("muffleMessage")
[08:27:53.557]                       }
[08:27:53.557]                       else if (inherits(cond, "warning")) {
[08:27:53.557]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.557]                         if (muffled) 
[08:27:53.557]                           invokeRestart("muffleWarning")
[08:27:53.557]                       }
[08:27:53.557]                       else if (inherits(cond, "condition")) {
[08:27:53.557]                         if (!is.null(pattern)) {
[08:27:53.557]                           computeRestarts <- base::computeRestarts
[08:27:53.557]                           grepl <- base::grepl
[08:27:53.557]                           restarts <- computeRestarts(cond)
[08:27:53.557]                           for (restart in restarts) {
[08:27:53.557]                             name <- restart$name
[08:27:53.557]                             if (is.null(name)) 
[08:27:53.557]                               next
[08:27:53.557]                             if (!grepl(pattern, name)) 
[08:27:53.557]                               next
[08:27:53.557]                             invokeRestart(restart)
[08:27:53.557]                             muffled <- TRUE
[08:27:53.557]                             break
[08:27:53.557]                           }
[08:27:53.557]                         }
[08:27:53.557]                       }
[08:27:53.557]                       invisible(muffled)
[08:27:53.557]                     }
[08:27:53.557]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.557]                   }
[08:27:53.557]                 }
[08:27:53.557]             }
[08:27:53.557]         }))
[08:27:53.557]     }, error = function(ex) {
[08:27:53.557]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.557]                 ...future.rng), started = ...future.startTime, 
[08:27:53.557]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.557]             version = "1.8"), class = "FutureResult")
[08:27:53.557]     }, finally = {
[08:27:53.557]         if (!identical(...future.workdir, getwd())) 
[08:27:53.557]             setwd(...future.workdir)
[08:27:53.557]         {
[08:27:53.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.557]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.557]             }
[08:27:53.557]             base::options(...future.oldOptions)
[08:27:53.557]             if (.Platform$OS.type == "windows") {
[08:27:53.557]                 old_names <- names(...future.oldEnvVars)
[08:27:53.557]                 envs <- base::Sys.getenv()
[08:27:53.557]                 names <- names(envs)
[08:27:53.557]                 common <- intersect(names, old_names)
[08:27:53.557]                 added <- setdiff(names, old_names)
[08:27:53.557]                 removed <- setdiff(old_names, names)
[08:27:53.557]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.557]                   envs[common]]
[08:27:53.557]                 NAMES <- toupper(changed)
[08:27:53.557]                 args <- list()
[08:27:53.557]                 for (kk in seq_along(NAMES)) {
[08:27:53.557]                   name <- changed[[kk]]
[08:27:53.557]                   NAME <- NAMES[[kk]]
[08:27:53.557]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.557]                     next
[08:27:53.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.557]                 }
[08:27:53.557]                 NAMES <- toupper(added)
[08:27:53.557]                 for (kk in seq_along(NAMES)) {
[08:27:53.557]                   name <- added[[kk]]
[08:27:53.557]                   NAME <- NAMES[[kk]]
[08:27:53.557]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.557]                     next
[08:27:53.557]                   args[[name]] <- ""
[08:27:53.557]                 }
[08:27:53.557]                 NAMES <- toupper(removed)
[08:27:53.557]                 for (kk in seq_along(NAMES)) {
[08:27:53.557]                   name <- removed[[kk]]
[08:27:53.557]                   NAME <- NAMES[[kk]]
[08:27:53.557]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.557]                     next
[08:27:53.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.557]                 }
[08:27:53.557]                 if (length(args) > 0) 
[08:27:53.557]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.557]             }
[08:27:53.557]             else {
[08:27:53.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.557]             }
[08:27:53.557]             {
[08:27:53.557]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.557]                   0L) {
[08:27:53.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.557]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.557]                   base::options(opts)
[08:27:53.557]                 }
[08:27:53.557]                 {
[08:27:53.557]                   {
[08:27:53.557]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.557]                     NULL
[08:27:53.557]                   }
[08:27:53.557]                   options(future.plan = NULL)
[08:27:53.557]                   if (is.na(NA_character_)) 
[08:27:53.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.557]                     .init = FALSE)
[08:27:53.557]                 }
[08:27:53.557]             }
[08:27:53.557]         }
[08:27:53.557]     })
[08:27:53.557]     if (TRUE) {
[08:27:53.557]         base::sink(type = "output", split = FALSE)
[08:27:53.557]         if (TRUE) {
[08:27:53.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.557]         }
[08:27:53.557]         else {
[08:27:53.557]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.557]         }
[08:27:53.557]         base::close(...future.stdout)
[08:27:53.557]         ...future.stdout <- NULL
[08:27:53.557]     }
[08:27:53.557]     ...future.result$conditions <- ...future.conditions
[08:27:53.557]     ...future.result$finished <- base::Sys.time()
[08:27:53.557]     ...future.result
[08:27:53.557] }
[08:27:53.560] MultisessionFuture started
[08:27:53.560] - Launch lazy future ... done
[08:27:53.561] run() for ‘MultisessionFuture’ ... done
[08:27:53.561] getGlobalsAndPackages() ...
[08:27:53.561] Searching for globals...
[08:27:53.561] 
[08:27:53.561] Searching for globals ... DONE
[08:27:53.561] - globals: [0] <none>
[08:27:53.561] getGlobalsAndPackages() ... DONE
[08:27:53.562] run() for ‘Future’ ...
[08:27:53.562] - state: ‘created’
[08:27:53.562] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.576] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.576] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.576]   - Field: ‘node’
[08:27:53.576]   - Field: ‘label’
[08:27:53.576]   - Field: ‘local’
[08:27:53.577]   - Field: ‘owner’
[08:27:53.577]   - Field: ‘envir’
[08:27:53.577]   - Field: ‘workers’
[08:27:53.577]   - Field: ‘packages’
[08:27:53.577]   - Field: ‘gc’
[08:27:53.577]   - Field: ‘conditions’
[08:27:53.577]   - Field: ‘persistent’
[08:27:53.577]   - Field: ‘expr’
[08:27:53.577]   - Field: ‘uuid’
[08:27:53.577]   - Field: ‘seed’
[08:27:53.577]   - Field: ‘version’
[08:27:53.577]   - Field: ‘result’
[08:27:53.578]   - Field: ‘asynchronous’
[08:27:53.578]   - Field: ‘calls’
[08:27:53.578]   - Field: ‘globals’
[08:27:53.578]   - Field: ‘stdout’
[08:27:53.578]   - Field: ‘earlySignal’
[08:27:53.578]   - Field: ‘lazy’
[08:27:53.578]   - Field: ‘state’
[08:27:53.578] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.578] - Launch lazy future ...
[08:27:53.579] Packages needed by the future expression (n = 0): <none>
[08:27:53.579] Packages needed by future strategies (n = 0): <none>
[08:27:53.579] {
[08:27:53.579]     {
[08:27:53.579]         {
[08:27:53.579]             ...future.startTime <- base::Sys.time()
[08:27:53.579]             {
[08:27:53.579]                 {
[08:27:53.579]                   {
[08:27:53.579]                     {
[08:27:53.579]                       base::local({
[08:27:53.579]                         has_future <- base::requireNamespace("future", 
[08:27:53.579]                           quietly = TRUE)
[08:27:53.579]                         if (has_future) {
[08:27:53.579]                           ns <- base::getNamespace("future")
[08:27:53.579]                           version <- ns[[".package"]][["version"]]
[08:27:53.579]                           if (is.null(version)) 
[08:27:53.579]                             version <- utils::packageVersion("future")
[08:27:53.579]                         }
[08:27:53.579]                         else {
[08:27:53.579]                           version <- NULL
[08:27:53.579]                         }
[08:27:53.579]                         if (!has_future || version < "1.8.0") {
[08:27:53.579]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.579]                             "", base::R.version$version.string), 
[08:27:53.579]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.579]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.579]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.579]                               "release", "version")], collapse = " "), 
[08:27:53.579]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.579]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.579]                             info)
[08:27:53.579]                           info <- base::paste(info, collapse = "; ")
[08:27:53.579]                           if (!has_future) {
[08:27:53.579]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.579]                               info)
[08:27:53.579]                           }
[08:27:53.579]                           else {
[08:27:53.579]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.579]                               info, version)
[08:27:53.579]                           }
[08:27:53.579]                           base::stop(msg)
[08:27:53.579]                         }
[08:27:53.579]                       })
[08:27:53.579]                     }
[08:27:53.579]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.579]                     base::options(mc.cores = 1L)
[08:27:53.579]                   }
[08:27:53.579]                   ...future.strategy.old <- future::plan("list")
[08:27:53.579]                   options(future.plan = NULL)
[08:27:53.579]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.579]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.579]                 }
[08:27:53.579]                 ...future.workdir <- getwd()
[08:27:53.579]             }
[08:27:53.579]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.579]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.579]         }
[08:27:53.579]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.579]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.579]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.579]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.579]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.579]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.579]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.579]             base::names(...future.oldOptions))
[08:27:53.579]     }
[08:27:53.579]     if (FALSE) {
[08:27:53.579]     }
[08:27:53.579]     else {
[08:27:53.579]         if (TRUE) {
[08:27:53.579]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.579]                 open = "w")
[08:27:53.579]         }
[08:27:53.579]         else {
[08:27:53.579]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.579]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.579]         }
[08:27:53.579]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.579]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.579]             base::sink(type = "output", split = FALSE)
[08:27:53.579]             base::close(...future.stdout)
[08:27:53.579]         }, add = TRUE)
[08:27:53.579]     }
[08:27:53.579]     ...future.frame <- base::sys.nframe()
[08:27:53.579]     ...future.conditions <- base::list()
[08:27:53.579]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.579]     if (FALSE) {
[08:27:53.579]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.579]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.579]     }
[08:27:53.579]     ...future.result <- base::tryCatch({
[08:27:53.579]         base::withCallingHandlers({
[08:27:53.579]             ...future.value <- base::withVisible(base::local({
[08:27:53.579]                 ...future.makeSendCondition <- base::local({
[08:27:53.579]                   sendCondition <- NULL
[08:27:53.579]                   function(frame = 1L) {
[08:27:53.579]                     if (is.function(sendCondition)) 
[08:27:53.579]                       return(sendCondition)
[08:27:53.579]                     ns <- getNamespace("parallel")
[08:27:53.579]                     if (exists("sendData", mode = "function", 
[08:27:53.579]                       envir = ns)) {
[08:27:53.579]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.579]                         envir = ns)
[08:27:53.579]                       envir <- sys.frame(frame)
[08:27:53.579]                       master <- NULL
[08:27:53.579]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.579]                         !identical(envir, emptyenv())) {
[08:27:53.579]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.579]                           inherits = FALSE)) {
[08:27:53.579]                           master <- get("master", mode = "list", 
[08:27:53.579]                             envir = envir, inherits = FALSE)
[08:27:53.579]                           if (inherits(master, c("SOCKnode", 
[08:27:53.579]                             "SOCK0node"))) {
[08:27:53.579]                             sendCondition <<- function(cond) {
[08:27:53.579]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.579]                                 success = TRUE)
[08:27:53.579]                               parallel_sendData(master, data)
[08:27:53.579]                             }
[08:27:53.579]                             return(sendCondition)
[08:27:53.579]                           }
[08:27:53.579]                         }
[08:27:53.579]                         frame <- frame + 1L
[08:27:53.579]                         envir <- sys.frame(frame)
[08:27:53.579]                       }
[08:27:53.579]                     }
[08:27:53.579]                     sendCondition <<- function(cond) NULL
[08:27:53.579]                   }
[08:27:53.579]                 })
[08:27:53.579]                 withCallingHandlers({
[08:27:53.579]                   NULL
[08:27:53.579]                 }, immediateCondition = function(cond) {
[08:27:53.579]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.579]                   sendCondition(cond)
[08:27:53.579]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.579]                   {
[08:27:53.579]                     inherits <- base::inherits
[08:27:53.579]                     invokeRestart <- base::invokeRestart
[08:27:53.579]                     is.null <- base::is.null
[08:27:53.579]                     muffled <- FALSE
[08:27:53.579]                     if (inherits(cond, "message")) {
[08:27:53.579]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.579]                       if (muffled) 
[08:27:53.579]                         invokeRestart("muffleMessage")
[08:27:53.579]                     }
[08:27:53.579]                     else if (inherits(cond, "warning")) {
[08:27:53.579]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.579]                       if (muffled) 
[08:27:53.579]                         invokeRestart("muffleWarning")
[08:27:53.579]                     }
[08:27:53.579]                     else if (inherits(cond, "condition")) {
[08:27:53.579]                       if (!is.null(pattern)) {
[08:27:53.579]                         computeRestarts <- base::computeRestarts
[08:27:53.579]                         grepl <- base::grepl
[08:27:53.579]                         restarts <- computeRestarts(cond)
[08:27:53.579]                         for (restart in restarts) {
[08:27:53.579]                           name <- restart$name
[08:27:53.579]                           if (is.null(name)) 
[08:27:53.579]                             next
[08:27:53.579]                           if (!grepl(pattern, name)) 
[08:27:53.579]                             next
[08:27:53.579]                           invokeRestart(restart)
[08:27:53.579]                           muffled <- TRUE
[08:27:53.579]                           break
[08:27:53.579]                         }
[08:27:53.579]                       }
[08:27:53.579]                     }
[08:27:53.579]                     invisible(muffled)
[08:27:53.579]                   }
[08:27:53.579]                   muffleCondition(cond)
[08:27:53.579]                 })
[08:27:53.579]             }))
[08:27:53.579]             future::FutureResult(value = ...future.value$value, 
[08:27:53.579]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.579]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.579]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.579]                     ...future.globalenv.names))
[08:27:53.579]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.579]         }, condition = base::local({
[08:27:53.579]             c <- base::c
[08:27:53.579]             inherits <- base::inherits
[08:27:53.579]             invokeRestart <- base::invokeRestart
[08:27:53.579]             length <- base::length
[08:27:53.579]             list <- base::list
[08:27:53.579]             seq.int <- base::seq.int
[08:27:53.579]             signalCondition <- base::signalCondition
[08:27:53.579]             sys.calls <- base::sys.calls
[08:27:53.579]             `[[` <- base::`[[`
[08:27:53.579]             `+` <- base::`+`
[08:27:53.579]             `<<-` <- base::`<<-`
[08:27:53.579]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.579]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.579]                   3L)]
[08:27:53.579]             }
[08:27:53.579]             function(cond) {
[08:27:53.579]                 is_error <- inherits(cond, "error")
[08:27:53.579]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.579]                   NULL)
[08:27:53.579]                 if (is_error) {
[08:27:53.579]                   sessionInformation <- function() {
[08:27:53.579]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.579]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.579]                       search = base::search(), system = base::Sys.info())
[08:27:53.579]                   }
[08:27:53.579]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.579]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.579]                     cond$call), session = sessionInformation(), 
[08:27:53.579]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.579]                   signalCondition(cond)
[08:27:53.579]                 }
[08:27:53.579]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.579]                 "immediateCondition"))) {
[08:27:53.579]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.579]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.579]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.579]                   if (TRUE && !signal) {
[08:27:53.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.579]                     {
[08:27:53.579]                       inherits <- base::inherits
[08:27:53.579]                       invokeRestart <- base::invokeRestart
[08:27:53.579]                       is.null <- base::is.null
[08:27:53.579]                       muffled <- FALSE
[08:27:53.579]                       if (inherits(cond, "message")) {
[08:27:53.579]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.579]                         if (muffled) 
[08:27:53.579]                           invokeRestart("muffleMessage")
[08:27:53.579]                       }
[08:27:53.579]                       else if (inherits(cond, "warning")) {
[08:27:53.579]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.579]                         if (muffled) 
[08:27:53.579]                           invokeRestart("muffleWarning")
[08:27:53.579]                       }
[08:27:53.579]                       else if (inherits(cond, "condition")) {
[08:27:53.579]                         if (!is.null(pattern)) {
[08:27:53.579]                           computeRestarts <- base::computeRestarts
[08:27:53.579]                           grepl <- base::grepl
[08:27:53.579]                           restarts <- computeRestarts(cond)
[08:27:53.579]                           for (restart in restarts) {
[08:27:53.579]                             name <- restart$name
[08:27:53.579]                             if (is.null(name)) 
[08:27:53.579]                               next
[08:27:53.579]                             if (!grepl(pattern, name)) 
[08:27:53.579]                               next
[08:27:53.579]                             invokeRestart(restart)
[08:27:53.579]                             muffled <- TRUE
[08:27:53.579]                             break
[08:27:53.579]                           }
[08:27:53.579]                         }
[08:27:53.579]                       }
[08:27:53.579]                       invisible(muffled)
[08:27:53.579]                     }
[08:27:53.579]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.579]                   }
[08:27:53.579]                 }
[08:27:53.579]                 else {
[08:27:53.579]                   if (TRUE) {
[08:27:53.579]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.579]                     {
[08:27:53.579]                       inherits <- base::inherits
[08:27:53.579]                       invokeRestart <- base::invokeRestart
[08:27:53.579]                       is.null <- base::is.null
[08:27:53.579]                       muffled <- FALSE
[08:27:53.579]                       if (inherits(cond, "message")) {
[08:27:53.579]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.579]                         if (muffled) 
[08:27:53.579]                           invokeRestart("muffleMessage")
[08:27:53.579]                       }
[08:27:53.579]                       else if (inherits(cond, "warning")) {
[08:27:53.579]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.579]                         if (muffled) 
[08:27:53.579]                           invokeRestart("muffleWarning")
[08:27:53.579]                       }
[08:27:53.579]                       else if (inherits(cond, "condition")) {
[08:27:53.579]                         if (!is.null(pattern)) {
[08:27:53.579]                           computeRestarts <- base::computeRestarts
[08:27:53.579]                           grepl <- base::grepl
[08:27:53.579]                           restarts <- computeRestarts(cond)
[08:27:53.579]                           for (restart in restarts) {
[08:27:53.579]                             name <- restart$name
[08:27:53.579]                             if (is.null(name)) 
[08:27:53.579]                               next
[08:27:53.579]                             if (!grepl(pattern, name)) 
[08:27:53.579]                               next
[08:27:53.579]                             invokeRestart(restart)
[08:27:53.579]                             muffled <- TRUE
[08:27:53.579]                             break
[08:27:53.579]                           }
[08:27:53.579]                         }
[08:27:53.579]                       }
[08:27:53.579]                       invisible(muffled)
[08:27:53.579]                     }
[08:27:53.579]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.579]                   }
[08:27:53.579]                 }
[08:27:53.579]             }
[08:27:53.579]         }))
[08:27:53.579]     }, error = function(ex) {
[08:27:53.579]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.579]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.579]                 ...future.rng), started = ...future.startTime, 
[08:27:53.579]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.579]             version = "1.8"), class = "FutureResult")
[08:27:53.579]     }, finally = {
[08:27:53.579]         if (!identical(...future.workdir, getwd())) 
[08:27:53.579]             setwd(...future.workdir)
[08:27:53.579]         {
[08:27:53.579]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.579]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.579]             }
[08:27:53.579]             base::options(...future.oldOptions)
[08:27:53.579]             if (.Platform$OS.type == "windows") {
[08:27:53.579]                 old_names <- names(...future.oldEnvVars)
[08:27:53.579]                 envs <- base::Sys.getenv()
[08:27:53.579]                 names <- names(envs)
[08:27:53.579]                 common <- intersect(names, old_names)
[08:27:53.579]                 added <- setdiff(names, old_names)
[08:27:53.579]                 removed <- setdiff(old_names, names)
[08:27:53.579]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.579]                   envs[common]]
[08:27:53.579]                 NAMES <- toupper(changed)
[08:27:53.579]                 args <- list()
[08:27:53.579]                 for (kk in seq_along(NAMES)) {
[08:27:53.579]                   name <- changed[[kk]]
[08:27:53.579]                   NAME <- NAMES[[kk]]
[08:27:53.579]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.579]                     next
[08:27:53.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.579]                 }
[08:27:53.579]                 NAMES <- toupper(added)
[08:27:53.579]                 for (kk in seq_along(NAMES)) {
[08:27:53.579]                   name <- added[[kk]]
[08:27:53.579]                   NAME <- NAMES[[kk]]
[08:27:53.579]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.579]                     next
[08:27:53.579]                   args[[name]] <- ""
[08:27:53.579]                 }
[08:27:53.579]                 NAMES <- toupper(removed)
[08:27:53.579]                 for (kk in seq_along(NAMES)) {
[08:27:53.579]                   name <- removed[[kk]]
[08:27:53.579]                   NAME <- NAMES[[kk]]
[08:27:53.579]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.579]                     next
[08:27:53.579]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.579]                 }
[08:27:53.579]                 if (length(args) > 0) 
[08:27:53.579]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.579]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.579]             }
[08:27:53.579]             else {
[08:27:53.579]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.579]             }
[08:27:53.579]             {
[08:27:53.579]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.579]                   0L) {
[08:27:53.579]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.579]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.579]                   base::options(opts)
[08:27:53.579]                 }
[08:27:53.579]                 {
[08:27:53.579]                   {
[08:27:53.579]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.579]                     NULL
[08:27:53.579]                   }
[08:27:53.579]                   options(future.plan = NULL)
[08:27:53.579]                   if (is.na(NA_character_)) 
[08:27:53.579]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.579]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.579]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.579]                     .init = FALSE)
[08:27:53.579]                 }
[08:27:53.579]             }
[08:27:53.579]         }
[08:27:53.579]     })
[08:27:53.579]     if (TRUE) {
[08:27:53.579]         base::sink(type = "output", split = FALSE)
[08:27:53.579]         if (TRUE) {
[08:27:53.579]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.579]         }
[08:27:53.579]         else {
[08:27:53.579]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.579]         }
[08:27:53.579]         base::close(...future.stdout)
[08:27:53.579]         ...future.stdout <- NULL
[08:27:53.579]     }
[08:27:53.579]     ...future.result$conditions <- ...future.conditions
[08:27:53.579]     ...future.result$finished <- base::Sys.time()
[08:27:53.579]     ...future.result
[08:27:53.579] }
[08:27:53.583] MultisessionFuture started
[08:27:53.583] - Launch lazy future ... done
[08:27:53.583] run() for ‘MultisessionFuture’ ... done
[08:27:53.583] getGlobalsAndPackages() ...
[08:27:53.583] Searching for globals...
[08:27:53.584] - globals found: [1] ‘{’
[08:27:53.584] Searching for globals ... DONE
[08:27:53.584] Resolving globals: FALSE
[08:27:53.585] 
[08:27:53.585] 
[08:27:53.585] getGlobalsAndPackages() ... DONE
[08:27:53.585] run() for ‘Future’ ...
[08:27:53.585] - state: ‘created’
[08:27:53.585] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.599] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.600] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.600]   - Field: ‘node’
[08:27:53.600]   - Field: ‘label’
[08:27:53.600]   - Field: ‘local’
[08:27:53.600]   - Field: ‘owner’
[08:27:53.600]   - Field: ‘envir’
[08:27:53.600]   - Field: ‘workers’
[08:27:53.601]   - Field: ‘packages’
[08:27:53.601]   - Field: ‘gc’
[08:27:53.601]   - Field: ‘conditions’
[08:27:53.601]   - Field: ‘persistent’
[08:27:53.601]   - Field: ‘expr’
[08:27:53.601]   - Field: ‘uuid’
[08:27:53.602]   - Field: ‘seed’
[08:27:53.602]   - Field: ‘version’
[08:27:53.602]   - Field: ‘result’
[08:27:53.602]   - Field: ‘asynchronous’
[08:27:53.602]   - Field: ‘calls’
[08:27:53.602]   - Field: ‘globals’
[08:27:53.602]   - Field: ‘stdout’
[08:27:53.603]   - Field: ‘earlySignal’
[08:27:53.603]   - Field: ‘lazy’
[08:27:53.603]   - Field: ‘state’
[08:27:53.603] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.603] - Launch lazy future ...
[08:27:53.604] Packages needed by the future expression (n = 0): <none>
[08:27:53.604] Packages needed by future strategies (n = 0): <none>
[08:27:53.604] {
[08:27:53.604]     {
[08:27:53.604]         {
[08:27:53.604]             ...future.startTime <- base::Sys.time()
[08:27:53.604]             {
[08:27:53.604]                 {
[08:27:53.604]                   {
[08:27:53.604]                     {
[08:27:53.604]                       base::local({
[08:27:53.604]                         has_future <- base::requireNamespace("future", 
[08:27:53.604]                           quietly = TRUE)
[08:27:53.604]                         if (has_future) {
[08:27:53.604]                           ns <- base::getNamespace("future")
[08:27:53.604]                           version <- ns[[".package"]][["version"]]
[08:27:53.604]                           if (is.null(version)) 
[08:27:53.604]                             version <- utils::packageVersion("future")
[08:27:53.604]                         }
[08:27:53.604]                         else {
[08:27:53.604]                           version <- NULL
[08:27:53.604]                         }
[08:27:53.604]                         if (!has_future || version < "1.8.0") {
[08:27:53.604]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.604]                             "", base::R.version$version.string), 
[08:27:53.604]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.604]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.604]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.604]                               "release", "version")], collapse = " "), 
[08:27:53.604]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.604]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.604]                             info)
[08:27:53.604]                           info <- base::paste(info, collapse = "; ")
[08:27:53.604]                           if (!has_future) {
[08:27:53.604]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.604]                               info)
[08:27:53.604]                           }
[08:27:53.604]                           else {
[08:27:53.604]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.604]                               info, version)
[08:27:53.604]                           }
[08:27:53.604]                           base::stop(msg)
[08:27:53.604]                         }
[08:27:53.604]                       })
[08:27:53.604]                     }
[08:27:53.604]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.604]                     base::options(mc.cores = 1L)
[08:27:53.604]                   }
[08:27:53.604]                   ...future.strategy.old <- future::plan("list")
[08:27:53.604]                   options(future.plan = NULL)
[08:27:53.604]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.604]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.604]                 }
[08:27:53.604]                 ...future.workdir <- getwd()
[08:27:53.604]             }
[08:27:53.604]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.604]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.604]         }
[08:27:53.604]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.604]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.604]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.604]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.604]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.604]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.604]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.604]             base::names(...future.oldOptions))
[08:27:53.604]     }
[08:27:53.604]     if (FALSE) {
[08:27:53.604]     }
[08:27:53.604]     else {
[08:27:53.604]         if (TRUE) {
[08:27:53.604]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.604]                 open = "w")
[08:27:53.604]         }
[08:27:53.604]         else {
[08:27:53.604]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.604]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.604]         }
[08:27:53.604]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.604]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.604]             base::sink(type = "output", split = FALSE)
[08:27:53.604]             base::close(...future.stdout)
[08:27:53.604]         }, add = TRUE)
[08:27:53.604]     }
[08:27:53.604]     ...future.frame <- base::sys.nframe()
[08:27:53.604]     ...future.conditions <- base::list()
[08:27:53.604]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.604]     if (FALSE) {
[08:27:53.604]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.604]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.604]     }
[08:27:53.604]     ...future.result <- base::tryCatch({
[08:27:53.604]         base::withCallingHandlers({
[08:27:53.604]             ...future.value <- base::withVisible(base::local({
[08:27:53.604]                 ...future.makeSendCondition <- base::local({
[08:27:53.604]                   sendCondition <- NULL
[08:27:53.604]                   function(frame = 1L) {
[08:27:53.604]                     if (is.function(sendCondition)) 
[08:27:53.604]                       return(sendCondition)
[08:27:53.604]                     ns <- getNamespace("parallel")
[08:27:53.604]                     if (exists("sendData", mode = "function", 
[08:27:53.604]                       envir = ns)) {
[08:27:53.604]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.604]                         envir = ns)
[08:27:53.604]                       envir <- sys.frame(frame)
[08:27:53.604]                       master <- NULL
[08:27:53.604]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.604]                         !identical(envir, emptyenv())) {
[08:27:53.604]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.604]                           inherits = FALSE)) {
[08:27:53.604]                           master <- get("master", mode = "list", 
[08:27:53.604]                             envir = envir, inherits = FALSE)
[08:27:53.604]                           if (inherits(master, c("SOCKnode", 
[08:27:53.604]                             "SOCK0node"))) {
[08:27:53.604]                             sendCondition <<- function(cond) {
[08:27:53.604]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.604]                                 success = TRUE)
[08:27:53.604]                               parallel_sendData(master, data)
[08:27:53.604]                             }
[08:27:53.604]                             return(sendCondition)
[08:27:53.604]                           }
[08:27:53.604]                         }
[08:27:53.604]                         frame <- frame + 1L
[08:27:53.604]                         envir <- sys.frame(frame)
[08:27:53.604]                       }
[08:27:53.604]                     }
[08:27:53.604]                     sendCondition <<- function(cond) NULL
[08:27:53.604]                   }
[08:27:53.604]                 })
[08:27:53.604]                 withCallingHandlers({
[08:27:53.604]                   {
[08:27:53.604]                     4
[08:27:53.604]                   }
[08:27:53.604]                 }, immediateCondition = function(cond) {
[08:27:53.604]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.604]                   sendCondition(cond)
[08:27:53.604]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.604]                   {
[08:27:53.604]                     inherits <- base::inherits
[08:27:53.604]                     invokeRestart <- base::invokeRestart
[08:27:53.604]                     is.null <- base::is.null
[08:27:53.604]                     muffled <- FALSE
[08:27:53.604]                     if (inherits(cond, "message")) {
[08:27:53.604]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.604]                       if (muffled) 
[08:27:53.604]                         invokeRestart("muffleMessage")
[08:27:53.604]                     }
[08:27:53.604]                     else if (inherits(cond, "warning")) {
[08:27:53.604]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.604]                       if (muffled) 
[08:27:53.604]                         invokeRestart("muffleWarning")
[08:27:53.604]                     }
[08:27:53.604]                     else if (inherits(cond, "condition")) {
[08:27:53.604]                       if (!is.null(pattern)) {
[08:27:53.604]                         computeRestarts <- base::computeRestarts
[08:27:53.604]                         grepl <- base::grepl
[08:27:53.604]                         restarts <- computeRestarts(cond)
[08:27:53.604]                         for (restart in restarts) {
[08:27:53.604]                           name <- restart$name
[08:27:53.604]                           if (is.null(name)) 
[08:27:53.604]                             next
[08:27:53.604]                           if (!grepl(pattern, name)) 
[08:27:53.604]                             next
[08:27:53.604]                           invokeRestart(restart)
[08:27:53.604]                           muffled <- TRUE
[08:27:53.604]                           break
[08:27:53.604]                         }
[08:27:53.604]                       }
[08:27:53.604]                     }
[08:27:53.604]                     invisible(muffled)
[08:27:53.604]                   }
[08:27:53.604]                   muffleCondition(cond)
[08:27:53.604]                 })
[08:27:53.604]             }))
[08:27:53.604]             future::FutureResult(value = ...future.value$value, 
[08:27:53.604]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.604]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.604]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.604]                     ...future.globalenv.names))
[08:27:53.604]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.604]         }, condition = base::local({
[08:27:53.604]             c <- base::c
[08:27:53.604]             inherits <- base::inherits
[08:27:53.604]             invokeRestart <- base::invokeRestart
[08:27:53.604]             length <- base::length
[08:27:53.604]             list <- base::list
[08:27:53.604]             seq.int <- base::seq.int
[08:27:53.604]             signalCondition <- base::signalCondition
[08:27:53.604]             sys.calls <- base::sys.calls
[08:27:53.604]             `[[` <- base::`[[`
[08:27:53.604]             `+` <- base::`+`
[08:27:53.604]             `<<-` <- base::`<<-`
[08:27:53.604]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.604]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.604]                   3L)]
[08:27:53.604]             }
[08:27:53.604]             function(cond) {
[08:27:53.604]                 is_error <- inherits(cond, "error")
[08:27:53.604]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.604]                   NULL)
[08:27:53.604]                 if (is_error) {
[08:27:53.604]                   sessionInformation <- function() {
[08:27:53.604]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.604]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.604]                       search = base::search(), system = base::Sys.info())
[08:27:53.604]                   }
[08:27:53.604]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.604]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.604]                     cond$call), session = sessionInformation(), 
[08:27:53.604]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.604]                   signalCondition(cond)
[08:27:53.604]                 }
[08:27:53.604]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.604]                 "immediateCondition"))) {
[08:27:53.604]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.604]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.604]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.604]                   if (TRUE && !signal) {
[08:27:53.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.604]                     {
[08:27:53.604]                       inherits <- base::inherits
[08:27:53.604]                       invokeRestart <- base::invokeRestart
[08:27:53.604]                       is.null <- base::is.null
[08:27:53.604]                       muffled <- FALSE
[08:27:53.604]                       if (inherits(cond, "message")) {
[08:27:53.604]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.604]                         if (muffled) 
[08:27:53.604]                           invokeRestart("muffleMessage")
[08:27:53.604]                       }
[08:27:53.604]                       else if (inherits(cond, "warning")) {
[08:27:53.604]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.604]                         if (muffled) 
[08:27:53.604]                           invokeRestart("muffleWarning")
[08:27:53.604]                       }
[08:27:53.604]                       else if (inherits(cond, "condition")) {
[08:27:53.604]                         if (!is.null(pattern)) {
[08:27:53.604]                           computeRestarts <- base::computeRestarts
[08:27:53.604]                           grepl <- base::grepl
[08:27:53.604]                           restarts <- computeRestarts(cond)
[08:27:53.604]                           for (restart in restarts) {
[08:27:53.604]                             name <- restart$name
[08:27:53.604]                             if (is.null(name)) 
[08:27:53.604]                               next
[08:27:53.604]                             if (!grepl(pattern, name)) 
[08:27:53.604]                               next
[08:27:53.604]                             invokeRestart(restart)
[08:27:53.604]                             muffled <- TRUE
[08:27:53.604]                             break
[08:27:53.604]                           }
[08:27:53.604]                         }
[08:27:53.604]                       }
[08:27:53.604]                       invisible(muffled)
[08:27:53.604]                     }
[08:27:53.604]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.604]                   }
[08:27:53.604]                 }
[08:27:53.604]                 else {
[08:27:53.604]                   if (TRUE) {
[08:27:53.604]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.604]                     {
[08:27:53.604]                       inherits <- base::inherits
[08:27:53.604]                       invokeRestart <- base::invokeRestart
[08:27:53.604]                       is.null <- base::is.null
[08:27:53.604]                       muffled <- FALSE
[08:27:53.604]                       if (inherits(cond, "message")) {
[08:27:53.604]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.604]                         if (muffled) 
[08:27:53.604]                           invokeRestart("muffleMessage")
[08:27:53.604]                       }
[08:27:53.604]                       else if (inherits(cond, "warning")) {
[08:27:53.604]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.604]                         if (muffled) 
[08:27:53.604]                           invokeRestart("muffleWarning")
[08:27:53.604]                       }
[08:27:53.604]                       else if (inherits(cond, "condition")) {
[08:27:53.604]                         if (!is.null(pattern)) {
[08:27:53.604]                           computeRestarts <- base::computeRestarts
[08:27:53.604]                           grepl <- base::grepl
[08:27:53.604]                           restarts <- computeRestarts(cond)
[08:27:53.604]                           for (restart in restarts) {
[08:27:53.604]                             name <- restart$name
[08:27:53.604]                             if (is.null(name)) 
[08:27:53.604]                               next
[08:27:53.604]                             if (!grepl(pattern, name)) 
[08:27:53.604]                               next
[08:27:53.604]                             invokeRestart(restart)
[08:27:53.604]                             muffled <- TRUE
[08:27:53.604]                             break
[08:27:53.604]                           }
[08:27:53.604]                         }
[08:27:53.604]                       }
[08:27:53.604]                       invisible(muffled)
[08:27:53.604]                     }
[08:27:53.604]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.604]                   }
[08:27:53.604]                 }
[08:27:53.604]             }
[08:27:53.604]         }))
[08:27:53.604]     }, error = function(ex) {
[08:27:53.604]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.604]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.604]                 ...future.rng), started = ...future.startTime, 
[08:27:53.604]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.604]             version = "1.8"), class = "FutureResult")
[08:27:53.604]     }, finally = {
[08:27:53.604]         if (!identical(...future.workdir, getwd())) 
[08:27:53.604]             setwd(...future.workdir)
[08:27:53.604]         {
[08:27:53.604]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.604]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.604]             }
[08:27:53.604]             base::options(...future.oldOptions)
[08:27:53.604]             if (.Platform$OS.type == "windows") {
[08:27:53.604]                 old_names <- names(...future.oldEnvVars)
[08:27:53.604]                 envs <- base::Sys.getenv()
[08:27:53.604]                 names <- names(envs)
[08:27:53.604]                 common <- intersect(names, old_names)
[08:27:53.604]                 added <- setdiff(names, old_names)
[08:27:53.604]                 removed <- setdiff(old_names, names)
[08:27:53.604]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.604]                   envs[common]]
[08:27:53.604]                 NAMES <- toupper(changed)
[08:27:53.604]                 args <- list()
[08:27:53.604]                 for (kk in seq_along(NAMES)) {
[08:27:53.604]                   name <- changed[[kk]]
[08:27:53.604]                   NAME <- NAMES[[kk]]
[08:27:53.604]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.604]                     next
[08:27:53.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.604]                 }
[08:27:53.604]                 NAMES <- toupper(added)
[08:27:53.604]                 for (kk in seq_along(NAMES)) {
[08:27:53.604]                   name <- added[[kk]]
[08:27:53.604]                   NAME <- NAMES[[kk]]
[08:27:53.604]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.604]                     next
[08:27:53.604]                   args[[name]] <- ""
[08:27:53.604]                 }
[08:27:53.604]                 NAMES <- toupper(removed)
[08:27:53.604]                 for (kk in seq_along(NAMES)) {
[08:27:53.604]                   name <- removed[[kk]]
[08:27:53.604]                   NAME <- NAMES[[kk]]
[08:27:53.604]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.604]                     next
[08:27:53.604]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.604]                 }
[08:27:53.604]                 if (length(args) > 0) 
[08:27:53.604]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.604]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.604]             }
[08:27:53.604]             else {
[08:27:53.604]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.604]             }
[08:27:53.604]             {
[08:27:53.604]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.604]                   0L) {
[08:27:53.604]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.604]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.604]                   base::options(opts)
[08:27:53.604]                 }
[08:27:53.604]                 {
[08:27:53.604]                   {
[08:27:53.604]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.604]                     NULL
[08:27:53.604]                   }
[08:27:53.604]                   options(future.plan = NULL)
[08:27:53.604]                   if (is.na(NA_character_)) 
[08:27:53.604]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.604]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.604]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.604]                     .init = FALSE)
[08:27:53.604]                 }
[08:27:53.604]             }
[08:27:53.604]         }
[08:27:53.604]     })
[08:27:53.604]     if (TRUE) {
[08:27:53.604]         base::sink(type = "output", split = FALSE)
[08:27:53.604]         if (TRUE) {
[08:27:53.604]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.604]         }
[08:27:53.604]         else {
[08:27:53.604]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.604]         }
[08:27:53.604]         base::close(...future.stdout)
[08:27:53.604]         ...future.stdout <- NULL
[08:27:53.604]     }
[08:27:53.604]     ...future.result$conditions <- ...future.conditions
[08:27:53.604]     ...future.result$finished <- base::Sys.time()
[08:27:53.604]     ...future.result
[08:27:53.604] }
[08:27:53.606] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:53.617] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.617] - Validating connection of MultisessionFuture
[08:27:53.618] - received message: FutureResult
[08:27:53.618] - Received FutureResult
[08:27:53.618] - Erased future from FutureRegistry
[08:27:53.618] result() for ClusterFuture ...
[08:27:53.618] - result already collected: FutureResult
[08:27:53.618] result() for ClusterFuture ... done
[08:27:53.618] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.618] result() for ClusterFuture ...
[08:27:53.618] - result already collected: FutureResult
[08:27:53.618] result() for ClusterFuture ... done
[08:27:53.619] result() for ClusterFuture ...
[08:27:53.619] - result already collected: FutureResult
[08:27:53.619] result() for ClusterFuture ... done
[08:27:53.620] MultisessionFuture started
[08:27:53.620] - Launch lazy future ... done
[08:27:53.620] run() for ‘MultisessionFuture’ ... done
<environment: 0x55d862378b20> 
<environment: 0x55d8630b1f50> 
[08:27:53.625] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.625] - Validating connection of MultisessionFuture
[08:27:53.626] - received message: FutureResult
[08:27:53.626] - Received FutureResult
[08:27:53.626] - Erased future from FutureRegistry
[08:27:53.626] result() for ClusterFuture ...
[08:27:53.626] - result already collected: FutureResult
[08:27:53.626] result() for ClusterFuture ... done
[08:27:53.626] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:53.638] resolve() on environment ...
[08:27:53.638]  recursive: 0
[08:27:53.639]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:53.639] signalConditionsASAP(numeric, pos=1) ...
[08:27:53.639] - nx: 4
[08:27:53.639] - relay: TRUE
[08:27:53.639] - stdout: TRUE
[08:27:53.639] - signal: TRUE
[08:27:53.642] - resignal: FALSE
[08:27:53.642] - force: TRUE
[08:27:53.642] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.642] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.642]  - until=2
[08:27:53.642]  - relaying element #2
[08:27:53.642] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.642] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.643] signalConditionsASAP(NULL, pos=1) ... done
[08:27:53.643]  length: 3 (resolved future 1)
[08:27:53.643] Future #2
[08:27:53.643] result() for ClusterFuture ...
[08:27:53.643] - result already collected: FutureResult
[08:27:53.643] result() for ClusterFuture ... done
[08:27:53.643] result() for ClusterFuture ...
[08:27:53.643] - result already collected: FutureResult
[08:27:53.643] result() for ClusterFuture ... done
[08:27:53.643] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:53.644] - nx: 4
[08:27:53.644] - relay: TRUE
[08:27:53.644] - stdout: TRUE
[08:27:53.644] - signal: TRUE
[08:27:53.644] - resignal: FALSE
[08:27:53.644] - force: TRUE
[08:27:53.644] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.644] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.644]  - until=2
[08:27:53.644]  - relaying element #2
[08:27:53.644] result() for ClusterFuture ...
[08:27:53.644] - result already collected: FutureResult
[08:27:53.644] result() for ClusterFuture ... done
[08:27:53.645] result() for ClusterFuture ...
[08:27:53.645] - result already collected: FutureResult
[08:27:53.645] result() for ClusterFuture ... done
[08:27:53.645] result() for ClusterFuture ...
[08:27:53.645] - result already collected: FutureResult
[08:27:53.645] result() for ClusterFuture ... done
[08:27:53.645] result() for ClusterFuture ...
[08:27:53.645] - result already collected: FutureResult
[08:27:53.645] result() for ClusterFuture ... done
[08:27:53.645] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.645] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.645] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:53.646]  length: 2 (resolved future 2)
[08:27:53.646] Future #3
[08:27:53.646] result() for ClusterFuture ...
[08:27:53.646] - result already collected: FutureResult
[08:27:53.646] result() for ClusterFuture ... done
[08:27:53.646] result() for ClusterFuture ...
[08:27:53.646] - result already collected: FutureResult
[08:27:53.646] result() for ClusterFuture ... done
[08:27:53.646] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:53.646] - nx: 4
[08:27:53.646] - relay: TRUE
[08:27:53.646] - stdout: TRUE
[08:27:53.647] - signal: TRUE
[08:27:53.647] - resignal: FALSE
[08:27:53.647] - force: TRUE
[08:27:53.647] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.647] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.647]  - until=3
[08:27:53.647]  - relaying element #3
[08:27:53.647] result() for ClusterFuture ...
[08:27:53.647] - result already collected: FutureResult
[08:27:53.647] result() for ClusterFuture ... done
[08:27:53.647] result() for ClusterFuture ...
[08:27:53.647] - result already collected: FutureResult
[08:27:53.647] result() for ClusterFuture ... done
[08:27:53.648] result() for ClusterFuture ...
[08:27:53.648] - result already collected: FutureResult
[08:27:53.648] result() for ClusterFuture ... done
[08:27:53.648] result() for ClusterFuture ...
[08:27:53.648] - result already collected: FutureResult
[08:27:53.648] result() for ClusterFuture ... done
[08:27:53.648] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.648] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.648] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:53.648]  length: 1 (resolved future 3)
[08:27:53.670] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.670] - Validating connection of MultisessionFuture
[08:27:53.670] - received message: FutureResult
[08:27:53.670] - Received FutureResult
[08:27:53.670] - Erased future from FutureRegistry
[08:27:53.670] result() for ClusterFuture ...
[08:27:53.670] - result already collected: FutureResult
[08:27:53.670] result() for ClusterFuture ... done
[08:27:53.671] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.671] Future #4
[08:27:53.671] result() for ClusterFuture ...
[08:27:53.671] - result already collected: FutureResult
[08:27:53.671] result() for ClusterFuture ... done
[08:27:53.671] result() for ClusterFuture ...
[08:27:53.671] - result already collected: FutureResult
[08:27:53.671] result() for ClusterFuture ... done
[08:27:53.671] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:53.671] - nx: 4
[08:27:53.671] - relay: TRUE
[08:27:53.671] - stdout: TRUE
[08:27:53.672] - signal: TRUE
[08:27:53.672] - resignal: FALSE
[08:27:53.672] - force: TRUE
[08:27:53.672] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.672] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.672]  - until=4
[08:27:53.672]  - relaying element #4
[08:27:53.672] result() for ClusterFuture ...
[08:27:53.672] - result already collected: FutureResult
[08:27:53.672] result() for ClusterFuture ... done
[08:27:53.672] result() for ClusterFuture ...
[08:27:53.672] - result already collected: FutureResult
[08:27:53.673] result() for ClusterFuture ... done
[08:27:53.673] result() for ClusterFuture ...
[08:27:53.673] - result already collected: FutureResult
[08:27:53.673] result() for ClusterFuture ... done
[08:27:53.673] result() for ClusterFuture ...
[08:27:53.673] - result already collected: FutureResult
[08:27:53.673] result() for ClusterFuture ... done
[08:27:53.673] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.673] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.673] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:53.673]  length: 0 (resolved future 4)
[08:27:53.673] Relaying remaining futures
[08:27:53.674] signalConditionsASAP(NULL, pos=0) ...
[08:27:53.674] - nx: 4
[08:27:53.674] - relay: TRUE
[08:27:53.674] - stdout: TRUE
[08:27:53.674] - signal: TRUE
[08:27:53.674] - resignal: FALSE
[08:27:53.674] - force: TRUE
[08:27:53.674] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.674] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:53.674] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.674] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.674] signalConditionsASAP(NULL, pos=0) ... done
[08:27:53.674] resolve() on environment ... DONE
[08:27:53.675] result() for ClusterFuture ...
[08:27:53.675] - result already collected: FutureResult
[08:27:53.675] result() for ClusterFuture ... done
[08:27:53.675] result() for ClusterFuture ...
[08:27:53.675] - result already collected: FutureResult
[08:27:53.675] result() for ClusterFuture ... done
[08:27:53.675] result() for ClusterFuture ...
[08:27:53.675] - result already collected: FutureResult
[08:27:53.675] result() for ClusterFuture ... done
[08:27:53.675] result() for ClusterFuture ...
[08:27:53.675] - result already collected: FutureResult
[08:27:53.675] result() for ClusterFuture ... done
[08:27:53.676] result() for ClusterFuture ...
[08:27:53.676] - result already collected: FutureResult
[08:27:53.676] result() for ClusterFuture ... done
[08:27:53.676] result() for ClusterFuture ...
[08:27:53.676] - result already collected: FutureResult
[08:27:53.676] result() for ClusterFuture ... done
<environment: 0x55d8632b4728> 
Dimensions: c(2, 3, 1)
[08:27:53.676] getGlobalsAndPackages() ...
[08:27:53.676] Searching for globals...
[08:27:53.677] 
[08:27:53.677] Searching for globals ... DONE
[08:27:53.677] - globals: [0] <none>
[08:27:53.677] getGlobalsAndPackages() ... DONE
[08:27:53.677] run() for ‘Future’ ...
[08:27:53.677] - state: ‘created’
[08:27:53.678] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.691] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.691]   - Field: ‘node’
[08:27:53.692]   - Field: ‘label’
[08:27:53.692]   - Field: ‘local’
[08:27:53.692]   - Field: ‘owner’
[08:27:53.692]   - Field: ‘envir’
[08:27:53.692]   - Field: ‘workers’
[08:27:53.692]   - Field: ‘packages’
[08:27:53.692]   - Field: ‘gc’
[08:27:53.692]   - Field: ‘conditions’
[08:27:53.692]   - Field: ‘persistent’
[08:27:53.692]   - Field: ‘expr’
[08:27:53.692]   - Field: ‘uuid’
[08:27:53.693]   - Field: ‘seed’
[08:27:53.693]   - Field: ‘version’
[08:27:53.693]   - Field: ‘result’
[08:27:53.693]   - Field: ‘asynchronous’
[08:27:53.693]   - Field: ‘calls’
[08:27:53.693]   - Field: ‘globals’
[08:27:53.693]   - Field: ‘stdout’
[08:27:53.693]   - Field: ‘earlySignal’
[08:27:53.693]   - Field: ‘lazy’
[08:27:53.693]   - Field: ‘state’
[08:27:53.693] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.693] - Launch lazy future ...
[08:27:53.694] Packages needed by the future expression (n = 0): <none>
[08:27:53.694] Packages needed by future strategies (n = 0): <none>
[08:27:53.694] {
[08:27:53.694]     {
[08:27:53.694]         {
[08:27:53.694]             ...future.startTime <- base::Sys.time()
[08:27:53.694]             {
[08:27:53.694]                 {
[08:27:53.694]                   {
[08:27:53.694]                     {
[08:27:53.694]                       base::local({
[08:27:53.694]                         has_future <- base::requireNamespace("future", 
[08:27:53.694]                           quietly = TRUE)
[08:27:53.694]                         if (has_future) {
[08:27:53.694]                           ns <- base::getNamespace("future")
[08:27:53.694]                           version <- ns[[".package"]][["version"]]
[08:27:53.694]                           if (is.null(version)) 
[08:27:53.694]                             version <- utils::packageVersion("future")
[08:27:53.694]                         }
[08:27:53.694]                         else {
[08:27:53.694]                           version <- NULL
[08:27:53.694]                         }
[08:27:53.694]                         if (!has_future || version < "1.8.0") {
[08:27:53.694]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.694]                             "", base::R.version$version.string), 
[08:27:53.694]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.694]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.694]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.694]                               "release", "version")], collapse = " "), 
[08:27:53.694]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.694]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.694]                             info)
[08:27:53.694]                           info <- base::paste(info, collapse = "; ")
[08:27:53.694]                           if (!has_future) {
[08:27:53.694]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.694]                               info)
[08:27:53.694]                           }
[08:27:53.694]                           else {
[08:27:53.694]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.694]                               info, version)
[08:27:53.694]                           }
[08:27:53.694]                           base::stop(msg)
[08:27:53.694]                         }
[08:27:53.694]                       })
[08:27:53.694]                     }
[08:27:53.694]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.694]                     base::options(mc.cores = 1L)
[08:27:53.694]                   }
[08:27:53.694]                   ...future.strategy.old <- future::plan("list")
[08:27:53.694]                   options(future.plan = NULL)
[08:27:53.694]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.694]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.694]                 }
[08:27:53.694]                 ...future.workdir <- getwd()
[08:27:53.694]             }
[08:27:53.694]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.694]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.694]         }
[08:27:53.694]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.694]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.694]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.694]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.694]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.694]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.694]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.694]             base::names(...future.oldOptions))
[08:27:53.694]     }
[08:27:53.694]     if (FALSE) {
[08:27:53.694]     }
[08:27:53.694]     else {
[08:27:53.694]         if (TRUE) {
[08:27:53.694]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.694]                 open = "w")
[08:27:53.694]         }
[08:27:53.694]         else {
[08:27:53.694]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.694]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.694]         }
[08:27:53.694]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.694]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.694]             base::sink(type = "output", split = FALSE)
[08:27:53.694]             base::close(...future.stdout)
[08:27:53.694]         }, add = TRUE)
[08:27:53.694]     }
[08:27:53.694]     ...future.frame <- base::sys.nframe()
[08:27:53.694]     ...future.conditions <- base::list()
[08:27:53.694]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.694]     if (FALSE) {
[08:27:53.694]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.694]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.694]     }
[08:27:53.694]     ...future.result <- base::tryCatch({
[08:27:53.694]         base::withCallingHandlers({
[08:27:53.694]             ...future.value <- base::withVisible(base::local({
[08:27:53.694]                 ...future.makeSendCondition <- base::local({
[08:27:53.694]                   sendCondition <- NULL
[08:27:53.694]                   function(frame = 1L) {
[08:27:53.694]                     if (is.function(sendCondition)) 
[08:27:53.694]                       return(sendCondition)
[08:27:53.694]                     ns <- getNamespace("parallel")
[08:27:53.694]                     if (exists("sendData", mode = "function", 
[08:27:53.694]                       envir = ns)) {
[08:27:53.694]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.694]                         envir = ns)
[08:27:53.694]                       envir <- sys.frame(frame)
[08:27:53.694]                       master <- NULL
[08:27:53.694]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.694]                         !identical(envir, emptyenv())) {
[08:27:53.694]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.694]                           inherits = FALSE)) {
[08:27:53.694]                           master <- get("master", mode = "list", 
[08:27:53.694]                             envir = envir, inherits = FALSE)
[08:27:53.694]                           if (inherits(master, c("SOCKnode", 
[08:27:53.694]                             "SOCK0node"))) {
[08:27:53.694]                             sendCondition <<- function(cond) {
[08:27:53.694]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.694]                                 success = TRUE)
[08:27:53.694]                               parallel_sendData(master, data)
[08:27:53.694]                             }
[08:27:53.694]                             return(sendCondition)
[08:27:53.694]                           }
[08:27:53.694]                         }
[08:27:53.694]                         frame <- frame + 1L
[08:27:53.694]                         envir <- sys.frame(frame)
[08:27:53.694]                       }
[08:27:53.694]                     }
[08:27:53.694]                     sendCondition <<- function(cond) NULL
[08:27:53.694]                   }
[08:27:53.694]                 })
[08:27:53.694]                 withCallingHandlers({
[08:27:53.694]                   2
[08:27:53.694]                 }, immediateCondition = function(cond) {
[08:27:53.694]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.694]                   sendCondition(cond)
[08:27:53.694]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.694]                   {
[08:27:53.694]                     inherits <- base::inherits
[08:27:53.694]                     invokeRestart <- base::invokeRestart
[08:27:53.694]                     is.null <- base::is.null
[08:27:53.694]                     muffled <- FALSE
[08:27:53.694]                     if (inherits(cond, "message")) {
[08:27:53.694]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.694]                       if (muffled) 
[08:27:53.694]                         invokeRestart("muffleMessage")
[08:27:53.694]                     }
[08:27:53.694]                     else if (inherits(cond, "warning")) {
[08:27:53.694]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.694]                       if (muffled) 
[08:27:53.694]                         invokeRestart("muffleWarning")
[08:27:53.694]                     }
[08:27:53.694]                     else if (inherits(cond, "condition")) {
[08:27:53.694]                       if (!is.null(pattern)) {
[08:27:53.694]                         computeRestarts <- base::computeRestarts
[08:27:53.694]                         grepl <- base::grepl
[08:27:53.694]                         restarts <- computeRestarts(cond)
[08:27:53.694]                         for (restart in restarts) {
[08:27:53.694]                           name <- restart$name
[08:27:53.694]                           if (is.null(name)) 
[08:27:53.694]                             next
[08:27:53.694]                           if (!grepl(pattern, name)) 
[08:27:53.694]                             next
[08:27:53.694]                           invokeRestart(restart)
[08:27:53.694]                           muffled <- TRUE
[08:27:53.694]                           break
[08:27:53.694]                         }
[08:27:53.694]                       }
[08:27:53.694]                     }
[08:27:53.694]                     invisible(muffled)
[08:27:53.694]                   }
[08:27:53.694]                   muffleCondition(cond)
[08:27:53.694]                 })
[08:27:53.694]             }))
[08:27:53.694]             future::FutureResult(value = ...future.value$value, 
[08:27:53.694]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.694]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.694]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.694]                     ...future.globalenv.names))
[08:27:53.694]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.694]         }, condition = base::local({
[08:27:53.694]             c <- base::c
[08:27:53.694]             inherits <- base::inherits
[08:27:53.694]             invokeRestart <- base::invokeRestart
[08:27:53.694]             length <- base::length
[08:27:53.694]             list <- base::list
[08:27:53.694]             seq.int <- base::seq.int
[08:27:53.694]             signalCondition <- base::signalCondition
[08:27:53.694]             sys.calls <- base::sys.calls
[08:27:53.694]             `[[` <- base::`[[`
[08:27:53.694]             `+` <- base::`+`
[08:27:53.694]             `<<-` <- base::`<<-`
[08:27:53.694]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.694]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.694]                   3L)]
[08:27:53.694]             }
[08:27:53.694]             function(cond) {
[08:27:53.694]                 is_error <- inherits(cond, "error")
[08:27:53.694]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.694]                   NULL)
[08:27:53.694]                 if (is_error) {
[08:27:53.694]                   sessionInformation <- function() {
[08:27:53.694]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.694]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.694]                       search = base::search(), system = base::Sys.info())
[08:27:53.694]                   }
[08:27:53.694]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.694]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.694]                     cond$call), session = sessionInformation(), 
[08:27:53.694]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.694]                   signalCondition(cond)
[08:27:53.694]                 }
[08:27:53.694]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.694]                 "immediateCondition"))) {
[08:27:53.694]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.694]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.694]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.694]                   if (TRUE && !signal) {
[08:27:53.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.694]                     {
[08:27:53.694]                       inherits <- base::inherits
[08:27:53.694]                       invokeRestart <- base::invokeRestart
[08:27:53.694]                       is.null <- base::is.null
[08:27:53.694]                       muffled <- FALSE
[08:27:53.694]                       if (inherits(cond, "message")) {
[08:27:53.694]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.694]                         if (muffled) 
[08:27:53.694]                           invokeRestart("muffleMessage")
[08:27:53.694]                       }
[08:27:53.694]                       else if (inherits(cond, "warning")) {
[08:27:53.694]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.694]                         if (muffled) 
[08:27:53.694]                           invokeRestart("muffleWarning")
[08:27:53.694]                       }
[08:27:53.694]                       else if (inherits(cond, "condition")) {
[08:27:53.694]                         if (!is.null(pattern)) {
[08:27:53.694]                           computeRestarts <- base::computeRestarts
[08:27:53.694]                           grepl <- base::grepl
[08:27:53.694]                           restarts <- computeRestarts(cond)
[08:27:53.694]                           for (restart in restarts) {
[08:27:53.694]                             name <- restart$name
[08:27:53.694]                             if (is.null(name)) 
[08:27:53.694]                               next
[08:27:53.694]                             if (!grepl(pattern, name)) 
[08:27:53.694]                               next
[08:27:53.694]                             invokeRestart(restart)
[08:27:53.694]                             muffled <- TRUE
[08:27:53.694]                             break
[08:27:53.694]                           }
[08:27:53.694]                         }
[08:27:53.694]                       }
[08:27:53.694]                       invisible(muffled)
[08:27:53.694]                     }
[08:27:53.694]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.694]                   }
[08:27:53.694]                 }
[08:27:53.694]                 else {
[08:27:53.694]                   if (TRUE) {
[08:27:53.694]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.694]                     {
[08:27:53.694]                       inherits <- base::inherits
[08:27:53.694]                       invokeRestart <- base::invokeRestart
[08:27:53.694]                       is.null <- base::is.null
[08:27:53.694]                       muffled <- FALSE
[08:27:53.694]                       if (inherits(cond, "message")) {
[08:27:53.694]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.694]                         if (muffled) 
[08:27:53.694]                           invokeRestart("muffleMessage")
[08:27:53.694]                       }
[08:27:53.694]                       else if (inherits(cond, "warning")) {
[08:27:53.694]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.694]                         if (muffled) 
[08:27:53.694]                           invokeRestart("muffleWarning")
[08:27:53.694]                       }
[08:27:53.694]                       else if (inherits(cond, "condition")) {
[08:27:53.694]                         if (!is.null(pattern)) {
[08:27:53.694]                           computeRestarts <- base::computeRestarts
[08:27:53.694]                           grepl <- base::grepl
[08:27:53.694]                           restarts <- computeRestarts(cond)
[08:27:53.694]                           for (restart in restarts) {
[08:27:53.694]                             name <- restart$name
[08:27:53.694]                             if (is.null(name)) 
[08:27:53.694]                               next
[08:27:53.694]                             if (!grepl(pattern, name)) 
[08:27:53.694]                               next
[08:27:53.694]                             invokeRestart(restart)
[08:27:53.694]                             muffled <- TRUE
[08:27:53.694]                             break
[08:27:53.694]                           }
[08:27:53.694]                         }
[08:27:53.694]                       }
[08:27:53.694]                       invisible(muffled)
[08:27:53.694]                     }
[08:27:53.694]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.694]                   }
[08:27:53.694]                 }
[08:27:53.694]             }
[08:27:53.694]         }))
[08:27:53.694]     }, error = function(ex) {
[08:27:53.694]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.694]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.694]                 ...future.rng), started = ...future.startTime, 
[08:27:53.694]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.694]             version = "1.8"), class = "FutureResult")
[08:27:53.694]     }, finally = {
[08:27:53.694]         if (!identical(...future.workdir, getwd())) 
[08:27:53.694]             setwd(...future.workdir)
[08:27:53.694]         {
[08:27:53.694]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.694]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.694]             }
[08:27:53.694]             base::options(...future.oldOptions)
[08:27:53.694]             if (.Platform$OS.type == "windows") {
[08:27:53.694]                 old_names <- names(...future.oldEnvVars)
[08:27:53.694]                 envs <- base::Sys.getenv()
[08:27:53.694]                 names <- names(envs)
[08:27:53.694]                 common <- intersect(names, old_names)
[08:27:53.694]                 added <- setdiff(names, old_names)
[08:27:53.694]                 removed <- setdiff(old_names, names)
[08:27:53.694]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.694]                   envs[common]]
[08:27:53.694]                 NAMES <- toupper(changed)
[08:27:53.694]                 args <- list()
[08:27:53.694]                 for (kk in seq_along(NAMES)) {
[08:27:53.694]                   name <- changed[[kk]]
[08:27:53.694]                   NAME <- NAMES[[kk]]
[08:27:53.694]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.694]                     next
[08:27:53.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.694]                 }
[08:27:53.694]                 NAMES <- toupper(added)
[08:27:53.694]                 for (kk in seq_along(NAMES)) {
[08:27:53.694]                   name <- added[[kk]]
[08:27:53.694]                   NAME <- NAMES[[kk]]
[08:27:53.694]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.694]                     next
[08:27:53.694]                   args[[name]] <- ""
[08:27:53.694]                 }
[08:27:53.694]                 NAMES <- toupper(removed)
[08:27:53.694]                 for (kk in seq_along(NAMES)) {
[08:27:53.694]                   name <- removed[[kk]]
[08:27:53.694]                   NAME <- NAMES[[kk]]
[08:27:53.694]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.694]                     next
[08:27:53.694]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.694]                 }
[08:27:53.694]                 if (length(args) > 0) 
[08:27:53.694]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.694]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.694]             }
[08:27:53.694]             else {
[08:27:53.694]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.694]             }
[08:27:53.694]             {
[08:27:53.694]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.694]                   0L) {
[08:27:53.694]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.694]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.694]                   base::options(opts)
[08:27:53.694]                 }
[08:27:53.694]                 {
[08:27:53.694]                   {
[08:27:53.694]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.694]                     NULL
[08:27:53.694]                   }
[08:27:53.694]                   options(future.plan = NULL)
[08:27:53.694]                   if (is.na(NA_character_)) 
[08:27:53.694]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.694]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.694]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.694]                     .init = FALSE)
[08:27:53.694]                 }
[08:27:53.694]             }
[08:27:53.694]         }
[08:27:53.694]     })
[08:27:53.694]     if (TRUE) {
[08:27:53.694]         base::sink(type = "output", split = FALSE)
[08:27:53.694]         if (TRUE) {
[08:27:53.694]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.694]         }
[08:27:53.694]         else {
[08:27:53.694]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.694]         }
[08:27:53.694]         base::close(...future.stdout)
[08:27:53.694]         ...future.stdout <- NULL
[08:27:53.694]     }
[08:27:53.694]     ...future.result$conditions <- ...future.conditions
[08:27:53.694]     ...future.result$finished <- base::Sys.time()
[08:27:53.694]     ...future.result
[08:27:53.694] }
[08:27:53.697] MultisessionFuture started
[08:27:53.698] - Launch lazy future ... done
[08:27:53.698] run() for ‘MultisessionFuture’ ... done
[08:27:53.698] getGlobalsAndPackages() ...
[08:27:53.698] Searching for globals...
[08:27:53.698] 
[08:27:53.698] Searching for globals ... DONE
[08:27:53.698] - globals: [0] <none>
[08:27:53.699] getGlobalsAndPackages() ... DONE
[08:27:53.699] run() for ‘Future’ ...
[08:27:53.699] - state: ‘created’
[08:27:53.699] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.713] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.713] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.713]   - Field: ‘node’
[08:27:53.713]   - Field: ‘label’
[08:27:53.713]   - Field: ‘local’
[08:27:53.713]   - Field: ‘owner’
[08:27:53.714]   - Field: ‘envir’
[08:27:53.714]   - Field: ‘workers’
[08:27:53.714]   - Field: ‘packages’
[08:27:53.714]   - Field: ‘gc’
[08:27:53.714]   - Field: ‘conditions’
[08:27:53.714]   - Field: ‘persistent’
[08:27:53.714]   - Field: ‘expr’
[08:27:53.714]   - Field: ‘uuid’
[08:27:53.714]   - Field: ‘seed’
[08:27:53.714]   - Field: ‘version’
[08:27:53.714]   - Field: ‘result’
[08:27:53.714]   - Field: ‘asynchronous’
[08:27:53.715]   - Field: ‘calls’
[08:27:53.715]   - Field: ‘globals’
[08:27:53.715]   - Field: ‘stdout’
[08:27:53.715]   - Field: ‘earlySignal’
[08:27:53.715]   - Field: ‘lazy’
[08:27:53.715]   - Field: ‘state’
[08:27:53.715] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.715] - Launch lazy future ...
[08:27:53.715] Packages needed by the future expression (n = 0): <none>
[08:27:53.716] Packages needed by future strategies (n = 0): <none>
[08:27:53.716] {
[08:27:53.716]     {
[08:27:53.716]         {
[08:27:53.716]             ...future.startTime <- base::Sys.time()
[08:27:53.716]             {
[08:27:53.716]                 {
[08:27:53.716]                   {
[08:27:53.716]                     {
[08:27:53.716]                       base::local({
[08:27:53.716]                         has_future <- base::requireNamespace("future", 
[08:27:53.716]                           quietly = TRUE)
[08:27:53.716]                         if (has_future) {
[08:27:53.716]                           ns <- base::getNamespace("future")
[08:27:53.716]                           version <- ns[[".package"]][["version"]]
[08:27:53.716]                           if (is.null(version)) 
[08:27:53.716]                             version <- utils::packageVersion("future")
[08:27:53.716]                         }
[08:27:53.716]                         else {
[08:27:53.716]                           version <- NULL
[08:27:53.716]                         }
[08:27:53.716]                         if (!has_future || version < "1.8.0") {
[08:27:53.716]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.716]                             "", base::R.version$version.string), 
[08:27:53.716]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.716]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.716]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.716]                               "release", "version")], collapse = " "), 
[08:27:53.716]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.716]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.716]                             info)
[08:27:53.716]                           info <- base::paste(info, collapse = "; ")
[08:27:53.716]                           if (!has_future) {
[08:27:53.716]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.716]                               info)
[08:27:53.716]                           }
[08:27:53.716]                           else {
[08:27:53.716]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.716]                               info, version)
[08:27:53.716]                           }
[08:27:53.716]                           base::stop(msg)
[08:27:53.716]                         }
[08:27:53.716]                       })
[08:27:53.716]                     }
[08:27:53.716]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.716]                     base::options(mc.cores = 1L)
[08:27:53.716]                   }
[08:27:53.716]                   ...future.strategy.old <- future::plan("list")
[08:27:53.716]                   options(future.plan = NULL)
[08:27:53.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.716]                 }
[08:27:53.716]                 ...future.workdir <- getwd()
[08:27:53.716]             }
[08:27:53.716]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.716]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.716]         }
[08:27:53.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.716]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.716]             base::names(...future.oldOptions))
[08:27:53.716]     }
[08:27:53.716]     if (FALSE) {
[08:27:53.716]     }
[08:27:53.716]     else {
[08:27:53.716]         if (TRUE) {
[08:27:53.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.716]                 open = "w")
[08:27:53.716]         }
[08:27:53.716]         else {
[08:27:53.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.716]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.716]         }
[08:27:53.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.716]             base::sink(type = "output", split = FALSE)
[08:27:53.716]             base::close(...future.stdout)
[08:27:53.716]         }, add = TRUE)
[08:27:53.716]     }
[08:27:53.716]     ...future.frame <- base::sys.nframe()
[08:27:53.716]     ...future.conditions <- base::list()
[08:27:53.716]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.716]     if (FALSE) {
[08:27:53.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.716]     }
[08:27:53.716]     ...future.result <- base::tryCatch({
[08:27:53.716]         base::withCallingHandlers({
[08:27:53.716]             ...future.value <- base::withVisible(base::local({
[08:27:53.716]                 ...future.makeSendCondition <- base::local({
[08:27:53.716]                   sendCondition <- NULL
[08:27:53.716]                   function(frame = 1L) {
[08:27:53.716]                     if (is.function(sendCondition)) 
[08:27:53.716]                       return(sendCondition)
[08:27:53.716]                     ns <- getNamespace("parallel")
[08:27:53.716]                     if (exists("sendData", mode = "function", 
[08:27:53.716]                       envir = ns)) {
[08:27:53.716]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.716]                         envir = ns)
[08:27:53.716]                       envir <- sys.frame(frame)
[08:27:53.716]                       master <- NULL
[08:27:53.716]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.716]                         !identical(envir, emptyenv())) {
[08:27:53.716]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.716]                           inherits = FALSE)) {
[08:27:53.716]                           master <- get("master", mode = "list", 
[08:27:53.716]                             envir = envir, inherits = FALSE)
[08:27:53.716]                           if (inherits(master, c("SOCKnode", 
[08:27:53.716]                             "SOCK0node"))) {
[08:27:53.716]                             sendCondition <<- function(cond) {
[08:27:53.716]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.716]                                 success = TRUE)
[08:27:53.716]                               parallel_sendData(master, data)
[08:27:53.716]                             }
[08:27:53.716]                             return(sendCondition)
[08:27:53.716]                           }
[08:27:53.716]                         }
[08:27:53.716]                         frame <- frame + 1L
[08:27:53.716]                         envir <- sys.frame(frame)
[08:27:53.716]                       }
[08:27:53.716]                     }
[08:27:53.716]                     sendCondition <<- function(cond) NULL
[08:27:53.716]                   }
[08:27:53.716]                 })
[08:27:53.716]                 withCallingHandlers({
[08:27:53.716]                   NULL
[08:27:53.716]                 }, immediateCondition = function(cond) {
[08:27:53.716]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.716]                   sendCondition(cond)
[08:27:53.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.716]                   {
[08:27:53.716]                     inherits <- base::inherits
[08:27:53.716]                     invokeRestart <- base::invokeRestart
[08:27:53.716]                     is.null <- base::is.null
[08:27:53.716]                     muffled <- FALSE
[08:27:53.716]                     if (inherits(cond, "message")) {
[08:27:53.716]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.716]                       if (muffled) 
[08:27:53.716]                         invokeRestart("muffleMessage")
[08:27:53.716]                     }
[08:27:53.716]                     else if (inherits(cond, "warning")) {
[08:27:53.716]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.716]                       if (muffled) 
[08:27:53.716]                         invokeRestart("muffleWarning")
[08:27:53.716]                     }
[08:27:53.716]                     else if (inherits(cond, "condition")) {
[08:27:53.716]                       if (!is.null(pattern)) {
[08:27:53.716]                         computeRestarts <- base::computeRestarts
[08:27:53.716]                         grepl <- base::grepl
[08:27:53.716]                         restarts <- computeRestarts(cond)
[08:27:53.716]                         for (restart in restarts) {
[08:27:53.716]                           name <- restart$name
[08:27:53.716]                           if (is.null(name)) 
[08:27:53.716]                             next
[08:27:53.716]                           if (!grepl(pattern, name)) 
[08:27:53.716]                             next
[08:27:53.716]                           invokeRestart(restart)
[08:27:53.716]                           muffled <- TRUE
[08:27:53.716]                           break
[08:27:53.716]                         }
[08:27:53.716]                       }
[08:27:53.716]                     }
[08:27:53.716]                     invisible(muffled)
[08:27:53.716]                   }
[08:27:53.716]                   muffleCondition(cond)
[08:27:53.716]                 })
[08:27:53.716]             }))
[08:27:53.716]             future::FutureResult(value = ...future.value$value, 
[08:27:53.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.716]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.716]                     ...future.globalenv.names))
[08:27:53.716]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.716]         }, condition = base::local({
[08:27:53.716]             c <- base::c
[08:27:53.716]             inherits <- base::inherits
[08:27:53.716]             invokeRestart <- base::invokeRestart
[08:27:53.716]             length <- base::length
[08:27:53.716]             list <- base::list
[08:27:53.716]             seq.int <- base::seq.int
[08:27:53.716]             signalCondition <- base::signalCondition
[08:27:53.716]             sys.calls <- base::sys.calls
[08:27:53.716]             `[[` <- base::`[[`
[08:27:53.716]             `+` <- base::`+`
[08:27:53.716]             `<<-` <- base::`<<-`
[08:27:53.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.716]                   3L)]
[08:27:53.716]             }
[08:27:53.716]             function(cond) {
[08:27:53.716]                 is_error <- inherits(cond, "error")
[08:27:53.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.716]                   NULL)
[08:27:53.716]                 if (is_error) {
[08:27:53.716]                   sessionInformation <- function() {
[08:27:53.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.716]                       search = base::search(), system = base::Sys.info())
[08:27:53.716]                   }
[08:27:53.716]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.716]                     cond$call), session = sessionInformation(), 
[08:27:53.716]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.716]                   signalCondition(cond)
[08:27:53.716]                 }
[08:27:53.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.716]                 "immediateCondition"))) {
[08:27:53.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.716]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.716]                   if (TRUE && !signal) {
[08:27:53.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.716]                     {
[08:27:53.716]                       inherits <- base::inherits
[08:27:53.716]                       invokeRestart <- base::invokeRestart
[08:27:53.716]                       is.null <- base::is.null
[08:27:53.716]                       muffled <- FALSE
[08:27:53.716]                       if (inherits(cond, "message")) {
[08:27:53.716]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.716]                         if (muffled) 
[08:27:53.716]                           invokeRestart("muffleMessage")
[08:27:53.716]                       }
[08:27:53.716]                       else if (inherits(cond, "warning")) {
[08:27:53.716]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.716]                         if (muffled) 
[08:27:53.716]                           invokeRestart("muffleWarning")
[08:27:53.716]                       }
[08:27:53.716]                       else if (inherits(cond, "condition")) {
[08:27:53.716]                         if (!is.null(pattern)) {
[08:27:53.716]                           computeRestarts <- base::computeRestarts
[08:27:53.716]                           grepl <- base::grepl
[08:27:53.716]                           restarts <- computeRestarts(cond)
[08:27:53.716]                           for (restart in restarts) {
[08:27:53.716]                             name <- restart$name
[08:27:53.716]                             if (is.null(name)) 
[08:27:53.716]                               next
[08:27:53.716]                             if (!grepl(pattern, name)) 
[08:27:53.716]                               next
[08:27:53.716]                             invokeRestart(restart)
[08:27:53.716]                             muffled <- TRUE
[08:27:53.716]                             break
[08:27:53.716]                           }
[08:27:53.716]                         }
[08:27:53.716]                       }
[08:27:53.716]                       invisible(muffled)
[08:27:53.716]                     }
[08:27:53.716]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.716]                   }
[08:27:53.716]                 }
[08:27:53.716]                 else {
[08:27:53.716]                   if (TRUE) {
[08:27:53.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.716]                     {
[08:27:53.716]                       inherits <- base::inherits
[08:27:53.716]                       invokeRestart <- base::invokeRestart
[08:27:53.716]                       is.null <- base::is.null
[08:27:53.716]                       muffled <- FALSE
[08:27:53.716]                       if (inherits(cond, "message")) {
[08:27:53.716]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.716]                         if (muffled) 
[08:27:53.716]                           invokeRestart("muffleMessage")
[08:27:53.716]                       }
[08:27:53.716]                       else if (inherits(cond, "warning")) {
[08:27:53.716]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.716]                         if (muffled) 
[08:27:53.716]                           invokeRestart("muffleWarning")
[08:27:53.716]                       }
[08:27:53.716]                       else if (inherits(cond, "condition")) {
[08:27:53.716]                         if (!is.null(pattern)) {
[08:27:53.716]                           computeRestarts <- base::computeRestarts
[08:27:53.716]                           grepl <- base::grepl
[08:27:53.716]                           restarts <- computeRestarts(cond)
[08:27:53.716]                           for (restart in restarts) {
[08:27:53.716]                             name <- restart$name
[08:27:53.716]                             if (is.null(name)) 
[08:27:53.716]                               next
[08:27:53.716]                             if (!grepl(pattern, name)) 
[08:27:53.716]                               next
[08:27:53.716]                             invokeRestart(restart)
[08:27:53.716]                             muffled <- TRUE
[08:27:53.716]                             break
[08:27:53.716]                           }
[08:27:53.716]                         }
[08:27:53.716]                       }
[08:27:53.716]                       invisible(muffled)
[08:27:53.716]                     }
[08:27:53.716]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.716]                   }
[08:27:53.716]                 }
[08:27:53.716]             }
[08:27:53.716]         }))
[08:27:53.716]     }, error = function(ex) {
[08:27:53.716]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.716]                 ...future.rng), started = ...future.startTime, 
[08:27:53.716]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.716]             version = "1.8"), class = "FutureResult")
[08:27:53.716]     }, finally = {
[08:27:53.716]         if (!identical(...future.workdir, getwd())) 
[08:27:53.716]             setwd(...future.workdir)
[08:27:53.716]         {
[08:27:53.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.716]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.716]             }
[08:27:53.716]             base::options(...future.oldOptions)
[08:27:53.716]             if (.Platform$OS.type == "windows") {
[08:27:53.716]                 old_names <- names(...future.oldEnvVars)
[08:27:53.716]                 envs <- base::Sys.getenv()
[08:27:53.716]                 names <- names(envs)
[08:27:53.716]                 common <- intersect(names, old_names)
[08:27:53.716]                 added <- setdiff(names, old_names)
[08:27:53.716]                 removed <- setdiff(old_names, names)
[08:27:53.716]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.716]                   envs[common]]
[08:27:53.716]                 NAMES <- toupper(changed)
[08:27:53.716]                 args <- list()
[08:27:53.716]                 for (kk in seq_along(NAMES)) {
[08:27:53.716]                   name <- changed[[kk]]
[08:27:53.716]                   NAME <- NAMES[[kk]]
[08:27:53.716]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.716]                     next
[08:27:53.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.716]                 }
[08:27:53.716]                 NAMES <- toupper(added)
[08:27:53.716]                 for (kk in seq_along(NAMES)) {
[08:27:53.716]                   name <- added[[kk]]
[08:27:53.716]                   NAME <- NAMES[[kk]]
[08:27:53.716]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.716]                     next
[08:27:53.716]                   args[[name]] <- ""
[08:27:53.716]                 }
[08:27:53.716]                 NAMES <- toupper(removed)
[08:27:53.716]                 for (kk in seq_along(NAMES)) {
[08:27:53.716]                   name <- removed[[kk]]
[08:27:53.716]                   NAME <- NAMES[[kk]]
[08:27:53.716]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.716]                     next
[08:27:53.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.716]                 }
[08:27:53.716]                 if (length(args) > 0) 
[08:27:53.716]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.716]             }
[08:27:53.716]             else {
[08:27:53.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.716]             }
[08:27:53.716]             {
[08:27:53.716]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.716]                   0L) {
[08:27:53.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.716]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.716]                   base::options(opts)
[08:27:53.716]                 }
[08:27:53.716]                 {
[08:27:53.716]                   {
[08:27:53.716]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.716]                     NULL
[08:27:53.716]                   }
[08:27:53.716]                   options(future.plan = NULL)
[08:27:53.716]                   if (is.na(NA_character_)) 
[08:27:53.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.716]                     .init = FALSE)
[08:27:53.716]                 }
[08:27:53.716]             }
[08:27:53.716]         }
[08:27:53.716]     })
[08:27:53.716]     if (TRUE) {
[08:27:53.716]         base::sink(type = "output", split = FALSE)
[08:27:53.716]         if (TRUE) {
[08:27:53.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.716]         }
[08:27:53.716]         else {
[08:27:53.716]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.716]         }
[08:27:53.716]         base::close(...future.stdout)
[08:27:53.716]         ...future.stdout <- NULL
[08:27:53.716]     }
[08:27:53.716]     ...future.result$conditions <- ...future.conditions
[08:27:53.716]     ...future.result$finished <- base::Sys.time()
[08:27:53.716]     ...future.result
[08:27:53.716] }
[08:27:53.719] MultisessionFuture started
[08:27:53.720] - Launch lazy future ... done
[08:27:53.720] run() for ‘MultisessionFuture’ ... done
[08:27:53.720] getGlobalsAndPackages() ...
[08:27:53.720] Searching for globals...
[08:27:53.721] - globals found: [1] ‘{’
[08:27:53.721] Searching for globals ... DONE
[08:27:53.721] Resolving globals: FALSE
[08:27:53.721] 
[08:27:53.721] 
[08:27:53.721] getGlobalsAndPackages() ... DONE
[08:27:53.722] run() for ‘Future’ ...
[08:27:53.722] - state: ‘created’
[08:27:53.722] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.736] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.736] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.736]   - Field: ‘node’
[08:27:53.736]   - Field: ‘label’
[08:27:53.736]   - Field: ‘local’
[08:27:53.737]   - Field: ‘owner’
[08:27:53.737]   - Field: ‘envir’
[08:27:53.737]   - Field: ‘workers’
[08:27:53.737]   - Field: ‘packages’
[08:27:53.737]   - Field: ‘gc’
[08:27:53.737]   - Field: ‘conditions’
[08:27:53.737]   - Field: ‘persistent’
[08:27:53.737]   - Field: ‘expr’
[08:27:53.737]   - Field: ‘uuid’
[08:27:53.737]   - Field: ‘seed’
[08:27:53.737]   - Field: ‘version’
[08:27:53.738]   - Field: ‘result’
[08:27:53.738]   - Field: ‘asynchronous’
[08:27:53.738]   - Field: ‘calls’
[08:27:53.738]   - Field: ‘globals’
[08:27:53.738]   - Field: ‘stdout’
[08:27:53.738]   - Field: ‘earlySignal’
[08:27:53.738]   - Field: ‘lazy’
[08:27:53.738]   - Field: ‘state’
[08:27:53.738] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.738] - Launch lazy future ...
[08:27:53.739] Packages needed by the future expression (n = 0): <none>
[08:27:53.739] Packages needed by future strategies (n = 0): <none>
[08:27:53.740] {
[08:27:53.740]     {
[08:27:53.740]         {
[08:27:53.740]             ...future.startTime <- base::Sys.time()
[08:27:53.740]             {
[08:27:53.740]                 {
[08:27:53.740]                   {
[08:27:53.740]                     {
[08:27:53.740]                       base::local({
[08:27:53.740]                         has_future <- base::requireNamespace("future", 
[08:27:53.740]                           quietly = TRUE)
[08:27:53.740]                         if (has_future) {
[08:27:53.740]                           ns <- base::getNamespace("future")
[08:27:53.740]                           version <- ns[[".package"]][["version"]]
[08:27:53.740]                           if (is.null(version)) 
[08:27:53.740]                             version <- utils::packageVersion("future")
[08:27:53.740]                         }
[08:27:53.740]                         else {
[08:27:53.740]                           version <- NULL
[08:27:53.740]                         }
[08:27:53.740]                         if (!has_future || version < "1.8.0") {
[08:27:53.740]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.740]                             "", base::R.version$version.string), 
[08:27:53.740]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.740]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.740]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.740]                               "release", "version")], collapse = " "), 
[08:27:53.740]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.740]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.740]                             info)
[08:27:53.740]                           info <- base::paste(info, collapse = "; ")
[08:27:53.740]                           if (!has_future) {
[08:27:53.740]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.740]                               info)
[08:27:53.740]                           }
[08:27:53.740]                           else {
[08:27:53.740]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.740]                               info, version)
[08:27:53.740]                           }
[08:27:53.740]                           base::stop(msg)
[08:27:53.740]                         }
[08:27:53.740]                       })
[08:27:53.740]                     }
[08:27:53.740]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.740]                     base::options(mc.cores = 1L)
[08:27:53.740]                   }
[08:27:53.740]                   ...future.strategy.old <- future::plan("list")
[08:27:53.740]                   options(future.plan = NULL)
[08:27:53.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.740]                 }
[08:27:53.740]                 ...future.workdir <- getwd()
[08:27:53.740]             }
[08:27:53.740]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.740]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.740]         }
[08:27:53.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.740]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.740]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.740]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.740]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.740]             base::names(...future.oldOptions))
[08:27:53.740]     }
[08:27:53.740]     if (FALSE) {
[08:27:53.740]     }
[08:27:53.740]     else {
[08:27:53.740]         if (TRUE) {
[08:27:53.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.740]                 open = "w")
[08:27:53.740]         }
[08:27:53.740]         else {
[08:27:53.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.740]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.740]         }
[08:27:53.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.740]             base::sink(type = "output", split = FALSE)
[08:27:53.740]             base::close(...future.stdout)
[08:27:53.740]         }, add = TRUE)
[08:27:53.740]     }
[08:27:53.740]     ...future.frame <- base::sys.nframe()
[08:27:53.740]     ...future.conditions <- base::list()
[08:27:53.740]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.740]     if (FALSE) {
[08:27:53.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.740]     }
[08:27:53.740]     ...future.result <- base::tryCatch({
[08:27:53.740]         base::withCallingHandlers({
[08:27:53.740]             ...future.value <- base::withVisible(base::local({
[08:27:53.740]                 ...future.makeSendCondition <- base::local({
[08:27:53.740]                   sendCondition <- NULL
[08:27:53.740]                   function(frame = 1L) {
[08:27:53.740]                     if (is.function(sendCondition)) 
[08:27:53.740]                       return(sendCondition)
[08:27:53.740]                     ns <- getNamespace("parallel")
[08:27:53.740]                     if (exists("sendData", mode = "function", 
[08:27:53.740]                       envir = ns)) {
[08:27:53.740]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.740]                         envir = ns)
[08:27:53.740]                       envir <- sys.frame(frame)
[08:27:53.740]                       master <- NULL
[08:27:53.740]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.740]                         !identical(envir, emptyenv())) {
[08:27:53.740]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.740]                           inherits = FALSE)) {
[08:27:53.740]                           master <- get("master", mode = "list", 
[08:27:53.740]                             envir = envir, inherits = FALSE)
[08:27:53.740]                           if (inherits(master, c("SOCKnode", 
[08:27:53.740]                             "SOCK0node"))) {
[08:27:53.740]                             sendCondition <<- function(cond) {
[08:27:53.740]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.740]                                 success = TRUE)
[08:27:53.740]                               parallel_sendData(master, data)
[08:27:53.740]                             }
[08:27:53.740]                             return(sendCondition)
[08:27:53.740]                           }
[08:27:53.740]                         }
[08:27:53.740]                         frame <- frame + 1L
[08:27:53.740]                         envir <- sys.frame(frame)
[08:27:53.740]                       }
[08:27:53.740]                     }
[08:27:53.740]                     sendCondition <<- function(cond) NULL
[08:27:53.740]                   }
[08:27:53.740]                 })
[08:27:53.740]                 withCallingHandlers({
[08:27:53.740]                   {
[08:27:53.740]                     4
[08:27:53.740]                   }
[08:27:53.740]                 }, immediateCondition = function(cond) {
[08:27:53.740]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.740]                   sendCondition(cond)
[08:27:53.740]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.740]                   {
[08:27:53.740]                     inherits <- base::inherits
[08:27:53.740]                     invokeRestart <- base::invokeRestart
[08:27:53.740]                     is.null <- base::is.null
[08:27:53.740]                     muffled <- FALSE
[08:27:53.740]                     if (inherits(cond, "message")) {
[08:27:53.740]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.740]                       if (muffled) 
[08:27:53.740]                         invokeRestart("muffleMessage")
[08:27:53.740]                     }
[08:27:53.740]                     else if (inherits(cond, "warning")) {
[08:27:53.740]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.740]                       if (muffled) 
[08:27:53.740]                         invokeRestart("muffleWarning")
[08:27:53.740]                     }
[08:27:53.740]                     else if (inherits(cond, "condition")) {
[08:27:53.740]                       if (!is.null(pattern)) {
[08:27:53.740]                         computeRestarts <- base::computeRestarts
[08:27:53.740]                         grepl <- base::grepl
[08:27:53.740]                         restarts <- computeRestarts(cond)
[08:27:53.740]                         for (restart in restarts) {
[08:27:53.740]                           name <- restart$name
[08:27:53.740]                           if (is.null(name)) 
[08:27:53.740]                             next
[08:27:53.740]                           if (!grepl(pattern, name)) 
[08:27:53.740]                             next
[08:27:53.740]                           invokeRestart(restart)
[08:27:53.740]                           muffled <- TRUE
[08:27:53.740]                           break
[08:27:53.740]                         }
[08:27:53.740]                       }
[08:27:53.740]                     }
[08:27:53.740]                     invisible(muffled)
[08:27:53.740]                   }
[08:27:53.740]                   muffleCondition(cond)
[08:27:53.740]                 })
[08:27:53.740]             }))
[08:27:53.740]             future::FutureResult(value = ...future.value$value, 
[08:27:53.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.740]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.740]                     ...future.globalenv.names))
[08:27:53.740]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.740]         }, condition = base::local({
[08:27:53.740]             c <- base::c
[08:27:53.740]             inherits <- base::inherits
[08:27:53.740]             invokeRestart <- base::invokeRestart
[08:27:53.740]             length <- base::length
[08:27:53.740]             list <- base::list
[08:27:53.740]             seq.int <- base::seq.int
[08:27:53.740]             signalCondition <- base::signalCondition
[08:27:53.740]             sys.calls <- base::sys.calls
[08:27:53.740]             `[[` <- base::`[[`
[08:27:53.740]             `+` <- base::`+`
[08:27:53.740]             `<<-` <- base::`<<-`
[08:27:53.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.740]                   3L)]
[08:27:53.740]             }
[08:27:53.740]             function(cond) {
[08:27:53.740]                 is_error <- inherits(cond, "error")
[08:27:53.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.740]                   NULL)
[08:27:53.740]                 if (is_error) {
[08:27:53.740]                   sessionInformation <- function() {
[08:27:53.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.740]                       search = base::search(), system = base::Sys.info())
[08:27:53.740]                   }
[08:27:53.740]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.740]                     cond$call), session = sessionInformation(), 
[08:27:53.740]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.740]                   signalCondition(cond)
[08:27:53.740]                 }
[08:27:53.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.740]                 "immediateCondition"))) {
[08:27:53.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.740]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.740]                   if (TRUE && !signal) {
[08:27:53.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.740]                     {
[08:27:53.740]                       inherits <- base::inherits
[08:27:53.740]                       invokeRestart <- base::invokeRestart
[08:27:53.740]                       is.null <- base::is.null
[08:27:53.740]                       muffled <- FALSE
[08:27:53.740]                       if (inherits(cond, "message")) {
[08:27:53.740]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.740]                         if (muffled) 
[08:27:53.740]                           invokeRestart("muffleMessage")
[08:27:53.740]                       }
[08:27:53.740]                       else if (inherits(cond, "warning")) {
[08:27:53.740]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.740]                         if (muffled) 
[08:27:53.740]                           invokeRestart("muffleWarning")
[08:27:53.740]                       }
[08:27:53.740]                       else if (inherits(cond, "condition")) {
[08:27:53.740]                         if (!is.null(pattern)) {
[08:27:53.740]                           computeRestarts <- base::computeRestarts
[08:27:53.740]                           grepl <- base::grepl
[08:27:53.740]                           restarts <- computeRestarts(cond)
[08:27:53.740]                           for (restart in restarts) {
[08:27:53.740]                             name <- restart$name
[08:27:53.740]                             if (is.null(name)) 
[08:27:53.740]                               next
[08:27:53.740]                             if (!grepl(pattern, name)) 
[08:27:53.740]                               next
[08:27:53.740]                             invokeRestart(restart)
[08:27:53.740]                             muffled <- TRUE
[08:27:53.740]                             break
[08:27:53.740]                           }
[08:27:53.740]                         }
[08:27:53.740]                       }
[08:27:53.740]                       invisible(muffled)
[08:27:53.740]                     }
[08:27:53.740]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.740]                   }
[08:27:53.740]                 }
[08:27:53.740]                 else {
[08:27:53.740]                   if (TRUE) {
[08:27:53.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.740]                     {
[08:27:53.740]                       inherits <- base::inherits
[08:27:53.740]                       invokeRestart <- base::invokeRestart
[08:27:53.740]                       is.null <- base::is.null
[08:27:53.740]                       muffled <- FALSE
[08:27:53.740]                       if (inherits(cond, "message")) {
[08:27:53.740]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.740]                         if (muffled) 
[08:27:53.740]                           invokeRestart("muffleMessage")
[08:27:53.740]                       }
[08:27:53.740]                       else if (inherits(cond, "warning")) {
[08:27:53.740]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.740]                         if (muffled) 
[08:27:53.740]                           invokeRestart("muffleWarning")
[08:27:53.740]                       }
[08:27:53.740]                       else if (inherits(cond, "condition")) {
[08:27:53.740]                         if (!is.null(pattern)) {
[08:27:53.740]                           computeRestarts <- base::computeRestarts
[08:27:53.740]                           grepl <- base::grepl
[08:27:53.740]                           restarts <- computeRestarts(cond)
[08:27:53.740]                           for (restart in restarts) {
[08:27:53.740]                             name <- restart$name
[08:27:53.740]                             if (is.null(name)) 
[08:27:53.740]                               next
[08:27:53.740]                             if (!grepl(pattern, name)) 
[08:27:53.740]                               next
[08:27:53.740]                             invokeRestart(restart)
[08:27:53.740]                             muffled <- TRUE
[08:27:53.740]                             break
[08:27:53.740]                           }
[08:27:53.740]                         }
[08:27:53.740]                       }
[08:27:53.740]                       invisible(muffled)
[08:27:53.740]                     }
[08:27:53.740]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.740]                   }
[08:27:53.740]                 }
[08:27:53.740]             }
[08:27:53.740]         }))
[08:27:53.740]     }, error = function(ex) {
[08:27:53.740]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.740]                 ...future.rng), started = ...future.startTime, 
[08:27:53.740]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.740]             version = "1.8"), class = "FutureResult")
[08:27:53.740]     }, finally = {
[08:27:53.740]         if (!identical(...future.workdir, getwd())) 
[08:27:53.740]             setwd(...future.workdir)
[08:27:53.740]         {
[08:27:53.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.740]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.740]             }
[08:27:53.740]             base::options(...future.oldOptions)
[08:27:53.740]             if (.Platform$OS.type == "windows") {
[08:27:53.740]                 old_names <- names(...future.oldEnvVars)
[08:27:53.740]                 envs <- base::Sys.getenv()
[08:27:53.740]                 names <- names(envs)
[08:27:53.740]                 common <- intersect(names, old_names)
[08:27:53.740]                 added <- setdiff(names, old_names)
[08:27:53.740]                 removed <- setdiff(old_names, names)
[08:27:53.740]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.740]                   envs[common]]
[08:27:53.740]                 NAMES <- toupper(changed)
[08:27:53.740]                 args <- list()
[08:27:53.740]                 for (kk in seq_along(NAMES)) {
[08:27:53.740]                   name <- changed[[kk]]
[08:27:53.740]                   NAME <- NAMES[[kk]]
[08:27:53.740]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.740]                     next
[08:27:53.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.740]                 }
[08:27:53.740]                 NAMES <- toupper(added)
[08:27:53.740]                 for (kk in seq_along(NAMES)) {
[08:27:53.740]                   name <- added[[kk]]
[08:27:53.740]                   NAME <- NAMES[[kk]]
[08:27:53.740]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.740]                     next
[08:27:53.740]                   args[[name]] <- ""
[08:27:53.740]                 }
[08:27:53.740]                 NAMES <- toupper(removed)
[08:27:53.740]                 for (kk in seq_along(NAMES)) {
[08:27:53.740]                   name <- removed[[kk]]
[08:27:53.740]                   NAME <- NAMES[[kk]]
[08:27:53.740]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.740]                     next
[08:27:53.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.740]                 }
[08:27:53.740]                 if (length(args) > 0) 
[08:27:53.740]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.740]             }
[08:27:53.740]             else {
[08:27:53.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.740]             }
[08:27:53.740]             {
[08:27:53.740]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.740]                   0L) {
[08:27:53.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.740]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.740]                   base::options(opts)
[08:27:53.740]                 }
[08:27:53.740]                 {
[08:27:53.740]                   {
[08:27:53.740]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.740]                     NULL
[08:27:53.740]                   }
[08:27:53.740]                   options(future.plan = NULL)
[08:27:53.740]                   if (is.na(NA_character_)) 
[08:27:53.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.740]                     .init = FALSE)
[08:27:53.740]                 }
[08:27:53.740]             }
[08:27:53.740]         }
[08:27:53.740]     })
[08:27:53.740]     if (TRUE) {
[08:27:53.740]         base::sink(type = "output", split = FALSE)
[08:27:53.740]         if (TRUE) {
[08:27:53.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.740]         }
[08:27:53.740]         else {
[08:27:53.740]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.740]         }
[08:27:53.740]         base::close(...future.stdout)
[08:27:53.740]         ...future.stdout <- NULL
[08:27:53.740]     }
[08:27:53.740]     ...future.result$conditions <- ...future.conditions
[08:27:53.740]     ...future.result$finished <- base::Sys.time()
[08:27:53.740]     ...future.result
[08:27:53.740] }
[08:27:53.743] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:53.753] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.754] - Validating connection of MultisessionFuture
[08:27:53.754] - received message: FutureResult
[08:27:53.754] - Received FutureResult
[08:27:53.754] - Erased future from FutureRegistry
[08:27:53.754] result() for ClusterFuture ...
[08:27:53.754] - result already collected: FutureResult
[08:27:53.754] result() for ClusterFuture ... done
[08:27:53.754] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.755] result() for ClusterFuture ...
[08:27:53.755] - result already collected: FutureResult
[08:27:53.755] result() for ClusterFuture ... done
[08:27:53.755] result() for ClusterFuture ...
[08:27:53.755] - result already collected: FutureResult
[08:27:53.755] result() for ClusterFuture ... done
[08:27:53.756] MultisessionFuture started
[08:27:53.756] - Launch lazy future ... done
[08:27:53.756] run() for ‘MultisessionFuture’ ... done
<environment: 0x55d8607175f0> 
<environment: 0x55d862548570> 
[08:27:53.761] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.761] - Validating connection of MultisessionFuture
[08:27:53.761] - received message: FutureResult
[08:27:53.762] - Received FutureResult
[08:27:53.762] - Erased future from FutureRegistry
[08:27:53.762] result() for ClusterFuture ...
[08:27:53.762] - result already collected: FutureResult
[08:27:53.762] result() for ClusterFuture ... done
[08:27:53.762] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:53.774] resolve() on environment ...
[08:27:53.774]  recursive: 0
[08:27:53.774]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:53.775] signalConditionsASAP(numeric, pos=1) ...
[08:27:53.775] - nx: 4
[08:27:53.775] - relay: TRUE
[08:27:53.775] - stdout: TRUE
[08:27:53.775] - signal: TRUE
[08:27:53.775] - resignal: FALSE
[08:27:53.775] - force: TRUE
[08:27:53.775] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.775] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.775]  - until=2
[08:27:53.775]  - relaying element #2
[08:27:53.775] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.776] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.776] signalConditionsASAP(NULL, pos=1) ... done
[08:27:53.776]  length: 3 (resolved future 1)
[08:27:53.776] Future #2
[08:27:53.776] result() for ClusterFuture ...
[08:27:53.776] - result already collected: FutureResult
[08:27:53.776] result() for ClusterFuture ... done
[08:27:53.776] result() for ClusterFuture ...
[08:27:53.776] - result already collected: FutureResult
[08:27:53.776] result() for ClusterFuture ... done
[08:27:53.776] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:53.777] - nx: 4
[08:27:53.777] - relay: TRUE
[08:27:53.777] - stdout: TRUE
[08:27:53.777] - signal: TRUE
[08:27:53.777] - resignal: FALSE
[08:27:53.777] - force: TRUE
[08:27:53.777] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.777] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.777]  - until=2
[08:27:53.777]  - relaying element #2
[08:27:53.777] result() for ClusterFuture ...
[08:27:53.777] - result already collected: FutureResult
[08:27:53.777] result() for ClusterFuture ... done
[08:27:53.778] result() for ClusterFuture ...
[08:27:53.778] - result already collected: FutureResult
[08:27:53.778] result() for ClusterFuture ... done
[08:27:53.778] result() for ClusterFuture ...
[08:27:53.778] - result already collected: FutureResult
[08:27:53.778] result() for ClusterFuture ... done
[08:27:53.778] result() for ClusterFuture ...
[08:27:53.778] - result already collected: FutureResult
[08:27:53.778] result() for ClusterFuture ... done
[08:27:53.778] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.778] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.778] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:53.779]  length: 2 (resolved future 2)
[08:27:53.779] Future #3
[08:27:53.779] result() for ClusterFuture ...
[08:27:53.779] - result already collected: FutureResult
[08:27:53.779] result() for ClusterFuture ... done
[08:27:53.779] result() for ClusterFuture ...
[08:27:53.779] - result already collected: FutureResult
[08:27:53.779] result() for ClusterFuture ... done
[08:27:53.779] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:53.779] - nx: 4
[08:27:53.779] - relay: TRUE
[08:27:53.779] - stdout: TRUE
[08:27:53.780] - signal: TRUE
[08:27:53.780] - resignal: FALSE
[08:27:53.780] - force: TRUE
[08:27:53.780] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.780] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.780]  - until=3
[08:27:53.780]  - relaying element #3
[08:27:53.780] result() for ClusterFuture ...
[08:27:53.780] - result already collected: FutureResult
[08:27:53.780] result() for ClusterFuture ... done
[08:27:53.780] result() for ClusterFuture ...
[08:27:53.780] - result already collected: FutureResult
[08:27:53.781] result() for ClusterFuture ... done
[08:27:53.781] result() for ClusterFuture ...
[08:27:53.781] - result already collected: FutureResult
[08:27:53.781] result() for ClusterFuture ... done
[08:27:53.781] result() for ClusterFuture ...
[08:27:53.781] - result already collected: FutureResult
[08:27:53.781] result() for ClusterFuture ... done
[08:27:53.781] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.781] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.781] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:53.781]  length: 1 (resolved future 3)
[08:27:53.802] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.803] - Validating connection of MultisessionFuture
[08:27:53.803] - received message: FutureResult
[08:27:53.803] - Received FutureResult
[08:27:53.803] - Erased future from FutureRegistry
[08:27:53.803] result() for ClusterFuture ...
[08:27:53.803] - result already collected: FutureResult
[08:27:53.803] result() for ClusterFuture ... done
[08:27:53.803] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.804] Future #4
[08:27:53.804] result() for ClusterFuture ...
[08:27:53.804] - result already collected: FutureResult
[08:27:53.804] result() for ClusterFuture ... done
[08:27:53.804] result() for ClusterFuture ...
[08:27:53.804] - result already collected: FutureResult
[08:27:53.804] result() for ClusterFuture ... done
[08:27:53.804] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:53.804] - nx: 4
[08:27:53.804] - relay: TRUE
[08:27:53.804] - stdout: TRUE
[08:27:53.804] - signal: TRUE
[08:27:53.805] - resignal: FALSE
[08:27:53.805] - force: TRUE
[08:27:53.805] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.805] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.805]  - until=4
[08:27:53.805]  - relaying element #4
[08:27:53.805] result() for ClusterFuture ...
[08:27:53.805] - result already collected: FutureResult
[08:27:53.805] result() for ClusterFuture ... done
[08:27:53.805] result() for ClusterFuture ...
[08:27:53.805] - result already collected: FutureResult
[08:27:53.805] result() for ClusterFuture ... done
[08:27:53.806] result() for ClusterFuture ...
[08:27:53.806] - result already collected: FutureResult
[08:27:53.806] result() for ClusterFuture ... done
[08:27:53.806] result() for ClusterFuture ...
[08:27:53.806] - result already collected: FutureResult
[08:27:53.806] result() for ClusterFuture ... done
[08:27:53.806] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.806] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.806] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:53.806]  length: 0 (resolved future 4)
[08:27:53.806] Relaying remaining futures
[08:27:53.807] signalConditionsASAP(NULL, pos=0) ...
[08:27:53.807] - nx: 4
[08:27:53.807] - relay: TRUE
[08:27:53.807] - stdout: TRUE
[08:27:53.807] - signal: TRUE
[08:27:53.807] - resignal: FALSE
[08:27:53.807] - force: TRUE
[08:27:53.807] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.807] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:53.807] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.807] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.807] signalConditionsASAP(NULL, pos=0) ... done
[08:27:53.808] resolve() on environment ... DONE
[08:27:53.808] result() for ClusterFuture ...
[08:27:53.808] - result already collected: FutureResult
[08:27:53.808] result() for ClusterFuture ... done
[08:27:53.808] result() for ClusterFuture ...
[08:27:53.808] - result already collected: FutureResult
[08:27:53.808] result() for ClusterFuture ... done
[08:27:53.808] result() for ClusterFuture ...
[08:27:53.808] - result already collected: FutureResult
[08:27:53.808] result() for ClusterFuture ... done
[08:27:53.808] result() for ClusterFuture ...
[08:27:53.808] - result already collected: FutureResult
[08:27:53.809] result() for ClusterFuture ... done
[08:27:53.809] result() for ClusterFuture ...
[08:27:53.809] - result already collected: FutureResult
[08:27:53.809] result() for ClusterFuture ... done
[08:27:53.809] result() for ClusterFuture ...
[08:27:53.809] - result already collected: FutureResult
[08:27:53.809] result() for ClusterFuture ... done
<environment: 0x55d862690540> 
Dimensions: c(2, 1, 3, 1)
[08:27:53.809] getGlobalsAndPackages() ...
[08:27:53.810] Searching for globals...
[08:27:53.810] 
[08:27:53.810] Searching for globals ... DONE
[08:27:53.810] - globals: [0] <none>
[08:27:53.810] getGlobalsAndPackages() ... DONE
[08:27:53.810] run() for ‘Future’ ...
[08:27:53.810] - state: ‘created’
[08:27:53.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.825] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.825] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.825]   - Field: ‘node’
[08:27:53.825]   - Field: ‘label’
[08:27:53.825]   - Field: ‘local’
[08:27:53.826]   - Field: ‘owner’
[08:27:53.826]   - Field: ‘envir’
[08:27:53.826]   - Field: ‘workers’
[08:27:53.826]   - Field: ‘packages’
[08:27:53.826]   - Field: ‘gc’
[08:27:53.826]   - Field: ‘conditions’
[08:27:53.826]   - Field: ‘persistent’
[08:27:53.826]   - Field: ‘expr’
[08:27:53.826]   - Field: ‘uuid’
[08:27:53.826]   - Field: ‘seed’
[08:27:53.826]   - Field: ‘version’
[08:27:53.827]   - Field: ‘result’
[08:27:53.827]   - Field: ‘asynchronous’
[08:27:53.827]   - Field: ‘calls’
[08:27:53.827]   - Field: ‘globals’
[08:27:53.827]   - Field: ‘stdout’
[08:27:53.827]   - Field: ‘earlySignal’
[08:27:53.827]   - Field: ‘lazy’
[08:27:53.827]   - Field: ‘state’
[08:27:53.827] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.827] - Launch lazy future ...
[08:27:53.828] Packages needed by the future expression (n = 0): <none>
[08:27:53.828] Packages needed by future strategies (n = 0): <none>
[08:27:53.831] {
[08:27:53.831]     {
[08:27:53.831]         {
[08:27:53.831]             ...future.startTime <- base::Sys.time()
[08:27:53.831]             {
[08:27:53.831]                 {
[08:27:53.831]                   {
[08:27:53.831]                     {
[08:27:53.831]                       base::local({
[08:27:53.831]                         has_future <- base::requireNamespace("future", 
[08:27:53.831]                           quietly = TRUE)
[08:27:53.831]                         if (has_future) {
[08:27:53.831]                           ns <- base::getNamespace("future")
[08:27:53.831]                           version <- ns[[".package"]][["version"]]
[08:27:53.831]                           if (is.null(version)) 
[08:27:53.831]                             version <- utils::packageVersion("future")
[08:27:53.831]                         }
[08:27:53.831]                         else {
[08:27:53.831]                           version <- NULL
[08:27:53.831]                         }
[08:27:53.831]                         if (!has_future || version < "1.8.0") {
[08:27:53.831]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.831]                             "", base::R.version$version.string), 
[08:27:53.831]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.831]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.831]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.831]                               "release", "version")], collapse = " "), 
[08:27:53.831]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.831]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.831]                             info)
[08:27:53.831]                           info <- base::paste(info, collapse = "; ")
[08:27:53.831]                           if (!has_future) {
[08:27:53.831]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.831]                               info)
[08:27:53.831]                           }
[08:27:53.831]                           else {
[08:27:53.831]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.831]                               info, version)
[08:27:53.831]                           }
[08:27:53.831]                           base::stop(msg)
[08:27:53.831]                         }
[08:27:53.831]                       })
[08:27:53.831]                     }
[08:27:53.831]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.831]                     base::options(mc.cores = 1L)
[08:27:53.831]                   }
[08:27:53.831]                   ...future.strategy.old <- future::plan("list")
[08:27:53.831]                   options(future.plan = NULL)
[08:27:53.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.831]                 }
[08:27:53.831]                 ...future.workdir <- getwd()
[08:27:53.831]             }
[08:27:53.831]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.831]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.831]         }
[08:27:53.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.831]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.831]             base::names(...future.oldOptions))
[08:27:53.831]     }
[08:27:53.831]     if (FALSE) {
[08:27:53.831]     }
[08:27:53.831]     else {
[08:27:53.831]         if (TRUE) {
[08:27:53.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.831]                 open = "w")
[08:27:53.831]         }
[08:27:53.831]         else {
[08:27:53.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.831]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.831]         }
[08:27:53.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.831]             base::sink(type = "output", split = FALSE)
[08:27:53.831]             base::close(...future.stdout)
[08:27:53.831]         }, add = TRUE)
[08:27:53.831]     }
[08:27:53.831]     ...future.frame <- base::sys.nframe()
[08:27:53.831]     ...future.conditions <- base::list()
[08:27:53.831]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.831]     if (FALSE) {
[08:27:53.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.831]     }
[08:27:53.831]     ...future.result <- base::tryCatch({
[08:27:53.831]         base::withCallingHandlers({
[08:27:53.831]             ...future.value <- base::withVisible(base::local({
[08:27:53.831]                 ...future.makeSendCondition <- base::local({
[08:27:53.831]                   sendCondition <- NULL
[08:27:53.831]                   function(frame = 1L) {
[08:27:53.831]                     if (is.function(sendCondition)) 
[08:27:53.831]                       return(sendCondition)
[08:27:53.831]                     ns <- getNamespace("parallel")
[08:27:53.831]                     if (exists("sendData", mode = "function", 
[08:27:53.831]                       envir = ns)) {
[08:27:53.831]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.831]                         envir = ns)
[08:27:53.831]                       envir <- sys.frame(frame)
[08:27:53.831]                       master <- NULL
[08:27:53.831]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.831]                         !identical(envir, emptyenv())) {
[08:27:53.831]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.831]                           inherits = FALSE)) {
[08:27:53.831]                           master <- get("master", mode = "list", 
[08:27:53.831]                             envir = envir, inherits = FALSE)
[08:27:53.831]                           if (inherits(master, c("SOCKnode", 
[08:27:53.831]                             "SOCK0node"))) {
[08:27:53.831]                             sendCondition <<- function(cond) {
[08:27:53.831]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.831]                                 success = TRUE)
[08:27:53.831]                               parallel_sendData(master, data)
[08:27:53.831]                             }
[08:27:53.831]                             return(sendCondition)
[08:27:53.831]                           }
[08:27:53.831]                         }
[08:27:53.831]                         frame <- frame + 1L
[08:27:53.831]                         envir <- sys.frame(frame)
[08:27:53.831]                       }
[08:27:53.831]                     }
[08:27:53.831]                     sendCondition <<- function(cond) NULL
[08:27:53.831]                   }
[08:27:53.831]                 })
[08:27:53.831]                 withCallingHandlers({
[08:27:53.831]                   2
[08:27:53.831]                 }, immediateCondition = function(cond) {
[08:27:53.831]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.831]                   sendCondition(cond)
[08:27:53.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.831]                   {
[08:27:53.831]                     inherits <- base::inherits
[08:27:53.831]                     invokeRestart <- base::invokeRestart
[08:27:53.831]                     is.null <- base::is.null
[08:27:53.831]                     muffled <- FALSE
[08:27:53.831]                     if (inherits(cond, "message")) {
[08:27:53.831]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.831]                       if (muffled) 
[08:27:53.831]                         invokeRestart("muffleMessage")
[08:27:53.831]                     }
[08:27:53.831]                     else if (inherits(cond, "warning")) {
[08:27:53.831]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.831]                       if (muffled) 
[08:27:53.831]                         invokeRestart("muffleWarning")
[08:27:53.831]                     }
[08:27:53.831]                     else if (inherits(cond, "condition")) {
[08:27:53.831]                       if (!is.null(pattern)) {
[08:27:53.831]                         computeRestarts <- base::computeRestarts
[08:27:53.831]                         grepl <- base::grepl
[08:27:53.831]                         restarts <- computeRestarts(cond)
[08:27:53.831]                         for (restart in restarts) {
[08:27:53.831]                           name <- restart$name
[08:27:53.831]                           if (is.null(name)) 
[08:27:53.831]                             next
[08:27:53.831]                           if (!grepl(pattern, name)) 
[08:27:53.831]                             next
[08:27:53.831]                           invokeRestart(restart)
[08:27:53.831]                           muffled <- TRUE
[08:27:53.831]                           break
[08:27:53.831]                         }
[08:27:53.831]                       }
[08:27:53.831]                     }
[08:27:53.831]                     invisible(muffled)
[08:27:53.831]                   }
[08:27:53.831]                   muffleCondition(cond)
[08:27:53.831]                 })
[08:27:53.831]             }))
[08:27:53.831]             future::FutureResult(value = ...future.value$value, 
[08:27:53.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.831]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.831]                     ...future.globalenv.names))
[08:27:53.831]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.831]         }, condition = base::local({
[08:27:53.831]             c <- base::c
[08:27:53.831]             inherits <- base::inherits
[08:27:53.831]             invokeRestart <- base::invokeRestart
[08:27:53.831]             length <- base::length
[08:27:53.831]             list <- base::list
[08:27:53.831]             seq.int <- base::seq.int
[08:27:53.831]             signalCondition <- base::signalCondition
[08:27:53.831]             sys.calls <- base::sys.calls
[08:27:53.831]             `[[` <- base::`[[`
[08:27:53.831]             `+` <- base::`+`
[08:27:53.831]             `<<-` <- base::`<<-`
[08:27:53.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.831]                   3L)]
[08:27:53.831]             }
[08:27:53.831]             function(cond) {
[08:27:53.831]                 is_error <- inherits(cond, "error")
[08:27:53.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.831]                   NULL)
[08:27:53.831]                 if (is_error) {
[08:27:53.831]                   sessionInformation <- function() {
[08:27:53.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.831]                       search = base::search(), system = base::Sys.info())
[08:27:53.831]                   }
[08:27:53.831]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.831]                     cond$call), session = sessionInformation(), 
[08:27:53.831]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.831]                   signalCondition(cond)
[08:27:53.831]                 }
[08:27:53.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.831]                 "immediateCondition"))) {
[08:27:53.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.831]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.831]                   if (TRUE && !signal) {
[08:27:53.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.831]                     {
[08:27:53.831]                       inherits <- base::inherits
[08:27:53.831]                       invokeRestart <- base::invokeRestart
[08:27:53.831]                       is.null <- base::is.null
[08:27:53.831]                       muffled <- FALSE
[08:27:53.831]                       if (inherits(cond, "message")) {
[08:27:53.831]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.831]                         if (muffled) 
[08:27:53.831]                           invokeRestart("muffleMessage")
[08:27:53.831]                       }
[08:27:53.831]                       else if (inherits(cond, "warning")) {
[08:27:53.831]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.831]                         if (muffled) 
[08:27:53.831]                           invokeRestart("muffleWarning")
[08:27:53.831]                       }
[08:27:53.831]                       else if (inherits(cond, "condition")) {
[08:27:53.831]                         if (!is.null(pattern)) {
[08:27:53.831]                           computeRestarts <- base::computeRestarts
[08:27:53.831]                           grepl <- base::grepl
[08:27:53.831]                           restarts <- computeRestarts(cond)
[08:27:53.831]                           for (restart in restarts) {
[08:27:53.831]                             name <- restart$name
[08:27:53.831]                             if (is.null(name)) 
[08:27:53.831]                               next
[08:27:53.831]                             if (!grepl(pattern, name)) 
[08:27:53.831]                               next
[08:27:53.831]                             invokeRestart(restart)
[08:27:53.831]                             muffled <- TRUE
[08:27:53.831]                             break
[08:27:53.831]                           }
[08:27:53.831]                         }
[08:27:53.831]                       }
[08:27:53.831]                       invisible(muffled)
[08:27:53.831]                     }
[08:27:53.831]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.831]                   }
[08:27:53.831]                 }
[08:27:53.831]                 else {
[08:27:53.831]                   if (TRUE) {
[08:27:53.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.831]                     {
[08:27:53.831]                       inherits <- base::inherits
[08:27:53.831]                       invokeRestart <- base::invokeRestart
[08:27:53.831]                       is.null <- base::is.null
[08:27:53.831]                       muffled <- FALSE
[08:27:53.831]                       if (inherits(cond, "message")) {
[08:27:53.831]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.831]                         if (muffled) 
[08:27:53.831]                           invokeRestart("muffleMessage")
[08:27:53.831]                       }
[08:27:53.831]                       else if (inherits(cond, "warning")) {
[08:27:53.831]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.831]                         if (muffled) 
[08:27:53.831]                           invokeRestart("muffleWarning")
[08:27:53.831]                       }
[08:27:53.831]                       else if (inherits(cond, "condition")) {
[08:27:53.831]                         if (!is.null(pattern)) {
[08:27:53.831]                           computeRestarts <- base::computeRestarts
[08:27:53.831]                           grepl <- base::grepl
[08:27:53.831]                           restarts <- computeRestarts(cond)
[08:27:53.831]                           for (restart in restarts) {
[08:27:53.831]                             name <- restart$name
[08:27:53.831]                             if (is.null(name)) 
[08:27:53.831]                               next
[08:27:53.831]                             if (!grepl(pattern, name)) 
[08:27:53.831]                               next
[08:27:53.831]                             invokeRestart(restart)
[08:27:53.831]                             muffled <- TRUE
[08:27:53.831]                             break
[08:27:53.831]                           }
[08:27:53.831]                         }
[08:27:53.831]                       }
[08:27:53.831]                       invisible(muffled)
[08:27:53.831]                     }
[08:27:53.831]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.831]                   }
[08:27:53.831]                 }
[08:27:53.831]             }
[08:27:53.831]         }))
[08:27:53.831]     }, error = function(ex) {
[08:27:53.831]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.831]                 ...future.rng), started = ...future.startTime, 
[08:27:53.831]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.831]             version = "1.8"), class = "FutureResult")
[08:27:53.831]     }, finally = {
[08:27:53.831]         if (!identical(...future.workdir, getwd())) 
[08:27:53.831]             setwd(...future.workdir)
[08:27:53.831]         {
[08:27:53.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.831]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.831]             }
[08:27:53.831]             base::options(...future.oldOptions)
[08:27:53.831]             if (.Platform$OS.type == "windows") {
[08:27:53.831]                 old_names <- names(...future.oldEnvVars)
[08:27:53.831]                 envs <- base::Sys.getenv()
[08:27:53.831]                 names <- names(envs)
[08:27:53.831]                 common <- intersect(names, old_names)
[08:27:53.831]                 added <- setdiff(names, old_names)
[08:27:53.831]                 removed <- setdiff(old_names, names)
[08:27:53.831]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.831]                   envs[common]]
[08:27:53.831]                 NAMES <- toupper(changed)
[08:27:53.831]                 args <- list()
[08:27:53.831]                 for (kk in seq_along(NAMES)) {
[08:27:53.831]                   name <- changed[[kk]]
[08:27:53.831]                   NAME <- NAMES[[kk]]
[08:27:53.831]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.831]                     next
[08:27:53.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.831]                 }
[08:27:53.831]                 NAMES <- toupper(added)
[08:27:53.831]                 for (kk in seq_along(NAMES)) {
[08:27:53.831]                   name <- added[[kk]]
[08:27:53.831]                   NAME <- NAMES[[kk]]
[08:27:53.831]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.831]                     next
[08:27:53.831]                   args[[name]] <- ""
[08:27:53.831]                 }
[08:27:53.831]                 NAMES <- toupper(removed)
[08:27:53.831]                 for (kk in seq_along(NAMES)) {
[08:27:53.831]                   name <- removed[[kk]]
[08:27:53.831]                   NAME <- NAMES[[kk]]
[08:27:53.831]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.831]                     next
[08:27:53.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.831]                 }
[08:27:53.831]                 if (length(args) > 0) 
[08:27:53.831]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.831]             }
[08:27:53.831]             else {
[08:27:53.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.831]             }
[08:27:53.831]             {
[08:27:53.831]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.831]                   0L) {
[08:27:53.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.831]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.831]                   base::options(opts)
[08:27:53.831]                 }
[08:27:53.831]                 {
[08:27:53.831]                   {
[08:27:53.831]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.831]                     NULL
[08:27:53.831]                   }
[08:27:53.831]                   options(future.plan = NULL)
[08:27:53.831]                   if (is.na(NA_character_)) 
[08:27:53.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.831]                     .init = FALSE)
[08:27:53.831]                 }
[08:27:53.831]             }
[08:27:53.831]         }
[08:27:53.831]     })
[08:27:53.831]     if (TRUE) {
[08:27:53.831]         base::sink(type = "output", split = FALSE)
[08:27:53.831]         if (TRUE) {
[08:27:53.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.831]         }
[08:27:53.831]         else {
[08:27:53.831]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.831]         }
[08:27:53.831]         base::close(...future.stdout)
[08:27:53.831]         ...future.stdout <- NULL
[08:27:53.831]     }
[08:27:53.831]     ...future.result$conditions <- ...future.conditions
[08:27:53.831]     ...future.result$finished <- base::Sys.time()
[08:27:53.831]     ...future.result
[08:27:53.831] }
[08:27:53.834] MultisessionFuture started
[08:27:53.835] - Launch lazy future ... done
[08:27:53.835] run() for ‘MultisessionFuture’ ... done
[08:27:53.835] getGlobalsAndPackages() ...
[08:27:53.835] Searching for globals...
[08:27:53.835] 
[08:27:53.835] Searching for globals ... DONE
[08:27:53.835] - globals: [0] <none>
[08:27:53.835] getGlobalsAndPackages() ... DONE
[08:27:53.836] run() for ‘Future’ ...
[08:27:53.836] - state: ‘created’
[08:27:53.836] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.850] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.850] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.850]   - Field: ‘node’
[08:27:53.850]   - Field: ‘label’
[08:27:53.850]   - Field: ‘local’
[08:27:53.851]   - Field: ‘owner’
[08:27:53.851]   - Field: ‘envir’
[08:27:53.851]   - Field: ‘workers’
[08:27:53.851]   - Field: ‘packages’
[08:27:53.851]   - Field: ‘gc’
[08:27:53.851]   - Field: ‘conditions’
[08:27:53.851]   - Field: ‘persistent’
[08:27:53.851]   - Field: ‘expr’
[08:27:53.851]   - Field: ‘uuid’
[08:27:53.851]   - Field: ‘seed’
[08:27:53.851]   - Field: ‘version’
[08:27:53.851]   - Field: ‘result’
[08:27:53.852]   - Field: ‘asynchronous’
[08:27:53.852]   - Field: ‘calls’
[08:27:53.852]   - Field: ‘globals’
[08:27:53.852]   - Field: ‘stdout’
[08:27:53.852]   - Field: ‘earlySignal’
[08:27:53.852]   - Field: ‘lazy’
[08:27:53.852]   - Field: ‘state’
[08:27:53.852] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.852] - Launch lazy future ...
[08:27:53.852] Packages needed by the future expression (n = 0): <none>
[08:27:53.853] Packages needed by future strategies (n = 0): <none>
[08:27:53.853] {
[08:27:53.853]     {
[08:27:53.853]         {
[08:27:53.853]             ...future.startTime <- base::Sys.time()
[08:27:53.853]             {
[08:27:53.853]                 {
[08:27:53.853]                   {
[08:27:53.853]                     {
[08:27:53.853]                       base::local({
[08:27:53.853]                         has_future <- base::requireNamespace("future", 
[08:27:53.853]                           quietly = TRUE)
[08:27:53.853]                         if (has_future) {
[08:27:53.853]                           ns <- base::getNamespace("future")
[08:27:53.853]                           version <- ns[[".package"]][["version"]]
[08:27:53.853]                           if (is.null(version)) 
[08:27:53.853]                             version <- utils::packageVersion("future")
[08:27:53.853]                         }
[08:27:53.853]                         else {
[08:27:53.853]                           version <- NULL
[08:27:53.853]                         }
[08:27:53.853]                         if (!has_future || version < "1.8.0") {
[08:27:53.853]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.853]                             "", base::R.version$version.string), 
[08:27:53.853]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.853]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.853]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.853]                               "release", "version")], collapse = " "), 
[08:27:53.853]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.853]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.853]                             info)
[08:27:53.853]                           info <- base::paste(info, collapse = "; ")
[08:27:53.853]                           if (!has_future) {
[08:27:53.853]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.853]                               info)
[08:27:53.853]                           }
[08:27:53.853]                           else {
[08:27:53.853]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.853]                               info, version)
[08:27:53.853]                           }
[08:27:53.853]                           base::stop(msg)
[08:27:53.853]                         }
[08:27:53.853]                       })
[08:27:53.853]                     }
[08:27:53.853]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.853]                     base::options(mc.cores = 1L)
[08:27:53.853]                   }
[08:27:53.853]                   ...future.strategy.old <- future::plan("list")
[08:27:53.853]                   options(future.plan = NULL)
[08:27:53.853]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.853]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.853]                 }
[08:27:53.853]                 ...future.workdir <- getwd()
[08:27:53.853]             }
[08:27:53.853]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.853]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.853]         }
[08:27:53.853]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.853]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.853]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.853]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.853]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.853]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.853]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.853]             base::names(...future.oldOptions))
[08:27:53.853]     }
[08:27:53.853]     if (FALSE) {
[08:27:53.853]     }
[08:27:53.853]     else {
[08:27:53.853]         if (TRUE) {
[08:27:53.853]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.853]                 open = "w")
[08:27:53.853]         }
[08:27:53.853]         else {
[08:27:53.853]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.853]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.853]         }
[08:27:53.853]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.853]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.853]             base::sink(type = "output", split = FALSE)
[08:27:53.853]             base::close(...future.stdout)
[08:27:53.853]         }, add = TRUE)
[08:27:53.853]     }
[08:27:53.853]     ...future.frame <- base::sys.nframe()
[08:27:53.853]     ...future.conditions <- base::list()
[08:27:53.853]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.853]     if (FALSE) {
[08:27:53.853]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.853]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.853]     }
[08:27:53.853]     ...future.result <- base::tryCatch({
[08:27:53.853]         base::withCallingHandlers({
[08:27:53.853]             ...future.value <- base::withVisible(base::local({
[08:27:53.853]                 ...future.makeSendCondition <- base::local({
[08:27:53.853]                   sendCondition <- NULL
[08:27:53.853]                   function(frame = 1L) {
[08:27:53.853]                     if (is.function(sendCondition)) 
[08:27:53.853]                       return(sendCondition)
[08:27:53.853]                     ns <- getNamespace("parallel")
[08:27:53.853]                     if (exists("sendData", mode = "function", 
[08:27:53.853]                       envir = ns)) {
[08:27:53.853]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.853]                         envir = ns)
[08:27:53.853]                       envir <- sys.frame(frame)
[08:27:53.853]                       master <- NULL
[08:27:53.853]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.853]                         !identical(envir, emptyenv())) {
[08:27:53.853]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.853]                           inherits = FALSE)) {
[08:27:53.853]                           master <- get("master", mode = "list", 
[08:27:53.853]                             envir = envir, inherits = FALSE)
[08:27:53.853]                           if (inherits(master, c("SOCKnode", 
[08:27:53.853]                             "SOCK0node"))) {
[08:27:53.853]                             sendCondition <<- function(cond) {
[08:27:53.853]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.853]                                 success = TRUE)
[08:27:53.853]                               parallel_sendData(master, data)
[08:27:53.853]                             }
[08:27:53.853]                             return(sendCondition)
[08:27:53.853]                           }
[08:27:53.853]                         }
[08:27:53.853]                         frame <- frame + 1L
[08:27:53.853]                         envir <- sys.frame(frame)
[08:27:53.853]                       }
[08:27:53.853]                     }
[08:27:53.853]                     sendCondition <<- function(cond) NULL
[08:27:53.853]                   }
[08:27:53.853]                 })
[08:27:53.853]                 withCallingHandlers({
[08:27:53.853]                   NULL
[08:27:53.853]                 }, immediateCondition = function(cond) {
[08:27:53.853]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.853]                   sendCondition(cond)
[08:27:53.853]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.853]                   {
[08:27:53.853]                     inherits <- base::inherits
[08:27:53.853]                     invokeRestart <- base::invokeRestart
[08:27:53.853]                     is.null <- base::is.null
[08:27:53.853]                     muffled <- FALSE
[08:27:53.853]                     if (inherits(cond, "message")) {
[08:27:53.853]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.853]                       if (muffled) 
[08:27:53.853]                         invokeRestart("muffleMessage")
[08:27:53.853]                     }
[08:27:53.853]                     else if (inherits(cond, "warning")) {
[08:27:53.853]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.853]                       if (muffled) 
[08:27:53.853]                         invokeRestart("muffleWarning")
[08:27:53.853]                     }
[08:27:53.853]                     else if (inherits(cond, "condition")) {
[08:27:53.853]                       if (!is.null(pattern)) {
[08:27:53.853]                         computeRestarts <- base::computeRestarts
[08:27:53.853]                         grepl <- base::grepl
[08:27:53.853]                         restarts <- computeRestarts(cond)
[08:27:53.853]                         for (restart in restarts) {
[08:27:53.853]                           name <- restart$name
[08:27:53.853]                           if (is.null(name)) 
[08:27:53.853]                             next
[08:27:53.853]                           if (!grepl(pattern, name)) 
[08:27:53.853]                             next
[08:27:53.853]                           invokeRestart(restart)
[08:27:53.853]                           muffled <- TRUE
[08:27:53.853]                           break
[08:27:53.853]                         }
[08:27:53.853]                       }
[08:27:53.853]                     }
[08:27:53.853]                     invisible(muffled)
[08:27:53.853]                   }
[08:27:53.853]                   muffleCondition(cond)
[08:27:53.853]                 })
[08:27:53.853]             }))
[08:27:53.853]             future::FutureResult(value = ...future.value$value, 
[08:27:53.853]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.853]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.853]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.853]                     ...future.globalenv.names))
[08:27:53.853]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.853]         }, condition = base::local({
[08:27:53.853]             c <- base::c
[08:27:53.853]             inherits <- base::inherits
[08:27:53.853]             invokeRestart <- base::invokeRestart
[08:27:53.853]             length <- base::length
[08:27:53.853]             list <- base::list
[08:27:53.853]             seq.int <- base::seq.int
[08:27:53.853]             signalCondition <- base::signalCondition
[08:27:53.853]             sys.calls <- base::sys.calls
[08:27:53.853]             `[[` <- base::`[[`
[08:27:53.853]             `+` <- base::`+`
[08:27:53.853]             `<<-` <- base::`<<-`
[08:27:53.853]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.853]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.853]                   3L)]
[08:27:53.853]             }
[08:27:53.853]             function(cond) {
[08:27:53.853]                 is_error <- inherits(cond, "error")
[08:27:53.853]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.853]                   NULL)
[08:27:53.853]                 if (is_error) {
[08:27:53.853]                   sessionInformation <- function() {
[08:27:53.853]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.853]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.853]                       search = base::search(), system = base::Sys.info())
[08:27:53.853]                   }
[08:27:53.853]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.853]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.853]                     cond$call), session = sessionInformation(), 
[08:27:53.853]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.853]                   signalCondition(cond)
[08:27:53.853]                 }
[08:27:53.853]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.853]                 "immediateCondition"))) {
[08:27:53.853]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.853]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.853]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.853]                   if (TRUE && !signal) {
[08:27:53.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.853]                     {
[08:27:53.853]                       inherits <- base::inherits
[08:27:53.853]                       invokeRestart <- base::invokeRestart
[08:27:53.853]                       is.null <- base::is.null
[08:27:53.853]                       muffled <- FALSE
[08:27:53.853]                       if (inherits(cond, "message")) {
[08:27:53.853]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.853]                         if (muffled) 
[08:27:53.853]                           invokeRestart("muffleMessage")
[08:27:53.853]                       }
[08:27:53.853]                       else if (inherits(cond, "warning")) {
[08:27:53.853]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.853]                         if (muffled) 
[08:27:53.853]                           invokeRestart("muffleWarning")
[08:27:53.853]                       }
[08:27:53.853]                       else if (inherits(cond, "condition")) {
[08:27:53.853]                         if (!is.null(pattern)) {
[08:27:53.853]                           computeRestarts <- base::computeRestarts
[08:27:53.853]                           grepl <- base::grepl
[08:27:53.853]                           restarts <- computeRestarts(cond)
[08:27:53.853]                           for (restart in restarts) {
[08:27:53.853]                             name <- restart$name
[08:27:53.853]                             if (is.null(name)) 
[08:27:53.853]                               next
[08:27:53.853]                             if (!grepl(pattern, name)) 
[08:27:53.853]                               next
[08:27:53.853]                             invokeRestart(restart)
[08:27:53.853]                             muffled <- TRUE
[08:27:53.853]                             break
[08:27:53.853]                           }
[08:27:53.853]                         }
[08:27:53.853]                       }
[08:27:53.853]                       invisible(muffled)
[08:27:53.853]                     }
[08:27:53.853]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.853]                   }
[08:27:53.853]                 }
[08:27:53.853]                 else {
[08:27:53.853]                   if (TRUE) {
[08:27:53.853]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.853]                     {
[08:27:53.853]                       inherits <- base::inherits
[08:27:53.853]                       invokeRestart <- base::invokeRestart
[08:27:53.853]                       is.null <- base::is.null
[08:27:53.853]                       muffled <- FALSE
[08:27:53.853]                       if (inherits(cond, "message")) {
[08:27:53.853]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.853]                         if (muffled) 
[08:27:53.853]                           invokeRestart("muffleMessage")
[08:27:53.853]                       }
[08:27:53.853]                       else if (inherits(cond, "warning")) {
[08:27:53.853]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.853]                         if (muffled) 
[08:27:53.853]                           invokeRestart("muffleWarning")
[08:27:53.853]                       }
[08:27:53.853]                       else if (inherits(cond, "condition")) {
[08:27:53.853]                         if (!is.null(pattern)) {
[08:27:53.853]                           computeRestarts <- base::computeRestarts
[08:27:53.853]                           grepl <- base::grepl
[08:27:53.853]                           restarts <- computeRestarts(cond)
[08:27:53.853]                           for (restart in restarts) {
[08:27:53.853]                             name <- restart$name
[08:27:53.853]                             if (is.null(name)) 
[08:27:53.853]                               next
[08:27:53.853]                             if (!grepl(pattern, name)) 
[08:27:53.853]                               next
[08:27:53.853]                             invokeRestart(restart)
[08:27:53.853]                             muffled <- TRUE
[08:27:53.853]                             break
[08:27:53.853]                           }
[08:27:53.853]                         }
[08:27:53.853]                       }
[08:27:53.853]                       invisible(muffled)
[08:27:53.853]                     }
[08:27:53.853]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.853]                   }
[08:27:53.853]                 }
[08:27:53.853]             }
[08:27:53.853]         }))
[08:27:53.853]     }, error = function(ex) {
[08:27:53.853]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.853]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.853]                 ...future.rng), started = ...future.startTime, 
[08:27:53.853]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.853]             version = "1.8"), class = "FutureResult")
[08:27:53.853]     }, finally = {
[08:27:53.853]         if (!identical(...future.workdir, getwd())) 
[08:27:53.853]             setwd(...future.workdir)
[08:27:53.853]         {
[08:27:53.853]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.853]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.853]             }
[08:27:53.853]             base::options(...future.oldOptions)
[08:27:53.853]             if (.Platform$OS.type == "windows") {
[08:27:53.853]                 old_names <- names(...future.oldEnvVars)
[08:27:53.853]                 envs <- base::Sys.getenv()
[08:27:53.853]                 names <- names(envs)
[08:27:53.853]                 common <- intersect(names, old_names)
[08:27:53.853]                 added <- setdiff(names, old_names)
[08:27:53.853]                 removed <- setdiff(old_names, names)
[08:27:53.853]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.853]                   envs[common]]
[08:27:53.853]                 NAMES <- toupper(changed)
[08:27:53.853]                 args <- list()
[08:27:53.853]                 for (kk in seq_along(NAMES)) {
[08:27:53.853]                   name <- changed[[kk]]
[08:27:53.853]                   NAME <- NAMES[[kk]]
[08:27:53.853]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.853]                     next
[08:27:53.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.853]                 }
[08:27:53.853]                 NAMES <- toupper(added)
[08:27:53.853]                 for (kk in seq_along(NAMES)) {
[08:27:53.853]                   name <- added[[kk]]
[08:27:53.853]                   NAME <- NAMES[[kk]]
[08:27:53.853]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.853]                     next
[08:27:53.853]                   args[[name]] <- ""
[08:27:53.853]                 }
[08:27:53.853]                 NAMES <- toupper(removed)
[08:27:53.853]                 for (kk in seq_along(NAMES)) {
[08:27:53.853]                   name <- removed[[kk]]
[08:27:53.853]                   NAME <- NAMES[[kk]]
[08:27:53.853]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.853]                     next
[08:27:53.853]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.853]                 }
[08:27:53.853]                 if (length(args) > 0) 
[08:27:53.853]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.853]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.853]             }
[08:27:53.853]             else {
[08:27:53.853]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.853]             }
[08:27:53.853]             {
[08:27:53.853]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.853]                   0L) {
[08:27:53.853]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.853]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.853]                   base::options(opts)
[08:27:53.853]                 }
[08:27:53.853]                 {
[08:27:53.853]                   {
[08:27:53.853]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.853]                     NULL
[08:27:53.853]                   }
[08:27:53.853]                   options(future.plan = NULL)
[08:27:53.853]                   if (is.na(NA_character_)) 
[08:27:53.853]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.853]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.853]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.853]                     .init = FALSE)
[08:27:53.853]                 }
[08:27:53.853]             }
[08:27:53.853]         }
[08:27:53.853]     })
[08:27:53.853]     if (TRUE) {
[08:27:53.853]         base::sink(type = "output", split = FALSE)
[08:27:53.853]         if (TRUE) {
[08:27:53.853]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.853]         }
[08:27:53.853]         else {
[08:27:53.853]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.853]         }
[08:27:53.853]         base::close(...future.stdout)
[08:27:53.853]         ...future.stdout <- NULL
[08:27:53.853]     }
[08:27:53.853]     ...future.result$conditions <- ...future.conditions
[08:27:53.853]     ...future.result$finished <- base::Sys.time()
[08:27:53.853]     ...future.result
[08:27:53.853] }
[08:27:53.856] MultisessionFuture started
[08:27:53.856] - Launch lazy future ... done
[08:27:53.856] run() for ‘MultisessionFuture’ ... done
[08:27:53.857] getGlobalsAndPackages() ...
[08:27:53.857] Searching for globals...
[08:27:53.857] - globals found: [1] ‘{’
[08:27:53.857] Searching for globals ... DONE
[08:27:53.857] Resolving globals: FALSE
[08:27:53.858] 
[08:27:53.858] 
[08:27:53.858] getGlobalsAndPackages() ... DONE
[08:27:53.858] run() for ‘Future’ ...
[08:27:53.858] - state: ‘created’
[08:27:53.858] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.872] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.872] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:53.872]   - Field: ‘node’
[08:27:53.872]   - Field: ‘label’
[08:27:53.872]   - Field: ‘local’
[08:27:53.873]   - Field: ‘owner’
[08:27:53.873]   - Field: ‘envir’
[08:27:53.873]   - Field: ‘workers’
[08:27:53.873]   - Field: ‘packages’
[08:27:53.873]   - Field: ‘gc’
[08:27:53.873]   - Field: ‘conditions’
[08:27:53.873]   - Field: ‘persistent’
[08:27:53.873]   - Field: ‘expr’
[08:27:53.873]   - Field: ‘uuid’
[08:27:53.873]   - Field: ‘seed’
[08:27:53.873]   - Field: ‘version’
[08:27:53.873]   - Field: ‘result’
[08:27:53.874]   - Field: ‘asynchronous’
[08:27:53.874]   - Field: ‘calls’
[08:27:53.874]   - Field: ‘globals’
[08:27:53.874]   - Field: ‘stdout’
[08:27:53.874]   - Field: ‘earlySignal’
[08:27:53.874]   - Field: ‘lazy’
[08:27:53.874]   - Field: ‘state’
[08:27:53.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:53.874] - Launch lazy future ...
[08:27:53.875] Packages needed by the future expression (n = 0): <none>
[08:27:53.875] Packages needed by future strategies (n = 0): <none>
[08:27:53.875] {
[08:27:53.875]     {
[08:27:53.875]         {
[08:27:53.875]             ...future.startTime <- base::Sys.time()
[08:27:53.875]             {
[08:27:53.875]                 {
[08:27:53.875]                   {
[08:27:53.875]                     {
[08:27:53.875]                       base::local({
[08:27:53.875]                         has_future <- base::requireNamespace("future", 
[08:27:53.875]                           quietly = TRUE)
[08:27:53.875]                         if (has_future) {
[08:27:53.875]                           ns <- base::getNamespace("future")
[08:27:53.875]                           version <- ns[[".package"]][["version"]]
[08:27:53.875]                           if (is.null(version)) 
[08:27:53.875]                             version <- utils::packageVersion("future")
[08:27:53.875]                         }
[08:27:53.875]                         else {
[08:27:53.875]                           version <- NULL
[08:27:53.875]                         }
[08:27:53.875]                         if (!has_future || version < "1.8.0") {
[08:27:53.875]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.875]                             "", base::R.version$version.string), 
[08:27:53.875]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.875]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.875]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.875]                               "release", "version")], collapse = " "), 
[08:27:53.875]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.875]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.875]                             info)
[08:27:53.875]                           info <- base::paste(info, collapse = "; ")
[08:27:53.875]                           if (!has_future) {
[08:27:53.875]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.875]                               info)
[08:27:53.875]                           }
[08:27:53.875]                           else {
[08:27:53.875]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.875]                               info, version)
[08:27:53.875]                           }
[08:27:53.875]                           base::stop(msg)
[08:27:53.875]                         }
[08:27:53.875]                       })
[08:27:53.875]                     }
[08:27:53.875]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.875]                     base::options(mc.cores = 1L)
[08:27:53.875]                   }
[08:27:53.875]                   ...future.strategy.old <- future::plan("list")
[08:27:53.875]                   options(future.plan = NULL)
[08:27:53.875]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.875]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.875]                 }
[08:27:53.875]                 ...future.workdir <- getwd()
[08:27:53.875]             }
[08:27:53.875]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.875]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.875]         }
[08:27:53.875]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.875]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.875]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.875]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.875]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.875]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.875]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.875]             base::names(...future.oldOptions))
[08:27:53.875]     }
[08:27:53.875]     if (FALSE) {
[08:27:53.875]     }
[08:27:53.875]     else {
[08:27:53.875]         if (TRUE) {
[08:27:53.875]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.875]                 open = "w")
[08:27:53.875]         }
[08:27:53.875]         else {
[08:27:53.875]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.875]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.875]         }
[08:27:53.875]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.875]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.875]             base::sink(type = "output", split = FALSE)
[08:27:53.875]             base::close(...future.stdout)
[08:27:53.875]         }, add = TRUE)
[08:27:53.875]     }
[08:27:53.875]     ...future.frame <- base::sys.nframe()
[08:27:53.875]     ...future.conditions <- base::list()
[08:27:53.875]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.875]     if (FALSE) {
[08:27:53.875]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.875]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.875]     }
[08:27:53.875]     ...future.result <- base::tryCatch({
[08:27:53.875]         base::withCallingHandlers({
[08:27:53.875]             ...future.value <- base::withVisible(base::local({
[08:27:53.875]                 ...future.makeSendCondition <- base::local({
[08:27:53.875]                   sendCondition <- NULL
[08:27:53.875]                   function(frame = 1L) {
[08:27:53.875]                     if (is.function(sendCondition)) 
[08:27:53.875]                       return(sendCondition)
[08:27:53.875]                     ns <- getNamespace("parallel")
[08:27:53.875]                     if (exists("sendData", mode = "function", 
[08:27:53.875]                       envir = ns)) {
[08:27:53.875]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:53.875]                         envir = ns)
[08:27:53.875]                       envir <- sys.frame(frame)
[08:27:53.875]                       master <- NULL
[08:27:53.875]                       while (!identical(envir, .GlobalEnv) && 
[08:27:53.875]                         !identical(envir, emptyenv())) {
[08:27:53.875]                         if (exists("master", mode = "list", envir = envir, 
[08:27:53.875]                           inherits = FALSE)) {
[08:27:53.875]                           master <- get("master", mode = "list", 
[08:27:53.875]                             envir = envir, inherits = FALSE)
[08:27:53.875]                           if (inherits(master, c("SOCKnode", 
[08:27:53.875]                             "SOCK0node"))) {
[08:27:53.875]                             sendCondition <<- function(cond) {
[08:27:53.875]                               data <- list(type = "VALUE", value = cond, 
[08:27:53.875]                                 success = TRUE)
[08:27:53.875]                               parallel_sendData(master, data)
[08:27:53.875]                             }
[08:27:53.875]                             return(sendCondition)
[08:27:53.875]                           }
[08:27:53.875]                         }
[08:27:53.875]                         frame <- frame + 1L
[08:27:53.875]                         envir <- sys.frame(frame)
[08:27:53.875]                       }
[08:27:53.875]                     }
[08:27:53.875]                     sendCondition <<- function(cond) NULL
[08:27:53.875]                   }
[08:27:53.875]                 })
[08:27:53.875]                 withCallingHandlers({
[08:27:53.875]                   {
[08:27:53.875]                     4
[08:27:53.875]                   }
[08:27:53.875]                 }, immediateCondition = function(cond) {
[08:27:53.875]                   sendCondition <- ...future.makeSendCondition()
[08:27:53.875]                   sendCondition(cond)
[08:27:53.875]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.875]                   {
[08:27:53.875]                     inherits <- base::inherits
[08:27:53.875]                     invokeRestart <- base::invokeRestart
[08:27:53.875]                     is.null <- base::is.null
[08:27:53.875]                     muffled <- FALSE
[08:27:53.875]                     if (inherits(cond, "message")) {
[08:27:53.875]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.875]                       if (muffled) 
[08:27:53.875]                         invokeRestart("muffleMessage")
[08:27:53.875]                     }
[08:27:53.875]                     else if (inherits(cond, "warning")) {
[08:27:53.875]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.875]                       if (muffled) 
[08:27:53.875]                         invokeRestart("muffleWarning")
[08:27:53.875]                     }
[08:27:53.875]                     else if (inherits(cond, "condition")) {
[08:27:53.875]                       if (!is.null(pattern)) {
[08:27:53.875]                         computeRestarts <- base::computeRestarts
[08:27:53.875]                         grepl <- base::grepl
[08:27:53.875]                         restarts <- computeRestarts(cond)
[08:27:53.875]                         for (restart in restarts) {
[08:27:53.875]                           name <- restart$name
[08:27:53.875]                           if (is.null(name)) 
[08:27:53.875]                             next
[08:27:53.875]                           if (!grepl(pattern, name)) 
[08:27:53.875]                             next
[08:27:53.875]                           invokeRestart(restart)
[08:27:53.875]                           muffled <- TRUE
[08:27:53.875]                           break
[08:27:53.875]                         }
[08:27:53.875]                       }
[08:27:53.875]                     }
[08:27:53.875]                     invisible(muffled)
[08:27:53.875]                   }
[08:27:53.875]                   muffleCondition(cond)
[08:27:53.875]                 })
[08:27:53.875]             }))
[08:27:53.875]             future::FutureResult(value = ...future.value$value, 
[08:27:53.875]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.875]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.875]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.875]                     ...future.globalenv.names))
[08:27:53.875]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.875]         }, condition = base::local({
[08:27:53.875]             c <- base::c
[08:27:53.875]             inherits <- base::inherits
[08:27:53.875]             invokeRestart <- base::invokeRestart
[08:27:53.875]             length <- base::length
[08:27:53.875]             list <- base::list
[08:27:53.875]             seq.int <- base::seq.int
[08:27:53.875]             signalCondition <- base::signalCondition
[08:27:53.875]             sys.calls <- base::sys.calls
[08:27:53.875]             `[[` <- base::`[[`
[08:27:53.875]             `+` <- base::`+`
[08:27:53.875]             `<<-` <- base::`<<-`
[08:27:53.875]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.875]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.875]                   3L)]
[08:27:53.875]             }
[08:27:53.875]             function(cond) {
[08:27:53.875]                 is_error <- inherits(cond, "error")
[08:27:53.875]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.875]                   NULL)
[08:27:53.875]                 if (is_error) {
[08:27:53.875]                   sessionInformation <- function() {
[08:27:53.875]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.875]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.875]                       search = base::search(), system = base::Sys.info())
[08:27:53.875]                   }
[08:27:53.875]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.875]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.875]                     cond$call), session = sessionInformation(), 
[08:27:53.875]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.875]                   signalCondition(cond)
[08:27:53.875]                 }
[08:27:53.875]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.875]                 "immediateCondition"))) {
[08:27:53.875]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.875]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.875]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.875]                   if (TRUE && !signal) {
[08:27:53.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.875]                     {
[08:27:53.875]                       inherits <- base::inherits
[08:27:53.875]                       invokeRestart <- base::invokeRestart
[08:27:53.875]                       is.null <- base::is.null
[08:27:53.875]                       muffled <- FALSE
[08:27:53.875]                       if (inherits(cond, "message")) {
[08:27:53.875]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.875]                         if (muffled) 
[08:27:53.875]                           invokeRestart("muffleMessage")
[08:27:53.875]                       }
[08:27:53.875]                       else if (inherits(cond, "warning")) {
[08:27:53.875]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.875]                         if (muffled) 
[08:27:53.875]                           invokeRestart("muffleWarning")
[08:27:53.875]                       }
[08:27:53.875]                       else if (inherits(cond, "condition")) {
[08:27:53.875]                         if (!is.null(pattern)) {
[08:27:53.875]                           computeRestarts <- base::computeRestarts
[08:27:53.875]                           grepl <- base::grepl
[08:27:53.875]                           restarts <- computeRestarts(cond)
[08:27:53.875]                           for (restart in restarts) {
[08:27:53.875]                             name <- restart$name
[08:27:53.875]                             if (is.null(name)) 
[08:27:53.875]                               next
[08:27:53.875]                             if (!grepl(pattern, name)) 
[08:27:53.875]                               next
[08:27:53.875]                             invokeRestart(restart)
[08:27:53.875]                             muffled <- TRUE
[08:27:53.875]                             break
[08:27:53.875]                           }
[08:27:53.875]                         }
[08:27:53.875]                       }
[08:27:53.875]                       invisible(muffled)
[08:27:53.875]                     }
[08:27:53.875]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.875]                   }
[08:27:53.875]                 }
[08:27:53.875]                 else {
[08:27:53.875]                   if (TRUE) {
[08:27:53.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.875]                     {
[08:27:53.875]                       inherits <- base::inherits
[08:27:53.875]                       invokeRestart <- base::invokeRestart
[08:27:53.875]                       is.null <- base::is.null
[08:27:53.875]                       muffled <- FALSE
[08:27:53.875]                       if (inherits(cond, "message")) {
[08:27:53.875]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.875]                         if (muffled) 
[08:27:53.875]                           invokeRestart("muffleMessage")
[08:27:53.875]                       }
[08:27:53.875]                       else if (inherits(cond, "warning")) {
[08:27:53.875]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.875]                         if (muffled) 
[08:27:53.875]                           invokeRestart("muffleWarning")
[08:27:53.875]                       }
[08:27:53.875]                       else if (inherits(cond, "condition")) {
[08:27:53.875]                         if (!is.null(pattern)) {
[08:27:53.875]                           computeRestarts <- base::computeRestarts
[08:27:53.875]                           grepl <- base::grepl
[08:27:53.875]                           restarts <- computeRestarts(cond)
[08:27:53.875]                           for (restart in restarts) {
[08:27:53.875]                             name <- restart$name
[08:27:53.875]                             if (is.null(name)) 
[08:27:53.875]                               next
[08:27:53.875]                             if (!grepl(pattern, name)) 
[08:27:53.875]                               next
[08:27:53.875]                             invokeRestart(restart)
[08:27:53.875]                             muffled <- TRUE
[08:27:53.875]                             break
[08:27:53.875]                           }
[08:27:53.875]                         }
[08:27:53.875]                       }
[08:27:53.875]                       invisible(muffled)
[08:27:53.875]                     }
[08:27:53.875]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.875]                   }
[08:27:53.875]                 }
[08:27:53.875]             }
[08:27:53.875]         }))
[08:27:53.875]     }, error = function(ex) {
[08:27:53.875]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.875]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.875]                 ...future.rng), started = ...future.startTime, 
[08:27:53.875]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.875]             version = "1.8"), class = "FutureResult")
[08:27:53.875]     }, finally = {
[08:27:53.875]         if (!identical(...future.workdir, getwd())) 
[08:27:53.875]             setwd(...future.workdir)
[08:27:53.875]         {
[08:27:53.875]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.875]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.875]             }
[08:27:53.875]             base::options(...future.oldOptions)
[08:27:53.875]             if (.Platform$OS.type == "windows") {
[08:27:53.875]                 old_names <- names(...future.oldEnvVars)
[08:27:53.875]                 envs <- base::Sys.getenv()
[08:27:53.875]                 names <- names(envs)
[08:27:53.875]                 common <- intersect(names, old_names)
[08:27:53.875]                 added <- setdiff(names, old_names)
[08:27:53.875]                 removed <- setdiff(old_names, names)
[08:27:53.875]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.875]                   envs[common]]
[08:27:53.875]                 NAMES <- toupper(changed)
[08:27:53.875]                 args <- list()
[08:27:53.875]                 for (kk in seq_along(NAMES)) {
[08:27:53.875]                   name <- changed[[kk]]
[08:27:53.875]                   NAME <- NAMES[[kk]]
[08:27:53.875]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.875]                     next
[08:27:53.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.875]                 }
[08:27:53.875]                 NAMES <- toupper(added)
[08:27:53.875]                 for (kk in seq_along(NAMES)) {
[08:27:53.875]                   name <- added[[kk]]
[08:27:53.875]                   NAME <- NAMES[[kk]]
[08:27:53.875]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.875]                     next
[08:27:53.875]                   args[[name]] <- ""
[08:27:53.875]                 }
[08:27:53.875]                 NAMES <- toupper(removed)
[08:27:53.875]                 for (kk in seq_along(NAMES)) {
[08:27:53.875]                   name <- removed[[kk]]
[08:27:53.875]                   NAME <- NAMES[[kk]]
[08:27:53.875]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.875]                     next
[08:27:53.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.875]                 }
[08:27:53.875]                 if (length(args) > 0) 
[08:27:53.875]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.875]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.875]             }
[08:27:53.875]             else {
[08:27:53.875]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.875]             }
[08:27:53.875]             {
[08:27:53.875]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.875]                   0L) {
[08:27:53.875]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.875]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.875]                   base::options(opts)
[08:27:53.875]                 }
[08:27:53.875]                 {
[08:27:53.875]                   {
[08:27:53.875]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.875]                     NULL
[08:27:53.875]                   }
[08:27:53.875]                   options(future.plan = NULL)
[08:27:53.875]                   if (is.na(NA_character_)) 
[08:27:53.875]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.875]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.875]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.875]                     .init = FALSE)
[08:27:53.875]                 }
[08:27:53.875]             }
[08:27:53.875]         }
[08:27:53.875]     })
[08:27:53.875]     if (TRUE) {
[08:27:53.875]         base::sink(type = "output", split = FALSE)
[08:27:53.875]         if (TRUE) {
[08:27:53.875]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.875]         }
[08:27:53.875]         else {
[08:27:53.875]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.875]         }
[08:27:53.875]         base::close(...future.stdout)
[08:27:53.875]         ...future.stdout <- NULL
[08:27:53.875]     }
[08:27:53.875]     ...future.result$conditions <- ...future.conditions
[08:27:53.875]     ...future.result$finished <- base::Sys.time()
[08:27:53.875]     ...future.result
[08:27:53.875] }
[08:27:53.877] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:53.888] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.888] - Validating connection of MultisessionFuture
[08:27:53.888] - received message: FutureResult
[08:27:53.889] - Received FutureResult
[08:27:53.889] - Erased future from FutureRegistry
[08:27:53.889] result() for ClusterFuture ...
[08:27:53.889] - result already collected: FutureResult
[08:27:53.889] result() for ClusterFuture ... done
[08:27:53.889] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.889] result() for ClusterFuture ...
[08:27:53.889] - result already collected: FutureResult
[08:27:53.889] result() for ClusterFuture ... done
[08:27:53.889] result() for ClusterFuture ...
[08:27:53.889] - result already collected: FutureResult
[08:27:53.889] result() for ClusterFuture ... done
[08:27:53.891] MultisessionFuture started
[08:27:53.891] - Launch lazy future ... done
[08:27:53.891] run() for ‘MultisessionFuture’ ... done
<environment: 0x55d862f51480> 
<environment: 0x55d85f3109c0> 
[08:27:53.898] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.898] - Validating connection of MultisessionFuture
[08:27:53.898] - received message: FutureResult
[08:27:53.899] - Received FutureResult
[08:27:53.899] - Erased future from FutureRegistry
[08:27:53.899] result() for ClusterFuture ...
[08:27:53.899] - result already collected: FutureResult
[08:27:53.899] result() for ClusterFuture ... done
[08:27:53.899] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[08:27:53.911] resolve() on environment ...
[08:27:53.911]  recursive: 0
[08:27:53.911]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[08:27:53.912] signalConditionsASAP(numeric, pos=1) ...
[08:27:53.912] - nx: 4
[08:27:53.912] - relay: TRUE
[08:27:53.912] - stdout: TRUE
[08:27:53.912] - signal: TRUE
[08:27:53.912] - resignal: FALSE
[08:27:53.912] - force: TRUE
[08:27:53.912] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.912] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.912]  - until=2
[08:27:53.912]  - relaying element #2
[08:27:53.912] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.913] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.913] signalConditionsASAP(NULL, pos=1) ... done
[08:27:53.913]  length: 3 (resolved future 1)
[08:27:53.913] Future #2
[08:27:53.913] result() for ClusterFuture ...
[08:27:53.913] - result already collected: FutureResult
[08:27:53.913] result() for ClusterFuture ... done
[08:27:53.913] result() for ClusterFuture ...
[08:27:53.913] - result already collected: FutureResult
[08:27:53.913] result() for ClusterFuture ... done
[08:27:53.914] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:53.914] - nx: 4
[08:27:53.914] - relay: TRUE
[08:27:53.914] - stdout: TRUE
[08:27:53.914] - signal: TRUE
[08:27:53.914] - resignal: FALSE
[08:27:53.914] - force: TRUE
[08:27:53.914] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[08:27:53.914] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[08:27:53.914]  - until=2
[08:27:53.914]  - relaying element #2
[08:27:53.914] result() for ClusterFuture ...
[08:27:53.914] - result already collected: FutureResult
[08:27:53.915] result() for ClusterFuture ... done
[08:27:53.915] result() for ClusterFuture ...
[08:27:53.915] - result already collected: FutureResult
[08:27:53.915] result() for ClusterFuture ... done
[08:27:53.915] result() for ClusterFuture ...
[08:27:53.915] - result already collected: FutureResult
[08:27:53.915] result() for ClusterFuture ... done
[08:27:53.915] result() for ClusterFuture ...
[08:27:53.915] - result already collected: FutureResult
[08:27:53.915] result() for ClusterFuture ... done
[08:27:53.915] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.915] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.916] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:53.916]  length: 2 (resolved future 2)
[08:27:53.916] Future #3
[08:27:53.916] result() for ClusterFuture ...
[08:27:53.916] - result already collected: FutureResult
[08:27:53.916] result() for ClusterFuture ... done
[08:27:53.916] result() for ClusterFuture ...
[08:27:53.916] - result already collected: FutureResult
[08:27:53.916] result() for ClusterFuture ... done
[08:27:53.916] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:53.916] - nx: 4
[08:27:53.916] - relay: TRUE
[08:27:53.917] - stdout: TRUE
[08:27:53.917] - signal: TRUE
[08:27:53.917] - resignal: FALSE
[08:27:53.917] - force: TRUE
[08:27:53.917] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[08:27:53.917] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[08:27:53.917]  - until=3
[08:27:53.917]  - relaying element #3
[08:27:53.917] result() for ClusterFuture ...
[08:27:53.917] - result already collected: FutureResult
[08:27:53.917] result() for ClusterFuture ... done
[08:27:53.917] result() for ClusterFuture ...
[08:27:53.918] - result already collected: FutureResult
[08:27:53.918] result() for ClusterFuture ... done
[08:27:53.918] result() for ClusterFuture ...
[08:27:53.918] - result already collected: FutureResult
[08:27:53.918] result() for ClusterFuture ... done
[08:27:53.918] result() for ClusterFuture ...
[08:27:53.918] - result already collected: FutureResult
[08:27:53.918] result() for ClusterFuture ... done
[08:27:53.918] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.918] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.918] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:53.918]  length: 1 (resolved future 3)
[08:27:53.940] receiveMessageFromWorker() for ClusterFuture ...
[08:27:53.940] - Validating connection of MultisessionFuture
[08:27:53.940] - received message: FutureResult
[08:27:53.940] - Received FutureResult
[08:27:53.940] - Erased future from FutureRegistry
[08:27:53.940] result() for ClusterFuture ...
[08:27:53.940] - result already collected: FutureResult
[08:27:53.940] result() for ClusterFuture ... done
[08:27:53.941] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:53.941] Future #4
[08:27:53.941] result() for ClusterFuture ...
[08:27:53.941] - result already collected: FutureResult
[08:27:53.941] result() for ClusterFuture ... done
[08:27:53.941] result() for ClusterFuture ...
[08:27:53.941] - result already collected: FutureResult
[08:27:53.941] result() for ClusterFuture ... done
[08:27:53.941] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:53.941] - nx: 4
[08:27:53.941] - relay: TRUE
[08:27:53.941] - stdout: TRUE
[08:27:53.942] - signal: TRUE
[08:27:53.942] - resignal: FALSE
[08:27:53.942] - force: TRUE
[08:27:53.942] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[08:27:53.942] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[08:27:53.942]  - until=4
[08:27:53.942]  - relaying element #4
[08:27:53.942] result() for ClusterFuture ...
[08:27:53.942] - result already collected: FutureResult
[08:27:53.942] result() for ClusterFuture ... done
[08:27:53.942] result() for ClusterFuture ...
[08:27:53.942] - result already collected: FutureResult
[08:27:53.943] result() for ClusterFuture ... done
[08:27:53.943] result() for ClusterFuture ...
[08:27:53.943] - result already collected: FutureResult
[08:27:53.943] result() for ClusterFuture ... done
[08:27:53.943] result() for ClusterFuture ...
[08:27:53.943] - result already collected: FutureResult
[08:27:53.943] result() for ClusterFuture ... done
[08:27:53.943] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.943] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.943] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:53.943]  length: 0 (resolved future 4)
[08:27:53.943] Relaying remaining futures
[08:27:53.944] signalConditionsASAP(NULL, pos=0) ...
[08:27:53.944] - nx: 4
[08:27:53.944] - relay: TRUE
[08:27:53.944] - stdout: TRUE
[08:27:53.944] - signal: TRUE
[08:27:53.944] - resignal: FALSE
[08:27:53.944] - force: TRUE
[08:27:53.944] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.944] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[08:27:53.944] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[08:27:53.944] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[08:27:53.944] signalConditionsASAP(NULL, pos=0) ... done
[08:27:53.945] resolve() on environment ... DONE
[08:27:53.945] result() for ClusterFuture ...
[08:27:53.945] - result already collected: FutureResult
[08:27:53.945] result() for ClusterFuture ... done
[08:27:53.945] result() for ClusterFuture ...
[08:27:53.945] - result already collected: FutureResult
[08:27:53.945] result() for ClusterFuture ... done
[08:27:53.945] result() for ClusterFuture ...
[08:27:53.945] - result already collected: FutureResult
[08:27:53.945] result() for ClusterFuture ... done
[08:27:53.945] result() for ClusterFuture ...
[08:27:53.945] - result already collected: FutureResult
[08:27:53.946] result() for ClusterFuture ... done
[08:27:53.946] result() for ClusterFuture ...
[08:27:53.946] - result already collected: FutureResult
[08:27:53.946] result() for ClusterFuture ... done
[08:27:53.946] result() for ClusterFuture ...
[08:27:53.946] - result already collected: FutureResult
[08:27:53.946] result() for ClusterFuture ... done
<environment: 0x55d85f330bd0> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[08:27:53.947] plan(): Setting new future strategy stack:
[08:27:53.947] List of future strategies:
[08:27:53.947] 1. multicore:
[08:27:53.947]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:53.947]    - tweaked: FALSE
[08:27:53.947]    - call: plan(strategy)
[08:27:53.949] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[08:27:53.950] getGlobalsAndPackages() ...
[08:27:53.950] Searching for globals...
[08:27:53.950] 
[08:27:53.950] Searching for globals ... DONE
[08:27:53.950] - globals: [0] <none>
[08:27:53.951] getGlobalsAndPackages() ... DONE
[08:27:53.951] run() for ‘Future’ ...
[08:27:53.951] - state: ‘created’
[08:27:53.951] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.954] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.954] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:53.954]   - Field: ‘label’
[08:27:53.954]   - Field: ‘local’
[08:27:53.954]   - Field: ‘owner’
[08:27:53.954]   - Field: ‘envir’
[08:27:53.954]   - Field: ‘workers’
[08:27:53.955]   - Field: ‘packages’
[08:27:53.955]   - Field: ‘gc’
[08:27:53.955]   - Field: ‘job’
[08:27:53.955]   - Field: ‘conditions’
[08:27:53.955]   - Field: ‘expr’
[08:27:53.955]   - Field: ‘uuid’
[08:27:53.955]   - Field: ‘seed’
[08:27:53.955]   - Field: ‘version’
[08:27:53.956]   - Field: ‘result’
[08:27:53.956]   - Field: ‘asynchronous’
[08:27:53.956]   - Field: ‘calls’
[08:27:53.956]   - Field: ‘globals’
[08:27:53.956]   - Field: ‘stdout’
[08:27:53.956]   - Field: ‘earlySignal’
[08:27:53.956]   - Field: ‘lazy’
[08:27:53.956]   - Field: ‘state’
[08:27:53.956] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:53.957] - Launch lazy future ...
[08:27:53.957] Packages needed by the future expression (n = 0): <none>
[08:27:53.957] Packages needed by future strategies (n = 0): <none>
[08:27:53.958] {
[08:27:53.958]     {
[08:27:53.958]         {
[08:27:53.958]             ...future.startTime <- base::Sys.time()
[08:27:53.958]             {
[08:27:53.958]                 {
[08:27:53.958]                   {
[08:27:53.958]                     {
[08:27:53.958]                       base::local({
[08:27:53.958]                         has_future <- base::requireNamespace("future", 
[08:27:53.958]                           quietly = TRUE)
[08:27:53.958]                         if (has_future) {
[08:27:53.958]                           ns <- base::getNamespace("future")
[08:27:53.958]                           version <- ns[[".package"]][["version"]]
[08:27:53.958]                           if (is.null(version)) 
[08:27:53.958]                             version <- utils::packageVersion("future")
[08:27:53.958]                         }
[08:27:53.958]                         else {
[08:27:53.958]                           version <- NULL
[08:27:53.958]                         }
[08:27:53.958]                         if (!has_future || version < "1.8.0") {
[08:27:53.958]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.958]                             "", base::R.version$version.string), 
[08:27:53.958]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.958]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.958]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.958]                               "release", "version")], collapse = " "), 
[08:27:53.958]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.958]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.958]                             info)
[08:27:53.958]                           info <- base::paste(info, collapse = "; ")
[08:27:53.958]                           if (!has_future) {
[08:27:53.958]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.958]                               info)
[08:27:53.958]                           }
[08:27:53.958]                           else {
[08:27:53.958]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.958]                               info, version)
[08:27:53.958]                           }
[08:27:53.958]                           base::stop(msg)
[08:27:53.958]                         }
[08:27:53.958]                       })
[08:27:53.958]                     }
[08:27:53.958]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.958]                     base::options(mc.cores = 1L)
[08:27:53.958]                   }
[08:27:53.958]                   ...future.strategy.old <- future::plan("list")
[08:27:53.958]                   options(future.plan = NULL)
[08:27:53.958]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.958]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.958]                 }
[08:27:53.958]                 ...future.workdir <- getwd()
[08:27:53.958]             }
[08:27:53.958]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.958]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.958]         }
[08:27:53.958]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.958]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.958]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.958]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.958]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.958]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.958]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.958]             base::names(...future.oldOptions))
[08:27:53.958]     }
[08:27:53.958]     if (FALSE) {
[08:27:53.958]     }
[08:27:53.958]     else {
[08:27:53.958]         if (TRUE) {
[08:27:53.958]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.958]                 open = "w")
[08:27:53.958]         }
[08:27:53.958]         else {
[08:27:53.958]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.958]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.958]         }
[08:27:53.958]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.958]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.958]             base::sink(type = "output", split = FALSE)
[08:27:53.958]             base::close(...future.stdout)
[08:27:53.958]         }, add = TRUE)
[08:27:53.958]     }
[08:27:53.958]     ...future.frame <- base::sys.nframe()
[08:27:53.958]     ...future.conditions <- base::list()
[08:27:53.958]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.958]     if (FALSE) {
[08:27:53.958]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.958]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.958]     }
[08:27:53.958]     ...future.result <- base::tryCatch({
[08:27:53.958]         base::withCallingHandlers({
[08:27:53.958]             ...future.value <- base::withVisible(base::local({
[08:27:53.958]                 withCallingHandlers({
[08:27:53.958]                   2
[08:27:53.958]                 }, immediateCondition = function(cond) {
[08:27:53.958]                   save_rds <- function (object, pathname, ...) 
[08:27:53.958]                   {
[08:27:53.958]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:53.958]                     if (file_test("-f", pathname_tmp)) {
[08:27:53.958]                       fi_tmp <- file.info(pathname_tmp)
[08:27:53.958]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:53.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:53.958]                         fi_tmp[["mtime"]])
[08:27:53.958]                     }
[08:27:53.958]                     tryCatch({
[08:27:53.958]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:53.958]                     }, error = function(ex) {
[08:27:53.958]                       msg <- conditionMessage(ex)
[08:27:53.958]                       fi_tmp <- file.info(pathname_tmp)
[08:27:53.958]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:53.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:53.958]                         fi_tmp[["mtime"]], msg)
[08:27:53.958]                       ex$message <- msg
[08:27:53.958]                       stop(ex)
[08:27:53.958]                     })
[08:27:53.958]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:53.958]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:53.958]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:53.958]                       fi_tmp <- file.info(pathname_tmp)
[08:27:53.958]                       fi <- file.info(pathname)
[08:27:53.958]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:53.958]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:53.958]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:53.958]                         fi[["size"]], fi[["mtime"]])
[08:27:53.958]                       stop(msg)
[08:27:53.958]                     }
[08:27:53.958]                     invisible(pathname)
[08:27:53.958]                   }
[08:27:53.958]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:53.958]                     rootPath = tempdir()) 
[08:27:53.958]                   {
[08:27:53.958]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:53.958]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:53.958]                       tmpdir = path, fileext = ".rds")
[08:27:53.958]                     save_rds(obj, file)
[08:27:53.958]                   }
[08:27:53.958]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:53.958]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.958]                   {
[08:27:53.958]                     inherits <- base::inherits
[08:27:53.958]                     invokeRestart <- base::invokeRestart
[08:27:53.958]                     is.null <- base::is.null
[08:27:53.958]                     muffled <- FALSE
[08:27:53.958]                     if (inherits(cond, "message")) {
[08:27:53.958]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.958]                       if (muffled) 
[08:27:53.958]                         invokeRestart("muffleMessage")
[08:27:53.958]                     }
[08:27:53.958]                     else if (inherits(cond, "warning")) {
[08:27:53.958]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.958]                       if (muffled) 
[08:27:53.958]                         invokeRestart("muffleWarning")
[08:27:53.958]                     }
[08:27:53.958]                     else if (inherits(cond, "condition")) {
[08:27:53.958]                       if (!is.null(pattern)) {
[08:27:53.958]                         computeRestarts <- base::computeRestarts
[08:27:53.958]                         grepl <- base::grepl
[08:27:53.958]                         restarts <- computeRestarts(cond)
[08:27:53.958]                         for (restart in restarts) {
[08:27:53.958]                           name <- restart$name
[08:27:53.958]                           if (is.null(name)) 
[08:27:53.958]                             next
[08:27:53.958]                           if (!grepl(pattern, name)) 
[08:27:53.958]                             next
[08:27:53.958]                           invokeRestart(restart)
[08:27:53.958]                           muffled <- TRUE
[08:27:53.958]                           break
[08:27:53.958]                         }
[08:27:53.958]                       }
[08:27:53.958]                     }
[08:27:53.958]                     invisible(muffled)
[08:27:53.958]                   }
[08:27:53.958]                   muffleCondition(cond)
[08:27:53.958]                 })
[08:27:53.958]             }))
[08:27:53.958]             future::FutureResult(value = ...future.value$value, 
[08:27:53.958]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.958]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.958]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.958]                     ...future.globalenv.names))
[08:27:53.958]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.958]         }, condition = base::local({
[08:27:53.958]             c <- base::c
[08:27:53.958]             inherits <- base::inherits
[08:27:53.958]             invokeRestart <- base::invokeRestart
[08:27:53.958]             length <- base::length
[08:27:53.958]             list <- base::list
[08:27:53.958]             seq.int <- base::seq.int
[08:27:53.958]             signalCondition <- base::signalCondition
[08:27:53.958]             sys.calls <- base::sys.calls
[08:27:53.958]             `[[` <- base::`[[`
[08:27:53.958]             `+` <- base::`+`
[08:27:53.958]             `<<-` <- base::`<<-`
[08:27:53.958]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.958]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.958]                   3L)]
[08:27:53.958]             }
[08:27:53.958]             function(cond) {
[08:27:53.958]                 is_error <- inherits(cond, "error")
[08:27:53.958]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.958]                   NULL)
[08:27:53.958]                 if (is_error) {
[08:27:53.958]                   sessionInformation <- function() {
[08:27:53.958]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.958]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.958]                       search = base::search(), system = base::Sys.info())
[08:27:53.958]                   }
[08:27:53.958]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.958]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.958]                     cond$call), session = sessionInformation(), 
[08:27:53.958]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.958]                   signalCondition(cond)
[08:27:53.958]                 }
[08:27:53.958]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.958]                 "immediateCondition"))) {
[08:27:53.958]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.958]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.958]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.958]                   if (TRUE && !signal) {
[08:27:53.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.958]                     {
[08:27:53.958]                       inherits <- base::inherits
[08:27:53.958]                       invokeRestart <- base::invokeRestart
[08:27:53.958]                       is.null <- base::is.null
[08:27:53.958]                       muffled <- FALSE
[08:27:53.958]                       if (inherits(cond, "message")) {
[08:27:53.958]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.958]                         if (muffled) 
[08:27:53.958]                           invokeRestart("muffleMessage")
[08:27:53.958]                       }
[08:27:53.958]                       else if (inherits(cond, "warning")) {
[08:27:53.958]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.958]                         if (muffled) 
[08:27:53.958]                           invokeRestart("muffleWarning")
[08:27:53.958]                       }
[08:27:53.958]                       else if (inherits(cond, "condition")) {
[08:27:53.958]                         if (!is.null(pattern)) {
[08:27:53.958]                           computeRestarts <- base::computeRestarts
[08:27:53.958]                           grepl <- base::grepl
[08:27:53.958]                           restarts <- computeRestarts(cond)
[08:27:53.958]                           for (restart in restarts) {
[08:27:53.958]                             name <- restart$name
[08:27:53.958]                             if (is.null(name)) 
[08:27:53.958]                               next
[08:27:53.958]                             if (!grepl(pattern, name)) 
[08:27:53.958]                               next
[08:27:53.958]                             invokeRestart(restart)
[08:27:53.958]                             muffled <- TRUE
[08:27:53.958]                             break
[08:27:53.958]                           }
[08:27:53.958]                         }
[08:27:53.958]                       }
[08:27:53.958]                       invisible(muffled)
[08:27:53.958]                     }
[08:27:53.958]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.958]                   }
[08:27:53.958]                 }
[08:27:53.958]                 else {
[08:27:53.958]                   if (TRUE) {
[08:27:53.958]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.958]                     {
[08:27:53.958]                       inherits <- base::inherits
[08:27:53.958]                       invokeRestart <- base::invokeRestart
[08:27:53.958]                       is.null <- base::is.null
[08:27:53.958]                       muffled <- FALSE
[08:27:53.958]                       if (inherits(cond, "message")) {
[08:27:53.958]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.958]                         if (muffled) 
[08:27:53.958]                           invokeRestart("muffleMessage")
[08:27:53.958]                       }
[08:27:53.958]                       else if (inherits(cond, "warning")) {
[08:27:53.958]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.958]                         if (muffled) 
[08:27:53.958]                           invokeRestart("muffleWarning")
[08:27:53.958]                       }
[08:27:53.958]                       else if (inherits(cond, "condition")) {
[08:27:53.958]                         if (!is.null(pattern)) {
[08:27:53.958]                           computeRestarts <- base::computeRestarts
[08:27:53.958]                           grepl <- base::grepl
[08:27:53.958]                           restarts <- computeRestarts(cond)
[08:27:53.958]                           for (restart in restarts) {
[08:27:53.958]                             name <- restart$name
[08:27:53.958]                             if (is.null(name)) 
[08:27:53.958]                               next
[08:27:53.958]                             if (!grepl(pattern, name)) 
[08:27:53.958]                               next
[08:27:53.958]                             invokeRestart(restart)
[08:27:53.958]                             muffled <- TRUE
[08:27:53.958]                             break
[08:27:53.958]                           }
[08:27:53.958]                         }
[08:27:53.958]                       }
[08:27:53.958]                       invisible(muffled)
[08:27:53.958]                     }
[08:27:53.958]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.958]                   }
[08:27:53.958]                 }
[08:27:53.958]             }
[08:27:53.958]         }))
[08:27:53.958]     }, error = function(ex) {
[08:27:53.958]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.958]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.958]                 ...future.rng), started = ...future.startTime, 
[08:27:53.958]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.958]             version = "1.8"), class = "FutureResult")
[08:27:53.958]     }, finally = {
[08:27:53.958]         if (!identical(...future.workdir, getwd())) 
[08:27:53.958]             setwd(...future.workdir)
[08:27:53.958]         {
[08:27:53.958]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.958]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.958]             }
[08:27:53.958]             base::options(...future.oldOptions)
[08:27:53.958]             if (.Platform$OS.type == "windows") {
[08:27:53.958]                 old_names <- names(...future.oldEnvVars)
[08:27:53.958]                 envs <- base::Sys.getenv()
[08:27:53.958]                 names <- names(envs)
[08:27:53.958]                 common <- intersect(names, old_names)
[08:27:53.958]                 added <- setdiff(names, old_names)
[08:27:53.958]                 removed <- setdiff(old_names, names)
[08:27:53.958]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.958]                   envs[common]]
[08:27:53.958]                 NAMES <- toupper(changed)
[08:27:53.958]                 args <- list()
[08:27:53.958]                 for (kk in seq_along(NAMES)) {
[08:27:53.958]                   name <- changed[[kk]]
[08:27:53.958]                   NAME <- NAMES[[kk]]
[08:27:53.958]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.958]                     next
[08:27:53.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.958]                 }
[08:27:53.958]                 NAMES <- toupper(added)
[08:27:53.958]                 for (kk in seq_along(NAMES)) {
[08:27:53.958]                   name <- added[[kk]]
[08:27:53.958]                   NAME <- NAMES[[kk]]
[08:27:53.958]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.958]                     next
[08:27:53.958]                   args[[name]] <- ""
[08:27:53.958]                 }
[08:27:53.958]                 NAMES <- toupper(removed)
[08:27:53.958]                 for (kk in seq_along(NAMES)) {
[08:27:53.958]                   name <- removed[[kk]]
[08:27:53.958]                   NAME <- NAMES[[kk]]
[08:27:53.958]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.958]                     next
[08:27:53.958]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.958]                 }
[08:27:53.958]                 if (length(args) > 0) 
[08:27:53.958]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.958]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.958]             }
[08:27:53.958]             else {
[08:27:53.958]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.958]             }
[08:27:53.958]             {
[08:27:53.958]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.958]                   0L) {
[08:27:53.958]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.958]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.958]                   base::options(opts)
[08:27:53.958]                 }
[08:27:53.958]                 {
[08:27:53.958]                   {
[08:27:53.958]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.958]                     NULL
[08:27:53.958]                   }
[08:27:53.958]                   options(future.plan = NULL)
[08:27:53.958]                   if (is.na(NA_character_)) 
[08:27:53.958]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.958]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.958]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.958]                     .init = FALSE)
[08:27:53.958]                 }
[08:27:53.958]             }
[08:27:53.958]         }
[08:27:53.958]     })
[08:27:53.958]     if (TRUE) {
[08:27:53.958]         base::sink(type = "output", split = FALSE)
[08:27:53.958]         if (TRUE) {
[08:27:53.958]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.958]         }
[08:27:53.958]         else {
[08:27:53.958]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.958]         }
[08:27:53.958]         base::close(...future.stdout)
[08:27:53.958]         ...future.stdout <- NULL
[08:27:53.958]     }
[08:27:53.958]     ...future.result$conditions <- ...future.conditions
[08:27:53.958]     ...future.result$finished <- base::Sys.time()
[08:27:53.958]     ...future.result
[08:27:53.958] }
[08:27:53.961] requestCore(): workers = 2
[08:27:53.964] MulticoreFuture started
[08:27:53.964] - Launch lazy future ... done
[08:27:53.964] run() for ‘MulticoreFuture’ ... done
[08:27:53.965] getGlobalsAndPackages() ...
[08:27:53.965] plan(): Setting new future strategy stack:
[08:27:53.965] Searching for globals...
[08:27:53.966] 
[08:27:53.965] List of future strategies:
[08:27:53.965] 1. sequential:
[08:27:53.965]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:53.965]    - tweaked: FALSE
[08:27:53.965]    - call: NULL
[08:27:53.966] Searching for globals ... DONE
[08:27:53.966] plan(): nbrOfWorkers() = 1
[08:27:53.966] - globals: [0] <none>
[08:27:53.966] getGlobalsAndPackages() ... DONE
[08:27:53.967] run() for ‘Future’ ...
[08:27:53.967] - state: ‘created’
[08:27:53.967] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.968] plan(): Setting new future strategy stack:
[08:27:53.968] List of future strategies:
[08:27:53.968] 1. multicore:
[08:27:53.968]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:53.968]    - tweaked: FALSE
[08:27:53.968]    - call: plan(strategy)
[08:27:53.971] plan(): nbrOfWorkers() = 2
[08:27:53.971] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.971] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:53.971]   - Field: ‘label’
[08:27:53.971]   - Field: ‘local’
[08:27:53.971]   - Field: ‘owner’
[08:27:53.972]   - Field: ‘envir’
[08:27:53.972]   - Field: ‘workers’
[08:27:53.972]   - Field: ‘packages’
[08:27:53.972]   - Field: ‘gc’
[08:27:53.972]   - Field: ‘job’
[08:27:53.972]   - Field: ‘conditions’
[08:27:53.972]   - Field: ‘expr’
[08:27:53.972]   - Field: ‘uuid’
[08:27:53.973]   - Field: ‘seed’
[08:27:53.973]   - Field: ‘version’
[08:27:53.973]   - Field: ‘result’
[08:27:53.973]   - Field: ‘asynchronous’
[08:27:53.973]   - Field: ‘calls’
[08:27:53.973]   - Field: ‘globals’
[08:27:53.973]   - Field: ‘stdout’
[08:27:53.973]   - Field: ‘earlySignal’
[08:27:53.974]   - Field: ‘lazy’
[08:27:53.974]   - Field: ‘state’
[08:27:53.974] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:53.974] - Launch lazy future ...
[08:27:53.974] Packages needed by the future expression (n = 0): <none>
[08:27:53.975] Packages needed by future strategies (n = 0): <none>
[08:27:53.975] {
[08:27:53.975]     {
[08:27:53.975]         {
[08:27:53.975]             ...future.startTime <- base::Sys.time()
[08:27:53.975]             {
[08:27:53.975]                 {
[08:27:53.975]                   {
[08:27:53.975]                     {
[08:27:53.975]                       base::local({
[08:27:53.975]                         has_future <- base::requireNamespace("future", 
[08:27:53.975]                           quietly = TRUE)
[08:27:53.975]                         if (has_future) {
[08:27:53.975]                           ns <- base::getNamespace("future")
[08:27:53.975]                           version <- ns[[".package"]][["version"]]
[08:27:53.975]                           if (is.null(version)) 
[08:27:53.975]                             version <- utils::packageVersion("future")
[08:27:53.975]                         }
[08:27:53.975]                         else {
[08:27:53.975]                           version <- NULL
[08:27:53.975]                         }
[08:27:53.975]                         if (!has_future || version < "1.8.0") {
[08:27:53.975]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.975]                             "", base::R.version$version.string), 
[08:27:53.975]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.975]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.975]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.975]                               "release", "version")], collapse = " "), 
[08:27:53.975]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.975]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.975]                             info)
[08:27:53.975]                           info <- base::paste(info, collapse = "; ")
[08:27:53.975]                           if (!has_future) {
[08:27:53.975]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.975]                               info)
[08:27:53.975]                           }
[08:27:53.975]                           else {
[08:27:53.975]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.975]                               info, version)
[08:27:53.975]                           }
[08:27:53.975]                           base::stop(msg)
[08:27:53.975]                         }
[08:27:53.975]                       })
[08:27:53.975]                     }
[08:27:53.975]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.975]                     base::options(mc.cores = 1L)
[08:27:53.975]                   }
[08:27:53.975]                   ...future.strategy.old <- future::plan("list")
[08:27:53.975]                   options(future.plan = NULL)
[08:27:53.975]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.975]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.975]                 }
[08:27:53.975]                 ...future.workdir <- getwd()
[08:27:53.975]             }
[08:27:53.975]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.975]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.975]         }
[08:27:53.975]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.975]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.975]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.975]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.975]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.975]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.975]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.975]             base::names(...future.oldOptions))
[08:27:53.975]     }
[08:27:53.975]     if (FALSE) {
[08:27:53.975]     }
[08:27:53.975]     else {
[08:27:53.975]         if (TRUE) {
[08:27:53.975]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.975]                 open = "w")
[08:27:53.975]         }
[08:27:53.975]         else {
[08:27:53.975]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.975]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.975]         }
[08:27:53.975]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.975]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.975]             base::sink(type = "output", split = FALSE)
[08:27:53.975]             base::close(...future.stdout)
[08:27:53.975]         }, add = TRUE)
[08:27:53.975]     }
[08:27:53.975]     ...future.frame <- base::sys.nframe()
[08:27:53.975]     ...future.conditions <- base::list()
[08:27:53.975]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.975]     if (FALSE) {
[08:27:53.975]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.975]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.975]     }
[08:27:53.975]     ...future.result <- base::tryCatch({
[08:27:53.975]         base::withCallingHandlers({
[08:27:53.975]             ...future.value <- base::withVisible(base::local({
[08:27:53.975]                 withCallingHandlers({
[08:27:53.975]                   NULL
[08:27:53.975]                 }, immediateCondition = function(cond) {
[08:27:53.975]                   save_rds <- function (object, pathname, ...) 
[08:27:53.975]                   {
[08:27:53.975]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:53.975]                     if (file_test("-f", pathname_tmp)) {
[08:27:53.975]                       fi_tmp <- file.info(pathname_tmp)
[08:27:53.975]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:53.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:53.975]                         fi_tmp[["mtime"]])
[08:27:53.975]                     }
[08:27:53.975]                     tryCatch({
[08:27:53.975]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:53.975]                     }, error = function(ex) {
[08:27:53.975]                       msg <- conditionMessage(ex)
[08:27:53.975]                       fi_tmp <- file.info(pathname_tmp)
[08:27:53.975]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:53.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:53.975]                         fi_tmp[["mtime"]], msg)
[08:27:53.975]                       ex$message <- msg
[08:27:53.975]                       stop(ex)
[08:27:53.975]                     })
[08:27:53.975]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:53.975]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:53.975]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:53.975]                       fi_tmp <- file.info(pathname_tmp)
[08:27:53.975]                       fi <- file.info(pathname)
[08:27:53.975]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:53.975]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:53.975]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:53.975]                         fi[["size"]], fi[["mtime"]])
[08:27:53.975]                       stop(msg)
[08:27:53.975]                     }
[08:27:53.975]                     invisible(pathname)
[08:27:53.975]                   }
[08:27:53.975]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:53.975]                     rootPath = tempdir()) 
[08:27:53.975]                   {
[08:27:53.975]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:53.975]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:53.975]                       tmpdir = path, fileext = ".rds")
[08:27:53.975]                     save_rds(obj, file)
[08:27:53.975]                   }
[08:27:53.975]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:53.975]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.975]                   {
[08:27:53.975]                     inherits <- base::inherits
[08:27:53.975]                     invokeRestart <- base::invokeRestart
[08:27:53.975]                     is.null <- base::is.null
[08:27:53.975]                     muffled <- FALSE
[08:27:53.975]                     if (inherits(cond, "message")) {
[08:27:53.975]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.975]                       if (muffled) 
[08:27:53.975]                         invokeRestart("muffleMessage")
[08:27:53.975]                     }
[08:27:53.975]                     else if (inherits(cond, "warning")) {
[08:27:53.975]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.975]                       if (muffled) 
[08:27:53.975]                         invokeRestart("muffleWarning")
[08:27:53.975]                     }
[08:27:53.975]                     else if (inherits(cond, "condition")) {
[08:27:53.975]                       if (!is.null(pattern)) {
[08:27:53.975]                         computeRestarts <- base::computeRestarts
[08:27:53.975]                         grepl <- base::grepl
[08:27:53.975]                         restarts <- computeRestarts(cond)
[08:27:53.975]                         for (restart in restarts) {
[08:27:53.975]                           name <- restart$name
[08:27:53.975]                           if (is.null(name)) 
[08:27:53.975]                             next
[08:27:53.975]                           if (!grepl(pattern, name)) 
[08:27:53.975]                             next
[08:27:53.975]                           invokeRestart(restart)
[08:27:53.975]                           muffled <- TRUE
[08:27:53.975]                           break
[08:27:53.975]                         }
[08:27:53.975]                       }
[08:27:53.975]                     }
[08:27:53.975]                     invisible(muffled)
[08:27:53.975]                   }
[08:27:53.975]                   muffleCondition(cond)
[08:27:53.975]                 })
[08:27:53.975]             }))
[08:27:53.975]             future::FutureResult(value = ...future.value$value, 
[08:27:53.975]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.975]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.975]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.975]                     ...future.globalenv.names))
[08:27:53.975]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.975]         }, condition = base::local({
[08:27:53.975]             c <- base::c
[08:27:53.975]             inherits <- base::inherits
[08:27:53.975]             invokeRestart <- base::invokeRestart
[08:27:53.975]             length <- base::length
[08:27:53.975]             list <- base::list
[08:27:53.975]             seq.int <- base::seq.int
[08:27:53.975]             signalCondition <- base::signalCondition
[08:27:53.975]             sys.calls <- base::sys.calls
[08:27:53.975]             `[[` <- base::`[[`
[08:27:53.975]             `+` <- base::`+`
[08:27:53.975]             `<<-` <- base::`<<-`
[08:27:53.975]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.975]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.975]                   3L)]
[08:27:53.975]             }
[08:27:53.975]             function(cond) {
[08:27:53.975]                 is_error <- inherits(cond, "error")
[08:27:53.975]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.975]                   NULL)
[08:27:53.975]                 if (is_error) {
[08:27:53.975]                   sessionInformation <- function() {
[08:27:53.975]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.975]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.975]                       search = base::search(), system = base::Sys.info())
[08:27:53.975]                   }
[08:27:53.975]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.975]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.975]                     cond$call), session = sessionInformation(), 
[08:27:53.975]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.975]                   signalCondition(cond)
[08:27:53.975]                 }
[08:27:53.975]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.975]                 "immediateCondition"))) {
[08:27:53.975]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.975]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.975]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.975]                   if (TRUE && !signal) {
[08:27:53.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.975]                     {
[08:27:53.975]                       inherits <- base::inherits
[08:27:53.975]                       invokeRestart <- base::invokeRestart
[08:27:53.975]                       is.null <- base::is.null
[08:27:53.975]                       muffled <- FALSE
[08:27:53.975]                       if (inherits(cond, "message")) {
[08:27:53.975]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.975]                         if (muffled) 
[08:27:53.975]                           invokeRestart("muffleMessage")
[08:27:53.975]                       }
[08:27:53.975]                       else if (inherits(cond, "warning")) {
[08:27:53.975]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.975]                         if (muffled) 
[08:27:53.975]                           invokeRestart("muffleWarning")
[08:27:53.975]                       }
[08:27:53.975]                       else if (inherits(cond, "condition")) {
[08:27:53.975]                         if (!is.null(pattern)) {
[08:27:53.975]                           computeRestarts <- base::computeRestarts
[08:27:53.975]                           grepl <- base::grepl
[08:27:53.975]                           restarts <- computeRestarts(cond)
[08:27:53.975]                           for (restart in restarts) {
[08:27:53.975]                             name <- restart$name
[08:27:53.975]                             if (is.null(name)) 
[08:27:53.975]                               next
[08:27:53.975]                             if (!grepl(pattern, name)) 
[08:27:53.975]                               next
[08:27:53.975]                             invokeRestart(restart)
[08:27:53.975]                             muffled <- TRUE
[08:27:53.975]                             break
[08:27:53.975]                           }
[08:27:53.975]                         }
[08:27:53.975]                       }
[08:27:53.975]                       invisible(muffled)
[08:27:53.975]                     }
[08:27:53.975]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.975]                   }
[08:27:53.975]                 }
[08:27:53.975]                 else {
[08:27:53.975]                   if (TRUE) {
[08:27:53.975]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.975]                     {
[08:27:53.975]                       inherits <- base::inherits
[08:27:53.975]                       invokeRestart <- base::invokeRestart
[08:27:53.975]                       is.null <- base::is.null
[08:27:53.975]                       muffled <- FALSE
[08:27:53.975]                       if (inherits(cond, "message")) {
[08:27:53.975]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.975]                         if (muffled) 
[08:27:53.975]                           invokeRestart("muffleMessage")
[08:27:53.975]                       }
[08:27:53.975]                       else if (inherits(cond, "warning")) {
[08:27:53.975]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.975]                         if (muffled) 
[08:27:53.975]                           invokeRestart("muffleWarning")
[08:27:53.975]                       }
[08:27:53.975]                       else if (inherits(cond, "condition")) {
[08:27:53.975]                         if (!is.null(pattern)) {
[08:27:53.975]                           computeRestarts <- base::computeRestarts
[08:27:53.975]                           grepl <- base::grepl
[08:27:53.975]                           restarts <- computeRestarts(cond)
[08:27:53.975]                           for (restart in restarts) {
[08:27:53.975]                             name <- restart$name
[08:27:53.975]                             if (is.null(name)) 
[08:27:53.975]                               next
[08:27:53.975]                             if (!grepl(pattern, name)) 
[08:27:53.975]                               next
[08:27:53.975]                             invokeRestart(restart)
[08:27:53.975]                             muffled <- TRUE
[08:27:53.975]                             break
[08:27:53.975]                           }
[08:27:53.975]                         }
[08:27:53.975]                       }
[08:27:53.975]                       invisible(muffled)
[08:27:53.975]                     }
[08:27:53.975]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.975]                   }
[08:27:53.975]                 }
[08:27:53.975]             }
[08:27:53.975]         }))
[08:27:53.975]     }, error = function(ex) {
[08:27:53.975]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.975]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.975]                 ...future.rng), started = ...future.startTime, 
[08:27:53.975]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.975]             version = "1.8"), class = "FutureResult")
[08:27:53.975]     }, finally = {
[08:27:53.975]         if (!identical(...future.workdir, getwd())) 
[08:27:53.975]             setwd(...future.workdir)
[08:27:53.975]         {
[08:27:53.975]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.975]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.975]             }
[08:27:53.975]             base::options(...future.oldOptions)
[08:27:53.975]             if (.Platform$OS.type == "windows") {
[08:27:53.975]                 old_names <- names(...future.oldEnvVars)
[08:27:53.975]                 envs <- base::Sys.getenv()
[08:27:53.975]                 names <- names(envs)
[08:27:53.975]                 common <- intersect(names, old_names)
[08:27:53.975]                 added <- setdiff(names, old_names)
[08:27:53.975]                 removed <- setdiff(old_names, names)
[08:27:53.975]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.975]                   envs[common]]
[08:27:53.975]                 NAMES <- toupper(changed)
[08:27:53.975]                 args <- list()
[08:27:53.975]                 for (kk in seq_along(NAMES)) {
[08:27:53.975]                   name <- changed[[kk]]
[08:27:53.975]                   NAME <- NAMES[[kk]]
[08:27:53.975]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.975]                     next
[08:27:53.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.975]                 }
[08:27:53.975]                 NAMES <- toupper(added)
[08:27:53.975]                 for (kk in seq_along(NAMES)) {
[08:27:53.975]                   name <- added[[kk]]
[08:27:53.975]                   NAME <- NAMES[[kk]]
[08:27:53.975]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.975]                     next
[08:27:53.975]                   args[[name]] <- ""
[08:27:53.975]                 }
[08:27:53.975]                 NAMES <- toupper(removed)
[08:27:53.975]                 for (kk in seq_along(NAMES)) {
[08:27:53.975]                   name <- removed[[kk]]
[08:27:53.975]                   NAME <- NAMES[[kk]]
[08:27:53.975]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.975]                     next
[08:27:53.975]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.975]                 }
[08:27:53.975]                 if (length(args) > 0) 
[08:27:53.975]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.975]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.975]             }
[08:27:53.975]             else {
[08:27:53.975]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.975]             }
[08:27:53.975]             {
[08:27:53.975]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.975]                   0L) {
[08:27:53.975]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.975]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.975]                   base::options(opts)
[08:27:53.975]                 }
[08:27:53.975]                 {
[08:27:53.975]                   {
[08:27:53.975]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.975]                     NULL
[08:27:53.975]                   }
[08:27:53.975]                   options(future.plan = NULL)
[08:27:53.975]                   if (is.na(NA_character_)) 
[08:27:53.975]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.975]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.975]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.975]                     .init = FALSE)
[08:27:53.975]                 }
[08:27:53.975]             }
[08:27:53.975]         }
[08:27:53.975]     })
[08:27:53.975]     if (TRUE) {
[08:27:53.975]         base::sink(type = "output", split = FALSE)
[08:27:53.975]         if (TRUE) {
[08:27:53.975]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.975]         }
[08:27:53.975]         else {
[08:27:53.975]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.975]         }
[08:27:53.975]         base::close(...future.stdout)
[08:27:53.975]         ...future.stdout <- NULL
[08:27:53.975]     }
[08:27:53.975]     ...future.result$conditions <- ...future.conditions
[08:27:53.975]     ...future.result$finished <- base::Sys.time()
[08:27:53.975]     ...future.result
[08:27:53.975] }
[08:27:53.979] requestCore(): workers = 2
[08:27:53.982] MulticoreFuture started
[08:27:53.982] - Launch lazy future ... done
[08:27:53.983] run() for ‘MulticoreFuture’ ... done
[08:27:53.983] plan(): Setting new future strategy stack:
[08:27:53.984] getGlobalsAndPackages() ...
[08:27:53.984] Searching for globals...
[08:27:53.983] List of future strategies:
[08:27:53.983] 1. sequential:
[08:27:53.983]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:53.983]    - tweaked: FALSE
[08:27:53.983]    - call: NULL
[08:27:53.985] plan(): nbrOfWorkers() = 1
[08:27:53.986] - globals found: [1] ‘{’
[08:27:53.986] Searching for globals ... DONE
[08:27:53.987] Resolving globals: FALSE
[08:27:53.987] 
[08:27:53.988] 
[08:27:53.988] getGlobalsAndPackages() ... DONE
[08:27:53.988] plan(): Setting new future strategy stack:
[08:27:53.988] run() for ‘Future’ ...
[08:27:53.988] List of future strategies:
[08:27:53.988] 1. multicore:
[08:27:53.988]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:53.988]    - tweaked: FALSE
[08:27:53.988]    - call: plan(strategy)
[08:27:53.989] - state: ‘created’
[08:27:53.989] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:53.992] plan(): nbrOfWorkers() = 2
[08:27:53.993] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:53.993] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:53.993]   - Field: ‘label’
[08:27:53.993]   - Field: ‘local’
[08:27:53.994]   - Field: ‘owner’
[08:27:53.994]   - Field: ‘envir’
[08:27:53.994]   - Field: ‘workers’
[08:27:53.994]   - Field: ‘packages’
[08:27:53.994]   - Field: ‘gc’
[08:27:53.994]   - Field: ‘job’
[08:27:53.994]   - Field: ‘conditions’
[08:27:53.994]   - Field: ‘expr’
[08:27:53.995]   - Field: ‘uuid’
[08:27:53.995]   - Field: ‘seed’
[08:27:53.995]   - Field: ‘version’
[08:27:53.995]   - Field: ‘result’
[08:27:53.995]   - Field: ‘asynchronous’
[08:27:53.995]   - Field: ‘calls’
[08:27:53.995]   - Field: ‘globals’
[08:27:53.995]   - Field: ‘stdout’
[08:27:53.996]   - Field: ‘earlySignal’
[08:27:53.996]   - Field: ‘lazy’
[08:27:53.996]   - Field: ‘state’
[08:27:53.996] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:53.996] - Launch lazy future ...
[08:27:53.997] Packages needed by the future expression (n = 0): <none>
[08:27:53.997] Packages needed by future strategies (n = 0): <none>
[08:27:53.997] {
[08:27:53.997]     {
[08:27:53.997]         {
[08:27:53.997]             ...future.startTime <- base::Sys.time()
[08:27:53.997]             {
[08:27:53.997]                 {
[08:27:53.997]                   {
[08:27:53.997]                     {
[08:27:53.997]                       base::local({
[08:27:53.997]                         has_future <- base::requireNamespace("future", 
[08:27:53.997]                           quietly = TRUE)
[08:27:53.997]                         if (has_future) {
[08:27:53.997]                           ns <- base::getNamespace("future")
[08:27:53.997]                           version <- ns[[".package"]][["version"]]
[08:27:53.997]                           if (is.null(version)) 
[08:27:53.997]                             version <- utils::packageVersion("future")
[08:27:53.997]                         }
[08:27:53.997]                         else {
[08:27:53.997]                           version <- NULL
[08:27:53.997]                         }
[08:27:53.997]                         if (!has_future || version < "1.8.0") {
[08:27:53.997]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:53.997]                             "", base::R.version$version.string), 
[08:27:53.997]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:53.997]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:53.997]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:53.997]                               "release", "version")], collapse = " "), 
[08:27:53.997]                             hostname = base::Sys.info()[["nodename"]])
[08:27:53.997]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:53.997]                             info)
[08:27:53.997]                           info <- base::paste(info, collapse = "; ")
[08:27:53.997]                           if (!has_future) {
[08:27:53.997]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:53.997]                               info)
[08:27:53.997]                           }
[08:27:53.997]                           else {
[08:27:53.997]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:53.997]                               info, version)
[08:27:53.997]                           }
[08:27:53.997]                           base::stop(msg)
[08:27:53.997]                         }
[08:27:53.997]                       })
[08:27:53.997]                     }
[08:27:53.997]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:53.997]                     base::options(mc.cores = 1L)
[08:27:53.997]                   }
[08:27:53.997]                   ...future.strategy.old <- future::plan("list")
[08:27:53.997]                   options(future.plan = NULL)
[08:27:53.997]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.997]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:53.997]                 }
[08:27:53.997]                 ...future.workdir <- getwd()
[08:27:53.997]             }
[08:27:53.997]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:53.997]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:53.997]         }
[08:27:53.997]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:53.997]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:53.997]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:53.997]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:53.997]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:53.997]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:53.997]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:53.997]             base::names(...future.oldOptions))
[08:27:53.997]     }
[08:27:53.997]     if (FALSE) {
[08:27:53.997]     }
[08:27:53.997]     else {
[08:27:53.997]         if (TRUE) {
[08:27:53.997]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:53.997]                 open = "w")
[08:27:53.997]         }
[08:27:53.997]         else {
[08:27:53.997]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:53.997]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:53.997]         }
[08:27:53.997]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:53.997]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:53.997]             base::sink(type = "output", split = FALSE)
[08:27:53.997]             base::close(...future.stdout)
[08:27:53.997]         }, add = TRUE)
[08:27:53.997]     }
[08:27:53.997]     ...future.frame <- base::sys.nframe()
[08:27:53.997]     ...future.conditions <- base::list()
[08:27:53.997]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:53.997]     if (FALSE) {
[08:27:53.997]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:53.997]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:53.997]     }
[08:27:53.997]     ...future.result <- base::tryCatch({
[08:27:53.997]         base::withCallingHandlers({
[08:27:53.997]             ...future.value <- base::withVisible(base::local({
[08:27:53.997]                 withCallingHandlers({
[08:27:53.997]                   {
[08:27:53.997]                     4
[08:27:53.997]                   }
[08:27:53.997]                 }, immediateCondition = function(cond) {
[08:27:53.997]                   save_rds <- function (object, pathname, ...) 
[08:27:53.997]                   {
[08:27:53.997]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:53.997]                     if (file_test("-f", pathname_tmp)) {
[08:27:53.997]                       fi_tmp <- file.info(pathname_tmp)
[08:27:53.997]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:53.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:53.997]                         fi_tmp[["mtime"]])
[08:27:53.997]                     }
[08:27:53.997]                     tryCatch({
[08:27:53.997]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:53.997]                     }, error = function(ex) {
[08:27:53.997]                       msg <- conditionMessage(ex)
[08:27:53.997]                       fi_tmp <- file.info(pathname_tmp)
[08:27:53.997]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:53.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:53.997]                         fi_tmp[["mtime"]], msg)
[08:27:53.997]                       ex$message <- msg
[08:27:53.997]                       stop(ex)
[08:27:53.997]                     })
[08:27:53.997]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:53.997]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:53.997]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:53.997]                       fi_tmp <- file.info(pathname_tmp)
[08:27:53.997]                       fi <- file.info(pathname)
[08:27:53.997]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:53.997]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:53.997]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:53.997]                         fi[["size"]], fi[["mtime"]])
[08:27:53.997]                       stop(msg)
[08:27:53.997]                     }
[08:27:53.997]                     invisible(pathname)
[08:27:53.997]                   }
[08:27:53.997]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:53.997]                     rootPath = tempdir()) 
[08:27:53.997]                   {
[08:27:53.997]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:53.997]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:53.997]                       tmpdir = path, fileext = ".rds")
[08:27:53.997]                     save_rds(obj, file)
[08:27:53.997]                   }
[08:27:53.997]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:53.997]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.997]                   {
[08:27:53.997]                     inherits <- base::inherits
[08:27:53.997]                     invokeRestart <- base::invokeRestart
[08:27:53.997]                     is.null <- base::is.null
[08:27:53.997]                     muffled <- FALSE
[08:27:53.997]                     if (inherits(cond, "message")) {
[08:27:53.997]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:53.997]                       if (muffled) 
[08:27:53.997]                         invokeRestart("muffleMessage")
[08:27:53.997]                     }
[08:27:53.997]                     else if (inherits(cond, "warning")) {
[08:27:53.997]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:53.997]                       if (muffled) 
[08:27:53.997]                         invokeRestart("muffleWarning")
[08:27:53.997]                     }
[08:27:53.997]                     else if (inherits(cond, "condition")) {
[08:27:53.997]                       if (!is.null(pattern)) {
[08:27:53.997]                         computeRestarts <- base::computeRestarts
[08:27:53.997]                         grepl <- base::grepl
[08:27:53.997]                         restarts <- computeRestarts(cond)
[08:27:53.997]                         for (restart in restarts) {
[08:27:53.997]                           name <- restart$name
[08:27:53.997]                           if (is.null(name)) 
[08:27:53.997]                             next
[08:27:53.997]                           if (!grepl(pattern, name)) 
[08:27:53.997]                             next
[08:27:53.997]                           invokeRestart(restart)
[08:27:53.997]                           muffled <- TRUE
[08:27:53.997]                           break
[08:27:53.997]                         }
[08:27:53.997]                       }
[08:27:53.997]                     }
[08:27:53.997]                     invisible(muffled)
[08:27:53.997]                   }
[08:27:53.997]                   muffleCondition(cond)
[08:27:53.997]                 })
[08:27:53.997]             }))
[08:27:53.997]             future::FutureResult(value = ...future.value$value, 
[08:27:53.997]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.997]                   ...future.rng), globalenv = if (FALSE) 
[08:27:53.997]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:53.997]                     ...future.globalenv.names))
[08:27:53.997]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:53.997]         }, condition = base::local({
[08:27:53.997]             c <- base::c
[08:27:53.997]             inherits <- base::inherits
[08:27:53.997]             invokeRestart <- base::invokeRestart
[08:27:53.997]             length <- base::length
[08:27:53.997]             list <- base::list
[08:27:53.997]             seq.int <- base::seq.int
[08:27:53.997]             signalCondition <- base::signalCondition
[08:27:53.997]             sys.calls <- base::sys.calls
[08:27:53.997]             `[[` <- base::`[[`
[08:27:53.997]             `+` <- base::`+`
[08:27:53.997]             `<<-` <- base::`<<-`
[08:27:53.997]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:53.997]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:53.997]                   3L)]
[08:27:53.997]             }
[08:27:53.997]             function(cond) {
[08:27:53.997]                 is_error <- inherits(cond, "error")
[08:27:53.997]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:53.997]                   NULL)
[08:27:53.997]                 if (is_error) {
[08:27:53.997]                   sessionInformation <- function() {
[08:27:53.997]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:53.997]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:53.997]                       search = base::search(), system = base::Sys.info())
[08:27:53.997]                   }
[08:27:53.997]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.997]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:53.997]                     cond$call), session = sessionInformation(), 
[08:27:53.997]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:53.997]                   signalCondition(cond)
[08:27:53.997]                 }
[08:27:53.997]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:53.997]                 "immediateCondition"))) {
[08:27:53.997]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:53.997]                   ...future.conditions[[length(...future.conditions) + 
[08:27:53.997]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:53.997]                   if (TRUE && !signal) {
[08:27:53.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.997]                     {
[08:27:53.997]                       inherits <- base::inherits
[08:27:53.997]                       invokeRestart <- base::invokeRestart
[08:27:53.997]                       is.null <- base::is.null
[08:27:53.997]                       muffled <- FALSE
[08:27:53.997]                       if (inherits(cond, "message")) {
[08:27:53.997]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.997]                         if (muffled) 
[08:27:53.997]                           invokeRestart("muffleMessage")
[08:27:53.997]                       }
[08:27:53.997]                       else if (inherits(cond, "warning")) {
[08:27:53.997]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.997]                         if (muffled) 
[08:27:53.997]                           invokeRestart("muffleWarning")
[08:27:53.997]                       }
[08:27:53.997]                       else if (inherits(cond, "condition")) {
[08:27:53.997]                         if (!is.null(pattern)) {
[08:27:53.997]                           computeRestarts <- base::computeRestarts
[08:27:53.997]                           grepl <- base::grepl
[08:27:53.997]                           restarts <- computeRestarts(cond)
[08:27:53.997]                           for (restart in restarts) {
[08:27:53.997]                             name <- restart$name
[08:27:53.997]                             if (is.null(name)) 
[08:27:53.997]                               next
[08:27:53.997]                             if (!grepl(pattern, name)) 
[08:27:53.997]                               next
[08:27:53.997]                             invokeRestart(restart)
[08:27:53.997]                             muffled <- TRUE
[08:27:53.997]                             break
[08:27:53.997]                           }
[08:27:53.997]                         }
[08:27:53.997]                       }
[08:27:53.997]                       invisible(muffled)
[08:27:53.997]                     }
[08:27:53.997]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.997]                   }
[08:27:53.997]                 }
[08:27:53.997]                 else {
[08:27:53.997]                   if (TRUE) {
[08:27:53.997]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:53.997]                     {
[08:27:53.997]                       inherits <- base::inherits
[08:27:53.997]                       invokeRestart <- base::invokeRestart
[08:27:53.997]                       is.null <- base::is.null
[08:27:53.997]                       muffled <- FALSE
[08:27:53.997]                       if (inherits(cond, "message")) {
[08:27:53.997]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:53.997]                         if (muffled) 
[08:27:53.997]                           invokeRestart("muffleMessage")
[08:27:53.997]                       }
[08:27:53.997]                       else if (inherits(cond, "warning")) {
[08:27:53.997]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:53.997]                         if (muffled) 
[08:27:53.997]                           invokeRestart("muffleWarning")
[08:27:53.997]                       }
[08:27:53.997]                       else if (inherits(cond, "condition")) {
[08:27:53.997]                         if (!is.null(pattern)) {
[08:27:53.997]                           computeRestarts <- base::computeRestarts
[08:27:53.997]                           grepl <- base::grepl
[08:27:53.997]                           restarts <- computeRestarts(cond)
[08:27:53.997]                           for (restart in restarts) {
[08:27:53.997]                             name <- restart$name
[08:27:53.997]                             if (is.null(name)) 
[08:27:53.997]                               next
[08:27:53.997]                             if (!grepl(pattern, name)) 
[08:27:53.997]                               next
[08:27:53.997]                             invokeRestart(restart)
[08:27:53.997]                             muffled <- TRUE
[08:27:53.997]                             break
[08:27:53.997]                           }
[08:27:53.997]                         }
[08:27:53.997]                       }
[08:27:53.997]                       invisible(muffled)
[08:27:53.997]                     }
[08:27:53.997]                     muffleCondition(cond, pattern = "^muffle")
[08:27:53.997]                   }
[08:27:53.997]                 }
[08:27:53.997]             }
[08:27:53.997]         }))
[08:27:53.997]     }, error = function(ex) {
[08:27:53.997]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:53.997]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:53.997]                 ...future.rng), started = ...future.startTime, 
[08:27:53.997]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:53.997]             version = "1.8"), class = "FutureResult")
[08:27:53.997]     }, finally = {
[08:27:53.997]         if (!identical(...future.workdir, getwd())) 
[08:27:53.997]             setwd(...future.workdir)
[08:27:53.997]         {
[08:27:53.997]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:53.997]                 ...future.oldOptions$nwarnings <- NULL
[08:27:53.997]             }
[08:27:53.997]             base::options(...future.oldOptions)
[08:27:53.997]             if (.Platform$OS.type == "windows") {
[08:27:53.997]                 old_names <- names(...future.oldEnvVars)
[08:27:53.997]                 envs <- base::Sys.getenv()
[08:27:53.997]                 names <- names(envs)
[08:27:53.997]                 common <- intersect(names, old_names)
[08:27:53.997]                 added <- setdiff(names, old_names)
[08:27:53.997]                 removed <- setdiff(old_names, names)
[08:27:53.997]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:53.997]                   envs[common]]
[08:27:53.997]                 NAMES <- toupper(changed)
[08:27:53.997]                 args <- list()
[08:27:53.997]                 for (kk in seq_along(NAMES)) {
[08:27:53.997]                   name <- changed[[kk]]
[08:27:53.997]                   NAME <- NAMES[[kk]]
[08:27:53.997]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.997]                     next
[08:27:53.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.997]                 }
[08:27:53.997]                 NAMES <- toupper(added)
[08:27:53.997]                 for (kk in seq_along(NAMES)) {
[08:27:53.997]                   name <- added[[kk]]
[08:27:53.997]                   NAME <- NAMES[[kk]]
[08:27:53.997]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.997]                     next
[08:27:53.997]                   args[[name]] <- ""
[08:27:53.997]                 }
[08:27:53.997]                 NAMES <- toupper(removed)
[08:27:53.997]                 for (kk in seq_along(NAMES)) {
[08:27:53.997]                   name <- removed[[kk]]
[08:27:53.997]                   NAME <- NAMES[[kk]]
[08:27:53.997]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:53.997]                     next
[08:27:53.997]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:53.997]                 }
[08:27:53.997]                 if (length(args) > 0) 
[08:27:53.997]                   base::do.call(base::Sys.setenv, args = args)
[08:27:53.997]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:53.997]             }
[08:27:53.997]             else {
[08:27:53.997]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:53.997]             }
[08:27:53.997]             {
[08:27:53.997]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:53.997]                   0L) {
[08:27:53.997]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:53.997]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:53.997]                   base::options(opts)
[08:27:53.997]                 }
[08:27:53.997]                 {
[08:27:53.997]                   {
[08:27:53.997]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:53.997]                     NULL
[08:27:53.997]                   }
[08:27:53.997]                   options(future.plan = NULL)
[08:27:53.997]                   if (is.na(NA_character_)) 
[08:27:53.997]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:53.997]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:53.997]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:53.997]                     .init = FALSE)
[08:27:53.997]                 }
[08:27:53.997]             }
[08:27:53.997]         }
[08:27:53.997]     })
[08:27:53.997]     if (TRUE) {
[08:27:53.997]         base::sink(type = "output", split = FALSE)
[08:27:53.997]         if (TRUE) {
[08:27:53.997]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:53.997]         }
[08:27:53.997]         else {
[08:27:53.997]             ...future.result["stdout"] <- base::list(NULL)
[08:27:53.997]         }
[08:27:53.997]         base::close(...future.stdout)
[08:27:53.997]         ...future.stdout <- NULL
[08:27:53.997]     }
[08:27:53.997]     ...future.result$conditions <- ...future.conditions
[08:27:53.997]     ...future.result$finished <- base::Sys.time()
[08:27:53.997]     ...future.result
[08:27:53.997] }
[08:27:54.001] requestCore(): workers = 2
[08:27:54.001] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:54.012] result() for MulticoreFuture ...
[08:27:54.013] result() for MulticoreFuture ...
[08:27:54.013] result() for MulticoreFuture ... done
[08:27:54.013] result() for MulticoreFuture ... done
[08:27:54.013] result() for MulticoreFuture ...
[08:27:54.014] result() for MulticoreFuture ... done
[08:27:54.017] MulticoreFuture started
[08:27:54.017] - Launch lazy future ... done
[08:27:54.017] run() for ‘MulticoreFuture’ ... done
[08:27:54.018] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55d862500448> 
[08:27:54.018] List of future strategies:
[08:27:54.018] 1. sequential:
[08:27:54.018]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.018]    - tweaked: FALSE
[08:27:54.018]    - call: NULL
[08:27:54.019] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55d86303e950> 
[08:27:54.021] plan(): Setting new future strategy stack:
[08:27:54.021] List of future strategies:
[08:27:54.021] 1. multicore:
[08:27:54.021]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.021]    - tweaked: FALSE
[08:27:54.021]    - call: plan(strategy)
[08:27:54.025] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:54.027] resolve() on list environment ...
[08:27:54.028]  recursive: 0
[08:27:54.029]  length: 6
[08:27:54.029]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:54.041] signalConditionsASAP(numeric, pos=1) ...
[08:27:54.042] - nx: 6
[08:27:54.043] - relay: TRUE
[08:27:54.043] - stdout: TRUE
[08:27:54.044] - signal: TRUE
[08:27:54.044] - resignal: FALSE
[08:27:54.045] - force: TRUE
[08:27:54.045] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.045] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.046]  - until=2
[08:27:54.046]  - relaying element #2
[08:27:54.046] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.046] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.047] signalConditionsASAP(NULL, pos=1) ... done
[08:27:54.047]  length: 5 (resolved future 1)
[08:27:54.047] Future #2
[08:27:54.047] result() for MulticoreFuture ...
[08:27:54.047] result() for MulticoreFuture ... done
[08:27:54.048] result() for MulticoreFuture ...
[08:27:54.048] result() for MulticoreFuture ... done
[08:27:54.048] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:54.048] - nx: 6
[08:27:54.048] - relay: TRUE
[08:27:54.048] - stdout: TRUE
[08:27:54.049] - signal: TRUE
[08:27:54.049] - resignal: FALSE
[08:27:54.049] - force: TRUE
[08:27:54.049] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.049] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.049]  - until=2
[08:27:54.050]  - relaying element #2
[08:27:54.050] result() for MulticoreFuture ...
[08:27:54.050] result() for MulticoreFuture ... done
[08:27:54.050] result() for MulticoreFuture ...
[08:27:54.050] result() for MulticoreFuture ... done
[08:27:54.050] result() for MulticoreFuture ...
[08:27:54.051] result() for MulticoreFuture ... done
[08:27:54.051] result() for MulticoreFuture ...
[08:27:54.051] result() for MulticoreFuture ... done
[08:27:54.051] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.051] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.051] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:54.052]  length: 4 (resolved future 2)
[08:27:54.052] Future #3
[08:27:54.052] result() for MulticoreFuture ...
[08:27:54.053] result() for MulticoreFuture ...
[08:27:54.053] result() for MulticoreFuture ... done
[08:27:54.054] result() for MulticoreFuture ... done
[08:27:54.054] result() for MulticoreFuture ...
[08:27:54.054] result() for MulticoreFuture ... done
[08:27:54.054] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:54.054] - nx: 6
[08:27:54.054] - relay: TRUE
[08:27:54.055] - stdout: TRUE
[08:27:54.055] - signal: TRUE
[08:27:54.055] - resignal: FALSE
[08:27:54.055] - force: TRUE
[08:27:54.055] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.055] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.055]  - until=3
[08:27:54.055]  - relaying element #3
[08:27:54.056] result() for MulticoreFuture ...
[08:27:54.056] result() for MulticoreFuture ... done
[08:27:54.056] result() for MulticoreFuture ...
[08:27:54.056] result() for MulticoreFuture ... done
[08:27:54.056] result() for MulticoreFuture ...
[08:27:54.056] result() for MulticoreFuture ... done
[08:27:54.056] result() for MulticoreFuture ...
[08:27:54.057] result() for MulticoreFuture ... done
[08:27:54.057] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.057] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.057] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:54.057]  length: 3 (resolved future 3)
[08:27:54.058] Future #4
[08:27:54.058] result() for MulticoreFuture ...
[08:27:54.058] result() for MulticoreFuture ...
[08:27:54.059] result() for MulticoreFuture ... done
[08:27:54.059] result() for MulticoreFuture ... done
[08:27:54.059] result() for MulticoreFuture ...
[08:27:54.059] result() for MulticoreFuture ... done
[08:27:54.059] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:54.059] - nx: 6
[08:27:54.059] - relay: TRUE
[08:27:54.060] - stdout: TRUE
[08:27:54.060] - signal: TRUE
[08:27:54.060] - resignal: FALSE
[08:27:54.060] - force: TRUE
[08:27:54.060] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.060] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.060]  - until=4
[08:27:54.060]  - relaying element #4
[08:27:54.060] result() for MulticoreFuture ...
[08:27:54.061] result() for MulticoreFuture ... done
[08:27:54.061] result() for MulticoreFuture ...
[08:27:54.061] result() for MulticoreFuture ... done
[08:27:54.061] result() for MulticoreFuture ...
[08:27:54.061] result() for MulticoreFuture ... done
[08:27:54.061] result() for MulticoreFuture ...
[08:27:54.061] result() for MulticoreFuture ... done
[08:27:54.062] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.062] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.062] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:54.062]  length: 2 (resolved future 4)
[08:27:54.062] signalConditionsASAP(NULL, pos=5) ...
[08:27:54.062] - nx: 6
[08:27:54.062] - relay: TRUE
[08:27:54.062] - stdout: TRUE
[08:27:54.062] - signal: TRUE
[08:27:54.062] - resignal: FALSE
[08:27:54.063] - force: TRUE
[08:27:54.063] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.063] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.063]  - until=6
[08:27:54.063]  - relaying element #6
[08:27:54.063] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.063] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.063] signalConditionsASAP(NULL, pos=5) ... done
[08:27:54.063]  length: 1 (resolved future 5)
[08:27:54.064] signalConditionsASAP(numeric, pos=6) ...
[08:27:54.064] - nx: 6
[08:27:54.064] - relay: TRUE
[08:27:54.064] - stdout: TRUE
[08:27:54.064] - signal: TRUE
[08:27:54.064] - resignal: FALSE
[08:27:54.064] - force: TRUE
[08:27:54.064] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.064] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.064]  - until=6
[08:27:54.064] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.065] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.065] signalConditionsASAP(numeric, pos=6) ... done
[08:27:54.065]  length: 0 (resolved future 6)
[08:27:54.065] Relaying remaining futures
[08:27:54.065] signalConditionsASAP(NULL, pos=0) ...
[08:27:54.065] - nx: 6
[08:27:54.065] - relay: TRUE
[08:27:54.065] - stdout: TRUE
[08:27:54.065] - signal: TRUE
[08:27:54.065] - resignal: FALSE
[08:27:54.065] - force: TRUE
[08:27:54.066] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.066] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:54.066] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.066] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.066] signalConditionsASAP(NULL, pos=0) ... done
[08:27:54.066] resolve() on list environment ... DONE
[08:27:54.066] result() for MulticoreFuture ...
[08:27:54.066] result() for MulticoreFuture ... done
[08:27:54.067] result() for MulticoreFuture ...
[08:27:54.067] result() for MulticoreFuture ... done
[08:27:54.067] result() for MulticoreFuture ...
[08:27:54.067] result() for MulticoreFuture ... done
[08:27:54.067] result() for MulticoreFuture ...
[08:27:54.067] result() for MulticoreFuture ... done
[08:27:54.067] result() for MulticoreFuture ...
[08:27:54.067] result() for MulticoreFuture ... done
[08:27:54.068] result() for MulticoreFuture ...
[08:27:54.068] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d86324d5c8> 
Dimensions: c(1, 6)
[08:27:54.068] getGlobalsAndPackages() ...
[08:27:54.068] Searching for globals...
[08:27:54.069] 
[08:27:54.069] Searching for globals ... DONE
[08:27:54.069] - globals: [0] <none>
[08:27:54.069] getGlobalsAndPackages() ... DONE
[08:27:54.070] run() for ‘Future’ ...
[08:27:54.070] - state: ‘created’
[08:27:54.070] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.072] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.072] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.072]   - Field: ‘label’
[08:27:54.072]   - Field: ‘local’
[08:27:54.072]   - Field: ‘owner’
[08:27:54.073]   - Field: ‘envir’
[08:27:54.073]   - Field: ‘workers’
[08:27:54.073]   - Field: ‘packages’
[08:27:54.073]   - Field: ‘gc’
[08:27:54.073]   - Field: ‘job’
[08:27:54.073]   - Field: ‘conditions’
[08:27:54.073]   - Field: ‘expr’
[08:27:54.073]   - Field: ‘uuid’
[08:27:54.073]   - Field: ‘seed’
[08:27:54.074]   - Field: ‘version’
[08:27:54.074]   - Field: ‘result’
[08:27:54.074]   - Field: ‘asynchronous’
[08:27:54.074]   - Field: ‘calls’
[08:27:54.074]   - Field: ‘globals’
[08:27:54.074]   - Field: ‘stdout’
[08:27:54.074]   - Field: ‘earlySignal’
[08:27:54.074]   - Field: ‘lazy’
[08:27:54.074]   - Field: ‘state’
[08:27:54.075] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.075] - Launch lazy future ...
[08:27:54.075] Packages needed by the future expression (n = 0): <none>
[08:27:54.075] Packages needed by future strategies (n = 0): <none>
[08:27:54.076] {
[08:27:54.076]     {
[08:27:54.076]         {
[08:27:54.076]             ...future.startTime <- base::Sys.time()
[08:27:54.076]             {
[08:27:54.076]                 {
[08:27:54.076]                   {
[08:27:54.076]                     {
[08:27:54.076]                       base::local({
[08:27:54.076]                         has_future <- base::requireNamespace("future", 
[08:27:54.076]                           quietly = TRUE)
[08:27:54.076]                         if (has_future) {
[08:27:54.076]                           ns <- base::getNamespace("future")
[08:27:54.076]                           version <- ns[[".package"]][["version"]]
[08:27:54.076]                           if (is.null(version)) 
[08:27:54.076]                             version <- utils::packageVersion("future")
[08:27:54.076]                         }
[08:27:54.076]                         else {
[08:27:54.076]                           version <- NULL
[08:27:54.076]                         }
[08:27:54.076]                         if (!has_future || version < "1.8.0") {
[08:27:54.076]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.076]                             "", base::R.version$version.string), 
[08:27:54.076]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.076]                               "release", "version")], collapse = " "), 
[08:27:54.076]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.076]                             info)
[08:27:54.076]                           info <- base::paste(info, collapse = "; ")
[08:27:54.076]                           if (!has_future) {
[08:27:54.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.076]                               info)
[08:27:54.076]                           }
[08:27:54.076]                           else {
[08:27:54.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.076]                               info, version)
[08:27:54.076]                           }
[08:27:54.076]                           base::stop(msg)
[08:27:54.076]                         }
[08:27:54.076]                       })
[08:27:54.076]                     }
[08:27:54.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.076]                     base::options(mc.cores = 1L)
[08:27:54.076]                   }
[08:27:54.076]                   ...future.strategy.old <- future::plan("list")
[08:27:54.076]                   options(future.plan = NULL)
[08:27:54.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.076]                 }
[08:27:54.076]                 ...future.workdir <- getwd()
[08:27:54.076]             }
[08:27:54.076]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.076]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.076]         }
[08:27:54.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.076]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.076]             base::names(...future.oldOptions))
[08:27:54.076]     }
[08:27:54.076]     if (FALSE) {
[08:27:54.076]     }
[08:27:54.076]     else {
[08:27:54.076]         if (TRUE) {
[08:27:54.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.076]                 open = "w")
[08:27:54.076]         }
[08:27:54.076]         else {
[08:27:54.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.076]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.076]         }
[08:27:54.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.076]             base::sink(type = "output", split = FALSE)
[08:27:54.076]             base::close(...future.stdout)
[08:27:54.076]         }, add = TRUE)
[08:27:54.076]     }
[08:27:54.076]     ...future.frame <- base::sys.nframe()
[08:27:54.076]     ...future.conditions <- base::list()
[08:27:54.076]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.076]     if (FALSE) {
[08:27:54.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.076]     }
[08:27:54.076]     ...future.result <- base::tryCatch({
[08:27:54.076]         base::withCallingHandlers({
[08:27:54.076]             ...future.value <- base::withVisible(base::local({
[08:27:54.076]                 withCallingHandlers({
[08:27:54.076]                   2
[08:27:54.076]                 }, immediateCondition = function(cond) {
[08:27:54.076]                   save_rds <- function (object, pathname, ...) 
[08:27:54.076]                   {
[08:27:54.076]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.076]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.076]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.076]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.076]                         fi_tmp[["mtime"]])
[08:27:54.076]                     }
[08:27:54.076]                     tryCatch({
[08:27:54.076]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.076]                     }, error = function(ex) {
[08:27:54.076]                       msg <- conditionMessage(ex)
[08:27:54.076]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.076]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.076]                         fi_tmp[["mtime"]], msg)
[08:27:54.076]                       ex$message <- msg
[08:27:54.076]                       stop(ex)
[08:27:54.076]                     })
[08:27:54.076]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.076]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.076]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.076]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.076]                       fi <- file.info(pathname)
[08:27:54.076]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.076]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.076]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.076]                         fi[["size"]], fi[["mtime"]])
[08:27:54.076]                       stop(msg)
[08:27:54.076]                     }
[08:27:54.076]                     invisible(pathname)
[08:27:54.076]                   }
[08:27:54.076]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.076]                     rootPath = tempdir()) 
[08:27:54.076]                   {
[08:27:54.076]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.076]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.076]                       tmpdir = path, fileext = ".rds")
[08:27:54.076]                     save_rds(obj, file)
[08:27:54.076]                   }
[08:27:54.076]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.076]                   {
[08:27:54.076]                     inherits <- base::inherits
[08:27:54.076]                     invokeRestart <- base::invokeRestart
[08:27:54.076]                     is.null <- base::is.null
[08:27:54.076]                     muffled <- FALSE
[08:27:54.076]                     if (inherits(cond, "message")) {
[08:27:54.076]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.076]                       if (muffled) 
[08:27:54.076]                         invokeRestart("muffleMessage")
[08:27:54.076]                     }
[08:27:54.076]                     else if (inherits(cond, "warning")) {
[08:27:54.076]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.076]                       if (muffled) 
[08:27:54.076]                         invokeRestart("muffleWarning")
[08:27:54.076]                     }
[08:27:54.076]                     else if (inherits(cond, "condition")) {
[08:27:54.076]                       if (!is.null(pattern)) {
[08:27:54.076]                         computeRestarts <- base::computeRestarts
[08:27:54.076]                         grepl <- base::grepl
[08:27:54.076]                         restarts <- computeRestarts(cond)
[08:27:54.076]                         for (restart in restarts) {
[08:27:54.076]                           name <- restart$name
[08:27:54.076]                           if (is.null(name)) 
[08:27:54.076]                             next
[08:27:54.076]                           if (!grepl(pattern, name)) 
[08:27:54.076]                             next
[08:27:54.076]                           invokeRestart(restart)
[08:27:54.076]                           muffled <- TRUE
[08:27:54.076]                           break
[08:27:54.076]                         }
[08:27:54.076]                       }
[08:27:54.076]                     }
[08:27:54.076]                     invisible(muffled)
[08:27:54.076]                   }
[08:27:54.076]                   muffleCondition(cond)
[08:27:54.076]                 })
[08:27:54.076]             }))
[08:27:54.076]             future::FutureResult(value = ...future.value$value, 
[08:27:54.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.076]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.076]                     ...future.globalenv.names))
[08:27:54.076]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.076]         }, condition = base::local({
[08:27:54.076]             c <- base::c
[08:27:54.076]             inherits <- base::inherits
[08:27:54.076]             invokeRestart <- base::invokeRestart
[08:27:54.076]             length <- base::length
[08:27:54.076]             list <- base::list
[08:27:54.076]             seq.int <- base::seq.int
[08:27:54.076]             signalCondition <- base::signalCondition
[08:27:54.076]             sys.calls <- base::sys.calls
[08:27:54.076]             `[[` <- base::`[[`
[08:27:54.076]             `+` <- base::`+`
[08:27:54.076]             `<<-` <- base::`<<-`
[08:27:54.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.076]                   3L)]
[08:27:54.076]             }
[08:27:54.076]             function(cond) {
[08:27:54.076]                 is_error <- inherits(cond, "error")
[08:27:54.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.076]                   NULL)
[08:27:54.076]                 if (is_error) {
[08:27:54.076]                   sessionInformation <- function() {
[08:27:54.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.076]                       search = base::search(), system = base::Sys.info())
[08:27:54.076]                   }
[08:27:54.076]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.076]                     cond$call), session = sessionInformation(), 
[08:27:54.076]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.076]                   signalCondition(cond)
[08:27:54.076]                 }
[08:27:54.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.076]                 "immediateCondition"))) {
[08:27:54.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.076]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.076]                   if (TRUE && !signal) {
[08:27:54.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.076]                     {
[08:27:54.076]                       inherits <- base::inherits
[08:27:54.076]                       invokeRestart <- base::invokeRestart
[08:27:54.076]                       is.null <- base::is.null
[08:27:54.076]                       muffled <- FALSE
[08:27:54.076]                       if (inherits(cond, "message")) {
[08:27:54.076]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.076]                         if (muffled) 
[08:27:54.076]                           invokeRestart("muffleMessage")
[08:27:54.076]                       }
[08:27:54.076]                       else if (inherits(cond, "warning")) {
[08:27:54.076]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.076]                         if (muffled) 
[08:27:54.076]                           invokeRestart("muffleWarning")
[08:27:54.076]                       }
[08:27:54.076]                       else if (inherits(cond, "condition")) {
[08:27:54.076]                         if (!is.null(pattern)) {
[08:27:54.076]                           computeRestarts <- base::computeRestarts
[08:27:54.076]                           grepl <- base::grepl
[08:27:54.076]                           restarts <- computeRestarts(cond)
[08:27:54.076]                           for (restart in restarts) {
[08:27:54.076]                             name <- restart$name
[08:27:54.076]                             if (is.null(name)) 
[08:27:54.076]                               next
[08:27:54.076]                             if (!grepl(pattern, name)) 
[08:27:54.076]                               next
[08:27:54.076]                             invokeRestart(restart)
[08:27:54.076]                             muffled <- TRUE
[08:27:54.076]                             break
[08:27:54.076]                           }
[08:27:54.076]                         }
[08:27:54.076]                       }
[08:27:54.076]                       invisible(muffled)
[08:27:54.076]                     }
[08:27:54.076]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.076]                   }
[08:27:54.076]                 }
[08:27:54.076]                 else {
[08:27:54.076]                   if (TRUE) {
[08:27:54.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.076]                     {
[08:27:54.076]                       inherits <- base::inherits
[08:27:54.076]                       invokeRestart <- base::invokeRestart
[08:27:54.076]                       is.null <- base::is.null
[08:27:54.076]                       muffled <- FALSE
[08:27:54.076]                       if (inherits(cond, "message")) {
[08:27:54.076]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.076]                         if (muffled) 
[08:27:54.076]                           invokeRestart("muffleMessage")
[08:27:54.076]                       }
[08:27:54.076]                       else if (inherits(cond, "warning")) {
[08:27:54.076]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.076]                         if (muffled) 
[08:27:54.076]                           invokeRestart("muffleWarning")
[08:27:54.076]                       }
[08:27:54.076]                       else if (inherits(cond, "condition")) {
[08:27:54.076]                         if (!is.null(pattern)) {
[08:27:54.076]                           computeRestarts <- base::computeRestarts
[08:27:54.076]                           grepl <- base::grepl
[08:27:54.076]                           restarts <- computeRestarts(cond)
[08:27:54.076]                           for (restart in restarts) {
[08:27:54.076]                             name <- restart$name
[08:27:54.076]                             if (is.null(name)) 
[08:27:54.076]                               next
[08:27:54.076]                             if (!grepl(pattern, name)) 
[08:27:54.076]                               next
[08:27:54.076]                             invokeRestart(restart)
[08:27:54.076]                             muffled <- TRUE
[08:27:54.076]                             break
[08:27:54.076]                           }
[08:27:54.076]                         }
[08:27:54.076]                       }
[08:27:54.076]                       invisible(muffled)
[08:27:54.076]                     }
[08:27:54.076]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.076]                   }
[08:27:54.076]                 }
[08:27:54.076]             }
[08:27:54.076]         }))
[08:27:54.076]     }, error = function(ex) {
[08:27:54.076]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.076]                 ...future.rng), started = ...future.startTime, 
[08:27:54.076]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.076]             version = "1.8"), class = "FutureResult")
[08:27:54.076]     }, finally = {
[08:27:54.076]         if (!identical(...future.workdir, getwd())) 
[08:27:54.076]             setwd(...future.workdir)
[08:27:54.076]         {
[08:27:54.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.076]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.076]             }
[08:27:54.076]             base::options(...future.oldOptions)
[08:27:54.076]             if (.Platform$OS.type == "windows") {
[08:27:54.076]                 old_names <- names(...future.oldEnvVars)
[08:27:54.076]                 envs <- base::Sys.getenv()
[08:27:54.076]                 names <- names(envs)
[08:27:54.076]                 common <- intersect(names, old_names)
[08:27:54.076]                 added <- setdiff(names, old_names)
[08:27:54.076]                 removed <- setdiff(old_names, names)
[08:27:54.076]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.076]                   envs[common]]
[08:27:54.076]                 NAMES <- toupper(changed)
[08:27:54.076]                 args <- list()
[08:27:54.076]                 for (kk in seq_along(NAMES)) {
[08:27:54.076]                   name <- changed[[kk]]
[08:27:54.076]                   NAME <- NAMES[[kk]]
[08:27:54.076]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.076]                     next
[08:27:54.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.076]                 }
[08:27:54.076]                 NAMES <- toupper(added)
[08:27:54.076]                 for (kk in seq_along(NAMES)) {
[08:27:54.076]                   name <- added[[kk]]
[08:27:54.076]                   NAME <- NAMES[[kk]]
[08:27:54.076]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.076]                     next
[08:27:54.076]                   args[[name]] <- ""
[08:27:54.076]                 }
[08:27:54.076]                 NAMES <- toupper(removed)
[08:27:54.076]                 for (kk in seq_along(NAMES)) {
[08:27:54.076]                   name <- removed[[kk]]
[08:27:54.076]                   NAME <- NAMES[[kk]]
[08:27:54.076]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.076]                     next
[08:27:54.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.076]                 }
[08:27:54.076]                 if (length(args) > 0) 
[08:27:54.076]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.076]             }
[08:27:54.076]             else {
[08:27:54.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.076]             }
[08:27:54.076]             {
[08:27:54.076]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.076]                   0L) {
[08:27:54.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.076]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.076]                   base::options(opts)
[08:27:54.076]                 }
[08:27:54.076]                 {
[08:27:54.076]                   {
[08:27:54.076]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.076]                     NULL
[08:27:54.076]                   }
[08:27:54.076]                   options(future.plan = NULL)
[08:27:54.076]                   if (is.na(NA_character_)) 
[08:27:54.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.076]                     .init = FALSE)
[08:27:54.076]                 }
[08:27:54.076]             }
[08:27:54.076]         }
[08:27:54.076]     })
[08:27:54.076]     if (TRUE) {
[08:27:54.076]         base::sink(type = "output", split = FALSE)
[08:27:54.076]         if (TRUE) {
[08:27:54.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.076]         }
[08:27:54.076]         else {
[08:27:54.076]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.076]         }
[08:27:54.076]         base::close(...future.stdout)
[08:27:54.076]         ...future.stdout <- NULL
[08:27:54.076]     }
[08:27:54.076]     ...future.result$conditions <- ...future.conditions
[08:27:54.076]     ...future.result$finished <- base::Sys.time()
[08:27:54.076]     ...future.result
[08:27:54.076] }
[08:27:54.078] requestCore(): workers = 2
[08:27:54.081] MulticoreFuture started
[08:27:54.082] - Launch lazy future ... done
[08:27:54.082] run() for ‘MulticoreFuture’ ... done
[08:27:54.082] plan(): Setting new future strategy stack:
[08:27:54.083] getGlobalsAndPackages() ...
[08:27:54.083] Searching for globals...
[08:27:54.083] List of future strategies:
[08:27:54.083] 1. sequential:
[08:27:54.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.083]    - tweaked: FALSE
[08:27:54.083]    - call: NULL
[08:27:54.084] plan(): nbrOfWorkers() = 1
[08:27:54.084] 
[08:27:54.084] Searching for globals ... DONE
[08:27:54.084] - globals: [0] <none>
[08:27:54.085] getGlobalsAndPackages() ... DONE
[08:27:54.086] run() for ‘Future’ ...
[08:27:54.086] - state: ‘created’
[08:27:54.086] plan(): Setting new future strategy stack:
[08:27:54.086] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.086] List of future strategies:
[08:27:54.086] 1. multicore:
[08:27:54.086]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.086]    - tweaked: FALSE
[08:27:54.086]    - call: plan(strategy)
[08:27:54.089] plan(): nbrOfWorkers() = 2
[08:27:54.089] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.090] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.090]   - Field: ‘label’
[08:27:54.090]   - Field: ‘local’
[08:27:54.090]   - Field: ‘owner’
[08:27:54.091]   - Field: ‘envir’
[08:27:54.091]   - Field: ‘workers’
[08:27:54.091]   - Field: ‘packages’
[08:27:54.091]   - Field: ‘gc’
[08:27:54.091]   - Field: ‘job’
[08:27:54.091]   - Field: ‘conditions’
[08:27:54.092]   - Field: ‘expr’
[08:27:54.092]   - Field: ‘uuid’
[08:27:54.092]   - Field: ‘seed’
[08:27:54.092]   - Field: ‘version’
[08:27:54.092]   - Field: ‘result’
[08:27:54.092]   - Field: ‘asynchronous’
[08:27:54.093]   - Field: ‘calls’
[08:27:54.093]   - Field: ‘globals’
[08:27:54.093]   - Field: ‘stdout’
[08:27:54.093]   - Field: ‘earlySignal’
[08:27:54.093]   - Field: ‘lazy’
[08:27:54.093]   - Field: ‘state’
[08:27:54.094] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.094] - Launch lazy future ...
[08:27:54.094] Packages needed by the future expression (n = 0): <none>
[08:27:54.095] Packages needed by future strategies (n = 0): <none>
[08:27:54.096] {
[08:27:54.096]     {
[08:27:54.096]         {
[08:27:54.096]             ...future.startTime <- base::Sys.time()
[08:27:54.096]             {
[08:27:54.096]                 {
[08:27:54.096]                   {
[08:27:54.096]                     {
[08:27:54.096]                       base::local({
[08:27:54.096]                         has_future <- base::requireNamespace("future", 
[08:27:54.096]                           quietly = TRUE)
[08:27:54.096]                         if (has_future) {
[08:27:54.096]                           ns <- base::getNamespace("future")
[08:27:54.096]                           version <- ns[[".package"]][["version"]]
[08:27:54.096]                           if (is.null(version)) 
[08:27:54.096]                             version <- utils::packageVersion("future")
[08:27:54.096]                         }
[08:27:54.096]                         else {
[08:27:54.096]                           version <- NULL
[08:27:54.096]                         }
[08:27:54.096]                         if (!has_future || version < "1.8.0") {
[08:27:54.096]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.096]                             "", base::R.version$version.string), 
[08:27:54.096]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.096]                               "release", "version")], collapse = " "), 
[08:27:54.096]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.096]                             info)
[08:27:54.096]                           info <- base::paste(info, collapse = "; ")
[08:27:54.096]                           if (!has_future) {
[08:27:54.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.096]                               info)
[08:27:54.096]                           }
[08:27:54.096]                           else {
[08:27:54.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.096]                               info, version)
[08:27:54.096]                           }
[08:27:54.096]                           base::stop(msg)
[08:27:54.096]                         }
[08:27:54.096]                       })
[08:27:54.096]                     }
[08:27:54.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.096]                     base::options(mc.cores = 1L)
[08:27:54.096]                   }
[08:27:54.096]                   ...future.strategy.old <- future::plan("list")
[08:27:54.096]                   options(future.plan = NULL)
[08:27:54.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.096]                 }
[08:27:54.096]                 ...future.workdir <- getwd()
[08:27:54.096]             }
[08:27:54.096]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.096]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.096]         }
[08:27:54.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.096]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.096]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.096]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.096]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.096]             base::names(...future.oldOptions))
[08:27:54.096]     }
[08:27:54.096]     if (FALSE) {
[08:27:54.096]     }
[08:27:54.096]     else {
[08:27:54.096]         if (TRUE) {
[08:27:54.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.096]                 open = "w")
[08:27:54.096]         }
[08:27:54.096]         else {
[08:27:54.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.096]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.096]         }
[08:27:54.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.096]             base::sink(type = "output", split = FALSE)
[08:27:54.096]             base::close(...future.stdout)
[08:27:54.096]         }, add = TRUE)
[08:27:54.096]     }
[08:27:54.096]     ...future.frame <- base::sys.nframe()
[08:27:54.096]     ...future.conditions <- base::list()
[08:27:54.096]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.096]     if (FALSE) {
[08:27:54.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.096]     }
[08:27:54.096]     ...future.result <- base::tryCatch({
[08:27:54.096]         base::withCallingHandlers({
[08:27:54.096]             ...future.value <- base::withVisible(base::local({
[08:27:54.096]                 withCallingHandlers({
[08:27:54.096]                   NULL
[08:27:54.096]                 }, immediateCondition = function(cond) {
[08:27:54.096]                   save_rds <- function (object, pathname, ...) 
[08:27:54.096]                   {
[08:27:54.096]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.096]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.096]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.096]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.096]                         fi_tmp[["mtime"]])
[08:27:54.096]                     }
[08:27:54.096]                     tryCatch({
[08:27:54.096]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.096]                     }, error = function(ex) {
[08:27:54.096]                       msg <- conditionMessage(ex)
[08:27:54.096]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.096]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.096]                         fi_tmp[["mtime"]], msg)
[08:27:54.096]                       ex$message <- msg
[08:27:54.096]                       stop(ex)
[08:27:54.096]                     })
[08:27:54.096]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.096]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.096]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.096]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.096]                       fi <- file.info(pathname)
[08:27:54.096]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.096]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.096]                         fi[["size"]], fi[["mtime"]])
[08:27:54.096]                       stop(msg)
[08:27:54.096]                     }
[08:27:54.096]                     invisible(pathname)
[08:27:54.096]                   }
[08:27:54.096]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.096]                     rootPath = tempdir()) 
[08:27:54.096]                   {
[08:27:54.096]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.096]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.096]                       tmpdir = path, fileext = ".rds")
[08:27:54.096]                     save_rds(obj, file)
[08:27:54.096]                   }
[08:27:54.096]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.096]                   {
[08:27:54.096]                     inherits <- base::inherits
[08:27:54.096]                     invokeRestart <- base::invokeRestart
[08:27:54.096]                     is.null <- base::is.null
[08:27:54.096]                     muffled <- FALSE
[08:27:54.096]                     if (inherits(cond, "message")) {
[08:27:54.096]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.096]                       if (muffled) 
[08:27:54.096]                         invokeRestart("muffleMessage")
[08:27:54.096]                     }
[08:27:54.096]                     else if (inherits(cond, "warning")) {
[08:27:54.096]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.096]                       if (muffled) 
[08:27:54.096]                         invokeRestart("muffleWarning")
[08:27:54.096]                     }
[08:27:54.096]                     else if (inherits(cond, "condition")) {
[08:27:54.096]                       if (!is.null(pattern)) {
[08:27:54.096]                         computeRestarts <- base::computeRestarts
[08:27:54.096]                         grepl <- base::grepl
[08:27:54.096]                         restarts <- computeRestarts(cond)
[08:27:54.096]                         for (restart in restarts) {
[08:27:54.096]                           name <- restart$name
[08:27:54.096]                           if (is.null(name)) 
[08:27:54.096]                             next
[08:27:54.096]                           if (!grepl(pattern, name)) 
[08:27:54.096]                             next
[08:27:54.096]                           invokeRestart(restart)
[08:27:54.096]                           muffled <- TRUE
[08:27:54.096]                           break
[08:27:54.096]                         }
[08:27:54.096]                       }
[08:27:54.096]                     }
[08:27:54.096]                     invisible(muffled)
[08:27:54.096]                   }
[08:27:54.096]                   muffleCondition(cond)
[08:27:54.096]                 })
[08:27:54.096]             }))
[08:27:54.096]             future::FutureResult(value = ...future.value$value, 
[08:27:54.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.096]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.096]                     ...future.globalenv.names))
[08:27:54.096]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.096]         }, condition = base::local({
[08:27:54.096]             c <- base::c
[08:27:54.096]             inherits <- base::inherits
[08:27:54.096]             invokeRestart <- base::invokeRestart
[08:27:54.096]             length <- base::length
[08:27:54.096]             list <- base::list
[08:27:54.096]             seq.int <- base::seq.int
[08:27:54.096]             signalCondition <- base::signalCondition
[08:27:54.096]             sys.calls <- base::sys.calls
[08:27:54.096]             `[[` <- base::`[[`
[08:27:54.096]             `+` <- base::`+`
[08:27:54.096]             `<<-` <- base::`<<-`
[08:27:54.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.096]                   3L)]
[08:27:54.096]             }
[08:27:54.096]             function(cond) {
[08:27:54.096]                 is_error <- inherits(cond, "error")
[08:27:54.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.096]                   NULL)
[08:27:54.096]                 if (is_error) {
[08:27:54.096]                   sessionInformation <- function() {
[08:27:54.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.096]                       search = base::search(), system = base::Sys.info())
[08:27:54.096]                   }
[08:27:54.096]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.096]                     cond$call), session = sessionInformation(), 
[08:27:54.096]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.096]                   signalCondition(cond)
[08:27:54.096]                 }
[08:27:54.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.096]                 "immediateCondition"))) {
[08:27:54.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.096]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.096]                   if (TRUE && !signal) {
[08:27:54.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.096]                     {
[08:27:54.096]                       inherits <- base::inherits
[08:27:54.096]                       invokeRestart <- base::invokeRestart
[08:27:54.096]                       is.null <- base::is.null
[08:27:54.096]                       muffled <- FALSE
[08:27:54.096]                       if (inherits(cond, "message")) {
[08:27:54.096]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.096]                         if (muffled) 
[08:27:54.096]                           invokeRestart("muffleMessage")
[08:27:54.096]                       }
[08:27:54.096]                       else if (inherits(cond, "warning")) {
[08:27:54.096]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.096]                         if (muffled) 
[08:27:54.096]                           invokeRestart("muffleWarning")
[08:27:54.096]                       }
[08:27:54.096]                       else if (inherits(cond, "condition")) {
[08:27:54.096]                         if (!is.null(pattern)) {
[08:27:54.096]                           computeRestarts <- base::computeRestarts
[08:27:54.096]                           grepl <- base::grepl
[08:27:54.096]                           restarts <- computeRestarts(cond)
[08:27:54.096]                           for (restart in restarts) {
[08:27:54.096]                             name <- restart$name
[08:27:54.096]                             if (is.null(name)) 
[08:27:54.096]                               next
[08:27:54.096]                             if (!grepl(pattern, name)) 
[08:27:54.096]                               next
[08:27:54.096]                             invokeRestart(restart)
[08:27:54.096]                             muffled <- TRUE
[08:27:54.096]                             break
[08:27:54.096]                           }
[08:27:54.096]                         }
[08:27:54.096]                       }
[08:27:54.096]                       invisible(muffled)
[08:27:54.096]                     }
[08:27:54.096]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.096]                   }
[08:27:54.096]                 }
[08:27:54.096]                 else {
[08:27:54.096]                   if (TRUE) {
[08:27:54.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.096]                     {
[08:27:54.096]                       inherits <- base::inherits
[08:27:54.096]                       invokeRestart <- base::invokeRestart
[08:27:54.096]                       is.null <- base::is.null
[08:27:54.096]                       muffled <- FALSE
[08:27:54.096]                       if (inherits(cond, "message")) {
[08:27:54.096]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.096]                         if (muffled) 
[08:27:54.096]                           invokeRestart("muffleMessage")
[08:27:54.096]                       }
[08:27:54.096]                       else if (inherits(cond, "warning")) {
[08:27:54.096]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.096]                         if (muffled) 
[08:27:54.096]                           invokeRestart("muffleWarning")
[08:27:54.096]                       }
[08:27:54.096]                       else if (inherits(cond, "condition")) {
[08:27:54.096]                         if (!is.null(pattern)) {
[08:27:54.096]                           computeRestarts <- base::computeRestarts
[08:27:54.096]                           grepl <- base::grepl
[08:27:54.096]                           restarts <- computeRestarts(cond)
[08:27:54.096]                           for (restart in restarts) {
[08:27:54.096]                             name <- restart$name
[08:27:54.096]                             if (is.null(name)) 
[08:27:54.096]                               next
[08:27:54.096]                             if (!grepl(pattern, name)) 
[08:27:54.096]                               next
[08:27:54.096]                             invokeRestart(restart)
[08:27:54.096]                             muffled <- TRUE
[08:27:54.096]                             break
[08:27:54.096]                           }
[08:27:54.096]                         }
[08:27:54.096]                       }
[08:27:54.096]                       invisible(muffled)
[08:27:54.096]                     }
[08:27:54.096]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.096]                   }
[08:27:54.096]                 }
[08:27:54.096]             }
[08:27:54.096]         }))
[08:27:54.096]     }, error = function(ex) {
[08:27:54.096]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.096]                 ...future.rng), started = ...future.startTime, 
[08:27:54.096]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.096]             version = "1.8"), class = "FutureResult")
[08:27:54.096]     }, finally = {
[08:27:54.096]         if (!identical(...future.workdir, getwd())) 
[08:27:54.096]             setwd(...future.workdir)
[08:27:54.096]         {
[08:27:54.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.096]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.096]             }
[08:27:54.096]             base::options(...future.oldOptions)
[08:27:54.096]             if (.Platform$OS.type == "windows") {
[08:27:54.096]                 old_names <- names(...future.oldEnvVars)
[08:27:54.096]                 envs <- base::Sys.getenv()
[08:27:54.096]                 names <- names(envs)
[08:27:54.096]                 common <- intersect(names, old_names)
[08:27:54.096]                 added <- setdiff(names, old_names)
[08:27:54.096]                 removed <- setdiff(old_names, names)
[08:27:54.096]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.096]                   envs[common]]
[08:27:54.096]                 NAMES <- toupper(changed)
[08:27:54.096]                 args <- list()
[08:27:54.096]                 for (kk in seq_along(NAMES)) {
[08:27:54.096]                   name <- changed[[kk]]
[08:27:54.096]                   NAME <- NAMES[[kk]]
[08:27:54.096]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.096]                     next
[08:27:54.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.096]                 }
[08:27:54.096]                 NAMES <- toupper(added)
[08:27:54.096]                 for (kk in seq_along(NAMES)) {
[08:27:54.096]                   name <- added[[kk]]
[08:27:54.096]                   NAME <- NAMES[[kk]]
[08:27:54.096]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.096]                     next
[08:27:54.096]                   args[[name]] <- ""
[08:27:54.096]                 }
[08:27:54.096]                 NAMES <- toupper(removed)
[08:27:54.096]                 for (kk in seq_along(NAMES)) {
[08:27:54.096]                   name <- removed[[kk]]
[08:27:54.096]                   NAME <- NAMES[[kk]]
[08:27:54.096]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.096]                     next
[08:27:54.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.096]                 }
[08:27:54.096]                 if (length(args) > 0) 
[08:27:54.096]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.096]             }
[08:27:54.096]             else {
[08:27:54.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.096]             }
[08:27:54.096]             {
[08:27:54.096]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.096]                   0L) {
[08:27:54.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.096]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.096]                   base::options(opts)
[08:27:54.096]                 }
[08:27:54.096]                 {
[08:27:54.096]                   {
[08:27:54.096]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.096]                     NULL
[08:27:54.096]                   }
[08:27:54.096]                   options(future.plan = NULL)
[08:27:54.096]                   if (is.na(NA_character_)) 
[08:27:54.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.096]                     .init = FALSE)
[08:27:54.096]                 }
[08:27:54.096]             }
[08:27:54.096]         }
[08:27:54.096]     })
[08:27:54.096]     if (TRUE) {
[08:27:54.096]         base::sink(type = "output", split = FALSE)
[08:27:54.096]         if (TRUE) {
[08:27:54.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.096]         }
[08:27:54.096]         else {
[08:27:54.096]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.096]         }
[08:27:54.096]         base::close(...future.stdout)
[08:27:54.096]         ...future.stdout <- NULL
[08:27:54.096]     }
[08:27:54.096]     ...future.result$conditions <- ...future.conditions
[08:27:54.096]     ...future.result$finished <- base::Sys.time()
[08:27:54.096]     ...future.result
[08:27:54.096] }
[08:27:54.099] requestCore(): workers = 2
[08:27:54.102] MulticoreFuture started
[08:27:54.103] - Launch lazy future ... done
[08:27:54.103] run() for ‘MulticoreFuture’ ... done
[08:27:54.104] plan(): Setting new future strategy stack:
[08:27:54.104] getGlobalsAndPackages() ...
[08:27:54.104] Searching for globals...
[08:27:54.104] List of future strategies:
[08:27:54.104] 1. sequential:
[08:27:54.104]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.104]    - tweaked: FALSE
[08:27:54.104]    - call: NULL
[08:27:54.105] plan(): nbrOfWorkers() = 1
[08:27:54.106] - globals found: [1] ‘{’
[08:27:54.106] Searching for globals ... DONE
[08:27:54.106] Resolving globals: FALSE
[08:27:54.107] 
[08:27:54.107] 
[08:27:54.107] getGlobalsAndPackages() ... DONE
[08:27:54.107] run() for ‘Future’ ...
[08:27:54.107] - state: ‘created’
[08:27:54.107] plan(): Setting new future strategy stack:
[08:27:54.108] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.108] List of future strategies:
[08:27:54.108] 1. multicore:
[08:27:54.108]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.108]    - tweaked: FALSE
[08:27:54.108]    - call: plan(strategy)
[08:27:54.111] plan(): nbrOfWorkers() = 2
[08:27:54.111] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.111] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.111]   - Field: ‘label’
[08:27:54.111]   - Field: ‘local’
[08:27:54.111]   - Field: ‘owner’
[08:27:54.111]   - Field: ‘envir’
[08:27:54.112]   - Field: ‘workers’
[08:27:54.112]   - Field: ‘packages’
[08:27:54.112]   - Field: ‘gc’
[08:27:54.112]   - Field: ‘job’
[08:27:54.112]   - Field: ‘conditions’
[08:27:54.112]   - Field: ‘expr’
[08:27:54.112]   - Field: ‘uuid’
[08:27:54.112]   - Field: ‘seed’
[08:27:54.113]   - Field: ‘version’
[08:27:54.113]   - Field: ‘result’
[08:27:54.113]   - Field: ‘asynchronous’
[08:27:54.113]   - Field: ‘calls’
[08:27:54.113]   - Field: ‘globals’
[08:27:54.113]   - Field: ‘stdout’
[08:27:54.113]   - Field: ‘earlySignal’
[08:27:54.113]   - Field: ‘lazy’
[08:27:54.114]   - Field: ‘state’
[08:27:54.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.114] - Launch lazy future ...
[08:27:54.114] Packages needed by the future expression (n = 0): <none>
[08:27:54.114] Packages needed by future strategies (n = 0): <none>
[08:27:54.115] {
[08:27:54.115]     {
[08:27:54.115]         {
[08:27:54.115]             ...future.startTime <- base::Sys.time()
[08:27:54.115]             {
[08:27:54.115]                 {
[08:27:54.115]                   {
[08:27:54.115]                     {
[08:27:54.115]                       base::local({
[08:27:54.115]                         has_future <- base::requireNamespace("future", 
[08:27:54.115]                           quietly = TRUE)
[08:27:54.115]                         if (has_future) {
[08:27:54.115]                           ns <- base::getNamespace("future")
[08:27:54.115]                           version <- ns[[".package"]][["version"]]
[08:27:54.115]                           if (is.null(version)) 
[08:27:54.115]                             version <- utils::packageVersion("future")
[08:27:54.115]                         }
[08:27:54.115]                         else {
[08:27:54.115]                           version <- NULL
[08:27:54.115]                         }
[08:27:54.115]                         if (!has_future || version < "1.8.0") {
[08:27:54.115]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.115]                             "", base::R.version$version.string), 
[08:27:54.115]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.115]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.115]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.115]                               "release", "version")], collapse = " "), 
[08:27:54.115]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.115]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.115]                             info)
[08:27:54.115]                           info <- base::paste(info, collapse = "; ")
[08:27:54.115]                           if (!has_future) {
[08:27:54.115]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.115]                               info)
[08:27:54.115]                           }
[08:27:54.115]                           else {
[08:27:54.115]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.115]                               info, version)
[08:27:54.115]                           }
[08:27:54.115]                           base::stop(msg)
[08:27:54.115]                         }
[08:27:54.115]                       })
[08:27:54.115]                     }
[08:27:54.115]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.115]                     base::options(mc.cores = 1L)
[08:27:54.115]                   }
[08:27:54.115]                   ...future.strategy.old <- future::plan("list")
[08:27:54.115]                   options(future.plan = NULL)
[08:27:54.115]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.115]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.115]                 }
[08:27:54.115]                 ...future.workdir <- getwd()
[08:27:54.115]             }
[08:27:54.115]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.115]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.115]         }
[08:27:54.115]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.115]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.115]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.115]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.115]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.115]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.115]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.115]             base::names(...future.oldOptions))
[08:27:54.115]     }
[08:27:54.115]     if (FALSE) {
[08:27:54.115]     }
[08:27:54.115]     else {
[08:27:54.115]         if (TRUE) {
[08:27:54.115]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.115]                 open = "w")
[08:27:54.115]         }
[08:27:54.115]         else {
[08:27:54.115]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.115]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.115]         }
[08:27:54.115]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.115]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.115]             base::sink(type = "output", split = FALSE)
[08:27:54.115]             base::close(...future.stdout)
[08:27:54.115]         }, add = TRUE)
[08:27:54.115]     }
[08:27:54.115]     ...future.frame <- base::sys.nframe()
[08:27:54.115]     ...future.conditions <- base::list()
[08:27:54.115]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.115]     if (FALSE) {
[08:27:54.115]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.115]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.115]     }
[08:27:54.115]     ...future.result <- base::tryCatch({
[08:27:54.115]         base::withCallingHandlers({
[08:27:54.115]             ...future.value <- base::withVisible(base::local({
[08:27:54.115]                 withCallingHandlers({
[08:27:54.115]                   {
[08:27:54.115]                     4
[08:27:54.115]                   }
[08:27:54.115]                 }, immediateCondition = function(cond) {
[08:27:54.115]                   save_rds <- function (object, pathname, ...) 
[08:27:54.115]                   {
[08:27:54.115]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.115]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.115]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.115]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.115]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.115]                         fi_tmp[["mtime"]])
[08:27:54.115]                     }
[08:27:54.115]                     tryCatch({
[08:27:54.115]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.115]                     }, error = function(ex) {
[08:27:54.115]                       msg <- conditionMessage(ex)
[08:27:54.115]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.115]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.115]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.115]                         fi_tmp[["mtime"]], msg)
[08:27:54.115]                       ex$message <- msg
[08:27:54.115]                       stop(ex)
[08:27:54.115]                     })
[08:27:54.115]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.115]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.115]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.115]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.115]                       fi <- file.info(pathname)
[08:27:54.115]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.115]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.115]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.115]                         fi[["size"]], fi[["mtime"]])
[08:27:54.115]                       stop(msg)
[08:27:54.115]                     }
[08:27:54.115]                     invisible(pathname)
[08:27:54.115]                   }
[08:27:54.115]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.115]                     rootPath = tempdir()) 
[08:27:54.115]                   {
[08:27:54.115]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.115]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.115]                       tmpdir = path, fileext = ".rds")
[08:27:54.115]                     save_rds(obj, file)
[08:27:54.115]                   }
[08:27:54.115]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.115]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.115]                   {
[08:27:54.115]                     inherits <- base::inherits
[08:27:54.115]                     invokeRestart <- base::invokeRestart
[08:27:54.115]                     is.null <- base::is.null
[08:27:54.115]                     muffled <- FALSE
[08:27:54.115]                     if (inherits(cond, "message")) {
[08:27:54.115]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.115]                       if (muffled) 
[08:27:54.115]                         invokeRestart("muffleMessage")
[08:27:54.115]                     }
[08:27:54.115]                     else if (inherits(cond, "warning")) {
[08:27:54.115]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.115]                       if (muffled) 
[08:27:54.115]                         invokeRestart("muffleWarning")
[08:27:54.115]                     }
[08:27:54.115]                     else if (inherits(cond, "condition")) {
[08:27:54.115]                       if (!is.null(pattern)) {
[08:27:54.115]                         computeRestarts <- base::computeRestarts
[08:27:54.115]                         grepl <- base::grepl
[08:27:54.115]                         restarts <- computeRestarts(cond)
[08:27:54.115]                         for (restart in restarts) {
[08:27:54.115]                           name <- restart$name
[08:27:54.115]                           if (is.null(name)) 
[08:27:54.115]                             next
[08:27:54.115]                           if (!grepl(pattern, name)) 
[08:27:54.115]                             next
[08:27:54.115]                           invokeRestart(restart)
[08:27:54.115]                           muffled <- TRUE
[08:27:54.115]                           break
[08:27:54.115]                         }
[08:27:54.115]                       }
[08:27:54.115]                     }
[08:27:54.115]                     invisible(muffled)
[08:27:54.115]                   }
[08:27:54.115]                   muffleCondition(cond)
[08:27:54.115]                 })
[08:27:54.115]             }))
[08:27:54.115]             future::FutureResult(value = ...future.value$value, 
[08:27:54.115]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.115]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.115]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.115]                     ...future.globalenv.names))
[08:27:54.115]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.115]         }, condition = base::local({
[08:27:54.115]             c <- base::c
[08:27:54.115]             inherits <- base::inherits
[08:27:54.115]             invokeRestart <- base::invokeRestart
[08:27:54.115]             length <- base::length
[08:27:54.115]             list <- base::list
[08:27:54.115]             seq.int <- base::seq.int
[08:27:54.115]             signalCondition <- base::signalCondition
[08:27:54.115]             sys.calls <- base::sys.calls
[08:27:54.115]             `[[` <- base::`[[`
[08:27:54.115]             `+` <- base::`+`
[08:27:54.115]             `<<-` <- base::`<<-`
[08:27:54.115]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.115]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.115]                   3L)]
[08:27:54.115]             }
[08:27:54.115]             function(cond) {
[08:27:54.115]                 is_error <- inherits(cond, "error")
[08:27:54.115]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.115]                   NULL)
[08:27:54.115]                 if (is_error) {
[08:27:54.115]                   sessionInformation <- function() {
[08:27:54.115]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.115]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.115]                       search = base::search(), system = base::Sys.info())
[08:27:54.115]                   }
[08:27:54.115]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.115]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.115]                     cond$call), session = sessionInformation(), 
[08:27:54.115]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.115]                   signalCondition(cond)
[08:27:54.115]                 }
[08:27:54.115]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.115]                 "immediateCondition"))) {
[08:27:54.115]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.115]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.115]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.115]                   if (TRUE && !signal) {
[08:27:54.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.115]                     {
[08:27:54.115]                       inherits <- base::inherits
[08:27:54.115]                       invokeRestart <- base::invokeRestart
[08:27:54.115]                       is.null <- base::is.null
[08:27:54.115]                       muffled <- FALSE
[08:27:54.115]                       if (inherits(cond, "message")) {
[08:27:54.115]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.115]                         if (muffled) 
[08:27:54.115]                           invokeRestart("muffleMessage")
[08:27:54.115]                       }
[08:27:54.115]                       else if (inherits(cond, "warning")) {
[08:27:54.115]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.115]                         if (muffled) 
[08:27:54.115]                           invokeRestart("muffleWarning")
[08:27:54.115]                       }
[08:27:54.115]                       else if (inherits(cond, "condition")) {
[08:27:54.115]                         if (!is.null(pattern)) {
[08:27:54.115]                           computeRestarts <- base::computeRestarts
[08:27:54.115]                           grepl <- base::grepl
[08:27:54.115]                           restarts <- computeRestarts(cond)
[08:27:54.115]                           for (restart in restarts) {
[08:27:54.115]                             name <- restart$name
[08:27:54.115]                             if (is.null(name)) 
[08:27:54.115]                               next
[08:27:54.115]                             if (!grepl(pattern, name)) 
[08:27:54.115]                               next
[08:27:54.115]                             invokeRestart(restart)
[08:27:54.115]                             muffled <- TRUE
[08:27:54.115]                             break
[08:27:54.115]                           }
[08:27:54.115]                         }
[08:27:54.115]                       }
[08:27:54.115]                       invisible(muffled)
[08:27:54.115]                     }
[08:27:54.115]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.115]                   }
[08:27:54.115]                 }
[08:27:54.115]                 else {
[08:27:54.115]                   if (TRUE) {
[08:27:54.115]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.115]                     {
[08:27:54.115]                       inherits <- base::inherits
[08:27:54.115]                       invokeRestart <- base::invokeRestart
[08:27:54.115]                       is.null <- base::is.null
[08:27:54.115]                       muffled <- FALSE
[08:27:54.115]                       if (inherits(cond, "message")) {
[08:27:54.115]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.115]                         if (muffled) 
[08:27:54.115]                           invokeRestart("muffleMessage")
[08:27:54.115]                       }
[08:27:54.115]                       else if (inherits(cond, "warning")) {
[08:27:54.115]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.115]                         if (muffled) 
[08:27:54.115]                           invokeRestart("muffleWarning")
[08:27:54.115]                       }
[08:27:54.115]                       else if (inherits(cond, "condition")) {
[08:27:54.115]                         if (!is.null(pattern)) {
[08:27:54.115]                           computeRestarts <- base::computeRestarts
[08:27:54.115]                           grepl <- base::grepl
[08:27:54.115]                           restarts <- computeRestarts(cond)
[08:27:54.115]                           for (restart in restarts) {
[08:27:54.115]                             name <- restart$name
[08:27:54.115]                             if (is.null(name)) 
[08:27:54.115]                               next
[08:27:54.115]                             if (!grepl(pattern, name)) 
[08:27:54.115]                               next
[08:27:54.115]                             invokeRestart(restart)
[08:27:54.115]                             muffled <- TRUE
[08:27:54.115]                             break
[08:27:54.115]                           }
[08:27:54.115]                         }
[08:27:54.115]                       }
[08:27:54.115]                       invisible(muffled)
[08:27:54.115]                     }
[08:27:54.115]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.115]                   }
[08:27:54.115]                 }
[08:27:54.115]             }
[08:27:54.115]         }))
[08:27:54.115]     }, error = function(ex) {
[08:27:54.115]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.115]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.115]                 ...future.rng), started = ...future.startTime, 
[08:27:54.115]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.115]             version = "1.8"), class = "FutureResult")
[08:27:54.115]     }, finally = {
[08:27:54.115]         if (!identical(...future.workdir, getwd())) 
[08:27:54.115]             setwd(...future.workdir)
[08:27:54.115]         {
[08:27:54.115]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.115]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.115]             }
[08:27:54.115]             base::options(...future.oldOptions)
[08:27:54.115]             if (.Platform$OS.type == "windows") {
[08:27:54.115]                 old_names <- names(...future.oldEnvVars)
[08:27:54.115]                 envs <- base::Sys.getenv()
[08:27:54.115]                 names <- names(envs)
[08:27:54.115]                 common <- intersect(names, old_names)
[08:27:54.115]                 added <- setdiff(names, old_names)
[08:27:54.115]                 removed <- setdiff(old_names, names)
[08:27:54.115]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.115]                   envs[common]]
[08:27:54.115]                 NAMES <- toupper(changed)
[08:27:54.115]                 args <- list()
[08:27:54.115]                 for (kk in seq_along(NAMES)) {
[08:27:54.115]                   name <- changed[[kk]]
[08:27:54.115]                   NAME <- NAMES[[kk]]
[08:27:54.115]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.115]                     next
[08:27:54.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.115]                 }
[08:27:54.115]                 NAMES <- toupper(added)
[08:27:54.115]                 for (kk in seq_along(NAMES)) {
[08:27:54.115]                   name <- added[[kk]]
[08:27:54.115]                   NAME <- NAMES[[kk]]
[08:27:54.115]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.115]                     next
[08:27:54.115]                   args[[name]] <- ""
[08:27:54.115]                 }
[08:27:54.115]                 NAMES <- toupper(removed)
[08:27:54.115]                 for (kk in seq_along(NAMES)) {
[08:27:54.115]                   name <- removed[[kk]]
[08:27:54.115]                   NAME <- NAMES[[kk]]
[08:27:54.115]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.115]                     next
[08:27:54.115]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.115]                 }
[08:27:54.115]                 if (length(args) > 0) 
[08:27:54.115]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.115]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.115]             }
[08:27:54.115]             else {
[08:27:54.115]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.115]             }
[08:27:54.115]             {
[08:27:54.115]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.115]                   0L) {
[08:27:54.115]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.115]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.115]                   base::options(opts)
[08:27:54.115]                 }
[08:27:54.115]                 {
[08:27:54.115]                   {
[08:27:54.115]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.115]                     NULL
[08:27:54.115]                   }
[08:27:54.115]                   options(future.plan = NULL)
[08:27:54.115]                   if (is.na(NA_character_)) 
[08:27:54.115]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.115]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.115]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.115]                     .init = FALSE)
[08:27:54.115]                 }
[08:27:54.115]             }
[08:27:54.115]         }
[08:27:54.115]     })
[08:27:54.115]     if (TRUE) {
[08:27:54.115]         base::sink(type = "output", split = FALSE)
[08:27:54.115]         if (TRUE) {
[08:27:54.115]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.115]         }
[08:27:54.115]         else {
[08:27:54.115]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.115]         }
[08:27:54.115]         base::close(...future.stdout)
[08:27:54.115]         ...future.stdout <- NULL
[08:27:54.115]     }
[08:27:54.115]     ...future.result$conditions <- ...future.conditions
[08:27:54.115]     ...future.result$finished <- base::Sys.time()
[08:27:54.115]     ...future.result
[08:27:54.115] }
[08:27:54.119] requestCore(): workers = 2
[08:27:54.119] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:54.130] result() for MulticoreFuture ...
[08:27:54.131] result() for MulticoreFuture ...
[08:27:54.131] result() for MulticoreFuture ... done
[08:27:54.131] result() for MulticoreFuture ... done
[08:27:54.132] result() for MulticoreFuture ...
[08:27:54.132] result() for MulticoreFuture ... done
[08:27:54.135] MulticoreFuture started
[08:27:54.136] - Launch lazy future ... done
[08:27:54.136] run() for ‘MulticoreFuture’ ... done
[08:27:54.136] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55d8606504f8> 
[08:27:54.137] List of future strategies:
[08:27:54.137] 1. sequential:
[08:27:54.137]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.137]    - tweaked: FALSE
[08:27:54.137]    - call: NULL
[08:27:54.138] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55d8623d5ac8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ :[08:27:54.141] plan(): Setting new future strategy stack:
 chr "a"
  ..$ :[08:27:54.142] List of future strategies:
[08:27:54.142] 1. multicore:
[08:27:54.142]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.142]    - tweaked: FALSE
[08:27:54.142]    - call: plan(strategy)
 chr [1:6] "a" "b" "c" "d" ...
[08:27:54.146] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:54.150] resolve() on list environment ...
[08:27:54.150]  recursive: 0
[08:27:54.151]  length: 6
[08:27:54.152]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:54.152] signalConditionsASAP(numeric, pos=1) ...
[08:27:54.152] - nx: 6
[08:27:54.152] - relay: TRUE
[08:27:54.152] - stdout: TRUE
[08:27:54.152] - signal: TRUE
[08:27:54.152] - resignal: FALSE
[08:27:54.152] - force: TRUE
[08:27:54.153] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.153] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.153]  - until=2
[08:27:54.153]  - relaying element #2
[08:27:54.153] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.153] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.153] signalConditionsASAP(NULL, pos=1) ... done
[08:27:54.153]  length: 5 (resolved future 1)
[08:27:54.154] Future #2
[08:27:54.154] result() for MulticoreFuture ...
[08:27:54.154] result() for MulticoreFuture ... done
[08:27:54.154] result() for MulticoreFuture ...
[08:27:54.154] result() for MulticoreFuture ... done
[08:27:54.154] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:54.155] - nx: 6
[08:27:54.155] - relay: TRUE
[08:27:54.155] - stdout: TRUE
[08:27:54.155] - signal: TRUE
[08:27:54.155] - resignal: FALSE
[08:27:54.155] - force: TRUE
[08:27:54.155] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.155] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.155]  - until=2
[08:27:54.156]  - relaying element #2
[08:27:54.156] result() for MulticoreFuture ...
[08:27:54.156] result() for MulticoreFuture ... done
[08:27:54.156] result() for MulticoreFuture ...
[08:27:54.156] result() for MulticoreFuture ... done
[08:27:54.156] result() for MulticoreFuture ...
[08:27:54.156] result() for MulticoreFuture ... done
[08:27:54.156] result() for MulticoreFuture ...
[08:27:54.157] result() for MulticoreFuture ... done
[08:27:54.157] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.157] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.157] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:54.157]  length: 4 (resolved future 2)
[08:27:54.157] Future #3
[08:27:54.158] result() for MulticoreFuture ...
[08:27:54.158] result() for MulticoreFuture ...
[08:27:54.159] result() for MulticoreFuture ... done
[08:27:54.159] result() for MulticoreFuture ... done
[08:27:54.159] result() for MulticoreFuture ...
[08:27:54.159] result() for MulticoreFuture ... done
[08:27:54.159] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:54.159] - nx: 6
[08:27:54.159] - relay: TRUE
[08:27:54.159] - stdout: TRUE
[08:27:54.160] - signal: TRUE
[08:27:54.160] - resignal: FALSE
[08:27:54.160] - force: TRUE
[08:27:54.160] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.160] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.160]  - until=3
[08:27:54.160]  - relaying element #3
[08:27:54.160] result() for MulticoreFuture ...
[08:27:54.160] result() for MulticoreFuture ... done
[08:27:54.161] result() for MulticoreFuture ...
[08:27:54.161] result() for MulticoreFuture ... done
[08:27:54.161] result() for MulticoreFuture ...
[08:27:54.161] result() for MulticoreFuture ... done
[08:27:54.161] result() for MulticoreFuture ...
[08:27:54.161] result() for MulticoreFuture ... done
[08:27:54.161] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.161] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.162] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:54.162]  length: 3 (resolved future 3)
[08:27:54.162] Future #4
[08:27:54.162] result() for MulticoreFuture ...
[08:27:54.163] result() for MulticoreFuture ...
[08:27:54.163] result() for MulticoreFuture ... done
[08:27:54.163] result() for MulticoreFuture ... done
[08:27:54.163] result() for MulticoreFuture ...
[08:27:54.164] result() for MulticoreFuture ... done
[08:27:54.164] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:54.164] - nx: 6
[08:27:54.164] - relay: TRUE
[08:27:54.164] - stdout: TRUE
[08:27:54.164] - signal: TRUE
[08:27:54.165] - resignal: FALSE
[08:27:54.165] - force: TRUE
[08:27:54.165] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.165] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.165]  - until=4
[08:27:54.165]  - relaying element #4
[08:27:54.166] result() for MulticoreFuture ...
[08:27:54.166] result() for MulticoreFuture ... done
[08:27:54.166] result() for MulticoreFuture ...
[08:27:54.166] result() for MulticoreFuture ... done
[08:27:54.166] result() for MulticoreFuture ...
[08:27:54.166] result() for MulticoreFuture ... done
[08:27:54.167] result() for MulticoreFuture ...
[08:27:54.167] result() for MulticoreFuture ... done
[08:27:54.167] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.167] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.167] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:54.167]  length: 2 (resolved future 4)
[08:27:54.168] signalConditionsASAP(NULL, pos=5) ...
[08:27:54.168] - nx: 6
[08:27:54.168] - relay: TRUE
[08:27:54.168] - stdout: TRUE
[08:27:54.168] - signal: TRUE
[08:27:54.168] - resignal: FALSE
[08:27:54.168] - force: TRUE
[08:27:54.168] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.168] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.168]  - until=6
[08:27:54.168]  - relaying element #6
[08:27:54.169] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.169] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.169] signalConditionsASAP(NULL, pos=5) ... done
[08:27:54.169]  length: 1 (resolved future 5)
[08:27:54.169] signalConditionsASAP(numeric, pos=6) ...
[08:27:54.169] - nx: 6
[08:27:54.169] - relay: TRUE
[08:27:54.169] - stdout: TRUE
[08:27:54.169] - signal: TRUE
[08:27:54.169] - resignal: FALSE
[08:27:54.170] - force: TRUE
[08:27:54.170] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.170] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.170]  - until=6
[08:27:54.170] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.170] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.170] signalConditionsASAP(numeric, pos=6) ... done
[08:27:54.170]  length: 0 (resolved future 6)
[08:27:54.170] Relaying remaining futures
[08:27:54.170] signalConditionsASAP(NULL, pos=0) ...
[08:27:54.171] - nx: 6
[08:27:54.171] - relay: TRUE
[08:27:54.171] - stdout: TRUE
[08:27:54.171] - signal: TRUE
[08:27:54.171] - resignal: FALSE
[08:27:54.171] - force: TRUE
[08:27:54.171] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.171] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:54.171] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.171] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.172] signalConditionsASAP(NULL, pos=0) ... done
[08:27:54.172] resolve() on list environment ... DONE
[08:27:54.172] result() for MulticoreFuture ...
[08:27:54.172] result() for MulticoreFuture ... done
[08:27:54.172] result() for MulticoreFuture ...
[08:27:54.172] result() for MulticoreFuture ... done
[08:27:54.172] result() for MulticoreFuture ...
[08:27:54.172] result() for MulticoreFuture ... done
[08:27:54.172] result() for MulticoreFuture ...
[08:27:54.173] result() for MulticoreFuture ... done
[08:27:54.173] result() for MulticoreFuture ...
[08:27:54.173] result() for MulticoreFuture ... done
[08:27:54.173] result() for MulticoreFuture ...
[08:27:54.173] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d862619218> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[08:27:54.175] getGlobalsAndPackages() ...
[08:27:54.175] Searching for globals...
[08:27:54.176] 
[08:27:54.176] Searching for globals ... DONE
[08:27:54.176] - globals: [0] <none>
[08:27:54.176] getGlobalsAndPackages() ... DONE
[08:27:54.176] run() for ‘Future’ ...
[08:27:54.177] - state: ‘created’
[08:27:54.177] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.179] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.179]   - Field: ‘label’
[08:27:54.179]   - Field: ‘local’
[08:27:54.180]   - Field: ‘owner’
[08:27:54.180]   - Field: ‘envir’
[08:27:54.180]   - Field: ‘workers’
[08:27:54.180]   - Field: ‘packages’
[08:27:54.180]   - Field: ‘gc’
[08:27:54.180]   - Field: ‘job’
[08:27:54.180]   - Field: ‘conditions’
[08:27:54.180]   - Field: ‘expr’
[08:27:54.180]   - Field: ‘uuid’
[08:27:54.181]   - Field: ‘seed’
[08:27:54.181]   - Field: ‘version’
[08:27:54.181]   - Field: ‘result’
[08:27:54.181]   - Field: ‘asynchronous’
[08:27:54.181]   - Field: ‘calls’
[08:27:54.181]   - Field: ‘globals’
[08:27:54.181]   - Field: ‘stdout’
[08:27:54.181]   - Field: ‘earlySignal’
[08:27:54.181]   - Field: ‘lazy’
[08:27:54.181]   - Field: ‘state’
[08:27:54.182] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.185] - Launch lazy future ...
[08:27:54.186] Packages needed by the future expression (n = 0): <none>
[08:27:54.186] Packages needed by future strategies (n = 0): <none>
[08:27:54.187] {
[08:27:54.187]     {
[08:27:54.187]         {
[08:27:54.187]             ...future.startTime <- base::Sys.time()
[08:27:54.187]             {
[08:27:54.187]                 {
[08:27:54.187]                   {
[08:27:54.187]                     {
[08:27:54.187]                       base::local({
[08:27:54.187]                         has_future <- base::requireNamespace("future", 
[08:27:54.187]                           quietly = TRUE)
[08:27:54.187]                         if (has_future) {
[08:27:54.187]                           ns <- base::getNamespace("future")
[08:27:54.187]                           version <- ns[[".package"]][["version"]]
[08:27:54.187]                           if (is.null(version)) 
[08:27:54.187]                             version <- utils::packageVersion("future")
[08:27:54.187]                         }
[08:27:54.187]                         else {
[08:27:54.187]                           version <- NULL
[08:27:54.187]                         }
[08:27:54.187]                         if (!has_future || version < "1.8.0") {
[08:27:54.187]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.187]                             "", base::R.version$version.string), 
[08:27:54.187]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.187]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.187]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.187]                               "release", "version")], collapse = " "), 
[08:27:54.187]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.187]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.187]                             info)
[08:27:54.187]                           info <- base::paste(info, collapse = "; ")
[08:27:54.187]                           if (!has_future) {
[08:27:54.187]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.187]                               info)
[08:27:54.187]                           }
[08:27:54.187]                           else {
[08:27:54.187]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.187]                               info, version)
[08:27:54.187]                           }
[08:27:54.187]                           base::stop(msg)
[08:27:54.187]                         }
[08:27:54.187]                       })
[08:27:54.187]                     }
[08:27:54.187]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.187]                     base::options(mc.cores = 1L)
[08:27:54.187]                   }
[08:27:54.187]                   ...future.strategy.old <- future::plan("list")
[08:27:54.187]                   options(future.plan = NULL)
[08:27:54.187]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.187]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.187]                 }
[08:27:54.187]                 ...future.workdir <- getwd()
[08:27:54.187]             }
[08:27:54.187]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.187]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.187]         }
[08:27:54.187]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.187]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.187]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.187]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.187]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.187]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.187]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.187]             base::names(...future.oldOptions))
[08:27:54.187]     }
[08:27:54.187]     if (FALSE) {
[08:27:54.187]     }
[08:27:54.187]     else {
[08:27:54.187]         if (TRUE) {
[08:27:54.187]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.187]                 open = "w")
[08:27:54.187]         }
[08:27:54.187]         else {
[08:27:54.187]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.187]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.187]         }
[08:27:54.187]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.187]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.187]             base::sink(type = "output", split = FALSE)
[08:27:54.187]             base::close(...future.stdout)
[08:27:54.187]         }, add = TRUE)
[08:27:54.187]     }
[08:27:54.187]     ...future.frame <- base::sys.nframe()
[08:27:54.187]     ...future.conditions <- base::list()
[08:27:54.187]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.187]     if (FALSE) {
[08:27:54.187]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.187]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.187]     }
[08:27:54.187]     ...future.result <- base::tryCatch({
[08:27:54.187]         base::withCallingHandlers({
[08:27:54.187]             ...future.value <- base::withVisible(base::local({
[08:27:54.187]                 withCallingHandlers({
[08:27:54.187]                   2
[08:27:54.187]                 }, immediateCondition = function(cond) {
[08:27:54.187]                   save_rds <- function (object, pathname, ...) 
[08:27:54.187]                   {
[08:27:54.187]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.187]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.187]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.187]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.187]                         fi_tmp[["mtime"]])
[08:27:54.187]                     }
[08:27:54.187]                     tryCatch({
[08:27:54.187]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.187]                     }, error = function(ex) {
[08:27:54.187]                       msg <- conditionMessage(ex)
[08:27:54.187]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.187]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.187]                         fi_tmp[["mtime"]], msg)
[08:27:54.187]                       ex$message <- msg
[08:27:54.187]                       stop(ex)
[08:27:54.187]                     })
[08:27:54.187]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.187]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.187]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.187]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.187]                       fi <- file.info(pathname)
[08:27:54.187]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.187]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.187]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.187]                         fi[["size"]], fi[["mtime"]])
[08:27:54.187]                       stop(msg)
[08:27:54.187]                     }
[08:27:54.187]                     invisible(pathname)
[08:27:54.187]                   }
[08:27:54.187]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.187]                     rootPath = tempdir()) 
[08:27:54.187]                   {
[08:27:54.187]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.187]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.187]                       tmpdir = path, fileext = ".rds")
[08:27:54.187]                     save_rds(obj, file)
[08:27:54.187]                   }
[08:27:54.187]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.187]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.187]                   {
[08:27:54.187]                     inherits <- base::inherits
[08:27:54.187]                     invokeRestart <- base::invokeRestart
[08:27:54.187]                     is.null <- base::is.null
[08:27:54.187]                     muffled <- FALSE
[08:27:54.187]                     if (inherits(cond, "message")) {
[08:27:54.187]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.187]                       if (muffled) 
[08:27:54.187]                         invokeRestart("muffleMessage")
[08:27:54.187]                     }
[08:27:54.187]                     else if (inherits(cond, "warning")) {
[08:27:54.187]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.187]                       if (muffled) 
[08:27:54.187]                         invokeRestart("muffleWarning")
[08:27:54.187]                     }
[08:27:54.187]                     else if (inherits(cond, "condition")) {
[08:27:54.187]                       if (!is.null(pattern)) {
[08:27:54.187]                         computeRestarts <- base::computeRestarts
[08:27:54.187]                         grepl <- base::grepl
[08:27:54.187]                         restarts <- computeRestarts(cond)
[08:27:54.187]                         for (restart in restarts) {
[08:27:54.187]                           name <- restart$name
[08:27:54.187]                           if (is.null(name)) 
[08:27:54.187]                             next
[08:27:54.187]                           if (!grepl(pattern, name)) 
[08:27:54.187]                             next
[08:27:54.187]                           invokeRestart(restart)
[08:27:54.187]                           muffled <- TRUE
[08:27:54.187]                           break
[08:27:54.187]                         }
[08:27:54.187]                       }
[08:27:54.187]                     }
[08:27:54.187]                     invisible(muffled)
[08:27:54.187]                   }
[08:27:54.187]                   muffleCondition(cond)
[08:27:54.187]                 })
[08:27:54.187]             }))
[08:27:54.187]             future::FutureResult(value = ...future.value$value, 
[08:27:54.187]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.187]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.187]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.187]                     ...future.globalenv.names))
[08:27:54.187]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.187]         }, condition = base::local({
[08:27:54.187]             c <- base::c
[08:27:54.187]             inherits <- base::inherits
[08:27:54.187]             invokeRestart <- base::invokeRestart
[08:27:54.187]             length <- base::length
[08:27:54.187]             list <- base::list
[08:27:54.187]             seq.int <- base::seq.int
[08:27:54.187]             signalCondition <- base::signalCondition
[08:27:54.187]             sys.calls <- base::sys.calls
[08:27:54.187]             `[[` <- base::`[[`
[08:27:54.187]             `+` <- base::`+`
[08:27:54.187]             `<<-` <- base::`<<-`
[08:27:54.187]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.187]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.187]                   3L)]
[08:27:54.187]             }
[08:27:54.187]             function(cond) {
[08:27:54.187]                 is_error <- inherits(cond, "error")
[08:27:54.187]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.187]                   NULL)
[08:27:54.187]                 if (is_error) {
[08:27:54.187]                   sessionInformation <- function() {
[08:27:54.187]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.187]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.187]                       search = base::search(), system = base::Sys.info())
[08:27:54.187]                   }
[08:27:54.187]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.187]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.187]                     cond$call), session = sessionInformation(), 
[08:27:54.187]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.187]                   signalCondition(cond)
[08:27:54.187]                 }
[08:27:54.187]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.187]                 "immediateCondition"))) {
[08:27:54.187]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.187]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.187]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.187]                   if (TRUE && !signal) {
[08:27:54.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.187]                     {
[08:27:54.187]                       inherits <- base::inherits
[08:27:54.187]                       invokeRestart <- base::invokeRestart
[08:27:54.187]                       is.null <- base::is.null
[08:27:54.187]                       muffled <- FALSE
[08:27:54.187]                       if (inherits(cond, "message")) {
[08:27:54.187]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.187]                         if (muffled) 
[08:27:54.187]                           invokeRestart("muffleMessage")
[08:27:54.187]                       }
[08:27:54.187]                       else if (inherits(cond, "warning")) {
[08:27:54.187]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.187]                         if (muffled) 
[08:27:54.187]                           invokeRestart("muffleWarning")
[08:27:54.187]                       }
[08:27:54.187]                       else if (inherits(cond, "condition")) {
[08:27:54.187]                         if (!is.null(pattern)) {
[08:27:54.187]                           computeRestarts <- base::computeRestarts
[08:27:54.187]                           grepl <- base::grepl
[08:27:54.187]                           restarts <- computeRestarts(cond)
[08:27:54.187]                           for (restart in restarts) {
[08:27:54.187]                             name <- restart$name
[08:27:54.187]                             if (is.null(name)) 
[08:27:54.187]                               next
[08:27:54.187]                             if (!grepl(pattern, name)) 
[08:27:54.187]                               next
[08:27:54.187]                             invokeRestart(restart)
[08:27:54.187]                             muffled <- TRUE
[08:27:54.187]                             break
[08:27:54.187]                           }
[08:27:54.187]                         }
[08:27:54.187]                       }
[08:27:54.187]                       invisible(muffled)
[08:27:54.187]                     }
[08:27:54.187]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.187]                   }
[08:27:54.187]                 }
[08:27:54.187]                 else {
[08:27:54.187]                   if (TRUE) {
[08:27:54.187]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.187]                     {
[08:27:54.187]                       inherits <- base::inherits
[08:27:54.187]                       invokeRestart <- base::invokeRestart
[08:27:54.187]                       is.null <- base::is.null
[08:27:54.187]                       muffled <- FALSE
[08:27:54.187]                       if (inherits(cond, "message")) {
[08:27:54.187]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.187]                         if (muffled) 
[08:27:54.187]                           invokeRestart("muffleMessage")
[08:27:54.187]                       }
[08:27:54.187]                       else if (inherits(cond, "warning")) {
[08:27:54.187]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.187]                         if (muffled) 
[08:27:54.187]                           invokeRestart("muffleWarning")
[08:27:54.187]                       }
[08:27:54.187]                       else if (inherits(cond, "condition")) {
[08:27:54.187]                         if (!is.null(pattern)) {
[08:27:54.187]                           computeRestarts <- base::computeRestarts
[08:27:54.187]                           grepl <- base::grepl
[08:27:54.187]                           restarts <- computeRestarts(cond)
[08:27:54.187]                           for (restart in restarts) {
[08:27:54.187]                             name <- restart$name
[08:27:54.187]                             if (is.null(name)) 
[08:27:54.187]                               next
[08:27:54.187]                             if (!grepl(pattern, name)) 
[08:27:54.187]                               next
[08:27:54.187]                             invokeRestart(restart)
[08:27:54.187]                             muffled <- TRUE
[08:27:54.187]                             break
[08:27:54.187]                           }
[08:27:54.187]                         }
[08:27:54.187]                       }
[08:27:54.187]                       invisible(muffled)
[08:27:54.187]                     }
[08:27:54.187]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.187]                   }
[08:27:54.187]                 }
[08:27:54.187]             }
[08:27:54.187]         }))
[08:27:54.187]     }, error = function(ex) {
[08:27:54.187]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.187]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.187]                 ...future.rng), started = ...future.startTime, 
[08:27:54.187]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.187]             version = "1.8"), class = "FutureResult")
[08:27:54.187]     }, finally = {
[08:27:54.187]         if (!identical(...future.workdir, getwd())) 
[08:27:54.187]             setwd(...future.workdir)
[08:27:54.187]         {
[08:27:54.187]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.187]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.187]             }
[08:27:54.187]             base::options(...future.oldOptions)
[08:27:54.187]             if (.Platform$OS.type == "windows") {
[08:27:54.187]                 old_names <- names(...future.oldEnvVars)
[08:27:54.187]                 envs <- base::Sys.getenv()
[08:27:54.187]                 names <- names(envs)
[08:27:54.187]                 common <- intersect(names, old_names)
[08:27:54.187]                 added <- setdiff(names, old_names)
[08:27:54.187]                 removed <- setdiff(old_names, names)
[08:27:54.187]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.187]                   envs[common]]
[08:27:54.187]                 NAMES <- toupper(changed)
[08:27:54.187]                 args <- list()
[08:27:54.187]                 for (kk in seq_along(NAMES)) {
[08:27:54.187]                   name <- changed[[kk]]
[08:27:54.187]                   NAME <- NAMES[[kk]]
[08:27:54.187]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.187]                     next
[08:27:54.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.187]                 }
[08:27:54.187]                 NAMES <- toupper(added)
[08:27:54.187]                 for (kk in seq_along(NAMES)) {
[08:27:54.187]                   name <- added[[kk]]
[08:27:54.187]                   NAME <- NAMES[[kk]]
[08:27:54.187]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.187]                     next
[08:27:54.187]                   args[[name]] <- ""
[08:27:54.187]                 }
[08:27:54.187]                 NAMES <- toupper(removed)
[08:27:54.187]                 for (kk in seq_along(NAMES)) {
[08:27:54.187]                   name <- removed[[kk]]
[08:27:54.187]                   NAME <- NAMES[[kk]]
[08:27:54.187]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.187]                     next
[08:27:54.187]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.187]                 }
[08:27:54.187]                 if (length(args) > 0) 
[08:27:54.187]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.187]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.187]             }
[08:27:54.187]             else {
[08:27:54.187]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.187]             }
[08:27:54.187]             {
[08:27:54.187]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.187]                   0L) {
[08:27:54.187]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.187]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.187]                   base::options(opts)
[08:27:54.187]                 }
[08:27:54.187]                 {
[08:27:54.187]                   {
[08:27:54.187]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.187]                     NULL
[08:27:54.187]                   }
[08:27:54.187]                   options(future.plan = NULL)
[08:27:54.187]                   if (is.na(NA_character_)) 
[08:27:54.187]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.187]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.187]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.187]                     .init = FALSE)
[08:27:54.187]                 }
[08:27:54.187]             }
[08:27:54.187]         }
[08:27:54.187]     })
[08:27:54.187]     if (TRUE) {
[08:27:54.187]         base::sink(type = "output", split = FALSE)
[08:27:54.187]         if (TRUE) {
[08:27:54.187]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.187]         }
[08:27:54.187]         else {
[08:27:54.187]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.187]         }
[08:27:54.187]         base::close(...future.stdout)
[08:27:54.187]         ...future.stdout <- NULL
[08:27:54.187]     }
[08:27:54.187]     ...future.result$conditions <- ...future.conditions
[08:27:54.187]     ...future.result$finished <- base::Sys.time()
[08:27:54.187]     ...future.result
[08:27:54.187] }
[08:27:54.190] requestCore(): workers = 2
[08:27:54.193] MulticoreFuture started
[08:27:54.193] - Launch lazy future ... done
[08:27:54.194] run() for ‘MulticoreFuture’ ... done
[08:27:54.194] getGlobalsAndPackages() ...
[08:27:54.194] plan(): Setting new future strategy stack:
[08:27:54.194] Searching for globals...
[08:27:54.194] List of future strategies:
[08:27:54.194] 1. sequential:
[08:27:54.194]    - args: function (..., envir = parent.[08:27:54.195] 
frame(), workers = "<NULL>")
[08:27:54.194]    - tweaked: FALSE
[08:27:54.194]    - call: NULL
[08:27:54.195] Searching for globals ... DONE
[08:27:54.195] plan(): nbrOfWorkers() = 1
[08:27:54.195] - globals: [0] <none>
[08:27:54.196] getGlobalsAndPackages() ... DONE
[08:27:54.196] run() for ‘Future’ ...
[08:27:54.196] - state: ‘created’
[08:27:54.197] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.198] plan(): Setting new future strategy stack:
[08:27:54.198] List of future strategies:
[08:27:54.198] 1. multicore:
[08:27:54.198]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.198]    - tweaked: FALSE
[08:27:54.198]    - call: plan(strategy)
[08:27:54.200] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.200] plan(): nbrOfWorkers() = 2
[08:27:54.200] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.201]   - Field: ‘label’
[08:27:54.201]   - Field: ‘local’
[08:27:54.201]   - Field: ‘owner’
[08:27:54.201]   - Field: ‘envir’
[08:27:54.201]   - Field: ‘workers’
[08:27:54.201]   - Field: ‘packages’
[08:27:54.201]   - Field: ‘gc’
[08:27:54.202]   - Field: ‘job’
[08:27:54.202]   - Field: ‘conditions’
[08:27:54.202]   - Field: ‘expr’
[08:27:54.202]   - Field: ‘uuid’
[08:27:54.202]   - Field: ‘seed’
[08:27:54.202]   - Field: ‘version’
[08:27:54.202]   - Field: ‘result’
[08:27:54.203]   - Field: ‘asynchronous’
[08:27:54.203]   - Field: ‘calls’
[08:27:54.203]   - Field: ‘globals’
[08:27:54.203]   - Field: ‘stdout’
[08:27:54.203]   - Field: ‘earlySignal’
[08:27:54.203]   - Field: ‘lazy’
[08:27:54.203]   - Field: ‘state’
[08:27:54.203] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.204] - Launch lazy future ...
[08:27:54.204] Packages needed by the future expression (n = 0): <none>
[08:27:54.204] Packages needed by future strategies (n = 0): <none>
[08:27:54.205] {
[08:27:54.205]     {
[08:27:54.205]         {
[08:27:54.205]             ...future.startTime <- base::Sys.time()
[08:27:54.205]             {
[08:27:54.205]                 {
[08:27:54.205]                   {
[08:27:54.205]                     {
[08:27:54.205]                       base::local({
[08:27:54.205]                         has_future <- base::requireNamespace("future", 
[08:27:54.205]                           quietly = TRUE)
[08:27:54.205]                         if (has_future) {
[08:27:54.205]                           ns <- base::getNamespace("future")
[08:27:54.205]                           version <- ns[[".package"]][["version"]]
[08:27:54.205]                           if (is.null(version)) 
[08:27:54.205]                             version <- utils::packageVersion("future")
[08:27:54.205]                         }
[08:27:54.205]                         else {
[08:27:54.205]                           version <- NULL
[08:27:54.205]                         }
[08:27:54.205]                         if (!has_future || version < "1.8.0") {
[08:27:54.205]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.205]                             "", base::R.version$version.string), 
[08:27:54.205]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.205]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.205]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.205]                               "release", "version")], collapse = " "), 
[08:27:54.205]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.205]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.205]                             info)
[08:27:54.205]                           info <- base::paste(info, collapse = "; ")
[08:27:54.205]                           if (!has_future) {
[08:27:54.205]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.205]                               info)
[08:27:54.205]                           }
[08:27:54.205]                           else {
[08:27:54.205]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.205]                               info, version)
[08:27:54.205]                           }
[08:27:54.205]                           base::stop(msg)
[08:27:54.205]                         }
[08:27:54.205]                       })
[08:27:54.205]                     }
[08:27:54.205]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.205]                     base::options(mc.cores = 1L)
[08:27:54.205]                   }
[08:27:54.205]                   ...future.strategy.old <- future::plan("list")
[08:27:54.205]                   options(future.plan = NULL)
[08:27:54.205]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.205]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.205]                 }
[08:27:54.205]                 ...future.workdir <- getwd()
[08:27:54.205]             }
[08:27:54.205]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.205]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.205]         }
[08:27:54.205]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.205]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.205]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.205]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.205]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.205]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.205]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.205]             base::names(...future.oldOptions))
[08:27:54.205]     }
[08:27:54.205]     if (FALSE) {
[08:27:54.205]     }
[08:27:54.205]     else {
[08:27:54.205]         if (TRUE) {
[08:27:54.205]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.205]                 open = "w")
[08:27:54.205]         }
[08:27:54.205]         else {
[08:27:54.205]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.205]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.205]         }
[08:27:54.205]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.205]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.205]             base::sink(type = "output", split = FALSE)
[08:27:54.205]             base::close(...future.stdout)
[08:27:54.205]         }, add = TRUE)
[08:27:54.205]     }
[08:27:54.205]     ...future.frame <- base::sys.nframe()
[08:27:54.205]     ...future.conditions <- base::list()
[08:27:54.205]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.205]     if (FALSE) {
[08:27:54.205]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.205]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.205]     }
[08:27:54.205]     ...future.result <- base::tryCatch({
[08:27:54.205]         base::withCallingHandlers({
[08:27:54.205]             ...future.value <- base::withVisible(base::local({
[08:27:54.205]                 withCallingHandlers({
[08:27:54.205]                   NULL
[08:27:54.205]                 }, immediateCondition = function(cond) {
[08:27:54.205]                   save_rds <- function (object, pathname, ...) 
[08:27:54.205]                   {
[08:27:54.205]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.205]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.205]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.205]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.205]                         fi_tmp[["mtime"]])
[08:27:54.205]                     }
[08:27:54.205]                     tryCatch({
[08:27:54.205]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.205]                     }, error = function(ex) {
[08:27:54.205]                       msg <- conditionMessage(ex)
[08:27:54.205]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.205]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.205]                         fi_tmp[["mtime"]], msg)
[08:27:54.205]                       ex$message <- msg
[08:27:54.205]                       stop(ex)
[08:27:54.205]                     })
[08:27:54.205]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.205]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.205]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.205]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.205]                       fi <- file.info(pathname)
[08:27:54.205]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.205]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.205]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.205]                         fi[["size"]], fi[["mtime"]])
[08:27:54.205]                       stop(msg)
[08:27:54.205]                     }
[08:27:54.205]                     invisible(pathname)
[08:27:54.205]                   }
[08:27:54.205]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.205]                     rootPath = tempdir()) 
[08:27:54.205]                   {
[08:27:54.205]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.205]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.205]                       tmpdir = path, fileext = ".rds")
[08:27:54.205]                     save_rds(obj, file)
[08:27:54.205]                   }
[08:27:54.205]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.205]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.205]                   {
[08:27:54.205]                     inherits <- base::inherits
[08:27:54.205]                     invokeRestart <- base::invokeRestart
[08:27:54.205]                     is.null <- base::is.null
[08:27:54.205]                     muffled <- FALSE
[08:27:54.205]                     if (inherits(cond, "message")) {
[08:27:54.205]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.205]                       if (muffled) 
[08:27:54.205]                         invokeRestart("muffleMessage")
[08:27:54.205]                     }
[08:27:54.205]                     else if (inherits(cond, "warning")) {
[08:27:54.205]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.205]                       if (muffled) 
[08:27:54.205]                         invokeRestart("muffleWarning")
[08:27:54.205]                     }
[08:27:54.205]                     else if (inherits(cond, "condition")) {
[08:27:54.205]                       if (!is.null(pattern)) {
[08:27:54.205]                         computeRestarts <- base::computeRestarts
[08:27:54.205]                         grepl <- base::grepl
[08:27:54.205]                         restarts <- computeRestarts(cond)
[08:27:54.205]                         for (restart in restarts) {
[08:27:54.205]                           name <- restart$name
[08:27:54.205]                           if (is.null(name)) 
[08:27:54.205]                             next
[08:27:54.205]                           if (!grepl(pattern, name)) 
[08:27:54.205]                             next
[08:27:54.205]                           invokeRestart(restart)
[08:27:54.205]                           muffled <- TRUE
[08:27:54.205]                           break
[08:27:54.205]                         }
[08:27:54.205]                       }
[08:27:54.205]                     }
[08:27:54.205]                     invisible(muffled)
[08:27:54.205]                   }
[08:27:54.205]                   muffleCondition(cond)
[08:27:54.205]                 })
[08:27:54.205]             }))
[08:27:54.205]             future::FutureResult(value = ...future.value$value, 
[08:27:54.205]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.205]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.205]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.205]                     ...future.globalenv.names))
[08:27:54.205]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.205]         }, condition = base::local({
[08:27:54.205]             c <- base::c
[08:27:54.205]             inherits <- base::inherits
[08:27:54.205]             invokeRestart <- base::invokeRestart
[08:27:54.205]             length <- base::length
[08:27:54.205]             list <- base::list
[08:27:54.205]             seq.int <- base::seq.int
[08:27:54.205]             signalCondition <- base::signalCondition
[08:27:54.205]             sys.calls <- base::sys.calls
[08:27:54.205]             `[[` <- base::`[[`
[08:27:54.205]             `+` <- base::`+`
[08:27:54.205]             `<<-` <- base::`<<-`
[08:27:54.205]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.205]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.205]                   3L)]
[08:27:54.205]             }
[08:27:54.205]             function(cond) {
[08:27:54.205]                 is_error <- inherits(cond, "error")
[08:27:54.205]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.205]                   NULL)
[08:27:54.205]                 if (is_error) {
[08:27:54.205]                   sessionInformation <- function() {
[08:27:54.205]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.205]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.205]                       search = base::search(), system = base::Sys.info())
[08:27:54.205]                   }
[08:27:54.205]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.205]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.205]                     cond$call), session = sessionInformation(), 
[08:27:54.205]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.205]                   signalCondition(cond)
[08:27:54.205]                 }
[08:27:54.205]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.205]                 "immediateCondition"))) {
[08:27:54.205]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.205]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.205]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.205]                   if (TRUE && !signal) {
[08:27:54.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.205]                     {
[08:27:54.205]                       inherits <- base::inherits
[08:27:54.205]                       invokeRestart <- base::invokeRestart
[08:27:54.205]                       is.null <- base::is.null
[08:27:54.205]                       muffled <- FALSE
[08:27:54.205]                       if (inherits(cond, "message")) {
[08:27:54.205]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.205]                         if (muffled) 
[08:27:54.205]                           invokeRestart("muffleMessage")
[08:27:54.205]                       }
[08:27:54.205]                       else if (inherits(cond, "warning")) {
[08:27:54.205]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.205]                         if (muffled) 
[08:27:54.205]                           invokeRestart("muffleWarning")
[08:27:54.205]                       }
[08:27:54.205]                       else if (inherits(cond, "condition")) {
[08:27:54.205]                         if (!is.null(pattern)) {
[08:27:54.205]                           computeRestarts <- base::computeRestarts
[08:27:54.205]                           grepl <- base::grepl
[08:27:54.205]                           restarts <- computeRestarts(cond)
[08:27:54.205]                           for (restart in restarts) {
[08:27:54.205]                             name <- restart$name
[08:27:54.205]                             if (is.null(name)) 
[08:27:54.205]                               next
[08:27:54.205]                             if (!grepl(pattern, name)) 
[08:27:54.205]                               next
[08:27:54.205]                             invokeRestart(restart)
[08:27:54.205]                             muffled <- TRUE
[08:27:54.205]                             break
[08:27:54.205]                           }
[08:27:54.205]                         }
[08:27:54.205]                       }
[08:27:54.205]                       invisible(muffled)
[08:27:54.205]                     }
[08:27:54.205]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.205]                   }
[08:27:54.205]                 }
[08:27:54.205]                 else {
[08:27:54.205]                   if (TRUE) {
[08:27:54.205]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.205]                     {
[08:27:54.205]                       inherits <- base::inherits
[08:27:54.205]                       invokeRestart <- base::invokeRestart
[08:27:54.205]                       is.null <- base::is.null
[08:27:54.205]                       muffled <- FALSE
[08:27:54.205]                       if (inherits(cond, "message")) {
[08:27:54.205]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.205]                         if (muffled) 
[08:27:54.205]                           invokeRestart("muffleMessage")
[08:27:54.205]                       }
[08:27:54.205]                       else if (inherits(cond, "warning")) {
[08:27:54.205]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.205]                         if (muffled) 
[08:27:54.205]                           invokeRestart("muffleWarning")
[08:27:54.205]                       }
[08:27:54.205]                       else if (inherits(cond, "condition")) {
[08:27:54.205]                         if (!is.null(pattern)) {
[08:27:54.205]                           computeRestarts <- base::computeRestarts
[08:27:54.205]                           grepl <- base::grepl
[08:27:54.205]                           restarts <- computeRestarts(cond)
[08:27:54.205]                           for (restart in restarts) {
[08:27:54.205]                             name <- restart$name
[08:27:54.205]                             if (is.null(name)) 
[08:27:54.205]                               next
[08:27:54.205]                             if (!grepl(pattern, name)) 
[08:27:54.205]                               next
[08:27:54.205]                             invokeRestart(restart)
[08:27:54.205]                             muffled <- TRUE
[08:27:54.205]                             break
[08:27:54.205]                           }
[08:27:54.205]                         }
[08:27:54.205]                       }
[08:27:54.205]                       invisible(muffled)
[08:27:54.205]                     }
[08:27:54.205]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.205]                   }
[08:27:54.205]                 }
[08:27:54.205]             }
[08:27:54.205]         }))
[08:27:54.205]     }, error = function(ex) {
[08:27:54.205]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.205]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.205]                 ...future.rng), started = ...future.startTime, 
[08:27:54.205]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.205]             version = "1.8"), class = "FutureResult")
[08:27:54.205]     }, finally = {
[08:27:54.205]         if (!identical(...future.workdir, getwd())) 
[08:27:54.205]             setwd(...future.workdir)
[08:27:54.205]         {
[08:27:54.205]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.205]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.205]             }
[08:27:54.205]             base::options(...future.oldOptions)
[08:27:54.205]             if (.Platform$OS.type == "windows") {
[08:27:54.205]                 old_names <- names(...future.oldEnvVars)
[08:27:54.205]                 envs <- base::Sys.getenv()
[08:27:54.205]                 names <- names(envs)
[08:27:54.205]                 common <- intersect(names, old_names)
[08:27:54.205]                 added <- setdiff(names, old_names)
[08:27:54.205]                 removed <- setdiff(old_names, names)
[08:27:54.205]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.205]                   envs[common]]
[08:27:54.205]                 NAMES <- toupper(changed)
[08:27:54.205]                 args <- list()
[08:27:54.205]                 for (kk in seq_along(NAMES)) {
[08:27:54.205]                   name <- changed[[kk]]
[08:27:54.205]                   NAME <- NAMES[[kk]]
[08:27:54.205]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.205]                     next
[08:27:54.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.205]                 }
[08:27:54.205]                 NAMES <- toupper(added)
[08:27:54.205]                 for (kk in seq_along(NAMES)) {
[08:27:54.205]                   name <- added[[kk]]
[08:27:54.205]                   NAME <- NAMES[[kk]]
[08:27:54.205]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.205]                     next
[08:27:54.205]                   args[[name]] <- ""
[08:27:54.205]                 }
[08:27:54.205]                 NAMES <- toupper(removed)
[08:27:54.205]                 for (kk in seq_along(NAMES)) {
[08:27:54.205]                   name <- removed[[kk]]
[08:27:54.205]                   NAME <- NAMES[[kk]]
[08:27:54.205]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.205]                     next
[08:27:54.205]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.205]                 }
[08:27:54.205]                 if (length(args) > 0) 
[08:27:54.205]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.205]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.205]             }
[08:27:54.205]             else {
[08:27:54.205]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.205]             }
[08:27:54.205]             {
[08:27:54.205]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.205]                   0L) {
[08:27:54.205]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.205]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.205]                   base::options(opts)
[08:27:54.205]                 }
[08:27:54.205]                 {
[08:27:54.205]                   {
[08:27:54.205]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.205]                     NULL
[08:27:54.205]                   }
[08:27:54.205]                   options(future.plan = NULL)
[08:27:54.205]                   if (is.na(NA_character_)) 
[08:27:54.205]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.205]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.205]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.205]                     .init = FALSE)
[08:27:54.205]                 }
[08:27:54.205]             }
[08:27:54.205]         }
[08:27:54.205]     })
[08:27:54.205]     if (TRUE) {
[08:27:54.205]         base::sink(type = "output", split = FALSE)
[08:27:54.205]         if (TRUE) {
[08:27:54.205]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.205]         }
[08:27:54.205]         else {
[08:27:54.205]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.205]         }
[08:27:54.205]         base::close(...future.stdout)
[08:27:54.205]         ...future.stdout <- NULL
[08:27:54.205]     }
[08:27:54.205]     ...future.result$conditions <- ...future.conditions
[08:27:54.205]     ...future.result$finished <- base::Sys.time()
[08:27:54.205]     ...future.result
[08:27:54.205] }
[08:27:54.209] requestCore(): workers = 2
[08:27:54.212] MulticoreFuture started
[08:27:54.212] - Launch lazy future ... done
[08:27:54.213] run() for ‘MulticoreFuture’ ... done
[08:27:54.213] plan(): Setting new future strategy stack:
[08:27:54.214] getGlobalsAndPackages() ...
[08:27:54.214] Searching for globals...
[08:27:54.214] List of future strategies:
[08:27:54.214] 1. sequential:
[08:27:54.214]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.214]    - tweaked: FALSE
[08:27:54.214]    - call: NULL
[08:27:54.215] plan(): nbrOfWorkers() = 1
[08:27:54.215] - globals found: [1] ‘{’
[08:27:54.215] Searching for globals ... DONE
[08:27:54.216] Resolving globals: FALSE
[08:27:54.216] 
[08:27:54.216] 
[08:27:54.217] getGlobalsAndPackages() ... DONE
[08:27:54.217] run() for ‘Future’ ...
[08:27:54.217] plan(): Setting new future strategy stack:
[08:27:54.217] - state: ‘created’
[08:27:54.217] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.217] List of future strategies:
[08:27:54.217] 1. multicore:
[08:27:54.217]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.217]    - tweaked: FALSE
[08:27:54.217]    - call: plan(strategy)
[08:27:54.221] plan(): nbrOfWorkers() = 2
[08:27:54.221] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.221] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.221]   - Field: ‘label’
[08:27:54.221]   - Field: ‘local’
[08:27:54.222]   - Field: ‘owner’
[08:27:54.222]   - Field: ‘envir’
[08:27:54.222]   - Field: ‘workers’
[08:27:54.222]   - Field: ‘packages’
[08:27:54.222]   - Field: ‘gc’
[08:27:54.222]   - Field: ‘job’
[08:27:54.222]   - Field: ‘conditions’
[08:27:54.223]   - Field: ‘expr’
[08:27:54.223]   - Field: ‘uuid’
[08:27:54.223]   - Field: ‘seed’
[08:27:54.223]   - Field: ‘version’
[08:27:54.223]   - Field: ‘result’
[08:27:54.223]   - Field: ‘asynchronous’
[08:27:54.223]   - Field: ‘calls’
[08:27:54.224]   - Field: ‘globals’
[08:27:54.224]   - Field: ‘stdout’
[08:27:54.224]   - Field: ‘earlySignal’
[08:27:54.224]   - Field: ‘lazy’
[08:27:54.224]   - Field: ‘state’
[08:27:54.224] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.225] - Launch lazy future ...
[08:27:54.225] Packages needed by the future expression (n = 0): <none>
[08:27:54.225] Packages needed by future strategies (n = 0): <none>
[08:27:54.226] {
[08:27:54.226]     {
[08:27:54.226]         {
[08:27:54.226]             ...future.startTime <- base::Sys.time()
[08:27:54.226]             {
[08:27:54.226]                 {
[08:27:54.226]                   {
[08:27:54.226]                     {
[08:27:54.226]                       base::local({
[08:27:54.226]                         has_future <- base::requireNamespace("future", 
[08:27:54.226]                           quietly = TRUE)
[08:27:54.226]                         if (has_future) {
[08:27:54.226]                           ns <- base::getNamespace("future")
[08:27:54.226]                           version <- ns[[".package"]][["version"]]
[08:27:54.226]                           if (is.null(version)) 
[08:27:54.226]                             version <- utils::packageVersion("future")
[08:27:54.226]                         }
[08:27:54.226]                         else {
[08:27:54.226]                           version <- NULL
[08:27:54.226]                         }
[08:27:54.226]                         if (!has_future || version < "1.8.0") {
[08:27:54.226]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.226]                             "", base::R.version$version.string), 
[08:27:54.226]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.226]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.226]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.226]                               "release", "version")], collapse = " "), 
[08:27:54.226]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.226]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.226]                             info)
[08:27:54.226]                           info <- base::paste(info, collapse = "; ")
[08:27:54.226]                           if (!has_future) {
[08:27:54.226]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.226]                               info)
[08:27:54.226]                           }
[08:27:54.226]                           else {
[08:27:54.226]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.226]                               info, version)
[08:27:54.226]                           }
[08:27:54.226]                           base::stop(msg)
[08:27:54.226]                         }
[08:27:54.226]                       })
[08:27:54.226]                     }
[08:27:54.226]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.226]                     base::options(mc.cores = 1L)
[08:27:54.226]                   }
[08:27:54.226]                   ...future.strategy.old <- future::plan("list")
[08:27:54.226]                   options(future.plan = NULL)
[08:27:54.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.226]                 }
[08:27:54.226]                 ...future.workdir <- getwd()
[08:27:54.226]             }
[08:27:54.226]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.226]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.226]         }
[08:27:54.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.226]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.226]             base::names(...future.oldOptions))
[08:27:54.226]     }
[08:27:54.226]     if (FALSE) {
[08:27:54.226]     }
[08:27:54.226]     else {
[08:27:54.226]         if (TRUE) {
[08:27:54.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.226]                 open = "w")
[08:27:54.226]         }
[08:27:54.226]         else {
[08:27:54.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.226]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.226]         }
[08:27:54.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.226]             base::sink(type = "output", split = FALSE)
[08:27:54.226]             base::close(...future.stdout)
[08:27:54.226]         }, add = TRUE)
[08:27:54.226]     }
[08:27:54.226]     ...future.frame <- base::sys.nframe()
[08:27:54.226]     ...future.conditions <- base::list()
[08:27:54.226]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.226]     if (FALSE) {
[08:27:54.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.226]     }
[08:27:54.226]     ...future.result <- base::tryCatch({
[08:27:54.226]         base::withCallingHandlers({
[08:27:54.226]             ...future.value <- base::withVisible(base::local({
[08:27:54.226]                 withCallingHandlers({
[08:27:54.226]                   {
[08:27:54.226]                     4
[08:27:54.226]                   }
[08:27:54.226]                 }, immediateCondition = function(cond) {
[08:27:54.226]                   save_rds <- function (object, pathname, ...) 
[08:27:54.226]                   {
[08:27:54.226]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.226]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.226]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.226]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.226]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.226]                         fi_tmp[["mtime"]])
[08:27:54.226]                     }
[08:27:54.226]                     tryCatch({
[08:27:54.226]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.226]                     }, error = function(ex) {
[08:27:54.226]                       msg <- conditionMessage(ex)
[08:27:54.226]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.226]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.226]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.226]                         fi_tmp[["mtime"]], msg)
[08:27:54.226]                       ex$message <- msg
[08:27:54.226]                       stop(ex)
[08:27:54.226]                     })
[08:27:54.226]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.226]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.226]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.226]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.226]                       fi <- file.info(pathname)
[08:27:54.226]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.226]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.226]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.226]                         fi[["size"]], fi[["mtime"]])
[08:27:54.226]                       stop(msg)
[08:27:54.226]                     }
[08:27:54.226]                     invisible(pathname)
[08:27:54.226]                   }
[08:27:54.226]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.226]                     rootPath = tempdir()) 
[08:27:54.226]                   {
[08:27:54.226]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.226]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.226]                       tmpdir = path, fileext = ".rds")
[08:27:54.226]                     save_rds(obj, file)
[08:27:54.226]                   }
[08:27:54.226]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.226]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.226]                   {
[08:27:54.226]                     inherits <- base::inherits
[08:27:54.226]                     invokeRestart <- base::invokeRestart
[08:27:54.226]                     is.null <- base::is.null
[08:27:54.226]                     muffled <- FALSE
[08:27:54.226]                     if (inherits(cond, "message")) {
[08:27:54.226]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.226]                       if (muffled) 
[08:27:54.226]                         invokeRestart("muffleMessage")
[08:27:54.226]                     }
[08:27:54.226]                     else if (inherits(cond, "warning")) {
[08:27:54.226]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.226]                       if (muffled) 
[08:27:54.226]                         invokeRestart("muffleWarning")
[08:27:54.226]                     }
[08:27:54.226]                     else if (inherits(cond, "condition")) {
[08:27:54.226]                       if (!is.null(pattern)) {
[08:27:54.226]                         computeRestarts <- base::computeRestarts
[08:27:54.226]                         grepl <- base::grepl
[08:27:54.226]                         restarts <- computeRestarts(cond)
[08:27:54.226]                         for (restart in restarts) {
[08:27:54.226]                           name <- restart$name
[08:27:54.226]                           if (is.null(name)) 
[08:27:54.226]                             next
[08:27:54.226]                           if (!grepl(pattern, name)) 
[08:27:54.226]                             next
[08:27:54.226]                           invokeRestart(restart)
[08:27:54.226]                           muffled <- TRUE
[08:27:54.226]                           break
[08:27:54.226]                         }
[08:27:54.226]                       }
[08:27:54.226]                     }
[08:27:54.226]                     invisible(muffled)
[08:27:54.226]                   }
[08:27:54.226]                   muffleCondition(cond)
[08:27:54.226]                 })
[08:27:54.226]             }))
[08:27:54.226]             future::FutureResult(value = ...future.value$value, 
[08:27:54.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.226]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.226]                     ...future.globalenv.names))
[08:27:54.226]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.226]         }, condition = base::local({
[08:27:54.226]             c <- base::c
[08:27:54.226]             inherits <- base::inherits
[08:27:54.226]             invokeRestart <- base::invokeRestart
[08:27:54.226]             length <- base::length
[08:27:54.226]             list <- base::list
[08:27:54.226]             seq.int <- base::seq.int
[08:27:54.226]             signalCondition <- base::signalCondition
[08:27:54.226]             sys.calls <- base::sys.calls
[08:27:54.226]             `[[` <- base::`[[`
[08:27:54.226]             `+` <- base::`+`
[08:27:54.226]             `<<-` <- base::`<<-`
[08:27:54.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.226]                   3L)]
[08:27:54.226]             }
[08:27:54.226]             function(cond) {
[08:27:54.226]                 is_error <- inherits(cond, "error")
[08:27:54.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.226]                   NULL)
[08:27:54.226]                 if (is_error) {
[08:27:54.226]                   sessionInformation <- function() {
[08:27:54.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.226]                       search = base::search(), system = base::Sys.info())
[08:27:54.226]                   }
[08:27:54.226]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.226]                     cond$call), session = sessionInformation(), 
[08:27:54.226]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.226]                   signalCondition(cond)
[08:27:54.226]                 }
[08:27:54.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.226]                 "immediateCondition"))) {
[08:27:54.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.226]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.226]                   if (TRUE && !signal) {
[08:27:54.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.226]                     {
[08:27:54.226]                       inherits <- base::inherits
[08:27:54.226]                       invokeRestart <- base::invokeRestart
[08:27:54.226]                       is.null <- base::is.null
[08:27:54.226]                       muffled <- FALSE
[08:27:54.226]                       if (inherits(cond, "message")) {
[08:27:54.226]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.226]                         if (muffled) 
[08:27:54.226]                           invokeRestart("muffleMessage")
[08:27:54.226]                       }
[08:27:54.226]                       else if (inherits(cond, "warning")) {
[08:27:54.226]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.226]                         if (muffled) 
[08:27:54.226]                           invokeRestart("muffleWarning")
[08:27:54.226]                       }
[08:27:54.226]                       else if (inherits(cond, "condition")) {
[08:27:54.226]                         if (!is.null(pattern)) {
[08:27:54.226]                           computeRestarts <- base::computeRestarts
[08:27:54.226]                           grepl <- base::grepl
[08:27:54.226]                           restarts <- computeRestarts(cond)
[08:27:54.226]                           for (restart in restarts) {
[08:27:54.226]                             name <- restart$name
[08:27:54.226]                             if (is.null(name)) 
[08:27:54.226]                               next
[08:27:54.226]                             if (!grepl(pattern, name)) 
[08:27:54.226]                               next
[08:27:54.226]                             invokeRestart(restart)
[08:27:54.226]                             muffled <- TRUE
[08:27:54.226]                             break
[08:27:54.226]                           }
[08:27:54.226]                         }
[08:27:54.226]                       }
[08:27:54.226]                       invisible(muffled)
[08:27:54.226]                     }
[08:27:54.226]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.226]                   }
[08:27:54.226]                 }
[08:27:54.226]                 else {
[08:27:54.226]                   if (TRUE) {
[08:27:54.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.226]                     {
[08:27:54.226]                       inherits <- base::inherits
[08:27:54.226]                       invokeRestart <- base::invokeRestart
[08:27:54.226]                       is.null <- base::is.null
[08:27:54.226]                       muffled <- FALSE
[08:27:54.226]                       if (inherits(cond, "message")) {
[08:27:54.226]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.226]                         if (muffled) 
[08:27:54.226]                           invokeRestart("muffleMessage")
[08:27:54.226]                       }
[08:27:54.226]                       else if (inherits(cond, "warning")) {
[08:27:54.226]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.226]                         if (muffled) 
[08:27:54.226]                           invokeRestart("muffleWarning")
[08:27:54.226]                       }
[08:27:54.226]                       else if (inherits(cond, "condition")) {
[08:27:54.226]                         if (!is.null(pattern)) {
[08:27:54.226]                           computeRestarts <- base::computeRestarts
[08:27:54.226]                           grepl <- base::grepl
[08:27:54.226]                           restarts <- computeRestarts(cond)
[08:27:54.226]                           for (restart in restarts) {
[08:27:54.226]                             name <- restart$name
[08:27:54.226]                             if (is.null(name)) 
[08:27:54.226]                               next
[08:27:54.226]                             if (!grepl(pattern, name)) 
[08:27:54.226]                               next
[08:27:54.226]                             invokeRestart(restart)
[08:27:54.226]                             muffled <- TRUE
[08:27:54.226]                             break
[08:27:54.226]                           }
[08:27:54.226]                         }
[08:27:54.226]                       }
[08:27:54.226]                       invisible(muffled)
[08:27:54.226]                     }
[08:27:54.226]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.226]                   }
[08:27:54.226]                 }
[08:27:54.226]             }
[08:27:54.226]         }))
[08:27:54.226]     }, error = function(ex) {
[08:27:54.226]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.226]                 ...future.rng), started = ...future.startTime, 
[08:27:54.226]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.226]             version = "1.8"), class = "FutureResult")
[08:27:54.226]     }, finally = {
[08:27:54.226]         if (!identical(...future.workdir, getwd())) 
[08:27:54.226]             setwd(...future.workdir)
[08:27:54.226]         {
[08:27:54.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.226]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.226]             }
[08:27:54.226]             base::options(...future.oldOptions)
[08:27:54.226]             if (.Platform$OS.type == "windows") {
[08:27:54.226]                 old_names <- names(...future.oldEnvVars)
[08:27:54.226]                 envs <- base::Sys.getenv()
[08:27:54.226]                 names <- names(envs)
[08:27:54.226]                 common <- intersect(names, old_names)
[08:27:54.226]                 added <- setdiff(names, old_names)
[08:27:54.226]                 removed <- setdiff(old_names, names)
[08:27:54.226]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.226]                   envs[common]]
[08:27:54.226]                 NAMES <- toupper(changed)
[08:27:54.226]                 args <- list()
[08:27:54.226]                 for (kk in seq_along(NAMES)) {
[08:27:54.226]                   name <- changed[[kk]]
[08:27:54.226]                   NAME <- NAMES[[kk]]
[08:27:54.226]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.226]                     next
[08:27:54.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.226]                 }
[08:27:54.226]                 NAMES <- toupper(added)
[08:27:54.226]                 for (kk in seq_along(NAMES)) {
[08:27:54.226]                   name <- added[[kk]]
[08:27:54.226]                   NAME <- NAMES[[kk]]
[08:27:54.226]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.226]                     next
[08:27:54.226]                   args[[name]] <- ""
[08:27:54.226]                 }
[08:27:54.226]                 NAMES <- toupper(removed)
[08:27:54.226]                 for (kk in seq_along(NAMES)) {
[08:27:54.226]                   name <- removed[[kk]]
[08:27:54.226]                   NAME <- NAMES[[kk]]
[08:27:54.226]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.226]                     next
[08:27:54.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.226]                 }
[08:27:54.226]                 if (length(args) > 0) 
[08:27:54.226]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.226]             }
[08:27:54.226]             else {
[08:27:54.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.226]             }
[08:27:54.226]             {
[08:27:54.226]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.226]                   0L) {
[08:27:54.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.226]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.226]                   base::options(opts)
[08:27:54.226]                 }
[08:27:54.226]                 {
[08:27:54.226]                   {
[08:27:54.226]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.226]                     NULL
[08:27:54.226]                   }
[08:27:54.226]                   options(future.plan = NULL)
[08:27:54.226]                   if (is.na(NA_character_)) 
[08:27:54.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.226]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.226]                     .init = FALSE)
[08:27:54.226]                 }
[08:27:54.226]             }
[08:27:54.226]         }
[08:27:54.226]     })
[08:27:54.226]     if (TRUE) {
[08:27:54.226]         base::sink(type = "output", split = FALSE)
[08:27:54.226]         if (TRUE) {
[08:27:54.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.226]         }
[08:27:54.226]         else {
[08:27:54.226]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.226]         }
[08:27:54.226]         base::close(...future.stdout)
[08:27:54.226]         ...future.stdout <- NULL
[08:27:54.226]     }
[08:27:54.226]     ...future.result$conditions <- ...future.conditions
[08:27:54.226]     ...future.result$finished <- base::Sys.time()
[08:27:54.226]     ...future.result
[08:27:54.226] }
[08:27:54.230] requestCore(): workers = 2
[08:27:54.230] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:54.241] result() for MulticoreFuture ...
[08:27:54.242] result() for MulticoreFuture ...
[08:27:54.242] result() for MulticoreFuture ... done
[08:27:54.242] result() for MulticoreFuture ... done
[08:27:54.242] result() for MulticoreFuture ...
[08:27:54.242] result() for MulticoreFuture ... done
[08:27:54.246] MulticoreFuture started
[08:27:54.246] - Launch lazy future ... done
[08:27:54.247] run() for ‘MulticoreFuture’ ... done
[08:27:54.247] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55d86307b290> 
[08:27:54.248] List of future strategies:
[08:27:54.248] 1. sequential:
[08:27:54.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.248]    - tweaked: FALSE
[08:27:54.248]    - call: NULL
[08:27:54.249] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55d86036af50> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=[08:27:54.253] plan(): Setting new future strategy stack:
List of 2
  ..$ :[08:27:54.253] List of future strategies:
[08:27:54.253] 1. multicore:
[08:27:54.253]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.253]    - tweaked: FALSE
[08:27:54.253]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[08:27:54.258] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:54.263] resolve() on list environment ...
[08:27:54.263]  recursive: 0
[08:27:54.265]  length: 6
[08:27:54.265]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:54.265] signalConditionsASAP(numeric, pos=1) ...
[08:27:54.265] - nx: 6
[08:27:54.265] - relay: TRUE
[08:27:54.265] - stdout: TRUE
[08:27:54.266] - signal: TRUE
[08:27:54.266] - resignal: FALSE
[08:27:54.266] - force: TRUE
[08:27:54.266] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.266] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.266]  - until=2
[08:27:54.266]  - relaying element #2
[08:27:54.267] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.267] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.267] signalConditionsASAP(NULL, pos=1) ... done
[08:27:54.267]  length: 5 (resolved future 1)
[08:27:54.267] Future #2
[08:27:54.267] result() for MulticoreFuture ...
[08:27:54.267] result() for MulticoreFuture ... done
[08:27:54.268] result() for MulticoreFuture ...
[08:27:54.268] result() for MulticoreFuture ... done
[08:27:54.268] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:54.268] - nx: 6
[08:27:54.268] - relay: TRUE
[08:27:54.268] - stdout: TRUE
[08:27:54.268] - signal: TRUE
[08:27:54.268] - resignal: FALSE
[08:27:54.269] - force: TRUE
[08:27:54.269] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.269] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.269]  - until=2
[08:27:54.269]  - relaying element #2
[08:27:54.269] result() for MulticoreFuture ...
[08:27:54.269] result() for MulticoreFuture ... done
[08:27:54.269] result() for MulticoreFuture ...
[08:27:54.270] result() for MulticoreFuture ... done
[08:27:54.270] result() for MulticoreFuture ...
[08:27:54.270] result() for MulticoreFuture ... done
[08:27:54.270] result() for MulticoreFuture ...
[08:27:54.270] result() for MulticoreFuture ... done
[08:27:54.270] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.270] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.271] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:54.271]  length: 4 (resolved future 2)
[08:27:54.271] Future #3
[08:27:54.271] result() for MulticoreFuture ...
[08:27:54.272] result() for MulticoreFuture ...
[08:27:54.272] result() for MulticoreFuture ... done
[08:27:54.272] result() for MulticoreFuture ... done
[08:27:54.272] result() for MulticoreFuture ...
[08:27:54.273] result() for MulticoreFuture ... done
[08:27:54.273] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:54.273] - nx: 6
[08:27:54.273] - relay: TRUE
[08:27:54.273] - stdout: TRUE
[08:27:54.273] - signal: TRUE
[08:27:54.273] - resignal: FALSE
[08:27:54.273] - force: TRUE
[08:27:54.274] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.274] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.274]  - until=3
[08:27:54.274]  - relaying element #3
[08:27:54.274] result() for MulticoreFuture ...
[08:27:54.274] result() for MulticoreFuture ... done
[08:27:54.274] result() for MulticoreFuture ...
[08:27:54.274] result() for MulticoreFuture ... done
[08:27:54.275] result() for MulticoreFuture ...
[08:27:54.275] result() for MulticoreFuture ... done
[08:27:54.275] result() for MulticoreFuture ...
[08:27:54.275] result() for MulticoreFuture ... done
[08:27:54.275] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.275] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.275] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:54.275]  length: 3 (resolved future 3)
[08:27:54.276] Future #4
[08:27:54.276] result() for MulticoreFuture ...
[08:27:54.277] result() for MulticoreFuture ...
[08:27:54.277] result() for MulticoreFuture ... done
[08:27:54.277] result() for MulticoreFuture ... done
[08:27:54.277] result() for MulticoreFuture ...
[08:27:54.278] result() for MulticoreFuture ... done
[08:27:54.278] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:54.278] - nx: 6
[08:27:54.278] - relay: TRUE
[08:27:54.278] - stdout: TRUE
[08:27:54.278] - signal: TRUE
[08:27:54.279] - resignal: FALSE
[08:27:54.279] - force: TRUE
[08:27:54.279] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.279] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.279]  - until=4
[08:27:54.279]  - relaying element #4
[08:27:54.280] result() for MulticoreFuture ...
[08:27:54.280] result() for MulticoreFuture ... done
[08:27:54.280] result() for MulticoreFuture ...
[08:27:54.280] result() for MulticoreFuture ... done
[08:27:54.280] result() for MulticoreFuture ...
[08:27:54.280] result() for MulticoreFuture ... done
[08:27:54.281] result() for MulticoreFuture ...
[08:27:54.281] result() for MulticoreFuture ... done
[08:27:54.281] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.281] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.281] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:54.281]  length: 2 (resolved future 4)
[08:27:54.282] signalConditionsASAP(NULL, pos=5) ...
[08:27:54.282] - nx: 6
[08:27:54.282] - relay: TRUE
[08:27:54.282] - stdout: TRUE
[08:27:54.282] - signal: TRUE
[08:27:54.282] - resignal: FALSE
[08:27:54.282] - force: TRUE
[08:27:54.282] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.283] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.283]  - until=6
[08:27:54.283]  - relaying element #6
[08:27:54.283] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.283] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.283] signalConditionsASAP(NULL, pos=5) ... done
[08:27:54.283]  length: 1 (resolved future 5)
[08:27:54.283] signalConditionsASAP(numeric, pos=6) ...
[08:27:54.283] - nx: 6
[08:27:54.283] - relay: TRUE
[08:27:54.284] - stdout: TRUE
[08:27:54.284] - signal: TRUE
[08:27:54.284] - resignal: FALSE
[08:27:54.284] - force: TRUE
[08:27:54.284] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.284] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.284]  - until=6
[08:27:54.284] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.284] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.284] signalConditionsASAP(numeric, pos=6) ... done
[08:27:54.284]  length: 0 (resolved future 6)
[08:27:54.285] Relaying remaining futures
[08:27:54.285] signalConditionsASAP(NULL, pos=0) ...
[08:27:54.285] - nx: 6
[08:27:54.285] - relay: TRUE
[08:27:54.285] - stdout: TRUE
[08:27:54.285] - signal: TRUE
[08:27:54.285] - resignal: FALSE
[08:27:54.285] - force: TRUE
[08:27:54.285] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.285] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:54.286] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.286] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.286] signalConditionsASAP(NULL, pos=0) ... done
[08:27:54.286] resolve() on list environment ... DONE
[08:27:54.286] result() for MulticoreFuture ...
[08:27:54.286] result() for MulticoreFuture ... done
[08:27:54.286] result() for MulticoreFuture ...
[08:27:54.286] result() for MulticoreFuture ... done
[08:27:54.286] result() for MulticoreFuture ...
[08:27:54.287] result() for MulticoreFuture ... done
[08:27:54.287] result() for MulticoreFuture ...
[08:27:54.287] result() for MulticoreFuture ... done
[08:27:54.287] result() for MulticoreFuture ...
[08:27:54.287] result() for MulticoreFuture ... done
[08:27:54.287] result() for MulticoreFuture ...
[08:27:54.287] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d85f412470> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[08:27:54.289] getGlobalsAndPackages() ...
[08:27:54.289] Searching for globals...
[08:27:54.290] 
[08:27:54.290] Searching for globals ... DONE
[08:27:54.290] - globals: [0] <none>
[08:27:54.290] getGlobalsAndPackages() ... DONE
[08:27:54.291] run() for ‘Future’ ...
[08:27:54.291] - state: ‘created’
[08:27:54.291] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.293] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.293]   - Field: ‘label’
[08:27:54.293]   - Field: ‘local’
[08:27:54.294]   - Field: ‘owner’
[08:27:54.294]   - Field: ‘envir’
[08:27:54.294]   - Field: ‘workers’
[08:27:54.294]   - Field: ‘packages’
[08:27:54.294]   - Field: ‘gc’
[08:27:54.294]   - Field: ‘job’
[08:27:54.294]   - Field: ‘conditions’
[08:27:54.294]   - Field: ‘expr’
[08:27:54.294]   - Field: ‘uuid’
[08:27:54.294]   - Field: ‘seed’
[08:27:54.295]   - Field: ‘version’
[08:27:54.295]   - Field: ‘result’
[08:27:54.295]   - Field: ‘asynchronous’
[08:27:54.295]   - Field: ‘calls’
[08:27:54.295]   - Field: ‘globals’
[08:27:54.295]   - Field: ‘stdout’
[08:27:54.295]   - Field: ‘earlySignal’
[08:27:54.295]   - Field: ‘lazy’
[08:27:54.295]   - Field: ‘state’
[08:27:54.296] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.296] - Launch lazy future ...
[08:27:54.296] Packages needed by the future expression (n = 0): <none>
[08:27:54.296] Packages needed by future strategies (n = 0): <none>
[08:27:54.297] {
[08:27:54.297]     {
[08:27:54.297]         {
[08:27:54.297]             ...future.startTime <- base::Sys.time()
[08:27:54.297]             {
[08:27:54.297]                 {
[08:27:54.297]                   {
[08:27:54.297]                     {
[08:27:54.297]                       base::local({
[08:27:54.297]                         has_future <- base::requireNamespace("future", 
[08:27:54.297]                           quietly = TRUE)
[08:27:54.297]                         if (has_future) {
[08:27:54.297]                           ns <- base::getNamespace("future")
[08:27:54.297]                           version <- ns[[".package"]][["version"]]
[08:27:54.297]                           if (is.null(version)) 
[08:27:54.297]                             version <- utils::packageVersion("future")
[08:27:54.297]                         }
[08:27:54.297]                         else {
[08:27:54.297]                           version <- NULL
[08:27:54.297]                         }
[08:27:54.297]                         if (!has_future || version < "1.8.0") {
[08:27:54.297]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.297]                             "", base::R.version$version.string), 
[08:27:54.297]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.297]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.297]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.297]                               "release", "version")], collapse = " "), 
[08:27:54.297]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.297]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.297]                             info)
[08:27:54.297]                           info <- base::paste(info, collapse = "; ")
[08:27:54.297]                           if (!has_future) {
[08:27:54.297]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.297]                               info)
[08:27:54.297]                           }
[08:27:54.297]                           else {
[08:27:54.297]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.297]                               info, version)
[08:27:54.297]                           }
[08:27:54.297]                           base::stop(msg)
[08:27:54.297]                         }
[08:27:54.297]                       })
[08:27:54.297]                     }
[08:27:54.297]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.297]                     base::options(mc.cores = 1L)
[08:27:54.297]                   }
[08:27:54.297]                   ...future.strategy.old <- future::plan("list")
[08:27:54.297]                   options(future.plan = NULL)
[08:27:54.297]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.297]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.297]                 }
[08:27:54.297]                 ...future.workdir <- getwd()
[08:27:54.297]             }
[08:27:54.297]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.297]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.297]         }
[08:27:54.297]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.297]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.297]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.297]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.297]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.297]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.297]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.297]             base::names(...future.oldOptions))
[08:27:54.297]     }
[08:27:54.297]     if (FALSE) {
[08:27:54.297]     }
[08:27:54.297]     else {
[08:27:54.297]         if (TRUE) {
[08:27:54.297]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.297]                 open = "w")
[08:27:54.297]         }
[08:27:54.297]         else {
[08:27:54.297]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.297]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.297]         }
[08:27:54.297]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.297]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.297]             base::sink(type = "output", split = FALSE)
[08:27:54.297]             base::close(...future.stdout)
[08:27:54.297]         }, add = TRUE)
[08:27:54.297]     }
[08:27:54.297]     ...future.frame <- base::sys.nframe()
[08:27:54.297]     ...future.conditions <- base::list()
[08:27:54.297]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.297]     if (FALSE) {
[08:27:54.297]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.297]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.297]     }
[08:27:54.297]     ...future.result <- base::tryCatch({
[08:27:54.297]         base::withCallingHandlers({
[08:27:54.297]             ...future.value <- base::withVisible(base::local({
[08:27:54.297]                 withCallingHandlers({
[08:27:54.297]                   2
[08:27:54.297]                 }, immediateCondition = function(cond) {
[08:27:54.297]                   save_rds <- function (object, pathname, ...) 
[08:27:54.297]                   {
[08:27:54.297]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.297]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.297]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.297]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.297]                         fi_tmp[["mtime"]])
[08:27:54.297]                     }
[08:27:54.297]                     tryCatch({
[08:27:54.297]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.297]                     }, error = function(ex) {
[08:27:54.297]                       msg <- conditionMessage(ex)
[08:27:54.297]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.297]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.297]                         fi_tmp[["mtime"]], msg)
[08:27:54.297]                       ex$message <- msg
[08:27:54.297]                       stop(ex)
[08:27:54.297]                     })
[08:27:54.297]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.297]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.297]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.297]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.297]                       fi <- file.info(pathname)
[08:27:54.297]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.297]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.297]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.297]                         fi[["size"]], fi[["mtime"]])
[08:27:54.297]                       stop(msg)
[08:27:54.297]                     }
[08:27:54.297]                     invisible(pathname)
[08:27:54.297]                   }
[08:27:54.297]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.297]                     rootPath = tempdir()) 
[08:27:54.297]                   {
[08:27:54.297]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.297]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.297]                       tmpdir = path, fileext = ".rds")
[08:27:54.297]                     save_rds(obj, file)
[08:27:54.297]                   }
[08:27:54.297]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.297]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.297]                   {
[08:27:54.297]                     inherits <- base::inherits
[08:27:54.297]                     invokeRestart <- base::invokeRestart
[08:27:54.297]                     is.null <- base::is.null
[08:27:54.297]                     muffled <- FALSE
[08:27:54.297]                     if (inherits(cond, "message")) {
[08:27:54.297]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.297]                       if (muffled) 
[08:27:54.297]                         invokeRestart("muffleMessage")
[08:27:54.297]                     }
[08:27:54.297]                     else if (inherits(cond, "warning")) {
[08:27:54.297]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.297]                       if (muffled) 
[08:27:54.297]                         invokeRestart("muffleWarning")
[08:27:54.297]                     }
[08:27:54.297]                     else if (inherits(cond, "condition")) {
[08:27:54.297]                       if (!is.null(pattern)) {
[08:27:54.297]                         computeRestarts <- base::computeRestarts
[08:27:54.297]                         grepl <- base::grepl
[08:27:54.297]                         restarts <- computeRestarts(cond)
[08:27:54.297]                         for (restart in restarts) {
[08:27:54.297]                           name <- restart$name
[08:27:54.297]                           if (is.null(name)) 
[08:27:54.297]                             next
[08:27:54.297]                           if (!grepl(pattern, name)) 
[08:27:54.297]                             next
[08:27:54.297]                           invokeRestart(restart)
[08:27:54.297]                           muffled <- TRUE
[08:27:54.297]                           break
[08:27:54.297]                         }
[08:27:54.297]                       }
[08:27:54.297]                     }
[08:27:54.297]                     invisible(muffled)
[08:27:54.297]                   }
[08:27:54.297]                   muffleCondition(cond)
[08:27:54.297]                 })
[08:27:54.297]             }))
[08:27:54.297]             future::FutureResult(value = ...future.value$value, 
[08:27:54.297]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.297]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.297]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.297]                     ...future.globalenv.names))
[08:27:54.297]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.297]         }, condition = base::local({
[08:27:54.297]             c <- base::c
[08:27:54.297]             inherits <- base::inherits
[08:27:54.297]             invokeRestart <- base::invokeRestart
[08:27:54.297]             length <- base::length
[08:27:54.297]             list <- base::list
[08:27:54.297]             seq.int <- base::seq.int
[08:27:54.297]             signalCondition <- base::signalCondition
[08:27:54.297]             sys.calls <- base::sys.calls
[08:27:54.297]             `[[` <- base::`[[`
[08:27:54.297]             `+` <- base::`+`
[08:27:54.297]             `<<-` <- base::`<<-`
[08:27:54.297]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.297]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.297]                   3L)]
[08:27:54.297]             }
[08:27:54.297]             function(cond) {
[08:27:54.297]                 is_error <- inherits(cond, "error")
[08:27:54.297]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.297]                   NULL)
[08:27:54.297]                 if (is_error) {
[08:27:54.297]                   sessionInformation <- function() {
[08:27:54.297]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.297]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.297]                       search = base::search(), system = base::Sys.info())
[08:27:54.297]                   }
[08:27:54.297]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.297]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.297]                     cond$call), session = sessionInformation(), 
[08:27:54.297]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.297]                   signalCondition(cond)
[08:27:54.297]                 }
[08:27:54.297]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.297]                 "immediateCondition"))) {
[08:27:54.297]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.297]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.297]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.297]                   if (TRUE && !signal) {
[08:27:54.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.297]                     {
[08:27:54.297]                       inherits <- base::inherits
[08:27:54.297]                       invokeRestart <- base::invokeRestart
[08:27:54.297]                       is.null <- base::is.null
[08:27:54.297]                       muffled <- FALSE
[08:27:54.297]                       if (inherits(cond, "message")) {
[08:27:54.297]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.297]                         if (muffled) 
[08:27:54.297]                           invokeRestart("muffleMessage")
[08:27:54.297]                       }
[08:27:54.297]                       else if (inherits(cond, "warning")) {
[08:27:54.297]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.297]                         if (muffled) 
[08:27:54.297]                           invokeRestart("muffleWarning")
[08:27:54.297]                       }
[08:27:54.297]                       else if (inherits(cond, "condition")) {
[08:27:54.297]                         if (!is.null(pattern)) {
[08:27:54.297]                           computeRestarts <- base::computeRestarts
[08:27:54.297]                           grepl <- base::grepl
[08:27:54.297]                           restarts <- computeRestarts(cond)
[08:27:54.297]                           for (restart in restarts) {
[08:27:54.297]                             name <- restart$name
[08:27:54.297]                             if (is.null(name)) 
[08:27:54.297]                               next
[08:27:54.297]                             if (!grepl(pattern, name)) 
[08:27:54.297]                               next
[08:27:54.297]                             invokeRestart(restart)
[08:27:54.297]                             muffled <- TRUE
[08:27:54.297]                             break
[08:27:54.297]                           }
[08:27:54.297]                         }
[08:27:54.297]                       }
[08:27:54.297]                       invisible(muffled)
[08:27:54.297]                     }
[08:27:54.297]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.297]                   }
[08:27:54.297]                 }
[08:27:54.297]                 else {
[08:27:54.297]                   if (TRUE) {
[08:27:54.297]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.297]                     {
[08:27:54.297]                       inherits <- base::inherits
[08:27:54.297]                       invokeRestart <- base::invokeRestart
[08:27:54.297]                       is.null <- base::is.null
[08:27:54.297]                       muffled <- FALSE
[08:27:54.297]                       if (inherits(cond, "message")) {
[08:27:54.297]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.297]                         if (muffled) 
[08:27:54.297]                           invokeRestart("muffleMessage")
[08:27:54.297]                       }
[08:27:54.297]                       else if (inherits(cond, "warning")) {
[08:27:54.297]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.297]                         if (muffled) 
[08:27:54.297]                           invokeRestart("muffleWarning")
[08:27:54.297]                       }
[08:27:54.297]                       else if (inherits(cond, "condition")) {
[08:27:54.297]                         if (!is.null(pattern)) {
[08:27:54.297]                           computeRestarts <- base::computeRestarts
[08:27:54.297]                           grepl <- base::grepl
[08:27:54.297]                           restarts <- computeRestarts(cond)
[08:27:54.297]                           for (restart in restarts) {
[08:27:54.297]                             name <- restart$name
[08:27:54.297]                             if (is.null(name)) 
[08:27:54.297]                               next
[08:27:54.297]                             if (!grepl(pattern, name)) 
[08:27:54.297]                               next
[08:27:54.297]                             invokeRestart(restart)
[08:27:54.297]                             muffled <- TRUE
[08:27:54.297]                             break
[08:27:54.297]                           }
[08:27:54.297]                         }
[08:27:54.297]                       }
[08:27:54.297]                       invisible(muffled)
[08:27:54.297]                     }
[08:27:54.297]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.297]                   }
[08:27:54.297]                 }
[08:27:54.297]             }
[08:27:54.297]         }))
[08:27:54.297]     }, error = function(ex) {
[08:27:54.297]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.297]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.297]                 ...future.rng), started = ...future.startTime, 
[08:27:54.297]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.297]             version = "1.8"), class = "FutureResult")
[08:27:54.297]     }, finally = {
[08:27:54.297]         if (!identical(...future.workdir, getwd())) 
[08:27:54.297]             setwd(...future.workdir)
[08:27:54.297]         {
[08:27:54.297]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.297]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.297]             }
[08:27:54.297]             base::options(...future.oldOptions)
[08:27:54.297]             if (.Platform$OS.type == "windows") {
[08:27:54.297]                 old_names <- names(...future.oldEnvVars)
[08:27:54.297]                 envs <- base::Sys.getenv()
[08:27:54.297]                 names <- names(envs)
[08:27:54.297]                 common <- intersect(names, old_names)
[08:27:54.297]                 added <- setdiff(names, old_names)
[08:27:54.297]                 removed <- setdiff(old_names, names)
[08:27:54.297]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.297]                   envs[common]]
[08:27:54.297]                 NAMES <- toupper(changed)
[08:27:54.297]                 args <- list()
[08:27:54.297]                 for (kk in seq_along(NAMES)) {
[08:27:54.297]                   name <- changed[[kk]]
[08:27:54.297]                   NAME <- NAMES[[kk]]
[08:27:54.297]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.297]                     next
[08:27:54.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.297]                 }
[08:27:54.297]                 NAMES <- toupper(added)
[08:27:54.297]                 for (kk in seq_along(NAMES)) {
[08:27:54.297]                   name <- added[[kk]]
[08:27:54.297]                   NAME <- NAMES[[kk]]
[08:27:54.297]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.297]                     next
[08:27:54.297]                   args[[name]] <- ""
[08:27:54.297]                 }
[08:27:54.297]                 NAMES <- toupper(removed)
[08:27:54.297]                 for (kk in seq_along(NAMES)) {
[08:27:54.297]                   name <- removed[[kk]]
[08:27:54.297]                   NAME <- NAMES[[kk]]
[08:27:54.297]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.297]                     next
[08:27:54.297]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.297]                 }
[08:27:54.297]                 if (length(args) > 0) 
[08:27:54.297]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.297]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.297]             }
[08:27:54.297]             else {
[08:27:54.297]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.297]             }
[08:27:54.297]             {
[08:27:54.297]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.297]                   0L) {
[08:27:54.297]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.297]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.297]                   base::options(opts)
[08:27:54.297]                 }
[08:27:54.297]                 {
[08:27:54.297]                   {
[08:27:54.297]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.297]                     NULL
[08:27:54.297]                   }
[08:27:54.297]                   options(future.plan = NULL)
[08:27:54.297]                   if (is.na(NA_character_)) 
[08:27:54.297]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.297]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.297]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.297]                     .init = FALSE)
[08:27:54.297]                 }
[08:27:54.297]             }
[08:27:54.297]         }
[08:27:54.297]     })
[08:27:54.297]     if (TRUE) {
[08:27:54.297]         base::sink(type = "output", split = FALSE)
[08:27:54.297]         if (TRUE) {
[08:27:54.297]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.297]         }
[08:27:54.297]         else {
[08:27:54.297]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.297]         }
[08:27:54.297]         base::close(...future.stdout)
[08:27:54.297]         ...future.stdout <- NULL
[08:27:54.297]     }
[08:27:54.297]     ...future.result$conditions <- ...future.conditions
[08:27:54.297]     ...future.result$finished <- base::Sys.time()
[08:27:54.297]     ...future.result
[08:27:54.297] }
[08:27:54.299] requestCore(): workers = 2
[08:27:54.302] MulticoreFuture started
[08:27:54.303] - Launch lazy future ... done
[08:27:54.303] run() for ‘MulticoreFuture’ ... done
[08:27:54.303] getGlobalsAndPackages() ...
[08:27:54.303] Searching for globals...
[08:27:54.303] plan(): Setting new future strategy stack:
[08:27:54.304] 
[08:27:54.304] Searching for globals ... DONE
[08:27:54.304] List of future strategies:
[08:27:54.304] 1. sequential:
[08:27:54.304]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.304]    - tweaked: FALSE
[08:27:54.304]    - call: NULL
[08:27:54.304] - globals: [0] <none>
[08:27:54.304] getGlobalsAndPackages() ... DONE
[08:27:54.305] plan(): nbrOfWorkers() = 1
[08:27:54.305] run() for ‘Future’ ...
[08:27:54.305] - state: ‘created’
[08:27:54.305] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.307] plan(): Setting new future strategy stack:
[08:27:54.307] List of future strategies:
[08:27:54.307] 1. multicore:
[08:27:54.307]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.307]    - tweaked: FALSE
[08:27:54.307]    - call: plan(strategy)
[08:27:54.309] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.309] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.309] plan(): nbrOfWorkers() = 2
[08:27:54.309]   - Field: ‘label’
[08:27:54.309]   - Field: ‘local’
[08:27:54.310]   - Field: ‘owner’
[08:27:54.310]   - Field: ‘envir’
[08:27:54.310]   - Field: ‘workers’
[08:27:54.310]   - Field: ‘packages’
[08:27:54.310]   - Field: ‘gc’
[08:27:54.310]   - Field: ‘job’
[08:27:54.310]   - Field: ‘conditions’
[08:27:54.310]   - Field: ‘expr’
[08:27:54.311]   - Field: ‘uuid’
[08:27:54.311]   - Field: ‘seed’
[08:27:54.311]   - Field: ‘version’
[08:27:54.311]   - Field: ‘result’
[08:27:54.311]   - Field: ‘asynchronous’
[08:27:54.311]   - Field: ‘calls’
[08:27:54.311]   - Field: ‘globals’
[08:27:54.311]   - Field: ‘stdout’
[08:27:54.312]   - Field: ‘earlySignal’
[08:27:54.312]   - Field: ‘lazy’
[08:27:54.312]   - Field: ‘state’
[08:27:54.312] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.312] - Launch lazy future ...
[08:27:54.313] Packages needed by the future expression (n = 0): <none>
[08:27:54.313] Packages needed by future strategies (n = 0): <none>
[08:27:54.314] {
[08:27:54.314]     {
[08:27:54.314]         {
[08:27:54.314]             ...future.startTime <- base::Sys.time()
[08:27:54.314]             {
[08:27:54.314]                 {
[08:27:54.314]                   {
[08:27:54.314]                     {
[08:27:54.314]                       base::local({
[08:27:54.314]                         has_future <- base::requireNamespace("future", 
[08:27:54.314]                           quietly = TRUE)
[08:27:54.314]                         if (has_future) {
[08:27:54.314]                           ns <- base::getNamespace("future")
[08:27:54.314]                           version <- ns[[".package"]][["version"]]
[08:27:54.314]                           if (is.null(version)) 
[08:27:54.314]                             version <- utils::packageVersion("future")
[08:27:54.314]                         }
[08:27:54.314]                         else {
[08:27:54.314]                           version <- NULL
[08:27:54.314]                         }
[08:27:54.314]                         if (!has_future || version < "1.8.0") {
[08:27:54.314]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.314]                             "", base::R.version$version.string), 
[08:27:54.314]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.314]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.314]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.314]                               "release", "version")], collapse = " "), 
[08:27:54.314]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.314]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.314]                             info)
[08:27:54.314]                           info <- base::paste(info, collapse = "; ")
[08:27:54.314]                           if (!has_future) {
[08:27:54.314]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.314]                               info)
[08:27:54.314]                           }
[08:27:54.314]                           else {
[08:27:54.314]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.314]                               info, version)
[08:27:54.314]                           }
[08:27:54.314]                           base::stop(msg)
[08:27:54.314]                         }
[08:27:54.314]                       })
[08:27:54.314]                     }
[08:27:54.314]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.314]                     base::options(mc.cores = 1L)
[08:27:54.314]                   }
[08:27:54.314]                   ...future.strategy.old <- future::plan("list")
[08:27:54.314]                   options(future.plan = NULL)
[08:27:54.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.314]                 }
[08:27:54.314]                 ...future.workdir <- getwd()
[08:27:54.314]             }
[08:27:54.314]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.314]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.314]         }
[08:27:54.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.314]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.314]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.314]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.314]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.314]             base::names(...future.oldOptions))
[08:27:54.314]     }
[08:27:54.314]     if (FALSE) {
[08:27:54.314]     }
[08:27:54.314]     else {
[08:27:54.314]         if (TRUE) {
[08:27:54.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.314]                 open = "w")
[08:27:54.314]         }
[08:27:54.314]         else {
[08:27:54.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.314]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.314]         }
[08:27:54.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.314]             base::sink(type = "output", split = FALSE)
[08:27:54.314]             base::close(...future.stdout)
[08:27:54.314]         }, add = TRUE)
[08:27:54.314]     }
[08:27:54.314]     ...future.frame <- base::sys.nframe()
[08:27:54.314]     ...future.conditions <- base::list()
[08:27:54.314]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.314]     if (FALSE) {
[08:27:54.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.314]     }
[08:27:54.314]     ...future.result <- base::tryCatch({
[08:27:54.314]         base::withCallingHandlers({
[08:27:54.314]             ...future.value <- base::withVisible(base::local({
[08:27:54.314]                 withCallingHandlers({
[08:27:54.314]                   NULL
[08:27:54.314]                 }, immediateCondition = function(cond) {
[08:27:54.314]                   save_rds <- function (object, pathname, ...) 
[08:27:54.314]                   {
[08:27:54.314]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.314]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.314]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.314]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.314]                         fi_tmp[["mtime"]])
[08:27:54.314]                     }
[08:27:54.314]                     tryCatch({
[08:27:54.314]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.314]                     }, error = function(ex) {
[08:27:54.314]                       msg <- conditionMessage(ex)
[08:27:54.314]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.314]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.314]                         fi_tmp[["mtime"]], msg)
[08:27:54.314]                       ex$message <- msg
[08:27:54.314]                       stop(ex)
[08:27:54.314]                     })
[08:27:54.314]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.314]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.314]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.314]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.314]                       fi <- file.info(pathname)
[08:27:54.314]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.314]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.314]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.314]                         fi[["size"]], fi[["mtime"]])
[08:27:54.314]                       stop(msg)
[08:27:54.314]                     }
[08:27:54.314]                     invisible(pathname)
[08:27:54.314]                   }
[08:27:54.314]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.314]                     rootPath = tempdir()) 
[08:27:54.314]                   {
[08:27:54.314]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.314]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.314]                       tmpdir = path, fileext = ".rds")
[08:27:54.314]                     save_rds(obj, file)
[08:27:54.314]                   }
[08:27:54.314]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.314]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.314]                   {
[08:27:54.314]                     inherits <- base::inherits
[08:27:54.314]                     invokeRestart <- base::invokeRestart
[08:27:54.314]                     is.null <- base::is.null
[08:27:54.314]                     muffled <- FALSE
[08:27:54.314]                     if (inherits(cond, "message")) {
[08:27:54.314]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.314]                       if (muffled) 
[08:27:54.314]                         invokeRestart("muffleMessage")
[08:27:54.314]                     }
[08:27:54.314]                     else if (inherits(cond, "warning")) {
[08:27:54.314]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.314]                       if (muffled) 
[08:27:54.314]                         invokeRestart("muffleWarning")
[08:27:54.314]                     }
[08:27:54.314]                     else if (inherits(cond, "condition")) {
[08:27:54.314]                       if (!is.null(pattern)) {
[08:27:54.314]                         computeRestarts <- base::computeRestarts
[08:27:54.314]                         grepl <- base::grepl
[08:27:54.314]                         restarts <- computeRestarts(cond)
[08:27:54.314]                         for (restart in restarts) {
[08:27:54.314]                           name <- restart$name
[08:27:54.314]                           if (is.null(name)) 
[08:27:54.314]                             next
[08:27:54.314]                           if (!grepl(pattern, name)) 
[08:27:54.314]                             next
[08:27:54.314]                           invokeRestart(restart)
[08:27:54.314]                           muffled <- TRUE
[08:27:54.314]                           break
[08:27:54.314]                         }
[08:27:54.314]                       }
[08:27:54.314]                     }
[08:27:54.314]                     invisible(muffled)
[08:27:54.314]                   }
[08:27:54.314]                   muffleCondition(cond)
[08:27:54.314]                 })
[08:27:54.314]             }))
[08:27:54.314]             future::FutureResult(value = ...future.value$value, 
[08:27:54.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.314]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.314]                     ...future.globalenv.names))
[08:27:54.314]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.314]         }, condition = base::local({
[08:27:54.314]             c <- base::c
[08:27:54.314]             inherits <- base::inherits
[08:27:54.314]             invokeRestart <- base::invokeRestart
[08:27:54.314]             length <- base::length
[08:27:54.314]             list <- base::list
[08:27:54.314]             seq.int <- base::seq.int
[08:27:54.314]             signalCondition <- base::signalCondition
[08:27:54.314]             sys.calls <- base::sys.calls
[08:27:54.314]             `[[` <- base::`[[`
[08:27:54.314]             `+` <- base::`+`
[08:27:54.314]             `<<-` <- base::`<<-`
[08:27:54.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.314]                   3L)]
[08:27:54.314]             }
[08:27:54.314]             function(cond) {
[08:27:54.314]                 is_error <- inherits(cond, "error")
[08:27:54.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.314]                   NULL)
[08:27:54.314]                 if (is_error) {
[08:27:54.314]                   sessionInformation <- function() {
[08:27:54.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.314]                       search = base::search(), system = base::Sys.info())
[08:27:54.314]                   }
[08:27:54.314]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.314]                     cond$call), session = sessionInformation(), 
[08:27:54.314]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.314]                   signalCondition(cond)
[08:27:54.314]                 }
[08:27:54.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.314]                 "immediateCondition"))) {
[08:27:54.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.314]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.314]                   if (TRUE && !signal) {
[08:27:54.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.314]                     {
[08:27:54.314]                       inherits <- base::inherits
[08:27:54.314]                       invokeRestart <- base::invokeRestart
[08:27:54.314]                       is.null <- base::is.null
[08:27:54.314]                       muffled <- FALSE
[08:27:54.314]                       if (inherits(cond, "message")) {
[08:27:54.314]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.314]                         if (muffled) 
[08:27:54.314]                           invokeRestart("muffleMessage")
[08:27:54.314]                       }
[08:27:54.314]                       else if (inherits(cond, "warning")) {
[08:27:54.314]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.314]                         if (muffled) 
[08:27:54.314]                           invokeRestart("muffleWarning")
[08:27:54.314]                       }
[08:27:54.314]                       else if (inherits(cond, "condition")) {
[08:27:54.314]                         if (!is.null(pattern)) {
[08:27:54.314]                           computeRestarts <- base::computeRestarts
[08:27:54.314]                           grepl <- base::grepl
[08:27:54.314]                           restarts <- computeRestarts(cond)
[08:27:54.314]                           for (restart in restarts) {
[08:27:54.314]                             name <- restart$name
[08:27:54.314]                             if (is.null(name)) 
[08:27:54.314]                               next
[08:27:54.314]                             if (!grepl(pattern, name)) 
[08:27:54.314]                               next
[08:27:54.314]                             invokeRestart(restart)
[08:27:54.314]                             muffled <- TRUE
[08:27:54.314]                             break
[08:27:54.314]                           }
[08:27:54.314]                         }
[08:27:54.314]                       }
[08:27:54.314]                       invisible(muffled)
[08:27:54.314]                     }
[08:27:54.314]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.314]                   }
[08:27:54.314]                 }
[08:27:54.314]                 else {
[08:27:54.314]                   if (TRUE) {
[08:27:54.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.314]                     {
[08:27:54.314]                       inherits <- base::inherits
[08:27:54.314]                       invokeRestart <- base::invokeRestart
[08:27:54.314]                       is.null <- base::is.null
[08:27:54.314]                       muffled <- FALSE
[08:27:54.314]                       if (inherits(cond, "message")) {
[08:27:54.314]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.314]                         if (muffled) 
[08:27:54.314]                           invokeRestart("muffleMessage")
[08:27:54.314]                       }
[08:27:54.314]                       else if (inherits(cond, "warning")) {
[08:27:54.314]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.314]                         if (muffled) 
[08:27:54.314]                           invokeRestart("muffleWarning")
[08:27:54.314]                       }
[08:27:54.314]                       else if (inherits(cond, "condition")) {
[08:27:54.314]                         if (!is.null(pattern)) {
[08:27:54.314]                           computeRestarts <- base::computeRestarts
[08:27:54.314]                           grepl <- base::grepl
[08:27:54.314]                           restarts <- computeRestarts(cond)
[08:27:54.314]                           for (restart in restarts) {
[08:27:54.314]                             name <- restart$name
[08:27:54.314]                             if (is.null(name)) 
[08:27:54.314]                               next
[08:27:54.314]                             if (!grepl(pattern, name)) 
[08:27:54.314]                               next
[08:27:54.314]                             invokeRestart(restart)
[08:27:54.314]                             muffled <- TRUE
[08:27:54.314]                             break
[08:27:54.314]                           }
[08:27:54.314]                         }
[08:27:54.314]                       }
[08:27:54.314]                       invisible(muffled)
[08:27:54.314]                     }
[08:27:54.314]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.314]                   }
[08:27:54.314]                 }
[08:27:54.314]             }
[08:27:54.314]         }))
[08:27:54.314]     }, error = function(ex) {
[08:27:54.314]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.314]                 ...future.rng), started = ...future.startTime, 
[08:27:54.314]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.314]             version = "1.8"), class = "FutureResult")
[08:27:54.314]     }, finally = {
[08:27:54.314]         if (!identical(...future.workdir, getwd())) 
[08:27:54.314]             setwd(...future.workdir)
[08:27:54.314]         {
[08:27:54.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.314]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.314]             }
[08:27:54.314]             base::options(...future.oldOptions)
[08:27:54.314]             if (.Platform$OS.type == "windows") {
[08:27:54.314]                 old_names <- names(...future.oldEnvVars)
[08:27:54.314]                 envs <- base::Sys.getenv()
[08:27:54.314]                 names <- names(envs)
[08:27:54.314]                 common <- intersect(names, old_names)
[08:27:54.314]                 added <- setdiff(names, old_names)
[08:27:54.314]                 removed <- setdiff(old_names, names)
[08:27:54.314]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.314]                   envs[common]]
[08:27:54.314]                 NAMES <- toupper(changed)
[08:27:54.314]                 args <- list()
[08:27:54.314]                 for (kk in seq_along(NAMES)) {
[08:27:54.314]                   name <- changed[[kk]]
[08:27:54.314]                   NAME <- NAMES[[kk]]
[08:27:54.314]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.314]                     next
[08:27:54.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.314]                 }
[08:27:54.314]                 NAMES <- toupper(added)
[08:27:54.314]                 for (kk in seq_along(NAMES)) {
[08:27:54.314]                   name <- added[[kk]]
[08:27:54.314]                   NAME <- NAMES[[kk]]
[08:27:54.314]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.314]                     next
[08:27:54.314]                   args[[name]] <- ""
[08:27:54.314]                 }
[08:27:54.314]                 NAMES <- toupper(removed)
[08:27:54.314]                 for (kk in seq_along(NAMES)) {
[08:27:54.314]                   name <- removed[[kk]]
[08:27:54.314]                   NAME <- NAMES[[kk]]
[08:27:54.314]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.314]                     next
[08:27:54.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.314]                 }
[08:27:54.314]                 if (length(args) > 0) 
[08:27:54.314]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.314]             }
[08:27:54.314]             else {
[08:27:54.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.314]             }
[08:27:54.314]             {
[08:27:54.314]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.314]                   0L) {
[08:27:54.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.314]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.314]                   base::options(opts)
[08:27:54.314]                 }
[08:27:54.314]                 {
[08:27:54.314]                   {
[08:27:54.314]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.314]                     NULL
[08:27:54.314]                   }
[08:27:54.314]                   options(future.plan = NULL)
[08:27:54.314]                   if (is.na(NA_character_)) 
[08:27:54.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.314]                     .init = FALSE)
[08:27:54.314]                 }
[08:27:54.314]             }
[08:27:54.314]         }
[08:27:54.314]     })
[08:27:54.314]     if (TRUE) {
[08:27:54.314]         base::sink(type = "output", split = FALSE)
[08:27:54.314]         if (TRUE) {
[08:27:54.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.314]         }
[08:27:54.314]         else {
[08:27:54.314]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.314]         }
[08:27:54.314]         base::close(...future.stdout)
[08:27:54.314]         ...future.stdout <- NULL
[08:27:54.314]     }
[08:27:54.314]     ...future.result$conditions <- ...future.conditions
[08:27:54.314]     ...future.result$finished <- base::Sys.time()
[08:27:54.314]     ...future.result
[08:27:54.314] }
[08:27:54.317] requestCore(): workers = 2
[08:27:54.321] MulticoreFuture started
[08:27:54.321] - Launch lazy future ... done
[08:27:54.321] run() for ‘MulticoreFuture’ ... done
[08:27:54.322] plan(): Setting new future strategy stack:
[08:27:54.322] getGlobalsAndPackages() ...
[08:27:54.322] Searching for globals...
[08:27:54.322] List of future strategies:
[08:27:54.322] 1. sequential:
[08:27:54.322]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.322]    - tweaked: FALSE
[08:27:54.322]    - call: NULL
[08:27:54.323] plan(): nbrOfWorkers() = 1
[08:27:54.323] - globals found: [1] ‘{’
[08:27:54.324] Searching for globals ... DONE
[08:27:54.324] Resolving globals: FALSE
[08:27:54.324] 
[08:27:54.324] 
[08:27:54.325] getGlobalsAndPackages() ... DONE
[08:27:54.325] run() for ‘Future’ ...
[08:27:54.325] plan(): Setting new future strategy stack:
[08:27:54.325] - state: ‘created’
[08:27:54.325] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.325] List of future strategies:
[08:27:54.325] 1. multicore:
[08:27:54.325]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.325]    - tweaked: FALSE
[08:27:54.325]    - call: plan(strategy)
[08:27:54.328] plan(): nbrOfWorkers() = 2
[08:27:54.329] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.329] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.329]   - Field: ‘label’
[08:27:54.329]   - Field: ‘local’
[08:27:54.329]   - Field: ‘owner’
[08:27:54.329]   - Field: ‘envir’
[08:27:54.329]   - Field: ‘workers’
[08:27:54.330]   - Field: ‘packages’
[08:27:54.330]   - Field: ‘gc’
[08:27:54.330]   - Field: ‘job’
[08:27:54.330]   - Field: ‘conditions’
[08:27:54.330]   - Field: ‘expr’
[08:27:54.330]   - Field: ‘uuid’
[08:27:54.330]   - Field: ‘seed’
[08:27:54.330]   - Field: ‘version’
[08:27:54.331]   - Field: ‘result’
[08:27:54.331]   - Field: ‘asynchronous’
[08:27:54.331]   - Field: ‘calls’
[08:27:54.331]   - Field: ‘globals’
[08:27:54.331]   - Field: ‘stdout’
[08:27:54.331]   - Field: ‘earlySignal’
[08:27:54.331]   - Field: ‘lazy’
[08:27:54.331]   - Field: ‘state’
[08:27:54.332] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.332] - Launch lazy future ...
[08:27:54.332] Packages needed by the future expression (n = 0): <none>
[08:27:54.332] Packages needed by future strategies (n = 0): <none>
[08:27:54.333] {
[08:27:54.333]     {
[08:27:54.333]         {
[08:27:54.333]             ...future.startTime <- base::Sys.time()
[08:27:54.333]             {
[08:27:54.333]                 {
[08:27:54.333]                   {
[08:27:54.333]                     {
[08:27:54.333]                       base::local({
[08:27:54.333]                         has_future <- base::requireNamespace("future", 
[08:27:54.333]                           quietly = TRUE)
[08:27:54.333]                         if (has_future) {
[08:27:54.333]                           ns <- base::getNamespace("future")
[08:27:54.333]                           version <- ns[[".package"]][["version"]]
[08:27:54.333]                           if (is.null(version)) 
[08:27:54.333]                             version <- utils::packageVersion("future")
[08:27:54.333]                         }
[08:27:54.333]                         else {
[08:27:54.333]                           version <- NULL
[08:27:54.333]                         }
[08:27:54.333]                         if (!has_future || version < "1.8.0") {
[08:27:54.333]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.333]                             "", base::R.version$version.string), 
[08:27:54.333]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.333]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.333]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.333]                               "release", "version")], collapse = " "), 
[08:27:54.333]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.333]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.333]                             info)
[08:27:54.333]                           info <- base::paste(info, collapse = "; ")
[08:27:54.333]                           if (!has_future) {
[08:27:54.333]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.333]                               info)
[08:27:54.333]                           }
[08:27:54.333]                           else {
[08:27:54.333]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.333]                               info, version)
[08:27:54.333]                           }
[08:27:54.333]                           base::stop(msg)
[08:27:54.333]                         }
[08:27:54.333]                       })
[08:27:54.333]                     }
[08:27:54.333]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.333]                     base::options(mc.cores = 1L)
[08:27:54.333]                   }
[08:27:54.333]                   ...future.strategy.old <- future::plan("list")
[08:27:54.333]                   options(future.plan = NULL)
[08:27:54.333]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.333]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.333]                 }
[08:27:54.333]                 ...future.workdir <- getwd()
[08:27:54.333]             }
[08:27:54.333]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.333]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.333]         }
[08:27:54.333]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.333]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.333]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.333]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.333]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.333]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.333]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.333]             base::names(...future.oldOptions))
[08:27:54.333]     }
[08:27:54.333]     if (FALSE) {
[08:27:54.333]     }
[08:27:54.333]     else {
[08:27:54.333]         if (TRUE) {
[08:27:54.333]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.333]                 open = "w")
[08:27:54.333]         }
[08:27:54.333]         else {
[08:27:54.333]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.333]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.333]         }
[08:27:54.333]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.333]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.333]             base::sink(type = "output", split = FALSE)
[08:27:54.333]             base::close(...future.stdout)
[08:27:54.333]         }, add = TRUE)
[08:27:54.333]     }
[08:27:54.333]     ...future.frame <- base::sys.nframe()
[08:27:54.333]     ...future.conditions <- base::list()
[08:27:54.333]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.333]     if (FALSE) {
[08:27:54.333]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.333]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.333]     }
[08:27:54.333]     ...future.result <- base::tryCatch({
[08:27:54.333]         base::withCallingHandlers({
[08:27:54.333]             ...future.value <- base::withVisible(base::local({
[08:27:54.333]                 withCallingHandlers({
[08:27:54.333]                   {
[08:27:54.333]                     4
[08:27:54.333]                   }
[08:27:54.333]                 }, immediateCondition = function(cond) {
[08:27:54.333]                   save_rds <- function (object, pathname, ...) 
[08:27:54.333]                   {
[08:27:54.333]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.333]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.333]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.333]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.333]                         fi_tmp[["mtime"]])
[08:27:54.333]                     }
[08:27:54.333]                     tryCatch({
[08:27:54.333]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.333]                     }, error = function(ex) {
[08:27:54.333]                       msg <- conditionMessage(ex)
[08:27:54.333]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.333]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.333]                         fi_tmp[["mtime"]], msg)
[08:27:54.333]                       ex$message <- msg
[08:27:54.333]                       stop(ex)
[08:27:54.333]                     })
[08:27:54.333]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.333]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.333]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.333]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.333]                       fi <- file.info(pathname)
[08:27:54.333]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.333]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.333]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.333]                         fi[["size"]], fi[["mtime"]])
[08:27:54.333]                       stop(msg)
[08:27:54.333]                     }
[08:27:54.333]                     invisible(pathname)
[08:27:54.333]                   }
[08:27:54.333]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.333]                     rootPath = tempdir()) 
[08:27:54.333]                   {
[08:27:54.333]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.333]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.333]                       tmpdir = path, fileext = ".rds")
[08:27:54.333]                     save_rds(obj, file)
[08:27:54.333]                   }
[08:27:54.333]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.333]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.333]                   {
[08:27:54.333]                     inherits <- base::inherits
[08:27:54.333]                     invokeRestart <- base::invokeRestart
[08:27:54.333]                     is.null <- base::is.null
[08:27:54.333]                     muffled <- FALSE
[08:27:54.333]                     if (inherits(cond, "message")) {
[08:27:54.333]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.333]                       if (muffled) 
[08:27:54.333]                         invokeRestart("muffleMessage")
[08:27:54.333]                     }
[08:27:54.333]                     else if (inherits(cond, "warning")) {
[08:27:54.333]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.333]                       if (muffled) 
[08:27:54.333]                         invokeRestart("muffleWarning")
[08:27:54.333]                     }
[08:27:54.333]                     else if (inherits(cond, "condition")) {
[08:27:54.333]                       if (!is.null(pattern)) {
[08:27:54.333]                         computeRestarts <- base::computeRestarts
[08:27:54.333]                         grepl <- base::grepl
[08:27:54.333]                         restarts <- computeRestarts(cond)
[08:27:54.333]                         for (restart in restarts) {
[08:27:54.333]                           name <- restart$name
[08:27:54.333]                           if (is.null(name)) 
[08:27:54.333]                             next
[08:27:54.333]                           if (!grepl(pattern, name)) 
[08:27:54.333]                             next
[08:27:54.333]                           invokeRestart(restart)
[08:27:54.333]                           muffled <- TRUE
[08:27:54.333]                           break
[08:27:54.333]                         }
[08:27:54.333]                       }
[08:27:54.333]                     }
[08:27:54.333]                     invisible(muffled)
[08:27:54.333]                   }
[08:27:54.333]                   muffleCondition(cond)
[08:27:54.333]                 })
[08:27:54.333]             }))
[08:27:54.333]             future::FutureResult(value = ...future.value$value, 
[08:27:54.333]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.333]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.333]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.333]                     ...future.globalenv.names))
[08:27:54.333]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.333]         }, condition = base::local({
[08:27:54.333]             c <- base::c
[08:27:54.333]             inherits <- base::inherits
[08:27:54.333]             invokeRestart <- base::invokeRestart
[08:27:54.333]             length <- base::length
[08:27:54.333]             list <- base::list
[08:27:54.333]             seq.int <- base::seq.int
[08:27:54.333]             signalCondition <- base::signalCondition
[08:27:54.333]             sys.calls <- base::sys.calls
[08:27:54.333]             `[[` <- base::`[[`
[08:27:54.333]             `+` <- base::`+`
[08:27:54.333]             `<<-` <- base::`<<-`
[08:27:54.333]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.333]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.333]                   3L)]
[08:27:54.333]             }
[08:27:54.333]             function(cond) {
[08:27:54.333]                 is_error <- inherits(cond, "error")
[08:27:54.333]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.333]                   NULL)
[08:27:54.333]                 if (is_error) {
[08:27:54.333]                   sessionInformation <- function() {
[08:27:54.333]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.333]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.333]                       search = base::search(), system = base::Sys.info())
[08:27:54.333]                   }
[08:27:54.333]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.333]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.333]                     cond$call), session = sessionInformation(), 
[08:27:54.333]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.333]                   signalCondition(cond)
[08:27:54.333]                 }
[08:27:54.333]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.333]                 "immediateCondition"))) {
[08:27:54.333]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.333]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.333]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.333]                   if (TRUE && !signal) {
[08:27:54.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.333]                     {
[08:27:54.333]                       inherits <- base::inherits
[08:27:54.333]                       invokeRestart <- base::invokeRestart
[08:27:54.333]                       is.null <- base::is.null
[08:27:54.333]                       muffled <- FALSE
[08:27:54.333]                       if (inherits(cond, "message")) {
[08:27:54.333]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.333]                         if (muffled) 
[08:27:54.333]                           invokeRestart("muffleMessage")
[08:27:54.333]                       }
[08:27:54.333]                       else if (inherits(cond, "warning")) {
[08:27:54.333]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.333]                         if (muffled) 
[08:27:54.333]                           invokeRestart("muffleWarning")
[08:27:54.333]                       }
[08:27:54.333]                       else if (inherits(cond, "condition")) {
[08:27:54.333]                         if (!is.null(pattern)) {
[08:27:54.333]                           computeRestarts <- base::computeRestarts
[08:27:54.333]                           grepl <- base::grepl
[08:27:54.333]                           restarts <- computeRestarts(cond)
[08:27:54.333]                           for (restart in restarts) {
[08:27:54.333]                             name <- restart$name
[08:27:54.333]                             if (is.null(name)) 
[08:27:54.333]                               next
[08:27:54.333]                             if (!grepl(pattern, name)) 
[08:27:54.333]                               next
[08:27:54.333]                             invokeRestart(restart)
[08:27:54.333]                             muffled <- TRUE
[08:27:54.333]                             break
[08:27:54.333]                           }
[08:27:54.333]                         }
[08:27:54.333]                       }
[08:27:54.333]                       invisible(muffled)
[08:27:54.333]                     }
[08:27:54.333]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.333]                   }
[08:27:54.333]                 }
[08:27:54.333]                 else {
[08:27:54.333]                   if (TRUE) {
[08:27:54.333]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.333]                     {
[08:27:54.333]                       inherits <- base::inherits
[08:27:54.333]                       invokeRestart <- base::invokeRestart
[08:27:54.333]                       is.null <- base::is.null
[08:27:54.333]                       muffled <- FALSE
[08:27:54.333]                       if (inherits(cond, "message")) {
[08:27:54.333]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.333]                         if (muffled) 
[08:27:54.333]                           invokeRestart("muffleMessage")
[08:27:54.333]                       }
[08:27:54.333]                       else if (inherits(cond, "warning")) {
[08:27:54.333]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.333]                         if (muffled) 
[08:27:54.333]                           invokeRestart("muffleWarning")
[08:27:54.333]                       }
[08:27:54.333]                       else if (inherits(cond, "condition")) {
[08:27:54.333]                         if (!is.null(pattern)) {
[08:27:54.333]                           computeRestarts <- base::computeRestarts
[08:27:54.333]                           grepl <- base::grepl
[08:27:54.333]                           restarts <- computeRestarts(cond)
[08:27:54.333]                           for (restart in restarts) {
[08:27:54.333]                             name <- restart$name
[08:27:54.333]                             if (is.null(name)) 
[08:27:54.333]                               next
[08:27:54.333]                             if (!grepl(pattern, name)) 
[08:27:54.333]                               next
[08:27:54.333]                             invokeRestart(restart)
[08:27:54.333]                             muffled <- TRUE
[08:27:54.333]                             break
[08:27:54.333]                           }
[08:27:54.333]                         }
[08:27:54.333]                       }
[08:27:54.333]                       invisible(muffled)
[08:27:54.333]                     }
[08:27:54.333]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.333]                   }
[08:27:54.333]                 }
[08:27:54.333]             }
[08:27:54.333]         }))
[08:27:54.333]     }, error = function(ex) {
[08:27:54.333]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.333]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.333]                 ...future.rng), started = ...future.startTime, 
[08:27:54.333]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.333]             version = "1.8"), class = "FutureResult")
[08:27:54.333]     }, finally = {
[08:27:54.333]         if (!identical(...future.workdir, getwd())) 
[08:27:54.333]             setwd(...future.workdir)
[08:27:54.333]         {
[08:27:54.333]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.333]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.333]             }
[08:27:54.333]             base::options(...future.oldOptions)
[08:27:54.333]             if (.Platform$OS.type == "windows") {
[08:27:54.333]                 old_names <- names(...future.oldEnvVars)
[08:27:54.333]                 envs <- base::Sys.getenv()
[08:27:54.333]                 names <- names(envs)
[08:27:54.333]                 common <- intersect(names, old_names)
[08:27:54.333]                 added <- setdiff(names, old_names)
[08:27:54.333]                 removed <- setdiff(old_names, names)
[08:27:54.333]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.333]                   envs[common]]
[08:27:54.333]                 NAMES <- toupper(changed)
[08:27:54.333]                 args <- list()
[08:27:54.333]                 for (kk in seq_along(NAMES)) {
[08:27:54.333]                   name <- changed[[kk]]
[08:27:54.333]                   NAME <- NAMES[[kk]]
[08:27:54.333]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.333]                     next
[08:27:54.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.333]                 }
[08:27:54.333]                 NAMES <- toupper(added)
[08:27:54.333]                 for (kk in seq_along(NAMES)) {
[08:27:54.333]                   name <- added[[kk]]
[08:27:54.333]                   NAME <- NAMES[[kk]]
[08:27:54.333]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.333]                     next
[08:27:54.333]                   args[[name]] <- ""
[08:27:54.333]                 }
[08:27:54.333]                 NAMES <- toupper(removed)
[08:27:54.333]                 for (kk in seq_along(NAMES)) {
[08:27:54.333]                   name <- removed[[kk]]
[08:27:54.333]                   NAME <- NAMES[[kk]]
[08:27:54.333]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.333]                     next
[08:27:54.333]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.333]                 }
[08:27:54.333]                 if (length(args) > 0) 
[08:27:54.333]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.333]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.333]             }
[08:27:54.333]             else {
[08:27:54.333]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.333]             }
[08:27:54.333]             {
[08:27:54.333]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.333]                   0L) {
[08:27:54.333]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.333]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.333]                   base::options(opts)
[08:27:54.333]                 }
[08:27:54.333]                 {
[08:27:54.333]                   {
[08:27:54.333]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.333]                     NULL
[08:27:54.333]                   }
[08:27:54.333]                   options(future.plan = NULL)
[08:27:54.333]                   if (is.na(NA_character_)) 
[08:27:54.333]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.333]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.333]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.333]                     .init = FALSE)
[08:27:54.333]                 }
[08:27:54.333]             }
[08:27:54.333]         }
[08:27:54.333]     })
[08:27:54.333]     if (TRUE) {
[08:27:54.333]         base::sink(type = "output", split = FALSE)
[08:27:54.333]         if (TRUE) {
[08:27:54.333]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.333]         }
[08:27:54.333]         else {
[08:27:54.333]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.333]         }
[08:27:54.333]         base::close(...future.stdout)
[08:27:54.333]         ...future.stdout <- NULL
[08:27:54.333]     }
[08:27:54.333]     ...future.result$conditions <- ...future.conditions
[08:27:54.333]     ...future.result$finished <- base::Sys.time()
[08:27:54.333]     ...future.result
[08:27:54.333] }
[08:27:54.336] requestCore(): workers = 2
[08:27:54.337] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:54.348] result() for MulticoreFuture ...
[08:27:54.349] result() for MulticoreFuture ...
[08:27:54.349] result() for MulticoreFuture ... done
[08:27:54.349] result() for MulticoreFuture ... done
[08:27:54.349] result() for MulticoreFuture ...
[08:27:54.349] result() for MulticoreFuture ... done
[08:27:54.352] MulticoreFuture started
[08:27:54.353] - Launch lazy future ... done
[08:27:54.353] run() for ‘MulticoreFuture’ ... done
[08:27:54.354] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55d862572768> 
[08:27:54.354] List of future strategies:
[08:27:54.354] 1. sequential:
[08:27:54.354]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.354]    - tweaked: FALSE
[08:27:54.354]    - call: NULL
[08:27:54.355] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55d8630c1f88> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=[08:27:54.358] plan(): Setting new future strategy stack:
List of 3
  ..$ :[08:27:54.359] List of future strategies:
[08:27:54.359] 1. multicore:
[08:27:54.359]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.359]    - tweaked: FALSE
[08:27:54.359]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[08:27:54.364] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:54.379] resolve() on list environment ...
[08:27:54.379]  recursive: 0
[08:27:54.381]  length: 6
[08:27:54.381]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:54.381] signalConditionsASAP(numeric, pos=1) ...
[08:27:54.381] - nx: 6
[08:27:54.381] - relay: TRUE
[08:27:54.381] - stdout: TRUE
[08:27:54.381] - signal: TRUE
[08:27:54.381] - resignal: FALSE
[08:27:54.382] - force: TRUE
[08:27:54.382] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.382] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.382]  - until=2
[08:27:54.382]  - relaying element #2
[08:27:54.382] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.382] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.382] signalConditionsASAP(NULL, pos=1) ... done
[08:27:54.383]  length: 5 (resolved future 1)
[08:27:54.383] Future #2
[08:27:54.383] result() for MulticoreFuture ...
[08:27:54.383] result() for MulticoreFuture ... done
[08:27:54.383] result() for MulticoreFuture ...
[08:27:54.383] result() for MulticoreFuture ... done
[08:27:54.383] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:54.384] - nx: 6
[08:27:54.384] - relay: TRUE
[08:27:54.384] - stdout: TRUE
[08:27:54.384] - signal: TRUE
[08:27:54.384] - resignal: FALSE
[08:27:54.384] - force: TRUE
[08:27:54.384] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.384] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.384]  - until=2
[08:27:54.384]  - relaying element #2
[08:27:54.385] result() for MulticoreFuture ...
[08:27:54.385] result() for MulticoreFuture ... done
[08:27:54.385] result() for MulticoreFuture ...
[08:27:54.385] result() for MulticoreFuture ... done
[08:27:54.385] result() for MulticoreFuture ...
[08:27:54.385] result() for MulticoreFuture ... done
[08:27:54.385] result() for MulticoreFuture ...
[08:27:54.385] result() for MulticoreFuture ... done
[08:27:54.386] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.386] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.386] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:54.386]  length: 4 (resolved future 2)
[08:27:54.386] Future #3
[08:27:54.387] result() for MulticoreFuture ...
[08:27:54.387] result() for MulticoreFuture ...
[08:27:54.387] result() for MulticoreFuture ... done
[08:27:54.388] result() for MulticoreFuture ... done
[08:27:54.388] result() for MulticoreFuture ...
[08:27:54.388] result() for MulticoreFuture ... done
[08:27:54.388] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:54.388] - nx: 6
[08:27:54.388] - relay: TRUE
[08:27:54.388] - stdout: TRUE
[08:27:54.388] - signal: TRUE
[08:27:54.388] - resignal: FALSE
[08:27:54.389] - force: TRUE
[08:27:54.389] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.389] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.389]  - until=3
[08:27:54.389]  - relaying element #3
[08:27:54.389] result() for MulticoreFuture ...
[08:27:54.389] result() for MulticoreFuture ... done
[08:27:54.389] result() for MulticoreFuture ...
[08:27:54.390] result() for MulticoreFuture ... done
[08:27:54.390] result() for MulticoreFuture ...
[08:27:54.390] result() for MulticoreFuture ... done
[08:27:54.390] result() for MulticoreFuture ...
[08:27:54.390] result() for MulticoreFuture ... done
[08:27:54.390] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.390] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.390] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:54.391]  length: 3 (resolved future 3)
[08:27:54.391] Future #4
[08:27:54.391] result() for MulticoreFuture ...
[08:27:54.392] result() for MulticoreFuture ...
[08:27:54.392] result() for MulticoreFuture ... done
[08:27:54.392] result() for MulticoreFuture ... done
[08:27:54.392] result() for MulticoreFuture ...
[08:27:54.393] result() for MulticoreFuture ... done
[08:27:54.393] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:54.393] - nx: 6
[08:27:54.393] - relay: TRUE
[08:27:54.393] - stdout: TRUE
[08:27:54.393] - signal: TRUE
[08:27:54.394] - resignal: FALSE
[08:27:54.394] - force: TRUE
[08:27:54.394] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.394] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.394]  - until=4
[08:27:54.394]  - relaying element #4
[08:27:54.394] result() for MulticoreFuture ...
[08:27:54.395] result() for MulticoreFuture ... done
[08:27:54.395] result() for MulticoreFuture ...
[08:27:54.395] result() for MulticoreFuture ... done
[08:27:54.395] result() for MulticoreFuture ...
[08:27:54.395] result() for MulticoreFuture ... done
[08:27:54.395] result() for MulticoreFuture ...
[08:27:54.396] result() for MulticoreFuture ... done
[08:27:54.396] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.396] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.396] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:54.396]  length: 2 (resolved future 4)
[08:27:54.396] signalConditionsASAP(NULL, pos=5) ...
[08:27:54.396] - nx: 6
[08:27:54.397] - relay: TRUE
[08:27:54.397] - stdout: TRUE
[08:27:54.397] - signal: TRUE
[08:27:54.397] - resignal: FALSE
[08:27:54.397] - force: TRUE
[08:27:54.397] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.397] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.397]  - until=6
[08:27:54.398]  - relaying element #6
[08:27:54.398] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.398] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.398] signalConditionsASAP(NULL, pos=5) ... done
[08:27:54.398]  length: 1 (resolved future 5)
[08:27:54.398] signalConditionsASAP(numeric, pos=6) ...
[08:27:54.398] - nx: 6
[08:27:54.398] - relay: TRUE
[08:27:54.398] - stdout: TRUE
[08:27:54.399] - signal: TRUE
[08:27:54.399] - resignal: FALSE
[08:27:54.399] - force: TRUE
[08:27:54.399] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.399] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.399]  - until=6
[08:27:54.399] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.399] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.399] signalConditionsASAP(numeric, pos=6) ... done
[08:27:54.399]  length: 0 (resolved future 6)
[08:27:54.400] Relaying remaining futures
[08:27:54.400] signalConditionsASAP(NULL, pos=0) ...
[08:27:54.400] - nx: 6
[08:27:54.400] - relay: TRUE
[08:27:54.400] - stdout: TRUE
[08:27:54.400] - signal: TRUE
[08:27:54.400] - resignal: FALSE
[08:27:54.400] - force: TRUE
[08:27:54.400] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.400] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:54.401] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.401] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.401] signalConditionsASAP(NULL, pos=0) ... done
[08:27:54.401] resolve() on list environment ... DONE
[08:27:54.401] result() for MulticoreFuture ...
[08:27:54.401] result() for MulticoreFuture ... done
[08:27:54.401] result() for MulticoreFuture ...
[08:27:54.401] result() for MulticoreFuture ... done
[08:27:54.401] result() for MulticoreFuture ...
[08:27:54.402] result() for MulticoreFuture ... done
[08:27:54.402] result() for MulticoreFuture ...
[08:27:54.402] result() for MulticoreFuture ... done
[08:27:54.402] result() for MulticoreFuture ...
[08:27:54.402] result() for MulticoreFuture ... done
[08:27:54.402] result() for MulticoreFuture ...
[08:27:54.402] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d8615ffa70> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[08:27:54.405] getGlobalsAndPackages() ...
[08:27:54.405] Searching for globals...
[08:27:54.406] 
[08:27:54.406] Searching for globals ... DONE
[08:27:54.406] - globals: [0] <none>
[08:27:54.406] getGlobalsAndPackages() ... DONE
[08:27:54.406] run() for ‘Future’ ...
[08:27:54.406] - state: ‘created’
[08:27:54.407] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.409] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.409]   - Field: ‘label’
[08:27:54.409]   - Field: ‘local’
[08:27:54.409]   - Field: ‘owner’
[08:27:54.409]   - Field: ‘envir’
[08:27:54.409]   - Field: ‘workers’
[08:27:54.410]   - Field: ‘packages’
[08:27:54.410]   - Field: ‘gc’
[08:27:54.410]   - Field: ‘job’
[08:27:54.410]   - Field: ‘conditions’
[08:27:54.410]   - Field: ‘expr’
[08:27:54.410]   - Field: ‘uuid’
[08:27:54.410]   - Field: ‘seed’
[08:27:54.410]   - Field: ‘version’
[08:27:54.410]   - Field: ‘result’
[08:27:54.411]   - Field: ‘asynchronous’
[08:27:54.411]   - Field: ‘calls’
[08:27:54.411]   - Field: ‘globals’
[08:27:54.411]   - Field: ‘stdout’
[08:27:54.411]   - Field: ‘earlySignal’
[08:27:54.411]   - Field: ‘lazy’
[08:27:54.411]   - Field: ‘state’
[08:27:54.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.411] - Launch lazy future ...
[08:27:54.412] Packages needed by the future expression (n = 0): <none>
[08:27:54.412] Packages needed by future strategies (n = 0): <none>
[08:27:54.412] {
[08:27:54.412]     {
[08:27:54.412]         {
[08:27:54.412]             ...future.startTime <- base::Sys.time()
[08:27:54.412]             {
[08:27:54.412]                 {
[08:27:54.412]                   {
[08:27:54.412]                     {
[08:27:54.412]                       base::local({
[08:27:54.412]                         has_future <- base::requireNamespace("future", 
[08:27:54.412]                           quietly = TRUE)
[08:27:54.412]                         if (has_future) {
[08:27:54.412]                           ns <- base::getNamespace("future")
[08:27:54.412]                           version <- ns[[".package"]][["version"]]
[08:27:54.412]                           if (is.null(version)) 
[08:27:54.412]                             version <- utils::packageVersion("future")
[08:27:54.412]                         }
[08:27:54.412]                         else {
[08:27:54.412]                           version <- NULL
[08:27:54.412]                         }
[08:27:54.412]                         if (!has_future || version < "1.8.0") {
[08:27:54.412]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.412]                             "", base::R.version$version.string), 
[08:27:54.412]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.412]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.412]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.412]                               "release", "version")], collapse = " "), 
[08:27:54.412]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.412]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.412]                             info)
[08:27:54.412]                           info <- base::paste(info, collapse = "; ")
[08:27:54.412]                           if (!has_future) {
[08:27:54.412]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.412]                               info)
[08:27:54.412]                           }
[08:27:54.412]                           else {
[08:27:54.412]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.412]                               info, version)
[08:27:54.412]                           }
[08:27:54.412]                           base::stop(msg)
[08:27:54.412]                         }
[08:27:54.412]                       })
[08:27:54.412]                     }
[08:27:54.412]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.412]                     base::options(mc.cores = 1L)
[08:27:54.412]                   }
[08:27:54.412]                   ...future.strategy.old <- future::plan("list")
[08:27:54.412]                   options(future.plan = NULL)
[08:27:54.412]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.412]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.412]                 }
[08:27:54.412]                 ...future.workdir <- getwd()
[08:27:54.412]             }
[08:27:54.412]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.412]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.412]         }
[08:27:54.412]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.412]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.412]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.412]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.412]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.412]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.412]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.412]             base::names(...future.oldOptions))
[08:27:54.412]     }
[08:27:54.412]     if (FALSE) {
[08:27:54.412]     }
[08:27:54.412]     else {
[08:27:54.412]         if (TRUE) {
[08:27:54.412]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.412]                 open = "w")
[08:27:54.412]         }
[08:27:54.412]         else {
[08:27:54.412]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.412]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.412]         }
[08:27:54.412]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.412]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.412]             base::sink(type = "output", split = FALSE)
[08:27:54.412]             base::close(...future.stdout)
[08:27:54.412]         }, add = TRUE)
[08:27:54.412]     }
[08:27:54.412]     ...future.frame <- base::sys.nframe()
[08:27:54.412]     ...future.conditions <- base::list()
[08:27:54.412]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.412]     if (FALSE) {
[08:27:54.412]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.412]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.412]     }
[08:27:54.412]     ...future.result <- base::tryCatch({
[08:27:54.412]         base::withCallingHandlers({
[08:27:54.412]             ...future.value <- base::withVisible(base::local({
[08:27:54.412]                 withCallingHandlers({
[08:27:54.412]                   2
[08:27:54.412]                 }, immediateCondition = function(cond) {
[08:27:54.412]                   save_rds <- function (object, pathname, ...) 
[08:27:54.412]                   {
[08:27:54.412]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.412]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.412]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.412]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.412]                         fi_tmp[["mtime"]])
[08:27:54.412]                     }
[08:27:54.412]                     tryCatch({
[08:27:54.412]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.412]                     }, error = function(ex) {
[08:27:54.412]                       msg <- conditionMessage(ex)
[08:27:54.412]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.412]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.412]                         fi_tmp[["mtime"]], msg)
[08:27:54.412]                       ex$message <- msg
[08:27:54.412]                       stop(ex)
[08:27:54.412]                     })
[08:27:54.412]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.412]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.412]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.412]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.412]                       fi <- file.info(pathname)
[08:27:54.412]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.412]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.412]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.412]                         fi[["size"]], fi[["mtime"]])
[08:27:54.412]                       stop(msg)
[08:27:54.412]                     }
[08:27:54.412]                     invisible(pathname)
[08:27:54.412]                   }
[08:27:54.412]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.412]                     rootPath = tempdir()) 
[08:27:54.412]                   {
[08:27:54.412]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.412]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.412]                       tmpdir = path, fileext = ".rds")
[08:27:54.412]                     save_rds(obj, file)
[08:27:54.412]                   }
[08:27:54.412]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.412]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.412]                   {
[08:27:54.412]                     inherits <- base::inherits
[08:27:54.412]                     invokeRestart <- base::invokeRestart
[08:27:54.412]                     is.null <- base::is.null
[08:27:54.412]                     muffled <- FALSE
[08:27:54.412]                     if (inherits(cond, "message")) {
[08:27:54.412]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.412]                       if (muffled) 
[08:27:54.412]                         invokeRestart("muffleMessage")
[08:27:54.412]                     }
[08:27:54.412]                     else if (inherits(cond, "warning")) {
[08:27:54.412]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.412]                       if (muffled) 
[08:27:54.412]                         invokeRestart("muffleWarning")
[08:27:54.412]                     }
[08:27:54.412]                     else if (inherits(cond, "condition")) {
[08:27:54.412]                       if (!is.null(pattern)) {
[08:27:54.412]                         computeRestarts <- base::computeRestarts
[08:27:54.412]                         grepl <- base::grepl
[08:27:54.412]                         restarts <- computeRestarts(cond)
[08:27:54.412]                         for (restart in restarts) {
[08:27:54.412]                           name <- restart$name
[08:27:54.412]                           if (is.null(name)) 
[08:27:54.412]                             next
[08:27:54.412]                           if (!grepl(pattern, name)) 
[08:27:54.412]                             next
[08:27:54.412]                           invokeRestart(restart)
[08:27:54.412]                           muffled <- TRUE
[08:27:54.412]                           break
[08:27:54.412]                         }
[08:27:54.412]                       }
[08:27:54.412]                     }
[08:27:54.412]                     invisible(muffled)
[08:27:54.412]                   }
[08:27:54.412]                   muffleCondition(cond)
[08:27:54.412]                 })
[08:27:54.412]             }))
[08:27:54.412]             future::FutureResult(value = ...future.value$value, 
[08:27:54.412]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.412]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.412]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.412]                     ...future.globalenv.names))
[08:27:54.412]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.412]         }, condition = base::local({
[08:27:54.412]             c <- base::c
[08:27:54.412]             inherits <- base::inherits
[08:27:54.412]             invokeRestart <- base::invokeRestart
[08:27:54.412]             length <- base::length
[08:27:54.412]             list <- base::list
[08:27:54.412]             seq.int <- base::seq.int
[08:27:54.412]             signalCondition <- base::signalCondition
[08:27:54.412]             sys.calls <- base::sys.calls
[08:27:54.412]             `[[` <- base::`[[`
[08:27:54.412]             `+` <- base::`+`
[08:27:54.412]             `<<-` <- base::`<<-`
[08:27:54.412]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.412]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.412]                   3L)]
[08:27:54.412]             }
[08:27:54.412]             function(cond) {
[08:27:54.412]                 is_error <- inherits(cond, "error")
[08:27:54.412]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.412]                   NULL)
[08:27:54.412]                 if (is_error) {
[08:27:54.412]                   sessionInformation <- function() {
[08:27:54.412]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.412]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.412]                       search = base::search(), system = base::Sys.info())
[08:27:54.412]                   }
[08:27:54.412]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.412]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.412]                     cond$call), session = sessionInformation(), 
[08:27:54.412]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.412]                   signalCondition(cond)
[08:27:54.412]                 }
[08:27:54.412]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.412]                 "immediateCondition"))) {
[08:27:54.412]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.412]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.412]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.412]                   if (TRUE && !signal) {
[08:27:54.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.412]                     {
[08:27:54.412]                       inherits <- base::inherits
[08:27:54.412]                       invokeRestart <- base::invokeRestart
[08:27:54.412]                       is.null <- base::is.null
[08:27:54.412]                       muffled <- FALSE
[08:27:54.412]                       if (inherits(cond, "message")) {
[08:27:54.412]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.412]                         if (muffled) 
[08:27:54.412]                           invokeRestart("muffleMessage")
[08:27:54.412]                       }
[08:27:54.412]                       else if (inherits(cond, "warning")) {
[08:27:54.412]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.412]                         if (muffled) 
[08:27:54.412]                           invokeRestart("muffleWarning")
[08:27:54.412]                       }
[08:27:54.412]                       else if (inherits(cond, "condition")) {
[08:27:54.412]                         if (!is.null(pattern)) {
[08:27:54.412]                           computeRestarts <- base::computeRestarts
[08:27:54.412]                           grepl <- base::grepl
[08:27:54.412]                           restarts <- computeRestarts(cond)
[08:27:54.412]                           for (restart in restarts) {
[08:27:54.412]                             name <- restart$name
[08:27:54.412]                             if (is.null(name)) 
[08:27:54.412]                               next
[08:27:54.412]                             if (!grepl(pattern, name)) 
[08:27:54.412]                               next
[08:27:54.412]                             invokeRestart(restart)
[08:27:54.412]                             muffled <- TRUE
[08:27:54.412]                             break
[08:27:54.412]                           }
[08:27:54.412]                         }
[08:27:54.412]                       }
[08:27:54.412]                       invisible(muffled)
[08:27:54.412]                     }
[08:27:54.412]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.412]                   }
[08:27:54.412]                 }
[08:27:54.412]                 else {
[08:27:54.412]                   if (TRUE) {
[08:27:54.412]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.412]                     {
[08:27:54.412]                       inherits <- base::inherits
[08:27:54.412]                       invokeRestart <- base::invokeRestart
[08:27:54.412]                       is.null <- base::is.null
[08:27:54.412]                       muffled <- FALSE
[08:27:54.412]                       if (inherits(cond, "message")) {
[08:27:54.412]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.412]                         if (muffled) 
[08:27:54.412]                           invokeRestart("muffleMessage")
[08:27:54.412]                       }
[08:27:54.412]                       else if (inherits(cond, "warning")) {
[08:27:54.412]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.412]                         if (muffled) 
[08:27:54.412]                           invokeRestart("muffleWarning")
[08:27:54.412]                       }
[08:27:54.412]                       else if (inherits(cond, "condition")) {
[08:27:54.412]                         if (!is.null(pattern)) {
[08:27:54.412]                           computeRestarts <- base::computeRestarts
[08:27:54.412]                           grepl <- base::grepl
[08:27:54.412]                           restarts <- computeRestarts(cond)
[08:27:54.412]                           for (restart in restarts) {
[08:27:54.412]                             name <- restart$name
[08:27:54.412]                             if (is.null(name)) 
[08:27:54.412]                               next
[08:27:54.412]                             if (!grepl(pattern, name)) 
[08:27:54.412]                               next
[08:27:54.412]                             invokeRestart(restart)
[08:27:54.412]                             muffled <- TRUE
[08:27:54.412]                             break
[08:27:54.412]                           }
[08:27:54.412]                         }
[08:27:54.412]                       }
[08:27:54.412]                       invisible(muffled)
[08:27:54.412]                     }
[08:27:54.412]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.412]                   }
[08:27:54.412]                 }
[08:27:54.412]             }
[08:27:54.412]         }))
[08:27:54.412]     }, error = function(ex) {
[08:27:54.412]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.412]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.412]                 ...future.rng), started = ...future.startTime, 
[08:27:54.412]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.412]             version = "1.8"), class = "FutureResult")
[08:27:54.412]     }, finally = {
[08:27:54.412]         if (!identical(...future.workdir, getwd())) 
[08:27:54.412]             setwd(...future.workdir)
[08:27:54.412]         {
[08:27:54.412]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.412]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.412]             }
[08:27:54.412]             base::options(...future.oldOptions)
[08:27:54.412]             if (.Platform$OS.type == "windows") {
[08:27:54.412]                 old_names <- names(...future.oldEnvVars)
[08:27:54.412]                 envs <- base::Sys.getenv()
[08:27:54.412]                 names <- names(envs)
[08:27:54.412]                 common <- intersect(names, old_names)
[08:27:54.412]                 added <- setdiff(names, old_names)
[08:27:54.412]                 removed <- setdiff(old_names, names)
[08:27:54.412]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.412]                   envs[common]]
[08:27:54.412]                 NAMES <- toupper(changed)
[08:27:54.412]                 args <- list()
[08:27:54.412]                 for (kk in seq_along(NAMES)) {
[08:27:54.412]                   name <- changed[[kk]]
[08:27:54.412]                   NAME <- NAMES[[kk]]
[08:27:54.412]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.412]                     next
[08:27:54.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.412]                 }
[08:27:54.412]                 NAMES <- toupper(added)
[08:27:54.412]                 for (kk in seq_along(NAMES)) {
[08:27:54.412]                   name <- added[[kk]]
[08:27:54.412]                   NAME <- NAMES[[kk]]
[08:27:54.412]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.412]                     next
[08:27:54.412]                   args[[name]] <- ""
[08:27:54.412]                 }
[08:27:54.412]                 NAMES <- toupper(removed)
[08:27:54.412]                 for (kk in seq_along(NAMES)) {
[08:27:54.412]                   name <- removed[[kk]]
[08:27:54.412]                   NAME <- NAMES[[kk]]
[08:27:54.412]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.412]                     next
[08:27:54.412]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.412]                 }
[08:27:54.412]                 if (length(args) > 0) 
[08:27:54.412]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.412]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.412]             }
[08:27:54.412]             else {
[08:27:54.412]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.412]             }
[08:27:54.412]             {
[08:27:54.412]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.412]                   0L) {
[08:27:54.412]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.412]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.412]                   base::options(opts)
[08:27:54.412]                 }
[08:27:54.412]                 {
[08:27:54.412]                   {
[08:27:54.412]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.412]                     NULL
[08:27:54.412]                   }
[08:27:54.412]                   options(future.plan = NULL)
[08:27:54.412]                   if (is.na(NA_character_)) 
[08:27:54.412]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.412]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.412]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.412]                     .init = FALSE)
[08:27:54.412]                 }
[08:27:54.412]             }
[08:27:54.412]         }
[08:27:54.412]     })
[08:27:54.412]     if (TRUE) {
[08:27:54.412]         base::sink(type = "output", split = FALSE)
[08:27:54.412]         if (TRUE) {
[08:27:54.412]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.412]         }
[08:27:54.412]         else {
[08:27:54.412]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.412]         }
[08:27:54.412]         base::close(...future.stdout)
[08:27:54.412]         ...future.stdout <- NULL
[08:27:54.412]     }
[08:27:54.412]     ...future.result$conditions <- ...future.conditions
[08:27:54.412]     ...future.result$finished <- base::Sys.time()
[08:27:54.412]     ...future.result
[08:27:54.412] }
[08:27:54.415] requestCore(): workers = 2
[08:27:54.418] MulticoreFuture started
[08:27:54.418] - Launch lazy future ... done
[08:27:54.418] run() for ‘MulticoreFuture’ ... done
[08:27:54.419] getGlobalsAndPackages() ...
[08:27:54.419] Searching for globals...
[08:27:54.419] plan(): Setting new future strategy stack:
[08:27:54.420] 
[08:27:54.420] Searching for globals ... DONE
[08:27:54.419] List of future strategies:
[08:27:54.419] 1. sequential:
[08:27:54.419]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.419]    - tweaked: FALSE
[08:27:54.419]    - call: NULL
[08:27:54.420] - globals: [0] <none>
[08:27:54.420] getGlobalsAndPackages() ... DONE
[08:27:54.420] plan(): nbrOfWorkers() = 1
[08:27:54.421] run() for ‘Future’ ...
[08:27:54.421] - state: ‘created’
[08:27:54.421] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.422] plan(): Setting new future strategy stack:
[08:27:54.422] List of future strategies:
[08:27:54.422] 1. multicore:
[08:27:54.422]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.422]    - tweaked: FALSE
[08:27:54.422]    - call: plan(strategy)
[08:27:54.425] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.425] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.425] plan(): nbrOfWorkers() = 2
[08:27:54.425]   - Field: ‘label’
[08:27:54.425]   - Field: ‘local’
[08:27:54.425]   - Field: ‘owner’
[08:27:54.425]   - Field: ‘envir’
[08:27:54.425]   - Field: ‘workers’
[08:27:54.426]   - Field: ‘packages’
[08:27:54.426]   - Field: ‘gc’
[08:27:54.426]   - Field: ‘job’
[08:27:54.426]   - Field: ‘conditions’
[08:27:54.426]   - Field: ‘expr’
[08:27:54.426]   - Field: ‘uuid’
[08:27:54.426]   - Field: ‘seed’
[08:27:54.426]   - Field: ‘version’
[08:27:54.427]   - Field: ‘result’
[08:27:54.427]   - Field: ‘asynchronous’
[08:27:54.427]   - Field: ‘calls’
[08:27:54.427]   - Field: ‘globals’
[08:27:54.427]   - Field: ‘stdout’
[08:27:54.427]   - Field: ‘earlySignal’
[08:27:54.427]   - Field: ‘lazy’
[08:27:54.427]   - Field: ‘state’
[08:27:54.428] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.428] - Launch lazy future ...
[08:27:54.428] Packages needed by the future expression (n = 0): <none>
[08:27:54.428] Packages needed by future strategies (n = 0): <none>
[08:27:54.429] {
[08:27:54.429]     {
[08:27:54.429]         {
[08:27:54.429]             ...future.startTime <- base::Sys.time()
[08:27:54.429]             {
[08:27:54.429]                 {
[08:27:54.429]                   {
[08:27:54.429]                     {
[08:27:54.429]                       base::local({
[08:27:54.429]                         has_future <- base::requireNamespace("future", 
[08:27:54.429]                           quietly = TRUE)
[08:27:54.429]                         if (has_future) {
[08:27:54.429]                           ns <- base::getNamespace("future")
[08:27:54.429]                           version <- ns[[".package"]][["version"]]
[08:27:54.429]                           if (is.null(version)) 
[08:27:54.429]                             version <- utils::packageVersion("future")
[08:27:54.429]                         }
[08:27:54.429]                         else {
[08:27:54.429]                           version <- NULL
[08:27:54.429]                         }
[08:27:54.429]                         if (!has_future || version < "1.8.0") {
[08:27:54.429]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.429]                             "", base::R.version$version.string), 
[08:27:54.429]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.429]                               "release", "version")], collapse = " "), 
[08:27:54.429]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.429]                             info)
[08:27:54.429]                           info <- base::paste(info, collapse = "; ")
[08:27:54.429]                           if (!has_future) {
[08:27:54.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.429]                               info)
[08:27:54.429]                           }
[08:27:54.429]                           else {
[08:27:54.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.429]                               info, version)
[08:27:54.429]                           }
[08:27:54.429]                           base::stop(msg)
[08:27:54.429]                         }
[08:27:54.429]                       })
[08:27:54.429]                     }
[08:27:54.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.429]                     base::options(mc.cores = 1L)
[08:27:54.429]                   }
[08:27:54.429]                   ...future.strategy.old <- future::plan("list")
[08:27:54.429]                   options(future.plan = NULL)
[08:27:54.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.429]                 }
[08:27:54.429]                 ...future.workdir <- getwd()
[08:27:54.429]             }
[08:27:54.429]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.429]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.429]         }
[08:27:54.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.429]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.429]             base::names(...future.oldOptions))
[08:27:54.429]     }
[08:27:54.429]     if (FALSE) {
[08:27:54.429]     }
[08:27:54.429]     else {
[08:27:54.429]         if (TRUE) {
[08:27:54.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.429]                 open = "w")
[08:27:54.429]         }
[08:27:54.429]         else {
[08:27:54.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.429]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.429]         }
[08:27:54.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.429]             base::sink(type = "output", split = FALSE)
[08:27:54.429]             base::close(...future.stdout)
[08:27:54.429]         }, add = TRUE)
[08:27:54.429]     }
[08:27:54.429]     ...future.frame <- base::sys.nframe()
[08:27:54.429]     ...future.conditions <- base::list()
[08:27:54.429]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.429]     if (FALSE) {
[08:27:54.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.429]     }
[08:27:54.429]     ...future.result <- base::tryCatch({
[08:27:54.429]         base::withCallingHandlers({
[08:27:54.429]             ...future.value <- base::withVisible(base::local({
[08:27:54.429]                 withCallingHandlers({
[08:27:54.429]                   NULL
[08:27:54.429]                 }, immediateCondition = function(cond) {
[08:27:54.429]                   save_rds <- function (object, pathname, ...) 
[08:27:54.429]                   {
[08:27:54.429]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.429]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.429]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.429]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.429]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.429]                         fi_tmp[["mtime"]])
[08:27:54.429]                     }
[08:27:54.429]                     tryCatch({
[08:27:54.429]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.429]                     }, error = function(ex) {
[08:27:54.429]                       msg <- conditionMessage(ex)
[08:27:54.429]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.429]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.429]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.429]                         fi_tmp[["mtime"]], msg)
[08:27:54.429]                       ex$message <- msg
[08:27:54.429]                       stop(ex)
[08:27:54.429]                     })
[08:27:54.429]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.429]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.429]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.429]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.429]                       fi <- file.info(pathname)
[08:27:54.429]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.429]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.429]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.429]                         fi[["size"]], fi[["mtime"]])
[08:27:54.429]                       stop(msg)
[08:27:54.429]                     }
[08:27:54.429]                     invisible(pathname)
[08:27:54.429]                   }
[08:27:54.429]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.429]                     rootPath = tempdir()) 
[08:27:54.429]                   {
[08:27:54.429]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.429]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.429]                       tmpdir = path, fileext = ".rds")
[08:27:54.429]                     save_rds(obj, file)
[08:27:54.429]                   }
[08:27:54.429]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.429]                   {
[08:27:54.429]                     inherits <- base::inherits
[08:27:54.429]                     invokeRestart <- base::invokeRestart
[08:27:54.429]                     is.null <- base::is.null
[08:27:54.429]                     muffled <- FALSE
[08:27:54.429]                     if (inherits(cond, "message")) {
[08:27:54.429]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.429]                       if (muffled) 
[08:27:54.429]                         invokeRestart("muffleMessage")
[08:27:54.429]                     }
[08:27:54.429]                     else if (inherits(cond, "warning")) {
[08:27:54.429]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.429]                       if (muffled) 
[08:27:54.429]                         invokeRestart("muffleWarning")
[08:27:54.429]                     }
[08:27:54.429]                     else if (inherits(cond, "condition")) {
[08:27:54.429]                       if (!is.null(pattern)) {
[08:27:54.429]                         computeRestarts <- base::computeRestarts
[08:27:54.429]                         grepl <- base::grepl
[08:27:54.429]                         restarts <- computeRestarts(cond)
[08:27:54.429]                         for (restart in restarts) {
[08:27:54.429]                           name <- restart$name
[08:27:54.429]                           if (is.null(name)) 
[08:27:54.429]                             next
[08:27:54.429]                           if (!grepl(pattern, name)) 
[08:27:54.429]                             next
[08:27:54.429]                           invokeRestart(restart)
[08:27:54.429]                           muffled <- TRUE
[08:27:54.429]                           break
[08:27:54.429]                         }
[08:27:54.429]                       }
[08:27:54.429]                     }
[08:27:54.429]                     invisible(muffled)
[08:27:54.429]                   }
[08:27:54.429]                   muffleCondition(cond)
[08:27:54.429]                 })
[08:27:54.429]             }))
[08:27:54.429]             future::FutureResult(value = ...future.value$value, 
[08:27:54.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.429]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.429]                     ...future.globalenv.names))
[08:27:54.429]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.429]         }, condition = base::local({
[08:27:54.429]             c <- base::c
[08:27:54.429]             inherits <- base::inherits
[08:27:54.429]             invokeRestart <- base::invokeRestart
[08:27:54.429]             length <- base::length
[08:27:54.429]             list <- base::list
[08:27:54.429]             seq.int <- base::seq.int
[08:27:54.429]             signalCondition <- base::signalCondition
[08:27:54.429]             sys.calls <- base::sys.calls
[08:27:54.429]             `[[` <- base::`[[`
[08:27:54.429]             `+` <- base::`+`
[08:27:54.429]             `<<-` <- base::`<<-`
[08:27:54.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.429]                   3L)]
[08:27:54.429]             }
[08:27:54.429]             function(cond) {
[08:27:54.429]                 is_error <- inherits(cond, "error")
[08:27:54.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.429]                   NULL)
[08:27:54.429]                 if (is_error) {
[08:27:54.429]                   sessionInformation <- function() {
[08:27:54.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.429]                       search = base::search(), system = base::Sys.info())
[08:27:54.429]                   }
[08:27:54.429]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.429]                     cond$call), session = sessionInformation(), 
[08:27:54.429]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.429]                   signalCondition(cond)
[08:27:54.429]                 }
[08:27:54.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.429]                 "immediateCondition"))) {
[08:27:54.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.429]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.429]                   if (TRUE && !signal) {
[08:27:54.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.429]                     {
[08:27:54.429]                       inherits <- base::inherits
[08:27:54.429]                       invokeRestart <- base::invokeRestart
[08:27:54.429]                       is.null <- base::is.null
[08:27:54.429]                       muffled <- FALSE
[08:27:54.429]                       if (inherits(cond, "message")) {
[08:27:54.429]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.429]                         if (muffled) 
[08:27:54.429]                           invokeRestart("muffleMessage")
[08:27:54.429]                       }
[08:27:54.429]                       else if (inherits(cond, "warning")) {
[08:27:54.429]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.429]                         if (muffled) 
[08:27:54.429]                           invokeRestart("muffleWarning")
[08:27:54.429]                       }
[08:27:54.429]                       else if (inherits(cond, "condition")) {
[08:27:54.429]                         if (!is.null(pattern)) {
[08:27:54.429]                           computeRestarts <- base::computeRestarts
[08:27:54.429]                           grepl <- base::grepl
[08:27:54.429]                           restarts <- computeRestarts(cond)
[08:27:54.429]                           for (restart in restarts) {
[08:27:54.429]                             name <- restart$name
[08:27:54.429]                             if (is.null(name)) 
[08:27:54.429]                               next
[08:27:54.429]                             if (!grepl(pattern, name)) 
[08:27:54.429]                               next
[08:27:54.429]                             invokeRestart(restart)
[08:27:54.429]                             muffled <- TRUE
[08:27:54.429]                             break
[08:27:54.429]                           }
[08:27:54.429]                         }
[08:27:54.429]                       }
[08:27:54.429]                       invisible(muffled)
[08:27:54.429]                     }
[08:27:54.429]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.429]                   }
[08:27:54.429]                 }
[08:27:54.429]                 else {
[08:27:54.429]                   if (TRUE) {
[08:27:54.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.429]                     {
[08:27:54.429]                       inherits <- base::inherits
[08:27:54.429]                       invokeRestart <- base::invokeRestart
[08:27:54.429]                       is.null <- base::is.null
[08:27:54.429]                       muffled <- FALSE
[08:27:54.429]                       if (inherits(cond, "message")) {
[08:27:54.429]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.429]                         if (muffled) 
[08:27:54.429]                           invokeRestart("muffleMessage")
[08:27:54.429]                       }
[08:27:54.429]                       else if (inherits(cond, "warning")) {
[08:27:54.429]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.429]                         if (muffled) 
[08:27:54.429]                           invokeRestart("muffleWarning")
[08:27:54.429]                       }
[08:27:54.429]                       else if (inherits(cond, "condition")) {
[08:27:54.429]                         if (!is.null(pattern)) {
[08:27:54.429]                           computeRestarts <- base::computeRestarts
[08:27:54.429]                           grepl <- base::grepl
[08:27:54.429]                           restarts <- computeRestarts(cond)
[08:27:54.429]                           for (restart in restarts) {
[08:27:54.429]                             name <- restart$name
[08:27:54.429]                             if (is.null(name)) 
[08:27:54.429]                               next
[08:27:54.429]                             if (!grepl(pattern, name)) 
[08:27:54.429]                               next
[08:27:54.429]                             invokeRestart(restart)
[08:27:54.429]                             muffled <- TRUE
[08:27:54.429]                             break
[08:27:54.429]                           }
[08:27:54.429]                         }
[08:27:54.429]                       }
[08:27:54.429]                       invisible(muffled)
[08:27:54.429]                     }
[08:27:54.429]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.429]                   }
[08:27:54.429]                 }
[08:27:54.429]             }
[08:27:54.429]         }))
[08:27:54.429]     }, error = function(ex) {
[08:27:54.429]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.429]                 ...future.rng), started = ...future.startTime, 
[08:27:54.429]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.429]             version = "1.8"), class = "FutureResult")
[08:27:54.429]     }, finally = {
[08:27:54.429]         if (!identical(...future.workdir, getwd())) 
[08:27:54.429]             setwd(...future.workdir)
[08:27:54.429]         {
[08:27:54.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.429]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.429]             }
[08:27:54.429]             base::options(...future.oldOptions)
[08:27:54.429]             if (.Platform$OS.type == "windows") {
[08:27:54.429]                 old_names <- names(...future.oldEnvVars)
[08:27:54.429]                 envs <- base::Sys.getenv()
[08:27:54.429]                 names <- names(envs)
[08:27:54.429]                 common <- intersect(names, old_names)
[08:27:54.429]                 added <- setdiff(names, old_names)
[08:27:54.429]                 removed <- setdiff(old_names, names)
[08:27:54.429]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.429]                   envs[common]]
[08:27:54.429]                 NAMES <- toupper(changed)
[08:27:54.429]                 args <- list()
[08:27:54.429]                 for (kk in seq_along(NAMES)) {
[08:27:54.429]                   name <- changed[[kk]]
[08:27:54.429]                   NAME <- NAMES[[kk]]
[08:27:54.429]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.429]                     next
[08:27:54.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.429]                 }
[08:27:54.429]                 NAMES <- toupper(added)
[08:27:54.429]                 for (kk in seq_along(NAMES)) {
[08:27:54.429]                   name <- added[[kk]]
[08:27:54.429]                   NAME <- NAMES[[kk]]
[08:27:54.429]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.429]                     next
[08:27:54.429]                   args[[name]] <- ""
[08:27:54.429]                 }
[08:27:54.429]                 NAMES <- toupper(removed)
[08:27:54.429]                 for (kk in seq_along(NAMES)) {
[08:27:54.429]                   name <- removed[[kk]]
[08:27:54.429]                   NAME <- NAMES[[kk]]
[08:27:54.429]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.429]                     next
[08:27:54.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.429]                 }
[08:27:54.429]                 if (length(args) > 0) 
[08:27:54.429]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.429]             }
[08:27:54.429]             else {
[08:27:54.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.429]             }
[08:27:54.429]             {
[08:27:54.429]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.429]                   0L) {
[08:27:54.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.429]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.429]                   base::options(opts)
[08:27:54.429]                 }
[08:27:54.429]                 {
[08:27:54.429]                   {
[08:27:54.429]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.429]                     NULL
[08:27:54.429]                   }
[08:27:54.429]                   options(future.plan = NULL)
[08:27:54.429]                   if (is.na(NA_character_)) 
[08:27:54.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.429]                     .init = FALSE)
[08:27:54.429]                 }
[08:27:54.429]             }
[08:27:54.429]         }
[08:27:54.429]     })
[08:27:54.429]     if (TRUE) {
[08:27:54.429]         base::sink(type = "output", split = FALSE)
[08:27:54.429]         if (TRUE) {
[08:27:54.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.429]         }
[08:27:54.429]         else {
[08:27:54.429]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.429]         }
[08:27:54.429]         base::close(...future.stdout)
[08:27:54.429]         ...future.stdout <- NULL
[08:27:54.429]     }
[08:27:54.429]     ...future.result$conditions <- ...future.conditions
[08:27:54.429]     ...future.result$finished <- base::Sys.time()
[08:27:54.429]     ...future.result
[08:27:54.429] }
[08:27:54.433] requestCore(): workers = 2
[08:27:54.436] MulticoreFuture started
[08:27:54.436] - Launch lazy future ... done
[08:27:54.436] run() for ‘MulticoreFuture’ ... done
[08:27:54.437] plan(): Setting new future strategy stack:
[08:27:54.437] getGlobalsAndPackages() ...
[08:27:54.437] Searching for globals...
[08:27:54.437] List of future strategies:
[08:27:54.437] 1. sequential:
[08:27:54.437]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.437]    - tweaked: FALSE
[08:27:54.437]    - call: NULL
[08:27:54.438] plan(): nbrOfWorkers() = 1
[08:27:54.439] - globals found: [1] ‘{’
[08:27:54.439] Searching for globals ... DONE
[08:27:54.439] Resolving globals: FALSE
[08:27:54.440] 
[08:27:54.440] 
[08:27:54.440] getGlobalsAndPackages() ... DONE
[08:27:54.440] run() for ‘Future’ ...
[08:27:54.440] - state: ‘created’
[08:27:54.440] plan(): Setting new future strategy stack:
[08:27:54.441] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.441] List of future strategies:
[08:27:54.441] 1. multicore:
[08:27:54.441]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.441]    - tweaked: FALSE
[08:27:54.441]    - call: plan(strategy)
[08:27:54.443] plan(): nbrOfWorkers() = 2
[08:27:54.444] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.444] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:27:54.444]   - Field: ‘label’
[08:27:54.444]   - Field: ‘local’
[08:27:54.444]   - Field: ‘owner’
[08:27:54.445]   - Field: ‘envir’
[08:27:54.445]   - Field: ‘workers’
[08:27:54.445]   - Field: ‘packages’
[08:27:54.445]   - Field: ‘gc’
[08:27:54.445]   - Field: ‘job’
[08:27:54.445]   - Field: ‘conditions’
[08:27:54.445]   - Field: ‘expr’
[08:27:54.445]   - Field: ‘uuid’
[08:27:54.446]   - Field: ‘seed’
[08:27:54.446]   - Field: ‘version’
[08:27:54.446]   - Field: ‘result’
[08:27:54.446]   - Field: ‘asynchronous’
[08:27:54.446]   - Field: ‘calls’
[08:27:54.446]   - Field: ‘globals’
[08:27:54.446]   - Field: ‘stdout’
[08:27:54.446]   - Field: ‘earlySignal’
[08:27:54.447]   - Field: ‘lazy’
[08:27:54.447]   - Field: ‘state’
[08:27:54.447] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:27:54.447] - Launch lazy future ...
[08:27:54.447] Packages needed by the future expression (n = 0): <none>
[08:27:54.448] Packages needed by future strategies (n = 0): <none>
[08:27:54.448] {
[08:27:54.448]     {
[08:27:54.448]         {
[08:27:54.448]             ...future.startTime <- base::Sys.time()
[08:27:54.448]             {
[08:27:54.448]                 {
[08:27:54.448]                   {
[08:27:54.448]                     {
[08:27:54.448]                       base::local({
[08:27:54.448]                         has_future <- base::requireNamespace("future", 
[08:27:54.448]                           quietly = TRUE)
[08:27:54.448]                         if (has_future) {
[08:27:54.448]                           ns <- base::getNamespace("future")
[08:27:54.448]                           version <- ns[[".package"]][["version"]]
[08:27:54.448]                           if (is.null(version)) 
[08:27:54.448]                             version <- utils::packageVersion("future")
[08:27:54.448]                         }
[08:27:54.448]                         else {
[08:27:54.448]                           version <- NULL
[08:27:54.448]                         }
[08:27:54.448]                         if (!has_future || version < "1.8.0") {
[08:27:54.448]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.448]                             "", base::R.version$version.string), 
[08:27:54.448]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.448]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.448]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.448]                               "release", "version")], collapse = " "), 
[08:27:54.448]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.448]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.448]                             info)
[08:27:54.448]                           info <- base::paste(info, collapse = "; ")
[08:27:54.448]                           if (!has_future) {
[08:27:54.448]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.448]                               info)
[08:27:54.448]                           }
[08:27:54.448]                           else {
[08:27:54.448]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.448]                               info, version)
[08:27:54.448]                           }
[08:27:54.448]                           base::stop(msg)
[08:27:54.448]                         }
[08:27:54.448]                       })
[08:27:54.448]                     }
[08:27:54.448]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.448]                     base::options(mc.cores = 1L)
[08:27:54.448]                   }
[08:27:54.448]                   ...future.strategy.old <- future::plan("list")
[08:27:54.448]                   options(future.plan = NULL)
[08:27:54.448]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.448]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.448]                 }
[08:27:54.448]                 ...future.workdir <- getwd()
[08:27:54.448]             }
[08:27:54.448]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.448]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.448]         }
[08:27:54.448]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.448]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.448]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.448]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.448]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.448]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.448]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.448]             base::names(...future.oldOptions))
[08:27:54.448]     }
[08:27:54.448]     if (FALSE) {
[08:27:54.448]     }
[08:27:54.448]     else {
[08:27:54.448]         if (TRUE) {
[08:27:54.448]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.448]                 open = "w")
[08:27:54.448]         }
[08:27:54.448]         else {
[08:27:54.448]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.448]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.448]         }
[08:27:54.448]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.448]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.448]             base::sink(type = "output", split = FALSE)
[08:27:54.448]             base::close(...future.stdout)
[08:27:54.448]         }, add = TRUE)
[08:27:54.448]     }
[08:27:54.448]     ...future.frame <- base::sys.nframe()
[08:27:54.448]     ...future.conditions <- base::list()
[08:27:54.448]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.448]     if (FALSE) {
[08:27:54.448]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.448]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.448]     }
[08:27:54.448]     ...future.result <- base::tryCatch({
[08:27:54.448]         base::withCallingHandlers({
[08:27:54.448]             ...future.value <- base::withVisible(base::local({
[08:27:54.448]                 withCallingHandlers({
[08:27:54.448]                   {
[08:27:54.448]                     4
[08:27:54.448]                   }
[08:27:54.448]                 }, immediateCondition = function(cond) {
[08:27:54.448]                   save_rds <- function (object, pathname, ...) 
[08:27:54.448]                   {
[08:27:54.448]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:27:54.448]                     if (file_test("-f", pathname_tmp)) {
[08:27:54.448]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.448]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:27:54.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.448]                         fi_tmp[["mtime"]])
[08:27:54.448]                     }
[08:27:54.448]                     tryCatch({
[08:27:54.448]                       saveRDS(object, file = pathname_tmp, ...)
[08:27:54.448]                     }, error = function(ex) {
[08:27:54.448]                       msg <- conditionMessage(ex)
[08:27:54.448]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.448]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:27:54.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.448]                         fi_tmp[["mtime"]], msg)
[08:27:54.448]                       ex$message <- msg
[08:27:54.448]                       stop(ex)
[08:27:54.448]                     })
[08:27:54.448]                     stopifnot(file_test("-f", pathname_tmp))
[08:27:54.448]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:27:54.448]                     if (!res || file_test("-f", pathname_tmp)) {
[08:27:54.448]                       fi_tmp <- file.info(pathname_tmp)
[08:27:54.448]                       fi <- file.info(pathname)
[08:27:54.448]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:27:54.448]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:27:54.448]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:27:54.448]                         fi[["size"]], fi[["mtime"]])
[08:27:54.448]                       stop(msg)
[08:27:54.448]                     }
[08:27:54.448]                     invisible(pathname)
[08:27:54.448]                   }
[08:27:54.448]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:27:54.448]                     rootPath = tempdir()) 
[08:27:54.448]                   {
[08:27:54.448]                     obj <- list(time = Sys.time(), condition = cond)
[08:27:54.448]                     file <- tempfile(pattern = class(cond)[1], 
[08:27:54.448]                       tmpdir = path, fileext = ".rds")
[08:27:54.448]                     save_rds(obj, file)
[08:27:54.448]                   }
[08:27:54.448]                   saveImmediateCondition(cond, path = "/tmp/Rtmpx5cIrS/.future/immediateConditions")
[08:27:54.448]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.448]                   {
[08:27:54.448]                     inherits <- base::inherits
[08:27:54.448]                     invokeRestart <- base::invokeRestart
[08:27:54.448]                     is.null <- base::is.null
[08:27:54.448]                     muffled <- FALSE
[08:27:54.448]                     if (inherits(cond, "message")) {
[08:27:54.448]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.448]                       if (muffled) 
[08:27:54.448]                         invokeRestart("muffleMessage")
[08:27:54.448]                     }
[08:27:54.448]                     else if (inherits(cond, "warning")) {
[08:27:54.448]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.448]                       if (muffled) 
[08:27:54.448]                         invokeRestart("muffleWarning")
[08:27:54.448]                     }
[08:27:54.448]                     else if (inherits(cond, "condition")) {
[08:27:54.448]                       if (!is.null(pattern)) {
[08:27:54.448]                         computeRestarts <- base::computeRestarts
[08:27:54.448]                         grepl <- base::grepl
[08:27:54.448]                         restarts <- computeRestarts(cond)
[08:27:54.448]                         for (restart in restarts) {
[08:27:54.448]                           name <- restart$name
[08:27:54.448]                           if (is.null(name)) 
[08:27:54.448]                             next
[08:27:54.448]                           if (!grepl(pattern, name)) 
[08:27:54.448]                             next
[08:27:54.448]                           invokeRestart(restart)
[08:27:54.448]                           muffled <- TRUE
[08:27:54.448]                           break
[08:27:54.448]                         }
[08:27:54.448]                       }
[08:27:54.448]                     }
[08:27:54.448]                     invisible(muffled)
[08:27:54.448]                   }
[08:27:54.448]                   muffleCondition(cond)
[08:27:54.448]                 })
[08:27:54.448]             }))
[08:27:54.448]             future::FutureResult(value = ...future.value$value, 
[08:27:54.448]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.448]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.448]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.448]                     ...future.globalenv.names))
[08:27:54.448]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.448]         }, condition = base::local({
[08:27:54.448]             c <- base::c
[08:27:54.448]             inherits <- base::inherits
[08:27:54.448]             invokeRestart <- base::invokeRestart
[08:27:54.448]             length <- base::length
[08:27:54.448]             list <- base::list
[08:27:54.448]             seq.int <- base::seq.int
[08:27:54.448]             signalCondition <- base::signalCondition
[08:27:54.448]             sys.calls <- base::sys.calls
[08:27:54.448]             `[[` <- base::`[[`
[08:27:54.448]             `+` <- base::`+`
[08:27:54.448]             `<<-` <- base::`<<-`
[08:27:54.448]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.448]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.448]                   3L)]
[08:27:54.448]             }
[08:27:54.448]             function(cond) {
[08:27:54.448]                 is_error <- inherits(cond, "error")
[08:27:54.448]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.448]                   NULL)
[08:27:54.448]                 if (is_error) {
[08:27:54.448]                   sessionInformation <- function() {
[08:27:54.448]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.448]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.448]                       search = base::search(), system = base::Sys.info())
[08:27:54.448]                   }
[08:27:54.448]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.448]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.448]                     cond$call), session = sessionInformation(), 
[08:27:54.448]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.448]                   signalCondition(cond)
[08:27:54.448]                 }
[08:27:54.448]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.448]                 "immediateCondition"))) {
[08:27:54.448]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.448]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.448]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.448]                   if (TRUE && !signal) {
[08:27:54.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.448]                     {
[08:27:54.448]                       inherits <- base::inherits
[08:27:54.448]                       invokeRestart <- base::invokeRestart
[08:27:54.448]                       is.null <- base::is.null
[08:27:54.448]                       muffled <- FALSE
[08:27:54.448]                       if (inherits(cond, "message")) {
[08:27:54.448]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.448]                         if (muffled) 
[08:27:54.448]                           invokeRestart("muffleMessage")
[08:27:54.448]                       }
[08:27:54.448]                       else if (inherits(cond, "warning")) {
[08:27:54.448]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.448]                         if (muffled) 
[08:27:54.448]                           invokeRestart("muffleWarning")
[08:27:54.448]                       }
[08:27:54.448]                       else if (inherits(cond, "condition")) {
[08:27:54.448]                         if (!is.null(pattern)) {
[08:27:54.448]                           computeRestarts <- base::computeRestarts
[08:27:54.448]                           grepl <- base::grepl
[08:27:54.448]                           restarts <- computeRestarts(cond)
[08:27:54.448]                           for (restart in restarts) {
[08:27:54.448]                             name <- restart$name
[08:27:54.448]                             if (is.null(name)) 
[08:27:54.448]                               next
[08:27:54.448]                             if (!grepl(pattern, name)) 
[08:27:54.448]                               next
[08:27:54.448]                             invokeRestart(restart)
[08:27:54.448]                             muffled <- TRUE
[08:27:54.448]                             break
[08:27:54.448]                           }
[08:27:54.448]                         }
[08:27:54.448]                       }
[08:27:54.448]                       invisible(muffled)
[08:27:54.448]                     }
[08:27:54.448]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.448]                   }
[08:27:54.448]                 }
[08:27:54.448]                 else {
[08:27:54.448]                   if (TRUE) {
[08:27:54.448]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.448]                     {
[08:27:54.448]                       inherits <- base::inherits
[08:27:54.448]                       invokeRestart <- base::invokeRestart
[08:27:54.448]                       is.null <- base::is.null
[08:27:54.448]                       muffled <- FALSE
[08:27:54.448]                       if (inherits(cond, "message")) {
[08:27:54.448]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.448]                         if (muffled) 
[08:27:54.448]                           invokeRestart("muffleMessage")
[08:27:54.448]                       }
[08:27:54.448]                       else if (inherits(cond, "warning")) {
[08:27:54.448]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.448]                         if (muffled) 
[08:27:54.448]                           invokeRestart("muffleWarning")
[08:27:54.448]                       }
[08:27:54.448]                       else if (inherits(cond, "condition")) {
[08:27:54.448]                         if (!is.null(pattern)) {
[08:27:54.448]                           computeRestarts <- base::computeRestarts
[08:27:54.448]                           grepl <- base::grepl
[08:27:54.448]                           restarts <- computeRestarts(cond)
[08:27:54.448]                           for (restart in restarts) {
[08:27:54.448]                             name <- restart$name
[08:27:54.448]                             if (is.null(name)) 
[08:27:54.448]                               next
[08:27:54.448]                             if (!grepl(pattern, name)) 
[08:27:54.448]                               next
[08:27:54.448]                             invokeRestart(restart)
[08:27:54.448]                             muffled <- TRUE
[08:27:54.448]                             break
[08:27:54.448]                           }
[08:27:54.448]                         }
[08:27:54.448]                       }
[08:27:54.448]                       invisible(muffled)
[08:27:54.448]                     }
[08:27:54.448]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.448]                   }
[08:27:54.448]                 }
[08:27:54.448]             }
[08:27:54.448]         }))
[08:27:54.448]     }, error = function(ex) {
[08:27:54.448]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.448]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.448]                 ...future.rng), started = ...future.startTime, 
[08:27:54.448]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.448]             version = "1.8"), class = "FutureResult")
[08:27:54.448]     }, finally = {
[08:27:54.448]         if (!identical(...future.workdir, getwd())) 
[08:27:54.448]             setwd(...future.workdir)
[08:27:54.448]         {
[08:27:54.448]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.448]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.448]             }
[08:27:54.448]             base::options(...future.oldOptions)
[08:27:54.448]             if (.Platform$OS.type == "windows") {
[08:27:54.448]                 old_names <- names(...future.oldEnvVars)
[08:27:54.448]                 envs <- base::Sys.getenv()
[08:27:54.448]                 names <- names(envs)
[08:27:54.448]                 common <- intersect(names, old_names)
[08:27:54.448]                 added <- setdiff(names, old_names)
[08:27:54.448]                 removed <- setdiff(old_names, names)
[08:27:54.448]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.448]                   envs[common]]
[08:27:54.448]                 NAMES <- toupper(changed)
[08:27:54.448]                 args <- list()
[08:27:54.448]                 for (kk in seq_along(NAMES)) {
[08:27:54.448]                   name <- changed[[kk]]
[08:27:54.448]                   NAME <- NAMES[[kk]]
[08:27:54.448]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.448]                     next
[08:27:54.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.448]                 }
[08:27:54.448]                 NAMES <- toupper(added)
[08:27:54.448]                 for (kk in seq_along(NAMES)) {
[08:27:54.448]                   name <- added[[kk]]
[08:27:54.448]                   NAME <- NAMES[[kk]]
[08:27:54.448]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.448]                     next
[08:27:54.448]                   args[[name]] <- ""
[08:27:54.448]                 }
[08:27:54.448]                 NAMES <- toupper(removed)
[08:27:54.448]                 for (kk in seq_along(NAMES)) {
[08:27:54.448]                   name <- removed[[kk]]
[08:27:54.448]                   NAME <- NAMES[[kk]]
[08:27:54.448]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.448]                     next
[08:27:54.448]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.448]                 }
[08:27:54.448]                 if (length(args) > 0) 
[08:27:54.448]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.448]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.448]             }
[08:27:54.448]             else {
[08:27:54.448]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.448]             }
[08:27:54.448]             {
[08:27:54.448]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.448]                   0L) {
[08:27:54.448]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.448]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.448]                   base::options(opts)
[08:27:54.448]                 }
[08:27:54.448]                 {
[08:27:54.448]                   {
[08:27:54.448]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.448]                     NULL
[08:27:54.448]                   }
[08:27:54.448]                   options(future.plan = NULL)
[08:27:54.448]                   if (is.na(NA_character_)) 
[08:27:54.448]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.448]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.448]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.448]                     .init = FALSE)
[08:27:54.448]                 }
[08:27:54.448]             }
[08:27:54.448]         }
[08:27:54.448]     })
[08:27:54.448]     if (TRUE) {
[08:27:54.448]         base::sink(type = "output", split = FALSE)
[08:27:54.448]         if (TRUE) {
[08:27:54.448]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.448]         }
[08:27:54.448]         else {
[08:27:54.448]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.448]         }
[08:27:54.448]         base::close(...future.stdout)
[08:27:54.448]         ...future.stdout <- NULL
[08:27:54.448]     }
[08:27:54.448]     ...future.result$conditions <- ...future.conditions
[08:27:54.448]     ...future.result$finished <- base::Sys.time()
[08:27:54.448]     ...future.result
[08:27:54.448] }
[08:27:54.452] requestCore(): workers = 2
[08:27:54.452] Poll #1 (0): usedCores() = 2, workers = 2
[08:27:54.463] result() for MulticoreFuture ...
[08:27:54.464] result() for MulticoreFuture ...
[08:27:54.464] result() for MulticoreFuture ... done
[08:27:54.464] result() for MulticoreFuture ... done
[08:27:54.465] result() for MulticoreFuture ...
[08:27:54.465] result() for MulticoreFuture ... done
[08:27:54.468] MulticoreFuture started
[08:27:54.468] - Launch lazy future ... done
[08:27:54.469] run() for ‘MulticoreFuture’ ... done
[08:27:54.469] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55d85f42c658> 
[08:27:54.470] List of future strategies:
[08:27:54.470] 1. sequential:
[08:27:54.470]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:54.470]    - tweaked: FALSE
[08:27:54.470]    - call: NULL
[08:27:54.471] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55d86264d5a8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ :[08:27:54.474] plan(): Setting new future strategy stack:
 chr [1:2] "a" "b"
  ..$ :[08:27:54.475] List of future strategies:
[08:27:54.475] 1. multicore:
[08:27:54.475]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:27:54.475]    - tweaked: FALSE
[08:27:54.475]    - call: plan(strategy)
 chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[08:27:54.480] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:54.484] resolve() on list environment ...
[08:27:54.484]  recursive: 0
[08:27:54.485]  length: 6
[08:27:54.486]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:54.486] signalConditionsASAP(numeric, pos=1) ...
[08:27:54.486] - nx: 6
[08:27:54.486] - relay: TRUE
[08:27:54.486] - stdout: TRUE
[08:27:54.486] - signal: TRUE
[08:27:54.486] - resignal: FALSE
[08:27:54.486] - force: TRUE
[08:27:54.487] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.487] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.487]  - until=2
[08:27:54.487]  - relaying element #2
[08:27:54.487] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.487] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.487] signalConditionsASAP(NULL, pos=1) ... done
[08:27:54.488]  length: 5 (resolved future 1)
[08:27:54.488] Future #2
[08:27:54.488] result() for MulticoreFuture ...
[08:27:54.488] result() for MulticoreFuture ... done
[08:27:54.488] result() for MulticoreFuture ...
[08:27:54.488] result() for MulticoreFuture ... done
[08:27:54.488] signalConditionsASAP(MulticoreFuture, pos=2) ...
[08:27:54.489] - nx: 6
[08:27:54.489] - relay: TRUE
[08:27:54.489] - stdout: TRUE
[08:27:54.489] - signal: TRUE
[08:27:54.489] - resignal: FALSE
[08:27:54.489] - force: TRUE
[08:27:54.489] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.489] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:54.489]  - until=2
[08:27:54.490]  - relaying element #2
[08:27:54.490] result() for MulticoreFuture ...
[08:27:54.490] result() for MulticoreFuture ... done
[08:27:54.490] result() for MulticoreFuture ...
[08:27:54.490] result() for MulticoreFuture ... done
[08:27:54.490] result() for MulticoreFuture ...
[08:27:54.490] result() for MulticoreFuture ... done
[08:27:54.490] result() for MulticoreFuture ...
[08:27:54.491] result() for MulticoreFuture ... done
[08:27:54.491] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.491] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.491] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[08:27:54.491]  length: 4 (resolved future 2)
[08:27:54.491] Future #3
[08:27:54.492] result() for MulticoreFuture ...
[08:27:54.492] result() for MulticoreFuture ...
[08:27:54.493] result() for MulticoreFuture ... done
[08:27:54.493] result() for MulticoreFuture ... done
[08:27:54.493] result() for MulticoreFuture ...
[08:27:54.493] result() for MulticoreFuture ... done
[08:27:54.493] signalConditionsASAP(MulticoreFuture, pos=3) ...
[08:27:54.493] - nx: 6
[08:27:54.493] - relay: TRUE
[08:27:54.494] - stdout: TRUE
[08:27:54.494] - signal: TRUE
[08:27:54.494] - resignal: FALSE
[08:27:54.494] - force: TRUE
[08:27:54.494] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.494] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:54.494]  - until=3
[08:27:54.494]  - relaying element #3
[08:27:54.494] result() for MulticoreFuture ...
[08:27:54.495] result() for MulticoreFuture ... done
[08:27:54.495] result() for MulticoreFuture ...
[08:27:54.495] result() for MulticoreFuture ... done
[08:27:54.495] result() for MulticoreFuture ...
[08:27:54.495] result() for MulticoreFuture ... done
[08:27:54.495] result() for MulticoreFuture ...
[08:27:54.495] result() for MulticoreFuture ... done
[08:27:54.495] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.496] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.496] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[08:27:54.496]  length: 3 (resolved future 3)
[08:27:54.496] Future #4
[08:27:54.496] result() for MulticoreFuture ...
[08:27:54.497] result() for MulticoreFuture ...
[08:27:54.497] result() for MulticoreFuture ... done
[08:27:54.497] result() for MulticoreFuture ... done
[08:27:54.498] result() for MulticoreFuture ...
[08:27:54.498] result() for MulticoreFuture ... done
[08:27:54.498] signalConditionsASAP(MulticoreFuture, pos=4) ...
[08:27:54.498] - nx: 6
[08:27:54.498] - relay: TRUE
[08:27:54.498] - stdout: TRUE
[08:27:54.499] - signal: TRUE
[08:27:54.499] - resignal: FALSE
[08:27:54.499] - force: TRUE
[08:27:54.499] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.499] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:54.499]  - until=4
[08:27:54.499]  - relaying element #4
[08:27:54.500] result() for MulticoreFuture ...
[08:27:54.500] result() for MulticoreFuture ... done
[08:27:54.500] result() for MulticoreFuture ...
[08:27:54.500] result() for MulticoreFuture ... done
[08:27:54.500] result() for MulticoreFuture ...
[08:27:54.500] result() for MulticoreFuture ... done
[08:27:54.501] result() for MulticoreFuture ...
[08:27:54.501] result() for MulticoreFuture ... done
[08:27:54.501] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.501] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.501] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[08:27:54.501]  length: 2 (resolved future 4)
[08:27:54.502] signalConditionsASAP(NULL, pos=5) ...
[08:27:54.502] - nx: 6
[08:27:54.502] - relay: TRUE
[08:27:54.502] - stdout: TRUE
[08:27:54.502] - signal: TRUE
[08:27:54.502] - resignal: FALSE
[08:27:54.502] - force: TRUE
[08:27:54.502] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.502] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.502]  - until=6
[08:27:54.503]  - relaying element #6
[08:27:54.503] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.503] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.503] signalConditionsASAP(NULL, pos=5) ... done
[08:27:54.503]  length: 1 (resolved future 5)
[08:27:54.503] signalConditionsASAP(numeric, pos=6) ...
[08:27:54.503] - nx: 6
[08:27:54.503] - relay: TRUE
[08:27:54.503] - stdout: TRUE
[08:27:54.503] - signal: TRUE
[08:27:54.504] - resignal: FALSE
[08:27:54.504] - force: TRUE
[08:27:54.504] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[08:27:54.504] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.504]  - until=6
[08:27:54.504] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.504] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.504] signalConditionsASAP(numeric, pos=6) ... done
[08:27:54.504]  length: 0 (resolved future 6)
[08:27:54.504] Relaying remaining futures
[08:27:54.504] signalConditionsASAP(NULL, pos=0) ...
[08:27:54.505] - nx: 6
[08:27:54.505] - relay: TRUE
[08:27:54.505] - stdout: TRUE
[08:27:54.505] - signal: TRUE
[08:27:54.505] - resignal: FALSE
[08:27:54.505] - force: TRUE
[08:27:54.505] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.505] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:54.505] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:54.505] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:54.506] signalConditionsASAP(NULL, pos=0) ... done
[08:27:54.506] resolve() on list environment ... DONE
[08:27:54.506] result() for MulticoreFuture ...
[08:27:54.506] result() for MulticoreFuture ... done
[08:27:54.510] result() for MulticoreFuture ...
[08:27:54.510] result() for MulticoreFuture ... done
[08:27:54.510] result() for MulticoreFuture ...
[08:27:54.511] result() for MulticoreFuture ... done
[08:27:54.511] result() for MulticoreFuture ...
[08:27:54.511] result() for MulticoreFuture ... done
[08:27:54.511] result() for MulticoreFuture ...
[08:27:54.512] result() for MulticoreFuture ... done
[08:27:54.512] result() for MulticoreFuture ...
[08:27:54.512] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d862906aa0> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[08:27:54.515] plan(): Setting new future strategy stack:
[08:27:54.515] List of future strategies:
[08:27:54.515] 1. multisession:
[08:27:54.515]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:54.515]    - tweaked: FALSE
[08:27:54.515]    - call: plan(strategy)
[08:27:54.515] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:27:54.515] multisession:
[08:27:54.515] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:27:54.515] - tweaked: FALSE
[08:27:54.515] - call: plan(strategy)
[08:27:54.517] getGlobalsAndPackages() ...
[08:27:54.518] Not searching for globals
[08:27:54.518] - globals: [0] <none>
[08:27:54.518] getGlobalsAndPackages() ... DONE
[08:27:54.779] Packages needed by the future expression (n = 0): <none>
[08:27:54.780] Packages needed by future strategies (n = 0): <none>
[08:27:54.780] {
[08:27:54.780]     {
[08:27:54.780]         {
[08:27:54.780]             ...future.startTime <- base::Sys.time()
[08:27:54.780]             {
[08:27:54.780]                 {
[08:27:54.780]                   {
[08:27:54.780]                     {
[08:27:54.780]                       base::local({
[08:27:54.780]                         has_future <- base::requireNamespace("future", 
[08:27:54.780]                           quietly = TRUE)
[08:27:54.780]                         if (has_future) {
[08:27:54.780]                           ns <- base::getNamespace("future")
[08:27:54.780]                           version <- ns[[".package"]][["version"]]
[08:27:54.780]                           if (is.null(version)) 
[08:27:54.780]                             version <- utils::packageVersion("future")
[08:27:54.780]                         }
[08:27:54.780]                         else {
[08:27:54.780]                           version <- NULL
[08:27:54.780]                         }
[08:27:54.780]                         if (!has_future || version < "1.8.0") {
[08:27:54.780]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.780]                             "", base::R.version$version.string), 
[08:27:54.780]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.780]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.780]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.780]                               "release", "version")], collapse = " "), 
[08:27:54.780]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.780]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.780]                             info)
[08:27:54.780]                           info <- base::paste(info, collapse = "; ")
[08:27:54.780]                           if (!has_future) {
[08:27:54.780]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.780]                               info)
[08:27:54.780]                           }
[08:27:54.780]                           else {
[08:27:54.780]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.780]                               info, version)
[08:27:54.780]                           }
[08:27:54.780]                           base::stop(msg)
[08:27:54.780]                         }
[08:27:54.780]                       })
[08:27:54.780]                     }
[08:27:54.780]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.780]                     base::options(mc.cores = 1L)
[08:27:54.780]                   }
[08:27:54.780]                   ...future.strategy.old <- future::plan("list")
[08:27:54.780]                   options(future.plan = NULL)
[08:27:54.780]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.780]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.780]                 }
[08:27:54.780]                 ...future.workdir <- getwd()
[08:27:54.780]             }
[08:27:54.780]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.780]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.780]         }
[08:27:54.780]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.780]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.780]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.780]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.780]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.780]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.780]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.780]             base::names(...future.oldOptions))
[08:27:54.780]     }
[08:27:54.780]     if (FALSE) {
[08:27:54.780]     }
[08:27:54.780]     else {
[08:27:54.780]         if (TRUE) {
[08:27:54.780]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.780]                 open = "w")
[08:27:54.780]         }
[08:27:54.780]         else {
[08:27:54.780]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.780]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.780]         }
[08:27:54.780]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.780]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.780]             base::sink(type = "output", split = FALSE)
[08:27:54.780]             base::close(...future.stdout)
[08:27:54.780]         }, add = TRUE)
[08:27:54.780]     }
[08:27:54.780]     ...future.frame <- base::sys.nframe()
[08:27:54.780]     ...future.conditions <- base::list()
[08:27:54.780]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.780]     if (FALSE) {
[08:27:54.780]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.780]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.780]     }
[08:27:54.780]     ...future.result <- base::tryCatch({
[08:27:54.780]         base::withCallingHandlers({
[08:27:54.780]             ...future.value <- base::withVisible(base::local({
[08:27:54.780]                 ...future.makeSendCondition <- base::local({
[08:27:54.780]                   sendCondition <- NULL
[08:27:54.780]                   function(frame = 1L) {
[08:27:54.780]                     if (is.function(sendCondition)) 
[08:27:54.780]                       return(sendCondition)
[08:27:54.780]                     ns <- getNamespace("parallel")
[08:27:54.780]                     if (exists("sendData", mode = "function", 
[08:27:54.780]                       envir = ns)) {
[08:27:54.780]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:54.780]                         envir = ns)
[08:27:54.780]                       envir <- sys.frame(frame)
[08:27:54.780]                       master <- NULL
[08:27:54.780]                       while (!identical(envir, .GlobalEnv) && 
[08:27:54.780]                         !identical(envir, emptyenv())) {
[08:27:54.780]                         if (exists("master", mode = "list", envir = envir, 
[08:27:54.780]                           inherits = FALSE)) {
[08:27:54.780]                           master <- get("master", mode = "list", 
[08:27:54.780]                             envir = envir, inherits = FALSE)
[08:27:54.780]                           if (inherits(master, c("SOCKnode", 
[08:27:54.780]                             "SOCK0node"))) {
[08:27:54.780]                             sendCondition <<- function(cond) {
[08:27:54.780]                               data <- list(type = "VALUE", value = cond, 
[08:27:54.780]                                 success = TRUE)
[08:27:54.780]                               parallel_sendData(master, data)
[08:27:54.780]                             }
[08:27:54.780]                             return(sendCondition)
[08:27:54.780]                           }
[08:27:54.780]                         }
[08:27:54.780]                         frame <- frame + 1L
[08:27:54.780]                         envir <- sys.frame(frame)
[08:27:54.780]                       }
[08:27:54.780]                     }
[08:27:54.780]                     sendCondition <<- function(cond) NULL
[08:27:54.780]                   }
[08:27:54.780]                 })
[08:27:54.780]                 withCallingHandlers({
[08:27:54.780]                   NA
[08:27:54.780]                 }, immediateCondition = function(cond) {
[08:27:54.780]                   sendCondition <- ...future.makeSendCondition()
[08:27:54.780]                   sendCondition(cond)
[08:27:54.780]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.780]                   {
[08:27:54.780]                     inherits <- base::inherits
[08:27:54.780]                     invokeRestart <- base::invokeRestart
[08:27:54.780]                     is.null <- base::is.null
[08:27:54.780]                     muffled <- FALSE
[08:27:54.780]                     if (inherits(cond, "message")) {
[08:27:54.780]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.780]                       if (muffled) 
[08:27:54.780]                         invokeRestart("muffleMessage")
[08:27:54.780]                     }
[08:27:54.780]                     else if (inherits(cond, "warning")) {
[08:27:54.780]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.780]                       if (muffled) 
[08:27:54.780]                         invokeRestart("muffleWarning")
[08:27:54.780]                     }
[08:27:54.780]                     else if (inherits(cond, "condition")) {
[08:27:54.780]                       if (!is.null(pattern)) {
[08:27:54.780]                         computeRestarts <- base::computeRestarts
[08:27:54.780]                         grepl <- base::grepl
[08:27:54.780]                         restarts <- computeRestarts(cond)
[08:27:54.780]                         for (restart in restarts) {
[08:27:54.780]                           name <- restart$name
[08:27:54.780]                           if (is.null(name)) 
[08:27:54.780]                             next
[08:27:54.780]                           if (!grepl(pattern, name)) 
[08:27:54.780]                             next
[08:27:54.780]                           invokeRestart(restart)
[08:27:54.780]                           muffled <- TRUE
[08:27:54.780]                           break
[08:27:54.780]                         }
[08:27:54.780]                       }
[08:27:54.780]                     }
[08:27:54.780]                     invisible(muffled)
[08:27:54.780]                   }
[08:27:54.780]                   muffleCondition(cond)
[08:27:54.780]                 })
[08:27:54.780]             }))
[08:27:54.780]             future::FutureResult(value = ...future.value$value, 
[08:27:54.780]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.780]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.780]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.780]                     ...future.globalenv.names))
[08:27:54.780]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.780]         }, condition = base::local({
[08:27:54.780]             c <- base::c
[08:27:54.780]             inherits <- base::inherits
[08:27:54.780]             invokeRestart <- base::invokeRestart
[08:27:54.780]             length <- base::length
[08:27:54.780]             list <- base::list
[08:27:54.780]             seq.int <- base::seq.int
[08:27:54.780]             signalCondition <- base::signalCondition
[08:27:54.780]             sys.calls <- base::sys.calls
[08:27:54.780]             `[[` <- base::`[[`
[08:27:54.780]             `+` <- base::`+`
[08:27:54.780]             `<<-` <- base::`<<-`
[08:27:54.780]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.780]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.780]                   3L)]
[08:27:54.780]             }
[08:27:54.780]             function(cond) {
[08:27:54.780]                 is_error <- inherits(cond, "error")
[08:27:54.780]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.780]                   NULL)
[08:27:54.780]                 if (is_error) {
[08:27:54.780]                   sessionInformation <- function() {
[08:27:54.780]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.780]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.780]                       search = base::search(), system = base::Sys.info())
[08:27:54.780]                   }
[08:27:54.780]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.780]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.780]                     cond$call), session = sessionInformation(), 
[08:27:54.780]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.780]                   signalCondition(cond)
[08:27:54.780]                 }
[08:27:54.780]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.780]                 "immediateCondition"))) {
[08:27:54.780]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.780]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.780]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.780]                   if (TRUE && !signal) {
[08:27:54.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.780]                     {
[08:27:54.780]                       inherits <- base::inherits
[08:27:54.780]                       invokeRestart <- base::invokeRestart
[08:27:54.780]                       is.null <- base::is.null
[08:27:54.780]                       muffled <- FALSE
[08:27:54.780]                       if (inherits(cond, "message")) {
[08:27:54.780]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.780]                         if (muffled) 
[08:27:54.780]                           invokeRestart("muffleMessage")
[08:27:54.780]                       }
[08:27:54.780]                       else if (inherits(cond, "warning")) {
[08:27:54.780]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.780]                         if (muffled) 
[08:27:54.780]                           invokeRestart("muffleWarning")
[08:27:54.780]                       }
[08:27:54.780]                       else if (inherits(cond, "condition")) {
[08:27:54.780]                         if (!is.null(pattern)) {
[08:27:54.780]                           computeRestarts <- base::computeRestarts
[08:27:54.780]                           grepl <- base::grepl
[08:27:54.780]                           restarts <- computeRestarts(cond)
[08:27:54.780]                           for (restart in restarts) {
[08:27:54.780]                             name <- restart$name
[08:27:54.780]                             if (is.null(name)) 
[08:27:54.780]                               next
[08:27:54.780]                             if (!grepl(pattern, name)) 
[08:27:54.780]                               next
[08:27:54.780]                             invokeRestart(restart)
[08:27:54.780]                             muffled <- TRUE
[08:27:54.780]                             break
[08:27:54.780]                           }
[08:27:54.780]                         }
[08:27:54.780]                       }
[08:27:54.780]                       invisible(muffled)
[08:27:54.780]                     }
[08:27:54.780]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.780]                   }
[08:27:54.780]                 }
[08:27:54.780]                 else {
[08:27:54.780]                   if (TRUE) {
[08:27:54.780]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.780]                     {
[08:27:54.780]                       inherits <- base::inherits
[08:27:54.780]                       invokeRestart <- base::invokeRestart
[08:27:54.780]                       is.null <- base::is.null
[08:27:54.780]                       muffled <- FALSE
[08:27:54.780]                       if (inherits(cond, "message")) {
[08:27:54.780]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.780]                         if (muffled) 
[08:27:54.780]                           invokeRestart("muffleMessage")
[08:27:54.780]                       }
[08:27:54.780]                       else if (inherits(cond, "warning")) {
[08:27:54.780]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.780]                         if (muffled) 
[08:27:54.780]                           invokeRestart("muffleWarning")
[08:27:54.780]                       }
[08:27:54.780]                       else if (inherits(cond, "condition")) {
[08:27:54.780]                         if (!is.null(pattern)) {
[08:27:54.780]                           computeRestarts <- base::computeRestarts
[08:27:54.780]                           grepl <- base::grepl
[08:27:54.780]                           restarts <- computeRestarts(cond)
[08:27:54.780]                           for (restart in restarts) {
[08:27:54.780]                             name <- restart$name
[08:27:54.780]                             if (is.null(name)) 
[08:27:54.780]                               next
[08:27:54.780]                             if (!grepl(pattern, name)) 
[08:27:54.780]                               next
[08:27:54.780]                             invokeRestart(restart)
[08:27:54.780]                             muffled <- TRUE
[08:27:54.780]                             break
[08:27:54.780]                           }
[08:27:54.780]                         }
[08:27:54.780]                       }
[08:27:54.780]                       invisible(muffled)
[08:27:54.780]                     }
[08:27:54.780]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.780]                   }
[08:27:54.780]                 }
[08:27:54.780]             }
[08:27:54.780]         }))
[08:27:54.780]     }, error = function(ex) {
[08:27:54.780]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.780]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.780]                 ...future.rng), started = ...future.startTime, 
[08:27:54.780]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.780]             version = "1.8"), class = "FutureResult")
[08:27:54.780]     }, finally = {
[08:27:54.780]         if (!identical(...future.workdir, getwd())) 
[08:27:54.780]             setwd(...future.workdir)
[08:27:54.780]         {
[08:27:54.780]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.780]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.780]             }
[08:27:54.780]             base::options(...future.oldOptions)
[08:27:54.780]             if (.Platform$OS.type == "windows") {
[08:27:54.780]                 old_names <- names(...future.oldEnvVars)
[08:27:54.780]                 envs <- base::Sys.getenv()
[08:27:54.780]                 names <- names(envs)
[08:27:54.780]                 common <- intersect(names, old_names)
[08:27:54.780]                 added <- setdiff(names, old_names)
[08:27:54.780]                 removed <- setdiff(old_names, names)
[08:27:54.780]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.780]                   envs[common]]
[08:27:54.780]                 NAMES <- toupper(changed)
[08:27:54.780]                 args <- list()
[08:27:54.780]                 for (kk in seq_along(NAMES)) {
[08:27:54.780]                   name <- changed[[kk]]
[08:27:54.780]                   NAME <- NAMES[[kk]]
[08:27:54.780]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.780]                     next
[08:27:54.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.780]                 }
[08:27:54.780]                 NAMES <- toupper(added)
[08:27:54.780]                 for (kk in seq_along(NAMES)) {
[08:27:54.780]                   name <- added[[kk]]
[08:27:54.780]                   NAME <- NAMES[[kk]]
[08:27:54.780]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.780]                     next
[08:27:54.780]                   args[[name]] <- ""
[08:27:54.780]                 }
[08:27:54.780]                 NAMES <- toupper(removed)
[08:27:54.780]                 for (kk in seq_along(NAMES)) {
[08:27:54.780]                   name <- removed[[kk]]
[08:27:54.780]                   NAME <- NAMES[[kk]]
[08:27:54.780]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.780]                     next
[08:27:54.780]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.780]                 }
[08:27:54.780]                 if (length(args) > 0) 
[08:27:54.780]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.780]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.780]             }
[08:27:54.780]             else {
[08:27:54.780]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.780]             }
[08:27:54.780]             {
[08:27:54.780]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.780]                   0L) {
[08:27:54.780]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.780]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.780]                   base::options(opts)
[08:27:54.780]                 }
[08:27:54.780]                 {
[08:27:54.780]                   {
[08:27:54.780]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.780]                     NULL
[08:27:54.780]                   }
[08:27:54.780]                   options(future.plan = NULL)
[08:27:54.780]                   if (is.na(NA_character_)) 
[08:27:54.780]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.780]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.780]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.780]                     .init = FALSE)
[08:27:54.780]                 }
[08:27:54.780]             }
[08:27:54.780]         }
[08:27:54.780]     })
[08:27:54.780]     if (TRUE) {
[08:27:54.780]         base::sink(type = "output", split = FALSE)
[08:27:54.780]         if (TRUE) {
[08:27:54.780]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.780]         }
[08:27:54.780]         else {
[08:27:54.780]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.780]         }
[08:27:54.780]         base::close(...future.stdout)
[08:27:54.780]         ...future.stdout <- NULL
[08:27:54.780]     }
[08:27:54.780]     ...future.result$conditions <- ...future.conditions
[08:27:54.780]     ...future.result$finished <- base::Sys.time()
[08:27:54.780]     ...future.result
[08:27:54.780] }
[08:27:54.836] MultisessionFuture started
[08:27:54.836] result() for ClusterFuture ...
[08:27:54.836] receiveMessageFromWorker() for ClusterFuture ...
[08:27:54.836] - Validating connection of MultisessionFuture
[08:27:54.868] - received message: FutureResult
[08:27:54.869] - Received FutureResult
[08:27:54.869] - Erased future from FutureRegistry
[08:27:54.869] result() for ClusterFuture ...
[08:27:54.869] - result already collected: FutureResult
[08:27:54.869] result() for ClusterFuture ... done
[08:27:54.869] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:54.869] result() for ClusterFuture ... done
[08:27:54.869] result() for ClusterFuture ...
[08:27:54.870] - result already collected: FutureResult
[08:27:54.870] result() for ClusterFuture ... done
[08:27:54.870] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:27:54.872] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[08:27:54.872] getGlobalsAndPackages() ...
[08:27:54.872] Searching for globals...
[08:27:54.872] 
[08:27:54.873] Searching for globals ... DONE
[08:27:54.873] - globals: [0] <none>
[08:27:54.873] getGlobalsAndPackages() ... DONE
[08:27:54.873] run() for ‘Future’ ...
[08:27:54.873] - state: ‘created’
[08:27:54.873] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.887] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.888] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:54.888]   - Field: ‘node’
[08:27:54.888]   - Field: ‘label’
[08:27:54.888]   - Field: ‘local’
[08:27:54.888]   - Field: ‘owner’
[08:27:54.888]   - Field: ‘envir’
[08:27:54.888]   - Field: ‘workers’
[08:27:54.888]   - Field: ‘packages’
[08:27:54.889]   - Field: ‘gc’
[08:27:54.889]   - Field: ‘conditions’
[08:27:54.889]   - Field: ‘persistent’
[08:27:54.889]   - Field: ‘expr’
[08:27:54.889]   - Field: ‘uuid’
[08:27:54.889]   - Field: ‘seed’
[08:27:54.889]   - Field: ‘version’
[08:27:54.889]   - Field: ‘result’
[08:27:54.889]   - Field: ‘asynchronous’
[08:27:54.889]   - Field: ‘calls’
[08:27:54.890]   - Field: ‘globals’
[08:27:54.890]   - Field: ‘stdout’
[08:27:54.890]   - Field: ‘earlySignal’
[08:27:54.890]   - Field: ‘lazy’
[08:27:54.890]   - Field: ‘state’
[08:27:54.890] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:54.890] - Launch lazy future ...
[08:27:54.891] Packages needed by the future expression (n = 0): <none>
[08:27:54.891] Packages needed by future strategies (n = 0): <none>
[08:27:54.891] {
[08:27:54.891]     {
[08:27:54.891]         {
[08:27:54.891]             ...future.startTime <- base::Sys.time()
[08:27:54.891]             {
[08:27:54.891]                 {
[08:27:54.891]                   {
[08:27:54.891]                     {
[08:27:54.891]                       base::local({
[08:27:54.891]                         has_future <- base::requireNamespace("future", 
[08:27:54.891]                           quietly = TRUE)
[08:27:54.891]                         if (has_future) {
[08:27:54.891]                           ns <- base::getNamespace("future")
[08:27:54.891]                           version <- ns[[".package"]][["version"]]
[08:27:54.891]                           if (is.null(version)) 
[08:27:54.891]                             version <- utils::packageVersion("future")
[08:27:54.891]                         }
[08:27:54.891]                         else {
[08:27:54.891]                           version <- NULL
[08:27:54.891]                         }
[08:27:54.891]                         if (!has_future || version < "1.8.0") {
[08:27:54.891]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.891]                             "", base::R.version$version.string), 
[08:27:54.891]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.891]                               "release", "version")], collapse = " "), 
[08:27:54.891]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.891]                             info)
[08:27:54.891]                           info <- base::paste(info, collapse = "; ")
[08:27:54.891]                           if (!has_future) {
[08:27:54.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.891]                               info)
[08:27:54.891]                           }
[08:27:54.891]                           else {
[08:27:54.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.891]                               info, version)
[08:27:54.891]                           }
[08:27:54.891]                           base::stop(msg)
[08:27:54.891]                         }
[08:27:54.891]                       })
[08:27:54.891]                     }
[08:27:54.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.891]                     base::options(mc.cores = 1L)
[08:27:54.891]                   }
[08:27:54.891]                   ...future.strategy.old <- future::plan("list")
[08:27:54.891]                   options(future.plan = NULL)
[08:27:54.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.891]                 }
[08:27:54.891]                 ...future.workdir <- getwd()
[08:27:54.891]             }
[08:27:54.891]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.891]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.891]         }
[08:27:54.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.891]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.891]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.891]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.891]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.891]             base::names(...future.oldOptions))
[08:27:54.891]     }
[08:27:54.891]     if (FALSE) {
[08:27:54.891]     }
[08:27:54.891]     else {
[08:27:54.891]         if (TRUE) {
[08:27:54.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.891]                 open = "w")
[08:27:54.891]         }
[08:27:54.891]         else {
[08:27:54.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.891]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.891]         }
[08:27:54.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.891]             base::sink(type = "output", split = FALSE)
[08:27:54.891]             base::close(...future.stdout)
[08:27:54.891]         }, add = TRUE)
[08:27:54.891]     }
[08:27:54.891]     ...future.frame <- base::sys.nframe()
[08:27:54.891]     ...future.conditions <- base::list()
[08:27:54.891]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.891]     if (FALSE) {
[08:27:54.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.891]     }
[08:27:54.891]     ...future.result <- base::tryCatch({
[08:27:54.891]         base::withCallingHandlers({
[08:27:54.891]             ...future.value <- base::withVisible(base::local({
[08:27:54.891]                 ...future.makeSendCondition <- base::local({
[08:27:54.891]                   sendCondition <- NULL
[08:27:54.891]                   function(frame = 1L) {
[08:27:54.891]                     if (is.function(sendCondition)) 
[08:27:54.891]                       return(sendCondition)
[08:27:54.891]                     ns <- getNamespace("parallel")
[08:27:54.891]                     if (exists("sendData", mode = "function", 
[08:27:54.891]                       envir = ns)) {
[08:27:54.891]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:54.891]                         envir = ns)
[08:27:54.891]                       envir <- sys.frame(frame)
[08:27:54.891]                       master <- NULL
[08:27:54.891]                       while (!identical(envir, .GlobalEnv) && 
[08:27:54.891]                         !identical(envir, emptyenv())) {
[08:27:54.891]                         if (exists("master", mode = "list", envir = envir, 
[08:27:54.891]                           inherits = FALSE)) {
[08:27:54.891]                           master <- get("master", mode = "list", 
[08:27:54.891]                             envir = envir, inherits = FALSE)
[08:27:54.891]                           if (inherits(master, c("SOCKnode", 
[08:27:54.891]                             "SOCK0node"))) {
[08:27:54.891]                             sendCondition <<- function(cond) {
[08:27:54.891]                               data <- list(type = "VALUE", value = cond, 
[08:27:54.891]                                 success = TRUE)
[08:27:54.891]                               parallel_sendData(master, data)
[08:27:54.891]                             }
[08:27:54.891]                             return(sendCondition)
[08:27:54.891]                           }
[08:27:54.891]                         }
[08:27:54.891]                         frame <- frame + 1L
[08:27:54.891]                         envir <- sys.frame(frame)
[08:27:54.891]                       }
[08:27:54.891]                     }
[08:27:54.891]                     sendCondition <<- function(cond) NULL
[08:27:54.891]                   }
[08:27:54.891]                 })
[08:27:54.891]                 withCallingHandlers({
[08:27:54.891]                   2
[08:27:54.891]                 }, immediateCondition = function(cond) {
[08:27:54.891]                   sendCondition <- ...future.makeSendCondition()
[08:27:54.891]                   sendCondition(cond)
[08:27:54.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.891]                   {
[08:27:54.891]                     inherits <- base::inherits
[08:27:54.891]                     invokeRestart <- base::invokeRestart
[08:27:54.891]                     is.null <- base::is.null
[08:27:54.891]                     muffled <- FALSE
[08:27:54.891]                     if (inherits(cond, "message")) {
[08:27:54.891]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.891]                       if (muffled) 
[08:27:54.891]                         invokeRestart("muffleMessage")
[08:27:54.891]                     }
[08:27:54.891]                     else if (inherits(cond, "warning")) {
[08:27:54.891]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.891]                       if (muffled) 
[08:27:54.891]                         invokeRestart("muffleWarning")
[08:27:54.891]                     }
[08:27:54.891]                     else if (inherits(cond, "condition")) {
[08:27:54.891]                       if (!is.null(pattern)) {
[08:27:54.891]                         computeRestarts <- base::computeRestarts
[08:27:54.891]                         grepl <- base::grepl
[08:27:54.891]                         restarts <- computeRestarts(cond)
[08:27:54.891]                         for (restart in restarts) {
[08:27:54.891]                           name <- restart$name
[08:27:54.891]                           if (is.null(name)) 
[08:27:54.891]                             next
[08:27:54.891]                           if (!grepl(pattern, name)) 
[08:27:54.891]                             next
[08:27:54.891]                           invokeRestart(restart)
[08:27:54.891]                           muffled <- TRUE
[08:27:54.891]                           break
[08:27:54.891]                         }
[08:27:54.891]                       }
[08:27:54.891]                     }
[08:27:54.891]                     invisible(muffled)
[08:27:54.891]                   }
[08:27:54.891]                   muffleCondition(cond)
[08:27:54.891]                 })
[08:27:54.891]             }))
[08:27:54.891]             future::FutureResult(value = ...future.value$value, 
[08:27:54.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.891]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.891]                     ...future.globalenv.names))
[08:27:54.891]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.891]         }, condition = base::local({
[08:27:54.891]             c <- base::c
[08:27:54.891]             inherits <- base::inherits
[08:27:54.891]             invokeRestart <- base::invokeRestart
[08:27:54.891]             length <- base::length
[08:27:54.891]             list <- base::list
[08:27:54.891]             seq.int <- base::seq.int
[08:27:54.891]             signalCondition <- base::signalCondition
[08:27:54.891]             sys.calls <- base::sys.calls
[08:27:54.891]             `[[` <- base::`[[`
[08:27:54.891]             `+` <- base::`+`
[08:27:54.891]             `<<-` <- base::`<<-`
[08:27:54.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.891]                   3L)]
[08:27:54.891]             }
[08:27:54.891]             function(cond) {
[08:27:54.891]                 is_error <- inherits(cond, "error")
[08:27:54.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.891]                   NULL)
[08:27:54.891]                 if (is_error) {
[08:27:54.891]                   sessionInformation <- function() {
[08:27:54.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.891]                       search = base::search(), system = base::Sys.info())
[08:27:54.891]                   }
[08:27:54.891]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.891]                     cond$call), session = sessionInformation(), 
[08:27:54.891]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.891]                   signalCondition(cond)
[08:27:54.891]                 }
[08:27:54.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.891]                 "immediateCondition"))) {
[08:27:54.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.891]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.891]                   if (TRUE && !signal) {
[08:27:54.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.891]                     {
[08:27:54.891]                       inherits <- base::inherits
[08:27:54.891]                       invokeRestart <- base::invokeRestart
[08:27:54.891]                       is.null <- base::is.null
[08:27:54.891]                       muffled <- FALSE
[08:27:54.891]                       if (inherits(cond, "message")) {
[08:27:54.891]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.891]                         if (muffled) 
[08:27:54.891]                           invokeRestart("muffleMessage")
[08:27:54.891]                       }
[08:27:54.891]                       else if (inherits(cond, "warning")) {
[08:27:54.891]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.891]                         if (muffled) 
[08:27:54.891]                           invokeRestart("muffleWarning")
[08:27:54.891]                       }
[08:27:54.891]                       else if (inherits(cond, "condition")) {
[08:27:54.891]                         if (!is.null(pattern)) {
[08:27:54.891]                           computeRestarts <- base::computeRestarts
[08:27:54.891]                           grepl <- base::grepl
[08:27:54.891]                           restarts <- computeRestarts(cond)
[08:27:54.891]                           for (restart in restarts) {
[08:27:54.891]                             name <- restart$name
[08:27:54.891]                             if (is.null(name)) 
[08:27:54.891]                               next
[08:27:54.891]                             if (!grepl(pattern, name)) 
[08:27:54.891]                               next
[08:27:54.891]                             invokeRestart(restart)
[08:27:54.891]                             muffled <- TRUE
[08:27:54.891]                             break
[08:27:54.891]                           }
[08:27:54.891]                         }
[08:27:54.891]                       }
[08:27:54.891]                       invisible(muffled)
[08:27:54.891]                     }
[08:27:54.891]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.891]                   }
[08:27:54.891]                 }
[08:27:54.891]                 else {
[08:27:54.891]                   if (TRUE) {
[08:27:54.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.891]                     {
[08:27:54.891]                       inherits <- base::inherits
[08:27:54.891]                       invokeRestart <- base::invokeRestart
[08:27:54.891]                       is.null <- base::is.null
[08:27:54.891]                       muffled <- FALSE
[08:27:54.891]                       if (inherits(cond, "message")) {
[08:27:54.891]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.891]                         if (muffled) 
[08:27:54.891]                           invokeRestart("muffleMessage")
[08:27:54.891]                       }
[08:27:54.891]                       else if (inherits(cond, "warning")) {
[08:27:54.891]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.891]                         if (muffled) 
[08:27:54.891]                           invokeRestart("muffleWarning")
[08:27:54.891]                       }
[08:27:54.891]                       else if (inherits(cond, "condition")) {
[08:27:54.891]                         if (!is.null(pattern)) {
[08:27:54.891]                           computeRestarts <- base::computeRestarts
[08:27:54.891]                           grepl <- base::grepl
[08:27:54.891]                           restarts <- computeRestarts(cond)
[08:27:54.891]                           for (restart in restarts) {
[08:27:54.891]                             name <- restart$name
[08:27:54.891]                             if (is.null(name)) 
[08:27:54.891]                               next
[08:27:54.891]                             if (!grepl(pattern, name)) 
[08:27:54.891]                               next
[08:27:54.891]                             invokeRestart(restart)
[08:27:54.891]                             muffled <- TRUE
[08:27:54.891]                             break
[08:27:54.891]                           }
[08:27:54.891]                         }
[08:27:54.891]                       }
[08:27:54.891]                       invisible(muffled)
[08:27:54.891]                     }
[08:27:54.891]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.891]                   }
[08:27:54.891]                 }
[08:27:54.891]             }
[08:27:54.891]         }))
[08:27:54.891]     }, error = function(ex) {
[08:27:54.891]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.891]                 ...future.rng), started = ...future.startTime, 
[08:27:54.891]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.891]             version = "1.8"), class = "FutureResult")
[08:27:54.891]     }, finally = {
[08:27:54.891]         if (!identical(...future.workdir, getwd())) 
[08:27:54.891]             setwd(...future.workdir)
[08:27:54.891]         {
[08:27:54.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.891]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.891]             }
[08:27:54.891]             base::options(...future.oldOptions)
[08:27:54.891]             if (.Platform$OS.type == "windows") {
[08:27:54.891]                 old_names <- names(...future.oldEnvVars)
[08:27:54.891]                 envs <- base::Sys.getenv()
[08:27:54.891]                 names <- names(envs)
[08:27:54.891]                 common <- intersect(names, old_names)
[08:27:54.891]                 added <- setdiff(names, old_names)
[08:27:54.891]                 removed <- setdiff(old_names, names)
[08:27:54.891]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.891]                   envs[common]]
[08:27:54.891]                 NAMES <- toupper(changed)
[08:27:54.891]                 args <- list()
[08:27:54.891]                 for (kk in seq_along(NAMES)) {
[08:27:54.891]                   name <- changed[[kk]]
[08:27:54.891]                   NAME <- NAMES[[kk]]
[08:27:54.891]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.891]                     next
[08:27:54.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.891]                 }
[08:27:54.891]                 NAMES <- toupper(added)
[08:27:54.891]                 for (kk in seq_along(NAMES)) {
[08:27:54.891]                   name <- added[[kk]]
[08:27:54.891]                   NAME <- NAMES[[kk]]
[08:27:54.891]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.891]                     next
[08:27:54.891]                   args[[name]] <- ""
[08:27:54.891]                 }
[08:27:54.891]                 NAMES <- toupper(removed)
[08:27:54.891]                 for (kk in seq_along(NAMES)) {
[08:27:54.891]                   name <- removed[[kk]]
[08:27:54.891]                   NAME <- NAMES[[kk]]
[08:27:54.891]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.891]                     next
[08:27:54.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.891]                 }
[08:27:54.891]                 if (length(args) > 0) 
[08:27:54.891]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.891]             }
[08:27:54.891]             else {
[08:27:54.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.891]             }
[08:27:54.891]             {
[08:27:54.891]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.891]                   0L) {
[08:27:54.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.891]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.891]                   base::options(opts)
[08:27:54.891]                 }
[08:27:54.891]                 {
[08:27:54.891]                   {
[08:27:54.891]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.891]                     NULL
[08:27:54.891]                   }
[08:27:54.891]                   options(future.plan = NULL)
[08:27:54.891]                   if (is.na(NA_character_)) 
[08:27:54.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.891]                     .init = FALSE)
[08:27:54.891]                 }
[08:27:54.891]             }
[08:27:54.891]         }
[08:27:54.891]     })
[08:27:54.891]     if (TRUE) {
[08:27:54.891]         base::sink(type = "output", split = FALSE)
[08:27:54.891]         if (TRUE) {
[08:27:54.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.891]         }
[08:27:54.891]         else {
[08:27:54.891]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.891]         }
[08:27:54.891]         base::close(...future.stdout)
[08:27:54.891]         ...future.stdout <- NULL
[08:27:54.891]     }
[08:27:54.891]     ...future.result$conditions <- ...future.conditions
[08:27:54.891]     ...future.result$finished <- base::Sys.time()
[08:27:54.891]     ...future.result
[08:27:54.891] }
[08:27:54.895] MultisessionFuture started
[08:27:54.895] - Launch lazy future ... done
[08:27:54.895] run() for ‘MultisessionFuture’ ... done
[08:27:54.895] getGlobalsAndPackages() ...
[08:27:54.895] Searching for globals...
[08:27:54.896] 
[08:27:54.896] Searching for globals ... DONE
[08:27:54.896] - globals: [0] <none>
[08:27:54.896] getGlobalsAndPackages() ... DONE
[08:27:54.896] run() for ‘Future’ ...
[08:27:54.896] - state: ‘created’
[08:27:54.897] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.913] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.913] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:54.913]   - Field: ‘node’
[08:27:54.913]   - Field: ‘label’
[08:27:54.913]   - Field: ‘local’
[08:27:54.913]   - Field: ‘owner’
[08:27:54.913]   - Field: ‘envir’
[08:27:54.913]   - Field: ‘workers’
[08:27:54.914]   - Field: ‘packages’
[08:27:54.914]   - Field: ‘gc’
[08:27:54.914]   - Field: ‘conditions’
[08:27:54.914]   - Field: ‘persistent’
[08:27:54.914]   - Field: ‘expr’
[08:27:54.914]   - Field: ‘uuid’
[08:27:54.914]   - Field: ‘seed’
[08:27:54.914]   - Field: ‘version’
[08:27:54.914]   - Field: ‘result’
[08:27:54.914]   - Field: ‘asynchronous’
[08:27:54.915]   - Field: ‘calls’
[08:27:54.915]   - Field: ‘globals’
[08:27:54.915]   - Field: ‘stdout’
[08:27:54.915]   - Field: ‘earlySignal’
[08:27:54.915]   - Field: ‘lazy’
[08:27:54.915]   - Field: ‘state’
[08:27:54.915] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:54.915] - Launch lazy future ...
[08:27:54.916] Packages needed by the future expression (n = 0): <none>
[08:27:54.916] Packages needed by future strategies (n = 0): <none>
[08:27:54.916] {
[08:27:54.916]     {
[08:27:54.916]         {
[08:27:54.916]             ...future.startTime <- base::Sys.time()
[08:27:54.916]             {
[08:27:54.916]                 {
[08:27:54.916]                   {
[08:27:54.916]                     {
[08:27:54.916]                       base::local({
[08:27:54.916]                         has_future <- base::requireNamespace("future", 
[08:27:54.916]                           quietly = TRUE)
[08:27:54.916]                         if (has_future) {
[08:27:54.916]                           ns <- base::getNamespace("future")
[08:27:54.916]                           version <- ns[[".package"]][["version"]]
[08:27:54.916]                           if (is.null(version)) 
[08:27:54.916]                             version <- utils::packageVersion("future")
[08:27:54.916]                         }
[08:27:54.916]                         else {
[08:27:54.916]                           version <- NULL
[08:27:54.916]                         }
[08:27:54.916]                         if (!has_future || version < "1.8.0") {
[08:27:54.916]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.916]                             "", base::R.version$version.string), 
[08:27:54.916]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.916]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.916]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.916]                               "release", "version")], collapse = " "), 
[08:27:54.916]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.916]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.916]                             info)
[08:27:54.916]                           info <- base::paste(info, collapse = "; ")
[08:27:54.916]                           if (!has_future) {
[08:27:54.916]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.916]                               info)
[08:27:54.916]                           }
[08:27:54.916]                           else {
[08:27:54.916]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.916]                               info, version)
[08:27:54.916]                           }
[08:27:54.916]                           base::stop(msg)
[08:27:54.916]                         }
[08:27:54.916]                       })
[08:27:54.916]                     }
[08:27:54.916]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.916]                     base::options(mc.cores = 1L)
[08:27:54.916]                   }
[08:27:54.916]                   ...future.strategy.old <- future::plan("list")
[08:27:54.916]                   options(future.plan = NULL)
[08:27:54.916]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.916]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.916]                 }
[08:27:54.916]                 ...future.workdir <- getwd()
[08:27:54.916]             }
[08:27:54.916]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.916]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.916]         }
[08:27:54.916]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.916]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.916]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.916]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.916]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.916]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.916]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.916]             base::names(...future.oldOptions))
[08:27:54.916]     }
[08:27:54.916]     if (FALSE) {
[08:27:54.916]     }
[08:27:54.916]     else {
[08:27:54.916]         if (TRUE) {
[08:27:54.916]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.916]                 open = "w")
[08:27:54.916]         }
[08:27:54.916]         else {
[08:27:54.916]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.916]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.916]         }
[08:27:54.916]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.916]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.916]             base::sink(type = "output", split = FALSE)
[08:27:54.916]             base::close(...future.stdout)
[08:27:54.916]         }, add = TRUE)
[08:27:54.916]     }
[08:27:54.916]     ...future.frame <- base::sys.nframe()
[08:27:54.916]     ...future.conditions <- base::list()
[08:27:54.916]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.916]     if (FALSE) {
[08:27:54.916]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.916]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.916]     }
[08:27:54.916]     ...future.result <- base::tryCatch({
[08:27:54.916]         base::withCallingHandlers({
[08:27:54.916]             ...future.value <- base::withVisible(base::local({
[08:27:54.916]                 ...future.makeSendCondition <- base::local({
[08:27:54.916]                   sendCondition <- NULL
[08:27:54.916]                   function(frame = 1L) {
[08:27:54.916]                     if (is.function(sendCondition)) 
[08:27:54.916]                       return(sendCondition)
[08:27:54.916]                     ns <- getNamespace("parallel")
[08:27:54.916]                     if (exists("sendData", mode = "function", 
[08:27:54.916]                       envir = ns)) {
[08:27:54.916]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:54.916]                         envir = ns)
[08:27:54.916]                       envir <- sys.frame(frame)
[08:27:54.916]                       master <- NULL
[08:27:54.916]                       while (!identical(envir, .GlobalEnv) && 
[08:27:54.916]                         !identical(envir, emptyenv())) {
[08:27:54.916]                         if (exists("master", mode = "list", envir = envir, 
[08:27:54.916]                           inherits = FALSE)) {
[08:27:54.916]                           master <- get("master", mode = "list", 
[08:27:54.916]                             envir = envir, inherits = FALSE)
[08:27:54.916]                           if (inherits(master, c("SOCKnode", 
[08:27:54.916]                             "SOCK0node"))) {
[08:27:54.916]                             sendCondition <<- function(cond) {
[08:27:54.916]                               data <- list(type = "VALUE", value = cond, 
[08:27:54.916]                                 success = TRUE)
[08:27:54.916]                               parallel_sendData(master, data)
[08:27:54.916]                             }
[08:27:54.916]                             return(sendCondition)
[08:27:54.916]                           }
[08:27:54.916]                         }
[08:27:54.916]                         frame <- frame + 1L
[08:27:54.916]                         envir <- sys.frame(frame)
[08:27:54.916]                       }
[08:27:54.916]                     }
[08:27:54.916]                     sendCondition <<- function(cond) NULL
[08:27:54.916]                   }
[08:27:54.916]                 })
[08:27:54.916]                 withCallingHandlers({
[08:27:54.916]                   NULL
[08:27:54.916]                 }, immediateCondition = function(cond) {
[08:27:54.916]                   sendCondition <- ...future.makeSendCondition()
[08:27:54.916]                   sendCondition(cond)
[08:27:54.916]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.916]                   {
[08:27:54.916]                     inherits <- base::inherits
[08:27:54.916]                     invokeRestart <- base::invokeRestart
[08:27:54.916]                     is.null <- base::is.null
[08:27:54.916]                     muffled <- FALSE
[08:27:54.916]                     if (inherits(cond, "message")) {
[08:27:54.916]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.916]                       if (muffled) 
[08:27:54.916]                         invokeRestart("muffleMessage")
[08:27:54.916]                     }
[08:27:54.916]                     else if (inherits(cond, "warning")) {
[08:27:54.916]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.916]                       if (muffled) 
[08:27:54.916]                         invokeRestart("muffleWarning")
[08:27:54.916]                     }
[08:27:54.916]                     else if (inherits(cond, "condition")) {
[08:27:54.916]                       if (!is.null(pattern)) {
[08:27:54.916]                         computeRestarts <- base::computeRestarts
[08:27:54.916]                         grepl <- base::grepl
[08:27:54.916]                         restarts <- computeRestarts(cond)
[08:27:54.916]                         for (restart in restarts) {
[08:27:54.916]                           name <- restart$name
[08:27:54.916]                           if (is.null(name)) 
[08:27:54.916]                             next
[08:27:54.916]                           if (!grepl(pattern, name)) 
[08:27:54.916]                             next
[08:27:54.916]                           invokeRestart(restart)
[08:27:54.916]                           muffled <- TRUE
[08:27:54.916]                           break
[08:27:54.916]                         }
[08:27:54.916]                       }
[08:27:54.916]                     }
[08:27:54.916]                     invisible(muffled)
[08:27:54.916]                   }
[08:27:54.916]                   muffleCondition(cond)
[08:27:54.916]                 })
[08:27:54.916]             }))
[08:27:54.916]             future::FutureResult(value = ...future.value$value, 
[08:27:54.916]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.916]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.916]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.916]                     ...future.globalenv.names))
[08:27:54.916]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.916]         }, condition = base::local({
[08:27:54.916]             c <- base::c
[08:27:54.916]             inherits <- base::inherits
[08:27:54.916]             invokeRestart <- base::invokeRestart
[08:27:54.916]             length <- base::length
[08:27:54.916]             list <- base::list
[08:27:54.916]             seq.int <- base::seq.int
[08:27:54.916]             signalCondition <- base::signalCondition
[08:27:54.916]             sys.calls <- base::sys.calls
[08:27:54.916]             `[[` <- base::`[[`
[08:27:54.916]             `+` <- base::`+`
[08:27:54.916]             `<<-` <- base::`<<-`
[08:27:54.916]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.916]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.916]                   3L)]
[08:27:54.916]             }
[08:27:54.916]             function(cond) {
[08:27:54.916]                 is_error <- inherits(cond, "error")
[08:27:54.916]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.916]                   NULL)
[08:27:54.916]                 if (is_error) {
[08:27:54.916]                   sessionInformation <- function() {
[08:27:54.916]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.916]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.916]                       search = base::search(), system = base::Sys.info())
[08:27:54.916]                   }
[08:27:54.916]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.916]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.916]                     cond$call), session = sessionInformation(), 
[08:27:54.916]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.916]                   signalCondition(cond)
[08:27:54.916]                 }
[08:27:54.916]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.916]                 "immediateCondition"))) {
[08:27:54.916]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.916]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.916]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.916]                   if (TRUE && !signal) {
[08:27:54.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.916]                     {
[08:27:54.916]                       inherits <- base::inherits
[08:27:54.916]                       invokeRestart <- base::invokeRestart
[08:27:54.916]                       is.null <- base::is.null
[08:27:54.916]                       muffled <- FALSE
[08:27:54.916]                       if (inherits(cond, "message")) {
[08:27:54.916]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.916]                         if (muffled) 
[08:27:54.916]                           invokeRestart("muffleMessage")
[08:27:54.916]                       }
[08:27:54.916]                       else if (inherits(cond, "warning")) {
[08:27:54.916]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.916]                         if (muffled) 
[08:27:54.916]                           invokeRestart("muffleWarning")
[08:27:54.916]                       }
[08:27:54.916]                       else if (inherits(cond, "condition")) {
[08:27:54.916]                         if (!is.null(pattern)) {
[08:27:54.916]                           computeRestarts <- base::computeRestarts
[08:27:54.916]                           grepl <- base::grepl
[08:27:54.916]                           restarts <- computeRestarts(cond)
[08:27:54.916]                           for (restart in restarts) {
[08:27:54.916]                             name <- restart$name
[08:27:54.916]                             if (is.null(name)) 
[08:27:54.916]                               next
[08:27:54.916]                             if (!grepl(pattern, name)) 
[08:27:54.916]                               next
[08:27:54.916]                             invokeRestart(restart)
[08:27:54.916]                             muffled <- TRUE
[08:27:54.916]                             break
[08:27:54.916]                           }
[08:27:54.916]                         }
[08:27:54.916]                       }
[08:27:54.916]                       invisible(muffled)
[08:27:54.916]                     }
[08:27:54.916]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.916]                   }
[08:27:54.916]                 }
[08:27:54.916]                 else {
[08:27:54.916]                   if (TRUE) {
[08:27:54.916]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.916]                     {
[08:27:54.916]                       inherits <- base::inherits
[08:27:54.916]                       invokeRestart <- base::invokeRestart
[08:27:54.916]                       is.null <- base::is.null
[08:27:54.916]                       muffled <- FALSE
[08:27:54.916]                       if (inherits(cond, "message")) {
[08:27:54.916]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.916]                         if (muffled) 
[08:27:54.916]                           invokeRestart("muffleMessage")
[08:27:54.916]                       }
[08:27:54.916]                       else if (inherits(cond, "warning")) {
[08:27:54.916]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.916]                         if (muffled) 
[08:27:54.916]                           invokeRestart("muffleWarning")
[08:27:54.916]                       }
[08:27:54.916]                       else if (inherits(cond, "condition")) {
[08:27:54.916]                         if (!is.null(pattern)) {
[08:27:54.916]                           computeRestarts <- base::computeRestarts
[08:27:54.916]                           grepl <- base::grepl
[08:27:54.916]                           restarts <- computeRestarts(cond)
[08:27:54.916]                           for (restart in restarts) {
[08:27:54.916]                             name <- restart$name
[08:27:54.916]                             if (is.null(name)) 
[08:27:54.916]                               next
[08:27:54.916]                             if (!grepl(pattern, name)) 
[08:27:54.916]                               next
[08:27:54.916]                             invokeRestart(restart)
[08:27:54.916]                             muffled <- TRUE
[08:27:54.916]                             break
[08:27:54.916]                           }
[08:27:54.916]                         }
[08:27:54.916]                       }
[08:27:54.916]                       invisible(muffled)
[08:27:54.916]                     }
[08:27:54.916]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.916]                   }
[08:27:54.916]                 }
[08:27:54.916]             }
[08:27:54.916]         }))
[08:27:54.916]     }, error = function(ex) {
[08:27:54.916]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.916]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.916]                 ...future.rng), started = ...future.startTime, 
[08:27:54.916]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.916]             version = "1.8"), class = "FutureResult")
[08:27:54.916]     }, finally = {
[08:27:54.916]         if (!identical(...future.workdir, getwd())) 
[08:27:54.916]             setwd(...future.workdir)
[08:27:54.916]         {
[08:27:54.916]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.916]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.916]             }
[08:27:54.916]             base::options(...future.oldOptions)
[08:27:54.916]             if (.Platform$OS.type == "windows") {
[08:27:54.916]                 old_names <- names(...future.oldEnvVars)
[08:27:54.916]                 envs <- base::Sys.getenv()
[08:27:54.916]                 names <- names(envs)
[08:27:54.916]                 common <- intersect(names, old_names)
[08:27:54.916]                 added <- setdiff(names, old_names)
[08:27:54.916]                 removed <- setdiff(old_names, names)
[08:27:54.916]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.916]                   envs[common]]
[08:27:54.916]                 NAMES <- toupper(changed)
[08:27:54.916]                 args <- list()
[08:27:54.916]                 for (kk in seq_along(NAMES)) {
[08:27:54.916]                   name <- changed[[kk]]
[08:27:54.916]                   NAME <- NAMES[[kk]]
[08:27:54.916]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.916]                     next
[08:27:54.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.916]                 }
[08:27:54.916]                 NAMES <- toupper(added)
[08:27:54.916]                 for (kk in seq_along(NAMES)) {
[08:27:54.916]                   name <- added[[kk]]
[08:27:54.916]                   NAME <- NAMES[[kk]]
[08:27:54.916]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.916]                     next
[08:27:54.916]                   args[[name]] <- ""
[08:27:54.916]                 }
[08:27:54.916]                 NAMES <- toupper(removed)
[08:27:54.916]                 for (kk in seq_along(NAMES)) {
[08:27:54.916]                   name <- removed[[kk]]
[08:27:54.916]                   NAME <- NAMES[[kk]]
[08:27:54.916]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.916]                     next
[08:27:54.916]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.916]                 }
[08:27:54.916]                 if (length(args) > 0) 
[08:27:54.916]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.916]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.916]             }
[08:27:54.916]             else {
[08:27:54.916]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.916]             }
[08:27:54.916]             {
[08:27:54.916]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.916]                   0L) {
[08:27:54.916]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.916]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.916]                   base::options(opts)
[08:27:54.916]                 }
[08:27:54.916]                 {
[08:27:54.916]                   {
[08:27:54.916]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.916]                     NULL
[08:27:54.916]                   }
[08:27:54.916]                   options(future.plan = NULL)
[08:27:54.916]                   if (is.na(NA_character_)) 
[08:27:54.916]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.916]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.916]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.916]                     .init = FALSE)
[08:27:54.916]                 }
[08:27:54.916]             }
[08:27:54.916]         }
[08:27:54.916]     })
[08:27:54.916]     if (TRUE) {
[08:27:54.916]         base::sink(type = "output", split = FALSE)
[08:27:54.916]         if (TRUE) {
[08:27:54.916]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.916]         }
[08:27:54.916]         else {
[08:27:54.916]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.916]         }
[08:27:54.916]         base::close(...future.stdout)
[08:27:54.916]         ...future.stdout <- NULL
[08:27:54.916]     }
[08:27:54.916]     ...future.result$conditions <- ...future.conditions
[08:27:54.916]     ...future.result$finished <- base::Sys.time()
[08:27:54.916]     ...future.result
[08:27:54.916] }
[08:27:54.971] MultisessionFuture started
[08:27:54.971] - Launch lazy future ... done
[08:27:54.971] run() for ‘MultisessionFuture’ ... done
[08:27:54.971] getGlobalsAndPackages() ...
[08:27:54.972] Searching for globals...
[08:27:54.972] - globals found: [1] ‘{’
[08:27:54.973] Searching for globals ... DONE
[08:27:54.973] Resolving globals: FALSE
[08:27:54.973] 
[08:27:54.973] 
[08:27:54.973] getGlobalsAndPackages() ... DONE
[08:27:54.973] run() for ‘Future’ ...
[08:27:54.974] - state: ‘created’
[08:27:54.974] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:54.988] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:54.988] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:54.988]   - Field: ‘node’
[08:27:54.989]   - Field: ‘label’
[08:27:54.989]   - Field: ‘local’
[08:27:54.989]   - Field: ‘owner’
[08:27:54.989]   - Field: ‘envir’
[08:27:54.989]   - Field: ‘workers’
[08:27:54.989]   - Field: ‘packages’
[08:27:54.989]   - Field: ‘gc’
[08:27:54.989]   - Field: ‘conditions’
[08:27:54.989]   - Field: ‘persistent’
[08:27:54.989]   - Field: ‘expr’
[08:27:54.990]   - Field: ‘uuid’
[08:27:54.990]   - Field: ‘seed’
[08:27:54.990]   - Field: ‘version’
[08:27:54.990]   - Field: ‘result’
[08:27:54.990]   - Field: ‘asynchronous’
[08:27:54.990]   - Field: ‘calls’
[08:27:54.990]   - Field: ‘globals’
[08:27:54.990]   - Field: ‘stdout’
[08:27:54.990]   - Field: ‘earlySignal’
[08:27:54.990]   - Field: ‘lazy’
[08:27:54.990]   - Field: ‘state’
[08:27:54.991] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:54.991] - Launch lazy future ...
[08:27:54.991] Packages needed by the future expression (n = 0): <none>
[08:27:54.991] Packages needed by future strategies (n = 0): <none>
[08:27:54.992] {
[08:27:54.992]     {
[08:27:54.992]         {
[08:27:54.992]             ...future.startTime <- base::Sys.time()
[08:27:54.992]             {
[08:27:54.992]                 {
[08:27:54.992]                   {
[08:27:54.992]                     {
[08:27:54.992]                       base::local({
[08:27:54.992]                         has_future <- base::requireNamespace("future", 
[08:27:54.992]                           quietly = TRUE)
[08:27:54.992]                         if (has_future) {
[08:27:54.992]                           ns <- base::getNamespace("future")
[08:27:54.992]                           version <- ns[[".package"]][["version"]]
[08:27:54.992]                           if (is.null(version)) 
[08:27:54.992]                             version <- utils::packageVersion("future")
[08:27:54.992]                         }
[08:27:54.992]                         else {
[08:27:54.992]                           version <- NULL
[08:27:54.992]                         }
[08:27:54.992]                         if (!has_future || version < "1.8.0") {
[08:27:54.992]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:54.992]                             "", base::R.version$version.string), 
[08:27:54.992]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:54.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:54.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:54.992]                               "release", "version")], collapse = " "), 
[08:27:54.992]                             hostname = base::Sys.info()[["nodename"]])
[08:27:54.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:54.992]                             info)
[08:27:54.992]                           info <- base::paste(info, collapse = "; ")
[08:27:54.992]                           if (!has_future) {
[08:27:54.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:54.992]                               info)
[08:27:54.992]                           }
[08:27:54.992]                           else {
[08:27:54.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:54.992]                               info, version)
[08:27:54.992]                           }
[08:27:54.992]                           base::stop(msg)
[08:27:54.992]                         }
[08:27:54.992]                       })
[08:27:54.992]                     }
[08:27:54.992]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:54.992]                     base::options(mc.cores = 1L)
[08:27:54.992]                   }
[08:27:54.992]                   ...future.strategy.old <- future::plan("list")
[08:27:54.992]                   options(future.plan = NULL)
[08:27:54.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:54.992]                 }
[08:27:54.992]                 ...future.workdir <- getwd()
[08:27:54.992]             }
[08:27:54.992]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:54.992]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:54.992]         }
[08:27:54.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:54.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:54.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:54.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:54.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:54.992]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:54.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:54.992]             base::names(...future.oldOptions))
[08:27:54.992]     }
[08:27:54.992]     if (FALSE) {
[08:27:54.992]     }
[08:27:54.992]     else {
[08:27:54.992]         if (TRUE) {
[08:27:54.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:54.992]                 open = "w")
[08:27:54.992]         }
[08:27:54.992]         else {
[08:27:54.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:54.992]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:54.992]         }
[08:27:54.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:54.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:54.992]             base::sink(type = "output", split = FALSE)
[08:27:54.992]             base::close(...future.stdout)
[08:27:54.992]         }, add = TRUE)
[08:27:54.992]     }
[08:27:54.992]     ...future.frame <- base::sys.nframe()
[08:27:54.992]     ...future.conditions <- base::list()
[08:27:54.992]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:54.992]     if (FALSE) {
[08:27:54.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:54.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:54.992]     }
[08:27:54.992]     ...future.result <- base::tryCatch({
[08:27:54.992]         base::withCallingHandlers({
[08:27:54.992]             ...future.value <- base::withVisible(base::local({
[08:27:54.992]                 ...future.makeSendCondition <- base::local({
[08:27:54.992]                   sendCondition <- NULL
[08:27:54.992]                   function(frame = 1L) {
[08:27:54.992]                     if (is.function(sendCondition)) 
[08:27:54.992]                       return(sendCondition)
[08:27:54.992]                     ns <- getNamespace("parallel")
[08:27:54.992]                     if (exists("sendData", mode = "function", 
[08:27:54.992]                       envir = ns)) {
[08:27:54.992]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:54.992]                         envir = ns)
[08:27:54.992]                       envir <- sys.frame(frame)
[08:27:54.992]                       master <- NULL
[08:27:54.992]                       while (!identical(envir, .GlobalEnv) && 
[08:27:54.992]                         !identical(envir, emptyenv())) {
[08:27:54.992]                         if (exists("master", mode = "list", envir = envir, 
[08:27:54.992]                           inherits = FALSE)) {
[08:27:54.992]                           master <- get("master", mode = "list", 
[08:27:54.992]                             envir = envir, inherits = FALSE)
[08:27:54.992]                           if (inherits(master, c("SOCKnode", 
[08:27:54.992]                             "SOCK0node"))) {
[08:27:54.992]                             sendCondition <<- function(cond) {
[08:27:54.992]                               data <- list(type = "VALUE", value = cond, 
[08:27:54.992]                                 success = TRUE)
[08:27:54.992]                               parallel_sendData(master, data)
[08:27:54.992]                             }
[08:27:54.992]                             return(sendCondition)
[08:27:54.992]                           }
[08:27:54.992]                         }
[08:27:54.992]                         frame <- frame + 1L
[08:27:54.992]                         envir <- sys.frame(frame)
[08:27:54.992]                       }
[08:27:54.992]                     }
[08:27:54.992]                     sendCondition <<- function(cond) NULL
[08:27:54.992]                   }
[08:27:54.992]                 })
[08:27:54.992]                 withCallingHandlers({
[08:27:54.992]                   {
[08:27:54.992]                     4
[08:27:54.992]                   }
[08:27:54.992]                 }, immediateCondition = function(cond) {
[08:27:54.992]                   sendCondition <- ...future.makeSendCondition()
[08:27:54.992]                   sendCondition(cond)
[08:27:54.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.992]                   {
[08:27:54.992]                     inherits <- base::inherits
[08:27:54.992]                     invokeRestart <- base::invokeRestart
[08:27:54.992]                     is.null <- base::is.null
[08:27:54.992]                     muffled <- FALSE
[08:27:54.992]                     if (inherits(cond, "message")) {
[08:27:54.992]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:54.992]                       if (muffled) 
[08:27:54.992]                         invokeRestart("muffleMessage")
[08:27:54.992]                     }
[08:27:54.992]                     else if (inherits(cond, "warning")) {
[08:27:54.992]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:54.992]                       if (muffled) 
[08:27:54.992]                         invokeRestart("muffleWarning")
[08:27:54.992]                     }
[08:27:54.992]                     else if (inherits(cond, "condition")) {
[08:27:54.992]                       if (!is.null(pattern)) {
[08:27:54.992]                         computeRestarts <- base::computeRestarts
[08:27:54.992]                         grepl <- base::grepl
[08:27:54.992]                         restarts <- computeRestarts(cond)
[08:27:54.992]                         for (restart in restarts) {
[08:27:54.992]                           name <- restart$name
[08:27:54.992]                           if (is.null(name)) 
[08:27:54.992]                             next
[08:27:54.992]                           if (!grepl(pattern, name)) 
[08:27:54.992]                             next
[08:27:54.992]                           invokeRestart(restart)
[08:27:54.992]                           muffled <- TRUE
[08:27:54.992]                           break
[08:27:54.992]                         }
[08:27:54.992]                       }
[08:27:54.992]                     }
[08:27:54.992]                     invisible(muffled)
[08:27:54.992]                   }
[08:27:54.992]                   muffleCondition(cond)
[08:27:54.992]                 })
[08:27:54.992]             }))
[08:27:54.992]             future::FutureResult(value = ...future.value$value, 
[08:27:54.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.992]                   ...future.rng), globalenv = if (FALSE) 
[08:27:54.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:54.992]                     ...future.globalenv.names))
[08:27:54.992]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:54.992]         }, condition = base::local({
[08:27:54.992]             c <- base::c
[08:27:54.992]             inherits <- base::inherits
[08:27:54.992]             invokeRestart <- base::invokeRestart
[08:27:54.992]             length <- base::length
[08:27:54.992]             list <- base::list
[08:27:54.992]             seq.int <- base::seq.int
[08:27:54.992]             signalCondition <- base::signalCondition
[08:27:54.992]             sys.calls <- base::sys.calls
[08:27:54.992]             `[[` <- base::`[[`
[08:27:54.992]             `+` <- base::`+`
[08:27:54.992]             `<<-` <- base::`<<-`
[08:27:54.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:54.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:54.992]                   3L)]
[08:27:54.992]             }
[08:27:54.992]             function(cond) {
[08:27:54.992]                 is_error <- inherits(cond, "error")
[08:27:54.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:54.992]                   NULL)
[08:27:54.992]                 if (is_error) {
[08:27:54.992]                   sessionInformation <- function() {
[08:27:54.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:54.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:54.992]                       search = base::search(), system = base::Sys.info())
[08:27:54.992]                   }
[08:27:54.992]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:54.992]                     cond$call), session = sessionInformation(), 
[08:27:54.992]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:54.992]                   signalCondition(cond)
[08:27:54.992]                 }
[08:27:54.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:54.992]                 "immediateCondition"))) {
[08:27:54.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:54.992]                   ...future.conditions[[length(...future.conditions) + 
[08:27:54.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:54.992]                   if (TRUE && !signal) {
[08:27:54.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.992]                     {
[08:27:54.992]                       inherits <- base::inherits
[08:27:54.992]                       invokeRestart <- base::invokeRestart
[08:27:54.992]                       is.null <- base::is.null
[08:27:54.992]                       muffled <- FALSE
[08:27:54.992]                       if (inherits(cond, "message")) {
[08:27:54.992]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.992]                         if (muffled) 
[08:27:54.992]                           invokeRestart("muffleMessage")
[08:27:54.992]                       }
[08:27:54.992]                       else if (inherits(cond, "warning")) {
[08:27:54.992]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.992]                         if (muffled) 
[08:27:54.992]                           invokeRestart("muffleWarning")
[08:27:54.992]                       }
[08:27:54.992]                       else if (inherits(cond, "condition")) {
[08:27:54.992]                         if (!is.null(pattern)) {
[08:27:54.992]                           computeRestarts <- base::computeRestarts
[08:27:54.992]                           grepl <- base::grepl
[08:27:54.992]                           restarts <- computeRestarts(cond)
[08:27:54.992]                           for (restart in restarts) {
[08:27:54.992]                             name <- restart$name
[08:27:54.992]                             if (is.null(name)) 
[08:27:54.992]                               next
[08:27:54.992]                             if (!grepl(pattern, name)) 
[08:27:54.992]                               next
[08:27:54.992]                             invokeRestart(restart)
[08:27:54.992]                             muffled <- TRUE
[08:27:54.992]                             break
[08:27:54.992]                           }
[08:27:54.992]                         }
[08:27:54.992]                       }
[08:27:54.992]                       invisible(muffled)
[08:27:54.992]                     }
[08:27:54.992]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.992]                   }
[08:27:54.992]                 }
[08:27:54.992]                 else {
[08:27:54.992]                   if (TRUE) {
[08:27:54.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:54.992]                     {
[08:27:54.992]                       inherits <- base::inherits
[08:27:54.992]                       invokeRestart <- base::invokeRestart
[08:27:54.992]                       is.null <- base::is.null
[08:27:54.992]                       muffled <- FALSE
[08:27:54.992]                       if (inherits(cond, "message")) {
[08:27:54.992]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:54.992]                         if (muffled) 
[08:27:54.992]                           invokeRestart("muffleMessage")
[08:27:54.992]                       }
[08:27:54.992]                       else if (inherits(cond, "warning")) {
[08:27:54.992]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:54.992]                         if (muffled) 
[08:27:54.992]                           invokeRestart("muffleWarning")
[08:27:54.992]                       }
[08:27:54.992]                       else if (inherits(cond, "condition")) {
[08:27:54.992]                         if (!is.null(pattern)) {
[08:27:54.992]                           computeRestarts <- base::computeRestarts
[08:27:54.992]                           grepl <- base::grepl
[08:27:54.992]                           restarts <- computeRestarts(cond)
[08:27:54.992]                           for (restart in restarts) {
[08:27:54.992]                             name <- restart$name
[08:27:54.992]                             if (is.null(name)) 
[08:27:54.992]                               next
[08:27:54.992]                             if (!grepl(pattern, name)) 
[08:27:54.992]                               next
[08:27:54.992]                             invokeRestart(restart)
[08:27:54.992]                             muffled <- TRUE
[08:27:54.992]                             break
[08:27:54.992]                           }
[08:27:54.992]                         }
[08:27:54.992]                       }
[08:27:54.992]                       invisible(muffled)
[08:27:54.992]                     }
[08:27:54.992]                     muffleCondition(cond, pattern = "^muffle")
[08:27:54.992]                   }
[08:27:54.992]                 }
[08:27:54.992]             }
[08:27:54.992]         }))
[08:27:54.992]     }, error = function(ex) {
[08:27:54.992]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:54.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:54.992]                 ...future.rng), started = ...future.startTime, 
[08:27:54.992]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:54.992]             version = "1.8"), class = "FutureResult")
[08:27:54.992]     }, finally = {
[08:27:54.992]         if (!identical(...future.workdir, getwd())) 
[08:27:54.992]             setwd(...future.workdir)
[08:27:54.992]         {
[08:27:54.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:54.992]                 ...future.oldOptions$nwarnings <- NULL
[08:27:54.992]             }
[08:27:54.992]             base::options(...future.oldOptions)
[08:27:54.992]             if (.Platform$OS.type == "windows") {
[08:27:54.992]                 old_names <- names(...future.oldEnvVars)
[08:27:54.992]                 envs <- base::Sys.getenv()
[08:27:54.992]                 names <- names(envs)
[08:27:54.992]                 common <- intersect(names, old_names)
[08:27:54.992]                 added <- setdiff(names, old_names)
[08:27:54.992]                 removed <- setdiff(old_names, names)
[08:27:54.992]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:54.992]                   envs[common]]
[08:27:54.992]                 NAMES <- toupper(changed)
[08:27:54.992]                 args <- list()
[08:27:54.992]                 for (kk in seq_along(NAMES)) {
[08:27:54.992]                   name <- changed[[kk]]
[08:27:54.992]                   NAME <- NAMES[[kk]]
[08:27:54.992]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.992]                     next
[08:27:54.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.992]                 }
[08:27:54.992]                 NAMES <- toupper(added)
[08:27:54.992]                 for (kk in seq_along(NAMES)) {
[08:27:54.992]                   name <- added[[kk]]
[08:27:54.992]                   NAME <- NAMES[[kk]]
[08:27:54.992]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.992]                     next
[08:27:54.992]                   args[[name]] <- ""
[08:27:54.992]                 }
[08:27:54.992]                 NAMES <- toupper(removed)
[08:27:54.992]                 for (kk in seq_along(NAMES)) {
[08:27:54.992]                   name <- removed[[kk]]
[08:27:54.992]                   NAME <- NAMES[[kk]]
[08:27:54.992]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:54.992]                     next
[08:27:54.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:54.992]                 }
[08:27:54.992]                 if (length(args) > 0) 
[08:27:54.992]                   base::do.call(base::Sys.setenv, args = args)
[08:27:54.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:54.992]             }
[08:27:54.992]             else {
[08:27:54.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:54.992]             }
[08:27:54.992]             {
[08:27:54.992]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:54.992]                   0L) {
[08:27:54.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:54.992]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:54.992]                   base::options(opts)
[08:27:54.992]                 }
[08:27:54.992]                 {
[08:27:54.992]                   {
[08:27:54.992]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:54.992]                     NULL
[08:27:54.992]                   }
[08:27:54.992]                   options(future.plan = NULL)
[08:27:54.992]                   if (is.na(NA_character_)) 
[08:27:54.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:54.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:54.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:54.992]                     .init = FALSE)
[08:27:54.992]                 }
[08:27:54.992]             }
[08:27:54.992]         }
[08:27:54.992]     })
[08:27:54.992]     if (TRUE) {
[08:27:54.992]         base::sink(type = "output", split = FALSE)
[08:27:54.992]         if (TRUE) {
[08:27:54.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:54.992]         }
[08:27:54.992]         else {
[08:27:54.992]             ...future.result["stdout"] <- base::list(NULL)
[08:27:54.992]         }
[08:27:54.992]         base::close(...future.stdout)
[08:27:54.992]         ...future.stdout <- NULL
[08:27:54.992]     }
[08:27:54.992]     ...future.result$conditions <- ...future.conditions
[08:27:54.992]     ...future.result$finished <- base::Sys.time()
[08:27:54.992]     ...future.result
[08:27:54.992] }
[08:27:54.994] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:55.005] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.005] - Validating connection of MultisessionFuture
[08:27:55.005] - received message: FutureResult
[08:27:55.006] - Received FutureResult
[08:27:55.006] - Erased future from FutureRegistry
[08:27:55.006] result() for ClusterFuture ...
[08:27:55.006] - result already collected: FutureResult
[08:27:55.006] result() for ClusterFuture ... done
[08:27:55.006] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.006] result() for ClusterFuture ...
[08:27:55.006] - result already collected: FutureResult
[08:27:55.006] result() for ClusterFuture ... done
[08:27:55.006] result() for ClusterFuture ...
[08:27:55.007] - result already collected: FutureResult
[08:27:55.007] result() for ClusterFuture ... done
[08:27:55.008] MultisessionFuture started
[08:27:55.008] - Launch lazy future ... done
[08:27:55.008] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d860964098> 
Classes 'listenv', 'environment' <environment: 0x55d8624db360> 
[08:27:55.013] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.013] - Validating connection of MultisessionFuture
[08:27:55.013] - received message: FutureResult
[08:27:55.013] - Received FutureResult
[08:27:55.013] - Erased future from FutureRegistry
[08:27:55.013] result() for ClusterFuture ...
[08:27:55.013] - result already collected: FutureResult
[08:27:55.013] result() for ClusterFuture ... done
[08:27:55.014] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:55.026] resolve() on list environment ...
[08:27:55.026]  recursive: 0
[08:27:55.027]  length: 6
[08:27:55.027]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:55.027] signalConditionsASAP(numeric, pos=1) ...
[08:27:55.027] - nx: 6
[08:27:55.027] - relay: TRUE
[08:27:55.027] - stdout: TRUE
[08:27:55.027] - signal: TRUE
[08:27:55.027] - resignal: FALSE
[08:27:55.027] - force: TRUE
[08:27:55.028] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.028] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.028]  - until=2
[08:27:55.028]  - relaying element #2
[08:27:55.028] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.028] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.028] signalConditionsASAP(NULL, pos=1) ... done
[08:27:55.028]  length: 5 (resolved future 1)
[08:27:55.028] Future #2
[08:27:55.028] result() for ClusterFuture ...
[08:27:55.028] - result already collected: FutureResult
[08:27:55.029] result() for ClusterFuture ... done
[08:27:55.029] result() for ClusterFuture ...
[08:27:55.029] - result already collected: FutureResult
[08:27:55.029] result() for ClusterFuture ... done
[08:27:55.029] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:55.029] - nx: 6
[08:27:55.029] - relay: TRUE
[08:27:55.029] - stdout: TRUE
[08:27:55.029] - signal: TRUE
[08:27:55.029] - resignal: FALSE
[08:27:55.029] - force: TRUE
[08:27:55.029] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.029] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.030]  - until=2
[08:27:55.030]  - relaying element #2
[08:27:55.030] result() for ClusterFuture ...
[08:27:55.030] - result already collected: FutureResult
[08:27:55.030] result() for ClusterFuture ... done
[08:27:55.030] result() for ClusterFuture ...
[08:27:55.030] - result already collected: FutureResult
[08:27:55.030] result() for ClusterFuture ... done
[08:27:55.030] result() for ClusterFuture ...
[08:27:55.030] - result already collected: FutureResult
[08:27:55.030] result() for ClusterFuture ... done
[08:27:55.031] result() for ClusterFuture ...
[08:27:55.031] - result already collected: FutureResult
[08:27:55.031] result() for ClusterFuture ... done
[08:27:55.031] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.031] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.031] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:55.031]  length: 4 (resolved future 2)
[08:27:55.031] Future #3
[08:27:55.031] result() for ClusterFuture ...
[08:27:55.031] - result already collected: FutureResult
[08:27:55.031] result() for ClusterFuture ... done
[08:27:55.031] result() for ClusterFuture ...
[08:27:55.032] - result already collected: FutureResult
[08:27:55.032] result() for ClusterFuture ... done
[08:27:55.032] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:55.032] - nx: 6
[08:27:55.032] - relay: TRUE
[08:27:55.032] - stdout: TRUE
[08:27:55.032] - signal: TRUE
[08:27:55.032] - resignal: FALSE
[08:27:55.032] - force: TRUE
[08:27:55.032] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.032] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.032]  - until=3
[08:27:55.032]  - relaying element #3
[08:27:55.033] result() for ClusterFuture ...
[08:27:55.033] - result already collected: FutureResult
[08:27:55.033] result() for ClusterFuture ... done
[08:27:55.033] result() for ClusterFuture ...
[08:27:55.033] - result already collected: FutureResult
[08:27:55.033] result() for ClusterFuture ... done
[08:27:55.033] result() for ClusterFuture ...
[08:27:55.033] - result already collected: FutureResult
[08:27:55.033] result() for ClusterFuture ... done
[08:27:55.033] result() for ClusterFuture ...
[08:27:55.033] - result already collected: FutureResult
[08:27:55.033] result() for ClusterFuture ... done
[08:27:55.034] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.034] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.034] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:55.034]  length: 3 (resolved future 3)
[08:27:55.044] signalConditionsASAP(NULL, pos=5) ...
[08:27:55.045] - nx: 6
[08:27:55.045] - relay: TRUE
[08:27:55.045] - stdout: TRUE
[08:27:55.045] - signal: TRUE
[08:27:55.045] - resignal: FALSE
[08:27:55.045] - force: TRUE
[08:27:55.045] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.045]  - until=6
[08:27:55.045]  - relaying element #4
[08:27:55.045]  - relaying element #6
[08:27:55.045] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.045] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.046] signalConditionsASAP(NULL, pos=5) ... done
[08:27:55.046]  length: 2 (resolved future 5)
[08:27:55.046] signalConditionsASAP(numeric, pos=6) ...
[08:27:55.046] - nx: 6
[08:27:55.046] - relay: TRUE
[08:27:55.046] - stdout: TRUE
[08:27:55.046] - signal: TRUE
[08:27:55.046] - resignal: FALSE
[08:27:55.046] - force: TRUE
[08:27:55.046] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.046] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.046]  - until=6
[08:27:55.047]  - relaying element #4
[08:27:55.047] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.047] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.047] signalConditionsASAP(NULL, pos=6) ... done
[08:27:55.047]  length: 1 (resolved future 6)
[08:27:55.058] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.058] - Validating connection of MultisessionFuture
[08:27:55.058] - received message: FutureResult
[08:27:55.058] - Received FutureResult
[08:27:55.058] - Erased future from FutureRegistry
[08:27:55.058] result() for ClusterFuture ...
[08:27:55.059] - result already collected: FutureResult
[08:27:55.059] result() for ClusterFuture ... done
[08:27:55.059] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.059] Future #4
[08:27:55.059] result() for ClusterFuture ...
[08:27:55.059] - result already collected: FutureResult
[08:27:55.059] result() for ClusterFuture ... done
[08:27:55.059] result() for ClusterFuture ...
[08:27:55.059] - result already collected: FutureResult
[08:27:55.059] result() for ClusterFuture ... done
[08:27:55.059] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:55.059] - nx: 6
[08:27:55.060] - relay: TRUE
[08:27:55.060] - stdout: TRUE
[08:27:55.060] - signal: TRUE
[08:27:55.060] - resignal: FALSE
[08:27:55.060] - force: TRUE
[08:27:55.060] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.060] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.060]  - until=6
[08:27:55.060]  - relaying element #4
[08:27:55.060] result() for ClusterFuture ...
[08:27:55.060] - result already collected: FutureResult
[08:27:55.060] result() for ClusterFuture ... done
[08:27:55.061] result() for ClusterFuture ...
[08:27:55.061] - result already collected: FutureResult
[08:27:55.061] result() for ClusterFuture ... done
[08:27:55.061] result() for ClusterFuture ...
[08:27:55.061] - result already collected: FutureResult
[08:27:55.061] result() for ClusterFuture ... done
[08:27:55.061] result() for ClusterFuture ...
[08:27:55.061] - result already collected: FutureResult
[08:27:55.061] result() for ClusterFuture ... done
[08:27:55.061] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.061] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.061] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:55.062]  length: 0 (resolved future 4)
[08:27:55.062] Relaying remaining futures
[08:27:55.062] signalConditionsASAP(NULL, pos=0) ...
[08:27:55.062] - nx: 6
[08:27:55.062] - relay: TRUE
[08:27:55.062] - stdout: TRUE
[08:27:55.062] - signal: TRUE
[08:27:55.062] - resignal: FALSE
[08:27:55.062] - force: TRUE
[08:27:55.062] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.062] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:55.063] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.063] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.063] signalConditionsASAP(NULL, pos=0) ... done
[08:27:55.063] resolve() on list environment ... DONE
[08:27:55.063] result() for ClusterFuture ...
[08:27:55.063] - result already collected: FutureResult
[08:27:55.063] result() for ClusterFuture ... done
[08:27:55.063] result() for ClusterFuture ...
[08:27:55.063] - result already collected: FutureResult
[08:27:55.063] result() for ClusterFuture ... done
[08:27:55.063] result() for ClusterFuture ...
[08:27:55.064] - result already collected: FutureResult
[08:27:55.064] result() for ClusterFuture ... done
[08:27:55.064] result() for ClusterFuture ...
[08:27:55.064] - result already collected: FutureResult
[08:27:55.064] result() for ClusterFuture ... done
[08:27:55.064] result() for ClusterFuture ...
[08:27:55.064] - result already collected: FutureResult
[08:27:55.064] result() for ClusterFuture ... done
[08:27:55.064] result() for ClusterFuture ...
[08:27:55.064] - result already collected: FutureResult
[08:27:55.065] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d8626c4b70> 
Dimensions: c(1, 6)
[08:27:55.065] getGlobalsAndPackages() ...
[08:27:55.065] Searching for globals...
[08:27:55.069] 
[08:27:55.069] Searching for globals ... DONE
[08:27:55.069] - globals: [0] <none>
[08:27:55.069] getGlobalsAndPackages() ... DONE
[08:27:55.069] run() for ‘Future’ ...
[08:27:55.069] - state: ‘created’
[08:27:55.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.083] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.083]   - Field: ‘node’
[08:27:55.083]   - Field: ‘label’
[08:27:55.084]   - Field: ‘local’
[08:27:55.084]   - Field: ‘owner’
[08:27:55.084]   - Field: ‘envir’
[08:27:55.084]   - Field: ‘workers’
[08:27:55.084]   - Field: ‘packages’
[08:27:55.084]   - Field: ‘gc’
[08:27:55.084]   - Field: ‘conditions’
[08:27:55.084]   - Field: ‘persistent’
[08:27:55.084]   - Field: ‘expr’
[08:27:55.084]   - Field: ‘uuid’
[08:27:55.084]   - Field: ‘seed’
[08:27:55.084]   - Field: ‘version’
[08:27:55.085]   - Field: ‘result’
[08:27:55.085]   - Field: ‘asynchronous’
[08:27:55.085]   - Field: ‘calls’
[08:27:55.085]   - Field: ‘globals’
[08:27:55.085]   - Field: ‘stdout’
[08:27:55.085]   - Field: ‘earlySignal’
[08:27:55.085]   - Field: ‘lazy’
[08:27:55.085]   - Field: ‘state’
[08:27:55.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.085] - Launch lazy future ...
[08:27:55.086] Packages needed by the future expression (n = 0): <none>
[08:27:55.086] Packages needed by future strategies (n = 0): <none>
[08:27:55.086] {
[08:27:55.086]     {
[08:27:55.086]         {
[08:27:55.086]             ...future.startTime <- base::Sys.time()
[08:27:55.086]             {
[08:27:55.086]                 {
[08:27:55.086]                   {
[08:27:55.086]                     {
[08:27:55.086]                       base::local({
[08:27:55.086]                         has_future <- base::requireNamespace("future", 
[08:27:55.086]                           quietly = TRUE)
[08:27:55.086]                         if (has_future) {
[08:27:55.086]                           ns <- base::getNamespace("future")
[08:27:55.086]                           version <- ns[[".package"]][["version"]]
[08:27:55.086]                           if (is.null(version)) 
[08:27:55.086]                             version <- utils::packageVersion("future")
[08:27:55.086]                         }
[08:27:55.086]                         else {
[08:27:55.086]                           version <- NULL
[08:27:55.086]                         }
[08:27:55.086]                         if (!has_future || version < "1.8.0") {
[08:27:55.086]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.086]                             "", base::R.version$version.string), 
[08:27:55.086]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.086]                               "release", "version")], collapse = " "), 
[08:27:55.086]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.086]                             info)
[08:27:55.086]                           info <- base::paste(info, collapse = "; ")
[08:27:55.086]                           if (!has_future) {
[08:27:55.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.086]                               info)
[08:27:55.086]                           }
[08:27:55.086]                           else {
[08:27:55.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.086]                               info, version)
[08:27:55.086]                           }
[08:27:55.086]                           base::stop(msg)
[08:27:55.086]                         }
[08:27:55.086]                       })
[08:27:55.086]                     }
[08:27:55.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.086]                     base::options(mc.cores = 1L)
[08:27:55.086]                   }
[08:27:55.086]                   ...future.strategy.old <- future::plan("list")
[08:27:55.086]                   options(future.plan = NULL)
[08:27:55.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.086]                 }
[08:27:55.086]                 ...future.workdir <- getwd()
[08:27:55.086]             }
[08:27:55.086]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.086]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.086]         }
[08:27:55.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.086]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.086]             base::names(...future.oldOptions))
[08:27:55.086]     }
[08:27:55.086]     if (FALSE) {
[08:27:55.086]     }
[08:27:55.086]     else {
[08:27:55.086]         if (TRUE) {
[08:27:55.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.086]                 open = "w")
[08:27:55.086]         }
[08:27:55.086]         else {
[08:27:55.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.086]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.086]         }
[08:27:55.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.086]             base::sink(type = "output", split = FALSE)
[08:27:55.086]             base::close(...future.stdout)
[08:27:55.086]         }, add = TRUE)
[08:27:55.086]     }
[08:27:55.086]     ...future.frame <- base::sys.nframe()
[08:27:55.086]     ...future.conditions <- base::list()
[08:27:55.086]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.086]     if (FALSE) {
[08:27:55.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.086]     }
[08:27:55.086]     ...future.result <- base::tryCatch({
[08:27:55.086]         base::withCallingHandlers({
[08:27:55.086]             ...future.value <- base::withVisible(base::local({
[08:27:55.086]                 ...future.makeSendCondition <- base::local({
[08:27:55.086]                   sendCondition <- NULL
[08:27:55.086]                   function(frame = 1L) {
[08:27:55.086]                     if (is.function(sendCondition)) 
[08:27:55.086]                       return(sendCondition)
[08:27:55.086]                     ns <- getNamespace("parallel")
[08:27:55.086]                     if (exists("sendData", mode = "function", 
[08:27:55.086]                       envir = ns)) {
[08:27:55.086]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.086]                         envir = ns)
[08:27:55.086]                       envir <- sys.frame(frame)
[08:27:55.086]                       master <- NULL
[08:27:55.086]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.086]                         !identical(envir, emptyenv())) {
[08:27:55.086]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.086]                           inherits = FALSE)) {
[08:27:55.086]                           master <- get("master", mode = "list", 
[08:27:55.086]                             envir = envir, inherits = FALSE)
[08:27:55.086]                           if (inherits(master, c("SOCKnode", 
[08:27:55.086]                             "SOCK0node"))) {
[08:27:55.086]                             sendCondition <<- function(cond) {
[08:27:55.086]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.086]                                 success = TRUE)
[08:27:55.086]                               parallel_sendData(master, data)
[08:27:55.086]                             }
[08:27:55.086]                             return(sendCondition)
[08:27:55.086]                           }
[08:27:55.086]                         }
[08:27:55.086]                         frame <- frame + 1L
[08:27:55.086]                         envir <- sys.frame(frame)
[08:27:55.086]                       }
[08:27:55.086]                     }
[08:27:55.086]                     sendCondition <<- function(cond) NULL
[08:27:55.086]                   }
[08:27:55.086]                 })
[08:27:55.086]                 withCallingHandlers({
[08:27:55.086]                   2
[08:27:55.086]                 }, immediateCondition = function(cond) {
[08:27:55.086]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.086]                   sendCondition(cond)
[08:27:55.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.086]                   {
[08:27:55.086]                     inherits <- base::inherits
[08:27:55.086]                     invokeRestart <- base::invokeRestart
[08:27:55.086]                     is.null <- base::is.null
[08:27:55.086]                     muffled <- FALSE
[08:27:55.086]                     if (inherits(cond, "message")) {
[08:27:55.086]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.086]                       if (muffled) 
[08:27:55.086]                         invokeRestart("muffleMessage")
[08:27:55.086]                     }
[08:27:55.086]                     else if (inherits(cond, "warning")) {
[08:27:55.086]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.086]                       if (muffled) 
[08:27:55.086]                         invokeRestart("muffleWarning")
[08:27:55.086]                     }
[08:27:55.086]                     else if (inherits(cond, "condition")) {
[08:27:55.086]                       if (!is.null(pattern)) {
[08:27:55.086]                         computeRestarts <- base::computeRestarts
[08:27:55.086]                         grepl <- base::grepl
[08:27:55.086]                         restarts <- computeRestarts(cond)
[08:27:55.086]                         for (restart in restarts) {
[08:27:55.086]                           name <- restart$name
[08:27:55.086]                           if (is.null(name)) 
[08:27:55.086]                             next
[08:27:55.086]                           if (!grepl(pattern, name)) 
[08:27:55.086]                             next
[08:27:55.086]                           invokeRestart(restart)
[08:27:55.086]                           muffled <- TRUE
[08:27:55.086]                           break
[08:27:55.086]                         }
[08:27:55.086]                       }
[08:27:55.086]                     }
[08:27:55.086]                     invisible(muffled)
[08:27:55.086]                   }
[08:27:55.086]                   muffleCondition(cond)
[08:27:55.086]                 })
[08:27:55.086]             }))
[08:27:55.086]             future::FutureResult(value = ...future.value$value, 
[08:27:55.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.086]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.086]                     ...future.globalenv.names))
[08:27:55.086]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.086]         }, condition = base::local({
[08:27:55.086]             c <- base::c
[08:27:55.086]             inherits <- base::inherits
[08:27:55.086]             invokeRestart <- base::invokeRestart
[08:27:55.086]             length <- base::length
[08:27:55.086]             list <- base::list
[08:27:55.086]             seq.int <- base::seq.int
[08:27:55.086]             signalCondition <- base::signalCondition
[08:27:55.086]             sys.calls <- base::sys.calls
[08:27:55.086]             `[[` <- base::`[[`
[08:27:55.086]             `+` <- base::`+`
[08:27:55.086]             `<<-` <- base::`<<-`
[08:27:55.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.086]                   3L)]
[08:27:55.086]             }
[08:27:55.086]             function(cond) {
[08:27:55.086]                 is_error <- inherits(cond, "error")
[08:27:55.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.086]                   NULL)
[08:27:55.086]                 if (is_error) {
[08:27:55.086]                   sessionInformation <- function() {
[08:27:55.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.086]                       search = base::search(), system = base::Sys.info())
[08:27:55.086]                   }
[08:27:55.086]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.086]                     cond$call), session = sessionInformation(), 
[08:27:55.086]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.086]                   signalCondition(cond)
[08:27:55.086]                 }
[08:27:55.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.086]                 "immediateCondition"))) {
[08:27:55.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.086]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.086]                   if (TRUE && !signal) {
[08:27:55.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.086]                     {
[08:27:55.086]                       inherits <- base::inherits
[08:27:55.086]                       invokeRestart <- base::invokeRestart
[08:27:55.086]                       is.null <- base::is.null
[08:27:55.086]                       muffled <- FALSE
[08:27:55.086]                       if (inherits(cond, "message")) {
[08:27:55.086]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.086]                         if (muffled) 
[08:27:55.086]                           invokeRestart("muffleMessage")
[08:27:55.086]                       }
[08:27:55.086]                       else if (inherits(cond, "warning")) {
[08:27:55.086]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.086]                         if (muffled) 
[08:27:55.086]                           invokeRestart("muffleWarning")
[08:27:55.086]                       }
[08:27:55.086]                       else if (inherits(cond, "condition")) {
[08:27:55.086]                         if (!is.null(pattern)) {
[08:27:55.086]                           computeRestarts <- base::computeRestarts
[08:27:55.086]                           grepl <- base::grepl
[08:27:55.086]                           restarts <- computeRestarts(cond)
[08:27:55.086]                           for (restart in restarts) {
[08:27:55.086]                             name <- restart$name
[08:27:55.086]                             if (is.null(name)) 
[08:27:55.086]                               next
[08:27:55.086]                             if (!grepl(pattern, name)) 
[08:27:55.086]                               next
[08:27:55.086]                             invokeRestart(restart)
[08:27:55.086]                             muffled <- TRUE
[08:27:55.086]                             break
[08:27:55.086]                           }
[08:27:55.086]                         }
[08:27:55.086]                       }
[08:27:55.086]                       invisible(muffled)
[08:27:55.086]                     }
[08:27:55.086]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.086]                   }
[08:27:55.086]                 }
[08:27:55.086]                 else {
[08:27:55.086]                   if (TRUE) {
[08:27:55.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.086]                     {
[08:27:55.086]                       inherits <- base::inherits
[08:27:55.086]                       invokeRestart <- base::invokeRestart
[08:27:55.086]                       is.null <- base::is.null
[08:27:55.086]                       muffled <- FALSE
[08:27:55.086]                       if (inherits(cond, "message")) {
[08:27:55.086]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.086]                         if (muffled) 
[08:27:55.086]                           invokeRestart("muffleMessage")
[08:27:55.086]                       }
[08:27:55.086]                       else if (inherits(cond, "warning")) {
[08:27:55.086]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.086]                         if (muffled) 
[08:27:55.086]                           invokeRestart("muffleWarning")
[08:27:55.086]                       }
[08:27:55.086]                       else if (inherits(cond, "condition")) {
[08:27:55.086]                         if (!is.null(pattern)) {
[08:27:55.086]                           computeRestarts <- base::computeRestarts
[08:27:55.086]                           grepl <- base::grepl
[08:27:55.086]                           restarts <- computeRestarts(cond)
[08:27:55.086]                           for (restart in restarts) {
[08:27:55.086]                             name <- restart$name
[08:27:55.086]                             if (is.null(name)) 
[08:27:55.086]                               next
[08:27:55.086]                             if (!grepl(pattern, name)) 
[08:27:55.086]                               next
[08:27:55.086]                             invokeRestart(restart)
[08:27:55.086]                             muffled <- TRUE
[08:27:55.086]                             break
[08:27:55.086]                           }
[08:27:55.086]                         }
[08:27:55.086]                       }
[08:27:55.086]                       invisible(muffled)
[08:27:55.086]                     }
[08:27:55.086]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.086]                   }
[08:27:55.086]                 }
[08:27:55.086]             }
[08:27:55.086]         }))
[08:27:55.086]     }, error = function(ex) {
[08:27:55.086]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.086]                 ...future.rng), started = ...future.startTime, 
[08:27:55.086]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.086]             version = "1.8"), class = "FutureResult")
[08:27:55.086]     }, finally = {
[08:27:55.086]         if (!identical(...future.workdir, getwd())) 
[08:27:55.086]             setwd(...future.workdir)
[08:27:55.086]         {
[08:27:55.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.086]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.086]             }
[08:27:55.086]             base::options(...future.oldOptions)
[08:27:55.086]             if (.Platform$OS.type == "windows") {
[08:27:55.086]                 old_names <- names(...future.oldEnvVars)
[08:27:55.086]                 envs <- base::Sys.getenv()
[08:27:55.086]                 names <- names(envs)
[08:27:55.086]                 common <- intersect(names, old_names)
[08:27:55.086]                 added <- setdiff(names, old_names)
[08:27:55.086]                 removed <- setdiff(old_names, names)
[08:27:55.086]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.086]                   envs[common]]
[08:27:55.086]                 NAMES <- toupper(changed)
[08:27:55.086]                 args <- list()
[08:27:55.086]                 for (kk in seq_along(NAMES)) {
[08:27:55.086]                   name <- changed[[kk]]
[08:27:55.086]                   NAME <- NAMES[[kk]]
[08:27:55.086]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.086]                     next
[08:27:55.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.086]                 }
[08:27:55.086]                 NAMES <- toupper(added)
[08:27:55.086]                 for (kk in seq_along(NAMES)) {
[08:27:55.086]                   name <- added[[kk]]
[08:27:55.086]                   NAME <- NAMES[[kk]]
[08:27:55.086]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.086]                     next
[08:27:55.086]                   args[[name]] <- ""
[08:27:55.086]                 }
[08:27:55.086]                 NAMES <- toupper(removed)
[08:27:55.086]                 for (kk in seq_along(NAMES)) {
[08:27:55.086]                   name <- removed[[kk]]
[08:27:55.086]                   NAME <- NAMES[[kk]]
[08:27:55.086]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.086]                     next
[08:27:55.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.086]                 }
[08:27:55.086]                 if (length(args) > 0) 
[08:27:55.086]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.086]             }
[08:27:55.086]             else {
[08:27:55.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.086]             }
[08:27:55.086]             {
[08:27:55.086]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.086]                   0L) {
[08:27:55.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.086]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.086]                   base::options(opts)
[08:27:55.086]                 }
[08:27:55.086]                 {
[08:27:55.086]                   {
[08:27:55.086]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.086]                     NULL
[08:27:55.086]                   }
[08:27:55.086]                   options(future.plan = NULL)
[08:27:55.086]                   if (is.na(NA_character_)) 
[08:27:55.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.086]                     .init = FALSE)
[08:27:55.086]                 }
[08:27:55.086]             }
[08:27:55.086]         }
[08:27:55.086]     })
[08:27:55.086]     if (TRUE) {
[08:27:55.086]         base::sink(type = "output", split = FALSE)
[08:27:55.086]         if (TRUE) {
[08:27:55.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.086]         }
[08:27:55.086]         else {
[08:27:55.086]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.086]         }
[08:27:55.086]         base::close(...future.stdout)
[08:27:55.086]         ...future.stdout <- NULL
[08:27:55.086]     }
[08:27:55.086]     ...future.result$conditions <- ...future.conditions
[08:27:55.086]     ...future.result$finished <- base::Sys.time()
[08:27:55.086]     ...future.result
[08:27:55.086] }
[08:27:55.089] MultisessionFuture started
[08:27:55.089] - Launch lazy future ... done
[08:27:55.090] run() for ‘MultisessionFuture’ ... done
[08:27:55.090] getGlobalsAndPackages() ...
[08:27:55.090] Searching for globals...
[08:27:55.090] 
[08:27:55.090] Searching for globals ... DONE
[08:27:55.090] - globals: [0] <none>
[08:27:55.090] getGlobalsAndPackages() ... DONE
[08:27:55.091] run() for ‘Future’ ...
[08:27:55.091] - state: ‘created’
[08:27:55.091] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.105] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.105] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.105]   - Field: ‘node’
[08:27:55.105]   - Field: ‘label’
[08:27:55.105]   - Field: ‘local’
[08:27:55.105]   - Field: ‘owner’
[08:27:55.105]   - Field: ‘envir’
[08:27:55.105]   - Field: ‘workers’
[08:27:55.105]   - Field: ‘packages’
[08:27:55.105]   - Field: ‘gc’
[08:27:55.106]   - Field: ‘conditions’
[08:27:55.106]   - Field: ‘persistent’
[08:27:55.106]   - Field: ‘expr’
[08:27:55.106]   - Field: ‘uuid’
[08:27:55.106]   - Field: ‘seed’
[08:27:55.106]   - Field: ‘version’
[08:27:55.106]   - Field: ‘result’
[08:27:55.106]   - Field: ‘asynchronous’
[08:27:55.106]   - Field: ‘calls’
[08:27:55.106]   - Field: ‘globals’
[08:27:55.106]   - Field: ‘stdout’
[08:27:55.106]   - Field: ‘earlySignal’
[08:27:55.107]   - Field: ‘lazy’
[08:27:55.107]   - Field: ‘state’
[08:27:55.107] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.107] - Launch lazy future ...
[08:27:55.107] Packages needed by the future expression (n = 0): <none>
[08:27:55.107] Packages needed by future strategies (n = 0): <none>
[08:27:55.108] {
[08:27:55.108]     {
[08:27:55.108]         {
[08:27:55.108]             ...future.startTime <- base::Sys.time()
[08:27:55.108]             {
[08:27:55.108]                 {
[08:27:55.108]                   {
[08:27:55.108]                     {
[08:27:55.108]                       base::local({
[08:27:55.108]                         has_future <- base::requireNamespace("future", 
[08:27:55.108]                           quietly = TRUE)
[08:27:55.108]                         if (has_future) {
[08:27:55.108]                           ns <- base::getNamespace("future")
[08:27:55.108]                           version <- ns[[".package"]][["version"]]
[08:27:55.108]                           if (is.null(version)) 
[08:27:55.108]                             version <- utils::packageVersion("future")
[08:27:55.108]                         }
[08:27:55.108]                         else {
[08:27:55.108]                           version <- NULL
[08:27:55.108]                         }
[08:27:55.108]                         if (!has_future || version < "1.8.0") {
[08:27:55.108]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.108]                             "", base::R.version$version.string), 
[08:27:55.108]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.108]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.108]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.108]                               "release", "version")], collapse = " "), 
[08:27:55.108]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.108]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.108]                             info)
[08:27:55.108]                           info <- base::paste(info, collapse = "; ")
[08:27:55.108]                           if (!has_future) {
[08:27:55.108]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.108]                               info)
[08:27:55.108]                           }
[08:27:55.108]                           else {
[08:27:55.108]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.108]                               info, version)
[08:27:55.108]                           }
[08:27:55.108]                           base::stop(msg)
[08:27:55.108]                         }
[08:27:55.108]                       })
[08:27:55.108]                     }
[08:27:55.108]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.108]                     base::options(mc.cores = 1L)
[08:27:55.108]                   }
[08:27:55.108]                   ...future.strategy.old <- future::plan("list")
[08:27:55.108]                   options(future.plan = NULL)
[08:27:55.108]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.108]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.108]                 }
[08:27:55.108]                 ...future.workdir <- getwd()
[08:27:55.108]             }
[08:27:55.108]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.108]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.108]         }
[08:27:55.108]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.108]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.108]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.108]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.108]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.108]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.108]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.108]             base::names(...future.oldOptions))
[08:27:55.108]     }
[08:27:55.108]     if (FALSE) {
[08:27:55.108]     }
[08:27:55.108]     else {
[08:27:55.108]         if (TRUE) {
[08:27:55.108]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.108]                 open = "w")
[08:27:55.108]         }
[08:27:55.108]         else {
[08:27:55.108]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.108]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.108]         }
[08:27:55.108]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.108]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.108]             base::sink(type = "output", split = FALSE)
[08:27:55.108]             base::close(...future.stdout)
[08:27:55.108]         }, add = TRUE)
[08:27:55.108]     }
[08:27:55.108]     ...future.frame <- base::sys.nframe()
[08:27:55.108]     ...future.conditions <- base::list()
[08:27:55.108]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.108]     if (FALSE) {
[08:27:55.108]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.108]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.108]     }
[08:27:55.108]     ...future.result <- base::tryCatch({
[08:27:55.108]         base::withCallingHandlers({
[08:27:55.108]             ...future.value <- base::withVisible(base::local({
[08:27:55.108]                 ...future.makeSendCondition <- base::local({
[08:27:55.108]                   sendCondition <- NULL
[08:27:55.108]                   function(frame = 1L) {
[08:27:55.108]                     if (is.function(sendCondition)) 
[08:27:55.108]                       return(sendCondition)
[08:27:55.108]                     ns <- getNamespace("parallel")
[08:27:55.108]                     if (exists("sendData", mode = "function", 
[08:27:55.108]                       envir = ns)) {
[08:27:55.108]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.108]                         envir = ns)
[08:27:55.108]                       envir <- sys.frame(frame)
[08:27:55.108]                       master <- NULL
[08:27:55.108]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.108]                         !identical(envir, emptyenv())) {
[08:27:55.108]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.108]                           inherits = FALSE)) {
[08:27:55.108]                           master <- get("master", mode = "list", 
[08:27:55.108]                             envir = envir, inherits = FALSE)
[08:27:55.108]                           if (inherits(master, c("SOCKnode", 
[08:27:55.108]                             "SOCK0node"))) {
[08:27:55.108]                             sendCondition <<- function(cond) {
[08:27:55.108]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.108]                                 success = TRUE)
[08:27:55.108]                               parallel_sendData(master, data)
[08:27:55.108]                             }
[08:27:55.108]                             return(sendCondition)
[08:27:55.108]                           }
[08:27:55.108]                         }
[08:27:55.108]                         frame <- frame + 1L
[08:27:55.108]                         envir <- sys.frame(frame)
[08:27:55.108]                       }
[08:27:55.108]                     }
[08:27:55.108]                     sendCondition <<- function(cond) NULL
[08:27:55.108]                   }
[08:27:55.108]                 })
[08:27:55.108]                 withCallingHandlers({
[08:27:55.108]                   NULL
[08:27:55.108]                 }, immediateCondition = function(cond) {
[08:27:55.108]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.108]                   sendCondition(cond)
[08:27:55.108]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.108]                   {
[08:27:55.108]                     inherits <- base::inherits
[08:27:55.108]                     invokeRestart <- base::invokeRestart
[08:27:55.108]                     is.null <- base::is.null
[08:27:55.108]                     muffled <- FALSE
[08:27:55.108]                     if (inherits(cond, "message")) {
[08:27:55.108]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.108]                       if (muffled) 
[08:27:55.108]                         invokeRestart("muffleMessage")
[08:27:55.108]                     }
[08:27:55.108]                     else if (inherits(cond, "warning")) {
[08:27:55.108]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.108]                       if (muffled) 
[08:27:55.108]                         invokeRestart("muffleWarning")
[08:27:55.108]                     }
[08:27:55.108]                     else if (inherits(cond, "condition")) {
[08:27:55.108]                       if (!is.null(pattern)) {
[08:27:55.108]                         computeRestarts <- base::computeRestarts
[08:27:55.108]                         grepl <- base::grepl
[08:27:55.108]                         restarts <- computeRestarts(cond)
[08:27:55.108]                         for (restart in restarts) {
[08:27:55.108]                           name <- restart$name
[08:27:55.108]                           if (is.null(name)) 
[08:27:55.108]                             next
[08:27:55.108]                           if (!grepl(pattern, name)) 
[08:27:55.108]                             next
[08:27:55.108]                           invokeRestart(restart)
[08:27:55.108]                           muffled <- TRUE
[08:27:55.108]                           break
[08:27:55.108]                         }
[08:27:55.108]                       }
[08:27:55.108]                     }
[08:27:55.108]                     invisible(muffled)
[08:27:55.108]                   }
[08:27:55.108]                   muffleCondition(cond)
[08:27:55.108]                 })
[08:27:55.108]             }))
[08:27:55.108]             future::FutureResult(value = ...future.value$value, 
[08:27:55.108]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.108]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.108]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.108]                     ...future.globalenv.names))
[08:27:55.108]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.108]         }, condition = base::local({
[08:27:55.108]             c <- base::c
[08:27:55.108]             inherits <- base::inherits
[08:27:55.108]             invokeRestart <- base::invokeRestart
[08:27:55.108]             length <- base::length
[08:27:55.108]             list <- base::list
[08:27:55.108]             seq.int <- base::seq.int
[08:27:55.108]             signalCondition <- base::signalCondition
[08:27:55.108]             sys.calls <- base::sys.calls
[08:27:55.108]             `[[` <- base::`[[`
[08:27:55.108]             `+` <- base::`+`
[08:27:55.108]             `<<-` <- base::`<<-`
[08:27:55.108]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.108]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.108]                   3L)]
[08:27:55.108]             }
[08:27:55.108]             function(cond) {
[08:27:55.108]                 is_error <- inherits(cond, "error")
[08:27:55.108]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.108]                   NULL)
[08:27:55.108]                 if (is_error) {
[08:27:55.108]                   sessionInformation <- function() {
[08:27:55.108]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.108]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.108]                       search = base::search(), system = base::Sys.info())
[08:27:55.108]                   }
[08:27:55.108]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.108]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.108]                     cond$call), session = sessionInformation(), 
[08:27:55.108]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.108]                   signalCondition(cond)
[08:27:55.108]                 }
[08:27:55.108]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.108]                 "immediateCondition"))) {
[08:27:55.108]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.108]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.108]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.108]                   if (TRUE && !signal) {
[08:27:55.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.108]                     {
[08:27:55.108]                       inherits <- base::inherits
[08:27:55.108]                       invokeRestart <- base::invokeRestart
[08:27:55.108]                       is.null <- base::is.null
[08:27:55.108]                       muffled <- FALSE
[08:27:55.108]                       if (inherits(cond, "message")) {
[08:27:55.108]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.108]                         if (muffled) 
[08:27:55.108]                           invokeRestart("muffleMessage")
[08:27:55.108]                       }
[08:27:55.108]                       else if (inherits(cond, "warning")) {
[08:27:55.108]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.108]                         if (muffled) 
[08:27:55.108]                           invokeRestart("muffleWarning")
[08:27:55.108]                       }
[08:27:55.108]                       else if (inherits(cond, "condition")) {
[08:27:55.108]                         if (!is.null(pattern)) {
[08:27:55.108]                           computeRestarts <- base::computeRestarts
[08:27:55.108]                           grepl <- base::grepl
[08:27:55.108]                           restarts <- computeRestarts(cond)
[08:27:55.108]                           for (restart in restarts) {
[08:27:55.108]                             name <- restart$name
[08:27:55.108]                             if (is.null(name)) 
[08:27:55.108]                               next
[08:27:55.108]                             if (!grepl(pattern, name)) 
[08:27:55.108]                               next
[08:27:55.108]                             invokeRestart(restart)
[08:27:55.108]                             muffled <- TRUE
[08:27:55.108]                             break
[08:27:55.108]                           }
[08:27:55.108]                         }
[08:27:55.108]                       }
[08:27:55.108]                       invisible(muffled)
[08:27:55.108]                     }
[08:27:55.108]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.108]                   }
[08:27:55.108]                 }
[08:27:55.108]                 else {
[08:27:55.108]                   if (TRUE) {
[08:27:55.108]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.108]                     {
[08:27:55.108]                       inherits <- base::inherits
[08:27:55.108]                       invokeRestart <- base::invokeRestart
[08:27:55.108]                       is.null <- base::is.null
[08:27:55.108]                       muffled <- FALSE
[08:27:55.108]                       if (inherits(cond, "message")) {
[08:27:55.108]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.108]                         if (muffled) 
[08:27:55.108]                           invokeRestart("muffleMessage")
[08:27:55.108]                       }
[08:27:55.108]                       else if (inherits(cond, "warning")) {
[08:27:55.108]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.108]                         if (muffled) 
[08:27:55.108]                           invokeRestart("muffleWarning")
[08:27:55.108]                       }
[08:27:55.108]                       else if (inherits(cond, "condition")) {
[08:27:55.108]                         if (!is.null(pattern)) {
[08:27:55.108]                           computeRestarts <- base::computeRestarts
[08:27:55.108]                           grepl <- base::grepl
[08:27:55.108]                           restarts <- computeRestarts(cond)
[08:27:55.108]                           for (restart in restarts) {
[08:27:55.108]                             name <- restart$name
[08:27:55.108]                             if (is.null(name)) 
[08:27:55.108]                               next
[08:27:55.108]                             if (!grepl(pattern, name)) 
[08:27:55.108]                               next
[08:27:55.108]                             invokeRestart(restart)
[08:27:55.108]                             muffled <- TRUE
[08:27:55.108]                             break
[08:27:55.108]                           }
[08:27:55.108]                         }
[08:27:55.108]                       }
[08:27:55.108]                       invisible(muffled)
[08:27:55.108]                     }
[08:27:55.108]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.108]                   }
[08:27:55.108]                 }
[08:27:55.108]             }
[08:27:55.108]         }))
[08:27:55.108]     }, error = function(ex) {
[08:27:55.108]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.108]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.108]                 ...future.rng), started = ...future.startTime, 
[08:27:55.108]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.108]             version = "1.8"), class = "FutureResult")
[08:27:55.108]     }, finally = {
[08:27:55.108]         if (!identical(...future.workdir, getwd())) 
[08:27:55.108]             setwd(...future.workdir)
[08:27:55.108]         {
[08:27:55.108]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.108]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.108]             }
[08:27:55.108]             base::options(...future.oldOptions)
[08:27:55.108]             if (.Platform$OS.type == "windows") {
[08:27:55.108]                 old_names <- names(...future.oldEnvVars)
[08:27:55.108]                 envs <- base::Sys.getenv()
[08:27:55.108]                 names <- names(envs)
[08:27:55.108]                 common <- intersect(names, old_names)
[08:27:55.108]                 added <- setdiff(names, old_names)
[08:27:55.108]                 removed <- setdiff(old_names, names)
[08:27:55.108]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.108]                   envs[common]]
[08:27:55.108]                 NAMES <- toupper(changed)
[08:27:55.108]                 args <- list()
[08:27:55.108]                 for (kk in seq_along(NAMES)) {
[08:27:55.108]                   name <- changed[[kk]]
[08:27:55.108]                   NAME <- NAMES[[kk]]
[08:27:55.108]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.108]                     next
[08:27:55.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.108]                 }
[08:27:55.108]                 NAMES <- toupper(added)
[08:27:55.108]                 for (kk in seq_along(NAMES)) {
[08:27:55.108]                   name <- added[[kk]]
[08:27:55.108]                   NAME <- NAMES[[kk]]
[08:27:55.108]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.108]                     next
[08:27:55.108]                   args[[name]] <- ""
[08:27:55.108]                 }
[08:27:55.108]                 NAMES <- toupper(removed)
[08:27:55.108]                 for (kk in seq_along(NAMES)) {
[08:27:55.108]                   name <- removed[[kk]]
[08:27:55.108]                   NAME <- NAMES[[kk]]
[08:27:55.108]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.108]                     next
[08:27:55.108]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.108]                 }
[08:27:55.108]                 if (length(args) > 0) 
[08:27:55.108]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.108]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.108]             }
[08:27:55.108]             else {
[08:27:55.108]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.108]             }
[08:27:55.108]             {
[08:27:55.108]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.108]                   0L) {
[08:27:55.108]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.108]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.108]                   base::options(opts)
[08:27:55.108]                 }
[08:27:55.108]                 {
[08:27:55.108]                   {
[08:27:55.108]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.108]                     NULL
[08:27:55.108]                   }
[08:27:55.108]                   options(future.plan = NULL)
[08:27:55.108]                   if (is.na(NA_character_)) 
[08:27:55.108]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.108]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.108]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.108]                     .init = FALSE)
[08:27:55.108]                 }
[08:27:55.108]             }
[08:27:55.108]         }
[08:27:55.108]     })
[08:27:55.108]     if (TRUE) {
[08:27:55.108]         base::sink(type = "output", split = FALSE)
[08:27:55.108]         if (TRUE) {
[08:27:55.108]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.108]         }
[08:27:55.108]         else {
[08:27:55.108]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.108]         }
[08:27:55.108]         base::close(...future.stdout)
[08:27:55.108]         ...future.stdout <- NULL
[08:27:55.108]     }
[08:27:55.108]     ...future.result$conditions <- ...future.conditions
[08:27:55.108]     ...future.result$finished <- base::Sys.time()
[08:27:55.108]     ...future.result
[08:27:55.108] }
[08:27:55.111] MultisessionFuture started
[08:27:55.111] - Launch lazy future ... done
[08:27:55.111] run() for ‘MultisessionFuture’ ... done
[08:27:55.111] getGlobalsAndPackages() ...
[08:27:55.111] Searching for globals...
[08:27:55.112] - globals found: [1] ‘{’
[08:27:55.112] Searching for globals ... DONE
[08:27:55.112] Resolving globals: FALSE
[08:27:55.113] 
[08:27:55.113] 
[08:27:55.113] getGlobalsAndPackages() ... DONE
[08:27:55.113] run() for ‘Future’ ...
[08:27:55.113] - state: ‘created’
[08:27:55.113] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.127] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.127] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.127]   - Field: ‘node’
[08:27:55.127]   - Field: ‘label’
[08:27:55.127]   - Field: ‘local’
[08:27:55.128]   - Field: ‘owner’
[08:27:55.128]   - Field: ‘envir’
[08:27:55.128]   - Field: ‘workers’
[08:27:55.128]   - Field: ‘packages’
[08:27:55.128]   - Field: ‘gc’
[08:27:55.128]   - Field: ‘conditions’
[08:27:55.128]   - Field: ‘persistent’
[08:27:55.128]   - Field: ‘expr’
[08:27:55.128]   - Field: ‘uuid’
[08:27:55.128]   - Field: ‘seed’
[08:27:55.128]   - Field: ‘version’
[08:27:55.128]   - Field: ‘result’
[08:27:55.129]   - Field: ‘asynchronous’
[08:27:55.129]   - Field: ‘calls’
[08:27:55.129]   - Field: ‘globals’
[08:27:55.129]   - Field: ‘stdout’
[08:27:55.129]   - Field: ‘earlySignal’
[08:27:55.129]   - Field: ‘lazy’
[08:27:55.129]   - Field: ‘state’
[08:27:55.129] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.129] - Launch lazy future ...
[08:27:55.130] Packages needed by the future expression (n = 0): <none>
[08:27:55.130] Packages needed by future strategies (n = 0): <none>
[08:27:55.131] {
[08:27:55.131]     {
[08:27:55.131]         {
[08:27:55.131]             ...future.startTime <- base::Sys.time()
[08:27:55.131]             {
[08:27:55.131]                 {
[08:27:55.131]                   {
[08:27:55.131]                     {
[08:27:55.131]                       base::local({
[08:27:55.131]                         has_future <- base::requireNamespace("future", 
[08:27:55.131]                           quietly = TRUE)
[08:27:55.131]                         if (has_future) {
[08:27:55.131]                           ns <- base::getNamespace("future")
[08:27:55.131]                           version <- ns[[".package"]][["version"]]
[08:27:55.131]                           if (is.null(version)) 
[08:27:55.131]                             version <- utils::packageVersion("future")
[08:27:55.131]                         }
[08:27:55.131]                         else {
[08:27:55.131]                           version <- NULL
[08:27:55.131]                         }
[08:27:55.131]                         if (!has_future || version < "1.8.0") {
[08:27:55.131]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.131]                             "", base::R.version$version.string), 
[08:27:55.131]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.131]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.131]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.131]                               "release", "version")], collapse = " "), 
[08:27:55.131]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.131]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.131]                             info)
[08:27:55.131]                           info <- base::paste(info, collapse = "; ")
[08:27:55.131]                           if (!has_future) {
[08:27:55.131]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.131]                               info)
[08:27:55.131]                           }
[08:27:55.131]                           else {
[08:27:55.131]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.131]                               info, version)
[08:27:55.131]                           }
[08:27:55.131]                           base::stop(msg)
[08:27:55.131]                         }
[08:27:55.131]                       })
[08:27:55.131]                     }
[08:27:55.131]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.131]                     base::options(mc.cores = 1L)
[08:27:55.131]                   }
[08:27:55.131]                   ...future.strategy.old <- future::plan("list")
[08:27:55.131]                   options(future.plan = NULL)
[08:27:55.131]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.131]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.131]                 }
[08:27:55.131]                 ...future.workdir <- getwd()
[08:27:55.131]             }
[08:27:55.131]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.131]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.131]         }
[08:27:55.131]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.131]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.131]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.131]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.131]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.131]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.131]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.131]             base::names(...future.oldOptions))
[08:27:55.131]     }
[08:27:55.131]     if (FALSE) {
[08:27:55.131]     }
[08:27:55.131]     else {
[08:27:55.131]         if (TRUE) {
[08:27:55.131]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.131]                 open = "w")
[08:27:55.131]         }
[08:27:55.131]         else {
[08:27:55.131]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.131]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.131]         }
[08:27:55.131]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.131]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.131]             base::sink(type = "output", split = FALSE)
[08:27:55.131]             base::close(...future.stdout)
[08:27:55.131]         }, add = TRUE)
[08:27:55.131]     }
[08:27:55.131]     ...future.frame <- base::sys.nframe()
[08:27:55.131]     ...future.conditions <- base::list()
[08:27:55.131]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.131]     if (FALSE) {
[08:27:55.131]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.131]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.131]     }
[08:27:55.131]     ...future.result <- base::tryCatch({
[08:27:55.131]         base::withCallingHandlers({
[08:27:55.131]             ...future.value <- base::withVisible(base::local({
[08:27:55.131]                 ...future.makeSendCondition <- base::local({
[08:27:55.131]                   sendCondition <- NULL
[08:27:55.131]                   function(frame = 1L) {
[08:27:55.131]                     if (is.function(sendCondition)) 
[08:27:55.131]                       return(sendCondition)
[08:27:55.131]                     ns <- getNamespace("parallel")
[08:27:55.131]                     if (exists("sendData", mode = "function", 
[08:27:55.131]                       envir = ns)) {
[08:27:55.131]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.131]                         envir = ns)
[08:27:55.131]                       envir <- sys.frame(frame)
[08:27:55.131]                       master <- NULL
[08:27:55.131]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.131]                         !identical(envir, emptyenv())) {
[08:27:55.131]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.131]                           inherits = FALSE)) {
[08:27:55.131]                           master <- get("master", mode = "list", 
[08:27:55.131]                             envir = envir, inherits = FALSE)
[08:27:55.131]                           if (inherits(master, c("SOCKnode", 
[08:27:55.131]                             "SOCK0node"))) {
[08:27:55.131]                             sendCondition <<- function(cond) {
[08:27:55.131]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.131]                                 success = TRUE)
[08:27:55.131]                               parallel_sendData(master, data)
[08:27:55.131]                             }
[08:27:55.131]                             return(sendCondition)
[08:27:55.131]                           }
[08:27:55.131]                         }
[08:27:55.131]                         frame <- frame + 1L
[08:27:55.131]                         envir <- sys.frame(frame)
[08:27:55.131]                       }
[08:27:55.131]                     }
[08:27:55.131]                     sendCondition <<- function(cond) NULL
[08:27:55.131]                   }
[08:27:55.131]                 })
[08:27:55.131]                 withCallingHandlers({
[08:27:55.131]                   {
[08:27:55.131]                     4
[08:27:55.131]                   }
[08:27:55.131]                 }, immediateCondition = function(cond) {
[08:27:55.131]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.131]                   sendCondition(cond)
[08:27:55.131]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.131]                   {
[08:27:55.131]                     inherits <- base::inherits
[08:27:55.131]                     invokeRestart <- base::invokeRestart
[08:27:55.131]                     is.null <- base::is.null
[08:27:55.131]                     muffled <- FALSE
[08:27:55.131]                     if (inherits(cond, "message")) {
[08:27:55.131]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.131]                       if (muffled) 
[08:27:55.131]                         invokeRestart("muffleMessage")
[08:27:55.131]                     }
[08:27:55.131]                     else if (inherits(cond, "warning")) {
[08:27:55.131]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.131]                       if (muffled) 
[08:27:55.131]                         invokeRestart("muffleWarning")
[08:27:55.131]                     }
[08:27:55.131]                     else if (inherits(cond, "condition")) {
[08:27:55.131]                       if (!is.null(pattern)) {
[08:27:55.131]                         computeRestarts <- base::computeRestarts
[08:27:55.131]                         grepl <- base::grepl
[08:27:55.131]                         restarts <- computeRestarts(cond)
[08:27:55.131]                         for (restart in restarts) {
[08:27:55.131]                           name <- restart$name
[08:27:55.131]                           if (is.null(name)) 
[08:27:55.131]                             next
[08:27:55.131]                           if (!grepl(pattern, name)) 
[08:27:55.131]                             next
[08:27:55.131]                           invokeRestart(restart)
[08:27:55.131]                           muffled <- TRUE
[08:27:55.131]                           break
[08:27:55.131]                         }
[08:27:55.131]                       }
[08:27:55.131]                     }
[08:27:55.131]                     invisible(muffled)
[08:27:55.131]                   }
[08:27:55.131]                   muffleCondition(cond)
[08:27:55.131]                 })
[08:27:55.131]             }))
[08:27:55.131]             future::FutureResult(value = ...future.value$value, 
[08:27:55.131]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.131]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.131]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.131]                     ...future.globalenv.names))
[08:27:55.131]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.131]         }, condition = base::local({
[08:27:55.131]             c <- base::c
[08:27:55.131]             inherits <- base::inherits
[08:27:55.131]             invokeRestart <- base::invokeRestart
[08:27:55.131]             length <- base::length
[08:27:55.131]             list <- base::list
[08:27:55.131]             seq.int <- base::seq.int
[08:27:55.131]             signalCondition <- base::signalCondition
[08:27:55.131]             sys.calls <- base::sys.calls
[08:27:55.131]             `[[` <- base::`[[`
[08:27:55.131]             `+` <- base::`+`
[08:27:55.131]             `<<-` <- base::`<<-`
[08:27:55.131]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.131]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.131]                   3L)]
[08:27:55.131]             }
[08:27:55.131]             function(cond) {
[08:27:55.131]                 is_error <- inherits(cond, "error")
[08:27:55.131]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.131]                   NULL)
[08:27:55.131]                 if (is_error) {
[08:27:55.131]                   sessionInformation <- function() {
[08:27:55.131]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.131]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.131]                       search = base::search(), system = base::Sys.info())
[08:27:55.131]                   }
[08:27:55.131]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.131]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.131]                     cond$call), session = sessionInformation(), 
[08:27:55.131]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.131]                   signalCondition(cond)
[08:27:55.131]                 }
[08:27:55.131]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.131]                 "immediateCondition"))) {
[08:27:55.131]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.131]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.131]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.131]                   if (TRUE && !signal) {
[08:27:55.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.131]                     {
[08:27:55.131]                       inherits <- base::inherits
[08:27:55.131]                       invokeRestart <- base::invokeRestart
[08:27:55.131]                       is.null <- base::is.null
[08:27:55.131]                       muffled <- FALSE
[08:27:55.131]                       if (inherits(cond, "message")) {
[08:27:55.131]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.131]                         if (muffled) 
[08:27:55.131]                           invokeRestart("muffleMessage")
[08:27:55.131]                       }
[08:27:55.131]                       else if (inherits(cond, "warning")) {
[08:27:55.131]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.131]                         if (muffled) 
[08:27:55.131]                           invokeRestart("muffleWarning")
[08:27:55.131]                       }
[08:27:55.131]                       else if (inherits(cond, "condition")) {
[08:27:55.131]                         if (!is.null(pattern)) {
[08:27:55.131]                           computeRestarts <- base::computeRestarts
[08:27:55.131]                           grepl <- base::grepl
[08:27:55.131]                           restarts <- computeRestarts(cond)
[08:27:55.131]                           for (restart in restarts) {
[08:27:55.131]                             name <- restart$name
[08:27:55.131]                             if (is.null(name)) 
[08:27:55.131]                               next
[08:27:55.131]                             if (!grepl(pattern, name)) 
[08:27:55.131]                               next
[08:27:55.131]                             invokeRestart(restart)
[08:27:55.131]                             muffled <- TRUE
[08:27:55.131]                             break
[08:27:55.131]                           }
[08:27:55.131]                         }
[08:27:55.131]                       }
[08:27:55.131]                       invisible(muffled)
[08:27:55.131]                     }
[08:27:55.131]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.131]                   }
[08:27:55.131]                 }
[08:27:55.131]                 else {
[08:27:55.131]                   if (TRUE) {
[08:27:55.131]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.131]                     {
[08:27:55.131]                       inherits <- base::inherits
[08:27:55.131]                       invokeRestart <- base::invokeRestart
[08:27:55.131]                       is.null <- base::is.null
[08:27:55.131]                       muffled <- FALSE
[08:27:55.131]                       if (inherits(cond, "message")) {
[08:27:55.131]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.131]                         if (muffled) 
[08:27:55.131]                           invokeRestart("muffleMessage")
[08:27:55.131]                       }
[08:27:55.131]                       else if (inherits(cond, "warning")) {
[08:27:55.131]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.131]                         if (muffled) 
[08:27:55.131]                           invokeRestart("muffleWarning")
[08:27:55.131]                       }
[08:27:55.131]                       else if (inherits(cond, "condition")) {
[08:27:55.131]                         if (!is.null(pattern)) {
[08:27:55.131]                           computeRestarts <- base::computeRestarts
[08:27:55.131]                           grepl <- base::grepl
[08:27:55.131]                           restarts <- computeRestarts(cond)
[08:27:55.131]                           for (restart in restarts) {
[08:27:55.131]                             name <- restart$name
[08:27:55.131]                             if (is.null(name)) 
[08:27:55.131]                               next
[08:27:55.131]                             if (!grepl(pattern, name)) 
[08:27:55.131]                               next
[08:27:55.131]                             invokeRestart(restart)
[08:27:55.131]                             muffled <- TRUE
[08:27:55.131]                             break
[08:27:55.131]                           }
[08:27:55.131]                         }
[08:27:55.131]                       }
[08:27:55.131]                       invisible(muffled)
[08:27:55.131]                     }
[08:27:55.131]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.131]                   }
[08:27:55.131]                 }
[08:27:55.131]             }
[08:27:55.131]         }))
[08:27:55.131]     }, error = function(ex) {
[08:27:55.131]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.131]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.131]                 ...future.rng), started = ...future.startTime, 
[08:27:55.131]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.131]             version = "1.8"), class = "FutureResult")
[08:27:55.131]     }, finally = {
[08:27:55.131]         if (!identical(...future.workdir, getwd())) 
[08:27:55.131]             setwd(...future.workdir)
[08:27:55.131]         {
[08:27:55.131]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.131]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.131]             }
[08:27:55.131]             base::options(...future.oldOptions)
[08:27:55.131]             if (.Platform$OS.type == "windows") {
[08:27:55.131]                 old_names <- names(...future.oldEnvVars)
[08:27:55.131]                 envs <- base::Sys.getenv()
[08:27:55.131]                 names <- names(envs)
[08:27:55.131]                 common <- intersect(names, old_names)
[08:27:55.131]                 added <- setdiff(names, old_names)
[08:27:55.131]                 removed <- setdiff(old_names, names)
[08:27:55.131]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.131]                   envs[common]]
[08:27:55.131]                 NAMES <- toupper(changed)
[08:27:55.131]                 args <- list()
[08:27:55.131]                 for (kk in seq_along(NAMES)) {
[08:27:55.131]                   name <- changed[[kk]]
[08:27:55.131]                   NAME <- NAMES[[kk]]
[08:27:55.131]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.131]                     next
[08:27:55.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.131]                 }
[08:27:55.131]                 NAMES <- toupper(added)
[08:27:55.131]                 for (kk in seq_along(NAMES)) {
[08:27:55.131]                   name <- added[[kk]]
[08:27:55.131]                   NAME <- NAMES[[kk]]
[08:27:55.131]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.131]                     next
[08:27:55.131]                   args[[name]] <- ""
[08:27:55.131]                 }
[08:27:55.131]                 NAMES <- toupper(removed)
[08:27:55.131]                 for (kk in seq_along(NAMES)) {
[08:27:55.131]                   name <- removed[[kk]]
[08:27:55.131]                   NAME <- NAMES[[kk]]
[08:27:55.131]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.131]                     next
[08:27:55.131]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.131]                 }
[08:27:55.131]                 if (length(args) > 0) 
[08:27:55.131]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.131]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.131]             }
[08:27:55.131]             else {
[08:27:55.131]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.131]             }
[08:27:55.131]             {
[08:27:55.131]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.131]                   0L) {
[08:27:55.131]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.131]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.131]                   base::options(opts)
[08:27:55.131]                 }
[08:27:55.131]                 {
[08:27:55.131]                   {
[08:27:55.131]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.131]                     NULL
[08:27:55.131]                   }
[08:27:55.131]                   options(future.plan = NULL)
[08:27:55.131]                   if (is.na(NA_character_)) 
[08:27:55.131]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.131]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.131]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.131]                     .init = FALSE)
[08:27:55.131]                 }
[08:27:55.131]             }
[08:27:55.131]         }
[08:27:55.131]     })
[08:27:55.131]     if (TRUE) {
[08:27:55.131]         base::sink(type = "output", split = FALSE)
[08:27:55.131]         if (TRUE) {
[08:27:55.131]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.131]         }
[08:27:55.131]         else {
[08:27:55.131]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.131]         }
[08:27:55.131]         base::close(...future.stdout)
[08:27:55.131]         ...future.stdout <- NULL
[08:27:55.131]     }
[08:27:55.131]     ...future.result$conditions <- ...future.conditions
[08:27:55.131]     ...future.result$finished <- base::Sys.time()
[08:27:55.131]     ...future.result
[08:27:55.131] }
[08:27:55.134] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:55.144] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.145] - Validating connection of MultisessionFuture
[08:27:55.145] - received message: FutureResult
[08:27:55.145] - Received FutureResult
[08:27:55.145] - Erased future from FutureRegistry
[08:27:55.145] result() for ClusterFuture ...
[08:27:55.145] - result already collected: FutureResult
[08:27:55.145] result() for ClusterFuture ... done
[08:27:55.145] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.145] result() for ClusterFuture ...
[08:27:55.145] - result already collected: FutureResult
[08:27:55.146] result() for ClusterFuture ... done
[08:27:55.146] result() for ClusterFuture ...
[08:27:55.146] - result already collected: FutureResult
[08:27:55.146] result() for ClusterFuture ... done
[08:27:55.147] MultisessionFuture started
[08:27:55.147] - Launch lazy future ... done
[08:27:55.147] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d863283ed0> 
Classes 'listenv', 'environment' <environment: 0x55d861ed0860> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[08:27:55.153] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.153] - Validating connection of MultisessionFuture
[08:27:55.153] - received message: FutureResult
[08:27:55.154] - Received FutureResult
[08:27:55.154] - Erased future from FutureRegistry
[08:27:55.154] result() for ClusterFuture ...
[08:27:55.154] - result already collected: FutureResult
[08:27:55.154] result() for ClusterFuture ... done
[08:27:55.154] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:55.167] resolve() on list environment ...
[08:27:55.167]  recursive: 0
[08:27:55.168]  length: 6
[08:27:55.168]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:55.168] signalConditionsASAP(numeric, pos=1) ...
[08:27:55.168] - nx: 6
[08:27:55.168] - relay: TRUE
[08:27:55.168] - stdout: TRUE
[08:27:55.169] - signal: TRUE
[08:27:55.169] - resignal: FALSE
[08:27:55.169] - force: TRUE
[08:27:55.169] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.169] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.169]  - until=2
[08:27:55.169]  - relaying element #2
[08:27:55.169] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.169] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.169] signalConditionsASAP(NULL, pos=1) ... done
[08:27:55.169]  length: 5 (resolved future 1)
[08:27:55.169] Future #2
[08:27:55.170] result() for ClusterFuture ...
[08:27:55.170] - result already collected: FutureResult
[08:27:55.170] result() for ClusterFuture ... done
[08:27:55.170] result() for ClusterFuture ...
[08:27:55.170] - result already collected: FutureResult
[08:27:55.170] result() for ClusterFuture ... done
[08:27:55.170] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:55.170] - nx: 6
[08:27:55.170] - relay: TRUE
[08:27:55.170] - stdout: TRUE
[08:27:55.170] - signal: TRUE
[08:27:55.170] - resignal: FALSE
[08:27:55.171] - force: TRUE
[08:27:55.171] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.171] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.171]  - until=2
[08:27:55.171]  - relaying element #2
[08:27:55.171] result() for ClusterFuture ...
[08:27:55.171] - result already collected: FutureResult
[08:27:55.171] result() for ClusterFuture ... done
[08:27:55.171] result() for ClusterFuture ...
[08:27:55.171] - result already collected: FutureResult
[08:27:55.171] result() for ClusterFuture ... done
[08:27:55.171] result() for ClusterFuture ...
[08:27:55.172] - result already collected: FutureResult
[08:27:55.172] result() for ClusterFuture ... done
[08:27:55.172] result() for ClusterFuture ...
[08:27:55.172] - result already collected: FutureResult
[08:27:55.172] result() for ClusterFuture ... done
[08:27:55.172] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.172] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.172] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:55.172]  length: 4 (resolved future 2)
[08:27:55.172] Future #3
[08:27:55.172] result() for ClusterFuture ...
[08:27:55.173] - result already collected: FutureResult
[08:27:55.173] result() for ClusterFuture ... done
[08:27:55.173] result() for ClusterFuture ...
[08:27:55.173] - result already collected: FutureResult
[08:27:55.173] result() for ClusterFuture ... done
[08:27:55.173] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:55.173] - nx: 6
[08:27:55.173] - relay: TRUE
[08:27:55.173] - stdout: TRUE
[08:27:55.173] - signal: TRUE
[08:27:55.173] - resignal: FALSE
[08:27:55.173] - force: TRUE
[08:27:55.173] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.174] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.174]  - until=3
[08:27:55.174]  - relaying element #3
[08:27:55.174] result() for ClusterFuture ...
[08:27:55.174] - result already collected: FutureResult
[08:27:55.174] result() for ClusterFuture ... done
[08:27:55.174] result() for ClusterFuture ...
[08:27:55.174] - result already collected: FutureResult
[08:27:55.174] result() for ClusterFuture ... done
[08:27:55.174] result() for ClusterFuture ...
[08:27:55.174] - result already collected: FutureResult
[08:27:55.174] result() for ClusterFuture ... done
[08:27:55.175] result() for ClusterFuture ...
[08:27:55.175] - result already collected: FutureResult
[08:27:55.175] result() for ClusterFuture ... done
[08:27:55.175] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.175] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.175] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:55.175]  length: 3 (resolved future 3)
[08:27:55.186] signalConditionsASAP(NULL, pos=5) ...
[08:27:55.186] - nx: 6
[08:27:55.186] - relay: TRUE
[08:27:55.186] - stdout: TRUE
[08:27:55.186] - signal: TRUE
[08:27:55.186] - resignal: FALSE
[08:27:55.186] - force: TRUE
[08:27:55.186] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.186] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.187]  - until=6
[08:27:55.187]  - relaying element #4
[08:27:55.187]  - relaying element #6
[08:27:55.187] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.187] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.187] signalConditionsASAP(NULL, pos=5) ... done
[08:27:55.187]  length: 2 (resolved future 5)
[08:27:55.187] signalConditionsASAP(numeric, pos=6) ...
[08:27:55.187] - nx: 6
[08:27:55.187] - relay: TRUE
[08:27:55.188] - stdout: TRUE
[08:27:55.188] - signal: TRUE
[08:27:55.188] - resignal: FALSE
[08:27:55.188] - force: TRUE
[08:27:55.188] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.188] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.188]  - until=6
[08:27:55.189]  - relaying element #4
[08:27:55.189] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.189] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.189] signalConditionsASAP(NULL, pos=6) ... done
[08:27:55.189]  length: 1 (resolved future 6)
[08:27:55.200] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.200] - Validating connection of MultisessionFuture
[08:27:55.200] - received message: FutureResult
[08:27:55.200] - Received FutureResult
[08:27:55.201] - Erased future from FutureRegistry
[08:27:55.201] result() for ClusterFuture ...
[08:27:55.201] - result already collected: FutureResult
[08:27:55.201] result() for ClusterFuture ... done
[08:27:55.201] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.201] Future #4
[08:27:55.201] result() for ClusterFuture ...
[08:27:55.201] - result already collected: FutureResult
[08:27:55.201] result() for ClusterFuture ... done
[08:27:55.201] result() for ClusterFuture ...
[08:27:55.201] - result already collected: FutureResult
[08:27:55.202] result() for ClusterFuture ... done
[08:27:55.202] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:55.202] - nx: 6
[08:27:55.202] - relay: TRUE
[08:27:55.202] - stdout: TRUE
[08:27:55.202] - signal: TRUE
[08:27:55.202] - resignal: FALSE
[08:27:55.202] - force: TRUE
[08:27:55.202] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.202] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.202]  - until=6
[08:27:55.202]  - relaying element #4
[08:27:55.203] result() for ClusterFuture ...
[08:27:55.203] - result already collected: FutureResult
[08:27:55.203] result() for ClusterFuture ... done
[08:27:55.203] result() for ClusterFuture ...
[08:27:55.203] - result already collected: FutureResult
[08:27:55.203] result() for ClusterFuture ... done
[08:27:55.203] result() for ClusterFuture ...
[08:27:55.203] - result already collected: FutureResult
[08:27:55.203] result() for ClusterFuture ... done
[08:27:55.203] result() for ClusterFuture ...
[08:27:55.203] - result already collected: FutureResult
[08:27:55.203] result() for ClusterFuture ... done
[08:27:55.204] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.204] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.204] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:55.204]  length: 0 (resolved future 4)
[08:27:55.204] Relaying remaining futures
[08:27:55.204] signalConditionsASAP(NULL, pos=0) ...
[08:27:55.204] - nx: 6
[08:27:55.204] - relay: TRUE
[08:27:55.204] - stdout: TRUE
[08:27:55.204] - signal: TRUE
[08:27:55.204] - resignal: FALSE
[08:27:55.204] - force: TRUE
[08:27:55.204] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.205] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:55.205] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.205] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.205] signalConditionsASAP(NULL, pos=0) ... done
[08:27:55.205] resolve() on list environment ... DONE
[08:27:55.205] result() for ClusterFuture ...
[08:27:55.205] - result already collected: FutureResult
[08:27:55.205] result() for ClusterFuture ... done
[08:27:55.205] result() for ClusterFuture ...
[08:27:55.205] - result already collected: FutureResult
[08:27:55.205] result() for ClusterFuture ... done
[08:27:55.206] result() for ClusterFuture ...
[08:27:55.206] - result already collected: FutureResult
[08:27:55.206] result() for ClusterFuture ... done
[08:27:55.206] result() for ClusterFuture ...
[08:27:55.206] - result already collected: FutureResult
[08:27:55.206] result() for ClusterFuture ... done
[08:27:55.206] result() for ClusterFuture ...
[08:27:55.206] - result already collected: FutureResult
[08:27:55.206] result() for ClusterFuture ... done
[08:27:55.206] result() for ClusterFuture ...
[08:27:55.207] - result already collected: FutureResult
[08:27:55.207] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d8621a3ad8> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[08:27:55.208] getGlobalsAndPackages() ...
[08:27:55.208] Searching for globals...
[08:27:55.209] 
[08:27:55.209] Searching for globals ... DONE
[08:27:55.209] - globals: [0] <none>
[08:27:55.209] getGlobalsAndPackages() ... DONE
[08:27:55.209] run() for ‘Future’ ...
[08:27:55.209] - state: ‘created’
[08:27:55.210] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.224] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.224] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.224]   - Field: ‘node’
[08:27:55.224]   - Field: ‘label’
[08:27:55.224]   - Field: ‘local’
[08:27:55.224]   - Field: ‘owner’
[08:27:55.224]   - Field: ‘envir’
[08:27:55.224]   - Field: ‘workers’
[08:27:55.225]   - Field: ‘packages’
[08:27:55.225]   - Field: ‘gc’
[08:27:55.225]   - Field: ‘conditions’
[08:27:55.225]   - Field: ‘persistent’
[08:27:55.225]   - Field: ‘expr’
[08:27:55.225]   - Field: ‘uuid’
[08:27:55.225]   - Field: ‘seed’
[08:27:55.225]   - Field: ‘version’
[08:27:55.225]   - Field: ‘result’
[08:27:55.225]   - Field: ‘asynchronous’
[08:27:55.225]   - Field: ‘calls’
[08:27:55.225]   - Field: ‘globals’
[08:27:55.226]   - Field: ‘stdout’
[08:27:55.226]   - Field: ‘earlySignal’
[08:27:55.226]   - Field: ‘lazy’
[08:27:55.226]   - Field: ‘state’
[08:27:55.226] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.226] - Launch lazy future ...
[08:27:55.226] Packages needed by the future expression (n = 0): <none>
[08:27:55.226] Packages needed by future strategies (n = 0): <none>
[08:27:55.227] {
[08:27:55.227]     {
[08:27:55.227]         {
[08:27:55.227]             ...future.startTime <- base::Sys.time()
[08:27:55.227]             {
[08:27:55.227]                 {
[08:27:55.227]                   {
[08:27:55.227]                     {
[08:27:55.227]                       base::local({
[08:27:55.227]                         has_future <- base::requireNamespace("future", 
[08:27:55.227]                           quietly = TRUE)
[08:27:55.227]                         if (has_future) {
[08:27:55.227]                           ns <- base::getNamespace("future")
[08:27:55.227]                           version <- ns[[".package"]][["version"]]
[08:27:55.227]                           if (is.null(version)) 
[08:27:55.227]                             version <- utils::packageVersion("future")
[08:27:55.227]                         }
[08:27:55.227]                         else {
[08:27:55.227]                           version <- NULL
[08:27:55.227]                         }
[08:27:55.227]                         if (!has_future || version < "1.8.0") {
[08:27:55.227]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.227]                             "", base::R.version$version.string), 
[08:27:55.227]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.227]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.227]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.227]                               "release", "version")], collapse = " "), 
[08:27:55.227]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.227]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.227]                             info)
[08:27:55.227]                           info <- base::paste(info, collapse = "; ")
[08:27:55.227]                           if (!has_future) {
[08:27:55.227]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.227]                               info)
[08:27:55.227]                           }
[08:27:55.227]                           else {
[08:27:55.227]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.227]                               info, version)
[08:27:55.227]                           }
[08:27:55.227]                           base::stop(msg)
[08:27:55.227]                         }
[08:27:55.227]                       })
[08:27:55.227]                     }
[08:27:55.227]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.227]                     base::options(mc.cores = 1L)
[08:27:55.227]                   }
[08:27:55.227]                   ...future.strategy.old <- future::plan("list")
[08:27:55.227]                   options(future.plan = NULL)
[08:27:55.227]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.227]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.227]                 }
[08:27:55.227]                 ...future.workdir <- getwd()
[08:27:55.227]             }
[08:27:55.227]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.227]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.227]         }
[08:27:55.227]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.227]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.227]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.227]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.227]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.227]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.227]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.227]             base::names(...future.oldOptions))
[08:27:55.227]     }
[08:27:55.227]     if (FALSE) {
[08:27:55.227]     }
[08:27:55.227]     else {
[08:27:55.227]         if (TRUE) {
[08:27:55.227]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.227]                 open = "w")
[08:27:55.227]         }
[08:27:55.227]         else {
[08:27:55.227]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.227]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.227]         }
[08:27:55.227]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.227]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.227]             base::sink(type = "output", split = FALSE)
[08:27:55.227]             base::close(...future.stdout)
[08:27:55.227]         }, add = TRUE)
[08:27:55.227]     }
[08:27:55.227]     ...future.frame <- base::sys.nframe()
[08:27:55.227]     ...future.conditions <- base::list()
[08:27:55.227]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.227]     if (FALSE) {
[08:27:55.227]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.227]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.227]     }
[08:27:55.227]     ...future.result <- base::tryCatch({
[08:27:55.227]         base::withCallingHandlers({
[08:27:55.227]             ...future.value <- base::withVisible(base::local({
[08:27:55.227]                 ...future.makeSendCondition <- base::local({
[08:27:55.227]                   sendCondition <- NULL
[08:27:55.227]                   function(frame = 1L) {
[08:27:55.227]                     if (is.function(sendCondition)) 
[08:27:55.227]                       return(sendCondition)
[08:27:55.227]                     ns <- getNamespace("parallel")
[08:27:55.227]                     if (exists("sendData", mode = "function", 
[08:27:55.227]                       envir = ns)) {
[08:27:55.227]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.227]                         envir = ns)
[08:27:55.227]                       envir <- sys.frame(frame)
[08:27:55.227]                       master <- NULL
[08:27:55.227]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.227]                         !identical(envir, emptyenv())) {
[08:27:55.227]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.227]                           inherits = FALSE)) {
[08:27:55.227]                           master <- get("master", mode = "list", 
[08:27:55.227]                             envir = envir, inherits = FALSE)
[08:27:55.227]                           if (inherits(master, c("SOCKnode", 
[08:27:55.227]                             "SOCK0node"))) {
[08:27:55.227]                             sendCondition <<- function(cond) {
[08:27:55.227]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.227]                                 success = TRUE)
[08:27:55.227]                               parallel_sendData(master, data)
[08:27:55.227]                             }
[08:27:55.227]                             return(sendCondition)
[08:27:55.227]                           }
[08:27:55.227]                         }
[08:27:55.227]                         frame <- frame + 1L
[08:27:55.227]                         envir <- sys.frame(frame)
[08:27:55.227]                       }
[08:27:55.227]                     }
[08:27:55.227]                     sendCondition <<- function(cond) NULL
[08:27:55.227]                   }
[08:27:55.227]                 })
[08:27:55.227]                 withCallingHandlers({
[08:27:55.227]                   2
[08:27:55.227]                 }, immediateCondition = function(cond) {
[08:27:55.227]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.227]                   sendCondition(cond)
[08:27:55.227]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.227]                   {
[08:27:55.227]                     inherits <- base::inherits
[08:27:55.227]                     invokeRestart <- base::invokeRestart
[08:27:55.227]                     is.null <- base::is.null
[08:27:55.227]                     muffled <- FALSE
[08:27:55.227]                     if (inherits(cond, "message")) {
[08:27:55.227]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.227]                       if (muffled) 
[08:27:55.227]                         invokeRestart("muffleMessage")
[08:27:55.227]                     }
[08:27:55.227]                     else if (inherits(cond, "warning")) {
[08:27:55.227]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.227]                       if (muffled) 
[08:27:55.227]                         invokeRestart("muffleWarning")
[08:27:55.227]                     }
[08:27:55.227]                     else if (inherits(cond, "condition")) {
[08:27:55.227]                       if (!is.null(pattern)) {
[08:27:55.227]                         computeRestarts <- base::computeRestarts
[08:27:55.227]                         grepl <- base::grepl
[08:27:55.227]                         restarts <- computeRestarts(cond)
[08:27:55.227]                         for (restart in restarts) {
[08:27:55.227]                           name <- restart$name
[08:27:55.227]                           if (is.null(name)) 
[08:27:55.227]                             next
[08:27:55.227]                           if (!grepl(pattern, name)) 
[08:27:55.227]                             next
[08:27:55.227]                           invokeRestart(restart)
[08:27:55.227]                           muffled <- TRUE
[08:27:55.227]                           break
[08:27:55.227]                         }
[08:27:55.227]                       }
[08:27:55.227]                     }
[08:27:55.227]                     invisible(muffled)
[08:27:55.227]                   }
[08:27:55.227]                   muffleCondition(cond)
[08:27:55.227]                 })
[08:27:55.227]             }))
[08:27:55.227]             future::FutureResult(value = ...future.value$value, 
[08:27:55.227]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.227]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.227]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.227]                     ...future.globalenv.names))
[08:27:55.227]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.227]         }, condition = base::local({
[08:27:55.227]             c <- base::c
[08:27:55.227]             inherits <- base::inherits
[08:27:55.227]             invokeRestart <- base::invokeRestart
[08:27:55.227]             length <- base::length
[08:27:55.227]             list <- base::list
[08:27:55.227]             seq.int <- base::seq.int
[08:27:55.227]             signalCondition <- base::signalCondition
[08:27:55.227]             sys.calls <- base::sys.calls
[08:27:55.227]             `[[` <- base::`[[`
[08:27:55.227]             `+` <- base::`+`
[08:27:55.227]             `<<-` <- base::`<<-`
[08:27:55.227]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.227]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.227]                   3L)]
[08:27:55.227]             }
[08:27:55.227]             function(cond) {
[08:27:55.227]                 is_error <- inherits(cond, "error")
[08:27:55.227]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.227]                   NULL)
[08:27:55.227]                 if (is_error) {
[08:27:55.227]                   sessionInformation <- function() {
[08:27:55.227]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.227]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.227]                       search = base::search(), system = base::Sys.info())
[08:27:55.227]                   }
[08:27:55.227]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.227]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.227]                     cond$call), session = sessionInformation(), 
[08:27:55.227]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.227]                   signalCondition(cond)
[08:27:55.227]                 }
[08:27:55.227]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.227]                 "immediateCondition"))) {
[08:27:55.227]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.227]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.227]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.227]                   if (TRUE && !signal) {
[08:27:55.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.227]                     {
[08:27:55.227]                       inherits <- base::inherits
[08:27:55.227]                       invokeRestart <- base::invokeRestart
[08:27:55.227]                       is.null <- base::is.null
[08:27:55.227]                       muffled <- FALSE
[08:27:55.227]                       if (inherits(cond, "message")) {
[08:27:55.227]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.227]                         if (muffled) 
[08:27:55.227]                           invokeRestart("muffleMessage")
[08:27:55.227]                       }
[08:27:55.227]                       else if (inherits(cond, "warning")) {
[08:27:55.227]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.227]                         if (muffled) 
[08:27:55.227]                           invokeRestart("muffleWarning")
[08:27:55.227]                       }
[08:27:55.227]                       else if (inherits(cond, "condition")) {
[08:27:55.227]                         if (!is.null(pattern)) {
[08:27:55.227]                           computeRestarts <- base::computeRestarts
[08:27:55.227]                           grepl <- base::grepl
[08:27:55.227]                           restarts <- computeRestarts(cond)
[08:27:55.227]                           for (restart in restarts) {
[08:27:55.227]                             name <- restart$name
[08:27:55.227]                             if (is.null(name)) 
[08:27:55.227]                               next
[08:27:55.227]                             if (!grepl(pattern, name)) 
[08:27:55.227]                               next
[08:27:55.227]                             invokeRestart(restart)
[08:27:55.227]                             muffled <- TRUE
[08:27:55.227]                             break
[08:27:55.227]                           }
[08:27:55.227]                         }
[08:27:55.227]                       }
[08:27:55.227]                       invisible(muffled)
[08:27:55.227]                     }
[08:27:55.227]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.227]                   }
[08:27:55.227]                 }
[08:27:55.227]                 else {
[08:27:55.227]                   if (TRUE) {
[08:27:55.227]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.227]                     {
[08:27:55.227]                       inherits <- base::inherits
[08:27:55.227]                       invokeRestart <- base::invokeRestart
[08:27:55.227]                       is.null <- base::is.null
[08:27:55.227]                       muffled <- FALSE
[08:27:55.227]                       if (inherits(cond, "message")) {
[08:27:55.227]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.227]                         if (muffled) 
[08:27:55.227]                           invokeRestart("muffleMessage")
[08:27:55.227]                       }
[08:27:55.227]                       else if (inherits(cond, "warning")) {
[08:27:55.227]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.227]                         if (muffled) 
[08:27:55.227]                           invokeRestart("muffleWarning")
[08:27:55.227]                       }
[08:27:55.227]                       else if (inherits(cond, "condition")) {
[08:27:55.227]                         if (!is.null(pattern)) {
[08:27:55.227]                           computeRestarts <- base::computeRestarts
[08:27:55.227]                           grepl <- base::grepl
[08:27:55.227]                           restarts <- computeRestarts(cond)
[08:27:55.227]                           for (restart in restarts) {
[08:27:55.227]                             name <- restart$name
[08:27:55.227]                             if (is.null(name)) 
[08:27:55.227]                               next
[08:27:55.227]                             if (!grepl(pattern, name)) 
[08:27:55.227]                               next
[08:27:55.227]                             invokeRestart(restart)
[08:27:55.227]                             muffled <- TRUE
[08:27:55.227]                             break
[08:27:55.227]                           }
[08:27:55.227]                         }
[08:27:55.227]                       }
[08:27:55.227]                       invisible(muffled)
[08:27:55.227]                     }
[08:27:55.227]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.227]                   }
[08:27:55.227]                 }
[08:27:55.227]             }
[08:27:55.227]         }))
[08:27:55.227]     }, error = function(ex) {
[08:27:55.227]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.227]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.227]                 ...future.rng), started = ...future.startTime, 
[08:27:55.227]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.227]             version = "1.8"), class = "FutureResult")
[08:27:55.227]     }, finally = {
[08:27:55.227]         if (!identical(...future.workdir, getwd())) 
[08:27:55.227]             setwd(...future.workdir)
[08:27:55.227]         {
[08:27:55.227]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.227]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.227]             }
[08:27:55.227]             base::options(...future.oldOptions)
[08:27:55.227]             if (.Platform$OS.type == "windows") {
[08:27:55.227]                 old_names <- names(...future.oldEnvVars)
[08:27:55.227]                 envs <- base::Sys.getenv()
[08:27:55.227]                 names <- names(envs)
[08:27:55.227]                 common <- intersect(names, old_names)
[08:27:55.227]                 added <- setdiff(names, old_names)
[08:27:55.227]                 removed <- setdiff(old_names, names)
[08:27:55.227]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.227]                   envs[common]]
[08:27:55.227]                 NAMES <- toupper(changed)
[08:27:55.227]                 args <- list()
[08:27:55.227]                 for (kk in seq_along(NAMES)) {
[08:27:55.227]                   name <- changed[[kk]]
[08:27:55.227]                   NAME <- NAMES[[kk]]
[08:27:55.227]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.227]                     next
[08:27:55.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.227]                 }
[08:27:55.227]                 NAMES <- toupper(added)
[08:27:55.227]                 for (kk in seq_along(NAMES)) {
[08:27:55.227]                   name <- added[[kk]]
[08:27:55.227]                   NAME <- NAMES[[kk]]
[08:27:55.227]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.227]                     next
[08:27:55.227]                   args[[name]] <- ""
[08:27:55.227]                 }
[08:27:55.227]                 NAMES <- toupper(removed)
[08:27:55.227]                 for (kk in seq_along(NAMES)) {
[08:27:55.227]                   name <- removed[[kk]]
[08:27:55.227]                   NAME <- NAMES[[kk]]
[08:27:55.227]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.227]                     next
[08:27:55.227]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.227]                 }
[08:27:55.227]                 if (length(args) > 0) 
[08:27:55.227]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.227]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.227]             }
[08:27:55.227]             else {
[08:27:55.227]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.227]             }
[08:27:55.227]             {
[08:27:55.227]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.227]                   0L) {
[08:27:55.227]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.227]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.227]                   base::options(opts)
[08:27:55.227]                 }
[08:27:55.227]                 {
[08:27:55.227]                   {
[08:27:55.227]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.227]                     NULL
[08:27:55.227]                   }
[08:27:55.227]                   options(future.plan = NULL)
[08:27:55.227]                   if (is.na(NA_character_)) 
[08:27:55.227]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.227]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.227]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.227]                     .init = FALSE)
[08:27:55.227]                 }
[08:27:55.227]             }
[08:27:55.227]         }
[08:27:55.227]     })
[08:27:55.227]     if (TRUE) {
[08:27:55.227]         base::sink(type = "output", split = FALSE)
[08:27:55.227]         if (TRUE) {
[08:27:55.227]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.227]         }
[08:27:55.227]         else {
[08:27:55.227]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.227]         }
[08:27:55.227]         base::close(...future.stdout)
[08:27:55.227]         ...future.stdout <- NULL
[08:27:55.227]     }
[08:27:55.227]     ...future.result$conditions <- ...future.conditions
[08:27:55.227]     ...future.result$finished <- base::Sys.time()
[08:27:55.227]     ...future.result
[08:27:55.227] }
[08:27:55.230] MultisessionFuture started
[08:27:55.230] - Launch lazy future ... done
[08:27:55.230] run() for ‘MultisessionFuture’ ... done
[08:27:55.230] getGlobalsAndPackages() ...
[08:27:55.231] Searching for globals...
[08:27:55.231] 
[08:27:55.231] Searching for globals ... DONE
[08:27:55.231] - globals: [0] <none>
[08:27:55.231] getGlobalsAndPackages() ... DONE
[08:27:55.231] run() for ‘Future’ ...
[08:27:55.231] - state: ‘created’
[08:27:55.232] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.254] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.254] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.254]   - Field: ‘node’
[08:27:55.254]   - Field: ‘label’
[08:27:55.254]   - Field: ‘local’
[08:27:55.254]   - Field: ‘owner’
[08:27:55.254]   - Field: ‘envir’
[08:27:55.254]   - Field: ‘workers’
[08:27:55.254]   - Field: ‘packages’
[08:27:55.255]   - Field: ‘gc’
[08:27:55.255]   - Field: ‘conditions’
[08:27:55.255]   - Field: ‘persistent’
[08:27:55.255]   - Field: ‘expr’
[08:27:55.255]   - Field: ‘uuid’
[08:27:55.255]   - Field: ‘seed’
[08:27:55.255]   - Field: ‘version’
[08:27:55.255]   - Field: ‘result’
[08:27:55.255]   - Field: ‘asynchronous’
[08:27:55.255]   - Field: ‘calls’
[08:27:55.255]   - Field: ‘globals’
[08:27:55.255]   - Field: ‘stdout’
[08:27:55.255]   - Field: ‘earlySignal’
[08:27:55.256]   - Field: ‘lazy’
[08:27:55.256]   - Field: ‘state’
[08:27:55.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.256] - Launch lazy future ...
[08:27:55.256] Packages needed by the future expression (n = 0): <none>
[08:27:55.256] Packages needed by future strategies (n = 0): <none>
[08:27:55.257] {
[08:27:55.257]     {
[08:27:55.257]         {
[08:27:55.257]             ...future.startTime <- base::Sys.time()
[08:27:55.257]             {
[08:27:55.257]                 {
[08:27:55.257]                   {
[08:27:55.257]                     {
[08:27:55.257]                       base::local({
[08:27:55.257]                         has_future <- base::requireNamespace("future", 
[08:27:55.257]                           quietly = TRUE)
[08:27:55.257]                         if (has_future) {
[08:27:55.257]                           ns <- base::getNamespace("future")
[08:27:55.257]                           version <- ns[[".package"]][["version"]]
[08:27:55.257]                           if (is.null(version)) 
[08:27:55.257]                             version <- utils::packageVersion("future")
[08:27:55.257]                         }
[08:27:55.257]                         else {
[08:27:55.257]                           version <- NULL
[08:27:55.257]                         }
[08:27:55.257]                         if (!has_future || version < "1.8.0") {
[08:27:55.257]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.257]                             "", base::R.version$version.string), 
[08:27:55.257]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.257]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.257]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.257]                               "release", "version")], collapse = " "), 
[08:27:55.257]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.257]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.257]                             info)
[08:27:55.257]                           info <- base::paste(info, collapse = "; ")
[08:27:55.257]                           if (!has_future) {
[08:27:55.257]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.257]                               info)
[08:27:55.257]                           }
[08:27:55.257]                           else {
[08:27:55.257]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.257]                               info, version)
[08:27:55.257]                           }
[08:27:55.257]                           base::stop(msg)
[08:27:55.257]                         }
[08:27:55.257]                       })
[08:27:55.257]                     }
[08:27:55.257]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.257]                     base::options(mc.cores = 1L)
[08:27:55.257]                   }
[08:27:55.257]                   ...future.strategy.old <- future::plan("list")
[08:27:55.257]                   options(future.plan = NULL)
[08:27:55.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.257]                 }
[08:27:55.257]                 ...future.workdir <- getwd()
[08:27:55.257]             }
[08:27:55.257]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.257]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.257]         }
[08:27:55.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.257]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.257]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.257]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.257]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.257]             base::names(...future.oldOptions))
[08:27:55.257]     }
[08:27:55.257]     if (FALSE) {
[08:27:55.257]     }
[08:27:55.257]     else {
[08:27:55.257]         if (TRUE) {
[08:27:55.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.257]                 open = "w")
[08:27:55.257]         }
[08:27:55.257]         else {
[08:27:55.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.257]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.257]         }
[08:27:55.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.257]             base::sink(type = "output", split = FALSE)
[08:27:55.257]             base::close(...future.stdout)
[08:27:55.257]         }, add = TRUE)
[08:27:55.257]     }
[08:27:55.257]     ...future.frame <- base::sys.nframe()
[08:27:55.257]     ...future.conditions <- base::list()
[08:27:55.257]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.257]     if (FALSE) {
[08:27:55.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.257]     }
[08:27:55.257]     ...future.result <- base::tryCatch({
[08:27:55.257]         base::withCallingHandlers({
[08:27:55.257]             ...future.value <- base::withVisible(base::local({
[08:27:55.257]                 ...future.makeSendCondition <- base::local({
[08:27:55.257]                   sendCondition <- NULL
[08:27:55.257]                   function(frame = 1L) {
[08:27:55.257]                     if (is.function(sendCondition)) 
[08:27:55.257]                       return(sendCondition)
[08:27:55.257]                     ns <- getNamespace("parallel")
[08:27:55.257]                     if (exists("sendData", mode = "function", 
[08:27:55.257]                       envir = ns)) {
[08:27:55.257]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.257]                         envir = ns)
[08:27:55.257]                       envir <- sys.frame(frame)
[08:27:55.257]                       master <- NULL
[08:27:55.257]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.257]                         !identical(envir, emptyenv())) {
[08:27:55.257]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.257]                           inherits = FALSE)) {
[08:27:55.257]                           master <- get("master", mode = "list", 
[08:27:55.257]                             envir = envir, inherits = FALSE)
[08:27:55.257]                           if (inherits(master, c("SOCKnode", 
[08:27:55.257]                             "SOCK0node"))) {
[08:27:55.257]                             sendCondition <<- function(cond) {
[08:27:55.257]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.257]                                 success = TRUE)
[08:27:55.257]                               parallel_sendData(master, data)
[08:27:55.257]                             }
[08:27:55.257]                             return(sendCondition)
[08:27:55.257]                           }
[08:27:55.257]                         }
[08:27:55.257]                         frame <- frame + 1L
[08:27:55.257]                         envir <- sys.frame(frame)
[08:27:55.257]                       }
[08:27:55.257]                     }
[08:27:55.257]                     sendCondition <<- function(cond) NULL
[08:27:55.257]                   }
[08:27:55.257]                 })
[08:27:55.257]                 withCallingHandlers({
[08:27:55.257]                   NULL
[08:27:55.257]                 }, immediateCondition = function(cond) {
[08:27:55.257]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.257]                   sendCondition(cond)
[08:27:55.257]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.257]                   {
[08:27:55.257]                     inherits <- base::inherits
[08:27:55.257]                     invokeRestart <- base::invokeRestart
[08:27:55.257]                     is.null <- base::is.null
[08:27:55.257]                     muffled <- FALSE
[08:27:55.257]                     if (inherits(cond, "message")) {
[08:27:55.257]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.257]                       if (muffled) 
[08:27:55.257]                         invokeRestart("muffleMessage")
[08:27:55.257]                     }
[08:27:55.257]                     else if (inherits(cond, "warning")) {
[08:27:55.257]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.257]                       if (muffled) 
[08:27:55.257]                         invokeRestart("muffleWarning")
[08:27:55.257]                     }
[08:27:55.257]                     else if (inherits(cond, "condition")) {
[08:27:55.257]                       if (!is.null(pattern)) {
[08:27:55.257]                         computeRestarts <- base::computeRestarts
[08:27:55.257]                         grepl <- base::grepl
[08:27:55.257]                         restarts <- computeRestarts(cond)
[08:27:55.257]                         for (restart in restarts) {
[08:27:55.257]                           name <- restart$name
[08:27:55.257]                           if (is.null(name)) 
[08:27:55.257]                             next
[08:27:55.257]                           if (!grepl(pattern, name)) 
[08:27:55.257]                             next
[08:27:55.257]                           invokeRestart(restart)
[08:27:55.257]                           muffled <- TRUE
[08:27:55.257]                           break
[08:27:55.257]                         }
[08:27:55.257]                       }
[08:27:55.257]                     }
[08:27:55.257]                     invisible(muffled)
[08:27:55.257]                   }
[08:27:55.257]                   muffleCondition(cond)
[08:27:55.257]                 })
[08:27:55.257]             }))
[08:27:55.257]             future::FutureResult(value = ...future.value$value, 
[08:27:55.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.257]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.257]                     ...future.globalenv.names))
[08:27:55.257]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.257]         }, condition = base::local({
[08:27:55.257]             c <- base::c
[08:27:55.257]             inherits <- base::inherits
[08:27:55.257]             invokeRestart <- base::invokeRestart
[08:27:55.257]             length <- base::length
[08:27:55.257]             list <- base::list
[08:27:55.257]             seq.int <- base::seq.int
[08:27:55.257]             signalCondition <- base::signalCondition
[08:27:55.257]             sys.calls <- base::sys.calls
[08:27:55.257]             `[[` <- base::`[[`
[08:27:55.257]             `+` <- base::`+`
[08:27:55.257]             `<<-` <- base::`<<-`
[08:27:55.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.257]                   3L)]
[08:27:55.257]             }
[08:27:55.257]             function(cond) {
[08:27:55.257]                 is_error <- inherits(cond, "error")
[08:27:55.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.257]                   NULL)
[08:27:55.257]                 if (is_error) {
[08:27:55.257]                   sessionInformation <- function() {
[08:27:55.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.257]                       search = base::search(), system = base::Sys.info())
[08:27:55.257]                   }
[08:27:55.257]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.257]                     cond$call), session = sessionInformation(), 
[08:27:55.257]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.257]                   signalCondition(cond)
[08:27:55.257]                 }
[08:27:55.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.257]                 "immediateCondition"))) {
[08:27:55.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.257]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.257]                   if (TRUE && !signal) {
[08:27:55.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.257]                     {
[08:27:55.257]                       inherits <- base::inherits
[08:27:55.257]                       invokeRestart <- base::invokeRestart
[08:27:55.257]                       is.null <- base::is.null
[08:27:55.257]                       muffled <- FALSE
[08:27:55.257]                       if (inherits(cond, "message")) {
[08:27:55.257]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.257]                         if (muffled) 
[08:27:55.257]                           invokeRestart("muffleMessage")
[08:27:55.257]                       }
[08:27:55.257]                       else if (inherits(cond, "warning")) {
[08:27:55.257]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.257]                         if (muffled) 
[08:27:55.257]                           invokeRestart("muffleWarning")
[08:27:55.257]                       }
[08:27:55.257]                       else if (inherits(cond, "condition")) {
[08:27:55.257]                         if (!is.null(pattern)) {
[08:27:55.257]                           computeRestarts <- base::computeRestarts
[08:27:55.257]                           grepl <- base::grepl
[08:27:55.257]                           restarts <- computeRestarts(cond)
[08:27:55.257]                           for (restart in restarts) {
[08:27:55.257]                             name <- restart$name
[08:27:55.257]                             if (is.null(name)) 
[08:27:55.257]                               next
[08:27:55.257]                             if (!grepl(pattern, name)) 
[08:27:55.257]                               next
[08:27:55.257]                             invokeRestart(restart)
[08:27:55.257]                             muffled <- TRUE
[08:27:55.257]                             break
[08:27:55.257]                           }
[08:27:55.257]                         }
[08:27:55.257]                       }
[08:27:55.257]                       invisible(muffled)
[08:27:55.257]                     }
[08:27:55.257]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.257]                   }
[08:27:55.257]                 }
[08:27:55.257]                 else {
[08:27:55.257]                   if (TRUE) {
[08:27:55.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.257]                     {
[08:27:55.257]                       inherits <- base::inherits
[08:27:55.257]                       invokeRestart <- base::invokeRestart
[08:27:55.257]                       is.null <- base::is.null
[08:27:55.257]                       muffled <- FALSE
[08:27:55.257]                       if (inherits(cond, "message")) {
[08:27:55.257]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.257]                         if (muffled) 
[08:27:55.257]                           invokeRestart("muffleMessage")
[08:27:55.257]                       }
[08:27:55.257]                       else if (inherits(cond, "warning")) {
[08:27:55.257]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.257]                         if (muffled) 
[08:27:55.257]                           invokeRestart("muffleWarning")
[08:27:55.257]                       }
[08:27:55.257]                       else if (inherits(cond, "condition")) {
[08:27:55.257]                         if (!is.null(pattern)) {
[08:27:55.257]                           computeRestarts <- base::computeRestarts
[08:27:55.257]                           grepl <- base::grepl
[08:27:55.257]                           restarts <- computeRestarts(cond)
[08:27:55.257]                           for (restart in restarts) {
[08:27:55.257]                             name <- restart$name
[08:27:55.257]                             if (is.null(name)) 
[08:27:55.257]                               next
[08:27:55.257]                             if (!grepl(pattern, name)) 
[08:27:55.257]                               next
[08:27:55.257]                             invokeRestart(restart)
[08:27:55.257]                             muffled <- TRUE
[08:27:55.257]                             break
[08:27:55.257]                           }
[08:27:55.257]                         }
[08:27:55.257]                       }
[08:27:55.257]                       invisible(muffled)
[08:27:55.257]                     }
[08:27:55.257]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.257]                   }
[08:27:55.257]                 }
[08:27:55.257]             }
[08:27:55.257]         }))
[08:27:55.257]     }, error = function(ex) {
[08:27:55.257]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.257]                 ...future.rng), started = ...future.startTime, 
[08:27:55.257]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.257]             version = "1.8"), class = "FutureResult")
[08:27:55.257]     }, finally = {
[08:27:55.257]         if (!identical(...future.workdir, getwd())) 
[08:27:55.257]             setwd(...future.workdir)
[08:27:55.257]         {
[08:27:55.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.257]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.257]             }
[08:27:55.257]             base::options(...future.oldOptions)
[08:27:55.257]             if (.Platform$OS.type == "windows") {
[08:27:55.257]                 old_names <- names(...future.oldEnvVars)
[08:27:55.257]                 envs <- base::Sys.getenv()
[08:27:55.257]                 names <- names(envs)
[08:27:55.257]                 common <- intersect(names, old_names)
[08:27:55.257]                 added <- setdiff(names, old_names)
[08:27:55.257]                 removed <- setdiff(old_names, names)
[08:27:55.257]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.257]                   envs[common]]
[08:27:55.257]                 NAMES <- toupper(changed)
[08:27:55.257]                 args <- list()
[08:27:55.257]                 for (kk in seq_along(NAMES)) {
[08:27:55.257]                   name <- changed[[kk]]
[08:27:55.257]                   NAME <- NAMES[[kk]]
[08:27:55.257]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.257]                     next
[08:27:55.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.257]                 }
[08:27:55.257]                 NAMES <- toupper(added)
[08:27:55.257]                 for (kk in seq_along(NAMES)) {
[08:27:55.257]                   name <- added[[kk]]
[08:27:55.257]                   NAME <- NAMES[[kk]]
[08:27:55.257]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.257]                     next
[08:27:55.257]                   args[[name]] <- ""
[08:27:55.257]                 }
[08:27:55.257]                 NAMES <- toupper(removed)
[08:27:55.257]                 for (kk in seq_along(NAMES)) {
[08:27:55.257]                   name <- removed[[kk]]
[08:27:55.257]                   NAME <- NAMES[[kk]]
[08:27:55.257]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.257]                     next
[08:27:55.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.257]                 }
[08:27:55.257]                 if (length(args) > 0) 
[08:27:55.257]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.257]             }
[08:27:55.257]             else {
[08:27:55.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.257]             }
[08:27:55.257]             {
[08:27:55.257]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.257]                   0L) {
[08:27:55.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.257]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.257]                   base::options(opts)
[08:27:55.257]                 }
[08:27:55.257]                 {
[08:27:55.257]                   {
[08:27:55.257]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.257]                     NULL
[08:27:55.257]                   }
[08:27:55.257]                   options(future.plan = NULL)
[08:27:55.257]                   if (is.na(NA_character_)) 
[08:27:55.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.257]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.257]                     .init = FALSE)
[08:27:55.257]                 }
[08:27:55.257]             }
[08:27:55.257]         }
[08:27:55.257]     })
[08:27:55.257]     if (TRUE) {
[08:27:55.257]         base::sink(type = "output", split = FALSE)
[08:27:55.257]         if (TRUE) {
[08:27:55.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.257]         }
[08:27:55.257]         else {
[08:27:55.257]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.257]         }
[08:27:55.257]         base::close(...future.stdout)
[08:27:55.257]         ...future.stdout <- NULL
[08:27:55.257]     }
[08:27:55.257]     ...future.result$conditions <- ...future.conditions
[08:27:55.257]     ...future.result$finished <- base::Sys.time()
[08:27:55.257]     ...future.result
[08:27:55.257] }
[08:27:55.260] MultisessionFuture started
[08:27:55.260] - Launch lazy future ... done
[08:27:55.260] run() for ‘MultisessionFuture’ ... done
[08:27:55.260] getGlobalsAndPackages() ...
[08:27:55.261] Searching for globals...
[08:27:55.261] - globals found: [1] ‘{’
[08:27:55.261] Searching for globals ... DONE
[08:27:55.261] Resolving globals: FALSE
[08:27:55.262] 
[08:27:55.262] 
[08:27:55.262] getGlobalsAndPackages() ... DONE
[08:27:55.262] run() for ‘Future’ ...
[08:27:55.262] - state: ‘created’
[08:27:55.262] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.277] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.277]   - Field: ‘node’
[08:27:55.277]   - Field: ‘label’
[08:27:55.277]   - Field: ‘local’
[08:27:55.277]   - Field: ‘owner’
[08:27:55.277]   - Field: ‘envir’
[08:27:55.277]   - Field: ‘workers’
[08:27:55.278]   - Field: ‘packages’
[08:27:55.278]   - Field: ‘gc’
[08:27:55.278]   - Field: ‘conditions’
[08:27:55.278]   - Field: ‘persistent’
[08:27:55.278]   - Field: ‘expr’
[08:27:55.278]   - Field: ‘uuid’
[08:27:55.278]   - Field: ‘seed’
[08:27:55.278]   - Field: ‘version’
[08:27:55.278]   - Field: ‘result’
[08:27:55.278]   - Field: ‘asynchronous’
[08:27:55.278]   - Field: ‘calls’
[08:27:55.278]   - Field: ‘globals’
[08:27:55.279]   - Field: ‘stdout’
[08:27:55.279]   - Field: ‘earlySignal’
[08:27:55.279]   - Field: ‘lazy’
[08:27:55.279]   - Field: ‘state’
[08:27:55.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.279] - Launch lazy future ...
[08:27:55.279] Packages needed by the future expression (n = 0): <none>
[08:27:55.279] Packages needed by future strategies (n = 0): <none>
[08:27:55.280] {
[08:27:55.280]     {
[08:27:55.280]         {
[08:27:55.280]             ...future.startTime <- base::Sys.time()
[08:27:55.280]             {
[08:27:55.280]                 {
[08:27:55.280]                   {
[08:27:55.280]                     {
[08:27:55.280]                       base::local({
[08:27:55.280]                         has_future <- base::requireNamespace("future", 
[08:27:55.280]                           quietly = TRUE)
[08:27:55.280]                         if (has_future) {
[08:27:55.280]                           ns <- base::getNamespace("future")
[08:27:55.280]                           version <- ns[[".package"]][["version"]]
[08:27:55.280]                           if (is.null(version)) 
[08:27:55.280]                             version <- utils::packageVersion("future")
[08:27:55.280]                         }
[08:27:55.280]                         else {
[08:27:55.280]                           version <- NULL
[08:27:55.280]                         }
[08:27:55.280]                         if (!has_future || version < "1.8.0") {
[08:27:55.280]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.280]                             "", base::R.version$version.string), 
[08:27:55.280]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.280]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.280]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.280]                               "release", "version")], collapse = " "), 
[08:27:55.280]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.280]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.280]                             info)
[08:27:55.280]                           info <- base::paste(info, collapse = "; ")
[08:27:55.280]                           if (!has_future) {
[08:27:55.280]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.280]                               info)
[08:27:55.280]                           }
[08:27:55.280]                           else {
[08:27:55.280]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.280]                               info, version)
[08:27:55.280]                           }
[08:27:55.280]                           base::stop(msg)
[08:27:55.280]                         }
[08:27:55.280]                       })
[08:27:55.280]                     }
[08:27:55.280]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.280]                     base::options(mc.cores = 1L)
[08:27:55.280]                   }
[08:27:55.280]                   ...future.strategy.old <- future::plan("list")
[08:27:55.280]                   options(future.plan = NULL)
[08:27:55.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.280]                 }
[08:27:55.280]                 ...future.workdir <- getwd()
[08:27:55.280]             }
[08:27:55.280]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.280]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.280]         }
[08:27:55.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.280]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.280]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.280]             base::names(...future.oldOptions))
[08:27:55.280]     }
[08:27:55.280]     if (FALSE) {
[08:27:55.280]     }
[08:27:55.280]     else {
[08:27:55.280]         if (TRUE) {
[08:27:55.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.280]                 open = "w")
[08:27:55.280]         }
[08:27:55.280]         else {
[08:27:55.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.280]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.280]         }
[08:27:55.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.280]             base::sink(type = "output", split = FALSE)
[08:27:55.280]             base::close(...future.stdout)
[08:27:55.280]         }, add = TRUE)
[08:27:55.280]     }
[08:27:55.280]     ...future.frame <- base::sys.nframe()
[08:27:55.280]     ...future.conditions <- base::list()
[08:27:55.280]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.280]     if (FALSE) {
[08:27:55.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.280]     }
[08:27:55.280]     ...future.result <- base::tryCatch({
[08:27:55.280]         base::withCallingHandlers({
[08:27:55.280]             ...future.value <- base::withVisible(base::local({
[08:27:55.280]                 ...future.makeSendCondition <- base::local({
[08:27:55.280]                   sendCondition <- NULL
[08:27:55.280]                   function(frame = 1L) {
[08:27:55.280]                     if (is.function(sendCondition)) 
[08:27:55.280]                       return(sendCondition)
[08:27:55.280]                     ns <- getNamespace("parallel")
[08:27:55.280]                     if (exists("sendData", mode = "function", 
[08:27:55.280]                       envir = ns)) {
[08:27:55.280]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.280]                         envir = ns)
[08:27:55.280]                       envir <- sys.frame(frame)
[08:27:55.280]                       master <- NULL
[08:27:55.280]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.280]                         !identical(envir, emptyenv())) {
[08:27:55.280]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.280]                           inherits = FALSE)) {
[08:27:55.280]                           master <- get("master", mode = "list", 
[08:27:55.280]                             envir = envir, inherits = FALSE)
[08:27:55.280]                           if (inherits(master, c("SOCKnode", 
[08:27:55.280]                             "SOCK0node"))) {
[08:27:55.280]                             sendCondition <<- function(cond) {
[08:27:55.280]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.280]                                 success = TRUE)
[08:27:55.280]                               parallel_sendData(master, data)
[08:27:55.280]                             }
[08:27:55.280]                             return(sendCondition)
[08:27:55.280]                           }
[08:27:55.280]                         }
[08:27:55.280]                         frame <- frame + 1L
[08:27:55.280]                         envir <- sys.frame(frame)
[08:27:55.280]                       }
[08:27:55.280]                     }
[08:27:55.280]                     sendCondition <<- function(cond) NULL
[08:27:55.280]                   }
[08:27:55.280]                 })
[08:27:55.280]                 withCallingHandlers({
[08:27:55.280]                   {
[08:27:55.280]                     4
[08:27:55.280]                   }
[08:27:55.280]                 }, immediateCondition = function(cond) {
[08:27:55.280]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.280]                   sendCondition(cond)
[08:27:55.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.280]                   {
[08:27:55.280]                     inherits <- base::inherits
[08:27:55.280]                     invokeRestart <- base::invokeRestart
[08:27:55.280]                     is.null <- base::is.null
[08:27:55.280]                     muffled <- FALSE
[08:27:55.280]                     if (inherits(cond, "message")) {
[08:27:55.280]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.280]                       if (muffled) 
[08:27:55.280]                         invokeRestart("muffleMessage")
[08:27:55.280]                     }
[08:27:55.280]                     else if (inherits(cond, "warning")) {
[08:27:55.280]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.280]                       if (muffled) 
[08:27:55.280]                         invokeRestart("muffleWarning")
[08:27:55.280]                     }
[08:27:55.280]                     else if (inherits(cond, "condition")) {
[08:27:55.280]                       if (!is.null(pattern)) {
[08:27:55.280]                         computeRestarts <- base::computeRestarts
[08:27:55.280]                         grepl <- base::grepl
[08:27:55.280]                         restarts <- computeRestarts(cond)
[08:27:55.280]                         for (restart in restarts) {
[08:27:55.280]                           name <- restart$name
[08:27:55.280]                           if (is.null(name)) 
[08:27:55.280]                             next
[08:27:55.280]                           if (!grepl(pattern, name)) 
[08:27:55.280]                             next
[08:27:55.280]                           invokeRestart(restart)
[08:27:55.280]                           muffled <- TRUE
[08:27:55.280]                           break
[08:27:55.280]                         }
[08:27:55.280]                       }
[08:27:55.280]                     }
[08:27:55.280]                     invisible(muffled)
[08:27:55.280]                   }
[08:27:55.280]                   muffleCondition(cond)
[08:27:55.280]                 })
[08:27:55.280]             }))
[08:27:55.280]             future::FutureResult(value = ...future.value$value, 
[08:27:55.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.280]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.280]                     ...future.globalenv.names))
[08:27:55.280]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.280]         }, condition = base::local({
[08:27:55.280]             c <- base::c
[08:27:55.280]             inherits <- base::inherits
[08:27:55.280]             invokeRestart <- base::invokeRestart
[08:27:55.280]             length <- base::length
[08:27:55.280]             list <- base::list
[08:27:55.280]             seq.int <- base::seq.int
[08:27:55.280]             signalCondition <- base::signalCondition
[08:27:55.280]             sys.calls <- base::sys.calls
[08:27:55.280]             `[[` <- base::`[[`
[08:27:55.280]             `+` <- base::`+`
[08:27:55.280]             `<<-` <- base::`<<-`
[08:27:55.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.280]                   3L)]
[08:27:55.280]             }
[08:27:55.280]             function(cond) {
[08:27:55.280]                 is_error <- inherits(cond, "error")
[08:27:55.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.280]                   NULL)
[08:27:55.280]                 if (is_error) {
[08:27:55.280]                   sessionInformation <- function() {
[08:27:55.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.280]                       search = base::search(), system = base::Sys.info())
[08:27:55.280]                   }
[08:27:55.280]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.280]                     cond$call), session = sessionInformation(), 
[08:27:55.280]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.280]                   signalCondition(cond)
[08:27:55.280]                 }
[08:27:55.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.280]                 "immediateCondition"))) {
[08:27:55.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.280]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.280]                   if (TRUE && !signal) {
[08:27:55.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.280]                     {
[08:27:55.280]                       inherits <- base::inherits
[08:27:55.280]                       invokeRestart <- base::invokeRestart
[08:27:55.280]                       is.null <- base::is.null
[08:27:55.280]                       muffled <- FALSE
[08:27:55.280]                       if (inherits(cond, "message")) {
[08:27:55.280]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.280]                         if (muffled) 
[08:27:55.280]                           invokeRestart("muffleMessage")
[08:27:55.280]                       }
[08:27:55.280]                       else if (inherits(cond, "warning")) {
[08:27:55.280]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.280]                         if (muffled) 
[08:27:55.280]                           invokeRestart("muffleWarning")
[08:27:55.280]                       }
[08:27:55.280]                       else if (inherits(cond, "condition")) {
[08:27:55.280]                         if (!is.null(pattern)) {
[08:27:55.280]                           computeRestarts <- base::computeRestarts
[08:27:55.280]                           grepl <- base::grepl
[08:27:55.280]                           restarts <- computeRestarts(cond)
[08:27:55.280]                           for (restart in restarts) {
[08:27:55.280]                             name <- restart$name
[08:27:55.280]                             if (is.null(name)) 
[08:27:55.280]                               next
[08:27:55.280]                             if (!grepl(pattern, name)) 
[08:27:55.280]                               next
[08:27:55.280]                             invokeRestart(restart)
[08:27:55.280]                             muffled <- TRUE
[08:27:55.280]                             break
[08:27:55.280]                           }
[08:27:55.280]                         }
[08:27:55.280]                       }
[08:27:55.280]                       invisible(muffled)
[08:27:55.280]                     }
[08:27:55.280]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.280]                   }
[08:27:55.280]                 }
[08:27:55.280]                 else {
[08:27:55.280]                   if (TRUE) {
[08:27:55.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.280]                     {
[08:27:55.280]                       inherits <- base::inherits
[08:27:55.280]                       invokeRestart <- base::invokeRestart
[08:27:55.280]                       is.null <- base::is.null
[08:27:55.280]                       muffled <- FALSE
[08:27:55.280]                       if (inherits(cond, "message")) {
[08:27:55.280]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.280]                         if (muffled) 
[08:27:55.280]                           invokeRestart("muffleMessage")
[08:27:55.280]                       }
[08:27:55.280]                       else if (inherits(cond, "warning")) {
[08:27:55.280]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.280]                         if (muffled) 
[08:27:55.280]                           invokeRestart("muffleWarning")
[08:27:55.280]                       }
[08:27:55.280]                       else if (inherits(cond, "condition")) {
[08:27:55.280]                         if (!is.null(pattern)) {
[08:27:55.280]                           computeRestarts <- base::computeRestarts
[08:27:55.280]                           grepl <- base::grepl
[08:27:55.280]                           restarts <- computeRestarts(cond)
[08:27:55.280]                           for (restart in restarts) {
[08:27:55.280]                             name <- restart$name
[08:27:55.280]                             if (is.null(name)) 
[08:27:55.280]                               next
[08:27:55.280]                             if (!grepl(pattern, name)) 
[08:27:55.280]                               next
[08:27:55.280]                             invokeRestart(restart)
[08:27:55.280]                             muffled <- TRUE
[08:27:55.280]                             break
[08:27:55.280]                           }
[08:27:55.280]                         }
[08:27:55.280]                       }
[08:27:55.280]                       invisible(muffled)
[08:27:55.280]                     }
[08:27:55.280]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.280]                   }
[08:27:55.280]                 }
[08:27:55.280]             }
[08:27:55.280]         }))
[08:27:55.280]     }, error = function(ex) {
[08:27:55.280]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.280]                 ...future.rng), started = ...future.startTime, 
[08:27:55.280]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.280]             version = "1.8"), class = "FutureResult")
[08:27:55.280]     }, finally = {
[08:27:55.280]         if (!identical(...future.workdir, getwd())) 
[08:27:55.280]             setwd(...future.workdir)
[08:27:55.280]         {
[08:27:55.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.280]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.280]             }
[08:27:55.280]             base::options(...future.oldOptions)
[08:27:55.280]             if (.Platform$OS.type == "windows") {
[08:27:55.280]                 old_names <- names(...future.oldEnvVars)
[08:27:55.280]                 envs <- base::Sys.getenv()
[08:27:55.280]                 names <- names(envs)
[08:27:55.280]                 common <- intersect(names, old_names)
[08:27:55.280]                 added <- setdiff(names, old_names)
[08:27:55.280]                 removed <- setdiff(old_names, names)
[08:27:55.280]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.280]                   envs[common]]
[08:27:55.280]                 NAMES <- toupper(changed)
[08:27:55.280]                 args <- list()
[08:27:55.280]                 for (kk in seq_along(NAMES)) {
[08:27:55.280]                   name <- changed[[kk]]
[08:27:55.280]                   NAME <- NAMES[[kk]]
[08:27:55.280]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.280]                     next
[08:27:55.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.280]                 }
[08:27:55.280]                 NAMES <- toupper(added)
[08:27:55.280]                 for (kk in seq_along(NAMES)) {
[08:27:55.280]                   name <- added[[kk]]
[08:27:55.280]                   NAME <- NAMES[[kk]]
[08:27:55.280]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.280]                     next
[08:27:55.280]                   args[[name]] <- ""
[08:27:55.280]                 }
[08:27:55.280]                 NAMES <- toupper(removed)
[08:27:55.280]                 for (kk in seq_along(NAMES)) {
[08:27:55.280]                   name <- removed[[kk]]
[08:27:55.280]                   NAME <- NAMES[[kk]]
[08:27:55.280]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.280]                     next
[08:27:55.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.280]                 }
[08:27:55.280]                 if (length(args) > 0) 
[08:27:55.280]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.280]             }
[08:27:55.280]             else {
[08:27:55.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.280]             }
[08:27:55.280]             {
[08:27:55.280]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.280]                   0L) {
[08:27:55.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.280]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.280]                   base::options(opts)
[08:27:55.280]                 }
[08:27:55.280]                 {
[08:27:55.280]                   {
[08:27:55.280]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.280]                     NULL
[08:27:55.280]                   }
[08:27:55.280]                   options(future.plan = NULL)
[08:27:55.280]                   if (is.na(NA_character_)) 
[08:27:55.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.280]                     .init = FALSE)
[08:27:55.280]                 }
[08:27:55.280]             }
[08:27:55.280]         }
[08:27:55.280]     })
[08:27:55.280]     if (TRUE) {
[08:27:55.280]         base::sink(type = "output", split = FALSE)
[08:27:55.280]         if (TRUE) {
[08:27:55.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.280]         }
[08:27:55.280]         else {
[08:27:55.280]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.280]         }
[08:27:55.280]         base::close(...future.stdout)
[08:27:55.280]         ...future.stdout <- NULL
[08:27:55.280]     }
[08:27:55.280]     ...future.result$conditions <- ...future.conditions
[08:27:55.280]     ...future.result$finished <- base::Sys.time()
[08:27:55.280]     ...future.result
[08:27:55.280] }
[08:27:55.282] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:55.293] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.293] - Validating connection of MultisessionFuture
[08:27:55.293] - received message: FutureResult
[08:27:55.293] - Received FutureResult
[08:27:55.293] - Erased future from FutureRegistry
[08:27:55.294] result() for ClusterFuture ...
[08:27:55.294] - result already collected: FutureResult
[08:27:55.294] result() for ClusterFuture ... done
[08:27:55.294] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.294] result() for ClusterFuture ...
[08:27:55.294] - result already collected: FutureResult
[08:27:55.294] result() for ClusterFuture ... done
[08:27:55.294] result() for ClusterFuture ...
[08:27:55.294] - result already collected: FutureResult
[08:27:55.294] result() for ClusterFuture ... done
[08:27:55.295] MultisessionFuture started
[08:27:55.296] - Launch lazy future ... done
[08:27:55.296] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d862bf0f78> 
Classes 'listenv', 'environment' <environment: 0x55d860687e78> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[08:27:55.302] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.302] - Validating connection of MultisessionFuture
[08:27:55.303] - received message: FutureResult
[08:27:55.303] - Received FutureResult
[08:27:55.303] - Erased future from FutureRegistry
[08:27:55.303] result() for ClusterFuture ...
[08:27:55.303] - result already collected: FutureResult
[08:27:55.303] result() for ClusterFuture ... done
[08:27:55.303] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:55.316] resolve() on list environment ...
[08:27:55.316]  recursive: 0
[08:27:55.317]  length: 6
[08:27:55.317]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:55.317] signalConditionsASAP(numeric, pos=1) ...
[08:27:55.317] - nx: 6
[08:27:55.318] - relay: TRUE
[08:27:55.318] - stdout: TRUE
[08:27:55.318] - signal: TRUE
[08:27:55.318] - resignal: FALSE
[08:27:55.318] - force: TRUE
[08:27:55.318] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.318] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.318]  - until=2
[08:27:55.318]  - relaying element #2
[08:27:55.318] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.318] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.318] signalConditionsASAP(NULL, pos=1) ... done
[08:27:55.319]  length: 5 (resolved future 1)
[08:27:55.319] Future #2
[08:27:55.319] result() for ClusterFuture ...
[08:27:55.319] - result already collected: FutureResult
[08:27:55.319] result() for ClusterFuture ... done
[08:27:55.319] result() for ClusterFuture ...
[08:27:55.319] - result already collected: FutureResult
[08:27:55.319] result() for ClusterFuture ... done
[08:27:55.319] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:55.319] - nx: 6
[08:27:55.319] - relay: TRUE
[08:27:55.319] - stdout: TRUE
[08:27:55.320] - signal: TRUE
[08:27:55.320] - resignal: FALSE
[08:27:55.320] - force: TRUE
[08:27:55.320] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.320] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.320]  - until=2
[08:27:55.320]  - relaying element #2
[08:27:55.320] result() for ClusterFuture ...
[08:27:55.320] - result already collected: FutureResult
[08:27:55.320] result() for ClusterFuture ... done
[08:27:55.320] result() for ClusterFuture ...
[08:27:55.320] - result already collected: FutureResult
[08:27:55.321] result() for ClusterFuture ... done
[08:27:55.321] result() for ClusterFuture ...
[08:27:55.321] - result already collected: FutureResult
[08:27:55.321] result() for ClusterFuture ... done
[08:27:55.321] result() for ClusterFuture ...
[08:27:55.321] - result already collected: FutureResult
[08:27:55.321] result() for ClusterFuture ... done
[08:27:55.321] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.321] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.321] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:55.321]  length: 4 (resolved future 2)
[08:27:55.321] Future #3
[08:27:55.322] result() for ClusterFuture ...
[08:27:55.322] - result already collected: FutureResult
[08:27:55.322] result() for ClusterFuture ... done
[08:27:55.322] result() for ClusterFuture ...
[08:27:55.322] - result already collected: FutureResult
[08:27:55.322] result() for ClusterFuture ... done
[08:27:55.322] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:55.322] - nx: 6
[08:27:55.322] - relay: TRUE
[08:27:55.322] - stdout: TRUE
[08:27:55.322] - signal: TRUE
[08:27:55.322] - resignal: FALSE
[08:27:55.323] - force: TRUE
[08:27:55.323] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.323] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.323]  - until=3
[08:27:55.323]  - relaying element #3
[08:27:55.323] result() for ClusterFuture ...
[08:27:55.323] - result already collected: FutureResult
[08:27:55.323] result() for ClusterFuture ... done
[08:27:55.323] result() for ClusterFuture ...
[08:27:55.323] - result already collected: FutureResult
[08:27:55.323] result() for ClusterFuture ... done
[08:27:55.323] result() for ClusterFuture ...
[08:27:55.324] - result already collected: FutureResult
[08:27:55.324] result() for ClusterFuture ... done
[08:27:55.324] result() for ClusterFuture ...
[08:27:55.324] - result already collected: FutureResult
[08:27:55.324] result() for ClusterFuture ... done
[08:27:55.324] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.324] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.324] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:55.324]  length: 3 (resolved future 3)
[08:27:55.335] signalConditionsASAP(NULL, pos=5) ...
[08:27:55.335] - nx: 6
[08:27:55.335] - relay: TRUE
[08:27:55.335] - stdout: TRUE
[08:27:55.335] - signal: TRUE
[08:27:55.336] - resignal: FALSE
[08:27:55.336] - force: TRUE
[08:27:55.336] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.336] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.336]  - until=6
[08:27:55.336]  - relaying element #4
[08:27:55.336]  - relaying element #6
[08:27:55.337] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.337] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.337] signalConditionsASAP(NULL, pos=5) ... done
[08:27:55.337]  length: 2 (resolved future 5)
[08:27:55.337] signalConditionsASAP(numeric, pos=6) ...
[08:27:55.337] - nx: 6
[08:27:55.337] - relay: TRUE
[08:27:55.338] - stdout: TRUE
[08:27:55.338] - signal: TRUE
[08:27:55.338] - resignal: FALSE
[08:27:55.338] - force: TRUE
[08:27:55.338] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.338] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.338]  - until=6
[08:27:55.338]  - relaying element #4
[08:27:55.338] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.339] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.339] signalConditionsASAP(NULL, pos=6) ... done
[08:27:55.339]  length: 1 (resolved future 6)
[08:27:55.350] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.350] - Validating connection of MultisessionFuture
[08:27:55.350] - received message: FutureResult
[08:27:55.350] - Received FutureResult
[08:27:55.350] - Erased future from FutureRegistry
[08:27:55.350] result() for ClusterFuture ...
[08:27:55.351] - result already collected: FutureResult
[08:27:55.351] result() for ClusterFuture ... done
[08:27:55.351] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.351] Future #4
[08:27:55.351] result() for ClusterFuture ...
[08:27:55.351] - result already collected: FutureResult
[08:27:55.351] result() for ClusterFuture ... done
[08:27:55.351] result() for ClusterFuture ...
[08:27:55.351] - result already collected: FutureResult
[08:27:55.351] result() for ClusterFuture ... done
[08:27:55.351] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:55.352] - nx: 6
[08:27:55.352] - relay: TRUE
[08:27:55.352] - stdout: TRUE
[08:27:55.352] - signal: TRUE
[08:27:55.352] - resignal: FALSE
[08:27:55.352] - force: TRUE
[08:27:55.352] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.352] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.352]  - until=6
[08:27:55.352]  - relaying element #4
[08:27:55.352] result() for ClusterFuture ...
[08:27:55.352] - result already collected: FutureResult
[08:27:55.353] result() for ClusterFuture ... done
[08:27:55.353] result() for ClusterFuture ...
[08:27:55.353] - result already collected: FutureResult
[08:27:55.353] result() for ClusterFuture ... done
[08:27:55.353] result() for ClusterFuture ...
[08:27:55.353] - result already collected: FutureResult
[08:27:55.353] result() for ClusterFuture ... done
[08:27:55.353] result() for ClusterFuture ...
[08:27:55.353] - result already collected: FutureResult
[08:27:55.353] result() for ClusterFuture ... done
[08:27:55.353] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.353] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.354] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:55.354]  length: 0 (resolved future 4)
[08:27:55.354] Relaying remaining futures
[08:27:55.354] signalConditionsASAP(NULL, pos=0) ...
[08:27:55.354] - nx: 6
[08:27:55.354] - relay: TRUE
[08:27:55.354] - stdout: TRUE
[08:27:55.354] - signal: TRUE
[08:27:55.354] - resignal: FALSE
[08:27:55.354] - force: TRUE
[08:27:55.354] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.354] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:55.355] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.355] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.355] signalConditionsASAP(NULL, pos=0) ... done
[08:27:55.355] resolve() on list environment ... DONE
[08:27:55.355] result() for ClusterFuture ...
[08:27:55.355] - result already collected: FutureResult
[08:27:55.355] result() for ClusterFuture ... done
[08:27:55.355] result() for ClusterFuture ...
[08:27:55.355] - result already collected: FutureResult
[08:27:55.355] result() for ClusterFuture ... done
[08:27:55.355] result() for ClusterFuture ...
[08:27:55.356] - result already collected: FutureResult
[08:27:55.356] result() for ClusterFuture ... done
[08:27:55.356] result() for ClusterFuture ...
[08:27:55.356] - result already collected: FutureResult
[08:27:55.356] result() for ClusterFuture ... done
[08:27:55.356] result() for ClusterFuture ...
[08:27:55.356] - result already collected: FutureResult
[08:27:55.356] result() for ClusterFuture ... done
[08:27:55.356] result() for ClusterFuture ...
[08:27:55.356] - result already collected: FutureResult
[08:27:55.357] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d85f28fa68> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[08:27:55.358] getGlobalsAndPackages() ...
[08:27:55.358] Searching for globals...
[08:27:55.359] 
[08:27:55.359] Searching for globals ... DONE
[08:27:55.359] - globals: [0] <none>
[08:27:55.359] getGlobalsAndPackages() ... DONE
[08:27:55.359] run() for ‘Future’ ...
[08:27:55.359] - state: ‘created’
[08:27:55.360] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.374] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.374]   - Field: ‘node’
[08:27:55.374]   - Field: ‘label’
[08:27:55.374]   - Field: ‘local’
[08:27:55.374]   - Field: ‘owner’
[08:27:55.374]   - Field: ‘envir’
[08:27:55.374]   - Field: ‘workers’
[08:27:55.374]   - Field: ‘packages’
[08:27:55.375]   - Field: ‘gc’
[08:27:55.375]   - Field: ‘conditions’
[08:27:55.375]   - Field: ‘persistent’
[08:27:55.375]   - Field: ‘expr’
[08:27:55.375]   - Field: ‘uuid’
[08:27:55.375]   - Field: ‘seed’
[08:27:55.375]   - Field: ‘version’
[08:27:55.375]   - Field: ‘result’
[08:27:55.375]   - Field: ‘asynchronous’
[08:27:55.375]   - Field: ‘calls’
[08:27:55.375]   - Field: ‘globals’
[08:27:55.375]   - Field: ‘stdout’
[08:27:55.376]   - Field: ‘earlySignal’
[08:27:55.376]   - Field: ‘lazy’
[08:27:55.376]   - Field: ‘state’
[08:27:55.376] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.376] - Launch lazy future ...
[08:27:55.376] Packages needed by the future expression (n = 0): <none>
[08:27:55.376] Packages needed by future strategies (n = 0): <none>
[08:27:55.377] {
[08:27:55.377]     {
[08:27:55.377]         {
[08:27:55.377]             ...future.startTime <- base::Sys.time()
[08:27:55.377]             {
[08:27:55.377]                 {
[08:27:55.377]                   {
[08:27:55.377]                     {
[08:27:55.377]                       base::local({
[08:27:55.377]                         has_future <- base::requireNamespace("future", 
[08:27:55.377]                           quietly = TRUE)
[08:27:55.377]                         if (has_future) {
[08:27:55.377]                           ns <- base::getNamespace("future")
[08:27:55.377]                           version <- ns[[".package"]][["version"]]
[08:27:55.377]                           if (is.null(version)) 
[08:27:55.377]                             version <- utils::packageVersion("future")
[08:27:55.377]                         }
[08:27:55.377]                         else {
[08:27:55.377]                           version <- NULL
[08:27:55.377]                         }
[08:27:55.377]                         if (!has_future || version < "1.8.0") {
[08:27:55.377]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.377]                             "", base::R.version$version.string), 
[08:27:55.377]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.377]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.377]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.377]                               "release", "version")], collapse = " "), 
[08:27:55.377]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.377]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.377]                             info)
[08:27:55.377]                           info <- base::paste(info, collapse = "; ")
[08:27:55.377]                           if (!has_future) {
[08:27:55.377]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.377]                               info)
[08:27:55.377]                           }
[08:27:55.377]                           else {
[08:27:55.377]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.377]                               info, version)
[08:27:55.377]                           }
[08:27:55.377]                           base::stop(msg)
[08:27:55.377]                         }
[08:27:55.377]                       })
[08:27:55.377]                     }
[08:27:55.377]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.377]                     base::options(mc.cores = 1L)
[08:27:55.377]                   }
[08:27:55.377]                   ...future.strategy.old <- future::plan("list")
[08:27:55.377]                   options(future.plan = NULL)
[08:27:55.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.377]                 }
[08:27:55.377]                 ...future.workdir <- getwd()
[08:27:55.377]             }
[08:27:55.377]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.377]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.377]         }
[08:27:55.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.377]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.377]             base::names(...future.oldOptions))
[08:27:55.377]     }
[08:27:55.377]     if (FALSE) {
[08:27:55.377]     }
[08:27:55.377]     else {
[08:27:55.377]         if (TRUE) {
[08:27:55.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.377]                 open = "w")
[08:27:55.377]         }
[08:27:55.377]         else {
[08:27:55.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.377]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.377]         }
[08:27:55.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.377]             base::sink(type = "output", split = FALSE)
[08:27:55.377]             base::close(...future.stdout)
[08:27:55.377]         }, add = TRUE)
[08:27:55.377]     }
[08:27:55.377]     ...future.frame <- base::sys.nframe()
[08:27:55.377]     ...future.conditions <- base::list()
[08:27:55.377]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.377]     if (FALSE) {
[08:27:55.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.377]     }
[08:27:55.377]     ...future.result <- base::tryCatch({
[08:27:55.377]         base::withCallingHandlers({
[08:27:55.377]             ...future.value <- base::withVisible(base::local({
[08:27:55.377]                 ...future.makeSendCondition <- base::local({
[08:27:55.377]                   sendCondition <- NULL
[08:27:55.377]                   function(frame = 1L) {
[08:27:55.377]                     if (is.function(sendCondition)) 
[08:27:55.377]                       return(sendCondition)
[08:27:55.377]                     ns <- getNamespace("parallel")
[08:27:55.377]                     if (exists("sendData", mode = "function", 
[08:27:55.377]                       envir = ns)) {
[08:27:55.377]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.377]                         envir = ns)
[08:27:55.377]                       envir <- sys.frame(frame)
[08:27:55.377]                       master <- NULL
[08:27:55.377]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.377]                         !identical(envir, emptyenv())) {
[08:27:55.377]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.377]                           inherits = FALSE)) {
[08:27:55.377]                           master <- get("master", mode = "list", 
[08:27:55.377]                             envir = envir, inherits = FALSE)
[08:27:55.377]                           if (inherits(master, c("SOCKnode", 
[08:27:55.377]                             "SOCK0node"))) {
[08:27:55.377]                             sendCondition <<- function(cond) {
[08:27:55.377]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.377]                                 success = TRUE)
[08:27:55.377]                               parallel_sendData(master, data)
[08:27:55.377]                             }
[08:27:55.377]                             return(sendCondition)
[08:27:55.377]                           }
[08:27:55.377]                         }
[08:27:55.377]                         frame <- frame + 1L
[08:27:55.377]                         envir <- sys.frame(frame)
[08:27:55.377]                       }
[08:27:55.377]                     }
[08:27:55.377]                     sendCondition <<- function(cond) NULL
[08:27:55.377]                   }
[08:27:55.377]                 })
[08:27:55.377]                 withCallingHandlers({
[08:27:55.377]                   2
[08:27:55.377]                 }, immediateCondition = function(cond) {
[08:27:55.377]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.377]                   sendCondition(cond)
[08:27:55.377]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.377]                   {
[08:27:55.377]                     inherits <- base::inherits
[08:27:55.377]                     invokeRestart <- base::invokeRestart
[08:27:55.377]                     is.null <- base::is.null
[08:27:55.377]                     muffled <- FALSE
[08:27:55.377]                     if (inherits(cond, "message")) {
[08:27:55.377]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.377]                       if (muffled) 
[08:27:55.377]                         invokeRestart("muffleMessage")
[08:27:55.377]                     }
[08:27:55.377]                     else if (inherits(cond, "warning")) {
[08:27:55.377]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.377]                       if (muffled) 
[08:27:55.377]                         invokeRestart("muffleWarning")
[08:27:55.377]                     }
[08:27:55.377]                     else if (inherits(cond, "condition")) {
[08:27:55.377]                       if (!is.null(pattern)) {
[08:27:55.377]                         computeRestarts <- base::computeRestarts
[08:27:55.377]                         grepl <- base::grepl
[08:27:55.377]                         restarts <- computeRestarts(cond)
[08:27:55.377]                         for (restart in restarts) {
[08:27:55.377]                           name <- restart$name
[08:27:55.377]                           if (is.null(name)) 
[08:27:55.377]                             next
[08:27:55.377]                           if (!grepl(pattern, name)) 
[08:27:55.377]                             next
[08:27:55.377]                           invokeRestart(restart)
[08:27:55.377]                           muffled <- TRUE
[08:27:55.377]                           break
[08:27:55.377]                         }
[08:27:55.377]                       }
[08:27:55.377]                     }
[08:27:55.377]                     invisible(muffled)
[08:27:55.377]                   }
[08:27:55.377]                   muffleCondition(cond)
[08:27:55.377]                 })
[08:27:55.377]             }))
[08:27:55.377]             future::FutureResult(value = ...future.value$value, 
[08:27:55.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.377]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.377]                     ...future.globalenv.names))
[08:27:55.377]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.377]         }, condition = base::local({
[08:27:55.377]             c <- base::c
[08:27:55.377]             inherits <- base::inherits
[08:27:55.377]             invokeRestart <- base::invokeRestart
[08:27:55.377]             length <- base::length
[08:27:55.377]             list <- base::list
[08:27:55.377]             seq.int <- base::seq.int
[08:27:55.377]             signalCondition <- base::signalCondition
[08:27:55.377]             sys.calls <- base::sys.calls
[08:27:55.377]             `[[` <- base::`[[`
[08:27:55.377]             `+` <- base::`+`
[08:27:55.377]             `<<-` <- base::`<<-`
[08:27:55.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.377]                   3L)]
[08:27:55.377]             }
[08:27:55.377]             function(cond) {
[08:27:55.377]                 is_error <- inherits(cond, "error")
[08:27:55.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.377]                   NULL)
[08:27:55.377]                 if (is_error) {
[08:27:55.377]                   sessionInformation <- function() {
[08:27:55.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.377]                       search = base::search(), system = base::Sys.info())
[08:27:55.377]                   }
[08:27:55.377]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.377]                     cond$call), session = sessionInformation(), 
[08:27:55.377]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.377]                   signalCondition(cond)
[08:27:55.377]                 }
[08:27:55.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.377]                 "immediateCondition"))) {
[08:27:55.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.377]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.377]                   if (TRUE && !signal) {
[08:27:55.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.377]                     {
[08:27:55.377]                       inherits <- base::inherits
[08:27:55.377]                       invokeRestart <- base::invokeRestart
[08:27:55.377]                       is.null <- base::is.null
[08:27:55.377]                       muffled <- FALSE
[08:27:55.377]                       if (inherits(cond, "message")) {
[08:27:55.377]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.377]                         if (muffled) 
[08:27:55.377]                           invokeRestart("muffleMessage")
[08:27:55.377]                       }
[08:27:55.377]                       else if (inherits(cond, "warning")) {
[08:27:55.377]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.377]                         if (muffled) 
[08:27:55.377]                           invokeRestart("muffleWarning")
[08:27:55.377]                       }
[08:27:55.377]                       else if (inherits(cond, "condition")) {
[08:27:55.377]                         if (!is.null(pattern)) {
[08:27:55.377]                           computeRestarts <- base::computeRestarts
[08:27:55.377]                           grepl <- base::grepl
[08:27:55.377]                           restarts <- computeRestarts(cond)
[08:27:55.377]                           for (restart in restarts) {
[08:27:55.377]                             name <- restart$name
[08:27:55.377]                             if (is.null(name)) 
[08:27:55.377]                               next
[08:27:55.377]                             if (!grepl(pattern, name)) 
[08:27:55.377]                               next
[08:27:55.377]                             invokeRestart(restart)
[08:27:55.377]                             muffled <- TRUE
[08:27:55.377]                             break
[08:27:55.377]                           }
[08:27:55.377]                         }
[08:27:55.377]                       }
[08:27:55.377]                       invisible(muffled)
[08:27:55.377]                     }
[08:27:55.377]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.377]                   }
[08:27:55.377]                 }
[08:27:55.377]                 else {
[08:27:55.377]                   if (TRUE) {
[08:27:55.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.377]                     {
[08:27:55.377]                       inherits <- base::inherits
[08:27:55.377]                       invokeRestart <- base::invokeRestart
[08:27:55.377]                       is.null <- base::is.null
[08:27:55.377]                       muffled <- FALSE
[08:27:55.377]                       if (inherits(cond, "message")) {
[08:27:55.377]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.377]                         if (muffled) 
[08:27:55.377]                           invokeRestart("muffleMessage")
[08:27:55.377]                       }
[08:27:55.377]                       else if (inherits(cond, "warning")) {
[08:27:55.377]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.377]                         if (muffled) 
[08:27:55.377]                           invokeRestart("muffleWarning")
[08:27:55.377]                       }
[08:27:55.377]                       else if (inherits(cond, "condition")) {
[08:27:55.377]                         if (!is.null(pattern)) {
[08:27:55.377]                           computeRestarts <- base::computeRestarts
[08:27:55.377]                           grepl <- base::grepl
[08:27:55.377]                           restarts <- computeRestarts(cond)
[08:27:55.377]                           for (restart in restarts) {
[08:27:55.377]                             name <- restart$name
[08:27:55.377]                             if (is.null(name)) 
[08:27:55.377]                               next
[08:27:55.377]                             if (!grepl(pattern, name)) 
[08:27:55.377]                               next
[08:27:55.377]                             invokeRestart(restart)
[08:27:55.377]                             muffled <- TRUE
[08:27:55.377]                             break
[08:27:55.377]                           }
[08:27:55.377]                         }
[08:27:55.377]                       }
[08:27:55.377]                       invisible(muffled)
[08:27:55.377]                     }
[08:27:55.377]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.377]                   }
[08:27:55.377]                 }
[08:27:55.377]             }
[08:27:55.377]         }))
[08:27:55.377]     }, error = function(ex) {
[08:27:55.377]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.377]                 ...future.rng), started = ...future.startTime, 
[08:27:55.377]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.377]             version = "1.8"), class = "FutureResult")
[08:27:55.377]     }, finally = {
[08:27:55.377]         if (!identical(...future.workdir, getwd())) 
[08:27:55.377]             setwd(...future.workdir)
[08:27:55.377]         {
[08:27:55.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.377]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.377]             }
[08:27:55.377]             base::options(...future.oldOptions)
[08:27:55.377]             if (.Platform$OS.type == "windows") {
[08:27:55.377]                 old_names <- names(...future.oldEnvVars)
[08:27:55.377]                 envs <- base::Sys.getenv()
[08:27:55.377]                 names <- names(envs)
[08:27:55.377]                 common <- intersect(names, old_names)
[08:27:55.377]                 added <- setdiff(names, old_names)
[08:27:55.377]                 removed <- setdiff(old_names, names)
[08:27:55.377]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.377]                   envs[common]]
[08:27:55.377]                 NAMES <- toupper(changed)
[08:27:55.377]                 args <- list()
[08:27:55.377]                 for (kk in seq_along(NAMES)) {
[08:27:55.377]                   name <- changed[[kk]]
[08:27:55.377]                   NAME <- NAMES[[kk]]
[08:27:55.377]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.377]                     next
[08:27:55.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.377]                 }
[08:27:55.377]                 NAMES <- toupper(added)
[08:27:55.377]                 for (kk in seq_along(NAMES)) {
[08:27:55.377]                   name <- added[[kk]]
[08:27:55.377]                   NAME <- NAMES[[kk]]
[08:27:55.377]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.377]                     next
[08:27:55.377]                   args[[name]] <- ""
[08:27:55.377]                 }
[08:27:55.377]                 NAMES <- toupper(removed)
[08:27:55.377]                 for (kk in seq_along(NAMES)) {
[08:27:55.377]                   name <- removed[[kk]]
[08:27:55.377]                   NAME <- NAMES[[kk]]
[08:27:55.377]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.377]                     next
[08:27:55.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.377]                 }
[08:27:55.377]                 if (length(args) > 0) 
[08:27:55.377]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.377]             }
[08:27:55.377]             else {
[08:27:55.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.377]             }
[08:27:55.377]             {
[08:27:55.377]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.377]                   0L) {
[08:27:55.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.377]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.377]                   base::options(opts)
[08:27:55.377]                 }
[08:27:55.377]                 {
[08:27:55.377]                   {
[08:27:55.377]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.377]                     NULL
[08:27:55.377]                   }
[08:27:55.377]                   options(future.plan = NULL)
[08:27:55.377]                   if (is.na(NA_character_)) 
[08:27:55.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.377]                     .init = FALSE)
[08:27:55.377]                 }
[08:27:55.377]             }
[08:27:55.377]         }
[08:27:55.377]     })
[08:27:55.377]     if (TRUE) {
[08:27:55.377]         base::sink(type = "output", split = FALSE)
[08:27:55.377]         if (TRUE) {
[08:27:55.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.377]         }
[08:27:55.377]         else {
[08:27:55.377]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.377]         }
[08:27:55.377]         base::close(...future.stdout)
[08:27:55.377]         ...future.stdout <- NULL
[08:27:55.377]     }
[08:27:55.377]     ...future.result$conditions <- ...future.conditions
[08:27:55.377]     ...future.result$finished <- base::Sys.time()
[08:27:55.377]     ...future.result
[08:27:55.377] }
[08:27:55.380] MultisessionFuture started
[08:27:55.380] - Launch lazy future ... done
[08:27:55.380] run() for ‘MultisessionFuture’ ... done
[08:27:55.380] getGlobalsAndPackages() ...
[08:27:55.381] Searching for globals...
[08:27:55.381] 
[08:27:55.381] Searching for globals ... DONE
[08:27:55.381] - globals: [0] <none>
[08:27:55.381] getGlobalsAndPackages() ... DONE
[08:27:55.381] run() for ‘Future’ ...
[08:27:55.382] - state: ‘created’
[08:27:55.382] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.396] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.396] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.396]   - Field: ‘node’
[08:27:55.396]   - Field: ‘label’
[08:27:55.396]   - Field: ‘local’
[08:27:55.396]   - Field: ‘owner’
[08:27:55.397]   - Field: ‘envir’
[08:27:55.397]   - Field: ‘workers’
[08:27:55.397]   - Field: ‘packages’
[08:27:55.397]   - Field: ‘gc’
[08:27:55.397]   - Field: ‘conditions’
[08:27:55.397]   - Field: ‘persistent’
[08:27:55.397]   - Field: ‘expr’
[08:27:55.397]   - Field: ‘uuid’
[08:27:55.397]   - Field: ‘seed’
[08:27:55.397]   - Field: ‘version’
[08:27:55.397]   - Field: ‘result’
[08:27:55.397]   - Field: ‘asynchronous’
[08:27:55.398]   - Field: ‘calls’
[08:27:55.398]   - Field: ‘globals’
[08:27:55.398]   - Field: ‘stdout’
[08:27:55.398]   - Field: ‘earlySignal’
[08:27:55.398]   - Field: ‘lazy’
[08:27:55.398]   - Field: ‘state’
[08:27:55.398] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.398] - Launch lazy future ...
[08:27:55.398] Packages needed by the future expression (n = 0): <none>
[08:27:55.399] Packages needed by future strategies (n = 0): <none>
[08:27:55.399] {
[08:27:55.399]     {
[08:27:55.399]         {
[08:27:55.399]             ...future.startTime <- base::Sys.time()
[08:27:55.399]             {
[08:27:55.399]                 {
[08:27:55.399]                   {
[08:27:55.399]                     {
[08:27:55.399]                       base::local({
[08:27:55.399]                         has_future <- base::requireNamespace("future", 
[08:27:55.399]                           quietly = TRUE)
[08:27:55.399]                         if (has_future) {
[08:27:55.399]                           ns <- base::getNamespace("future")
[08:27:55.399]                           version <- ns[[".package"]][["version"]]
[08:27:55.399]                           if (is.null(version)) 
[08:27:55.399]                             version <- utils::packageVersion("future")
[08:27:55.399]                         }
[08:27:55.399]                         else {
[08:27:55.399]                           version <- NULL
[08:27:55.399]                         }
[08:27:55.399]                         if (!has_future || version < "1.8.0") {
[08:27:55.399]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.399]                             "", base::R.version$version.string), 
[08:27:55.399]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.399]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.399]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.399]                               "release", "version")], collapse = " "), 
[08:27:55.399]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.399]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.399]                             info)
[08:27:55.399]                           info <- base::paste(info, collapse = "; ")
[08:27:55.399]                           if (!has_future) {
[08:27:55.399]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.399]                               info)
[08:27:55.399]                           }
[08:27:55.399]                           else {
[08:27:55.399]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.399]                               info, version)
[08:27:55.399]                           }
[08:27:55.399]                           base::stop(msg)
[08:27:55.399]                         }
[08:27:55.399]                       })
[08:27:55.399]                     }
[08:27:55.399]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.399]                     base::options(mc.cores = 1L)
[08:27:55.399]                   }
[08:27:55.399]                   ...future.strategy.old <- future::plan("list")
[08:27:55.399]                   options(future.plan = NULL)
[08:27:55.399]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.399]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.399]                 }
[08:27:55.399]                 ...future.workdir <- getwd()
[08:27:55.399]             }
[08:27:55.399]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.399]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.399]         }
[08:27:55.399]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.399]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.399]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.399]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.399]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.399]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.399]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.399]             base::names(...future.oldOptions))
[08:27:55.399]     }
[08:27:55.399]     if (FALSE) {
[08:27:55.399]     }
[08:27:55.399]     else {
[08:27:55.399]         if (TRUE) {
[08:27:55.399]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.399]                 open = "w")
[08:27:55.399]         }
[08:27:55.399]         else {
[08:27:55.399]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.399]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.399]         }
[08:27:55.399]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.399]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.399]             base::sink(type = "output", split = FALSE)
[08:27:55.399]             base::close(...future.stdout)
[08:27:55.399]         }, add = TRUE)
[08:27:55.399]     }
[08:27:55.399]     ...future.frame <- base::sys.nframe()
[08:27:55.399]     ...future.conditions <- base::list()
[08:27:55.399]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.399]     if (FALSE) {
[08:27:55.399]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.399]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.399]     }
[08:27:55.399]     ...future.result <- base::tryCatch({
[08:27:55.399]         base::withCallingHandlers({
[08:27:55.399]             ...future.value <- base::withVisible(base::local({
[08:27:55.399]                 ...future.makeSendCondition <- base::local({
[08:27:55.399]                   sendCondition <- NULL
[08:27:55.399]                   function(frame = 1L) {
[08:27:55.399]                     if (is.function(sendCondition)) 
[08:27:55.399]                       return(sendCondition)
[08:27:55.399]                     ns <- getNamespace("parallel")
[08:27:55.399]                     if (exists("sendData", mode = "function", 
[08:27:55.399]                       envir = ns)) {
[08:27:55.399]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.399]                         envir = ns)
[08:27:55.399]                       envir <- sys.frame(frame)
[08:27:55.399]                       master <- NULL
[08:27:55.399]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.399]                         !identical(envir, emptyenv())) {
[08:27:55.399]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.399]                           inherits = FALSE)) {
[08:27:55.399]                           master <- get("master", mode = "list", 
[08:27:55.399]                             envir = envir, inherits = FALSE)
[08:27:55.399]                           if (inherits(master, c("SOCKnode", 
[08:27:55.399]                             "SOCK0node"))) {
[08:27:55.399]                             sendCondition <<- function(cond) {
[08:27:55.399]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.399]                                 success = TRUE)
[08:27:55.399]                               parallel_sendData(master, data)
[08:27:55.399]                             }
[08:27:55.399]                             return(sendCondition)
[08:27:55.399]                           }
[08:27:55.399]                         }
[08:27:55.399]                         frame <- frame + 1L
[08:27:55.399]                         envir <- sys.frame(frame)
[08:27:55.399]                       }
[08:27:55.399]                     }
[08:27:55.399]                     sendCondition <<- function(cond) NULL
[08:27:55.399]                   }
[08:27:55.399]                 })
[08:27:55.399]                 withCallingHandlers({
[08:27:55.399]                   NULL
[08:27:55.399]                 }, immediateCondition = function(cond) {
[08:27:55.399]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.399]                   sendCondition(cond)
[08:27:55.399]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.399]                   {
[08:27:55.399]                     inherits <- base::inherits
[08:27:55.399]                     invokeRestart <- base::invokeRestart
[08:27:55.399]                     is.null <- base::is.null
[08:27:55.399]                     muffled <- FALSE
[08:27:55.399]                     if (inherits(cond, "message")) {
[08:27:55.399]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.399]                       if (muffled) 
[08:27:55.399]                         invokeRestart("muffleMessage")
[08:27:55.399]                     }
[08:27:55.399]                     else if (inherits(cond, "warning")) {
[08:27:55.399]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.399]                       if (muffled) 
[08:27:55.399]                         invokeRestart("muffleWarning")
[08:27:55.399]                     }
[08:27:55.399]                     else if (inherits(cond, "condition")) {
[08:27:55.399]                       if (!is.null(pattern)) {
[08:27:55.399]                         computeRestarts <- base::computeRestarts
[08:27:55.399]                         grepl <- base::grepl
[08:27:55.399]                         restarts <- computeRestarts(cond)
[08:27:55.399]                         for (restart in restarts) {
[08:27:55.399]                           name <- restart$name
[08:27:55.399]                           if (is.null(name)) 
[08:27:55.399]                             next
[08:27:55.399]                           if (!grepl(pattern, name)) 
[08:27:55.399]                             next
[08:27:55.399]                           invokeRestart(restart)
[08:27:55.399]                           muffled <- TRUE
[08:27:55.399]                           break
[08:27:55.399]                         }
[08:27:55.399]                       }
[08:27:55.399]                     }
[08:27:55.399]                     invisible(muffled)
[08:27:55.399]                   }
[08:27:55.399]                   muffleCondition(cond)
[08:27:55.399]                 })
[08:27:55.399]             }))
[08:27:55.399]             future::FutureResult(value = ...future.value$value, 
[08:27:55.399]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.399]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.399]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.399]                     ...future.globalenv.names))
[08:27:55.399]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.399]         }, condition = base::local({
[08:27:55.399]             c <- base::c
[08:27:55.399]             inherits <- base::inherits
[08:27:55.399]             invokeRestart <- base::invokeRestart
[08:27:55.399]             length <- base::length
[08:27:55.399]             list <- base::list
[08:27:55.399]             seq.int <- base::seq.int
[08:27:55.399]             signalCondition <- base::signalCondition
[08:27:55.399]             sys.calls <- base::sys.calls
[08:27:55.399]             `[[` <- base::`[[`
[08:27:55.399]             `+` <- base::`+`
[08:27:55.399]             `<<-` <- base::`<<-`
[08:27:55.399]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.399]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.399]                   3L)]
[08:27:55.399]             }
[08:27:55.399]             function(cond) {
[08:27:55.399]                 is_error <- inherits(cond, "error")
[08:27:55.399]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.399]                   NULL)
[08:27:55.399]                 if (is_error) {
[08:27:55.399]                   sessionInformation <- function() {
[08:27:55.399]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.399]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.399]                       search = base::search(), system = base::Sys.info())
[08:27:55.399]                   }
[08:27:55.399]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.399]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.399]                     cond$call), session = sessionInformation(), 
[08:27:55.399]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.399]                   signalCondition(cond)
[08:27:55.399]                 }
[08:27:55.399]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.399]                 "immediateCondition"))) {
[08:27:55.399]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.399]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.399]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.399]                   if (TRUE && !signal) {
[08:27:55.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.399]                     {
[08:27:55.399]                       inherits <- base::inherits
[08:27:55.399]                       invokeRestart <- base::invokeRestart
[08:27:55.399]                       is.null <- base::is.null
[08:27:55.399]                       muffled <- FALSE
[08:27:55.399]                       if (inherits(cond, "message")) {
[08:27:55.399]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.399]                         if (muffled) 
[08:27:55.399]                           invokeRestart("muffleMessage")
[08:27:55.399]                       }
[08:27:55.399]                       else if (inherits(cond, "warning")) {
[08:27:55.399]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.399]                         if (muffled) 
[08:27:55.399]                           invokeRestart("muffleWarning")
[08:27:55.399]                       }
[08:27:55.399]                       else if (inherits(cond, "condition")) {
[08:27:55.399]                         if (!is.null(pattern)) {
[08:27:55.399]                           computeRestarts <- base::computeRestarts
[08:27:55.399]                           grepl <- base::grepl
[08:27:55.399]                           restarts <- computeRestarts(cond)
[08:27:55.399]                           for (restart in restarts) {
[08:27:55.399]                             name <- restart$name
[08:27:55.399]                             if (is.null(name)) 
[08:27:55.399]                               next
[08:27:55.399]                             if (!grepl(pattern, name)) 
[08:27:55.399]                               next
[08:27:55.399]                             invokeRestart(restart)
[08:27:55.399]                             muffled <- TRUE
[08:27:55.399]                             break
[08:27:55.399]                           }
[08:27:55.399]                         }
[08:27:55.399]                       }
[08:27:55.399]                       invisible(muffled)
[08:27:55.399]                     }
[08:27:55.399]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.399]                   }
[08:27:55.399]                 }
[08:27:55.399]                 else {
[08:27:55.399]                   if (TRUE) {
[08:27:55.399]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.399]                     {
[08:27:55.399]                       inherits <- base::inherits
[08:27:55.399]                       invokeRestart <- base::invokeRestart
[08:27:55.399]                       is.null <- base::is.null
[08:27:55.399]                       muffled <- FALSE
[08:27:55.399]                       if (inherits(cond, "message")) {
[08:27:55.399]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.399]                         if (muffled) 
[08:27:55.399]                           invokeRestart("muffleMessage")
[08:27:55.399]                       }
[08:27:55.399]                       else if (inherits(cond, "warning")) {
[08:27:55.399]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.399]                         if (muffled) 
[08:27:55.399]                           invokeRestart("muffleWarning")
[08:27:55.399]                       }
[08:27:55.399]                       else if (inherits(cond, "condition")) {
[08:27:55.399]                         if (!is.null(pattern)) {
[08:27:55.399]                           computeRestarts <- base::computeRestarts
[08:27:55.399]                           grepl <- base::grepl
[08:27:55.399]                           restarts <- computeRestarts(cond)
[08:27:55.399]                           for (restart in restarts) {
[08:27:55.399]                             name <- restart$name
[08:27:55.399]                             if (is.null(name)) 
[08:27:55.399]                               next
[08:27:55.399]                             if (!grepl(pattern, name)) 
[08:27:55.399]                               next
[08:27:55.399]                             invokeRestart(restart)
[08:27:55.399]                             muffled <- TRUE
[08:27:55.399]                             break
[08:27:55.399]                           }
[08:27:55.399]                         }
[08:27:55.399]                       }
[08:27:55.399]                       invisible(muffled)
[08:27:55.399]                     }
[08:27:55.399]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.399]                   }
[08:27:55.399]                 }
[08:27:55.399]             }
[08:27:55.399]         }))
[08:27:55.399]     }, error = function(ex) {
[08:27:55.399]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.399]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.399]                 ...future.rng), started = ...future.startTime, 
[08:27:55.399]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.399]             version = "1.8"), class = "FutureResult")
[08:27:55.399]     }, finally = {
[08:27:55.399]         if (!identical(...future.workdir, getwd())) 
[08:27:55.399]             setwd(...future.workdir)
[08:27:55.399]         {
[08:27:55.399]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.399]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.399]             }
[08:27:55.399]             base::options(...future.oldOptions)
[08:27:55.399]             if (.Platform$OS.type == "windows") {
[08:27:55.399]                 old_names <- names(...future.oldEnvVars)
[08:27:55.399]                 envs <- base::Sys.getenv()
[08:27:55.399]                 names <- names(envs)
[08:27:55.399]                 common <- intersect(names, old_names)
[08:27:55.399]                 added <- setdiff(names, old_names)
[08:27:55.399]                 removed <- setdiff(old_names, names)
[08:27:55.399]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.399]                   envs[common]]
[08:27:55.399]                 NAMES <- toupper(changed)
[08:27:55.399]                 args <- list()
[08:27:55.399]                 for (kk in seq_along(NAMES)) {
[08:27:55.399]                   name <- changed[[kk]]
[08:27:55.399]                   NAME <- NAMES[[kk]]
[08:27:55.399]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.399]                     next
[08:27:55.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.399]                 }
[08:27:55.399]                 NAMES <- toupper(added)
[08:27:55.399]                 for (kk in seq_along(NAMES)) {
[08:27:55.399]                   name <- added[[kk]]
[08:27:55.399]                   NAME <- NAMES[[kk]]
[08:27:55.399]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.399]                     next
[08:27:55.399]                   args[[name]] <- ""
[08:27:55.399]                 }
[08:27:55.399]                 NAMES <- toupper(removed)
[08:27:55.399]                 for (kk in seq_along(NAMES)) {
[08:27:55.399]                   name <- removed[[kk]]
[08:27:55.399]                   NAME <- NAMES[[kk]]
[08:27:55.399]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.399]                     next
[08:27:55.399]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.399]                 }
[08:27:55.399]                 if (length(args) > 0) 
[08:27:55.399]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.399]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.399]             }
[08:27:55.399]             else {
[08:27:55.399]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.399]             }
[08:27:55.399]             {
[08:27:55.399]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.399]                   0L) {
[08:27:55.399]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.399]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.399]                   base::options(opts)
[08:27:55.399]                 }
[08:27:55.399]                 {
[08:27:55.399]                   {
[08:27:55.399]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.399]                     NULL
[08:27:55.399]                   }
[08:27:55.399]                   options(future.plan = NULL)
[08:27:55.399]                   if (is.na(NA_character_)) 
[08:27:55.399]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.399]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.399]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.399]                     .init = FALSE)
[08:27:55.399]                 }
[08:27:55.399]             }
[08:27:55.399]         }
[08:27:55.399]     })
[08:27:55.399]     if (TRUE) {
[08:27:55.399]         base::sink(type = "output", split = FALSE)
[08:27:55.399]         if (TRUE) {
[08:27:55.399]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.399]         }
[08:27:55.399]         else {
[08:27:55.399]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.399]         }
[08:27:55.399]         base::close(...future.stdout)
[08:27:55.399]         ...future.stdout <- NULL
[08:27:55.399]     }
[08:27:55.399]     ...future.result$conditions <- ...future.conditions
[08:27:55.399]     ...future.result$finished <- base::Sys.time()
[08:27:55.399]     ...future.result
[08:27:55.399] }
[08:27:55.402] MultisessionFuture started
[08:27:55.402] - Launch lazy future ... done
[08:27:55.403] run() for ‘MultisessionFuture’ ... done
[08:27:55.403] getGlobalsAndPackages() ...
[08:27:55.403] Searching for globals...
[08:27:55.404] - globals found: [1] ‘{’
[08:27:55.404] Searching for globals ... DONE
[08:27:55.404] Resolving globals: FALSE
[08:27:55.404] 
[08:27:55.404] 
[08:27:55.404] getGlobalsAndPackages() ... DONE
[08:27:55.405] run() for ‘Future’ ...
[08:27:55.405] - state: ‘created’
[08:27:55.405] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.419] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.420] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.420]   - Field: ‘node’
[08:27:55.420]   - Field: ‘label’
[08:27:55.424]   - Field: ‘local’
[08:27:55.424]   - Field: ‘owner’
[08:27:55.424]   - Field: ‘envir’
[08:27:55.424]   - Field: ‘workers’
[08:27:55.425]   - Field: ‘packages’
[08:27:55.425]   - Field: ‘gc’
[08:27:55.425]   - Field: ‘conditions’
[08:27:55.425]   - Field: ‘persistent’
[08:27:55.425]   - Field: ‘expr’
[08:27:55.425]   - Field: ‘uuid’
[08:27:55.425]   - Field: ‘seed’
[08:27:55.425]   - Field: ‘version’
[08:27:55.425]   - Field: ‘result’
[08:27:55.425]   - Field: ‘asynchronous’
[08:27:55.425]   - Field: ‘calls’
[08:27:55.426]   - Field: ‘globals’
[08:27:55.426]   - Field: ‘stdout’
[08:27:55.426]   - Field: ‘earlySignal’
[08:27:55.426]   - Field: ‘lazy’
[08:27:55.426]   - Field: ‘state’
[08:27:55.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.426] - Launch lazy future ...
[08:27:55.426] Packages needed by the future expression (n = 0): <none>
[08:27:55.426] Packages needed by future strategies (n = 0): <none>
[08:27:55.427] {
[08:27:55.427]     {
[08:27:55.427]         {
[08:27:55.427]             ...future.startTime <- base::Sys.time()
[08:27:55.427]             {
[08:27:55.427]                 {
[08:27:55.427]                   {
[08:27:55.427]                     {
[08:27:55.427]                       base::local({
[08:27:55.427]                         has_future <- base::requireNamespace("future", 
[08:27:55.427]                           quietly = TRUE)
[08:27:55.427]                         if (has_future) {
[08:27:55.427]                           ns <- base::getNamespace("future")
[08:27:55.427]                           version <- ns[[".package"]][["version"]]
[08:27:55.427]                           if (is.null(version)) 
[08:27:55.427]                             version <- utils::packageVersion("future")
[08:27:55.427]                         }
[08:27:55.427]                         else {
[08:27:55.427]                           version <- NULL
[08:27:55.427]                         }
[08:27:55.427]                         if (!has_future || version < "1.8.0") {
[08:27:55.427]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.427]                             "", base::R.version$version.string), 
[08:27:55.427]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.427]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.427]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.427]                               "release", "version")], collapse = " "), 
[08:27:55.427]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.427]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.427]                             info)
[08:27:55.427]                           info <- base::paste(info, collapse = "; ")
[08:27:55.427]                           if (!has_future) {
[08:27:55.427]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.427]                               info)
[08:27:55.427]                           }
[08:27:55.427]                           else {
[08:27:55.427]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.427]                               info, version)
[08:27:55.427]                           }
[08:27:55.427]                           base::stop(msg)
[08:27:55.427]                         }
[08:27:55.427]                       })
[08:27:55.427]                     }
[08:27:55.427]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.427]                     base::options(mc.cores = 1L)
[08:27:55.427]                   }
[08:27:55.427]                   ...future.strategy.old <- future::plan("list")
[08:27:55.427]                   options(future.plan = NULL)
[08:27:55.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.427]                 }
[08:27:55.427]                 ...future.workdir <- getwd()
[08:27:55.427]             }
[08:27:55.427]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.427]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.427]         }
[08:27:55.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.427]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.427]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.427]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.427]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.427]             base::names(...future.oldOptions))
[08:27:55.427]     }
[08:27:55.427]     if (FALSE) {
[08:27:55.427]     }
[08:27:55.427]     else {
[08:27:55.427]         if (TRUE) {
[08:27:55.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.427]                 open = "w")
[08:27:55.427]         }
[08:27:55.427]         else {
[08:27:55.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.427]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.427]         }
[08:27:55.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.427]             base::sink(type = "output", split = FALSE)
[08:27:55.427]             base::close(...future.stdout)
[08:27:55.427]         }, add = TRUE)
[08:27:55.427]     }
[08:27:55.427]     ...future.frame <- base::sys.nframe()
[08:27:55.427]     ...future.conditions <- base::list()
[08:27:55.427]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.427]     if (FALSE) {
[08:27:55.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.427]     }
[08:27:55.427]     ...future.result <- base::tryCatch({
[08:27:55.427]         base::withCallingHandlers({
[08:27:55.427]             ...future.value <- base::withVisible(base::local({
[08:27:55.427]                 ...future.makeSendCondition <- base::local({
[08:27:55.427]                   sendCondition <- NULL
[08:27:55.427]                   function(frame = 1L) {
[08:27:55.427]                     if (is.function(sendCondition)) 
[08:27:55.427]                       return(sendCondition)
[08:27:55.427]                     ns <- getNamespace("parallel")
[08:27:55.427]                     if (exists("sendData", mode = "function", 
[08:27:55.427]                       envir = ns)) {
[08:27:55.427]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.427]                         envir = ns)
[08:27:55.427]                       envir <- sys.frame(frame)
[08:27:55.427]                       master <- NULL
[08:27:55.427]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.427]                         !identical(envir, emptyenv())) {
[08:27:55.427]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.427]                           inherits = FALSE)) {
[08:27:55.427]                           master <- get("master", mode = "list", 
[08:27:55.427]                             envir = envir, inherits = FALSE)
[08:27:55.427]                           if (inherits(master, c("SOCKnode", 
[08:27:55.427]                             "SOCK0node"))) {
[08:27:55.427]                             sendCondition <<- function(cond) {
[08:27:55.427]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.427]                                 success = TRUE)
[08:27:55.427]                               parallel_sendData(master, data)
[08:27:55.427]                             }
[08:27:55.427]                             return(sendCondition)
[08:27:55.427]                           }
[08:27:55.427]                         }
[08:27:55.427]                         frame <- frame + 1L
[08:27:55.427]                         envir <- sys.frame(frame)
[08:27:55.427]                       }
[08:27:55.427]                     }
[08:27:55.427]                     sendCondition <<- function(cond) NULL
[08:27:55.427]                   }
[08:27:55.427]                 })
[08:27:55.427]                 withCallingHandlers({
[08:27:55.427]                   {
[08:27:55.427]                     4
[08:27:55.427]                   }
[08:27:55.427]                 }, immediateCondition = function(cond) {
[08:27:55.427]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.427]                   sendCondition(cond)
[08:27:55.427]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.427]                   {
[08:27:55.427]                     inherits <- base::inherits
[08:27:55.427]                     invokeRestart <- base::invokeRestart
[08:27:55.427]                     is.null <- base::is.null
[08:27:55.427]                     muffled <- FALSE
[08:27:55.427]                     if (inherits(cond, "message")) {
[08:27:55.427]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.427]                       if (muffled) 
[08:27:55.427]                         invokeRestart("muffleMessage")
[08:27:55.427]                     }
[08:27:55.427]                     else if (inherits(cond, "warning")) {
[08:27:55.427]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.427]                       if (muffled) 
[08:27:55.427]                         invokeRestart("muffleWarning")
[08:27:55.427]                     }
[08:27:55.427]                     else if (inherits(cond, "condition")) {
[08:27:55.427]                       if (!is.null(pattern)) {
[08:27:55.427]                         computeRestarts <- base::computeRestarts
[08:27:55.427]                         grepl <- base::grepl
[08:27:55.427]                         restarts <- computeRestarts(cond)
[08:27:55.427]                         for (restart in restarts) {
[08:27:55.427]                           name <- restart$name
[08:27:55.427]                           if (is.null(name)) 
[08:27:55.427]                             next
[08:27:55.427]                           if (!grepl(pattern, name)) 
[08:27:55.427]                             next
[08:27:55.427]                           invokeRestart(restart)
[08:27:55.427]                           muffled <- TRUE
[08:27:55.427]                           break
[08:27:55.427]                         }
[08:27:55.427]                       }
[08:27:55.427]                     }
[08:27:55.427]                     invisible(muffled)
[08:27:55.427]                   }
[08:27:55.427]                   muffleCondition(cond)
[08:27:55.427]                 })
[08:27:55.427]             }))
[08:27:55.427]             future::FutureResult(value = ...future.value$value, 
[08:27:55.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.427]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.427]                     ...future.globalenv.names))
[08:27:55.427]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.427]         }, condition = base::local({
[08:27:55.427]             c <- base::c
[08:27:55.427]             inherits <- base::inherits
[08:27:55.427]             invokeRestart <- base::invokeRestart
[08:27:55.427]             length <- base::length
[08:27:55.427]             list <- base::list
[08:27:55.427]             seq.int <- base::seq.int
[08:27:55.427]             signalCondition <- base::signalCondition
[08:27:55.427]             sys.calls <- base::sys.calls
[08:27:55.427]             `[[` <- base::`[[`
[08:27:55.427]             `+` <- base::`+`
[08:27:55.427]             `<<-` <- base::`<<-`
[08:27:55.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.427]                   3L)]
[08:27:55.427]             }
[08:27:55.427]             function(cond) {
[08:27:55.427]                 is_error <- inherits(cond, "error")
[08:27:55.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.427]                   NULL)
[08:27:55.427]                 if (is_error) {
[08:27:55.427]                   sessionInformation <- function() {
[08:27:55.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.427]                       search = base::search(), system = base::Sys.info())
[08:27:55.427]                   }
[08:27:55.427]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.427]                     cond$call), session = sessionInformation(), 
[08:27:55.427]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.427]                   signalCondition(cond)
[08:27:55.427]                 }
[08:27:55.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.427]                 "immediateCondition"))) {
[08:27:55.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.427]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.427]                   if (TRUE && !signal) {
[08:27:55.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.427]                     {
[08:27:55.427]                       inherits <- base::inherits
[08:27:55.427]                       invokeRestart <- base::invokeRestart
[08:27:55.427]                       is.null <- base::is.null
[08:27:55.427]                       muffled <- FALSE
[08:27:55.427]                       if (inherits(cond, "message")) {
[08:27:55.427]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.427]                         if (muffled) 
[08:27:55.427]                           invokeRestart("muffleMessage")
[08:27:55.427]                       }
[08:27:55.427]                       else if (inherits(cond, "warning")) {
[08:27:55.427]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.427]                         if (muffled) 
[08:27:55.427]                           invokeRestart("muffleWarning")
[08:27:55.427]                       }
[08:27:55.427]                       else if (inherits(cond, "condition")) {
[08:27:55.427]                         if (!is.null(pattern)) {
[08:27:55.427]                           computeRestarts <- base::computeRestarts
[08:27:55.427]                           grepl <- base::grepl
[08:27:55.427]                           restarts <- computeRestarts(cond)
[08:27:55.427]                           for (restart in restarts) {
[08:27:55.427]                             name <- restart$name
[08:27:55.427]                             if (is.null(name)) 
[08:27:55.427]                               next
[08:27:55.427]                             if (!grepl(pattern, name)) 
[08:27:55.427]                               next
[08:27:55.427]                             invokeRestart(restart)
[08:27:55.427]                             muffled <- TRUE
[08:27:55.427]                             break
[08:27:55.427]                           }
[08:27:55.427]                         }
[08:27:55.427]                       }
[08:27:55.427]                       invisible(muffled)
[08:27:55.427]                     }
[08:27:55.427]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.427]                   }
[08:27:55.427]                 }
[08:27:55.427]                 else {
[08:27:55.427]                   if (TRUE) {
[08:27:55.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.427]                     {
[08:27:55.427]                       inherits <- base::inherits
[08:27:55.427]                       invokeRestart <- base::invokeRestart
[08:27:55.427]                       is.null <- base::is.null
[08:27:55.427]                       muffled <- FALSE
[08:27:55.427]                       if (inherits(cond, "message")) {
[08:27:55.427]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.427]                         if (muffled) 
[08:27:55.427]                           invokeRestart("muffleMessage")
[08:27:55.427]                       }
[08:27:55.427]                       else if (inherits(cond, "warning")) {
[08:27:55.427]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.427]                         if (muffled) 
[08:27:55.427]                           invokeRestart("muffleWarning")
[08:27:55.427]                       }
[08:27:55.427]                       else if (inherits(cond, "condition")) {
[08:27:55.427]                         if (!is.null(pattern)) {
[08:27:55.427]                           computeRestarts <- base::computeRestarts
[08:27:55.427]                           grepl <- base::grepl
[08:27:55.427]                           restarts <- computeRestarts(cond)
[08:27:55.427]                           for (restart in restarts) {
[08:27:55.427]                             name <- restart$name
[08:27:55.427]                             if (is.null(name)) 
[08:27:55.427]                               next
[08:27:55.427]                             if (!grepl(pattern, name)) 
[08:27:55.427]                               next
[08:27:55.427]                             invokeRestart(restart)
[08:27:55.427]                             muffled <- TRUE
[08:27:55.427]                             break
[08:27:55.427]                           }
[08:27:55.427]                         }
[08:27:55.427]                       }
[08:27:55.427]                       invisible(muffled)
[08:27:55.427]                     }
[08:27:55.427]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.427]                   }
[08:27:55.427]                 }
[08:27:55.427]             }
[08:27:55.427]         }))
[08:27:55.427]     }, error = function(ex) {
[08:27:55.427]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.427]                 ...future.rng), started = ...future.startTime, 
[08:27:55.427]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.427]             version = "1.8"), class = "FutureResult")
[08:27:55.427]     }, finally = {
[08:27:55.427]         if (!identical(...future.workdir, getwd())) 
[08:27:55.427]             setwd(...future.workdir)
[08:27:55.427]         {
[08:27:55.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.427]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.427]             }
[08:27:55.427]             base::options(...future.oldOptions)
[08:27:55.427]             if (.Platform$OS.type == "windows") {
[08:27:55.427]                 old_names <- names(...future.oldEnvVars)
[08:27:55.427]                 envs <- base::Sys.getenv()
[08:27:55.427]                 names <- names(envs)
[08:27:55.427]                 common <- intersect(names, old_names)
[08:27:55.427]                 added <- setdiff(names, old_names)
[08:27:55.427]                 removed <- setdiff(old_names, names)
[08:27:55.427]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.427]                   envs[common]]
[08:27:55.427]                 NAMES <- toupper(changed)
[08:27:55.427]                 args <- list()
[08:27:55.427]                 for (kk in seq_along(NAMES)) {
[08:27:55.427]                   name <- changed[[kk]]
[08:27:55.427]                   NAME <- NAMES[[kk]]
[08:27:55.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.427]                     next
[08:27:55.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.427]                 }
[08:27:55.427]                 NAMES <- toupper(added)
[08:27:55.427]                 for (kk in seq_along(NAMES)) {
[08:27:55.427]                   name <- added[[kk]]
[08:27:55.427]                   NAME <- NAMES[[kk]]
[08:27:55.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.427]                     next
[08:27:55.427]                   args[[name]] <- ""
[08:27:55.427]                 }
[08:27:55.427]                 NAMES <- toupper(removed)
[08:27:55.427]                 for (kk in seq_along(NAMES)) {
[08:27:55.427]                   name <- removed[[kk]]
[08:27:55.427]                   NAME <- NAMES[[kk]]
[08:27:55.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.427]                     next
[08:27:55.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.427]                 }
[08:27:55.427]                 if (length(args) > 0) 
[08:27:55.427]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.427]             }
[08:27:55.427]             else {
[08:27:55.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.427]             }
[08:27:55.427]             {
[08:27:55.427]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.427]                   0L) {
[08:27:55.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.427]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.427]                   base::options(opts)
[08:27:55.427]                 }
[08:27:55.427]                 {
[08:27:55.427]                   {
[08:27:55.427]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.427]                     NULL
[08:27:55.427]                   }
[08:27:55.427]                   options(future.plan = NULL)
[08:27:55.427]                   if (is.na(NA_character_)) 
[08:27:55.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.427]                     .init = FALSE)
[08:27:55.427]                 }
[08:27:55.427]             }
[08:27:55.427]         }
[08:27:55.427]     })
[08:27:55.427]     if (TRUE) {
[08:27:55.427]         base::sink(type = "output", split = FALSE)
[08:27:55.427]         if (TRUE) {
[08:27:55.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.427]         }
[08:27:55.427]         else {
[08:27:55.427]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.427]         }
[08:27:55.427]         base::close(...future.stdout)
[08:27:55.427]         ...future.stdout <- NULL
[08:27:55.427]     }
[08:27:55.427]     ...future.result$conditions <- ...future.conditions
[08:27:55.427]     ...future.result$finished <- base::Sys.time()
[08:27:55.427]     ...future.result
[08:27:55.427] }
[08:27:55.429] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:55.440] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.440] - Validating connection of MultisessionFuture
[08:27:55.440] - received message: FutureResult
[08:27:55.441] - Received FutureResult
[08:27:55.441] - Erased future from FutureRegistry
[08:27:55.441] result() for ClusterFuture ...
[08:27:55.441] - result already collected: FutureResult
[08:27:55.441] result() for ClusterFuture ... done
[08:27:55.441] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.441] result() for ClusterFuture ...
[08:27:55.441] - result already collected: FutureResult
[08:27:55.441] result() for ClusterFuture ... done
[08:27:55.441] result() for ClusterFuture ...
[08:27:55.441] - result already collected: FutureResult
[08:27:55.441] result() for ClusterFuture ... done
[08:27:55.443] MultisessionFuture started
[08:27:55.443] - Launch lazy future ... done
[08:27:55.443] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d8626ea5d0> 
Classes 'listenv', 'environment' <environment: 0x55d861004af0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[08:27:55.447] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.447] - Validating connection of MultisessionFuture
[08:27:55.447] - received message: FutureResult
[08:27:55.448] - Received FutureResult
[08:27:55.448] - Erased future from FutureRegistry
[08:27:55.448] result() for ClusterFuture ...
[08:27:55.448] - result already collected: FutureResult
[08:27:55.448] result() for ClusterFuture ... done
[08:27:55.448] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:55.461] resolve() on list environment ...
[08:27:55.461]  recursive: 0
[08:27:55.462]  length: 6
[08:27:55.462]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:55.462] signalConditionsASAP(numeric, pos=1) ...
[08:27:55.462] - nx: 6
[08:27:55.462] - relay: TRUE
[08:27:55.462] - stdout: TRUE
[08:27:55.462] - signal: TRUE
[08:27:55.463] - resignal: FALSE
[08:27:55.463] - force: TRUE
[08:27:55.463] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.463] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.463]  - until=2
[08:27:55.463]  - relaying element #2
[08:27:55.463] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.463] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.463] signalConditionsASAP(NULL, pos=1) ... done
[08:27:55.463]  length: 5 (resolved future 1)
[08:27:55.463] Future #2
[08:27:55.463] result() for ClusterFuture ...
[08:27:55.464] - result already collected: FutureResult
[08:27:55.464] result() for ClusterFuture ... done
[08:27:55.464] result() for ClusterFuture ...
[08:27:55.464] - result already collected: FutureResult
[08:27:55.464] result() for ClusterFuture ... done
[08:27:55.464] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:55.464] - nx: 6
[08:27:55.464] - relay: TRUE
[08:27:55.464] - stdout: TRUE
[08:27:55.464] - signal: TRUE
[08:27:55.464] - resignal: FALSE
[08:27:55.464] - force: TRUE
[08:27:55.465] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.465] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.465]  - until=2
[08:27:55.465]  - relaying element #2
[08:27:55.465] result() for ClusterFuture ...
[08:27:55.465] - result already collected: FutureResult
[08:27:55.465] result() for ClusterFuture ... done
[08:27:55.465] result() for ClusterFuture ...
[08:27:55.465] - result already collected: FutureResult
[08:27:55.465] result() for ClusterFuture ... done
[08:27:55.465] result() for ClusterFuture ...
[08:27:55.465] - result already collected: FutureResult
[08:27:55.466] result() for ClusterFuture ... done
[08:27:55.466] result() for ClusterFuture ...
[08:27:55.466] - result already collected: FutureResult
[08:27:55.466] result() for ClusterFuture ... done
[08:27:55.466] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.466] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.466] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:55.466]  length: 4 (resolved future 2)
[08:27:55.466] Future #3
[08:27:55.466] result() for ClusterFuture ...
[08:27:55.466] - result already collected: FutureResult
[08:27:55.466] result() for ClusterFuture ... done
[08:27:55.467] result() for ClusterFuture ...
[08:27:55.467] - result already collected: FutureResult
[08:27:55.467] result() for ClusterFuture ... done
[08:27:55.467] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:55.467] - nx: 6
[08:27:55.467] - relay: TRUE
[08:27:55.467] - stdout: TRUE
[08:27:55.467] - signal: TRUE
[08:27:55.467] - resignal: FALSE
[08:27:55.467] - force: TRUE
[08:27:55.467] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.467] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.468]  - until=3
[08:27:55.468]  - relaying element #3
[08:27:55.468] result() for ClusterFuture ...
[08:27:55.468] - result already collected: FutureResult
[08:27:55.468] result() for ClusterFuture ... done
[08:27:55.468] result() for ClusterFuture ...
[08:27:55.468] - result already collected: FutureResult
[08:27:55.468] result() for ClusterFuture ... done
[08:27:55.468] result() for ClusterFuture ...
[08:27:55.468] - result already collected: FutureResult
[08:27:55.468] result() for ClusterFuture ... done
[08:27:55.468] result() for ClusterFuture ...
[08:27:55.469] - result already collected: FutureResult
[08:27:55.469] result() for ClusterFuture ... done
[08:27:55.469] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.469] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.469] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:55.469]  length: 3 (resolved future 3)
[08:27:55.480] signalConditionsASAP(NULL, pos=5) ...
[08:27:55.480] - nx: 6
[08:27:55.480] - relay: TRUE
[08:27:55.480] - stdout: TRUE
[08:27:55.480] - signal: TRUE
[08:27:55.480] - resignal: FALSE
[08:27:55.480] - force: TRUE
[08:27:55.480] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.480] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.480]  - until=6
[08:27:55.480]  - relaying element #4
[08:27:55.481]  - relaying element #6
[08:27:55.481] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.481] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.481] signalConditionsASAP(NULL, pos=5) ... done
[08:27:55.481]  length: 2 (resolved future 5)
[08:27:55.481] signalConditionsASAP(numeric, pos=6) ...
[08:27:55.481] - nx: 6
[08:27:55.481] - relay: TRUE
[08:27:55.481] - stdout: TRUE
[08:27:55.481] - signal: TRUE
[08:27:55.481] - resignal: FALSE
[08:27:55.481] - force: TRUE
[08:27:55.482] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.482] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.482]  - until=6
[08:27:55.482]  - relaying element #4
[08:27:55.482] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.482] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.482] signalConditionsASAP(NULL, pos=6) ... done
[08:27:55.482]  length: 1 (resolved future 6)
[08:27:55.493] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.493] - Validating connection of MultisessionFuture
[08:27:55.493] - received message: FutureResult
[08:27:55.493] - Received FutureResult
[08:27:55.494] - Erased future from FutureRegistry
[08:27:55.494] result() for ClusterFuture ...
[08:27:55.494] - result already collected: FutureResult
[08:27:55.494] result() for ClusterFuture ... done
[08:27:55.494] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.494] Future #4
[08:27:55.494] result() for ClusterFuture ...
[08:27:55.494] - result already collected: FutureResult
[08:27:55.494] result() for ClusterFuture ... done
[08:27:55.494] result() for ClusterFuture ...
[08:27:55.494] - result already collected: FutureResult
[08:27:55.494] result() for ClusterFuture ... done
[08:27:55.495] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:55.495] - nx: 6
[08:27:55.495] - relay: TRUE
[08:27:55.495] - stdout: TRUE
[08:27:55.495] - signal: TRUE
[08:27:55.495] - resignal: FALSE
[08:27:55.495] - force: TRUE
[08:27:55.495] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.495] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.495]  - until=6
[08:27:55.495]  - relaying element #4
[08:27:55.495] result() for ClusterFuture ...
[08:27:55.496] - result already collected: FutureResult
[08:27:55.496] result() for ClusterFuture ... done
[08:27:55.496] result() for ClusterFuture ...
[08:27:55.496] - result already collected: FutureResult
[08:27:55.496] result() for ClusterFuture ... done
[08:27:55.496] result() for ClusterFuture ...
[08:27:55.496] - result already collected: FutureResult
[08:27:55.496] result() for ClusterFuture ... done
[08:27:55.496] result() for ClusterFuture ...
[08:27:55.496] - result already collected: FutureResult
[08:27:55.496] result() for ClusterFuture ... done
[08:27:55.496] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.497] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.497] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:55.497]  length: 0 (resolved future 4)
[08:27:55.497] Relaying remaining futures
[08:27:55.497] signalConditionsASAP(NULL, pos=0) ...
[08:27:55.497] - nx: 6
[08:27:55.497] - relay: TRUE
[08:27:55.497] - stdout: TRUE
[08:27:55.497] - signal: TRUE
[08:27:55.497] - resignal: FALSE
[08:27:55.497] - force: TRUE
[08:27:55.497] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.497] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:55.498] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.498] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.498] signalConditionsASAP(NULL, pos=0) ... done
[08:27:55.498] resolve() on list environment ... DONE
[08:27:55.498] result() for ClusterFuture ...
[08:27:55.498] - result already collected: FutureResult
[08:27:55.498] result() for ClusterFuture ... done
[08:27:55.498] result() for ClusterFuture ...
[08:27:55.498] - result already collected: FutureResult
[08:27:55.498] result() for ClusterFuture ... done
[08:27:55.499] result() for ClusterFuture ...
[08:27:55.499] - result already collected: FutureResult
[08:27:55.499] result() for ClusterFuture ... done
[08:27:55.499] result() for ClusterFuture ...
[08:27:55.499] - result already collected: FutureResult
[08:27:55.499] result() for ClusterFuture ... done
[08:27:55.499] result() for ClusterFuture ...
[08:27:55.499] - result already collected: FutureResult
[08:27:55.499] result() for ClusterFuture ... done
[08:27:55.499] result() for ClusterFuture ...
[08:27:55.500] - result already collected: FutureResult
[08:27:55.500] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d860974dd0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[08:27:55.502] getGlobalsAndPackages() ...
[08:27:55.502] Searching for globals...
[08:27:55.502] 
[08:27:55.502] Searching for globals ... DONE
[08:27:55.502] - globals: [0] <none>
[08:27:55.502] getGlobalsAndPackages() ... DONE
[08:27:55.503] run() for ‘Future’ ...
[08:27:55.503] - state: ‘created’
[08:27:55.503] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.519] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.520] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.520]   - Field: ‘node’
[08:27:55.520]   - Field: ‘label’
[08:27:55.520]   - Field: ‘local’
[08:27:55.520]   - Field: ‘owner’
[08:27:55.521]   - Field: ‘envir’
[08:27:55.521]   - Field: ‘workers’
[08:27:55.521]   - Field: ‘packages’
[08:27:55.521]   - Field: ‘gc’
[08:27:55.521]   - Field: ‘conditions’
[08:27:55.521]   - Field: ‘persistent’
[08:27:55.521]   - Field: ‘expr’
[08:27:55.522]   - Field: ‘uuid’
[08:27:55.522]   - Field: ‘seed’
[08:27:55.522]   - Field: ‘version’
[08:27:55.522]   - Field: ‘result’
[08:27:55.522]   - Field: ‘asynchronous’
[08:27:55.522]   - Field: ‘calls’
[08:27:55.522]   - Field: ‘globals’
[08:27:55.522]   - Field: ‘stdout’
[08:27:55.523]   - Field: ‘earlySignal’
[08:27:55.523]   - Field: ‘lazy’
[08:27:55.523]   - Field: ‘state’
[08:27:55.523] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.523] - Launch lazy future ...
[08:27:55.524] Packages needed by the future expression (n = 0): <none>
[08:27:55.524] Packages needed by future strategies (n = 0): <none>
[08:27:55.525] {
[08:27:55.525]     {
[08:27:55.525]         {
[08:27:55.525]             ...future.startTime <- base::Sys.time()
[08:27:55.525]             {
[08:27:55.525]                 {
[08:27:55.525]                   {
[08:27:55.525]                     {
[08:27:55.525]                       base::local({
[08:27:55.525]                         has_future <- base::requireNamespace("future", 
[08:27:55.525]                           quietly = TRUE)
[08:27:55.525]                         if (has_future) {
[08:27:55.525]                           ns <- base::getNamespace("future")
[08:27:55.525]                           version <- ns[[".package"]][["version"]]
[08:27:55.525]                           if (is.null(version)) 
[08:27:55.525]                             version <- utils::packageVersion("future")
[08:27:55.525]                         }
[08:27:55.525]                         else {
[08:27:55.525]                           version <- NULL
[08:27:55.525]                         }
[08:27:55.525]                         if (!has_future || version < "1.8.0") {
[08:27:55.525]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.525]                             "", base::R.version$version.string), 
[08:27:55.525]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.525]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.525]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.525]                               "release", "version")], collapse = " "), 
[08:27:55.525]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.525]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.525]                             info)
[08:27:55.525]                           info <- base::paste(info, collapse = "; ")
[08:27:55.525]                           if (!has_future) {
[08:27:55.525]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.525]                               info)
[08:27:55.525]                           }
[08:27:55.525]                           else {
[08:27:55.525]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.525]                               info, version)
[08:27:55.525]                           }
[08:27:55.525]                           base::stop(msg)
[08:27:55.525]                         }
[08:27:55.525]                       })
[08:27:55.525]                     }
[08:27:55.525]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.525]                     base::options(mc.cores = 1L)
[08:27:55.525]                   }
[08:27:55.525]                   ...future.strategy.old <- future::plan("list")
[08:27:55.525]                   options(future.plan = NULL)
[08:27:55.525]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.525]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.525]                 }
[08:27:55.525]                 ...future.workdir <- getwd()
[08:27:55.525]             }
[08:27:55.525]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.525]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.525]         }
[08:27:55.525]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.525]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.525]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.525]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.525]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.525]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.525]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.525]             base::names(...future.oldOptions))
[08:27:55.525]     }
[08:27:55.525]     if (FALSE) {
[08:27:55.525]     }
[08:27:55.525]     else {
[08:27:55.525]         if (TRUE) {
[08:27:55.525]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.525]                 open = "w")
[08:27:55.525]         }
[08:27:55.525]         else {
[08:27:55.525]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.525]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.525]         }
[08:27:55.525]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.525]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.525]             base::sink(type = "output", split = FALSE)
[08:27:55.525]             base::close(...future.stdout)
[08:27:55.525]         }, add = TRUE)
[08:27:55.525]     }
[08:27:55.525]     ...future.frame <- base::sys.nframe()
[08:27:55.525]     ...future.conditions <- base::list()
[08:27:55.525]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.525]     if (FALSE) {
[08:27:55.525]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.525]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.525]     }
[08:27:55.525]     ...future.result <- base::tryCatch({
[08:27:55.525]         base::withCallingHandlers({
[08:27:55.525]             ...future.value <- base::withVisible(base::local({
[08:27:55.525]                 ...future.makeSendCondition <- base::local({
[08:27:55.525]                   sendCondition <- NULL
[08:27:55.525]                   function(frame = 1L) {
[08:27:55.525]                     if (is.function(sendCondition)) 
[08:27:55.525]                       return(sendCondition)
[08:27:55.525]                     ns <- getNamespace("parallel")
[08:27:55.525]                     if (exists("sendData", mode = "function", 
[08:27:55.525]                       envir = ns)) {
[08:27:55.525]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.525]                         envir = ns)
[08:27:55.525]                       envir <- sys.frame(frame)
[08:27:55.525]                       master <- NULL
[08:27:55.525]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.525]                         !identical(envir, emptyenv())) {
[08:27:55.525]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.525]                           inherits = FALSE)) {
[08:27:55.525]                           master <- get("master", mode = "list", 
[08:27:55.525]                             envir = envir, inherits = FALSE)
[08:27:55.525]                           if (inherits(master, c("SOCKnode", 
[08:27:55.525]                             "SOCK0node"))) {
[08:27:55.525]                             sendCondition <<- function(cond) {
[08:27:55.525]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.525]                                 success = TRUE)
[08:27:55.525]                               parallel_sendData(master, data)
[08:27:55.525]                             }
[08:27:55.525]                             return(sendCondition)
[08:27:55.525]                           }
[08:27:55.525]                         }
[08:27:55.525]                         frame <- frame + 1L
[08:27:55.525]                         envir <- sys.frame(frame)
[08:27:55.525]                       }
[08:27:55.525]                     }
[08:27:55.525]                     sendCondition <<- function(cond) NULL
[08:27:55.525]                   }
[08:27:55.525]                 })
[08:27:55.525]                 withCallingHandlers({
[08:27:55.525]                   2
[08:27:55.525]                 }, immediateCondition = function(cond) {
[08:27:55.525]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.525]                   sendCondition(cond)
[08:27:55.525]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.525]                   {
[08:27:55.525]                     inherits <- base::inherits
[08:27:55.525]                     invokeRestart <- base::invokeRestart
[08:27:55.525]                     is.null <- base::is.null
[08:27:55.525]                     muffled <- FALSE
[08:27:55.525]                     if (inherits(cond, "message")) {
[08:27:55.525]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.525]                       if (muffled) 
[08:27:55.525]                         invokeRestart("muffleMessage")
[08:27:55.525]                     }
[08:27:55.525]                     else if (inherits(cond, "warning")) {
[08:27:55.525]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.525]                       if (muffled) 
[08:27:55.525]                         invokeRestart("muffleWarning")
[08:27:55.525]                     }
[08:27:55.525]                     else if (inherits(cond, "condition")) {
[08:27:55.525]                       if (!is.null(pattern)) {
[08:27:55.525]                         computeRestarts <- base::computeRestarts
[08:27:55.525]                         grepl <- base::grepl
[08:27:55.525]                         restarts <- computeRestarts(cond)
[08:27:55.525]                         for (restart in restarts) {
[08:27:55.525]                           name <- restart$name
[08:27:55.525]                           if (is.null(name)) 
[08:27:55.525]                             next
[08:27:55.525]                           if (!grepl(pattern, name)) 
[08:27:55.525]                             next
[08:27:55.525]                           invokeRestart(restart)
[08:27:55.525]                           muffled <- TRUE
[08:27:55.525]                           break
[08:27:55.525]                         }
[08:27:55.525]                       }
[08:27:55.525]                     }
[08:27:55.525]                     invisible(muffled)
[08:27:55.525]                   }
[08:27:55.525]                   muffleCondition(cond)
[08:27:55.525]                 })
[08:27:55.525]             }))
[08:27:55.525]             future::FutureResult(value = ...future.value$value, 
[08:27:55.525]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.525]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.525]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.525]                     ...future.globalenv.names))
[08:27:55.525]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.525]         }, condition = base::local({
[08:27:55.525]             c <- base::c
[08:27:55.525]             inherits <- base::inherits
[08:27:55.525]             invokeRestart <- base::invokeRestart
[08:27:55.525]             length <- base::length
[08:27:55.525]             list <- base::list
[08:27:55.525]             seq.int <- base::seq.int
[08:27:55.525]             signalCondition <- base::signalCondition
[08:27:55.525]             sys.calls <- base::sys.calls
[08:27:55.525]             `[[` <- base::`[[`
[08:27:55.525]             `+` <- base::`+`
[08:27:55.525]             `<<-` <- base::`<<-`
[08:27:55.525]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.525]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.525]                   3L)]
[08:27:55.525]             }
[08:27:55.525]             function(cond) {
[08:27:55.525]                 is_error <- inherits(cond, "error")
[08:27:55.525]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.525]                   NULL)
[08:27:55.525]                 if (is_error) {
[08:27:55.525]                   sessionInformation <- function() {
[08:27:55.525]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.525]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.525]                       search = base::search(), system = base::Sys.info())
[08:27:55.525]                   }
[08:27:55.525]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.525]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.525]                     cond$call), session = sessionInformation(), 
[08:27:55.525]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.525]                   signalCondition(cond)
[08:27:55.525]                 }
[08:27:55.525]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.525]                 "immediateCondition"))) {
[08:27:55.525]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.525]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.525]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.525]                   if (TRUE && !signal) {
[08:27:55.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.525]                     {
[08:27:55.525]                       inherits <- base::inherits
[08:27:55.525]                       invokeRestart <- base::invokeRestart
[08:27:55.525]                       is.null <- base::is.null
[08:27:55.525]                       muffled <- FALSE
[08:27:55.525]                       if (inherits(cond, "message")) {
[08:27:55.525]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.525]                         if (muffled) 
[08:27:55.525]                           invokeRestart("muffleMessage")
[08:27:55.525]                       }
[08:27:55.525]                       else if (inherits(cond, "warning")) {
[08:27:55.525]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.525]                         if (muffled) 
[08:27:55.525]                           invokeRestart("muffleWarning")
[08:27:55.525]                       }
[08:27:55.525]                       else if (inherits(cond, "condition")) {
[08:27:55.525]                         if (!is.null(pattern)) {
[08:27:55.525]                           computeRestarts <- base::computeRestarts
[08:27:55.525]                           grepl <- base::grepl
[08:27:55.525]                           restarts <- computeRestarts(cond)
[08:27:55.525]                           for (restart in restarts) {
[08:27:55.525]                             name <- restart$name
[08:27:55.525]                             if (is.null(name)) 
[08:27:55.525]                               next
[08:27:55.525]                             if (!grepl(pattern, name)) 
[08:27:55.525]                               next
[08:27:55.525]                             invokeRestart(restart)
[08:27:55.525]                             muffled <- TRUE
[08:27:55.525]                             break
[08:27:55.525]                           }
[08:27:55.525]                         }
[08:27:55.525]                       }
[08:27:55.525]                       invisible(muffled)
[08:27:55.525]                     }
[08:27:55.525]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.525]                   }
[08:27:55.525]                 }
[08:27:55.525]                 else {
[08:27:55.525]                   if (TRUE) {
[08:27:55.525]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.525]                     {
[08:27:55.525]                       inherits <- base::inherits
[08:27:55.525]                       invokeRestart <- base::invokeRestart
[08:27:55.525]                       is.null <- base::is.null
[08:27:55.525]                       muffled <- FALSE
[08:27:55.525]                       if (inherits(cond, "message")) {
[08:27:55.525]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.525]                         if (muffled) 
[08:27:55.525]                           invokeRestart("muffleMessage")
[08:27:55.525]                       }
[08:27:55.525]                       else if (inherits(cond, "warning")) {
[08:27:55.525]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.525]                         if (muffled) 
[08:27:55.525]                           invokeRestart("muffleWarning")
[08:27:55.525]                       }
[08:27:55.525]                       else if (inherits(cond, "condition")) {
[08:27:55.525]                         if (!is.null(pattern)) {
[08:27:55.525]                           computeRestarts <- base::computeRestarts
[08:27:55.525]                           grepl <- base::grepl
[08:27:55.525]                           restarts <- computeRestarts(cond)
[08:27:55.525]                           for (restart in restarts) {
[08:27:55.525]                             name <- restart$name
[08:27:55.525]                             if (is.null(name)) 
[08:27:55.525]                               next
[08:27:55.525]                             if (!grepl(pattern, name)) 
[08:27:55.525]                               next
[08:27:55.525]                             invokeRestart(restart)
[08:27:55.525]                             muffled <- TRUE
[08:27:55.525]                             break
[08:27:55.525]                           }
[08:27:55.525]                         }
[08:27:55.525]                       }
[08:27:55.525]                       invisible(muffled)
[08:27:55.525]                     }
[08:27:55.525]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.525]                   }
[08:27:55.525]                 }
[08:27:55.525]             }
[08:27:55.525]         }))
[08:27:55.525]     }, error = function(ex) {
[08:27:55.525]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.525]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.525]                 ...future.rng), started = ...future.startTime, 
[08:27:55.525]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.525]             version = "1.8"), class = "FutureResult")
[08:27:55.525]     }, finally = {
[08:27:55.525]         if (!identical(...future.workdir, getwd())) 
[08:27:55.525]             setwd(...future.workdir)
[08:27:55.525]         {
[08:27:55.525]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.525]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.525]             }
[08:27:55.525]             base::options(...future.oldOptions)
[08:27:55.525]             if (.Platform$OS.type == "windows") {
[08:27:55.525]                 old_names <- names(...future.oldEnvVars)
[08:27:55.525]                 envs <- base::Sys.getenv()
[08:27:55.525]                 names <- names(envs)
[08:27:55.525]                 common <- intersect(names, old_names)
[08:27:55.525]                 added <- setdiff(names, old_names)
[08:27:55.525]                 removed <- setdiff(old_names, names)
[08:27:55.525]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.525]                   envs[common]]
[08:27:55.525]                 NAMES <- toupper(changed)
[08:27:55.525]                 args <- list()
[08:27:55.525]                 for (kk in seq_along(NAMES)) {
[08:27:55.525]                   name <- changed[[kk]]
[08:27:55.525]                   NAME <- NAMES[[kk]]
[08:27:55.525]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.525]                     next
[08:27:55.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.525]                 }
[08:27:55.525]                 NAMES <- toupper(added)
[08:27:55.525]                 for (kk in seq_along(NAMES)) {
[08:27:55.525]                   name <- added[[kk]]
[08:27:55.525]                   NAME <- NAMES[[kk]]
[08:27:55.525]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.525]                     next
[08:27:55.525]                   args[[name]] <- ""
[08:27:55.525]                 }
[08:27:55.525]                 NAMES <- toupper(removed)
[08:27:55.525]                 for (kk in seq_along(NAMES)) {
[08:27:55.525]                   name <- removed[[kk]]
[08:27:55.525]                   NAME <- NAMES[[kk]]
[08:27:55.525]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.525]                     next
[08:27:55.525]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.525]                 }
[08:27:55.525]                 if (length(args) > 0) 
[08:27:55.525]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.525]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.525]             }
[08:27:55.525]             else {
[08:27:55.525]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.525]             }
[08:27:55.525]             {
[08:27:55.525]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.525]                   0L) {
[08:27:55.525]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.525]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.525]                   base::options(opts)
[08:27:55.525]                 }
[08:27:55.525]                 {
[08:27:55.525]                   {
[08:27:55.525]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.525]                     NULL
[08:27:55.525]                   }
[08:27:55.525]                   options(future.plan = NULL)
[08:27:55.525]                   if (is.na(NA_character_)) 
[08:27:55.525]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.525]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.525]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.525]                     .init = FALSE)
[08:27:55.525]                 }
[08:27:55.525]             }
[08:27:55.525]         }
[08:27:55.525]     })
[08:27:55.525]     if (TRUE) {
[08:27:55.525]         base::sink(type = "output", split = FALSE)
[08:27:55.525]         if (TRUE) {
[08:27:55.525]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.525]         }
[08:27:55.525]         else {
[08:27:55.525]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.525]         }
[08:27:55.525]         base::close(...future.stdout)
[08:27:55.525]         ...future.stdout <- NULL
[08:27:55.525]     }
[08:27:55.525]     ...future.result$conditions <- ...future.conditions
[08:27:55.525]     ...future.result$finished <- base::Sys.time()
[08:27:55.525]     ...future.result
[08:27:55.525] }
[08:27:55.530] MultisessionFuture started
[08:27:55.530] - Launch lazy future ... done
[08:27:55.530] run() for ‘MultisessionFuture’ ... done
[08:27:55.530] getGlobalsAndPackages() ...
[08:27:55.530] Searching for globals...
[08:27:55.531] 
[08:27:55.531] Searching for globals ... DONE
[08:27:55.531] - globals: [0] <none>
[08:27:55.531] getGlobalsAndPackages() ... DONE
[08:27:55.532] run() for ‘Future’ ...
[08:27:55.532] - state: ‘created’
[08:27:55.532] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.552] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.552]   - Field: ‘node’
[08:27:55.553]   - Field: ‘label’
[08:27:55.553]   - Field: ‘local’
[08:27:55.553]   - Field: ‘owner’
[08:27:55.553]   - Field: ‘envir’
[08:27:55.553]   - Field: ‘workers’
[08:27:55.553]   - Field: ‘packages’
[08:27:55.553]   - Field: ‘gc’
[08:27:55.554]   - Field: ‘conditions’
[08:27:55.554]   - Field: ‘persistent’
[08:27:55.554]   - Field: ‘expr’
[08:27:55.554]   - Field: ‘uuid’
[08:27:55.554]   - Field: ‘seed’
[08:27:55.554]   - Field: ‘version’
[08:27:55.554]   - Field: ‘result’
[08:27:55.555]   - Field: ‘asynchronous’
[08:27:55.555]   - Field: ‘calls’
[08:27:55.555]   - Field: ‘globals’
[08:27:55.555]   - Field: ‘stdout’
[08:27:55.555]   - Field: ‘earlySignal’
[08:27:55.555]   - Field: ‘lazy’
[08:27:55.555]   - Field: ‘state’
[08:27:55.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.556] - Launch lazy future ...
[08:27:55.556] Packages needed by the future expression (n = 0): <none>
[08:27:55.556] Packages needed by future strategies (n = 0): <none>
[08:27:55.557] {
[08:27:55.557]     {
[08:27:55.557]         {
[08:27:55.557]             ...future.startTime <- base::Sys.time()
[08:27:55.557]             {
[08:27:55.557]                 {
[08:27:55.557]                   {
[08:27:55.557]                     {
[08:27:55.557]                       base::local({
[08:27:55.557]                         has_future <- base::requireNamespace("future", 
[08:27:55.557]                           quietly = TRUE)
[08:27:55.557]                         if (has_future) {
[08:27:55.557]                           ns <- base::getNamespace("future")
[08:27:55.557]                           version <- ns[[".package"]][["version"]]
[08:27:55.557]                           if (is.null(version)) 
[08:27:55.557]                             version <- utils::packageVersion("future")
[08:27:55.557]                         }
[08:27:55.557]                         else {
[08:27:55.557]                           version <- NULL
[08:27:55.557]                         }
[08:27:55.557]                         if (!has_future || version < "1.8.0") {
[08:27:55.557]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.557]                             "", base::R.version$version.string), 
[08:27:55.557]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.557]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.557]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.557]                               "release", "version")], collapse = " "), 
[08:27:55.557]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.557]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.557]                             info)
[08:27:55.557]                           info <- base::paste(info, collapse = "; ")
[08:27:55.557]                           if (!has_future) {
[08:27:55.557]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.557]                               info)
[08:27:55.557]                           }
[08:27:55.557]                           else {
[08:27:55.557]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.557]                               info, version)
[08:27:55.557]                           }
[08:27:55.557]                           base::stop(msg)
[08:27:55.557]                         }
[08:27:55.557]                       })
[08:27:55.557]                     }
[08:27:55.557]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.557]                     base::options(mc.cores = 1L)
[08:27:55.557]                   }
[08:27:55.557]                   ...future.strategy.old <- future::plan("list")
[08:27:55.557]                   options(future.plan = NULL)
[08:27:55.557]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.557]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.557]                 }
[08:27:55.557]                 ...future.workdir <- getwd()
[08:27:55.557]             }
[08:27:55.557]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.557]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.557]         }
[08:27:55.557]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.557]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.557]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.557]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.557]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.557]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.557]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.557]             base::names(...future.oldOptions))
[08:27:55.557]     }
[08:27:55.557]     if (FALSE) {
[08:27:55.557]     }
[08:27:55.557]     else {
[08:27:55.557]         if (TRUE) {
[08:27:55.557]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.557]                 open = "w")
[08:27:55.557]         }
[08:27:55.557]         else {
[08:27:55.557]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.557]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.557]         }
[08:27:55.557]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.557]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.557]             base::sink(type = "output", split = FALSE)
[08:27:55.557]             base::close(...future.stdout)
[08:27:55.557]         }, add = TRUE)
[08:27:55.557]     }
[08:27:55.557]     ...future.frame <- base::sys.nframe()
[08:27:55.557]     ...future.conditions <- base::list()
[08:27:55.557]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.557]     if (FALSE) {
[08:27:55.557]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.557]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.557]     }
[08:27:55.557]     ...future.result <- base::tryCatch({
[08:27:55.557]         base::withCallingHandlers({
[08:27:55.557]             ...future.value <- base::withVisible(base::local({
[08:27:55.557]                 ...future.makeSendCondition <- base::local({
[08:27:55.557]                   sendCondition <- NULL
[08:27:55.557]                   function(frame = 1L) {
[08:27:55.557]                     if (is.function(sendCondition)) 
[08:27:55.557]                       return(sendCondition)
[08:27:55.557]                     ns <- getNamespace("parallel")
[08:27:55.557]                     if (exists("sendData", mode = "function", 
[08:27:55.557]                       envir = ns)) {
[08:27:55.557]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.557]                         envir = ns)
[08:27:55.557]                       envir <- sys.frame(frame)
[08:27:55.557]                       master <- NULL
[08:27:55.557]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.557]                         !identical(envir, emptyenv())) {
[08:27:55.557]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.557]                           inherits = FALSE)) {
[08:27:55.557]                           master <- get("master", mode = "list", 
[08:27:55.557]                             envir = envir, inherits = FALSE)
[08:27:55.557]                           if (inherits(master, c("SOCKnode", 
[08:27:55.557]                             "SOCK0node"))) {
[08:27:55.557]                             sendCondition <<- function(cond) {
[08:27:55.557]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.557]                                 success = TRUE)
[08:27:55.557]                               parallel_sendData(master, data)
[08:27:55.557]                             }
[08:27:55.557]                             return(sendCondition)
[08:27:55.557]                           }
[08:27:55.557]                         }
[08:27:55.557]                         frame <- frame + 1L
[08:27:55.557]                         envir <- sys.frame(frame)
[08:27:55.557]                       }
[08:27:55.557]                     }
[08:27:55.557]                     sendCondition <<- function(cond) NULL
[08:27:55.557]                   }
[08:27:55.557]                 })
[08:27:55.557]                 withCallingHandlers({
[08:27:55.557]                   NULL
[08:27:55.557]                 }, immediateCondition = function(cond) {
[08:27:55.557]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.557]                   sendCondition(cond)
[08:27:55.557]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.557]                   {
[08:27:55.557]                     inherits <- base::inherits
[08:27:55.557]                     invokeRestart <- base::invokeRestart
[08:27:55.557]                     is.null <- base::is.null
[08:27:55.557]                     muffled <- FALSE
[08:27:55.557]                     if (inherits(cond, "message")) {
[08:27:55.557]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.557]                       if (muffled) 
[08:27:55.557]                         invokeRestart("muffleMessage")
[08:27:55.557]                     }
[08:27:55.557]                     else if (inherits(cond, "warning")) {
[08:27:55.557]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.557]                       if (muffled) 
[08:27:55.557]                         invokeRestart("muffleWarning")
[08:27:55.557]                     }
[08:27:55.557]                     else if (inherits(cond, "condition")) {
[08:27:55.557]                       if (!is.null(pattern)) {
[08:27:55.557]                         computeRestarts <- base::computeRestarts
[08:27:55.557]                         grepl <- base::grepl
[08:27:55.557]                         restarts <- computeRestarts(cond)
[08:27:55.557]                         for (restart in restarts) {
[08:27:55.557]                           name <- restart$name
[08:27:55.557]                           if (is.null(name)) 
[08:27:55.557]                             next
[08:27:55.557]                           if (!grepl(pattern, name)) 
[08:27:55.557]                             next
[08:27:55.557]                           invokeRestart(restart)
[08:27:55.557]                           muffled <- TRUE
[08:27:55.557]                           break
[08:27:55.557]                         }
[08:27:55.557]                       }
[08:27:55.557]                     }
[08:27:55.557]                     invisible(muffled)
[08:27:55.557]                   }
[08:27:55.557]                   muffleCondition(cond)
[08:27:55.557]                 })
[08:27:55.557]             }))
[08:27:55.557]             future::FutureResult(value = ...future.value$value, 
[08:27:55.557]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.557]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.557]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.557]                     ...future.globalenv.names))
[08:27:55.557]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.557]         }, condition = base::local({
[08:27:55.557]             c <- base::c
[08:27:55.557]             inherits <- base::inherits
[08:27:55.557]             invokeRestart <- base::invokeRestart
[08:27:55.557]             length <- base::length
[08:27:55.557]             list <- base::list
[08:27:55.557]             seq.int <- base::seq.int
[08:27:55.557]             signalCondition <- base::signalCondition
[08:27:55.557]             sys.calls <- base::sys.calls
[08:27:55.557]             `[[` <- base::`[[`
[08:27:55.557]             `+` <- base::`+`
[08:27:55.557]             `<<-` <- base::`<<-`
[08:27:55.557]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.557]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.557]                   3L)]
[08:27:55.557]             }
[08:27:55.557]             function(cond) {
[08:27:55.557]                 is_error <- inherits(cond, "error")
[08:27:55.557]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.557]                   NULL)
[08:27:55.557]                 if (is_error) {
[08:27:55.557]                   sessionInformation <- function() {
[08:27:55.557]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.557]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.557]                       search = base::search(), system = base::Sys.info())
[08:27:55.557]                   }
[08:27:55.557]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.557]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.557]                     cond$call), session = sessionInformation(), 
[08:27:55.557]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.557]                   signalCondition(cond)
[08:27:55.557]                 }
[08:27:55.557]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.557]                 "immediateCondition"))) {
[08:27:55.557]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.557]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.557]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.557]                   if (TRUE && !signal) {
[08:27:55.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.557]                     {
[08:27:55.557]                       inherits <- base::inherits
[08:27:55.557]                       invokeRestart <- base::invokeRestart
[08:27:55.557]                       is.null <- base::is.null
[08:27:55.557]                       muffled <- FALSE
[08:27:55.557]                       if (inherits(cond, "message")) {
[08:27:55.557]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.557]                         if (muffled) 
[08:27:55.557]                           invokeRestart("muffleMessage")
[08:27:55.557]                       }
[08:27:55.557]                       else if (inherits(cond, "warning")) {
[08:27:55.557]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.557]                         if (muffled) 
[08:27:55.557]                           invokeRestart("muffleWarning")
[08:27:55.557]                       }
[08:27:55.557]                       else if (inherits(cond, "condition")) {
[08:27:55.557]                         if (!is.null(pattern)) {
[08:27:55.557]                           computeRestarts <- base::computeRestarts
[08:27:55.557]                           grepl <- base::grepl
[08:27:55.557]                           restarts <- computeRestarts(cond)
[08:27:55.557]                           for (restart in restarts) {
[08:27:55.557]                             name <- restart$name
[08:27:55.557]                             if (is.null(name)) 
[08:27:55.557]                               next
[08:27:55.557]                             if (!grepl(pattern, name)) 
[08:27:55.557]                               next
[08:27:55.557]                             invokeRestart(restart)
[08:27:55.557]                             muffled <- TRUE
[08:27:55.557]                             break
[08:27:55.557]                           }
[08:27:55.557]                         }
[08:27:55.557]                       }
[08:27:55.557]                       invisible(muffled)
[08:27:55.557]                     }
[08:27:55.557]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.557]                   }
[08:27:55.557]                 }
[08:27:55.557]                 else {
[08:27:55.557]                   if (TRUE) {
[08:27:55.557]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.557]                     {
[08:27:55.557]                       inherits <- base::inherits
[08:27:55.557]                       invokeRestart <- base::invokeRestart
[08:27:55.557]                       is.null <- base::is.null
[08:27:55.557]                       muffled <- FALSE
[08:27:55.557]                       if (inherits(cond, "message")) {
[08:27:55.557]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.557]                         if (muffled) 
[08:27:55.557]                           invokeRestart("muffleMessage")
[08:27:55.557]                       }
[08:27:55.557]                       else if (inherits(cond, "warning")) {
[08:27:55.557]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.557]                         if (muffled) 
[08:27:55.557]                           invokeRestart("muffleWarning")
[08:27:55.557]                       }
[08:27:55.557]                       else if (inherits(cond, "condition")) {
[08:27:55.557]                         if (!is.null(pattern)) {
[08:27:55.557]                           computeRestarts <- base::computeRestarts
[08:27:55.557]                           grepl <- base::grepl
[08:27:55.557]                           restarts <- computeRestarts(cond)
[08:27:55.557]                           for (restart in restarts) {
[08:27:55.557]                             name <- restart$name
[08:27:55.557]                             if (is.null(name)) 
[08:27:55.557]                               next
[08:27:55.557]                             if (!grepl(pattern, name)) 
[08:27:55.557]                               next
[08:27:55.557]                             invokeRestart(restart)
[08:27:55.557]                             muffled <- TRUE
[08:27:55.557]                             break
[08:27:55.557]                           }
[08:27:55.557]                         }
[08:27:55.557]                       }
[08:27:55.557]                       invisible(muffled)
[08:27:55.557]                     }
[08:27:55.557]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.557]                   }
[08:27:55.557]                 }
[08:27:55.557]             }
[08:27:55.557]         }))
[08:27:55.557]     }, error = function(ex) {
[08:27:55.557]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.557]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.557]                 ...future.rng), started = ...future.startTime, 
[08:27:55.557]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.557]             version = "1.8"), class = "FutureResult")
[08:27:55.557]     }, finally = {
[08:27:55.557]         if (!identical(...future.workdir, getwd())) 
[08:27:55.557]             setwd(...future.workdir)
[08:27:55.557]         {
[08:27:55.557]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.557]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.557]             }
[08:27:55.557]             base::options(...future.oldOptions)
[08:27:55.557]             if (.Platform$OS.type == "windows") {
[08:27:55.557]                 old_names <- names(...future.oldEnvVars)
[08:27:55.557]                 envs <- base::Sys.getenv()
[08:27:55.557]                 names <- names(envs)
[08:27:55.557]                 common <- intersect(names, old_names)
[08:27:55.557]                 added <- setdiff(names, old_names)
[08:27:55.557]                 removed <- setdiff(old_names, names)
[08:27:55.557]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.557]                   envs[common]]
[08:27:55.557]                 NAMES <- toupper(changed)
[08:27:55.557]                 args <- list()
[08:27:55.557]                 for (kk in seq_along(NAMES)) {
[08:27:55.557]                   name <- changed[[kk]]
[08:27:55.557]                   NAME <- NAMES[[kk]]
[08:27:55.557]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.557]                     next
[08:27:55.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.557]                 }
[08:27:55.557]                 NAMES <- toupper(added)
[08:27:55.557]                 for (kk in seq_along(NAMES)) {
[08:27:55.557]                   name <- added[[kk]]
[08:27:55.557]                   NAME <- NAMES[[kk]]
[08:27:55.557]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.557]                     next
[08:27:55.557]                   args[[name]] <- ""
[08:27:55.557]                 }
[08:27:55.557]                 NAMES <- toupper(removed)
[08:27:55.557]                 for (kk in seq_along(NAMES)) {
[08:27:55.557]                   name <- removed[[kk]]
[08:27:55.557]                   NAME <- NAMES[[kk]]
[08:27:55.557]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.557]                     next
[08:27:55.557]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.557]                 }
[08:27:55.557]                 if (length(args) > 0) 
[08:27:55.557]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.557]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.557]             }
[08:27:55.557]             else {
[08:27:55.557]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.557]             }
[08:27:55.557]             {
[08:27:55.557]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.557]                   0L) {
[08:27:55.557]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.557]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.557]                   base::options(opts)
[08:27:55.557]                 }
[08:27:55.557]                 {
[08:27:55.557]                   {
[08:27:55.557]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.557]                     NULL
[08:27:55.557]                   }
[08:27:55.557]                   options(future.plan = NULL)
[08:27:55.557]                   if (is.na(NA_character_)) 
[08:27:55.557]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.557]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.557]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.557]                     .init = FALSE)
[08:27:55.557]                 }
[08:27:55.557]             }
[08:27:55.557]         }
[08:27:55.557]     })
[08:27:55.557]     if (TRUE) {
[08:27:55.557]         base::sink(type = "output", split = FALSE)
[08:27:55.557]         if (TRUE) {
[08:27:55.557]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.557]         }
[08:27:55.557]         else {
[08:27:55.557]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.557]         }
[08:27:55.557]         base::close(...future.stdout)
[08:27:55.557]         ...future.stdout <- NULL
[08:27:55.557]     }
[08:27:55.557]     ...future.result$conditions <- ...future.conditions
[08:27:55.557]     ...future.result$finished <- base::Sys.time()
[08:27:55.557]     ...future.result
[08:27:55.557] }
[08:27:55.561] MultisessionFuture started
[08:27:55.561] - Launch lazy future ... done
[08:27:55.561] run() for ‘MultisessionFuture’ ... done
[08:27:55.562] getGlobalsAndPackages() ...
[08:27:55.562] Searching for globals...
[08:27:55.563] - globals found: [1] ‘{’
[08:27:55.563] Searching for globals ... DONE
[08:27:55.563] Resolving globals: FALSE
[08:27:55.563] 
[08:27:55.563] 
[08:27:55.563] getGlobalsAndPackages() ... DONE
[08:27:55.564] run() for ‘Future’ ...
[08:27:55.564] - state: ‘created’
[08:27:55.564] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:27:55.580] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:27:55.580] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:27:55.580]   - Field: ‘node’
[08:27:55.580]   - Field: ‘label’
[08:27:55.580]   - Field: ‘local’
[08:27:55.580]   - Field: ‘owner’
[08:27:55.580]   - Field: ‘envir’
[08:27:55.581]   - Field: ‘workers’
[08:27:55.581]   - Field: ‘packages’
[08:27:55.581]   - Field: ‘gc’
[08:27:55.581]   - Field: ‘conditions’
[08:27:55.581]   - Field: ‘persistent’
[08:27:55.581]   - Field: ‘expr’
[08:27:55.581]   - Field: ‘uuid’
[08:27:55.581]   - Field: ‘seed’
[08:27:55.581]   - Field: ‘version’
[08:27:55.581]   - Field: ‘result’
[08:27:55.581]   - Field: ‘asynchronous’
[08:27:55.581]   - Field: ‘calls’
[08:27:55.582]   - Field: ‘globals’
[08:27:55.582]   - Field: ‘stdout’
[08:27:55.582]   - Field: ‘earlySignal’
[08:27:55.582]   - Field: ‘lazy’
[08:27:55.582]   - Field: ‘state’
[08:27:55.582] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:27:55.582] - Launch lazy future ...
[08:27:55.582] Packages needed by the future expression (n = 0): <none>
[08:27:55.582] Packages needed by future strategies (n = 0): <none>
[08:27:55.583] {
[08:27:55.583]     {
[08:27:55.583]         {
[08:27:55.583]             ...future.startTime <- base::Sys.time()
[08:27:55.583]             {
[08:27:55.583]                 {
[08:27:55.583]                   {
[08:27:55.583]                     {
[08:27:55.583]                       base::local({
[08:27:55.583]                         has_future <- base::requireNamespace("future", 
[08:27:55.583]                           quietly = TRUE)
[08:27:55.583]                         if (has_future) {
[08:27:55.583]                           ns <- base::getNamespace("future")
[08:27:55.583]                           version <- ns[[".package"]][["version"]]
[08:27:55.583]                           if (is.null(version)) 
[08:27:55.583]                             version <- utils::packageVersion("future")
[08:27:55.583]                         }
[08:27:55.583]                         else {
[08:27:55.583]                           version <- NULL
[08:27:55.583]                         }
[08:27:55.583]                         if (!has_future || version < "1.8.0") {
[08:27:55.583]                           info <- base::c(r_version = base::gsub("R version ", 
[08:27:55.583]                             "", base::R.version$version.string), 
[08:27:55.583]                             platform = base::sprintf("%s (%s-bit)", 
[08:27:55.583]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:27:55.583]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:27:55.583]                               "release", "version")], collapse = " "), 
[08:27:55.583]                             hostname = base::Sys.info()[["nodename"]])
[08:27:55.583]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:27:55.583]                             info)
[08:27:55.583]                           info <- base::paste(info, collapse = "; ")
[08:27:55.583]                           if (!has_future) {
[08:27:55.583]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:27:55.583]                               info)
[08:27:55.583]                           }
[08:27:55.583]                           else {
[08:27:55.583]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:27:55.583]                               info, version)
[08:27:55.583]                           }
[08:27:55.583]                           base::stop(msg)
[08:27:55.583]                         }
[08:27:55.583]                       })
[08:27:55.583]                     }
[08:27:55.583]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:27:55.583]                     base::options(mc.cores = 1L)
[08:27:55.583]                   }
[08:27:55.583]                   ...future.strategy.old <- future::plan("list")
[08:27:55.583]                   options(future.plan = NULL)
[08:27:55.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:27:55.583]                 }
[08:27:55.583]                 ...future.workdir <- getwd()
[08:27:55.583]             }
[08:27:55.583]             ...future.oldOptions <- base::as.list(base::.Options)
[08:27:55.583]             ...future.oldEnvVars <- base::Sys.getenv()
[08:27:55.583]         }
[08:27:55.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[08:27:55.583]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[08:27:55.583]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[08:27:55.583]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[08:27:55.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:27:55.583]             future.stdout.windows.reencode = NULL, width = 80L)
[08:27:55.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:27:55.583]             base::names(...future.oldOptions))
[08:27:55.583]     }
[08:27:55.583]     if (FALSE) {
[08:27:55.583]     }
[08:27:55.583]     else {
[08:27:55.583]         if (TRUE) {
[08:27:55.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:27:55.583]                 open = "w")
[08:27:55.583]         }
[08:27:55.583]         else {
[08:27:55.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:27:55.583]                 windows = "NUL", "/dev/null"), open = "w")
[08:27:55.583]         }
[08:27:55.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:27:55.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:27:55.583]             base::sink(type = "output", split = FALSE)
[08:27:55.583]             base::close(...future.stdout)
[08:27:55.583]         }, add = TRUE)
[08:27:55.583]     }
[08:27:55.583]     ...future.frame <- base::sys.nframe()
[08:27:55.583]     ...future.conditions <- base::list()
[08:27:55.583]     ...future.rng <- base::globalenv()$.Random.seed
[08:27:55.583]     if (FALSE) {
[08:27:55.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:27:55.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:27:55.583]     }
[08:27:55.583]     ...future.result <- base::tryCatch({
[08:27:55.583]         base::withCallingHandlers({
[08:27:55.583]             ...future.value <- base::withVisible(base::local({
[08:27:55.583]                 ...future.makeSendCondition <- base::local({
[08:27:55.583]                   sendCondition <- NULL
[08:27:55.583]                   function(frame = 1L) {
[08:27:55.583]                     if (is.function(sendCondition)) 
[08:27:55.583]                       return(sendCondition)
[08:27:55.583]                     ns <- getNamespace("parallel")
[08:27:55.583]                     if (exists("sendData", mode = "function", 
[08:27:55.583]                       envir = ns)) {
[08:27:55.583]                       parallel_sendData <- get("sendData", mode = "function", 
[08:27:55.583]                         envir = ns)
[08:27:55.583]                       envir <- sys.frame(frame)
[08:27:55.583]                       master <- NULL
[08:27:55.583]                       while (!identical(envir, .GlobalEnv) && 
[08:27:55.583]                         !identical(envir, emptyenv())) {
[08:27:55.583]                         if (exists("master", mode = "list", envir = envir, 
[08:27:55.583]                           inherits = FALSE)) {
[08:27:55.583]                           master <- get("master", mode = "list", 
[08:27:55.583]                             envir = envir, inherits = FALSE)
[08:27:55.583]                           if (inherits(master, c("SOCKnode", 
[08:27:55.583]                             "SOCK0node"))) {
[08:27:55.583]                             sendCondition <<- function(cond) {
[08:27:55.583]                               data <- list(type = "VALUE", value = cond, 
[08:27:55.583]                                 success = TRUE)
[08:27:55.583]                               parallel_sendData(master, data)
[08:27:55.583]                             }
[08:27:55.583]                             return(sendCondition)
[08:27:55.583]                           }
[08:27:55.583]                         }
[08:27:55.583]                         frame <- frame + 1L
[08:27:55.583]                         envir <- sys.frame(frame)
[08:27:55.583]                       }
[08:27:55.583]                     }
[08:27:55.583]                     sendCondition <<- function(cond) NULL
[08:27:55.583]                   }
[08:27:55.583]                 })
[08:27:55.583]                 withCallingHandlers({
[08:27:55.583]                   {
[08:27:55.583]                     4
[08:27:55.583]                   }
[08:27:55.583]                 }, immediateCondition = function(cond) {
[08:27:55.583]                   sendCondition <- ...future.makeSendCondition()
[08:27:55.583]                   sendCondition(cond)
[08:27:55.583]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.583]                   {
[08:27:55.583]                     inherits <- base::inherits
[08:27:55.583]                     invokeRestart <- base::invokeRestart
[08:27:55.583]                     is.null <- base::is.null
[08:27:55.583]                     muffled <- FALSE
[08:27:55.583]                     if (inherits(cond, "message")) {
[08:27:55.583]                       muffled <- grepl(pattern, "muffleMessage")
[08:27:55.583]                       if (muffled) 
[08:27:55.583]                         invokeRestart("muffleMessage")
[08:27:55.583]                     }
[08:27:55.583]                     else if (inherits(cond, "warning")) {
[08:27:55.583]                       muffled <- grepl(pattern, "muffleWarning")
[08:27:55.583]                       if (muffled) 
[08:27:55.583]                         invokeRestart("muffleWarning")
[08:27:55.583]                     }
[08:27:55.583]                     else if (inherits(cond, "condition")) {
[08:27:55.583]                       if (!is.null(pattern)) {
[08:27:55.583]                         computeRestarts <- base::computeRestarts
[08:27:55.583]                         grepl <- base::grepl
[08:27:55.583]                         restarts <- computeRestarts(cond)
[08:27:55.583]                         for (restart in restarts) {
[08:27:55.583]                           name <- restart$name
[08:27:55.583]                           if (is.null(name)) 
[08:27:55.583]                             next
[08:27:55.583]                           if (!grepl(pattern, name)) 
[08:27:55.583]                             next
[08:27:55.583]                           invokeRestart(restart)
[08:27:55.583]                           muffled <- TRUE
[08:27:55.583]                           break
[08:27:55.583]                         }
[08:27:55.583]                       }
[08:27:55.583]                     }
[08:27:55.583]                     invisible(muffled)
[08:27:55.583]                   }
[08:27:55.583]                   muffleCondition(cond)
[08:27:55.583]                 })
[08:27:55.583]             }))
[08:27:55.583]             future::FutureResult(value = ...future.value$value, 
[08:27:55.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.583]                   ...future.rng), globalenv = if (FALSE) 
[08:27:55.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:27:55.583]                     ...future.globalenv.names))
[08:27:55.583]                 else NULL, started = ...future.startTime, version = "1.8")
[08:27:55.583]         }, condition = base::local({
[08:27:55.583]             c <- base::c
[08:27:55.583]             inherits <- base::inherits
[08:27:55.583]             invokeRestart <- base::invokeRestart
[08:27:55.583]             length <- base::length
[08:27:55.583]             list <- base::list
[08:27:55.583]             seq.int <- base::seq.int
[08:27:55.583]             signalCondition <- base::signalCondition
[08:27:55.583]             sys.calls <- base::sys.calls
[08:27:55.583]             `[[` <- base::`[[`
[08:27:55.583]             `+` <- base::`+`
[08:27:55.583]             `<<-` <- base::`<<-`
[08:27:55.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:27:55.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:27:55.583]                   3L)]
[08:27:55.583]             }
[08:27:55.583]             function(cond) {
[08:27:55.583]                 is_error <- inherits(cond, "error")
[08:27:55.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:27:55.583]                   NULL)
[08:27:55.583]                 if (is_error) {
[08:27:55.583]                   sessionInformation <- function() {
[08:27:55.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:27:55.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:27:55.583]                       search = base::search(), system = base::Sys.info())
[08:27:55.583]                   }
[08:27:55.583]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:27:55.583]                     cond$call), session = sessionInformation(), 
[08:27:55.583]                     timestamp = base::Sys.time(), signaled = 0L)
[08:27:55.583]                   signalCondition(cond)
[08:27:55.583]                 }
[08:27:55.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:27:55.583]                 "immediateCondition"))) {
[08:27:55.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:27:55.583]                   ...future.conditions[[length(...future.conditions) + 
[08:27:55.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:27:55.583]                   if (TRUE && !signal) {
[08:27:55.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.583]                     {
[08:27:55.583]                       inherits <- base::inherits
[08:27:55.583]                       invokeRestart <- base::invokeRestart
[08:27:55.583]                       is.null <- base::is.null
[08:27:55.583]                       muffled <- FALSE
[08:27:55.583]                       if (inherits(cond, "message")) {
[08:27:55.583]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.583]                         if (muffled) 
[08:27:55.583]                           invokeRestart("muffleMessage")
[08:27:55.583]                       }
[08:27:55.583]                       else if (inherits(cond, "warning")) {
[08:27:55.583]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.583]                         if (muffled) 
[08:27:55.583]                           invokeRestart("muffleWarning")
[08:27:55.583]                       }
[08:27:55.583]                       else if (inherits(cond, "condition")) {
[08:27:55.583]                         if (!is.null(pattern)) {
[08:27:55.583]                           computeRestarts <- base::computeRestarts
[08:27:55.583]                           grepl <- base::grepl
[08:27:55.583]                           restarts <- computeRestarts(cond)
[08:27:55.583]                           for (restart in restarts) {
[08:27:55.583]                             name <- restart$name
[08:27:55.583]                             if (is.null(name)) 
[08:27:55.583]                               next
[08:27:55.583]                             if (!grepl(pattern, name)) 
[08:27:55.583]                               next
[08:27:55.583]                             invokeRestart(restart)
[08:27:55.583]                             muffled <- TRUE
[08:27:55.583]                             break
[08:27:55.583]                           }
[08:27:55.583]                         }
[08:27:55.583]                       }
[08:27:55.583]                       invisible(muffled)
[08:27:55.583]                     }
[08:27:55.583]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.583]                   }
[08:27:55.583]                 }
[08:27:55.583]                 else {
[08:27:55.583]                   if (TRUE) {
[08:27:55.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:27:55.583]                     {
[08:27:55.583]                       inherits <- base::inherits
[08:27:55.583]                       invokeRestart <- base::invokeRestart
[08:27:55.583]                       is.null <- base::is.null
[08:27:55.583]                       muffled <- FALSE
[08:27:55.583]                       if (inherits(cond, "message")) {
[08:27:55.583]                         muffled <- grepl(pattern, "muffleMessage")
[08:27:55.583]                         if (muffled) 
[08:27:55.583]                           invokeRestart("muffleMessage")
[08:27:55.583]                       }
[08:27:55.583]                       else if (inherits(cond, "warning")) {
[08:27:55.583]                         muffled <- grepl(pattern, "muffleWarning")
[08:27:55.583]                         if (muffled) 
[08:27:55.583]                           invokeRestart("muffleWarning")
[08:27:55.583]                       }
[08:27:55.583]                       else if (inherits(cond, "condition")) {
[08:27:55.583]                         if (!is.null(pattern)) {
[08:27:55.583]                           computeRestarts <- base::computeRestarts
[08:27:55.583]                           grepl <- base::grepl
[08:27:55.583]                           restarts <- computeRestarts(cond)
[08:27:55.583]                           for (restart in restarts) {
[08:27:55.583]                             name <- restart$name
[08:27:55.583]                             if (is.null(name)) 
[08:27:55.583]                               next
[08:27:55.583]                             if (!grepl(pattern, name)) 
[08:27:55.583]                               next
[08:27:55.583]                             invokeRestart(restart)
[08:27:55.583]                             muffled <- TRUE
[08:27:55.583]                             break
[08:27:55.583]                           }
[08:27:55.583]                         }
[08:27:55.583]                       }
[08:27:55.583]                       invisible(muffled)
[08:27:55.583]                     }
[08:27:55.583]                     muffleCondition(cond, pattern = "^muffle")
[08:27:55.583]                   }
[08:27:55.583]                 }
[08:27:55.583]             }
[08:27:55.583]         }))
[08:27:55.583]     }, error = function(ex) {
[08:27:55.583]         base::structure(base::list(value = NULL, visible = NULL, 
[08:27:55.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:27:55.583]                 ...future.rng), started = ...future.startTime, 
[08:27:55.583]             finished = Sys.time(), session_uuid = NA_character_, 
[08:27:55.583]             version = "1.8"), class = "FutureResult")
[08:27:55.583]     }, finally = {
[08:27:55.583]         if (!identical(...future.workdir, getwd())) 
[08:27:55.583]             setwd(...future.workdir)
[08:27:55.583]         {
[08:27:55.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:27:55.583]                 ...future.oldOptions$nwarnings <- NULL
[08:27:55.583]             }
[08:27:55.583]             base::options(...future.oldOptions)
[08:27:55.583]             if (.Platform$OS.type == "windows") {
[08:27:55.583]                 old_names <- names(...future.oldEnvVars)
[08:27:55.583]                 envs <- base::Sys.getenv()
[08:27:55.583]                 names <- names(envs)
[08:27:55.583]                 common <- intersect(names, old_names)
[08:27:55.583]                 added <- setdiff(names, old_names)
[08:27:55.583]                 removed <- setdiff(old_names, names)
[08:27:55.583]                 changed <- common[...future.oldEnvVars[common] != 
[08:27:55.583]                   envs[common]]
[08:27:55.583]                 NAMES <- toupper(changed)
[08:27:55.583]                 args <- list()
[08:27:55.583]                 for (kk in seq_along(NAMES)) {
[08:27:55.583]                   name <- changed[[kk]]
[08:27:55.583]                   NAME <- NAMES[[kk]]
[08:27:55.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.583]                     next
[08:27:55.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.583]                 }
[08:27:55.583]                 NAMES <- toupper(added)
[08:27:55.583]                 for (kk in seq_along(NAMES)) {
[08:27:55.583]                   name <- added[[kk]]
[08:27:55.583]                   NAME <- NAMES[[kk]]
[08:27:55.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.583]                     next
[08:27:55.583]                   args[[name]] <- ""
[08:27:55.583]                 }
[08:27:55.583]                 NAMES <- toupper(removed)
[08:27:55.583]                 for (kk in seq_along(NAMES)) {
[08:27:55.583]                   name <- removed[[kk]]
[08:27:55.583]                   NAME <- NAMES[[kk]]
[08:27:55.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:27:55.583]                     next
[08:27:55.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:27:55.583]                 }
[08:27:55.583]                 if (length(args) > 0) 
[08:27:55.583]                   base::do.call(base::Sys.setenv, args = args)
[08:27:55.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:27:55.583]             }
[08:27:55.583]             else {
[08:27:55.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:27:55.583]             }
[08:27:55.583]             {
[08:27:55.583]                 if (base::length(...future.futureOptionsAdded) > 
[08:27:55.583]                   0L) {
[08:27:55.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:27:55.583]                   base::names(opts) <- ...future.futureOptionsAdded
[08:27:55.583]                   base::options(opts)
[08:27:55.583]                 }
[08:27:55.583]                 {
[08:27:55.583]                   {
[08:27:55.583]                     base::options(mc.cores = ...future.mc.cores.old)
[08:27:55.583]                     NULL
[08:27:55.583]                   }
[08:27:55.583]                   options(future.plan = NULL)
[08:27:55.583]                   if (is.na(NA_character_)) 
[08:27:55.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:27:55.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:27:55.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:27:55.583]                     .init = FALSE)
[08:27:55.583]                 }
[08:27:55.583]             }
[08:27:55.583]         }
[08:27:55.583]     })
[08:27:55.583]     if (TRUE) {
[08:27:55.583]         base::sink(type = "output", split = FALSE)
[08:27:55.583]         if (TRUE) {
[08:27:55.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:27:55.583]         }
[08:27:55.583]         else {
[08:27:55.583]             ...future.result["stdout"] <- base::list(NULL)
[08:27:55.583]         }
[08:27:55.583]         base::close(...future.stdout)
[08:27:55.583]         ...future.stdout <- NULL
[08:27:55.583]     }
[08:27:55.583]     ...future.result$conditions <- ...future.conditions
[08:27:55.583]     ...future.result$finished <- base::Sys.time()
[08:27:55.583]     ...future.result
[08:27:55.583] }
[08:27:55.585] Poll #1 (0): usedNodes() = 2, workers = 2
[08:27:55.596] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.596] - Validating connection of MultisessionFuture
[08:27:55.596] - received message: FutureResult
[08:27:55.596] - Received FutureResult
[08:27:55.597] - Erased future from FutureRegistry
[08:27:55.597] result() for ClusterFuture ...
[08:27:55.597] - result already collected: FutureResult
[08:27:55.597] result() for ClusterFuture ... done
[08:27:55.597] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.597] result() for ClusterFuture ...
[08:27:55.597] - result already collected: FutureResult
[08:27:55.597] result() for ClusterFuture ... done
[08:27:55.597] result() for ClusterFuture ...
[08:27:55.597] - result already collected: FutureResult
[08:27:55.597] result() for ClusterFuture ... done
[08:27:55.598] MultisessionFuture started
[08:27:55.599] - Launch lazy future ... done
[08:27:55.599] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55d86231eee8> 
Classes 'listenv', 'environment' <environment: 0x55d8630b8650> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[08:27:55.607] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.607] - Validating connection of MultisessionFuture
[08:27:55.607] - received message: FutureResult
[08:27:55.607] - Received FutureResult
[08:27:55.607] - Erased future from FutureRegistry
[08:27:55.607] result() for ClusterFuture ...
[08:27:55.607] - result already collected: FutureResult
[08:27:55.607] result() for ClusterFuture ... done
[08:27:55.607] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[08:27:55.621] resolve() on list environment ...
[08:27:55.621]  recursive: 0
[08:27:55.622]  length: 6
[08:27:55.622]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[08:27:55.622] signalConditionsASAP(numeric, pos=1) ...
[08:27:55.622] - nx: 6
[08:27:55.622] - relay: TRUE
[08:27:55.622] - stdout: TRUE
[08:27:55.622] - signal: TRUE
[08:27:55.622] - resignal: FALSE
[08:27:55.622] - force: TRUE
[08:27:55.622] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.622] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.623]  - until=2
[08:27:55.623]  - relaying element #2
[08:27:55.623] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.623] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.623] signalConditionsASAP(NULL, pos=1) ... done
[08:27:55.623]  length: 5 (resolved future 1)
[08:27:55.623] Future #2
[08:27:55.623] result() for ClusterFuture ...
[08:27:55.623] - result already collected: FutureResult
[08:27:55.623] result() for ClusterFuture ... done
[08:27:55.623] result() for ClusterFuture ...
[08:27:55.624] - result already collected: FutureResult
[08:27:55.624] result() for ClusterFuture ... done
[08:27:55.624] signalConditionsASAP(MultisessionFuture, pos=2) ...
[08:27:55.624] - nx: 6
[08:27:55.624] - relay: TRUE
[08:27:55.624] - stdout: TRUE
[08:27:55.624] - signal: TRUE
[08:27:55.624] - resignal: FALSE
[08:27:55.624] - force: TRUE
[08:27:55.624] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.624] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[08:27:55.624]  - until=2
[08:27:55.625]  - relaying element #2
[08:27:55.625] result() for ClusterFuture ...
[08:27:55.625] - result already collected: FutureResult
[08:27:55.625] result() for ClusterFuture ... done
[08:27:55.625] result() for ClusterFuture ...
[08:27:55.625] - result already collected: FutureResult
[08:27:55.625] result() for ClusterFuture ... done
[08:27:55.625] result() for ClusterFuture ...
[08:27:55.625] - result already collected: FutureResult
[08:27:55.625] result() for ClusterFuture ... done
[08:27:55.625] result() for ClusterFuture ...
[08:27:55.625] - result already collected: FutureResult
[08:27:55.625] result() for ClusterFuture ... done
[08:27:55.626] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.626] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.626] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[08:27:55.626]  length: 4 (resolved future 2)
[08:27:55.626] Future #3
[08:27:55.626] result() for ClusterFuture ...
[08:27:55.626] - result already collected: FutureResult
[08:27:55.626] result() for ClusterFuture ... done
[08:27:55.626] result() for ClusterFuture ...
[08:27:55.626] - result already collected: FutureResult
[08:27:55.626] result() for ClusterFuture ... done
[08:27:55.627] signalConditionsASAP(MultisessionFuture, pos=3) ...
[08:27:55.627] - nx: 6
[08:27:55.627] - relay: TRUE
[08:27:55.627] - stdout: TRUE
[08:27:55.627] - signal: TRUE
[08:27:55.627] - resignal: FALSE
[08:27:55.627] - force: TRUE
[08:27:55.627] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.627] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[08:27:55.627]  - until=3
[08:27:55.627]  - relaying element #3
[08:27:55.627] result() for ClusterFuture ...
[08:27:55.627] - result already collected: FutureResult
[08:27:55.628] result() for ClusterFuture ... done
[08:27:55.628] result() for ClusterFuture ...
[08:27:55.628] - result already collected: FutureResult
[08:27:55.628] result() for ClusterFuture ... done
[08:27:55.628] result() for ClusterFuture ...
[08:27:55.628] - result already collected: FutureResult
[08:27:55.628] result() for ClusterFuture ... done
[08:27:55.628] result() for ClusterFuture ...
[08:27:55.628] - result already collected: FutureResult
[08:27:55.628] result() for ClusterFuture ... done
[08:27:55.628] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.628] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.628] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[08:27:55.629]  length: 3 (resolved future 3)
[08:27:55.639] signalConditionsASAP(NULL, pos=5) ...
[08:27:55.639] - nx: 6
[08:27:55.640] - relay: TRUE
[08:27:55.640] - stdout: TRUE
[08:27:55.640] - signal: TRUE
[08:27:55.640] - resignal: FALSE
[08:27:55.640] - force: TRUE
[08:27:55.640] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.640] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.641]  - until=6
[08:27:55.641]  - relaying element #4
[08:27:55.641]  - relaying element #6
[08:27:55.641] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.641] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.641] signalConditionsASAP(NULL, pos=5) ... done
[08:27:55.641]  length: 2 (resolved future 5)
[08:27:55.642] signalConditionsASAP(numeric, pos=6) ...
[08:27:55.642] - nx: 6
[08:27:55.642] - relay: TRUE
[08:27:55.642] - stdout: TRUE
[08:27:55.642] - signal: TRUE
[08:27:55.642] - resignal: FALSE
[08:27:55.642] - force: TRUE
[08:27:55.642] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[08:27:55.642] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.643]  - until=6
[08:27:55.643]  - relaying element #4
[08:27:55.643] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.643] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.643] signalConditionsASAP(NULL, pos=6) ... done
[08:27:55.643]  length: 1 (resolved future 6)
[08:27:55.654] receiveMessageFromWorker() for ClusterFuture ...
[08:27:55.654] - Validating connection of MultisessionFuture
[08:27:55.654] - received message: FutureResult
[08:27:55.654] - Received FutureResult
[08:27:55.654] - Erased future from FutureRegistry
[08:27:55.654] result() for ClusterFuture ...
[08:27:55.654] - result already collected: FutureResult
[08:27:55.655] result() for ClusterFuture ... done
[08:27:55.655] receiveMessageFromWorker() for ClusterFuture ... done
[08:27:55.655] Future #4
[08:27:55.655] result() for ClusterFuture ...
[08:27:55.655] - result already collected: FutureResult
[08:27:55.655] result() for ClusterFuture ... done
[08:27:55.655] result() for ClusterFuture ...
[08:27:55.655] - result already collected: FutureResult
[08:27:55.655] result() for ClusterFuture ... done
[08:27:55.655] signalConditionsASAP(MultisessionFuture, pos=4) ...
[08:27:55.655] - nx: 6
[08:27:55.655] - relay: TRUE
[08:27:55.656] - stdout: TRUE
[08:27:55.656] - signal: TRUE
[08:27:55.656] - resignal: FALSE
[08:27:55.656] - force: TRUE
[08:27:55.656] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[08:27:55.656] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[08:27:55.656]  - until=6
[08:27:55.656]  - relaying element #4
[08:27:55.656] result() for ClusterFuture ...
[08:27:55.656] - result already collected: FutureResult
[08:27:55.656] result() for ClusterFuture ... done
[08:27:55.656] result() for ClusterFuture ...
[08:27:55.657] - result already collected: FutureResult
[08:27:55.657] result() for ClusterFuture ... done
[08:27:55.657] result() for ClusterFuture ...
[08:27:55.657] - result already collected: FutureResult
[08:27:55.657] result() for ClusterFuture ... done
[08:27:55.657] result() for ClusterFuture ...
[08:27:55.657] - result already collected: FutureResult
[08:27:55.657] result() for ClusterFuture ... done
[08:27:55.657] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.657] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.657] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[08:27:55.658]  length: 0 (resolved future 4)
[08:27:55.658] Relaying remaining futures
[08:27:55.658] signalConditionsASAP(NULL, pos=0) ...
[08:27:55.658] - nx: 6
[08:27:55.658] - relay: TRUE
[08:27:55.658] - stdout: TRUE
[08:27:55.658] - signal: TRUE
[08:27:55.658] - resignal: FALSE
[08:27:55.658] - force: TRUE
[08:27:55.658] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.658] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[08:27:55.658] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[08:27:55.659] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[08:27:55.659] signalConditionsASAP(NULL, pos=0) ... done
[08:27:55.659] resolve() on list environment ... DONE
[08:27:55.659] result() for ClusterFuture ...
[08:27:55.659] - result already collected: FutureResult
[08:27:55.659] result() for ClusterFuture ... done
[08:27:55.659] result() for ClusterFuture ...
[08:27:55.659] - result already collected: FutureResult
[08:27:55.659] result() for ClusterFuture ... done
[08:27:55.659] result() for ClusterFuture ...
[08:27:55.659] - result already collected: FutureResult
[08:27:55.660] result() for ClusterFuture ... done
[08:27:55.660] result() for ClusterFuture ...
[08:27:55.660] - result already collected: FutureResult
[08:27:55.660] result() for ClusterFuture ... done
[08:27:55.660] result() for ClusterFuture ...
[08:27:55.660] - result already collected: FutureResult
[08:27:55.660] result() for ClusterFuture ... done
[08:27:55.660] result() for ClusterFuture ...
[08:27:55.660] - result already collected: FutureResult
[08:27:55.660] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55d861085d70> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[08:27:55.663] plan(): Setting new future strategy stack:
[08:27:55.663] List of future strategies:
[08:27:55.663] 1. FutureStrategy:
[08:27:55.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:27:55.663]    - tweaked: FALSE
[08:27:55.663]    - call: future::plan(oplan)
[08:27:55.664] plan(): nbrOfWorkers() = 1
> 
