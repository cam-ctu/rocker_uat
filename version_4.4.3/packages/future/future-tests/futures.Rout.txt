
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:01:28.438] plan(): Setting new future strategy stack:
[11:01:28.439] List of future strategies:
[11:01:28.439] 1. sequential:
[11:01:28.439]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.439]    - tweaked: FALSE
[11:01:28.439]    - call: future::plan("sequential")
[11:01:28.452] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> ## Backward compatibility
> if (getRversion() < "3.2.0") {
+   names <- function(x) {
+     if (class(x)[1] == "environment") {
+       ls(envir = x, all.names = TRUE)
+     } else {
+       base::names(x)
+     }
+   }
+ }
> 
> dims <- list(
+   NULL,
+   c(1, 6),
+   c(2, 3),
+   c(2, 3, 1),
+   c(2, 1, 3, 1)
+ )
> 
> 
> message("*** futures() / resolved() / value() ...")
*** futures() / resolved() / value() ...
> 
> for (cores in 1:availCores) {
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   for (type in c("list", "environment", "listenv")) {
+     message(sprintf("Type of object: %s", type))
+ 
+     for (strategy in supportedStrategies(cores)) {
+       message("Type of future: ", strategy)
+       plan(strategy)
+ 
+       for (dim in dims) {
+         message("Dimensions: ", deparse(dim))
+ 
+         if (type == "list") {
+           x <- list()
+         } else if (type == "listenv") {
+           x <- listenv()
+         } else if (type == "environment") {
+           x <- new.env()
+         }
+ 
+         x$a <- 1
+         x$b <- future(2)
+         x$c <- future(NULL)
+         if (type != "list") x$d %<-% { 4 }
+         if (type != "environment") x[[6]] <- 6
+         str(x)
+ 
+         if (!is.null(dim)) {
+           if (type != "environment") {
+             names <- names(x)
+             dim(x) <- dim
+             dimnames(x) <- lapply(dim, FUN = function(n) letters[1:n])
+             names(x) <- names
+           }
+         }
+ 
+         f <- futures(x)
+         str(f)
+         if (type != "environment") {
+           stopifnot(length(f) == length(x))
+           stopifnot(identical(names(f), names(x)))
+         }
+         stopifnot(identical(dim(f), dim(x)))
+         stopifnot(identical(dimnames(f), dimnames(x)))
+ 
+         r <- resolved(x)
+         str(r)
+         if (type != "environment") {
+           stopifnot(length(r) == length(x))
+           stopifnot(identical(names(r), names(x)))
+         }
+         stopifnot(identical(dim(r), dim(x)))
+         stopifnot(identical(dimnames(r), dimnames(x)))
+ 
+         v <- value(x)
+         str(v)
+         if (type != "environment") {
+           stopifnot(length(v) == length(x))
+           stopifnot(identical(names(v), names(x)))
+         }
+         stopifnot(identical(dim(v), dim(x)))
+         stopifnot(identical(dimnames(v), dimnames(x)))
+       } # for (dim ...)
+     } # for (strategy ...)
+ 
+     message(sprintf("*** futures() - %s ... DONE", type))
+   } # for (type ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
Type of object: list
Type of future: sequential
[11:01:28.508] plan(): Setting new future strategy stack:
[11:01:28.508] List of future strategies:
[11:01:28.508] 1. sequential:
[11:01:28.508]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.508]    - tweaked: FALSE
[11:01:28.508]    - call: plan(strategy)
[11:01:28.520] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[11:01:28.521] getGlobalsAndPackages() ...
[11:01:28.521] Searching for globals...
[11:01:28.522] 
[11:01:28.523] Searching for globals ... DONE
[11:01:28.523] - globals: [0] <none>
[11:01:28.523] getGlobalsAndPackages() ... DONE
[11:01:28.523] run() for ‘Future’ ...
[11:01:28.523] - state: ‘created’
[11:01:28.524] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.524] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.524] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.524]   - Field: ‘label’
[11:01:28.524]   - Field: ‘local’
[11:01:28.524]   - Field: ‘owner’
[11:01:28.524]   - Field: ‘envir’
[11:01:28.524]   - Field: ‘packages’
[11:01:28.525]   - Field: ‘gc’
[11:01:28.525]   - Field: ‘conditions’
[11:01:28.525]   - Field: ‘expr’
[11:01:28.525]   - Field: ‘uuid’
[11:01:28.525]   - Field: ‘seed’
[11:01:28.525]   - Field: ‘version’
[11:01:28.525]   - Field: ‘result’
[11:01:28.525]   - Field: ‘asynchronous’
[11:01:28.525]   - Field: ‘calls’
[11:01:28.525]   - Field: ‘globals’
[11:01:28.525]   - Field: ‘stdout’
[11:01:28.525]   - Field: ‘earlySignal’
[11:01:28.525]   - Field: ‘lazy’
[11:01:28.526]   - Field: ‘state’
[11:01:28.526] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.526] - Launch lazy future ...
[11:01:28.526] Packages needed by the future expression (n = 0): <none>
[11:01:28.526] Packages needed by future strategies (n = 0): <none>
[11:01:28.527] {
[11:01:28.527]     {
[11:01:28.527]         {
[11:01:28.527]             ...future.startTime <- base::Sys.time()
[11:01:28.527]             {
[11:01:28.527]                 {
[11:01:28.527]                   {
[11:01:28.527]                     base::local({
[11:01:28.527]                       has_future <- base::requireNamespace("future", 
[11:01:28.527]                         quietly = TRUE)
[11:01:28.527]                       if (has_future) {
[11:01:28.527]                         ns <- base::getNamespace("future")
[11:01:28.527]                         version <- ns[[".package"]][["version"]]
[11:01:28.527]                         if (is.null(version)) 
[11:01:28.527]                           version <- utils::packageVersion("future")
[11:01:28.527]                       }
[11:01:28.527]                       else {
[11:01:28.527]                         version <- NULL
[11:01:28.527]                       }
[11:01:28.527]                       if (!has_future || version < "1.8.0") {
[11:01:28.527]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.527]                           "", base::R.version$version.string), 
[11:01:28.527]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.527]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.527]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.527]                             "release", "version")], collapse = " "), 
[11:01:28.527]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.527]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.527]                           info)
[11:01:28.527]                         info <- base::paste(info, collapse = "; ")
[11:01:28.527]                         if (!has_future) {
[11:01:28.527]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.527]                             info)
[11:01:28.527]                         }
[11:01:28.527]                         else {
[11:01:28.527]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.527]                             info, version)
[11:01:28.527]                         }
[11:01:28.527]                         base::stop(msg)
[11:01:28.527]                       }
[11:01:28.527]                     })
[11:01:28.527]                   }
[11:01:28.527]                   ...future.strategy.old <- future::plan("list")
[11:01:28.527]                   options(future.plan = NULL)
[11:01:28.527]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.527]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.527]                 }
[11:01:28.527]                 ...future.workdir <- getwd()
[11:01:28.527]             }
[11:01:28.527]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.527]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.527]         }
[11:01:28.527]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.527]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.527]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.527]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.527]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.527]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.527]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.527]             base::names(...future.oldOptions))
[11:01:28.527]     }
[11:01:28.527]     if (FALSE) {
[11:01:28.527]     }
[11:01:28.527]     else {
[11:01:28.527]         if (TRUE) {
[11:01:28.527]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.527]                 open = "w")
[11:01:28.527]         }
[11:01:28.527]         else {
[11:01:28.527]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.527]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.527]         }
[11:01:28.527]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.527]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.527]             base::sink(type = "output", split = FALSE)
[11:01:28.527]             base::close(...future.stdout)
[11:01:28.527]         }, add = TRUE)
[11:01:28.527]     }
[11:01:28.527]     ...future.frame <- base::sys.nframe()
[11:01:28.527]     ...future.conditions <- base::list()
[11:01:28.527]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.527]     if (FALSE) {
[11:01:28.527]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.527]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.527]     }
[11:01:28.527]     ...future.result <- base::tryCatch({
[11:01:28.527]         base::withCallingHandlers({
[11:01:28.527]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.527]             future::FutureResult(value = ...future.value$value, 
[11:01:28.527]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.527]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.527]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.527]                     ...future.globalenv.names))
[11:01:28.527]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.527]         }, condition = base::local({
[11:01:28.527]             c <- base::c
[11:01:28.527]             inherits <- base::inherits
[11:01:28.527]             invokeRestart <- base::invokeRestart
[11:01:28.527]             length <- base::length
[11:01:28.527]             list <- base::list
[11:01:28.527]             seq.int <- base::seq.int
[11:01:28.527]             signalCondition <- base::signalCondition
[11:01:28.527]             sys.calls <- base::sys.calls
[11:01:28.527]             `[[` <- base::`[[`
[11:01:28.527]             `+` <- base::`+`
[11:01:28.527]             `<<-` <- base::`<<-`
[11:01:28.527]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.527]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.527]                   3L)]
[11:01:28.527]             }
[11:01:28.527]             function(cond) {
[11:01:28.527]                 is_error <- inherits(cond, "error")
[11:01:28.527]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.527]                   NULL)
[11:01:28.527]                 if (is_error) {
[11:01:28.527]                   sessionInformation <- function() {
[11:01:28.527]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.527]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.527]                       search = base::search(), system = base::Sys.info())
[11:01:28.527]                   }
[11:01:28.527]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.527]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.527]                     cond$call), session = sessionInformation(), 
[11:01:28.527]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.527]                   signalCondition(cond)
[11:01:28.527]                 }
[11:01:28.527]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.527]                 "immediateCondition"))) {
[11:01:28.527]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.527]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.527]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.527]                   if (TRUE && !signal) {
[11:01:28.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.527]                     {
[11:01:28.527]                       inherits <- base::inherits
[11:01:28.527]                       invokeRestart <- base::invokeRestart
[11:01:28.527]                       is.null <- base::is.null
[11:01:28.527]                       muffled <- FALSE
[11:01:28.527]                       if (inherits(cond, "message")) {
[11:01:28.527]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.527]                         if (muffled) 
[11:01:28.527]                           invokeRestart("muffleMessage")
[11:01:28.527]                       }
[11:01:28.527]                       else if (inherits(cond, "warning")) {
[11:01:28.527]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.527]                         if (muffled) 
[11:01:28.527]                           invokeRestart("muffleWarning")
[11:01:28.527]                       }
[11:01:28.527]                       else if (inherits(cond, "condition")) {
[11:01:28.527]                         if (!is.null(pattern)) {
[11:01:28.527]                           computeRestarts <- base::computeRestarts
[11:01:28.527]                           grepl <- base::grepl
[11:01:28.527]                           restarts <- computeRestarts(cond)
[11:01:28.527]                           for (restart in restarts) {
[11:01:28.527]                             name <- restart$name
[11:01:28.527]                             if (is.null(name)) 
[11:01:28.527]                               next
[11:01:28.527]                             if (!grepl(pattern, name)) 
[11:01:28.527]                               next
[11:01:28.527]                             invokeRestart(restart)
[11:01:28.527]                             muffled <- TRUE
[11:01:28.527]                             break
[11:01:28.527]                           }
[11:01:28.527]                         }
[11:01:28.527]                       }
[11:01:28.527]                       invisible(muffled)
[11:01:28.527]                     }
[11:01:28.527]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.527]                   }
[11:01:28.527]                 }
[11:01:28.527]                 else {
[11:01:28.527]                   if (TRUE) {
[11:01:28.527]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.527]                     {
[11:01:28.527]                       inherits <- base::inherits
[11:01:28.527]                       invokeRestart <- base::invokeRestart
[11:01:28.527]                       is.null <- base::is.null
[11:01:28.527]                       muffled <- FALSE
[11:01:28.527]                       if (inherits(cond, "message")) {
[11:01:28.527]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.527]                         if (muffled) 
[11:01:28.527]                           invokeRestart("muffleMessage")
[11:01:28.527]                       }
[11:01:28.527]                       else if (inherits(cond, "warning")) {
[11:01:28.527]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.527]                         if (muffled) 
[11:01:28.527]                           invokeRestart("muffleWarning")
[11:01:28.527]                       }
[11:01:28.527]                       else if (inherits(cond, "condition")) {
[11:01:28.527]                         if (!is.null(pattern)) {
[11:01:28.527]                           computeRestarts <- base::computeRestarts
[11:01:28.527]                           grepl <- base::grepl
[11:01:28.527]                           restarts <- computeRestarts(cond)
[11:01:28.527]                           for (restart in restarts) {
[11:01:28.527]                             name <- restart$name
[11:01:28.527]                             if (is.null(name)) 
[11:01:28.527]                               next
[11:01:28.527]                             if (!grepl(pattern, name)) 
[11:01:28.527]                               next
[11:01:28.527]                             invokeRestart(restart)
[11:01:28.527]                             muffled <- TRUE
[11:01:28.527]                             break
[11:01:28.527]                           }
[11:01:28.527]                         }
[11:01:28.527]                       }
[11:01:28.527]                       invisible(muffled)
[11:01:28.527]                     }
[11:01:28.527]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.527]                   }
[11:01:28.527]                 }
[11:01:28.527]             }
[11:01:28.527]         }))
[11:01:28.527]     }, error = function(ex) {
[11:01:28.527]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.527]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.527]                 ...future.rng), started = ...future.startTime, 
[11:01:28.527]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.527]             version = "1.8"), class = "FutureResult")
[11:01:28.527]     }, finally = {
[11:01:28.527]         if (!identical(...future.workdir, getwd())) 
[11:01:28.527]             setwd(...future.workdir)
[11:01:28.527]         {
[11:01:28.527]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.527]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.527]             }
[11:01:28.527]             base::options(...future.oldOptions)
[11:01:28.527]             if (.Platform$OS.type == "windows") {
[11:01:28.527]                 old_names <- names(...future.oldEnvVars)
[11:01:28.527]                 envs <- base::Sys.getenv()
[11:01:28.527]                 names <- names(envs)
[11:01:28.527]                 common <- intersect(names, old_names)
[11:01:28.527]                 added <- setdiff(names, old_names)
[11:01:28.527]                 removed <- setdiff(old_names, names)
[11:01:28.527]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.527]                   envs[common]]
[11:01:28.527]                 NAMES <- toupper(changed)
[11:01:28.527]                 args <- list()
[11:01:28.527]                 for (kk in seq_along(NAMES)) {
[11:01:28.527]                   name <- changed[[kk]]
[11:01:28.527]                   NAME <- NAMES[[kk]]
[11:01:28.527]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.527]                     next
[11:01:28.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.527]                 }
[11:01:28.527]                 NAMES <- toupper(added)
[11:01:28.527]                 for (kk in seq_along(NAMES)) {
[11:01:28.527]                   name <- added[[kk]]
[11:01:28.527]                   NAME <- NAMES[[kk]]
[11:01:28.527]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.527]                     next
[11:01:28.527]                   args[[name]] <- ""
[11:01:28.527]                 }
[11:01:28.527]                 NAMES <- toupper(removed)
[11:01:28.527]                 for (kk in seq_along(NAMES)) {
[11:01:28.527]                   name <- removed[[kk]]
[11:01:28.527]                   NAME <- NAMES[[kk]]
[11:01:28.527]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.527]                     next
[11:01:28.527]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.527]                 }
[11:01:28.527]                 if (length(args) > 0) 
[11:01:28.527]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.527]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.527]             }
[11:01:28.527]             else {
[11:01:28.527]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.527]             }
[11:01:28.527]             {
[11:01:28.527]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.527]                   0L) {
[11:01:28.527]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.527]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.527]                   base::options(opts)
[11:01:28.527]                 }
[11:01:28.527]                 {
[11:01:28.527]                   {
[11:01:28.527]                     NULL
[11:01:28.527]                     RNGkind("Mersenne-Twister")
[11:01:28.527]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.527]                       inherits = FALSE)
[11:01:28.527]                   }
[11:01:28.527]                   options(future.plan = NULL)
[11:01:28.527]                   if (is.na(NA_character_)) 
[11:01:28.527]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.527]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.527]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.527]                     .init = FALSE)
[11:01:28.527]                 }
[11:01:28.527]             }
[11:01:28.527]         }
[11:01:28.527]     })
[11:01:28.527]     if (TRUE) {
[11:01:28.527]         base::sink(type = "output", split = FALSE)
[11:01:28.527]         if (TRUE) {
[11:01:28.527]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.527]         }
[11:01:28.527]         else {
[11:01:28.527]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.527]         }
[11:01:28.527]         base::close(...future.stdout)
[11:01:28.527]         ...future.stdout <- NULL
[11:01:28.527]     }
[11:01:28.527]     ...future.result$conditions <- ...future.conditions
[11:01:28.527]     ...future.result$finished <- base::Sys.time()
[11:01:28.527]     ...future.result
[11:01:28.527] }
[11:01:28.529] plan(): Setting new future strategy stack:
[11:01:28.529] List of future strategies:
[11:01:28.529] 1. sequential:
[11:01:28.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.529]    - tweaked: FALSE
[11:01:28.529]    - call: NULL
[11:01:28.530] plan(): nbrOfWorkers() = 1
[11:01:28.531] plan(): Setting new future strategy stack:
[11:01:28.531] List of future strategies:
[11:01:28.531] 1. sequential:
[11:01:28.531]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.531]    - tweaked: FALSE
[11:01:28.531]    - call: plan(strategy)
[11:01:28.531] plan(): nbrOfWorkers() = 1
[11:01:28.531] SequentialFuture started (and completed)
[11:01:28.532] - Launch lazy future ... done
[11:01:28.532] run() for ‘SequentialFuture’ ... done
[11:01:28.532] getGlobalsAndPackages() ...
[11:01:28.532] Searching for globals...
[11:01:28.532] 
[11:01:28.532] Searching for globals ... DONE
[11:01:28.532] - globals: [0] <none>
[11:01:28.532] getGlobalsAndPackages() ... DONE
[11:01:28.533] run() for ‘Future’ ...
[11:01:28.533] - state: ‘created’
[11:01:28.533] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.533] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.533]   - Field: ‘label’
[11:01:28.533]   - Field: ‘local’
[11:01:28.533]   - Field: ‘owner’
[11:01:28.534]   - Field: ‘envir’
[11:01:28.534]   - Field: ‘packages’
[11:01:28.534]   - Field: ‘gc’
[11:01:28.534]   - Field: ‘conditions’
[11:01:28.534]   - Field: ‘expr’
[11:01:28.534]   - Field: ‘uuid’
[11:01:28.534]   - Field: ‘seed’
[11:01:28.534]   - Field: ‘version’
[11:01:28.534]   - Field: ‘result’
[11:01:28.534]   - Field: ‘asynchronous’
[11:01:28.534]   - Field: ‘calls’
[11:01:28.534]   - Field: ‘globals’
[11:01:28.534]   - Field: ‘stdout’
[11:01:28.535]   - Field: ‘earlySignal’
[11:01:28.535]   - Field: ‘lazy’
[11:01:28.535]   - Field: ‘state’
[11:01:28.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.535] - Launch lazy future ...
[11:01:28.535] Packages needed by the future expression (n = 0): <none>
[11:01:28.535] Packages needed by future strategies (n = 0): <none>
[11:01:28.536] {
[11:01:28.536]     {
[11:01:28.536]         {
[11:01:28.536]             ...future.startTime <- base::Sys.time()
[11:01:28.536]             {
[11:01:28.536]                 {
[11:01:28.536]                   {
[11:01:28.536]                     base::local({
[11:01:28.536]                       has_future <- base::requireNamespace("future", 
[11:01:28.536]                         quietly = TRUE)
[11:01:28.536]                       if (has_future) {
[11:01:28.536]                         ns <- base::getNamespace("future")
[11:01:28.536]                         version <- ns[[".package"]][["version"]]
[11:01:28.536]                         if (is.null(version)) 
[11:01:28.536]                           version <- utils::packageVersion("future")
[11:01:28.536]                       }
[11:01:28.536]                       else {
[11:01:28.536]                         version <- NULL
[11:01:28.536]                       }
[11:01:28.536]                       if (!has_future || version < "1.8.0") {
[11:01:28.536]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.536]                           "", base::R.version$version.string), 
[11:01:28.536]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.536]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.536]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.536]                             "release", "version")], collapse = " "), 
[11:01:28.536]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.536]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.536]                           info)
[11:01:28.536]                         info <- base::paste(info, collapse = "; ")
[11:01:28.536]                         if (!has_future) {
[11:01:28.536]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.536]                             info)
[11:01:28.536]                         }
[11:01:28.536]                         else {
[11:01:28.536]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.536]                             info, version)
[11:01:28.536]                         }
[11:01:28.536]                         base::stop(msg)
[11:01:28.536]                       }
[11:01:28.536]                     })
[11:01:28.536]                   }
[11:01:28.536]                   ...future.strategy.old <- future::plan("list")
[11:01:28.536]                   options(future.plan = NULL)
[11:01:28.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.536]                 }
[11:01:28.536]                 ...future.workdir <- getwd()
[11:01:28.536]             }
[11:01:28.536]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.536]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.536]         }
[11:01:28.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.536]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.536]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.536]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.536]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.536]             base::names(...future.oldOptions))
[11:01:28.536]     }
[11:01:28.536]     if (FALSE) {
[11:01:28.536]     }
[11:01:28.536]     else {
[11:01:28.536]         if (TRUE) {
[11:01:28.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.536]                 open = "w")
[11:01:28.536]         }
[11:01:28.536]         else {
[11:01:28.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.536]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.536]         }
[11:01:28.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.536]             base::sink(type = "output", split = FALSE)
[11:01:28.536]             base::close(...future.stdout)
[11:01:28.536]         }, add = TRUE)
[11:01:28.536]     }
[11:01:28.536]     ...future.frame <- base::sys.nframe()
[11:01:28.536]     ...future.conditions <- base::list()
[11:01:28.536]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.536]     if (FALSE) {
[11:01:28.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.536]     }
[11:01:28.536]     ...future.result <- base::tryCatch({
[11:01:28.536]         base::withCallingHandlers({
[11:01:28.536]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.536]             future::FutureResult(value = ...future.value$value, 
[11:01:28.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.536]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.536]                     ...future.globalenv.names))
[11:01:28.536]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.536]         }, condition = base::local({
[11:01:28.536]             c <- base::c
[11:01:28.536]             inherits <- base::inherits
[11:01:28.536]             invokeRestart <- base::invokeRestart
[11:01:28.536]             length <- base::length
[11:01:28.536]             list <- base::list
[11:01:28.536]             seq.int <- base::seq.int
[11:01:28.536]             signalCondition <- base::signalCondition
[11:01:28.536]             sys.calls <- base::sys.calls
[11:01:28.536]             `[[` <- base::`[[`
[11:01:28.536]             `+` <- base::`+`
[11:01:28.536]             `<<-` <- base::`<<-`
[11:01:28.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.536]                   3L)]
[11:01:28.536]             }
[11:01:28.536]             function(cond) {
[11:01:28.536]                 is_error <- inherits(cond, "error")
[11:01:28.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.536]                   NULL)
[11:01:28.536]                 if (is_error) {
[11:01:28.536]                   sessionInformation <- function() {
[11:01:28.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.536]                       search = base::search(), system = base::Sys.info())
[11:01:28.536]                   }
[11:01:28.536]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.536]                     cond$call), session = sessionInformation(), 
[11:01:28.536]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.536]                   signalCondition(cond)
[11:01:28.536]                 }
[11:01:28.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.536]                 "immediateCondition"))) {
[11:01:28.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.536]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.536]                   if (TRUE && !signal) {
[11:01:28.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.536]                     {
[11:01:28.536]                       inherits <- base::inherits
[11:01:28.536]                       invokeRestart <- base::invokeRestart
[11:01:28.536]                       is.null <- base::is.null
[11:01:28.536]                       muffled <- FALSE
[11:01:28.536]                       if (inherits(cond, "message")) {
[11:01:28.536]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.536]                         if (muffled) 
[11:01:28.536]                           invokeRestart("muffleMessage")
[11:01:28.536]                       }
[11:01:28.536]                       else if (inherits(cond, "warning")) {
[11:01:28.536]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.536]                         if (muffled) 
[11:01:28.536]                           invokeRestart("muffleWarning")
[11:01:28.536]                       }
[11:01:28.536]                       else if (inherits(cond, "condition")) {
[11:01:28.536]                         if (!is.null(pattern)) {
[11:01:28.536]                           computeRestarts <- base::computeRestarts
[11:01:28.536]                           grepl <- base::grepl
[11:01:28.536]                           restarts <- computeRestarts(cond)
[11:01:28.536]                           for (restart in restarts) {
[11:01:28.536]                             name <- restart$name
[11:01:28.536]                             if (is.null(name)) 
[11:01:28.536]                               next
[11:01:28.536]                             if (!grepl(pattern, name)) 
[11:01:28.536]                               next
[11:01:28.536]                             invokeRestart(restart)
[11:01:28.536]                             muffled <- TRUE
[11:01:28.536]                             break
[11:01:28.536]                           }
[11:01:28.536]                         }
[11:01:28.536]                       }
[11:01:28.536]                       invisible(muffled)
[11:01:28.536]                     }
[11:01:28.536]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.536]                   }
[11:01:28.536]                 }
[11:01:28.536]                 else {
[11:01:28.536]                   if (TRUE) {
[11:01:28.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.536]                     {
[11:01:28.536]                       inherits <- base::inherits
[11:01:28.536]                       invokeRestart <- base::invokeRestart
[11:01:28.536]                       is.null <- base::is.null
[11:01:28.536]                       muffled <- FALSE
[11:01:28.536]                       if (inherits(cond, "message")) {
[11:01:28.536]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.536]                         if (muffled) 
[11:01:28.536]                           invokeRestart("muffleMessage")
[11:01:28.536]                       }
[11:01:28.536]                       else if (inherits(cond, "warning")) {
[11:01:28.536]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.536]                         if (muffled) 
[11:01:28.536]                           invokeRestart("muffleWarning")
[11:01:28.536]                       }
[11:01:28.536]                       else if (inherits(cond, "condition")) {
[11:01:28.536]                         if (!is.null(pattern)) {
[11:01:28.536]                           computeRestarts <- base::computeRestarts
[11:01:28.536]                           grepl <- base::grepl
[11:01:28.536]                           restarts <- computeRestarts(cond)
[11:01:28.536]                           for (restart in restarts) {
[11:01:28.536]                             name <- restart$name
[11:01:28.536]                             if (is.null(name)) 
[11:01:28.536]                               next
[11:01:28.536]                             if (!grepl(pattern, name)) 
[11:01:28.536]                               next
[11:01:28.536]                             invokeRestart(restart)
[11:01:28.536]                             muffled <- TRUE
[11:01:28.536]                             break
[11:01:28.536]                           }
[11:01:28.536]                         }
[11:01:28.536]                       }
[11:01:28.536]                       invisible(muffled)
[11:01:28.536]                     }
[11:01:28.536]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.536]                   }
[11:01:28.536]                 }
[11:01:28.536]             }
[11:01:28.536]         }))
[11:01:28.536]     }, error = function(ex) {
[11:01:28.536]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.536]                 ...future.rng), started = ...future.startTime, 
[11:01:28.536]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.536]             version = "1.8"), class = "FutureResult")
[11:01:28.536]     }, finally = {
[11:01:28.536]         if (!identical(...future.workdir, getwd())) 
[11:01:28.536]             setwd(...future.workdir)
[11:01:28.536]         {
[11:01:28.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.536]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.536]             }
[11:01:28.536]             base::options(...future.oldOptions)
[11:01:28.536]             if (.Platform$OS.type == "windows") {
[11:01:28.536]                 old_names <- names(...future.oldEnvVars)
[11:01:28.536]                 envs <- base::Sys.getenv()
[11:01:28.536]                 names <- names(envs)
[11:01:28.536]                 common <- intersect(names, old_names)
[11:01:28.536]                 added <- setdiff(names, old_names)
[11:01:28.536]                 removed <- setdiff(old_names, names)
[11:01:28.536]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.536]                   envs[common]]
[11:01:28.536]                 NAMES <- toupper(changed)
[11:01:28.536]                 args <- list()
[11:01:28.536]                 for (kk in seq_along(NAMES)) {
[11:01:28.536]                   name <- changed[[kk]]
[11:01:28.536]                   NAME <- NAMES[[kk]]
[11:01:28.536]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.536]                     next
[11:01:28.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.536]                 }
[11:01:28.536]                 NAMES <- toupper(added)
[11:01:28.536]                 for (kk in seq_along(NAMES)) {
[11:01:28.536]                   name <- added[[kk]]
[11:01:28.536]                   NAME <- NAMES[[kk]]
[11:01:28.536]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.536]                     next
[11:01:28.536]                   args[[name]] <- ""
[11:01:28.536]                 }
[11:01:28.536]                 NAMES <- toupper(removed)
[11:01:28.536]                 for (kk in seq_along(NAMES)) {
[11:01:28.536]                   name <- removed[[kk]]
[11:01:28.536]                   NAME <- NAMES[[kk]]
[11:01:28.536]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.536]                     next
[11:01:28.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.536]                 }
[11:01:28.536]                 if (length(args) > 0) 
[11:01:28.536]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.536]             }
[11:01:28.536]             else {
[11:01:28.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.536]             }
[11:01:28.536]             {
[11:01:28.536]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.536]                   0L) {
[11:01:28.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.536]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.536]                   base::options(opts)
[11:01:28.536]                 }
[11:01:28.536]                 {
[11:01:28.536]                   {
[11:01:28.536]                     NULL
[11:01:28.536]                     RNGkind("Mersenne-Twister")
[11:01:28.536]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.536]                       inherits = FALSE)
[11:01:28.536]                   }
[11:01:28.536]                   options(future.plan = NULL)
[11:01:28.536]                   if (is.na(NA_character_)) 
[11:01:28.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.536]                     .init = FALSE)
[11:01:28.536]                 }
[11:01:28.536]             }
[11:01:28.536]         }
[11:01:28.536]     })
[11:01:28.536]     if (TRUE) {
[11:01:28.536]         base::sink(type = "output", split = FALSE)
[11:01:28.536]         if (TRUE) {
[11:01:28.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.536]         }
[11:01:28.536]         else {
[11:01:28.536]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.536]         }
[11:01:28.536]         base::close(...future.stdout)
[11:01:28.536]         ...future.stdout <- NULL
[11:01:28.536]     }
[11:01:28.536]     ...future.result$conditions <- ...future.conditions
[11:01:28.536]     ...future.result$finished <- base::Sys.time()
[11:01:28.536]     ...future.result
[11:01:28.536] }
[11:01:28.537] plan(): Setting new future strategy stack:
[11:01:28.537] List of future strategies:
[11:01:28.537] 1. sequential:
[11:01:28.537]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.537]    - tweaked: FALSE
[11:01:28.537]    - call: NULL
[11:01:28.538] plan(): nbrOfWorkers() = 1
[11:01:28.538] plan(): Setting new future strategy stack:
[11:01:28.539] List of future strategies:
[11:01:28.539] 1. sequential:
[11:01:28.539]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.539]    - tweaked: FALSE
[11:01:28.539]    - call: plan(strategy)
[11:01:28.539] plan(): nbrOfWorkers() = 1
[11:01:28.539] SequentialFuture started (and completed)
[11:01:28.539] - Launch lazy future ... done
[11:01:28.539] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c50b88f0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c651b198> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c50b88f0> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c651b198> 
 $  : NULL
 $  : NULL
 $  : num 6
[11:01:28.545] resolved() for ‘SequentialFuture’ ...
[11:01:28.545] - state: ‘finished’
[11:01:28.545] - run: TRUE
[11:01:28.545] - result: ‘FutureResult’
[11:01:28.545] resolved() for ‘SequentialFuture’ ... done
[11:01:28.545] resolved() for ‘SequentialFuture’ ...
[11:01:28.545] - state: ‘finished’
[11:01:28.545] - run: TRUE
[11:01:28.545] - result: ‘FutureResult’
[11:01:28.545] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:28.546] resolve() on list ...
[11:01:28.546]  recursive: 0
[11:01:28.547]  length: 6
[11:01:28.547]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:28.547] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.547] - nx: 6
[11:01:28.547] - relay: TRUE
[11:01:28.547] - stdout: TRUE
[11:01:28.547] - signal: TRUE
[11:01:28.547] - resignal: FALSE
[11:01:28.547] - force: TRUE
[11:01:28.547] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.547] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.547]  - until=2
[11:01:28.548]  - relaying element #2
[11:01:28.548] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.548] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.548] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.548]  length: 5 (resolved future 1)
[11:01:28.548] resolved() for ‘SequentialFuture’ ...
[11:01:28.548] - state: ‘finished’
[11:01:28.548] - run: TRUE
[11:01:28.548] - result: ‘FutureResult’
[11:01:28.548] resolved() for ‘SequentialFuture’ ... done
[11:01:28.548] Future #2
[11:01:28.549] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.549] - nx: 6
[11:01:28.549] - relay: TRUE
[11:01:28.549] - stdout: TRUE
[11:01:28.549] - signal: TRUE
[11:01:28.549] - resignal: FALSE
[11:01:28.549] - force: TRUE
[11:01:28.551] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.551] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.551]  - until=2
[11:01:28.551]  - relaying element #2
[11:01:28.551] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.551] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.551] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.551]  length: 4 (resolved future 2)
[11:01:28.552] resolved() for ‘SequentialFuture’ ...
[11:01:28.552] - state: ‘finished’
[11:01:28.552] - run: TRUE
[11:01:28.552] - result: ‘FutureResult’
[11:01:28.552] resolved() for ‘SequentialFuture’ ... done
[11:01:28.552] Future #3
[11:01:28.552] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.552] - nx: 6
[11:01:28.552] - relay: TRUE
[11:01:28.552] - stdout: TRUE
[11:01:28.552] - signal: TRUE
[11:01:28.553] - resignal: FALSE
[11:01:28.553] - force: TRUE
[11:01:28.553] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.553] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.553]  - until=3
[11:01:28.553]  - relaying element #3
[11:01:28.553] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.553] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.553] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.553]  length: 3 (resolved future 3)
[11:01:28.553] signalConditionsASAP(NULL, pos=4) ...
[11:01:28.554] - nx: 6
[11:01:28.554] - relay: TRUE
[11:01:28.554] - stdout: TRUE
[11:01:28.554] - signal: TRUE
[11:01:28.554] - resignal: FALSE
[11:01:28.554] - force: TRUE
[11:01:28.554] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.554] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.554]  - until=5
[11:01:28.554]  - relaying element #5
[11:01:28.554] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.554] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.554] signalConditionsASAP(NULL, pos=4) ... done
[11:01:28.555]  length: 2 (resolved future 4)
[11:01:28.555] signalConditionsASAP(NULL, pos=5) ...
[11:01:28.555] - nx: 6
[11:01:28.555] - relay: TRUE
[11:01:28.555] - stdout: TRUE
[11:01:28.555] - signal: TRUE
[11:01:28.555] - resignal: FALSE
[11:01:28.555] - force: TRUE
[11:01:28.555] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.555] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.555]  - until=6
[11:01:28.555]  - relaying element #6
[11:01:28.555] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.555] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.556] signalConditionsASAP(NULL, pos=5) ... done
[11:01:28.556]  length: 1 (resolved future 5)
[11:01:28.556] signalConditionsASAP(numeric, pos=6) ...
[11:01:28.556] - nx: 6
[11:01:28.556] - relay: TRUE
[11:01:28.556] - stdout: TRUE
[11:01:28.556] - signal: TRUE
[11:01:28.556] - resignal: FALSE
[11:01:28.556] - force: TRUE
[11:01:28.556] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.556] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.556]  - until=6
[11:01:28.556] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.557] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.557] signalConditionsASAP(numeric, pos=6) ... done
[11:01:28.557]  length: 0 (resolved future 6)
[11:01:28.557] Relaying remaining futures
[11:01:28.557] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.557] - nx: 6
[11:01:28.557] - relay: TRUE
[11:01:28.557] - stdout: TRUE
[11:01:28.557] - signal: TRUE
[11:01:28.557] - resignal: FALSE
[11:01:28.557] - force: TRUE
[11:01:28.557] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.557] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:28.558] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.558] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.558] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.558] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[11:01:28.560] getGlobalsAndPackages() ...
[11:01:28.560] Searching for globals...
[11:01:28.560] 
[11:01:28.560] Searching for globals ... DONE
[11:01:28.560] - globals: [0] <none>
[11:01:28.560] getGlobalsAndPackages() ... DONE
[11:01:28.561] run() for ‘Future’ ...
[11:01:28.561] - state: ‘created’
[11:01:28.561] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.561] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.561] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.561]   - Field: ‘label’
[11:01:28.561]   - Field: ‘local’
[11:01:28.561]   - Field: ‘owner’
[11:01:28.561]   - Field: ‘envir’
[11:01:28.561]   - Field: ‘packages’
[11:01:28.562]   - Field: ‘gc’
[11:01:28.562]   - Field: ‘conditions’
[11:01:28.562]   - Field: ‘expr’
[11:01:28.562]   - Field: ‘uuid’
[11:01:28.562]   - Field: ‘seed’
[11:01:28.562]   - Field: ‘version’
[11:01:28.562]   - Field: ‘result’
[11:01:28.562]   - Field: ‘asynchronous’
[11:01:28.562]   - Field: ‘calls’
[11:01:28.562]   - Field: ‘globals’
[11:01:28.562]   - Field: ‘stdout’
[11:01:28.563]   - Field: ‘earlySignal’
[11:01:28.563]   - Field: ‘lazy’
[11:01:28.563]   - Field: ‘state’
[11:01:28.563] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.563] - Launch lazy future ...
[11:01:28.563] Packages needed by the future expression (n = 0): <none>
[11:01:28.563] Packages needed by future strategies (n = 0): <none>
[11:01:28.563] {
[11:01:28.563]     {
[11:01:28.563]         {
[11:01:28.563]             ...future.startTime <- base::Sys.time()
[11:01:28.563]             {
[11:01:28.563]                 {
[11:01:28.563]                   {
[11:01:28.563]                     base::local({
[11:01:28.563]                       has_future <- base::requireNamespace("future", 
[11:01:28.563]                         quietly = TRUE)
[11:01:28.563]                       if (has_future) {
[11:01:28.563]                         ns <- base::getNamespace("future")
[11:01:28.563]                         version <- ns[[".package"]][["version"]]
[11:01:28.563]                         if (is.null(version)) 
[11:01:28.563]                           version <- utils::packageVersion("future")
[11:01:28.563]                       }
[11:01:28.563]                       else {
[11:01:28.563]                         version <- NULL
[11:01:28.563]                       }
[11:01:28.563]                       if (!has_future || version < "1.8.0") {
[11:01:28.563]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.563]                           "", base::R.version$version.string), 
[11:01:28.563]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.563]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.563]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.563]                             "release", "version")], collapse = " "), 
[11:01:28.563]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.563]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.563]                           info)
[11:01:28.563]                         info <- base::paste(info, collapse = "; ")
[11:01:28.563]                         if (!has_future) {
[11:01:28.563]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.563]                             info)
[11:01:28.563]                         }
[11:01:28.563]                         else {
[11:01:28.563]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.563]                             info, version)
[11:01:28.563]                         }
[11:01:28.563]                         base::stop(msg)
[11:01:28.563]                       }
[11:01:28.563]                     })
[11:01:28.563]                   }
[11:01:28.563]                   ...future.strategy.old <- future::plan("list")
[11:01:28.563]                   options(future.plan = NULL)
[11:01:28.563]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.563]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.563]                 }
[11:01:28.563]                 ...future.workdir <- getwd()
[11:01:28.563]             }
[11:01:28.563]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.563]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.563]         }
[11:01:28.563]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.563]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.563]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.563]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.563]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.563]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.563]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.563]             base::names(...future.oldOptions))
[11:01:28.563]     }
[11:01:28.563]     if (FALSE) {
[11:01:28.563]     }
[11:01:28.563]     else {
[11:01:28.563]         if (TRUE) {
[11:01:28.563]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.563]                 open = "w")
[11:01:28.563]         }
[11:01:28.563]         else {
[11:01:28.563]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.563]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.563]         }
[11:01:28.563]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.563]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.563]             base::sink(type = "output", split = FALSE)
[11:01:28.563]             base::close(...future.stdout)
[11:01:28.563]         }, add = TRUE)
[11:01:28.563]     }
[11:01:28.563]     ...future.frame <- base::sys.nframe()
[11:01:28.563]     ...future.conditions <- base::list()
[11:01:28.563]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.563]     if (FALSE) {
[11:01:28.563]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.563]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.563]     }
[11:01:28.563]     ...future.result <- base::tryCatch({
[11:01:28.563]         base::withCallingHandlers({
[11:01:28.563]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.563]             future::FutureResult(value = ...future.value$value, 
[11:01:28.563]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.563]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.563]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.563]                     ...future.globalenv.names))
[11:01:28.563]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.563]         }, condition = base::local({
[11:01:28.563]             c <- base::c
[11:01:28.563]             inherits <- base::inherits
[11:01:28.563]             invokeRestart <- base::invokeRestart
[11:01:28.563]             length <- base::length
[11:01:28.563]             list <- base::list
[11:01:28.563]             seq.int <- base::seq.int
[11:01:28.563]             signalCondition <- base::signalCondition
[11:01:28.563]             sys.calls <- base::sys.calls
[11:01:28.563]             `[[` <- base::`[[`
[11:01:28.563]             `+` <- base::`+`
[11:01:28.563]             `<<-` <- base::`<<-`
[11:01:28.563]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.563]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.563]                   3L)]
[11:01:28.563]             }
[11:01:28.563]             function(cond) {
[11:01:28.563]                 is_error <- inherits(cond, "error")
[11:01:28.563]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.563]                   NULL)
[11:01:28.563]                 if (is_error) {
[11:01:28.563]                   sessionInformation <- function() {
[11:01:28.563]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.563]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.563]                       search = base::search(), system = base::Sys.info())
[11:01:28.563]                   }
[11:01:28.563]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.563]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.563]                     cond$call), session = sessionInformation(), 
[11:01:28.563]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.563]                   signalCondition(cond)
[11:01:28.563]                 }
[11:01:28.563]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.563]                 "immediateCondition"))) {
[11:01:28.563]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.563]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.563]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.563]                   if (TRUE && !signal) {
[11:01:28.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.563]                     {
[11:01:28.563]                       inherits <- base::inherits
[11:01:28.563]                       invokeRestart <- base::invokeRestart
[11:01:28.563]                       is.null <- base::is.null
[11:01:28.563]                       muffled <- FALSE
[11:01:28.563]                       if (inherits(cond, "message")) {
[11:01:28.563]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.563]                         if (muffled) 
[11:01:28.563]                           invokeRestart("muffleMessage")
[11:01:28.563]                       }
[11:01:28.563]                       else if (inherits(cond, "warning")) {
[11:01:28.563]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.563]                         if (muffled) 
[11:01:28.563]                           invokeRestart("muffleWarning")
[11:01:28.563]                       }
[11:01:28.563]                       else if (inherits(cond, "condition")) {
[11:01:28.563]                         if (!is.null(pattern)) {
[11:01:28.563]                           computeRestarts <- base::computeRestarts
[11:01:28.563]                           grepl <- base::grepl
[11:01:28.563]                           restarts <- computeRestarts(cond)
[11:01:28.563]                           for (restart in restarts) {
[11:01:28.563]                             name <- restart$name
[11:01:28.563]                             if (is.null(name)) 
[11:01:28.563]                               next
[11:01:28.563]                             if (!grepl(pattern, name)) 
[11:01:28.563]                               next
[11:01:28.563]                             invokeRestart(restart)
[11:01:28.563]                             muffled <- TRUE
[11:01:28.563]                             break
[11:01:28.563]                           }
[11:01:28.563]                         }
[11:01:28.563]                       }
[11:01:28.563]                       invisible(muffled)
[11:01:28.563]                     }
[11:01:28.563]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.563]                   }
[11:01:28.563]                 }
[11:01:28.563]                 else {
[11:01:28.563]                   if (TRUE) {
[11:01:28.563]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.563]                     {
[11:01:28.563]                       inherits <- base::inherits
[11:01:28.563]                       invokeRestart <- base::invokeRestart
[11:01:28.563]                       is.null <- base::is.null
[11:01:28.563]                       muffled <- FALSE
[11:01:28.563]                       if (inherits(cond, "message")) {
[11:01:28.563]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.563]                         if (muffled) 
[11:01:28.563]                           invokeRestart("muffleMessage")
[11:01:28.563]                       }
[11:01:28.563]                       else if (inherits(cond, "warning")) {
[11:01:28.563]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.563]                         if (muffled) 
[11:01:28.563]                           invokeRestart("muffleWarning")
[11:01:28.563]                       }
[11:01:28.563]                       else if (inherits(cond, "condition")) {
[11:01:28.563]                         if (!is.null(pattern)) {
[11:01:28.563]                           computeRestarts <- base::computeRestarts
[11:01:28.563]                           grepl <- base::grepl
[11:01:28.563]                           restarts <- computeRestarts(cond)
[11:01:28.563]                           for (restart in restarts) {
[11:01:28.563]                             name <- restart$name
[11:01:28.563]                             if (is.null(name)) 
[11:01:28.563]                               next
[11:01:28.563]                             if (!grepl(pattern, name)) 
[11:01:28.563]                               next
[11:01:28.563]                             invokeRestart(restart)
[11:01:28.563]                             muffled <- TRUE
[11:01:28.563]                             break
[11:01:28.563]                           }
[11:01:28.563]                         }
[11:01:28.563]                       }
[11:01:28.563]                       invisible(muffled)
[11:01:28.563]                     }
[11:01:28.563]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.563]                   }
[11:01:28.563]                 }
[11:01:28.563]             }
[11:01:28.563]         }))
[11:01:28.563]     }, error = function(ex) {
[11:01:28.563]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.563]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.563]                 ...future.rng), started = ...future.startTime, 
[11:01:28.563]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.563]             version = "1.8"), class = "FutureResult")
[11:01:28.563]     }, finally = {
[11:01:28.563]         if (!identical(...future.workdir, getwd())) 
[11:01:28.563]             setwd(...future.workdir)
[11:01:28.563]         {
[11:01:28.563]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.563]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.563]             }
[11:01:28.563]             base::options(...future.oldOptions)
[11:01:28.563]             if (.Platform$OS.type == "windows") {
[11:01:28.563]                 old_names <- names(...future.oldEnvVars)
[11:01:28.563]                 envs <- base::Sys.getenv()
[11:01:28.563]                 names <- names(envs)
[11:01:28.563]                 common <- intersect(names, old_names)
[11:01:28.563]                 added <- setdiff(names, old_names)
[11:01:28.563]                 removed <- setdiff(old_names, names)
[11:01:28.563]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.563]                   envs[common]]
[11:01:28.563]                 NAMES <- toupper(changed)
[11:01:28.563]                 args <- list()
[11:01:28.563]                 for (kk in seq_along(NAMES)) {
[11:01:28.563]                   name <- changed[[kk]]
[11:01:28.563]                   NAME <- NAMES[[kk]]
[11:01:28.563]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.563]                     next
[11:01:28.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.563]                 }
[11:01:28.563]                 NAMES <- toupper(added)
[11:01:28.563]                 for (kk in seq_along(NAMES)) {
[11:01:28.563]                   name <- added[[kk]]
[11:01:28.563]                   NAME <- NAMES[[kk]]
[11:01:28.563]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.563]                     next
[11:01:28.563]                   args[[name]] <- ""
[11:01:28.563]                 }
[11:01:28.563]                 NAMES <- toupper(removed)
[11:01:28.563]                 for (kk in seq_along(NAMES)) {
[11:01:28.563]                   name <- removed[[kk]]
[11:01:28.563]                   NAME <- NAMES[[kk]]
[11:01:28.563]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.563]                     next
[11:01:28.563]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.563]                 }
[11:01:28.563]                 if (length(args) > 0) 
[11:01:28.563]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.563]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.563]             }
[11:01:28.563]             else {
[11:01:28.563]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.563]             }
[11:01:28.563]             {
[11:01:28.563]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.563]                   0L) {
[11:01:28.563]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.563]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.563]                   base::options(opts)
[11:01:28.563]                 }
[11:01:28.563]                 {
[11:01:28.563]                   {
[11:01:28.563]                     NULL
[11:01:28.563]                     RNGkind("Mersenne-Twister")
[11:01:28.563]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.563]                       inherits = FALSE)
[11:01:28.563]                   }
[11:01:28.563]                   options(future.plan = NULL)
[11:01:28.563]                   if (is.na(NA_character_)) 
[11:01:28.563]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.563]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.563]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.563]                     .init = FALSE)
[11:01:28.563]                 }
[11:01:28.563]             }
[11:01:28.563]         }
[11:01:28.563]     })
[11:01:28.563]     if (TRUE) {
[11:01:28.563]         base::sink(type = "output", split = FALSE)
[11:01:28.563]         if (TRUE) {
[11:01:28.563]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.563]         }
[11:01:28.563]         else {
[11:01:28.563]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.563]         }
[11:01:28.563]         base::close(...future.stdout)
[11:01:28.563]         ...future.stdout <- NULL
[11:01:28.563]     }
[11:01:28.563]     ...future.result$conditions <- ...future.conditions
[11:01:28.563]     ...future.result$finished <- base::Sys.time()
[11:01:28.563]     ...future.result
[11:01:28.563] }
[11:01:28.565] plan(): Setting new future strategy stack:
[11:01:28.565] List of future strategies:
[11:01:28.565] 1. sequential:
[11:01:28.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.565]    - tweaked: FALSE
[11:01:28.565]    - call: NULL
[11:01:28.566] plan(): nbrOfWorkers() = 1
[11:01:28.566] plan(): Setting new future strategy stack:
[11:01:28.566] List of future strategies:
[11:01:28.566] 1. sequential:
[11:01:28.566]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.566]    - tweaked: FALSE
[11:01:28.566]    - call: plan(strategy)
[11:01:28.567] plan(): nbrOfWorkers() = 1
[11:01:28.567] SequentialFuture started (and completed)
[11:01:28.567] - Launch lazy future ... done
[11:01:28.567] run() for ‘SequentialFuture’ ... done
[11:01:28.567] getGlobalsAndPackages() ...
[11:01:28.567] Searching for globals...
[11:01:28.568] 
[11:01:28.568] Searching for globals ... DONE
[11:01:28.568] - globals: [0] <none>
[11:01:28.568] getGlobalsAndPackages() ... DONE
[11:01:28.568] run() for ‘Future’ ...
[11:01:28.568] - state: ‘created’
[11:01:28.568] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.569] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.569] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.569]   - Field: ‘label’
[11:01:28.569]   - Field: ‘local’
[11:01:28.569]   - Field: ‘owner’
[11:01:28.569]   - Field: ‘envir’
[11:01:28.569]   - Field: ‘packages’
[11:01:28.569]   - Field: ‘gc’
[11:01:28.569]   - Field: ‘conditions’
[11:01:28.569]   - Field: ‘expr’
[11:01:28.569]   - Field: ‘uuid’
[11:01:28.570]   - Field: ‘seed’
[11:01:28.570]   - Field: ‘version’
[11:01:28.570]   - Field: ‘result’
[11:01:28.570]   - Field: ‘asynchronous’
[11:01:28.570]   - Field: ‘calls’
[11:01:28.570]   - Field: ‘globals’
[11:01:28.570]   - Field: ‘stdout’
[11:01:28.570]   - Field: ‘earlySignal’
[11:01:28.570]   - Field: ‘lazy’
[11:01:28.570]   - Field: ‘state’
[11:01:28.570] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.570] - Launch lazy future ...
[11:01:28.571] Packages needed by the future expression (n = 0): <none>
[11:01:28.571] Packages needed by future strategies (n = 0): <none>
[11:01:28.571] {
[11:01:28.571]     {
[11:01:28.571]         {
[11:01:28.571]             ...future.startTime <- base::Sys.time()
[11:01:28.571]             {
[11:01:28.571]                 {
[11:01:28.571]                   {
[11:01:28.571]                     base::local({
[11:01:28.571]                       has_future <- base::requireNamespace("future", 
[11:01:28.571]                         quietly = TRUE)
[11:01:28.571]                       if (has_future) {
[11:01:28.571]                         ns <- base::getNamespace("future")
[11:01:28.571]                         version <- ns[[".package"]][["version"]]
[11:01:28.571]                         if (is.null(version)) 
[11:01:28.571]                           version <- utils::packageVersion("future")
[11:01:28.571]                       }
[11:01:28.571]                       else {
[11:01:28.571]                         version <- NULL
[11:01:28.571]                       }
[11:01:28.571]                       if (!has_future || version < "1.8.0") {
[11:01:28.571]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.571]                           "", base::R.version$version.string), 
[11:01:28.571]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.571]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.571]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.571]                             "release", "version")], collapse = " "), 
[11:01:28.571]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.571]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.571]                           info)
[11:01:28.571]                         info <- base::paste(info, collapse = "; ")
[11:01:28.571]                         if (!has_future) {
[11:01:28.571]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.571]                             info)
[11:01:28.571]                         }
[11:01:28.571]                         else {
[11:01:28.571]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.571]                             info, version)
[11:01:28.571]                         }
[11:01:28.571]                         base::stop(msg)
[11:01:28.571]                       }
[11:01:28.571]                     })
[11:01:28.571]                   }
[11:01:28.571]                   ...future.strategy.old <- future::plan("list")
[11:01:28.571]                   options(future.plan = NULL)
[11:01:28.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.571]                 }
[11:01:28.571]                 ...future.workdir <- getwd()
[11:01:28.571]             }
[11:01:28.571]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.571]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.571]         }
[11:01:28.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.571]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.571]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.571]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.571]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.571]             base::names(...future.oldOptions))
[11:01:28.571]     }
[11:01:28.571]     if (FALSE) {
[11:01:28.571]     }
[11:01:28.571]     else {
[11:01:28.571]         if (TRUE) {
[11:01:28.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.571]                 open = "w")
[11:01:28.571]         }
[11:01:28.571]         else {
[11:01:28.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.571]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.571]         }
[11:01:28.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.571]             base::sink(type = "output", split = FALSE)
[11:01:28.571]             base::close(...future.stdout)
[11:01:28.571]         }, add = TRUE)
[11:01:28.571]     }
[11:01:28.571]     ...future.frame <- base::sys.nframe()
[11:01:28.571]     ...future.conditions <- base::list()
[11:01:28.571]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.571]     if (FALSE) {
[11:01:28.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.571]     }
[11:01:28.571]     ...future.result <- base::tryCatch({
[11:01:28.571]         base::withCallingHandlers({
[11:01:28.571]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.571]             future::FutureResult(value = ...future.value$value, 
[11:01:28.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.571]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.571]                     ...future.globalenv.names))
[11:01:28.571]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.571]         }, condition = base::local({
[11:01:28.571]             c <- base::c
[11:01:28.571]             inherits <- base::inherits
[11:01:28.571]             invokeRestart <- base::invokeRestart
[11:01:28.571]             length <- base::length
[11:01:28.571]             list <- base::list
[11:01:28.571]             seq.int <- base::seq.int
[11:01:28.571]             signalCondition <- base::signalCondition
[11:01:28.571]             sys.calls <- base::sys.calls
[11:01:28.571]             `[[` <- base::`[[`
[11:01:28.571]             `+` <- base::`+`
[11:01:28.571]             `<<-` <- base::`<<-`
[11:01:28.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.571]                   3L)]
[11:01:28.571]             }
[11:01:28.571]             function(cond) {
[11:01:28.571]                 is_error <- inherits(cond, "error")
[11:01:28.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.571]                   NULL)
[11:01:28.571]                 if (is_error) {
[11:01:28.571]                   sessionInformation <- function() {
[11:01:28.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.571]                       search = base::search(), system = base::Sys.info())
[11:01:28.571]                   }
[11:01:28.571]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.571]                     cond$call), session = sessionInformation(), 
[11:01:28.571]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.571]                   signalCondition(cond)
[11:01:28.571]                 }
[11:01:28.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.571]                 "immediateCondition"))) {
[11:01:28.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.571]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.571]                   if (TRUE && !signal) {
[11:01:28.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.571]                     {
[11:01:28.571]                       inherits <- base::inherits
[11:01:28.571]                       invokeRestart <- base::invokeRestart
[11:01:28.571]                       is.null <- base::is.null
[11:01:28.571]                       muffled <- FALSE
[11:01:28.571]                       if (inherits(cond, "message")) {
[11:01:28.571]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.571]                         if (muffled) 
[11:01:28.571]                           invokeRestart("muffleMessage")
[11:01:28.571]                       }
[11:01:28.571]                       else if (inherits(cond, "warning")) {
[11:01:28.571]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.571]                         if (muffled) 
[11:01:28.571]                           invokeRestart("muffleWarning")
[11:01:28.571]                       }
[11:01:28.571]                       else if (inherits(cond, "condition")) {
[11:01:28.571]                         if (!is.null(pattern)) {
[11:01:28.571]                           computeRestarts <- base::computeRestarts
[11:01:28.571]                           grepl <- base::grepl
[11:01:28.571]                           restarts <- computeRestarts(cond)
[11:01:28.571]                           for (restart in restarts) {
[11:01:28.571]                             name <- restart$name
[11:01:28.571]                             if (is.null(name)) 
[11:01:28.571]                               next
[11:01:28.571]                             if (!grepl(pattern, name)) 
[11:01:28.571]                               next
[11:01:28.571]                             invokeRestart(restart)
[11:01:28.571]                             muffled <- TRUE
[11:01:28.571]                             break
[11:01:28.571]                           }
[11:01:28.571]                         }
[11:01:28.571]                       }
[11:01:28.571]                       invisible(muffled)
[11:01:28.571]                     }
[11:01:28.571]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.571]                   }
[11:01:28.571]                 }
[11:01:28.571]                 else {
[11:01:28.571]                   if (TRUE) {
[11:01:28.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.571]                     {
[11:01:28.571]                       inherits <- base::inherits
[11:01:28.571]                       invokeRestart <- base::invokeRestart
[11:01:28.571]                       is.null <- base::is.null
[11:01:28.571]                       muffled <- FALSE
[11:01:28.571]                       if (inherits(cond, "message")) {
[11:01:28.571]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.571]                         if (muffled) 
[11:01:28.571]                           invokeRestart("muffleMessage")
[11:01:28.571]                       }
[11:01:28.571]                       else if (inherits(cond, "warning")) {
[11:01:28.571]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.571]                         if (muffled) 
[11:01:28.571]                           invokeRestart("muffleWarning")
[11:01:28.571]                       }
[11:01:28.571]                       else if (inherits(cond, "condition")) {
[11:01:28.571]                         if (!is.null(pattern)) {
[11:01:28.571]                           computeRestarts <- base::computeRestarts
[11:01:28.571]                           grepl <- base::grepl
[11:01:28.571]                           restarts <- computeRestarts(cond)
[11:01:28.571]                           for (restart in restarts) {
[11:01:28.571]                             name <- restart$name
[11:01:28.571]                             if (is.null(name)) 
[11:01:28.571]                               next
[11:01:28.571]                             if (!grepl(pattern, name)) 
[11:01:28.571]                               next
[11:01:28.571]                             invokeRestart(restart)
[11:01:28.571]                             muffled <- TRUE
[11:01:28.571]                             break
[11:01:28.571]                           }
[11:01:28.571]                         }
[11:01:28.571]                       }
[11:01:28.571]                       invisible(muffled)
[11:01:28.571]                     }
[11:01:28.571]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.571]                   }
[11:01:28.571]                 }
[11:01:28.571]             }
[11:01:28.571]         }))
[11:01:28.571]     }, error = function(ex) {
[11:01:28.571]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.571]                 ...future.rng), started = ...future.startTime, 
[11:01:28.571]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.571]             version = "1.8"), class = "FutureResult")
[11:01:28.571]     }, finally = {
[11:01:28.571]         if (!identical(...future.workdir, getwd())) 
[11:01:28.571]             setwd(...future.workdir)
[11:01:28.571]         {
[11:01:28.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.571]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.571]             }
[11:01:28.571]             base::options(...future.oldOptions)
[11:01:28.571]             if (.Platform$OS.type == "windows") {
[11:01:28.571]                 old_names <- names(...future.oldEnvVars)
[11:01:28.571]                 envs <- base::Sys.getenv()
[11:01:28.571]                 names <- names(envs)
[11:01:28.571]                 common <- intersect(names, old_names)
[11:01:28.571]                 added <- setdiff(names, old_names)
[11:01:28.571]                 removed <- setdiff(old_names, names)
[11:01:28.571]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.571]                   envs[common]]
[11:01:28.571]                 NAMES <- toupper(changed)
[11:01:28.571]                 args <- list()
[11:01:28.571]                 for (kk in seq_along(NAMES)) {
[11:01:28.571]                   name <- changed[[kk]]
[11:01:28.571]                   NAME <- NAMES[[kk]]
[11:01:28.571]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.571]                     next
[11:01:28.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.571]                 }
[11:01:28.571]                 NAMES <- toupper(added)
[11:01:28.571]                 for (kk in seq_along(NAMES)) {
[11:01:28.571]                   name <- added[[kk]]
[11:01:28.571]                   NAME <- NAMES[[kk]]
[11:01:28.571]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.571]                     next
[11:01:28.571]                   args[[name]] <- ""
[11:01:28.571]                 }
[11:01:28.571]                 NAMES <- toupper(removed)
[11:01:28.571]                 for (kk in seq_along(NAMES)) {
[11:01:28.571]                   name <- removed[[kk]]
[11:01:28.571]                   NAME <- NAMES[[kk]]
[11:01:28.571]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.571]                     next
[11:01:28.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.571]                 }
[11:01:28.571]                 if (length(args) > 0) 
[11:01:28.571]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.571]             }
[11:01:28.571]             else {
[11:01:28.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.571]             }
[11:01:28.571]             {
[11:01:28.571]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.571]                   0L) {
[11:01:28.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.571]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.571]                   base::options(opts)
[11:01:28.571]                 }
[11:01:28.571]                 {
[11:01:28.571]                   {
[11:01:28.571]                     NULL
[11:01:28.571]                     RNGkind("Mersenne-Twister")
[11:01:28.571]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.571]                       inherits = FALSE)
[11:01:28.571]                   }
[11:01:28.571]                   options(future.plan = NULL)
[11:01:28.571]                   if (is.na(NA_character_)) 
[11:01:28.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.571]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.571]                     .init = FALSE)
[11:01:28.571]                 }
[11:01:28.571]             }
[11:01:28.571]         }
[11:01:28.571]     })
[11:01:28.571]     if (TRUE) {
[11:01:28.571]         base::sink(type = "output", split = FALSE)
[11:01:28.571]         if (TRUE) {
[11:01:28.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.571]         }
[11:01:28.571]         else {
[11:01:28.571]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.571]         }
[11:01:28.571]         base::close(...future.stdout)
[11:01:28.571]         ...future.stdout <- NULL
[11:01:28.571]     }
[11:01:28.571]     ...future.result$conditions <- ...future.conditions
[11:01:28.571]     ...future.result$finished <- base::Sys.time()
[11:01:28.571]     ...future.result
[11:01:28.571] }
[11:01:28.573] plan(): Setting new future strategy stack:
[11:01:28.573] List of future strategies:
[11:01:28.573] 1. sequential:
[11:01:28.573]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.573]    - tweaked: FALSE
[11:01:28.573]    - call: NULL
[11:01:28.573] plan(): nbrOfWorkers() = 1
[11:01:28.574] plan(): Setting new future strategy stack:
[11:01:28.574] List of future strategies:
[11:01:28.574] 1. sequential:
[11:01:28.574]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.574]    - tweaked: FALSE
[11:01:28.574]    - call: plan(strategy)
[11:01:28.574] plan(): nbrOfWorkers() = 1
[11:01:28.575] SequentialFuture started (and completed)
[11:01:28.575] - Launch lazy future ... done
[11:01:28.575] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c646ea88> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c686e748> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c646ea88> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c686e748> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[11:01:28.580] resolved() for ‘SequentialFuture’ ...
[11:01:28.580] - state: ‘finished’
[11:01:28.580] - run: TRUE
[11:01:28.580] - result: ‘FutureResult’
[11:01:28.580] resolved() for ‘SequentialFuture’ ... done
[11:01:28.581] resolved() for ‘SequentialFuture’ ...
[11:01:28.581] - state: ‘finished’
[11:01:28.581] - run: TRUE
[11:01:28.581] - result: ‘FutureResult’
[11:01:28.581] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:28.583] resolve() on list ...
[11:01:28.583]  recursive: 0
[11:01:28.583]  length: 6
[11:01:28.583]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:28.583] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.583] - nx: 6
[11:01:28.583] - relay: TRUE
[11:01:28.583] - stdout: TRUE
[11:01:28.583] - signal: TRUE
[11:01:28.583] - resignal: FALSE
[11:01:28.583] - force: TRUE
[11:01:28.584] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.584] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.584]  - until=2
[11:01:28.584]  - relaying element #2
[11:01:28.584] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.584] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.584] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.584]  length: 5 (resolved future 1)
[11:01:28.584] resolved() for ‘SequentialFuture’ ...
[11:01:28.584] - state: ‘finished’
[11:01:28.584] - run: TRUE
[11:01:28.584] - result: ‘FutureResult’
[11:01:28.585] resolved() for ‘SequentialFuture’ ... done
[11:01:28.585] Future #2
[11:01:28.585] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.585] - nx: 6
[11:01:28.585] - relay: TRUE
[11:01:28.585] - stdout: TRUE
[11:01:28.585] - signal: TRUE
[11:01:28.585] - resignal: FALSE
[11:01:28.585] - force: TRUE
[11:01:28.585] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.585] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.585]  - until=2
[11:01:28.586]  - relaying element #2
[11:01:28.586] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.586] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.586] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.586]  length: 4 (resolved future 2)
[11:01:28.586] resolved() for ‘SequentialFuture’ ...
[11:01:28.586] - state: ‘finished’
[11:01:28.586] - run: TRUE
[11:01:28.586] - result: ‘FutureResult’
[11:01:28.586] resolved() for ‘SequentialFuture’ ... done
[11:01:28.586] Future #3
[11:01:28.587] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.587] - nx: 6
[11:01:28.587] - relay: TRUE
[11:01:28.587] - stdout: TRUE
[11:01:28.587] - signal: TRUE
[11:01:28.587] - resignal: FALSE
[11:01:28.587] - force: TRUE
[11:01:28.587] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.587] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.587]  - until=3
[11:01:28.587]  - relaying element #3
[11:01:28.587] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.588] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.588] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.588]  length: 3 (resolved future 3)
[11:01:28.588] signalConditionsASAP(NULL, pos=4) ...
[11:01:28.588] - nx: 6
[11:01:28.588] - relay: TRUE
[11:01:28.588] - stdout: TRUE
[11:01:28.588] - signal: TRUE
[11:01:28.588] - resignal: FALSE
[11:01:28.588] - force: TRUE
[11:01:28.588] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.588] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.589]  - until=5
[11:01:28.589]  - relaying element #5
[11:01:28.589] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.589] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.589] signalConditionsASAP(NULL, pos=4) ... done
[11:01:28.589]  length: 2 (resolved future 4)
[11:01:28.589] signalConditionsASAP(NULL, pos=5) ...
[11:01:28.589] - nx: 6
[11:01:28.589] - relay: TRUE
[11:01:28.589] - stdout: TRUE
[11:01:28.589] - signal: TRUE
[11:01:28.589] - resignal: FALSE
[11:01:28.589] - force: TRUE
[11:01:28.589] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.590] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.590]  - until=6
[11:01:28.590]  - relaying element #6
[11:01:28.590] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.590] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.590] signalConditionsASAP(NULL, pos=5) ... done
[11:01:28.590]  length: 1 (resolved future 5)
[11:01:28.590] signalConditionsASAP(numeric, pos=6) ...
[11:01:28.590] - nx: 6
[11:01:28.590] - relay: TRUE
[11:01:28.590] - stdout: TRUE
[11:01:28.590] - signal: TRUE
[11:01:28.590] - resignal: FALSE
[11:01:28.591] - force: TRUE
[11:01:28.591] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.591] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.591]  - until=6
[11:01:28.591] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.591] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.591] signalConditionsASAP(numeric, pos=6) ... done
[11:01:28.591]  length: 0 (resolved future 6)
[11:01:28.591] Relaying remaining futures
[11:01:28.591] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.591] - nx: 6
[11:01:28.591] - relay: TRUE
[11:01:28.591] - stdout: TRUE
[11:01:28.591] - signal: TRUE
[11:01:28.592] - resignal: FALSE
[11:01:28.592] - force: TRUE
[11:01:28.592] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.592] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:28.592] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.592] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.592] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.592] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[11:01:28.595] getGlobalsAndPackages() ...
[11:01:28.595] Searching for globals...
[11:01:28.595] 
[11:01:28.595] Searching for globals ... DONE
[11:01:28.596] - globals: [0] <none>
[11:01:28.596] getGlobalsAndPackages() ... DONE
[11:01:28.596] run() for ‘Future’ ...
[11:01:28.596] - state: ‘created’
[11:01:28.596] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.596] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.596] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.596]   - Field: ‘label’
[11:01:28.597]   - Field: ‘local’
[11:01:28.597]   - Field: ‘owner’
[11:01:28.597]   - Field: ‘envir’
[11:01:28.597]   - Field: ‘packages’
[11:01:28.597]   - Field: ‘gc’
[11:01:28.597]   - Field: ‘conditions’
[11:01:28.597]   - Field: ‘expr’
[11:01:28.597]   - Field: ‘uuid’
[11:01:28.597]   - Field: ‘seed’
[11:01:28.597]   - Field: ‘version’
[11:01:28.597]   - Field: ‘result’
[11:01:28.597]   - Field: ‘asynchronous’
[11:01:28.597]   - Field: ‘calls’
[11:01:28.598]   - Field: ‘globals’
[11:01:28.598]   - Field: ‘stdout’
[11:01:28.598]   - Field: ‘earlySignal’
[11:01:28.598]   - Field: ‘lazy’
[11:01:28.598]   - Field: ‘state’
[11:01:28.598] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.598] - Launch lazy future ...
[11:01:28.598] Packages needed by the future expression (n = 0): <none>
[11:01:28.598] Packages needed by future strategies (n = 0): <none>
[11:01:28.599] {
[11:01:28.599]     {
[11:01:28.599]         {
[11:01:28.599]             ...future.startTime <- base::Sys.time()
[11:01:28.599]             {
[11:01:28.599]                 {
[11:01:28.599]                   {
[11:01:28.599]                     base::local({
[11:01:28.599]                       has_future <- base::requireNamespace("future", 
[11:01:28.599]                         quietly = TRUE)
[11:01:28.599]                       if (has_future) {
[11:01:28.599]                         ns <- base::getNamespace("future")
[11:01:28.599]                         version <- ns[[".package"]][["version"]]
[11:01:28.599]                         if (is.null(version)) 
[11:01:28.599]                           version <- utils::packageVersion("future")
[11:01:28.599]                       }
[11:01:28.599]                       else {
[11:01:28.599]                         version <- NULL
[11:01:28.599]                       }
[11:01:28.599]                       if (!has_future || version < "1.8.0") {
[11:01:28.599]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.599]                           "", base::R.version$version.string), 
[11:01:28.599]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.599]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.599]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.599]                             "release", "version")], collapse = " "), 
[11:01:28.599]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.599]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.599]                           info)
[11:01:28.599]                         info <- base::paste(info, collapse = "; ")
[11:01:28.599]                         if (!has_future) {
[11:01:28.599]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.599]                             info)
[11:01:28.599]                         }
[11:01:28.599]                         else {
[11:01:28.599]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.599]                             info, version)
[11:01:28.599]                         }
[11:01:28.599]                         base::stop(msg)
[11:01:28.599]                       }
[11:01:28.599]                     })
[11:01:28.599]                   }
[11:01:28.599]                   ...future.strategy.old <- future::plan("list")
[11:01:28.599]                   options(future.plan = NULL)
[11:01:28.599]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.599]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.599]                 }
[11:01:28.599]                 ...future.workdir <- getwd()
[11:01:28.599]             }
[11:01:28.599]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.599]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.599]         }
[11:01:28.599]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.599]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.599]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.599]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.599]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.599]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.599]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.599]             base::names(...future.oldOptions))
[11:01:28.599]     }
[11:01:28.599]     if (FALSE) {
[11:01:28.599]     }
[11:01:28.599]     else {
[11:01:28.599]         if (TRUE) {
[11:01:28.599]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.599]                 open = "w")
[11:01:28.599]         }
[11:01:28.599]         else {
[11:01:28.599]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.599]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.599]         }
[11:01:28.599]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.599]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.599]             base::sink(type = "output", split = FALSE)
[11:01:28.599]             base::close(...future.stdout)
[11:01:28.599]         }, add = TRUE)
[11:01:28.599]     }
[11:01:28.599]     ...future.frame <- base::sys.nframe()
[11:01:28.599]     ...future.conditions <- base::list()
[11:01:28.599]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.599]     if (FALSE) {
[11:01:28.599]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.599]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.599]     }
[11:01:28.599]     ...future.result <- base::tryCatch({
[11:01:28.599]         base::withCallingHandlers({
[11:01:28.599]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.599]             future::FutureResult(value = ...future.value$value, 
[11:01:28.599]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.599]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.599]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.599]                     ...future.globalenv.names))
[11:01:28.599]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.599]         }, condition = base::local({
[11:01:28.599]             c <- base::c
[11:01:28.599]             inherits <- base::inherits
[11:01:28.599]             invokeRestart <- base::invokeRestart
[11:01:28.599]             length <- base::length
[11:01:28.599]             list <- base::list
[11:01:28.599]             seq.int <- base::seq.int
[11:01:28.599]             signalCondition <- base::signalCondition
[11:01:28.599]             sys.calls <- base::sys.calls
[11:01:28.599]             `[[` <- base::`[[`
[11:01:28.599]             `+` <- base::`+`
[11:01:28.599]             `<<-` <- base::`<<-`
[11:01:28.599]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.599]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.599]                   3L)]
[11:01:28.599]             }
[11:01:28.599]             function(cond) {
[11:01:28.599]                 is_error <- inherits(cond, "error")
[11:01:28.599]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.599]                   NULL)
[11:01:28.599]                 if (is_error) {
[11:01:28.599]                   sessionInformation <- function() {
[11:01:28.599]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.599]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.599]                       search = base::search(), system = base::Sys.info())
[11:01:28.599]                   }
[11:01:28.599]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.599]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.599]                     cond$call), session = sessionInformation(), 
[11:01:28.599]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.599]                   signalCondition(cond)
[11:01:28.599]                 }
[11:01:28.599]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.599]                 "immediateCondition"))) {
[11:01:28.599]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.599]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.599]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.599]                   if (TRUE && !signal) {
[11:01:28.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.599]                     {
[11:01:28.599]                       inherits <- base::inherits
[11:01:28.599]                       invokeRestart <- base::invokeRestart
[11:01:28.599]                       is.null <- base::is.null
[11:01:28.599]                       muffled <- FALSE
[11:01:28.599]                       if (inherits(cond, "message")) {
[11:01:28.599]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.599]                         if (muffled) 
[11:01:28.599]                           invokeRestart("muffleMessage")
[11:01:28.599]                       }
[11:01:28.599]                       else if (inherits(cond, "warning")) {
[11:01:28.599]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.599]                         if (muffled) 
[11:01:28.599]                           invokeRestart("muffleWarning")
[11:01:28.599]                       }
[11:01:28.599]                       else if (inherits(cond, "condition")) {
[11:01:28.599]                         if (!is.null(pattern)) {
[11:01:28.599]                           computeRestarts <- base::computeRestarts
[11:01:28.599]                           grepl <- base::grepl
[11:01:28.599]                           restarts <- computeRestarts(cond)
[11:01:28.599]                           for (restart in restarts) {
[11:01:28.599]                             name <- restart$name
[11:01:28.599]                             if (is.null(name)) 
[11:01:28.599]                               next
[11:01:28.599]                             if (!grepl(pattern, name)) 
[11:01:28.599]                               next
[11:01:28.599]                             invokeRestart(restart)
[11:01:28.599]                             muffled <- TRUE
[11:01:28.599]                             break
[11:01:28.599]                           }
[11:01:28.599]                         }
[11:01:28.599]                       }
[11:01:28.599]                       invisible(muffled)
[11:01:28.599]                     }
[11:01:28.599]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.599]                   }
[11:01:28.599]                 }
[11:01:28.599]                 else {
[11:01:28.599]                   if (TRUE) {
[11:01:28.599]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.599]                     {
[11:01:28.599]                       inherits <- base::inherits
[11:01:28.599]                       invokeRestart <- base::invokeRestart
[11:01:28.599]                       is.null <- base::is.null
[11:01:28.599]                       muffled <- FALSE
[11:01:28.599]                       if (inherits(cond, "message")) {
[11:01:28.599]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.599]                         if (muffled) 
[11:01:28.599]                           invokeRestart("muffleMessage")
[11:01:28.599]                       }
[11:01:28.599]                       else if (inherits(cond, "warning")) {
[11:01:28.599]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.599]                         if (muffled) 
[11:01:28.599]                           invokeRestart("muffleWarning")
[11:01:28.599]                       }
[11:01:28.599]                       else if (inherits(cond, "condition")) {
[11:01:28.599]                         if (!is.null(pattern)) {
[11:01:28.599]                           computeRestarts <- base::computeRestarts
[11:01:28.599]                           grepl <- base::grepl
[11:01:28.599]                           restarts <- computeRestarts(cond)
[11:01:28.599]                           for (restart in restarts) {
[11:01:28.599]                             name <- restart$name
[11:01:28.599]                             if (is.null(name)) 
[11:01:28.599]                               next
[11:01:28.599]                             if (!grepl(pattern, name)) 
[11:01:28.599]                               next
[11:01:28.599]                             invokeRestart(restart)
[11:01:28.599]                             muffled <- TRUE
[11:01:28.599]                             break
[11:01:28.599]                           }
[11:01:28.599]                         }
[11:01:28.599]                       }
[11:01:28.599]                       invisible(muffled)
[11:01:28.599]                     }
[11:01:28.599]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.599]                   }
[11:01:28.599]                 }
[11:01:28.599]             }
[11:01:28.599]         }))
[11:01:28.599]     }, error = function(ex) {
[11:01:28.599]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.599]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.599]                 ...future.rng), started = ...future.startTime, 
[11:01:28.599]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.599]             version = "1.8"), class = "FutureResult")
[11:01:28.599]     }, finally = {
[11:01:28.599]         if (!identical(...future.workdir, getwd())) 
[11:01:28.599]             setwd(...future.workdir)
[11:01:28.599]         {
[11:01:28.599]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.599]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.599]             }
[11:01:28.599]             base::options(...future.oldOptions)
[11:01:28.599]             if (.Platform$OS.type == "windows") {
[11:01:28.599]                 old_names <- names(...future.oldEnvVars)
[11:01:28.599]                 envs <- base::Sys.getenv()
[11:01:28.599]                 names <- names(envs)
[11:01:28.599]                 common <- intersect(names, old_names)
[11:01:28.599]                 added <- setdiff(names, old_names)
[11:01:28.599]                 removed <- setdiff(old_names, names)
[11:01:28.599]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.599]                   envs[common]]
[11:01:28.599]                 NAMES <- toupper(changed)
[11:01:28.599]                 args <- list()
[11:01:28.599]                 for (kk in seq_along(NAMES)) {
[11:01:28.599]                   name <- changed[[kk]]
[11:01:28.599]                   NAME <- NAMES[[kk]]
[11:01:28.599]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.599]                     next
[11:01:28.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.599]                 }
[11:01:28.599]                 NAMES <- toupper(added)
[11:01:28.599]                 for (kk in seq_along(NAMES)) {
[11:01:28.599]                   name <- added[[kk]]
[11:01:28.599]                   NAME <- NAMES[[kk]]
[11:01:28.599]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.599]                     next
[11:01:28.599]                   args[[name]] <- ""
[11:01:28.599]                 }
[11:01:28.599]                 NAMES <- toupper(removed)
[11:01:28.599]                 for (kk in seq_along(NAMES)) {
[11:01:28.599]                   name <- removed[[kk]]
[11:01:28.599]                   NAME <- NAMES[[kk]]
[11:01:28.599]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.599]                     next
[11:01:28.599]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.599]                 }
[11:01:28.599]                 if (length(args) > 0) 
[11:01:28.599]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.599]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.599]             }
[11:01:28.599]             else {
[11:01:28.599]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.599]             }
[11:01:28.599]             {
[11:01:28.599]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.599]                   0L) {
[11:01:28.599]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.599]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.599]                   base::options(opts)
[11:01:28.599]                 }
[11:01:28.599]                 {
[11:01:28.599]                   {
[11:01:28.599]                     NULL
[11:01:28.599]                     RNGkind("Mersenne-Twister")
[11:01:28.599]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.599]                       inherits = FALSE)
[11:01:28.599]                   }
[11:01:28.599]                   options(future.plan = NULL)
[11:01:28.599]                   if (is.na(NA_character_)) 
[11:01:28.599]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.599]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.599]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.599]                     .init = FALSE)
[11:01:28.599]                 }
[11:01:28.599]             }
[11:01:28.599]         }
[11:01:28.599]     })
[11:01:28.599]     if (TRUE) {
[11:01:28.599]         base::sink(type = "output", split = FALSE)
[11:01:28.599]         if (TRUE) {
[11:01:28.599]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.599]         }
[11:01:28.599]         else {
[11:01:28.599]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.599]         }
[11:01:28.599]         base::close(...future.stdout)
[11:01:28.599]         ...future.stdout <- NULL
[11:01:28.599]     }
[11:01:28.599]     ...future.result$conditions <- ...future.conditions
[11:01:28.599]     ...future.result$finished <- base::Sys.time()
[11:01:28.599]     ...future.result
[11:01:28.599] }
[11:01:28.600] plan(): Setting new future strategy stack:
[11:01:28.600] List of future strategies:
[11:01:28.600] 1. sequential:
[11:01:28.600]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.600]    - tweaked: FALSE
[11:01:28.600]    - call: NULL
[11:01:28.601] plan(): nbrOfWorkers() = 1
[11:01:28.602] plan(): Setting new future strategy stack:
[11:01:28.602] List of future strategies:
[11:01:28.602] 1. sequential:
[11:01:28.602]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.602]    - tweaked: FALSE
[11:01:28.602]    - call: plan(strategy)
[11:01:28.602] plan(): nbrOfWorkers() = 1
[11:01:28.602] SequentialFuture started (and completed)
[11:01:28.602] - Launch lazy future ... done
[11:01:28.602] run() for ‘SequentialFuture’ ... done
[11:01:28.603] getGlobalsAndPackages() ...
[11:01:28.603] Searching for globals...
[11:01:28.604] 
[11:01:28.604] Searching for globals ... DONE
[11:01:28.604] - globals: [0] <none>
[11:01:28.604] getGlobalsAndPackages() ... DONE
[11:01:28.604] run() for ‘Future’ ...
[11:01:28.604] - state: ‘created’
[11:01:28.604] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.605] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.605] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.605]   - Field: ‘label’
[11:01:28.605]   - Field: ‘local’
[11:01:28.605]   - Field: ‘owner’
[11:01:28.605]   - Field: ‘envir’
[11:01:28.605]   - Field: ‘packages’
[11:01:28.605]   - Field: ‘gc’
[11:01:28.605]   - Field: ‘conditions’
[11:01:28.605]   - Field: ‘expr’
[11:01:28.605]   - Field: ‘uuid’
[11:01:28.605]   - Field: ‘seed’
[11:01:28.606]   - Field: ‘version’
[11:01:28.606]   - Field: ‘result’
[11:01:28.606]   - Field: ‘asynchronous’
[11:01:28.606]   - Field: ‘calls’
[11:01:28.606]   - Field: ‘globals’
[11:01:28.606]   - Field: ‘stdout’
[11:01:28.606]   - Field: ‘earlySignal’
[11:01:28.606]   - Field: ‘lazy’
[11:01:28.606]   - Field: ‘state’
[11:01:28.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.606] - Launch lazy future ...
[11:01:28.607] Packages needed by the future expression (n = 0): <none>
[11:01:28.607] Packages needed by future strategies (n = 0): <none>
[11:01:28.607] {
[11:01:28.607]     {
[11:01:28.607]         {
[11:01:28.607]             ...future.startTime <- base::Sys.time()
[11:01:28.607]             {
[11:01:28.607]                 {
[11:01:28.607]                   {
[11:01:28.607]                     base::local({
[11:01:28.607]                       has_future <- base::requireNamespace("future", 
[11:01:28.607]                         quietly = TRUE)
[11:01:28.607]                       if (has_future) {
[11:01:28.607]                         ns <- base::getNamespace("future")
[11:01:28.607]                         version <- ns[[".package"]][["version"]]
[11:01:28.607]                         if (is.null(version)) 
[11:01:28.607]                           version <- utils::packageVersion("future")
[11:01:28.607]                       }
[11:01:28.607]                       else {
[11:01:28.607]                         version <- NULL
[11:01:28.607]                       }
[11:01:28.607]                       if (!has_future || version < "1.8.0") {
[11:01:28.607]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.607]                           "", base::R.version$version.string), 
[11:01:28.607]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.607]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.607]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.607]                             "release", "version")], collapse = " "), 
[11:01:28.607]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.607]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.607]                           info)
[11:01:28.607]                         info <- base::paste(info, collapse = "; ")
[11:01:28.607]                         if (!has_future) {
[11:01:28.607]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.607]                             info)
[11:01:28.607]                         }
[11:01:28.607]                         else {
[11:01:28.607]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.607]                             info, version)
[11:01:28.607]                         }
[11:01:28.607]                         base::stop(msg)
[11:01:28.607]                       }
[11:01:28.607]                     })
[11:01:28.607]                   }
[11:01:28.607]                   ...future.strategy.old <- future::plan("list")
[11:01:28.607]                   options(future.plan = NULL)
[11:01:28.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.607]                 }
[11:01:28.607]                 ...future.workdir <- getwd()
[11:01:28.607]             }
[11:01:28.607]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.607]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.607]         }
[11:01:28.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.607]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.607]             base::names(...future.oldOptions))
[11:01:28.607]     }
[11:01:28.607]     if (FALSE) {
[11:01:28.607]     }
[11:01:28.607]     else {
[11:01:28.607]         if (TRUE) {
[11:01:28.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.607]                 open = "w")
[11:01:28.607]         }
[11:01:28.607]         else {
[11:01:28.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.607]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.607]         }
[11:01:28.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.607]             base::sink(type = "output", split = FALSE)
[11:01:28.607]             base::close(...future.stdout)
[11:01:28.607]         }, add = TRUE)
[11:01:28.607]     }
[11:01:28.607]     ...future.frame <- base::sys.nframe()
[11:01:28.607]     ...future.conditions <- base::list()
[11:01:28.607]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.607]     if (FALSE) {
[11:01:28.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.607]     }
[11:01:28.607]     ...future.result <- base::tryCatch({
[11:01:28.607]         base::withCallingHandlers({
[11:01:28.607]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.607]             future::FutureResult(value = ...future.value$value, 
[11:01:28.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.607]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.607]                     ...future.globalenv.names))
[11:01:28.607]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.607]         }, condition = base::local({
[11:01:28.607]             c <- base::c
[11:01:28.607]             inherits <- base::inherits
[11:01:28.607]             invokeRestart <- base::invokeRestart
[11:01:28.607]             length <- base::length
[11:01:28.607]             list <- base::list
[11:01:28.607]             seq.int <- base::seq.int
[11:01:28.607]             signalCondition <- base::signalCondition
[11:01:28.607]             sys.calls <- base::sys.calls
[11:01:28.607]             `[[` <- base::`[[`
[11:01:28.607]             `+` <- base::`+`
[11:01:28.607]             `<<-` <- base::`<<-`
[11:01:28.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.607]                   3L)]
[11:01:28.607]             }
[11:01:28.607]             function(cond) {
[11:01:28.607]                 is_error <- inherits(cond, "error")
[11:01:28.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.607]                   NULL)
[11:01:28.607]                 if (is_error) {
[11:01:28.607]                   sessionInformation <- function() {
[11:01:28.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.607]                       search = base::search(), system = base::Sys.info())
[11:01:28.607]                   }
[11:01:28.607]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.607]                     cond$call), session = sessionInformation(), 
[11:01:28.607]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.607]                   signalCondition(cond)
[11:01:28.607]                 }
[11:01:28.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.607]                 "immediateCondition"))) {
[11:01:28.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.607]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.607]                   if (TRUE && !signal) {
[11:01:28.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.607]                     {
[11:01:28.607]                       inherits <- base::inherits
[11:01:28.607]                       invokeRestart <- base::invokeRestart
[11:01:28.607]                       is.null <- base::is.null
[11:01:28.607]                       muffled <- FALSE
[11:01:28.607]                       if (inherits(cond, "message")) {
[11:01:28.607]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.607]                         if (muffled) 
[11:01:28.607]                           invokeRestart("muffleMessage")
[11:01:28.607]                       }
[11:01:28.607]                       else if (inherits(cond, "warning")) {
[11:01:28.607]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.607]                         if (muffled) 
[11:01:28.607]                           invokeRestart("muffleWarning")
[11:01:28.607]                       }
[11:01:28.607]                       else if (inherits(cond, "condition")) {
[11:01:28.607]                         if (!is.null(pattern)) {
[11:01:28.607]                           computeRestarts <- base::computeRestarts
[11:01:28.607]                           grepl <- base::grepl
[11:01:28.607]                           restarts <- computeRestarts(cond)
[11:01:28.607]                           for (restart in restarts) {
[11:01:28.607]                             name <- restart$name
[11:01:28.607]                             if (is.null(name)) 
[11:01:28.607]                               next
[11:01:28.607]                             if (!grepl(pattern, name)) 
[11:01:28.607]                               next
[11:01:28.607]                             invokeRestart(restart)
[11:01:28.607]                             muffled <- TRUE
[11:01:28.607]                             break
[11:01:28.607]                           }
[11:01:28.607]                         }
[11:01:28.607]                       }
[11:01:28.607]                       invisible(muffled)
[11:01:28.607]                     }
[11:01:28.607]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.607]                   }
[11:01:28.607]                 }
[11:01:28.607]                 else {
[11:01:28.607]                   if (TRUE) {
[11:01:28.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.607]                     {
[11:01:28.607]                       inherits <- base::inherits
[11:01:28.607]                       invokeRestart <- base::invokeRestart
[11:01:28.607]                       is.null <- base::is.null
[11:01:28.607]                       muffled <- FALSE
[11:01:28.607]                       if (inherits(cond, "message")) {
[11:01:28.607]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.607]                         if (muffled) 
[11:01:28.607]                           invokeRestart("muffleMessage")
[11:01:28.607]                       }
[11:01:28.607]                       else if (inherits(cond, "warning")) {
[11:01:28.607]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.607]                         if (muffled) 
[11:01:28.607]                           invokeRestart("muffleWarning")
[11:01:28.607]                       }
[11:01:28.607]                       else if (inherits(cond, "condition")) {
[11:01:28.607]                         if (!is.null(pattern)) {
[11:01:28.607]                           computeRestarts <- base::computeRestarts
[11:01:28.607]                           grepl <- base::grepl
[11:01:28.607]                           restarts <- computeRestarts(cond)
[11:01:28.607]                           for (restart in restarts) {
[11:01:28.607]                             name <- restart$name
[11:01:28.607]                             if (is.null(name)) 
[11:01:28.607]                               next
[11:01:28.607]                             if (!grepl(pattern, name)) 
[11:01:28.607]                               next
[11:01:28.607]                             invokeRestart(restart)
[11:01:28.607]                             muffled <- TRUE
[11:01:28.607]                             break
[11:01:28.607]                           }
[11:01:28.607]                         }
[11:01:28.607]                       }
[11:01:28.607]                       invisible(muffled)
[11:01:28.607]                     }
[11:01:28.607]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.607]                   }
[11:01:28.607]                 }
[11:01:28.607]             }
[11:01:28.607]         }))
[11:01:28.607]     }, error = function(ex) {
[11:01:28.607]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.607]                 ...future.rng), started = ...future.startTime, 
[11:01:28.607]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.607]             version = "1.8"), class = "FutureResult")
[11:01:28.607]     }, finally = {
[11:01:28.607]         if (!identical(...future.workdir, getwd())) 
[11:01:28.607]             setwd(...future.workdir)
[11:01:28.607]         {
[11:01:28.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.607]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.607]             }
[11:01:28.607]             base::options(...future.oldOptions)
[11:01:28.607]             if (.Platform$OS.type == "windows") {
[11:01:28.607]                 old_names <- names(...future.oldEnvVars)
[11:01:28.607]                 envs <- base::Sys.getenv()
[11:01:28.607]                 names <- names(envs)
[11:01:28.607]                 common <- intersect(names, old_names)
[11:01:28.607]                 added <- setdiff(names, old_names)
[11:01:28.607]                 removed <- setdiff(old_names, names)
[11:01:28.607]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.607]                   envs[common]]
[11:01:28.607]                 NAMES <- toupper(changed)
[11:01:28.607]                 args <- list()
[11:01:28.607]                 for (kk in seq_along(NAMES)) {
[11:01:28.607]                   name <- changed[[kk]]
[11:01:28.607]                   NAME <- NAMES[[kk]]
[11:01:28.607]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.607]                     next
[11:01:28.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.607]                 }
[11:01:28.607]                 NAMES <- toupper(added)
[11:01:28.607]                 for (kk in seq_along(NAMES)) {
[11:01:28.607]                   name <- added[[kk]]
[11:01:28.607]                   NAME <- NAMES[[kk]]
[11:01:28.607]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.607]                     next
[11:01:28.607]                   args[[name]] <- ""
[11:01:28.607]                 }
[11:01:28.607]                 NAMES <- toupper(removed)
[11:01:28.607]                 for (kk in seq_along(NAMES)) {
[11:01:28.607]                   name <- removed[[kk]]
[11:01:28.607]                   NAME <- NAMES[[kk]]
[11:01:28.607]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.607]                     next
[11:01:28.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.607]                 }
[11:01:28.607]                 if (length(args) > 0) 
[11:01:28.607]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.607]             }
[11:01:28.607]             else {
[11:01:28.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.607]             }
[11:01:28.607]             {
[11:01:28.607]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.607]                   0L) {
[11:01:28.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.607]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.607]                   base::options(opts)
[11:01:28.607]                 }
[11:01:28.607]                 {
[11:01:28.607]                   {
[11:01:28.607]                     NULL
[11:01:28.607]                     RNGkind("Mersenne-Twister")
[11:01:28.607]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.607]                       inherits = FALSE)
[11:01:28.607]                   }
[11:01:28.607]                   options(future.plan = NULL)
[11:01:28.607]                   if (is.na(NA_character_)) 
[11:01:28.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.607]                     .init = FALSE)
[11:01:28.607]                 }
[11:01:28.607]             }
[11:01:28.607]         }
[11:01:28.607]     })
[11:01:28.607]     if (TRUE) {
[11:01:28.607]         base::sink(type = "output", split = FALSE)
[11:01:28.607]         if (TRUE) {
[11:01:28.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.607]         }
[11:01:28.607]         else {
[11:01:28.607]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.607]         }
[11:01:28.607]         base::close(...future.stdout)
[11:01:28.607]         ...future.stdout <- NULL
[11:01:28.607]     }
[11:01:28.607]     ...future.result$conditions <- ...future.conditions
[11:01:28.607]     ...future.result$finished <- base::Sys.time()
[11:01:28.607]     ...future.result
[11:01:28.607] }
[11:01:28.609] plan(): Setting new future strategy stack:
[11:01:28.609] List of future strategies:
[11:01:28.609] 1. sequential:
[11:01:28.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.609]    - tweaked: FALSE
[11:01:28.609]    - call: NULL
[11:01:28.609] plan(): nbrOfWorkers() = 1
[11:01:28.610] plan(): Setting new future strategy stack:
[11:01:28.610] List of future strategies:
[11:01:28.610] 1. sequential:
[11:01:28.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.610]    - tweaked: FALSE
[11:01:28.610]    - call: plan(strategy)
[11:01:28.610] plan(): nbrOfWorkers() = 1
[11:01:28.610] SequentialFuture started (and completed)
[11:01:28.611] - Launch lazy future ... done
[11:01:28.611] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c6a324f8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c5c17038> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c6a324f8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c5c17038> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[11:01:28.615] resolved() for ‘SequentialFuture’ ...
[11:01:28.615] - state: ‘finished’
[11:01:28.615] - run: TRUE
[11:01:28.615] - result: ‘FutureResult’
[11:01:28.615] resolved() for ‘SequentialFuture’ ... done
[11:01:28.615] resolved() for ‘SequentialFuture’ ...
[11:01:28.616] - state: ‘finished’
[11:01:28.616] - run: TRUE
[11:01:28.616] - result: ‘FutureResult’
[11:01:28.616] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:28.617] resolve() on list ...
[11:01:28.617]  recursive: 0
[11:01:28.617]  length: 6
[11:01:28.617]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:28.618] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.618] - nx: 6
[11:01:28.618] - relay: TRUE
[11:01:28.618] - stdout: TRUE
[11:01:28.618] - signal: TRUE
[11:01:28.618] - resignal: FALSE
[11:01:28.618] - force: TRUE
[11:01:28.618] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.618] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.618]  - until=2
[11:01:28.618]  - relaying element #2
[11:01:28.618] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.618] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.618] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.619]  length: 5 (resolved future 1)
[11:01:28.619] resolved() for ‘SequentialFuture’ ...
[11:01:28.619] - state: ‘finished’
[11:01:28.619] - run: TRUE
[11:01:28.619] - result: ‘FutureResult’
[11:01:28.619] resolved() for ‘SequentialFuture’ ... done
[11:01:28.619] Future #2
[11:01:28.619] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.619] - nx: 6
[11:01:28.619] - relay: TRUE
[11:01:28.619] - stdout: TRUE
[11:01:28.620] - signal: TRUE
[11:01:28.620] - resignal: FALSE
[11:01:28.620] - force: TRUE
[11:01:28.620] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.620] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.620]  - until=2
[11:01:28.620]  - relaying element #2
[11:01:28.620] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.620] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.620] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.620]  length: 4 (resolved future 2)
[11:01:28.620] resolved() for ‘SequentialFuture’ ...
[11:01:28.621] - state: ‘finished’
[11:01:28.621] - run: TRUE
[11:01:28.621] - result: ‘FutureResult’
[11:01:28.621] resolved() for ‘SequentialFuture’ ... done
[11:01:28.621] Future #3
[11:01:28.621] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.621] - nx: 6
[11:01:28.621] - relay: TRUE
[11:01:28.621] - stdout: TRUE
[11:01:28.621] - signal: TRUE
[11:01:28.621] - resignal: FALSE
[11:01:28.621] - force: TRUE
[11:01:28.621] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.622] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.622]  - until=3
[11:01:28.622]  - relaying element #3
[11:01:28.622] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.622] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.622] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.622]  length: 3 (resolved future 3)
[11:01:28.622] signalConditionsASAP(NULL, pos=4) ...
[11:01:28.622] - nx: 6
[11:01:28.622] - relay: TRUE
[11:01:28.622] - stdout: TRUE
[11:01:28.623] - signal: TRUE
[11:01:28.623] - resignal: FALSE
[11:01:28.623] - force: TRUE
[11:01:28.623] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.623] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.623]  - until=5
[11:01:28.623]  - relaying element #5
[11:01:28.623] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.623] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.623] signalConditionsASAP(NULL, pos=4) ... done
[11:01:28.623]  length: 2 (resolved future 4)
[11:01:28.623] signalConditionsASAP(NULL, pos=5) ...
[11:01:28.623] - nx: 6
[11:01:28.624] - relay: TRUE
[11:01:28.624] - stdout: TRUE
[11:01:28.624] - signal: TRUE
[11:01:28.624] - resignal: FALSE
[11:01:28.624] - force: TRUE
[11:01:28.624] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.624] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.624]  - until=6
[11:01:28.624]  - relaying element #6
[11:01:28.624] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.624] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.624] signalConditionsASAP(NULL, pos=5) ... done
[11:01:28.624]  length: 1 (resolved future 5)
[11:01:28.625] signalConditionsASAP(numeric, pos=6) ...
[11:01:28.625] - nx: 6
[11:01:28.625] - relay: TRUE
[11:01:28.625] - stdout: TRUE
[11:01:28.625] - signal: TRUE
[11:01:28.625] - resignal: FALSE
[11:01:28.625] - force: TRUE
[11:01:28.625] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.625] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.625]  - until=6
[11:01:28.625] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.625] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.625] signalConditionsASAP(numeric, pos=6) ... done
[11:01:28.625]  length: 0 (resolved future 6)
[11:01:28.626] Relaying remaining futures
[11:01:28.626] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.626] - nx: 6
[11:01:28.626] - relay: TRUE
[11:01:28.626] - stdout: TRUE
[11:01:28.626] - signal: TRUE
[11:01:28.626] - resignal: FALSE
[11:01:28.626] - force: TRUE
[11:01:28.626] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.626] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:28.626] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.626] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.626] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.627] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[11:01:28.630] getGlobalsAndPackages() ...
[11:01:28.630] Searching for globals...
[11:01:28.631] 
[11:01:28.631] Searching for globals ... DONE
[11:01:28.631] - globals: [0] <none>
[11:01:28.631] getGlobalsAndPackages() ... DONE
[11:01:28.631] run() for ‘Future’ ...
[11:01:28.631] - state: ‘created’
[11:01:28.631] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.631] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.632] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.632]   - Field: ‘label’
[11:01:28.632]   - Field: ‘local’
[11:01:28.632]   - Field: ‘owner’
[11:01:28.632]   - Field: ‘envir’
[11:01:28.632]   - Field: ‘packages’
[11:01:28.632]   - Field: ‘gc’
[11:01:28.632]   - Field: ‘conditions’
[11:01:28.632]   - Field: ‘expr’
[11:01:28.632]   - Field: ‘uuid’
[11:01:28.632]   - Field: ‘seed’
[11:01:28.632]   - Field: ‘version’
[11:01:28.632]   - Field: ‘result’
[11:01:28.633]   - Field: ‘asynchronous’
[11:01:28.633]   - Field: ‘calls’
[11:01:28.633]   - Field: ‘globals’
[11:01:28.633]   - Field: ‘stdout’
[11:01:28.633]   - Field: ‘earlySignal’
[11:01:28.633]   - Field: ‘lazy’
[11:01:28.633]   - Field: ‘state’
[11:01:28.633] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.633] - Launch lazy future ...
[11:01:28.633] Packages needed by the future expression (n = 0): <none>
[11:01:28.634] Packages needed by future strategies (n = 0): <none>
[11:01:28.634] {
[11:01:28.634]     {
[11:01:28.634]         {
[11:01:28.634]             ...future.startTime <- base::Sys.time()
[11:01:28.634]             {
[11:01:28.634]                 {
[11:01:28.634]                   {
[11:01:28.634]                     base::local({
[11:01:28.634]                       has_future <- base::requireNamespace("future", 
[11:01:28.634]                         quietly = TRUE)
[11:01:28.634]                       if (has_future) {
[11:01:28.634]                         ns <- base::getNamespace("future")
[11:01:28.634]                         version <- ns[[".package"]][["version"]]
[11:01:28.634]                         if (is.null(version)) 
[11:01:28.634]                           version <- utils::packageVersion("future")
[11:01:28.634]                       }
[11:01:28.634]                       else {
[11:01:28.634]                         version <- NULL
[11:01:28.634]                       }
[11:01:28.634]                       if (!has_future || version < "1.8.0") {
[11:01:28.634]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.634]                           "", base::R.version$version.string), 
[11:01:28.634]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.634]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.634]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.634]                             "release", "version")], collapse = " "), 
[11:01:28.634]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.634]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.634]                           info)
[11:01:28.634]                         info <- base::paste(info, collapse = "; ")
[11:01:28.634]                         if (!has_future) {
[11:01:28.634]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.634]                             info)
[11:01:28.634]                         }
[11:01:28.634]                         else {
[11:01:28.634]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.634]                             info, version)
[11:01:28.634]                         }
[11:01:28.634]                         base::stop(msg)
[11:01:28.634]                       }
[11:01:28.634]                     })
[11:01:28.634]                   }
[11:01:28.634]                   ...future.strategy.old <- future::plan("list")
[11:01:28.634]                   options(future.plan = NULL)
[11:01:28.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.634]                 }
[11:01:28.634]                 ...future.workdir <- getwd()
[11:01:28.634]             }
[11:01:28.634]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.634]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.634]         }
[11:01:28.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.634]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.634]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.634]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.634]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.634]             base::names(...future.oldOptions))
[11:01:28.634]     }
[11:01:28.634]     if (FALSE) {
[11:01:28.634]     }
[11:01:28.634]     else {
[11:01:28.634]         if (TRUE) {
[11:01:28.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.634]                 open = "w")
[11:01:28.634]         }
[11:01:28.634]         else {
[11:01:28.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.634]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.634]         }
[11:01:28.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.634]             base::sink(type = "output", split = FALSE)
[11:01:28.634]             base::close(...future.stdout)
[11:01:28.634]         }, add = TRUE)
[11:01:28.634]     }
[11:01:28.634]     ...future.frame <- base::sys.nframe()
[11:01:28.634]     ...future.conditions <- base::list()
[11:01:28.634]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.634]     if (FALSE) {
[11:01:28.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.634]     }
[11:01:28.634]     ...future.result <- base::tryCatch({
[11:01:28.634]         base::withCallingHandlers({
[11:01:28.634]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.634]             future::FutureResult(value = ...future.value$value, 
[11:01:28.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.634]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.634]                     ...future.globalenv.names))
[11:01:28.634]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.634]         }, condition = base::local({
[11:01:28.634]             c <- base::c
[11:01:28.634]             inherits <- base::inherits
[11:01:28.634]             invokeRestart <- base::invokeRestart
[11:01:28.634]             length <- base::length
[11:01:28.634]             list <- base::list
[11:01:28.634]             seq.int <- base::seq.int
[11:01:28.634]             signalCondition <- base::signalCondition
[11:01:28.634]             sys.calls <- base::sys.calls
[11:01:28.634]             `[[` <- base::`[[`
[11:01:28.634]             `+` <- base::`+`
[11:01:28.634]             `<<-` <- base::`<<-`
[11:01:28.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.634]                   3L)]
[11:01:28.634]             }
[11:01:28.634]             function(cond) {
[11:01:28.634]                 is_error <- inherits(cond, "error")
[11:01:28.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.634]                   NULL)
[11:01:28.634]                 if (is_error) {
[11:01:28.634]                   sessionInformation <- function() {
[11:01:28.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.634]                       search = base::search(), system = base::Sys.info())
[11:01:28.634]                   }
[11:01:28.634]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.634]                     cond$call), session = sessionInformation(), 
[11:01:28.634]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.634]                   signalCondition(cond)
[11:01:28.634]                 }
[11:01:28.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.634]                 "immediateCondition"))) {
[11:01:28.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.634]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.634]                   if (TRUE && !signal) {
[11:01:28.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.634]                     {
[11:01:28.634]                       inherits <- base::inherits
[11:01:28.634]                       invokeRestart <- base::invokeRestart
[11:01:28.634]                       is.null <- base::is.null
[11:01:28.634]                       muffled <- FALSE
[11:01:28.634]                       if (inherits(cond, "message")) {
[11:01:28.634]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.634]                         if (muffled) 
[11:01:28.634]                           invokeRestart("muffleMessage")
[11:01:28.634]                       }
[11:01:28.634]                       else if (inherits(cond, "warning")) {
[11:01:28.634]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.634]                         if (muffled) 
[11:01:28.634]                           invokeRestart("muffleWarning")
[11:01:28.634]                       }
[11:01:28.634]                       else if (inherits(cond, "condition")) {
[11:01:28.634]                         if (!is.null(pattern)) {
[11:01:28.634]                           computeRestarts <- base::computeRestarts
[11:01:28.634]                           grepl <- base::grepl
[11:01:28.634]                           restarts <- computeRestarts(cond)
[11:01:28.634]                           for (restart in restarts) {
[11:01:28.634]                             name <- restart$name
[11:01:28.634]                             if (is.null(name)) 
[11:01:28.634]                               next
[11:01:28.634]                             if (!grepl(pattern, name)) 
[11:01:28.634]                               next
[11:01:28.634]                             invokeRestart(restart)
[11:01:28.634]                             muffled <- TRUE
[11:01:28.634]                             break
[11:01:28.634]                           }
[11:01:28.634]                         }
[11:01:28.634]                       }
[11:01:28.634]                       invisible(muffled)
[11:01:28.634]                     }
[11:01:28.634]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.634]                   }
[11:01:28.634]                 }
[11:01:28.634]                 else {
[11:01:28.634]                   if (TRUE) {
[11:01:28.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.634]                     {
[11:01:28.634]                       inherits <- base::inherits
[11:01:28.634]                       invokeRestart <- base::invokeRestart
[11:01:28.634]                       is.null <- base::is.null
[11:01:28.634]                       muffled <- FALSE
[11:01:28.634]                       if (inherits(cond, "message")) {
[11:01:28.634]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.634]                         if (muffled) 
[11:01:28.634]                           invokeRestart("muffleMessage")
[11:01:28.634]                       }
[11:01:28.634]                       else if (inherits(cond, "warning")) {
[11:01:28.634]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.634]                         if (muffled) 
[11:01:28.634]                           invokeRestart("muffleWarning")
[11:01:28.634]                       }
[11:01:28.634]                       else if (inherits(cond, "condition")) {
[11:01:28.634]                         if (!is.null(pattern)) {
[11:01:28.634]                           computeRestarts <- base::computeRestarts
[11:01:28.634]                           grepl <- base::grepl
[11:01:28.634]                           restarts <- computeRestarts(cond)
[11:01:28.634]                           for (restart in restarts) {
[11:01:28.634]                             name <- restart$name
[11:01:28.634]                             if (is.null(name)) 
[11:01:28.634]                               next
[11:01:28.634]                             if (!grepl(pattern, name)) 
[11:01:28.634]                               next
[11:01:28.634]                             invokeRestart(restart)
[11:01:28.634]                             muffled <- TRUE
[11:01:28.634]                             break
[11:01:28.634]                           }
[11:01:28.634]                         }
[11:01:28.634]                       }
[11:01:28.634]                       invisible(muffled)
[11:01:28.634]                     }
[11:01:28.634]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.634]                   }
[11:01:28.634]                 }
[11:01:28.634]             }
[11:01:28.634]         }))
[11:01:28.634]     }, error = function(ex) {
[11:01:28.634]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.634]                 ...future.rng), started = ...future.startTime, 
[11:01:28.634]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.634]             version = "1.8"), class = "FutureResult")
[11:01:28.634]     }, finally = {
[11:01:28.634]         if (!identical(...future.workdir, getwd())) 
[11:01:28.634]             setwd(...future.workdir)
[11:01:28.634]         {
[11:01:28.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.634]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.634]             }
[11:01:28.634]             base::options(...future.oldOptions)
[11:01:28.634]             if (.Platform$OS.type == "windows") {
[11:01:28.634]                 old_names <- names(...future.oldEnvVars)
[11:01:28.634]                 envs <- base::Sys.getenv()
[11:01:28.634]                 names <- names(envs)
[11:01:28.634]                 common <- intersect(names, old_names)
[11:01:28.634]                 added <- setdiff(names, old_names)
[11:01:28.634]                 removed <- setdiff(old_names, names)
[11:01:28.634]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.634]                   envs[common]]
[11:01:28.634]                 NAMES <- toupper(changed)
[11:01:28.634]                 args <- list()
[11:01:28.634]                 for (kk in seq_along(NAMES)) {
[11:01:28.634]                   name <- changed[[kk]]
[11:01:28.634]                   NAME <- NAMES[[kk]]
[11:01:28.634]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.634]                     next
[11:01:28.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.634]                 }
[11:01:28.634]                 NAMES <- toupper(added)
[11:01:28.634]                 for (kk in seq_along(NAMES)) {
[11:01:28.634]                   name <- added[[kk]]
[11:01:28.634]                   NAME <- NAMES[[kk]]
[11:01:28.634]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.634]                     next
[11:01:28.634]                   args[[name]] <- ""
[11:01:28.634]                 }
[11:01:28.634]                 NAMES <- toupper(removed)
[11:01:28.634]                 for (kk in seq_along(NAMES)) {
[11:01:28.634]                   name <- removed[[kk]]
[11:01:28.634]                   NAME <- NAMES[[kk]]
[11:01:28.634]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.634]                     next
[11:01:28.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.634]                 }
[11:01:28.634]                 if (length(args) > 0) 
[11:01:28.634]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.634]             }
[11:01:28.634]             else {
[11:01:28.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.634]             }
[11:01:28.634]             {
[11:01:28.634]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.634]                   0L) {
[11:01:28.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.634]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.634]                   base::options(opts)
[11:01:28.634]                 }
[11:01:28.634]                 {
[11:01:28.634]                   {
[11:01:28.634]                     NULL
[11:01:28.634]                     RNGkind("Mersenne-Twister")
[11:01:28.634]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.634]                       inherits = FALSE)
[11:01:28.634]                   }
[11:01:28.634]                   options(future.plan = NULL)
[11:01:28.634]                   if (is.na(NA_character_)) 
[11:01:28.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.634]                     .init = FALSE)
[11:01:28.634]                 }
[11:01:28.634]             }
[11:01:28.634]         }
[11:01:28.634]     })
[11:01:28.634]     if (TRUE) {
[11:01:28.634]         base::sink(type = "output", split = FALSE)
[11:01:28.634]         if (TRUE) {
[11:01:28.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.634]         }
[11:01:28.634]         else {
[11:01:28.634]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.634]         }
[11:01:28.634]         base::close(...future.stdout)
[11:01:28.634]         ...future.stdout <- NULL
[11:01:28.634]     }
[11:01:28.634]     ...future.result$conditions <- ...future.conditions
[11:01:28.634]     ...future.result$finished <- base::Sys.time()
[11:01:28.634]     ...future.result
[11:01:28.634] }
[11:01:28.636] plan(): Setting new future strategy stack:
[11:01:28.636] List of future strategies:
[11:01:28.636] 1. sequential:
[11:01:28.636]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.636]    - tweaked: FALSE
[11:01:28.636]    - call: NULL
[11:01:28.636] plan(): nbrOfWorkers() = 1
[11:01:28.637] plan(): Setting new future strategy stack:
[11:01:28.637] List of future strategies:
[11:01:28.637] 1. sequential:
[11:01:28.637]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.637]    - tweaked: FALSE
[11:01:28.637]    - call: plan(strategy)
[11:01:28.637] plan(): nbrOfWorkers() = 1
[11:01:28.638] SequentialFuture started (and completed)
[11:01:28.638] - Launch lazy future ... done
[11:01:28.638] run() for ‘SequentialFuture’ ... done
[11:01:28.638] getGlobalsAndPackages() ...
[11:01:28.638] Searching for globals...
[11:01:28.638] 
[11:01:28.638] Searching for globals ... DONE
[11:01:28.638] - globals: [0] <none>
[11:01:28.638] getGlobalsAndPackages() ... DONE
[11:01:28.639] run() for ‘Future’ ...
[11:01:28.639] - state: ‘created’
[11:01:28.639] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.639] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.639] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.639]   - Field: ‘label’
[11:01:28.639]   - Field: ‘local’
[11:01:28.639]   - Field: ‘owner’
[11:01:28.640]   - Field: ‘envir’
[11:01:28.640]   - Field: ‘packages’
[11:01:28.640]   - Field: ‘gc’
[11:01:28.640]   - Field: ‘conditions’
[11:01:28.640]   - Field: ‘expr’
[11:01:28.640]   - Field: ‘uuid’
[11:01:28.640]   - Field: ‘seed’
[11:01:28.640]   - Field: ‘version’
[11:01:28.640]   - Field: ‘result’
[11:01:28.640]   - Field: ‘asynchronous’
[11:01:28.640]   - Field: ‘calls’
[11:01:28.640]   - Field: ‘globals’
[11:01:28.640]   - Field: ‘stdout’
[11:01:28.641]   - Field: ‘earlySignal’
[11:01:28.641]   - Field: ‘lazy’
[11:01:28.641]   - Field: ‘state’
[11:01:28.641] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.641] - Launch lazy future ...
[11:01:28.641] Packages needed by the future expression (n = 0): <none>
[11:01:28.641] Packages needed by future strategies (n = 0): <none>
[11:01:28.642] {
[11:01:28.642]     {
[11:01:28.642]         {
[11:01:28.642]             ...future.startTime <- base::Sys.time()
[11:01:28.642]             {
[11:01:28.642]                 {
[11:01:28.642]                   {
[11:01:28.642]                     base::local({
[11:01:28.642]                       has_future <- base::requireNamespace("future", 
[11:01:28.642]                         quietly = TRUE)
[11:01:28.642]                       if (has_future) {
[11:01:28.642]                         ns <- base::getNamespace("future")
[11:01:28.642]                         version <- ns[[".package"]][["version"]]
[11:01:28.642]                         if (is.null(version)) 
[11:01:28.642]                           version <- utils::packageVersion("future")
[11:01:28.642]                       }
[11:01:28.642]                       else {
[11:01:28.642]                         version <- NULL
[11:01:28.642]                       }
[11:01:28.642]                       if (!has_future || version < "1.8.0") {
[11:01:28.642]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.642]                           "", base::R.version$version.string), 
[11:01:28.642]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.642]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.642]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.642]                             "release", "version")], collapse = " "), 
[11:01:28.642]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.642]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.642]                           info)
[11:01:28.642]                         info <- base::paste(info, collapse = "; ")
[11:01:28.642]                         if (!has_future) {
[11:01:28.642]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.642]                             info)
[11:01:28.642]                         }
[11:01:28.642]                         else {
[11:01:28.642]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.642]                             info, version)
[11:01:28.642]                         }
[11:01:28.642]                         base::stop(msg)
[11:01:28.642]                       }
[11:01:28.642]                     })
[11:01:28.642]                   }
[11:01:28.642]                   ...future.strategy.old <- future::plan("list")
[11:01:28.642]                   options(future.plan = NULL)
[11:01:28.642]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.642]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.642]                 }
[11:01:28.642]                 ...future.workdir <- getwd()
[11:01:28.642]             }
[11:01:28.642]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.642]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.642]         }
[11:01:28.642]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.642]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.642]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.642]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.642]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.642]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.642]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.642]             base::names(...future.oldOptions))
[11:01:28.642]     }
[11:01:28.642]     if (FALSE) {
[11:01:28.642]     }
[11:01:28.642]     else {
[11:01:28.642]         if (TRUE) {
[11:01:28.642]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.642]                 open = "w")
[11:01:28.642]         }
[11:01:28.642]         else {
[11:01:28.642]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.642]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.642]         }
[11:01:28.642]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.642]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.642]             base::sink(type = "output", split = FALSE)
[11:01:28.642]             base::close(...future.stdout)
[11:01:28.642]         }, add = TRUE)
[11:01:28.642]     }
[11:01:28.642]     ...future.frame <- base::sys.nframe()
[11:01:28.642]     ...future.conditions <- base::list()
[11:01:28.642]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.642]     if (FALSE) {
[11:01:28.642]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.642]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.642]     }
[11:01:28.642]     ...future.result <- base::tryCatch({
[11:01:28.642]         base::withCallingHandlers({
[11:01:28.642]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.642]             future::FutureResult(value = ...future.value$value, 
[11:01:28.642]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.642]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.642]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.642]                     ...future.globalenv.names))
[11:01:28.642]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.642]         }, condition = base::local({
[11:01:28.642]             c <- base::c
[11:01:28.642]             inherits <- base::inherits
[11:01:28.642]             invokeRestart <- base::invokeRestart
[11:01:28.642]             length <- base::length
[11:01:28.642]             list <- base::list
[11:01:28.642]             seq.int <- base::seq.int
[11:01:28.642]             signalCondition <- base::signalCondition
[11:01:28.642]             sys.calls <- base::sys.calls
[11:01:28.642]             `[[` <- base::`[[`
[11:01:28.642]             `+` <- base::`+`
[11:01:28.642]             `<<-` <- base::`<<-`
[11:01:28.642]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.642]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.642]                   3L)]
[11:01:28.642]             }
[11:01:28.642]             function(cond) {
[11:01:28.642]                 is_error <- inherits(cond, "error")
[11:01:28.642]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.642]                   NULL)
[11:01:28.642]                 if (is_error) {
[11:01:28.642]                   sessionInformation <- function() {
[11:01:28.642]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.642]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.642]                       search = base::search(), system = base::Sys.info())
[11:01:28.642]                   }
[11:01:28.642]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.642]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.642]                     cond$call), session = sessionInformation(), 
[11:01:28.642]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.642]                   signalCondition(cond)
[11:01:28.642]                 }
[11:01:28.642]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.642]                 "immediateCondition"))) {
[11:01:28.642]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.642]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.642]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.642]                   if (TRUE && !signal) {
[11:01:28.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.642]                     {
[11:01:28.642]                       inherits <- base::inherits
[11:01:28.642]                       invokeRestart <- base::invokeRestart
[11:01:28.642]                       is.null <- base::is.null
[11:01:28.642]                       muffled <- FALSE
[11:01:28.642]                       if (inherits(cond, "message")) {
[11:01:28.642]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.642]                         if (muffled) 
[11:01:28.642]                           invokeRestart("muffleMessage")
[11:01:28.642]                       }
[11:01:28.642]                       else if (inherits(cond, "warning")) {
[11:01:28.642]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.642]                         if (muffled) 
[11:01:28.642]                           invokeRestart("muffleWarning")
[11:01:28.642]                       }
[11:01:28.642]                       else if (inherits(cond, "condition")) {
[11:01:28.642]                         if (!is.null(pattern)) {
[11:01:28.642]                           computeRestarts <- base::computeRestarts
[11:01:28.642]                           grepl <- base::grepl
[11:01:28.642]                           restarts <- computeRestarts(cond)
[11:01:28.642]                           for (restart in restarts) {
[11:01:28.642]                             name <- restart$name
[11:01:28.642]                             if (is.null(name)) 
[11:01:28.642]                               next
[11:01:28.642]                             if (!grepl(pattern, name)) 
[11:01:28.642]                               next
[11:01:28.642]                             invokeRestart(restart)
[11:01:28.642]                             muffled <- TRUE
[11:01:28.642]                             break
[11:01:28.642]                           }
[11:01:28.642]                         }
[11:01:28.642]                       }
[11:01:28.642]                       invisible(muffled)
[11:01:28.642]                     }
[11:01:28.642]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.642]                   }
[11:01:28.642]                 }
[11:01:28.642]                 else {
[11:01:28.642]                   if (TRUE) {
[11:01:28.642]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.642]                     {
[11:01:28.642]                       inherits <- base::inherits
[11:01:28.642]                       invokeRestart <- base::invokeRestart
[11:01:28.642]                       is.null <- base::is.null
[11:01:28.642]                       muffled <- FALSE
[11:01:28.642]                       if (inherits(cond, "message")) {
[11:01:28.642]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.642]                         if (muffled) 
[11:01:28.642]                           invokeRestart("muffleMessage")
[11:01:28.642]                       }
[11:01:28.642]                       else if (inherits(cond, "warning")) {
[11:01:28.642]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.642]                         if (muffled) 
[11:01:28.642]                           invokeRestart("muffleWarning")
[11:01:28.642]                       }
[11:01:28.642]                       else if (inherits(cond, "condition")) {
[11:01:28.642]                         if (!is.null(pattern)) {
[11:01:28.642]                           computeRestarts <- base::computeRestarts
[11:01:28.642]                           grepl <- base::grepl
[11:01:28.642]                           restarts <- computeRestarts(cond)
[11:01:28.642]                           for (restart in restarts) {
[11:01:28.642]                             name <- restart$name
[11:01:28.642]                             if (is.null(name)) 
[11:01:28.642]                               next
[11:01:28.642]                             if (!grepl(pattern, name)) 
[11:01:28.642]                               next
[11:01:28.642]                             invokeRestart(restart)
[11:01:28.642]                             muffled <- TRUE
[11:01:28.642]                             break
[11:01:28.642]                           }
[11:01:28.642]                         }
[11:01:28.642]                       }
[11:01:28.642]                       invisible(muffled)
[11:01:28.642]                     }
[11:01:28.642]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.642]                   }
[11:01:28.642]                 }
[11:01:28.642]             }
[11:01:28.642]         }))
[11:01:28.642]     }, error = function(ex) {
[11:01:28.642]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.642]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.642]                 ...future.rng), started = ...future.startTime, 
[11:01:28.642]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.642]             version = "1.8"), class = "FutureResult")
[11:01:28.642]     }, finally = {
[11:01:28.642]         if (!identical(...future.workdir, getwd())) 
[11:01:28.642]             setwd(...future.workdir)
[11:01:28.642]         {
[11:01:28.642]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.642]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.642]             }
[11:01:28.642]             base::options(...future.oldOptions)
[11:01:28.642]             if (.Platform$OS.type == "windows") {
[11:01:28.642]                 old_names <- names(...future.oldEnvVars)
[11:01:28.642]                 envs <- base::Sys.getenv()
[11:01:28.642]                 names <- names(envs)
[11:01:28.642]                 common <- intersect(names, old_names)
[11:01:28.642]                 added <- setdiff(names, old_names)
[11:01:28.642]                 removed <- setdiff(old_names, names)
[11:01:28.642]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.642]                   envs[common]]
[11:01:28.642]                 NAMES <- toupper(changed)
[11:01:28.642]                 args <- list()
[11:01:28.642]                 for (kk in seq_along(NAMES)) {
[11:01:28.642]                   name <- changed[[kk]]
[11:01:28.642]                   NAME <- NAMES[[kk]]
[11:01:28.642]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.642]                     next
[11:01:28.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.642]                 }
[11:01:28.642]                 NAMES <- toupper(added)
[11:01:28.642]                 for (kk in seq_along(NAMES)) {
[11:01:28.642]                   name <- added[[kk]]
[11:01:28.642]                   NAME <- NAMES[[kk]]
[11:01:28.642]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.642]                     next
[11:01:28.642]                   args[[name]] <- ""
[11:01:28.642]                 }
[11:01:28.642]                 NAMES <- toupper(removed)
[11:01:28.642]                 for (kk in seq_along(NAMES)) {
[11:01:28.642]                   name <- removed[[kk]]
[11:01:28.642]                   NAME <- NAMES[[kk]]
[11:01:28.642]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.642]                     next
[11:01:28.642]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.642]                 }
[11:01:28.642]                 if (length(args) > 0) 
[11:01:28.642]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.642]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.642]             }
[11:01:28.642]             else {
[11:01:28.642]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.642]             }
[11:01:28.642]             {
[11:01:28.642]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.642]                   0L) {
[11:01:28.642]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.642]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.642]                   base::options(opts)
[11:01:28.642]                 }
[11:01:28.642]                 {
[11:01:28.642]                   {
[11:01:28.642]                     NULL
[11:01:28.642]                     RNGkind("Mersenne-Twister")
[11:01:28.642]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.642]                       inherits = FALSE)
[11:01:28.642]                   }
[11:01:28.642]                   options(future.plan = NULL)
[11:01:28.642]                   if (is.na(NA_character_)) 
[11:01:28.642]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.642]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.642]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.642]                     .init = FALSE)
[11:01:28.642]                 }
[11:01:28.642]             }
[11:01:28.642]         }
[11:01:28.642]     })
[11:01:28.642]     if (TRUE) {
[11:01:28.642]         base::sink(type = "output", split = FALSE)
[11:01:28.642]         if (TRUE) {
[11:01:28.642]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.642]         }
[11:01:28.642]         else {
[11:01:28.642]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.642]         }
[11:01:28.642]         base::close(...future.stdout)
[11:01:28.642]         ...future.stdout <- NULL
[11:01:28.642]     }
[11:01:28.642]     ...future.result$conditions <- ...future.conditions
[11:01:28.642]     ...future.result$finished <- base::Sys.time()
[11:01:28.642]     ...future.result
[11:01:28.642] }
[11:01:28.643] plan(): Setting new future strategy stack:
[11:01:28.643] List of future strategies:
[11:01:28.643] 1. sequential:
[11:01:28.643]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.643]    - tweaked: FALSE
[11:01:28.643]    - call: NULL
[11:01:28.644] plan(): nbrOfWorkers() = 1
[11:01:28.644] plan(): Setting new future strategy stack:
[11:01:28.644] List of future strategies:
[11:01:28.644] 1. sequential:
[11:01:28.644]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.644]    - tweaked: FALSE
[11:01:28.644]    - call: plan(strategy)
[11:01:28.645] plan(): nbrOfWorkers() = 1
[11:01:28.645] SequentialFuture started (and completed)
[11:01:28.645] - Launch lazy future ... done
[11:01:28.645] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c4d460a8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c624e500> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c4d460a8> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c624e500> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[11:01:28.650] resolved() for ‘SequentialFuture’ ...
[11:01:28.650] - state: ‘finished’
[11:01:28.650] - run: TRUE
[11:01:28.650] - result: ‘FutureResult’
[11:01:28.650] resolved() for ‘SequentialFuture’ ... done
[11:01:28.650] resolved() for ‘SequentialFuture’ ...
[11:01:28.650] - state: ‘finished’
[11:01:28.650] - run: TRUE
[11:01:28.650] - result: ‘FutureResult’
[11:01:28.651] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:28.652] resolve() on list ...
[11:01:28.652]  recursive: 0
[11:01:28.652]  length: 6
[11:01:28.652]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:28.652] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.653] - nx: 6
[11:01:28.653] - relay: TRUE
[11:01:28.653] - stdout: TRUE
[11:01:28.653] - signal: TRUE
[11:01:28.653] - resignal: FALSE
[11:01:28.653] - force: TRUE
[11:01:28.653] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.653] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.653]  - until=2
[11:01:28.653]  - relaying element #2
[11:01:28.653] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.653] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.653] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.654]  length: 5 (resolved future 1)
[11:01:28.654] resolved() for ‘SequentialFuture’ ...
[11:01:28.654] - state: ‘finished’
[11:01:28.654] - run: TRUE
[11:01:28.654] - result: ‘FutureResult’
[11:01:28.654] resolved() for ‘SequentialFuture’ ... done
[11:01:28.654] Future #2
[11:01:28.654] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.654] - nx: 6
[11:01:28.654] - relay: TRUE
[11:01:28.655] - stdout: TRUE
[11:01:28.655] - signal: TRUE
[11:01:28.656] - resignal: FALSE
[11:01:28.656] - force: TRUE
[11:01:28.656] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.656] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.656]  - until=2
[11:01:28.656]  - relaying element #2
[11:01:28.656] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.656] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.656] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.656]  length: 4 (resolved future 2)
[11:01:28.656] resolved() for ‘SequentialFuture’ ...
[11:01:28.657] - state: ‘finished’
[11:01:28.657] - run: TRUE
[11:01:28.657] - result: ‘FutureResult’
[11:01:28.657] resolved() for ‘SequentialFuture’ ... done
[11:01:28.657] Future #3
[11:01:28.657] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.657] - nx: 6
[11:01:28.657] - relay: TRUE
[11:01:28.657] - stdout: TRUE
[11:01:28.657] - signal: TRUE
[11:01:28.657] - resignal: FALSE
[11:01:28.657] - force: TRUE
[11:01:28.658] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.658] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.658]  - until=3
[11:01:28.658]  - relaying element #3
[11:01:28.658] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.658] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.658] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.658]  length: 3 (resolved future 3)
[11:01:28.658] signalConditionsASAP(NULL, pos=4) ...
[11:01:28.658] - nx: 6
[11:01:28.658] - relay: TRUE
[11:01:28.658] - stdout: TRUE
[11:01:28.659] - signal: TRUE
[11:01:28.659] - resignal: FALSE
[11:01:28.659] - force: TRUE
[11:01:28.659] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.659] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.659]  - until=5
[11:01:28.659]  - relaying element #5
[11:01:28.659] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.659] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.659] signalConditionsASAP(NULL, pos=4) ... done
[11:01:28.659]  length: 2 (resolved future 4)
[11:01:28.659] signalConditionsASAP(NULL, pos=5) ...
[11:01:28.659] - nx: 6
[11:01:28.660] - relay: TRUE
[11:01:28.660] - stdout: TRUE
[11:01:28.660] - signal: TRUE
[11:01:28.660] - resignal: FALSE
[11:01:28.660] - force: TRUE
[11:01:28.660] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.660] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.660]  - until=6
[11:01:28.660]  - relaying element #6
[11:01:28.660] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.660] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.660] signalConditionsASAP(NULL, pos=5) ... done
[11:01:28.660]  length: 1 (resolved future 5)
[11:01:28.661] signalConditionsASAP(numeric, pos=6) ...
[11:01:28.661] - nx: 6
[11:01:28.661] - relay: TRUE
[11:01:28.661] - stdout: TRUE
[11:01:28.661] - signal: TRUE
[11:01:28.661] - resignal: FALSE
[11:01:28.661] - force: TRUE
[11:01:28.661] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.661] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.661]  - until=6
[11:01:28.661] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.661] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.661] signalConditionsASAP(numeric, pos=6) ... done
[11:01:28.662]  length: 0 (resolved future 6)
[11:01:28.662] Relaying remaining futures
[11:01:28.662] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.662] - nx: 6
[11:01:28.662] - relay: TRUE
[11:01:28.662] - stdout: TRUE
[11:01:28.662] - signal: TRUE
[11:01:28.662] - resignal: FALSE
[11:01:28.662] - force: TRUE
[11:01:28.662] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.662] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:28.662] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.662] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.663] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.663] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[11:01:28.666] getGlobalsAndPackages() ...
[11:01:28.666] Searching for globals...
[11:01:28.666] 
[11:01:28.666] Searching for globals ... DONE
[11:01:28.666] - globals: [0] <none>
[11:01:28.666] getGlobalsAndPackages() ... DONE
[11:01:28.667] run() for ‘Future’ ...
[11:01:28.667] - state: ‘created’
[11:01:28.667] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.667] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.667] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.667]   - Field: ‘label’
[11:01:28.667]   - Field: ‘local’
[11:01:28.667]   - Field: ‘owner’
[11:01:28.667]   - Field: ‘envir’
[11:01:28.668]   - Field: ‘packages’
[11:01:28.668]   - Field: ‘gc’
[11:01:28.668]   - Field: ‘conditions’
[11:01:28.668]   - Field: ‘expr’
[11:01:28.668]   - Field: ‘uuid’
[11:01:28.668]   - Field: ‘seed’
[11:01:28.668]   - Field: ‘version’
[11:01:28.668]   - Field: ‘result’
[11:01:28.668]   - Field: ‘asynchronous’
[11:01:28.668]   - Field: ‘calls’
[11:01:28.668]   - Field: ‘globals’
[11:01:28.668]   - Field: ‘stdout’
[11:01:28.668]   - Field: ‘earlySignal’
[11:01:28.669]   - Field: ‘lazy’
[11:01:28.669]   - Field: ‘state’
[11:01:28.669] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.669] - Launch lazy future ...
[11:01:28.669] Packages needed by the future expression (n = 0): <none>
[11:01:28.669] Packages needed by future strategies (n = 0): <none>
[11:01:28.669] {
[11:01:28.669]     {
[11:01:28.669]         {
[11:01:28.669]             ...future.startTime <- base::Sys.time()
[11:01:28.669]             {
[11:01:28.669]                 {
[11:01:28.669]                   {
[11:01:28.669]                     base::local({
[11:01:28.669]                       has_future <- base::requireNamespace("future", 
[11:01:28.669]                         quietly = TRUE)
[11:01:28.669]                       if (has_future) {
[11:01:28.669]                         ns <- base::getNamespace("future")
[11:01:28.669]                         version <- ns[[".package"]][["version"]]
[11:01:28.669]                         if (is.null(version)) 
[11:01:28.669]                           version <- utils::packageVersion("future")
[11:01:28.669]                       }
[11:01:28.669]                       else {
[11:01:28.669]                         version <- NULL
[11:01:28.669]                       }
[11:01:28.669]                       if (!has_future || version < "1.8.0") {
[11:01:28.669]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.669]                           "", base::R.version$version.string), 
[11:01:28.669]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.669]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.669]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.669]                             "release", "version")], collapse = " "), 
[11:01:28.669]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.669]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.669]                           info)
[11:01:28.669]                         info <- base::paste(info, collapse = "; ")
[11:01:28.669]                         if (!has_future) {
[11:01:28.669]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.669]                             info)
[11:01:28.669]                         }
[11:01:28.669]                         else {
[11:01:28.669]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.669]                             info, version)
[11:01:28.669]                         }
[11:01:28.669]                         base::stop(msg)
[11:01:28.669]                       }
[11:01:28.669]                     })
[11:01:28.669]                   }
[11:01:28.669]                   ...future.strategy.old <- future::plan("list")
[11:01:28.669]                   options(future.plan = NULL)
[11:01:28.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.669]                 }
[11:01:28.669]                 ...future.workdir <- getwd()
[11:01:28.669]             }
[11:01:28.669]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.669]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.669]         }
[11:01:28.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.669]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.669]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.669]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.669]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.669]             base::names(...future.oldOptions))
[11:01:28.669]     }
[11:01:28.669]     if (FALSE) {
[11:01:28.669]     }
[11:01:28.669]     else {
[11:01:28.669]         if (TRUE) {
[11:01:28.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.669]                 open = "w")
[11:01:28.669]         }
[11:01:28.669]         else {
[11:01:28.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.669]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.669]         }
[11:01:28.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.669]             base::sink(type = "output", split = FALSE)
[11:01:28.669]             base::close(...future.stdout)
[11:01:28.669]         }, add = TRUE)
[11:01:28.669]     }
[11:01:28.669]     ...future.frame <- base::sys.nframe()
[11:01:28.669]     ...future.conditions <- base::list()
[11:01:28.669]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.669]     if (FALSE) {
[11:01:28.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.669]     }
[11:01:28.669]     ...future.result <- base::tryCatch({
[11:01:28.669]         base::withCallingHandlers({
[11:01:28.669]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.669]             future::FutureResult(value = ...future.value$value, 
[11:01:28.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.669]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.669]                     ...future.globalenv.names))
[11:01:28.669]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.669]         }, condition = base::local({
[11:01:28.669]             c <- base::c
[11:01:28.669]             inherits <- base::inherits
[11:01:28.669]             invokeRestart <- base::invokeRestart
[11:01:28.669]             length <- base::length
[11:01:28.669]             list <- base::list
[11:01:28.669]             seq.int <- base::seq.int
[11:01:28.669]             signalCondition <- base::signalCondition
[11:01:28.669]             sys.calls <- base::sys.calls
[11:01:28.669]             `[[` <- base::`[[`
[11:01:28.669]             `+` <- base::`+`
[11:01:28.669]             `<<-` <- base::`<<-`
[11:01:28.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.669]                   3L)]
[11:01:28.669]             }
[11:01:28.669]             function(cond) {
[11:01:28.669]                 is_error <- inherits(cond, "error")
[11:01:28.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.669]                   NULL)
[11:01:28.669]                 if (is_error) {
[11:01:28.669]                   sessionInformation <- function() {
[11:01:28.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.669]                       search = base::search(), system = base::Sys.info())
[11:01:28.669]                   }
[11:01:28.669]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.669]                     cond$call), session = sessionInformation(), 
[11:01:28.669]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.669]                   signalCondition(cond)
[11:01:28.669]                 }
[11:01:28.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.669]                 "immediateCondition"))) {
[11:01:28.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.669]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.669]                   if (TRUE && !signal) {
[11:01:28.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.669]                     {
[11:01:28.669]                       inherits <- base::inherits
[11:01:28.669]                       invokeRestart <- base::invokeRestart
[11:01:28.669]                       is.null <- base::is.null
[11:01:28.669]                       muffled <- FALSE
[11:01:28.669]                       if (inherits(cond, "message")) {
[11:01:28.669]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.669]                         if (muffled) 
[11:01:28.669]                           invokeRestart("muffleMessage")
[11:01:28.669]                       }
[11:01:28.669]                       else if (inherits(cond, "warning")) {
[11:01:28.669]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.669]                         if (muffled) 
[11:01:28.669]                           invokeRestart("muffleWarning")
[11:01:28.669]                       }
[11:01:28.669]                       else if (inherits(cond, "condition")) {
[11:01:28.669]                         if (!is.null(pattern)) {
[11:01:28.669]                           computeRestarts <- base::computeRestarts
[11:01:28.669]                           grepl <- base::grepl
[11:01:28.669]                           restarts <- computeRestarts(cond)
[11:01:28.669]                           for (restart in restarts) {
[11:01:28.669]                             name <- restart$name
[11:01:28.669]                             if (is.null(name)) 
[11:01:28.669]                               next
[11:01:28.669]                             if (!grepl(pattern, name)) 
[11:01:28.669]                               next
[11:01:28.669]                             invokeRestart(restart)
[11:01:28.669]                             muffled <- TRUE
[11:01:28.669]                             break
[11:01:28.669]                           }
[11:01:28.669]                         }
[11:01:28.669]                       }
[11:01:28.669]                       invisible(muffled)
[11:01:28.669]                     }
[11:01:28.669]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.669]                   }
[11:01:28.669]                 }
[11:01:28.669]                 else {
[11:01:28.669]                   if (TRUE) {
[11:01:28.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.669]                     {
[11:01:28.669]                       inherits <- base::inherits
[11:01:28.669]                       invokeRestart <- base::invokeRestart
[11:01:28.669]                       is.null <- base::is.null
[11:01:28.669]                       muffled <- FALSE
[11:01:28.669]                       if (inherits(cond, "message")) {
[11:01:28.669]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.669]                         if (muffled) 
[11:01:28.669]                           invokeRestart("muffleMessage")
[11:01:28.669]                       }
[11:01:28.669]                       else if (inherits(cond, "warning")) {
[11:01:28.669]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.669]                         if (muffled) 
[11:01:28.669]                           invokeRestart("muffleWarning")
[11:01:28.669]                       }
[11:01:28.669]                       else if (inherits(cond, "condition")) {
[11:01:28.669]                         if (!is.null(pattern)) {
[11:01:28.669]                           computeRestarts <- base::computeRestarts
[11:01:28.669]                           grepl <- base::grepl
[11:01:28.669]                           restarts <- computeRestarts(cond)
[11:01:28.669]                           for (restart in restarts) {
[11:01:28.669]                             name <- restart$name
[11:01:28.669]                             if (is.null(name)) 
[11:01:28.669]                               next
[11:01:28.669]                             if (!grepl(pattern, name)) 
[11:01:28.669]                               next
[11:01:28.669]                             invokeRestart(restart)
[11:01:28.669]                             muffled <- TRUE
[11:01:28.669]                             break
[11:01:28.669]                           }
[11:01:28.669]                         }
[11:01:28.669]                       }
[11:01:28.669]                       invisible(muffled)
[11:01:28.669]                     }
[11:01:28.669]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.669]                   }
[11:01:28.669]                 }
[11:01:28.669]             }
[11:01:28.669]         }))
[11:01:28.669]     }, error = function(ex) {
[11:01:28.669]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.669]                 ...future.rng), started = ...future.startTime, 
[11:01:28.669]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.669]             version = "1.8"), class = "FutureResult")
[11:01:28.669]     }, finally = {
[11:01:28.669]         if (!identical(...future.workdir, getwd())) 
[11:01:28.669]             setwd(...future.workdir)
[11:01:28.669]         {
[11:01:28.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.669]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.669]             }
[11:01:28.669]             base::options(...future.oldOptions)
[11:01:28.669]             if (.Platform$OS.type == "windows") {
[11:01:28.669]                 old_names <- names(...future.oldEnvVars)
[11:01:28.669]                 envs <- base::Sys.getenv()
[11:01:28.669]                 names <- names(envs)
[11:01:28.669]                 common <- intersect(names, old_names)
[11:01:28.669]                 added <- setdiff(names, old_names)
[11:01:28.669]                 removed <- setdiff(old_names, names)
[11:01:28.669]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.669]                   envs[common]]
[11:01:28.669]                 NAMES <- toupper(changed)
[11:01:28.669]                 args <- list()
[11:01:28.669]                 for (kk in seq_along(NAMES)) {
[11:01:28.669]                   name <- changed[[kk]]
[11:01:28.669]                   NAME <- NAMES[[kk]]
[11:01:28.669]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.669]                     next
[11:01:28.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.669]                 }
[11:01:28.669]                 NAMES <- toupper(added)
[11:01:28.669]                 for (kk in seq_along(NAMES)) {
[11:01:28.669]                   name <- added[[kk]]
[11:01:28.669]                   NAME <- NAMES[[kk]]
[11:01:28.669]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.669]                     next
[11:01:28.669]                   args[[name]] <- ""
[11:01:28.669]                 }
[11:01:28.669]                 NAMES <- toupper(removed)
[11:01:28.669]                 for (kk in seq_along(NAMES)) {
[11:01:28.669]                   name <- removed[[kk]]
[11:01:28.669]                   NAME <- NAMES[[kk]]
[11:01:28.669]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.669]                     next
[11:01:28.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.669]                 }
[11:01:28.669]                 if (length(args) > 0) 
[11:01:28.669]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.669]             }
[11:01:28.669]             else {
[11:01:28.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.669]             }
[11:01:28.669]             {
[11:01:28.669]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.669]                   0L) {
[11:01:28.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.669]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.669]                   base::options(opts)
[11:01:28.669]                 }
[11:01:28.669]                 {
[11:01:28.669]                   {
[11:01:28.669]                     NULL
[11:01:28.669]                     RNGkind("Mersenne-Twister")
[11:01:28.669]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.669]                       inherits = FALSE)
[11:01:28.669]                   }
[11:01:28.669]                   options(future.plan = NULL)
[11:01:28.669]                   if (is.na(NA_character_)) 
[11:01:28.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.669]                     .init = FALSE)
[11:01:28.669]                 }
[11:01:28.669]             }
[11:01:28.669]         }
[11:01:28.669]     })
[11:01:28.669]     if (TRUE) {
[11:01:28.669]         base::sink(type = "output", split = FALSE)
[11:01:28.669]         if (TRUE) {
[11:01:28.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.669]         }
[11:01:28.669]         else {
[11:01:28.669]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.669]         }
[11:01:28.669]         base::close(...future.stdout)
[11:01:28.669]         ...future.stdout <- NULL
[11:01:28.669]     }
[11:01:28.669]     ...future.result$conditions <- ...future.conditions
[11:01:28.669]     ...future.result$finished <- base::Sys.time()
[11:01:28.669]     ...future.result
[11:01:28.669] }
[11:01:28.671] plan(): Setting new future strategy stack:
[11:01:28.671] List of future strategies:
[11:01:28.671] 1. sequential:
[11:01:28.671]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.671]    - tweaked: FALSE
[11:01:28.671]    - call: NULL
[11:01:28.672] plan(): nbrOfWorkers() = 1
[11:01:28.672] plan(): Setting new future strategy stack:
[11:01:28.672] List of future strategies:
[11:01:28.672] 1. sequential:
[11:01:28.672]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.672]    - tweaked: FALSE
[11:01:28.672]    - call: plan(strategy)
[11:01:28.673] plan(): nbrOfWorkers() = 1
[11:01:28.673] SequentialFuture started (and completed)
[11:01:28.673] - Launch lazy future ... done
[11:01:28.673] run() for ‘SequentialFuture’ ... done
[11:01:28.673] getGlobalsAndPackages() ...
[11:01:28.673] Searching for globals...
[11:01:28.674] 
[11:01:28.674] Searching for globals ... DONE
[11:01:28.674] - globals: [0] <none>
[11:01:28.674] getGlobalsAndPackages() ... DONE
[11:01:28.674] run() for ‘Future’ ...
[11:01:28.674] - state: ‘created’
[11:01:28.674] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.674] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.675] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.675]   - Field: ‘label’
[11:01:28.675]   - Field: ‘local’
[11:01:28.675]   - Field: ‘owner’
[11:01:28.675]   - Field: ‘envir’
[11:01:28.675]   - Field: ‘packages’
[11:01:28.675]   - Field: ‘gc’
[11:01:28.675]   - Field: ‘conditions’
[11:01:28.675]   - Field: ‘expr’
[11:01:28.675]   - Field: ‘uuid’
[11:01:28.675]   - Field: ‘seed’
[11:01:28.675]   - Field: ‘version’
[11:01:28.676]   - Field: ‘result’
[11:01:28.676]   - Field: ‘asynchronous’
[11:01:28.676]   - Field: ‘calls’
[11:01:28.676]   - Field: ‘globals’
[11:01:28.676]   - Field: ‘stdout’
[11:01:28.676]   - Field: ‘earlySignal’
[11:01:28.676]   - Field: ‘lazy’
[11:01:28.676]   - Field: ‘state’
[11:01:28.676] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.676] - Launch lazy future ...
[11:01:28.676] Packages needed by the future expression (n = 0): <none>
[11:01:28.677] Packages needed by future strategies (n = 0): <none>
[11:01:28.677] {
[11:01:28.677]     {
[11:01:28.677]         {
[11:01:28.677]             ...future.startTime <- base::Sys.time()
[11:01:28.677]             {
[11:01:28.677]                 {
[11:01:28.677]                   {
[11:01:28.677]                     base::local({
[11:01:28.677]                       has_future <- base::requireNamespace("future", 
[11:01:28.677]                         quietly = TRUE)
[11:01:28.677]                       if (has_future) {
[11:01:28.677]                         ns <- base::getNamespace("future")
[11:01:28.677]                         version <- ns[[".package"]][["version"]]
[11:01:28.677]                         if (is.null(version)) 
[11:01:28.677]                           version <- utils::packageVersion("future")
[11:01:28.677]                       }
[11:01:28.677]                       else {
[11:01:28.677]                         version <- NULL
[11:01:28.677]                       }
[11:01:28.677]                       if (!has_future || version < "1.8.0") {
[11:01:28.677]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.677]                           "", base::R.version$version.string), 
[11:01:28.677]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.677]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.677]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.677]                             "release", "version")], collapse = " "), 
[11:01:28.677]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.677]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.677]                           info)
[11:01:28.677]                         info <- base::paste(info, collapse = "; ")
[11:01:28.677]                         if (!has_future) {
[11:01:28.677]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.677]                             info)
[11:01:28.677]                         }
[11:01:28.677]                         else {
[11:01:28.677]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.677]                             info, version)
[11:01:28.677]                         }
[11:01:28.677]                         base::stop(msg)
[11:01:28.677]                       }
[11:01:28.677]                     })
[11:01:28.677]                   }
[11:01:28.677]                   ...future.strategy.old <- future::plan("list")
[11:01:28.677]                   options(future.plan = NULL)
[11:01:28.677]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.677]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.677]                 }
[11:01:28.677]                 ...future.workdir <- getwd()
[11:01:28.677]             }
[11:01:28.677]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.677]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.677]         }
[11:01:28.677]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.677]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.677]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.677]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.677]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.677]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.677]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.677]             base::names(...future.oldOptions))
[11:01:28.677]     }
[11:01:28.677]     if (FALSE) {
[11:01:28.677]     }
[11:01:28.677]     else {
[11:01:28.677]         if (TRUE) {
[11:01:28.677]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.677]                 open = "w")
[11:01:28.677]         }
[11:01:28.677]         else {
[11:01:28.677]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.677]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.677]         }
[11:01:28.677]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.677]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.677]             base::sink(type = "output", split = FALSE)
[11:01:28.677]             base::close(...future.stdout)
[11:01:28.677]         }, add = TRUE)
[11:01:28.677]     }
[11:01:28.677]     ...future.frame <- base::sys.nframe()
[11:01:28.677]     ...future.conditions <- base::list()
[11:01:28.677]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.677]     if (FALSE) {
[11:01:28.677]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.677]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.677]     }
[11:01:28.677]     ...future.result <- base::tryCatch({
[11:01:28.677]         base::withCallingHandlers({
[11:01:28.677]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.677]             future::FutureResult(value = ...future.value$value, 
[11:01:28.677]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.677]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.677]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.677]                     ...future.globalenv.names))
[11:01:28.677]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.677]         }, condition = base::local({
[11:01:28.677]             c <- base::c
[11:01:28.677]             inherits <- base::inherits
[11:01:28.677]             invokeRestart <- base::invokeRestart
[11:01:28.677]             length <- base::length
[11:01:28.677]             list <- base::list
[11:01:28.677]             seq.int <- base::seq.int
[11:01:28.677]             signalCondition <- base::signalCondition
[11:01:28.677]             sys.calls <- base::sys.calls
[11:01:28.677]             `[[` <- base::`[[`
[11:01:28.677]             `+` <- base::`+`
[11:01:28.677]             `<<-` <- base::`<<-`
[11:01:28.677]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.677]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.677]                   3L)]
[11:01:28.677]             }
[11:01:28.677]             function(cond) {
[11:01:28.677]                 is_error <- inherits(cond, "error")
[11:01:28.677]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.677]                   NULL)
[11:01:28.677]                 if (is_error) {
[11:01:28.677]                   sessionInformation <- function() {
[11:01:28.677]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.677]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.677]                       search = base::search(), system = base::Sys.info())
[11:01:28.677]                   }
[11:01:28.677]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.677]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.677]                     cond$call), session = sessionInformation(), 
[11:01:28.677]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.677]                   signalCondition(cond)
[11:01:28.677]                 }
[11:01:28.677]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.677]                 "immediateCondition"))) {
[11:01:28.677]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.677]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.677]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.677]                   if (TRUE && !signal) {
[11:01:28.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.677]                     {
[11:01:28.677]                       inherits <- base::inherits
[11:01:28.677]                       invokeRestart <- base::invokeRestart
[11:01:28.677]                       is.null <- base::is.null
[11:01:28.677]                       muffled <- FALSE
[11:01:28.677]                       if (inherits(cond, "message")) {
[11:01:28.677]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.677]                         if (muffled) 
[11:01:28.677]                           invokeRestart("muffleMessage")
[11:01:28.677]                       }
[11:01:28.677]                       else if (inherits(cond, "warning")) {
[11:01:28.677]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.677]                         if (muffled) 
[11:01:28.677]                           invokeRestart("muffleWarning")
[11:01:28.677]                       }
[11:01:28.677]                       else if (inherits(cond, "condition")) {
[11:01:28.677]                         if (!is.null(pattern)) {
[11:01:28.677]                           computeRestarts <- base::computeRestarts
[11:01:28.677]                           grepl <- base::grepl
[11:01:28.677]                           restarts <- computeRestarts(cond)
[11:01:28.677]                           for (restart in restarts) {
[11:01:28.677]                             name <- restart$name
[11:01:28.677]                             if (is.null(name)) 
[11:01:28.677]                               next
[11:01:28.677]                             if (!grepl(pattern, name)) 
[11:01:28.677]                               next
[11:01:28.677]                             invokeRestart(restart)
[11:01:28.677]                             muffled <- TRUE
[11:01:28.677]                             break
[11:01:28.677]                           }
[11:01:28.677]                         }
[11:01:28.677]                       }
[11:01:28.677]                       invisible(muffled)
[11:01:28.677]                     }
[11:01:28.677]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.677]                   }
[11:01:28.677]                 }
[11:01:28.677]                 else {
[11:01:28.677]                   if (TRUE) {
[11:01:28.677]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.677]                     {
[11:01:28.677]                       inherits <- base::inherits
[11:01:28.677]                       invokeRestart <- base::invokeRestart
[11:01:28.677]                       is.null <- base::is.null
[11:01:28.677]                       muffled <- FALSE
[11:01:28.677]                       if (inherits(cond, "message")) {
[11:01:28.677]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.677]                         if (muffled) 
[11:01:28.677]                           invokeRestart("muffleMessage")
[11:01:28.677]                       }
[11:01:28.677]                       else if (inherits(cond, "warning")) {
[11:01:28.677]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.677]                         if (muffled) 
[11:01:28.677]                           invokeRestart("muffleWarning")
[11:01:28.677]                       }
[11:01:28.677]                       else if (inherits(cond, "condition")) {
[11:01:28.677]                         if (!is.null(pattern)) {
[11:01:28.677]                           computeRestarts <- base::computeRestarts
[11:01:28.677]                           grepl <- base::grepl
[11:01:28.677]                           restarts <- computeRestarts(cond)
[11:01:28.677]                           for (restart in restarts) {
[11:01:28.677]                             name <- restart$name
[11:01:28.677]                             if (is.null(name)) 
[11:01:28.677]                               next
[11:01:28.677]                             if (!grepl(pattern, name)) 
[11:01:28.677]                               next
[11:01:28.677]                             invokeRestart(restart)
[11:01:28.677]                             muffled <- TRUE
[11:01:28.677]                             break
[11:01:28.677]                           }
[11:01:28.677]                         }
[11:01:28.677]                       }
[11:01:28.677]                       invisible(muffled)
[11:01:28.677]                     }
[11:01:28.677]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.677]                   }
[11:01:28.677]                 }
[11:01:28.677]             }
[11:01:28.677]         }))
[11:01:28.677]     }, error = function(ex) {
[11:01:28.677]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.677]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.677]                 ...future.rng), started = ...future.startTime, 
[11:01:28.677]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.677]             version = "1.8"), class = "FutureResult")
[11:01:28.677]     }, finally = {
[11:01:28.677]         if (!identical(...future.workdir, getwd())) 
[11:01:28.677]             setwd(...future.workdir)
[11:01:28.677]         {
[11:01:28.677]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.677]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.677]             }
[11:01:28.677]             base::options(...future.oldOptions)
[11:01:28.677]             if (.Platform$OS.type == "windows") {
[11:01:28.677]                 old_names <- names(...future.oldEnvVars)
[11:01:28.677]                 envs <- base::Sys.getenv()
[11:01:28.677]                 names <- names(envs)
[11:01:28.677]                 common <- intersect(names, old_names)
[11:01:28.677]                 added <- setdiff(names, old_names)
[11:01:28.677]                 removed <- setdiff(old_names, names)
[11:01:28.677]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.677]                   envs[common]]
[11:01:28.677]                 NAMES <- toupper(changed)
[11:01:28.677]                 args <- list()
[11:01:28.677]                 for (kk in seq_along(NAMES)) {
[11:01:28.677]                   name <- changed[[kk]]
[11:01:28.677]                   NAME <- NAMES[[kk]]
[11:01:28.677]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.677]                     next
[11:01:28.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.677]                 }
[11:01:28.677]                 NAMES <- toupper(added)
[11:01:28.677]                 for (kk in seq_along(NAMES)) {
[11:01:28.677]                   name <- added[[kk]]
[11:01:28.677]                   NAME <- NAMES[[kk]]
[11:01:28.677]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.677]                     next
[11:01:28.677]                   args[[name]] <- ""
[11:01:28.677]                 }
[11:01:28.677]                 NAMES <- toupper(removed)
[11:01:28.677]                 for (kk in seq_along(NAMES)) {
[11:01:28.677]                   name <- removed[[kk]]
[11:01:28.677]                   NAME <- NAMES[[kk]]
[11:01:28.677]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.677]                     next
[11:01:28.677]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.677]                 }
[11:01:28.677]                 if (length(args) > 0) 
[11:01:28.677]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.677]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.677]             }
[11:01:28.677]             else {
[11:01:28.677]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.677]             }
[11:01:28.677]             {
[11:01:28.677]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.677]                   0L) {
[11:01:28.677]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.677]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.677]                   base::options(opts)
[11:01:28.677]                 }
[11:01:28.677]                 {
[11:01:28.677]                   {
[11:01:28.677]                     NULL
[11:01:28.677]                     RNGkind("Mersenne-Twister")
[11:01:28.677]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.677]                       inherits = FALSE)
[11:01:28.677]                   }
[11:01:28.677]                   options(future.plan = NULL)
[11:01:28.677]                   if (is.na(NA_character_)) 
[11:01:28.677]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.677]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.677]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.677]                     .init = FALSE)
[11:01:28.677]                 }
[11:01:28.677]             }
[11:01:28.677]         }
[11:01:28.677]     })
[11:01:28.677]     if (TRUE) {
[11:01:28.677]         base::sink(type = "output", split = FALSE)
[11:01:28.677]         if (TRUE) {
[11:01:28.677]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.677]         }
[11:01:28.677]         else {
[11:01:28.677]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.677]         }
[11:01:28.677]         base::close(...future.stdout)
[11:01:28.677]         ...future.stdout <- NULL
[11:01:28.677]     }
[11:01:28.677]     ...future.result$conditions <- ...future.conditions
[11:01:28.677]     ...future.result$finished <- base::Sys.time()
[11:01:28.677]     ...future.result
[11:01:28.677] }
[11:01:28.679] plan(): Setting new future strategy stack:
[11:01:28.679] List of future strategies:
[11:01:28.679] 1. sequential:
[11:01:28.679]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.679]    - tweaked: FALSE
[11:01:28.679]    - call: NULL
[11:01:28.679] plan(): nbrOfWorkers() = 1
[11:01:28.680] plan(): Setting new future strategy stack:
[11:01:28.680] List of future strategies:
[11:01:28.680] 1. sequential:
[11:01:28.680]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.680]    - tweaked: FALSE
[11:01:28.680]    - call: plan(strategy)
[11:01:28.680] plan(): nbrOfWorkers() = 1
[11:01:28.680] SequentialFuture started (and completed)
[11:01:28.681] - Launch lazy future ... done
[11:01:28.681] run() for ‘SequentialFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c659ec70> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c69f7d18> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c659ec70> 
 $ c:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a9c69f7d18> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[11:01:28.687] resolved() for ‘SequentialFuture’ ...
[11:01:28.687] - state: ‘finished’
[11:01:28.687] - run: TRUE
[11:01:28.687] - result: ‘FutureResult’
[11:01:28.687] resolved() for ‘SequentialFuture’ ... done
[11:01:28.687] resolved() for ‘SequentialFuture’ ...
[11:01:28.687] - state: ‘finished’
[11:01:28.687] - run: TRUE
[11:01:28.687] - result: ‘FutureResult’
[11:01:28.687] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:28.689] resolve() on list ...
[11:01:28.689]  recursive: 0
[11:01:28.689]  length: 6
[11:01:28.689]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:28.689] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.690] - nx: 6
[11:01:28.690] - relay: TRUE
[11:01:28.690] - stdout: TRUE
[11:01:28.690] - signal: TRUE
[11:01:28.690] - resignal: FALSE
[11:01:28.690] - force: TRUE
[11:01:28.690] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.690] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.690]  - until=2
[11:01:28.690]  - relaying element #2
[11:01:28.690] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.690] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.690] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.691]  length: 5 (resolved future 1)
[11:01:28.691] resolved() for ‘SequentialFuture’ ...
[11:01:28.691] - state: ‘finished’
[11:01:28.691] - run: TRUE
[11:01:28.691] - result: ‘FutureResult’
[11:01:28.691] resolved() for ‘SequentialFuture’ ... done
[11:01:28.691] Future #2
[11:01:28.691] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.691] - nx: 6
[11:01:28.691] - relay: TRUE
[11:01:28.691] - stdout: TRUE
[11:01:28.691] - signal: TRUE
[11:01:28.692] - resignal: FALSE
[11:01:28.692] - force: TRUE
[11:01:28.692] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.692] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.692]  - until=2
[11:01:28.692]  - relaying element #2
[11:01:28.692] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.692] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.692] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.692]  length: 4 (resolved future 2)
[11:01:28.692] resolved() for ‘SequentialFuture’ ...
[11:01:28.692] - state: ‘finished’
[11:01:28.693] - run: TRUE
[11:01:28.693] - result: ‘FutureResult’
[11:01:28.693] resolved() for ‘SequentialFuture’ ... done
[11:01:28.693] Future #3
[11:01:28.693] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.693] - nx: 6
[11:01:28.693] - relay: TRUE
[11:01:28.693] - stdout: TRUE
[11:01:28.693] - signal: TRUE
[11:01:28.693] - resignal: FALSE
[11:01:28.693] - force: TRUE
[11:01:28.693] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.693] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.694]  - until=3
[11:01:28.694]  - relaying element #3
[11:01:28.694] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.694] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.694] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.694]  length: 3 (resolved future 3)
[11:01:28.694] signalConditionsASAP(NULL, pos=4) ...
[11:01:28.694] - nx: 6
[11:01:28.694] - relay: TRUE
[11:01:28.694] - stdout: TRUE
[11:01:28.694] - signal: TRUE
[11:01:28.694] - resignal: FALSE
[11:01:28.695] - force: TRUE
[11:01:28.695] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.695] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.695]  - until=5
[11:01:28.695]  - relaying element #5
[11:01:28.695] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.695] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.695] signalConditionsASAP(NULL, pos=4) ... done
[11:01:28.695]  length: 2 (resolved future 4)
[11:01:28.695] signalConditionsASAP(NULL, pos=5) ...
[11:01:28.695] - nx: 6
[11:01:28.695] - relay: TRUE
[11:01:28.695] - stdout: TRUE
[11:01:28.696] - signal: TRUE
[11:01:28.696] - resignal: FALSE
[11:01:28.696] - force: TRUE
[11:01:28.696] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.696] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.696]  - until=6
[11:01:28.696]  - relaying element #6
[11:01:28.696] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.696] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.696] signalConditionsASAP(NULL, pos=5) ... done
[11:01:28.696]  length: 1 (resolved future 5)
[11:01:28.696] signalConditionsASAP(numeric, pos=6) ...
[11:01:28.696] - nx: 6
[11:01:28.697] - relay: TRUE
[11:01:28.697] - stdout: TRUE
[11:01:28.697] - signal: TRUE
[11:01:28.697] - resignal: FALSE
[11:01:28.697] - force: TRUE
[11:01:28.697] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.697] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.697]  - until=6
[11:01:28.697] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.697] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.697] signalConditionsASAP(numeric, pos=6) ... done
[11:01:28.697]  length: 0 (resolved future 6)
[11:01:28.697] Relaying remaining futures
[11:01:28.697] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.698] - nx: 6
[11:01:28.698] - relay: TRUE
[11:01:28.698] - stdout: TRUE
[11:01:28.698] - signal: TRUE
[11:01:28.698] - resignal: FALSE
[11:01:28.698] - force: TRUE
[11:01:28.698] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.698] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:28.698] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.698] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.698] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.698] resolve() on list ... DONE
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: sequential
[11:01:28.707] plan(): Setting new future strategy stack:
[11:01:28.707] List of future strategies:
[11:01:28.707] 1. sequential:
[11:01:28.707]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.707]    - tweaked: FALSE
[11:01:28.707]    - call: plan(strategy)
[11:01:28.708] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[11:01:28.708] getGlobalsAndPackages() ...
[11:01:28.708] Searching for globals...
[11:01:28.708] 
[11:01:28.708] Searching for globals ... DONE
[11:01:28.708] - globals: [0] <none>
[11:01:28.709] getGlobalsAndPackages() ... DONE
[11:01:28.709] run() for ‘Future’ ...
[11:01:28.709] - state: ‘created’
[11:01:28.709] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.709] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.709] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.709]   - Field: ‘label’
[11:01:28.709]   - Field: ‘local’
[11:01:28.710]   - Field: ‘owner’
[11:01:28.710]   - Field: ‘envir’
[11:01:28.710]   - Field: ‘packages’
[11:01:28.710]   - Field: ‘gc’
[11:01:28.710]   - Field: ‘conditions’
[11:01:28.710]   - Field: ‘expr’
[11:01:28.710]   - Field: ‘uuid’
[11:01:28.710]   - Field: ‘seed’
[11:01:28.710]   - Field: ‘version’
[11:01:28.710]   - Field: ‘result’
[11:01:28.710]   - Field: ‘asynchronous’
[11:01:28.710]   - Field: ‘calls’
[11:01:28.711]   - Field: ‘globals’
[11:01:28.711]   - Field: ‘stdout’
[11:01:28.711]   - Field: ‘earlySignal’
[11:01:28.711]   - Field: ‘lazy’
[11:01:28.711]   - Field: ‘state’
[11:01:28.711] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.711] - Launch lazy future ...
[11:01:28.711] Packages needed by the future expression (n = 0): <none>
[11:01:28.711] Packages needed by future strategies (n = 0): <none>
[11:01:28.712] {
[11:01:28.712]     {
[11:01:28.712]         {
[11:01:28.712]             ...future.startTime <- base::Sys.time()
[11:01:28.712]             {
[11:01:28.712]                 {
[11:01:28.712]                   {
[11:01:28.712]                     base::local({
[11:01:28.712]                       has_future <- base::requireNamespace("future", 
[11:01:28.712]                         quietly = TRUE)
[11:01:28.712]                       if (has_future) {
[11:01:28.712]                         ns <- base::getNamespace("future")
[11:01:28.712]                         version <- ns[[".package"]][["version"]]
[11:01:28.712]                         if (is.null(version)) 
[11:01:28.712]                           version <- utils::packageVersion("future")
[11:01:28.712]                       }
[11:01:28.712]                       else {
[11:01:28.712]                         version <- NULL
[11:01:28.712]                       }
[11:01:28.712]                       if (!has_future || version < "1.8.0") {
[11:01:28.712]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.712]                           "", base::R.version$version.string), 
[11:01:28.712]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.712]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.712]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.712]                             "release", "version")], collapse = " "), 
[11:01:28.712]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.712]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.712]                           info)
[11:01:28.712]                         info <- base::paste(info, collapse = "; ")
[11:01:28.712]                         if (!has_future) {
[11:01:28.712]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.712]                             info)
[11:01:28.712]                         }
[11:01:28.712]                         else {
[11:01:28.712]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.712]                             info, version)
[11:01:28.712]                         }
[11:01:28.712]                         base::stop(msg)
[11:01:28.712]                       }
[11:01:28.712]                     })
[11:01:28.712]                   }
[11:01:28.712]                   ...future.strategy.old <- future::plan("list")
[11:01:28.712]                   options(future.plan = NULL)
[11:01:28.712]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.712]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.712]                 }
[11:01:28.712]                 ...future.workdir <- getwd()
[11:01:28.712]             }
[11:01:28.712]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.712]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.712]         }
[11:01:28.712]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.712]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.712]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.712]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.712]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.712]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.712]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.712]             base::names(...future.oldOptions))
[11:01:28.712]     }
[11:01:28.712]     if (FALSE) {
[11:01:28.712]     }
[11:01:28.712]     else {
[11:01:28.712]         if (TRUE) {
[11:01:28.712]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.712]                 open = "w")
[11:01:28.712]         }
[11:01:28.712]         else {
[11:01:28.712]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.712]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.712]         }
[11:01:28.712]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.712]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.712]             base::sink(type = "output", split = FALSE)
[11:01:28.712]             base::close(...future.stdout)
[11:01:28.712]         }, add = TRUE)
[11:01:28.712]     }
[11:01:28.712]     ...future.frame <- base::sys.nframe()
[11:01:28.712]     ...future.conditions <- base::list()
[11:01:28.712]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.712]     if (FALSE) {
[11:01:28.712]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.712]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.712]     }
[11:01:28.712]     ...future.result <- base::tryCatch({
[11:01:28.712]         base::withCallingHandlers({
[11:01:28.712]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.712]             future::FutureResult(value = ...future.value$value, 
[11:01:28.712]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.712]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.712]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.712]                     ...future.globalenv.names))
[11:01:28.712]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.712]         }, condition = base::local({
[11:01:28.712]             c <- base::c
[11:01:28.712]             inherits <- base::inherits
[11:01:28.712]             invokeRestart <- base::invokeRestart
[11:01:28.712]             length <- base::length
[11:01:28.712]             list <- base::list
[11:01:28.712]             seq.int <- base::seq.int
[11:01:28.712]             signalCondition <- base::signalCondition
[11:01:28.712]             sys.calls <- base::sys.calls
[11:01:28.712]             `[[` <- base::`[[`
[11:01:28.712]             `+` <- base::`+`
[11:01:28.712]             `<<-` <- base::`<<-`
[11:01:28.712]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.712]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.712]                   3L)]
[11:01:28.712]             }
[11:01:28.712]             function(cond) {
[11:01:28.712]                 is_error <- inherits(cond, "error")
[11:01:28.712]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.712]                   NULL)
[11:01:28.712]                 if (is_error) {
[11:01:28.712]                   sessionInformation <- function() {
[11:01:28.712]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.712]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.712]                       search = base::search(), system = base::Sys.info())
[11:01:28.712]                   }
[11:01:28.712]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.712]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.712]                     cond$call), session = sessionInformation(), 
[11:01:28.712]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.712]                   signalCondition(cond)
[11:01:28.712]                 }
[11:01:28.712]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.712]                 "immediateCondition"))) {
[11:01:28.712]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.712]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.712]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.712]                   if (TRUE && !signal) {
[11:01:28.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.712]                     {
[11:01:28.712]                       inherits <- base::inherits
[11:01:28.712]                       invokeRestart <- base::invokeRestart
[11:01:28.712]                       is.null <- base::is.null
[11:01:28.712]                       muffled <- FALSE
[11:01:28.712]                       if (inherits(cond, "message")) {
[11:01:28.712]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.712]                         if (muffled) 
[11:01:28.712]                           invokeRestart("muffleMessage")
[11:01:28.712]                       }
[11:01:28.712]                       else if (inherits(cond, "warning")) {
[11:01:28.712]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.712]                         if (muffled) 
[11:01:28.712]                           invokeRestart("muffleWarning")
[11:01:28.712]                       }
[11:01:28.712]                       else if (inherits(cond, "condition")) {
[11:01:28.712]                         if (!is.null(pattern)) {
[11:01:28.712]                           computeRestarts <- base::computeRestarts
[11:01:28.712]                           grepl <- base::grepl
[11:01:28.712]                           restarts <- computeRestarts(cond)
[11:01:28.712]                           for (restart in restarts) {
[11:01:28.712]                             name <- restart$name
[11:01:28.712]                             if (is.null(name)) 
[11:01:28.712]                               next
[11:01:28.712]                             if (!grepl(pattern, name)) 
[11:01:28.712]                               next
[11:01:28.712]                             invokeRestart(restart)
[11:01:28.712]                             muffled <- TRUE
[11:01:28.712]                             break
[11:01:28.712]                           }
[11:01:28.712]                         }
[11:01:28.712]                       }
[11:01:28.712]                       invisible(muffled)
[11:01:28.712]                     }
[11:01:28.712]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.712]                   }
[11:01:28.712]                 }
[11:01:28.712]                 else {
[11:01:28.712]                   if (TRUE) {
[11:01:28.712]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.712]                     {
[11:01:28.712]                       inherits <- base::inherits
[11:01:28.712]                       invokeRestart <- base::invokeRestart
[11:01:28.712]                       is.null <- base::is.null
[11:01:28.712]                       muffled <- FALSE
[11:01:28.712]                       if (inherits(cond, "message")) {
[11:01:28.712]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.712]                         if (muffled) 
[11:01:28.712]                           invokeRestart("muffleMessage")
[11:01:28.712]                       }
[11:01:28.712]                       else if (inherits(cond, "warning")) {
[11:01:28.712]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.712]                         if (muffled) 
[11:01:28.712]                           invokeRestart("muffleWarning")
[11:01:28.712]                       }
[11:01:28.712]                       else if (inherits(cond, "condition")) {
[11:01:28.712]                         if (!is.null(pattern)) {
[11:01:28.712]                           computeRestarts <- base::computeRestarts
[11:01:28.712]                           grepl <- base::grepl
[11:01:28.712]                           restarts <- computeRestarts(cond)
[11:01:28.712]                           for (restart in restarts) {
[11:01:28.712]                             name <- restart$name
[11:01:28.712]                             if (is.null(name)) 
[11:01:28.712]                               next
[11:01:28.712]                             if (!grepl(pattern, name)) 
[11:01:28.712]                               next
[11:01:28.712]                             invokeRestart(restart)
[11:01:28.712]                             muffled <- TRUE
[11:01:28.712]                             break
[11:01:28.712]                           }
[11:01:28.712]                         }
[11:01:28.712]                       }
[11:01:28.712]                       invisible(muffled)
[11:01:28.712]                     }
[11:01:28.712]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.712]                   }
[11:01:28.712]                 }
[11:01:28.712]             }
[11:01:28.712]         }))
[11:01:28.712]     }, error = function(ex) {
[11:01:28.712]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.712]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.712]                 ...future.rng), started = ...future.startTime, 
[11:01:28.712]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.712]             version = "1.8"), class = "FutureResult")
[11:01:28.712]     }, finally = {
[11:01:28.712]         if (!identical(...future.workdir, getwd())) 
[11:01:28.712]             setwd(...future.workdir)
[11:01:28.712]         {
[11:01:28.712]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.712]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.712]             }
[11:01:28.712]             base::options(...future.oldOptions)
[11:01:28.712]             if (.Platform$OS.type == "windows") {
[11:01:28.712]                 old_names <- names(...future.oldEnvVars)
[11:01:28.712]                 envs <- base::Sys.getenv()
[11:01:28.712]                 names <- names(envs)
[11:01:28.712]                 common <- intersect(names, old_names)
[11:01:28.712]                 added <- setdiff(names, old_names)
[11:01:28.712]                 removed <- setdiff(old_names, names)
[11:01:28.712]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.712]                   envs[common]]
[11:01:28.712]                 NAMES <- toupper(changed)
[11:01:28.712]                 args <- list()
[11:01:28.712]                 for (kk in seq_along(NAMES)) {
[11:01:28.712]                   name <- changed[[kk]]
[11:01:28.712]                   NAME <- NAMES[[kk]]
[11:01:28.712]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.712]                     next
[11:01:28.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.712]                 }
[11:01:28.712]                 NAMES <- toupper(added)
[11:01:28.712]                 for (kk in seq_along(NAMES)) {
[11:01:28.712]                   name <- added[[kk]]
[11:01:28.712]                   NAME <- NAMES[[kk]]
[11:01:28.712]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.712]                     next
[11:01:28.712]                   args[[name]] <- ""
[11:01:28.712]                 }
[11:01:28.712]                 NAMES <- toupper(removed)
[11:01:28.712]                 for (kk in seq_along(NAMES)) {
[11:01:28.712]                   name <- removed[[kk]]
[11:01:28.712]                   NAME <- NAMES[[kk]]
[11:01:28.712]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.712]                     next
[11:01:28.712]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.712]                 }
[11:01:28.712]                 if (length(args) > 0) 
[11:01:28.712]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.712]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.712]             }
[11:01:28.712]             else {
[11:01:28.712]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.712]             }
[11:01:28.712]             {
[11:01:28.712]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.712]                   0L) {
[11:01:28.712]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.712]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.712]                   base::options(opts)
[11:01:28.712]                 }
[11:01:28.712]                 {
[11:01:28.712]                   {
[11:01:28.712]                     NULL
[11:01:28.712]                     RNGkind("Mersenne-Twister")
[11:01:28.712]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.712]                       inherits = FALSE)
[11:01:28.712]                   }
[11:01:28.712]                   options(future.plan = NULL)
[11:01:28.712]                   if (is.na(NA_character_)) 
[11:01:28.712]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.712]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.712]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.712]                     .init = FALSE)
[11:01:28.712]                 }
[11:01:28.712]             }
[11:01:28.712]         }
[11:01:28.712]     })
[11:01:28.712]     if (TRUE) {
[11:01:28.712]         base::sink(type = "output", split = FALSE)
[11:01:28.712]         if (TRUE) {
[11:01:28.712]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.712]         }
[11:01:28.712]         else {
[11:01:28.712]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.712]         }
[11:01:28.712]         base::close(...future.stdout)
[11:01:28.712]         ...future.stdout <- NULL
[11:01:28.712]     }
[11:01:28.712]     ...future.result$conditions <- ...future.conditions
[11:01:28.712]     ...future.result$finished <- base::Sys.time()
[11:01:28.712]     ...future.result
[11:01:28.712] }
[11:01:28.713] plan(): Setting new future strategy stack:
[11:01:28.713] List of future strategies:
[11:01:28.713] 1. sequential:
[11:01:28.713]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.713]    - tweaked: FALSE
[11:01:28.713]    - call: NULL
[11:01:28.714] plan(): nbrOfWorkers() = 1
[11:01:28.715] plan(): Setting new future strategy stack:
[11:01:28.715] List of future strategies:
[11:01:28.715] 1. sequential:
[11:01:28.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.715]    - tweaked: FALSE
[11:01:28.715]    - call: plan(strategy)
[11:01:28.715] plan(): nbrOfWorkers() = 1
[11:01:28.715] SequentialFuture started (and completed)
[11:01:28.715] - Launch lazy future ... done
[11:01:28.715] run() for ‘SequentialFuture’ ... done
[11:01:28.716] getGlobalsAndPackages() ...
[11:01:28.716] Searching for globals...
[11:01:28.716] 
[11:01:28.716] Searching for globals ... DONE
[11:01:28.716] - globals: [0] <none>
[11:01:28.716] getGlobalsAndPackages() ... DONE
[11:01:28.716] run() for ‘Future’ ...
[11:01:28.716] - state: ‘created’
[11:01:28.716] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.717] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.717] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.717]   - Field: ‘label’
[11:01:28.717]   - Field: ‘local’
[11:01:28.717]   - Field: ‘owner’
[11:01:28.717]   - Field: ‘envir’
[11:01:28.717]   - Field: ‘packages’
[11:01:28.717]   - Field: ‘gc’
[11:01:28.717]   - Field: ‘conditions’
[11:01:28.718]   - Field: ‘expr’
[11:01:28.718]   - Field: ‘uuid’
[11:01:28.718]   - Field: ‘seed’
[11:01:28.718]   - Field: ‘version’
[11:01:28.718]   - Field: ‘result’
[11:01:28.718]   - Field: ‘asynchronous’
[11:01:28.718]   - Field: ‘calls’
[11:01:28.718]   - Field: ‘globals’
[11:01:28.718]   - Field: ‘stdout’
[11:01:28.718]   - Field: ‘earlySignal’
[11:01:28.718]   - Field: ‘lazy’
[11:01:28.718]   - Field: ‘state’
[11:01:28.718] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.719] - Launch lazy future ...
[11:01:28.719] Packages needed by the future expression (n = 0): <none>
[11:01:28.719] Packages needed by future strategies (n = 0): <none>
[11:01:28.719] {
[11:01:28.719]     {
[11:01:28.719]         {
[11:01:28.719]             ...future.startTime <- base::Sys.time()
[11:01:28.719]             {
[11:01:28.719]                 {
[11:01:28.719]                   {
[11:01:28.719]                     base::local({
[11:01:28.719]                       has_future <- base::requireNamespace("future", 
[11:01:28.719]                         quietly = TRUE)
[11:01:28.719]                       if (has_future) {
[11:01:28.719]                         ns <- base::getNamespace("future")
[11:01:28.719]                         version <- ns[[".package"]][["version"]]
[11:01:28.719]                         if (is.null(version)) 
[11:01:28.719]                           version <- utils::packageVersion("future")
[11:01:28.719]                       }
[11:01:28.719]                       else {
[11:01:28.719]                         version <- NULL
[11:01:28.719]                       }
[11:01:28.719]                       if (!has_future || version < "1.8.0") {
[11:01:28.719]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.719]                           "", base::R.version$version.string), 
[11:01:28.719]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.719]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.719]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.719]                             "release", "version")], collapse = " "), 
[11:01:28.719]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.719]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.719]                           info)
[11:01:28.719]                         info <- base::paste(info, collapse = "; ")
[11:01:28.719]                         if (!has_future) {
[11:01:28.719]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.719]                             info)
[11:01:28.719]                         }
[11:01:28.719]                         else {
[11:01:28.719]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.719]                             info, version)
[11:01:28.719]                         }
[11:01:28.719]                         base::stop(msg)
[11:01:28.719]                       }
[11:01:28.719]                     })
[11:01:28.719]                   }
[11:01:28.719]                   ...future.strategy.old <- future::plan("list")
[11:01:28.719]                   options(future.plan = NULL)
[11:01:28.719]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.719]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.719]                 }
[11:01:28.719]                 ...future.workdir <- getwd()
[11:01:28.719]             }
[11:01:28.719]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.719]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.719]         }
[11:01:28.719]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.719]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.719]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.719]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.719]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.719]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.719]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.719]             base::names(...future.oldOptions))
[11:01:28.719]     }
[11:01:28.719]     if (FALSE) {
[11:01:28.719]     }
[11:01:28.719]     else {
[11:01:28.719]         if (TRUE) {
[11:01:28.719]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.719]                 open = "w")
[11:01:28.719]         }
[11:01:28.719]         else {
[11:01:28.719]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.719]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.719]         }
[11:01:28.719]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.719]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.719]             base::sink(type = "output", split = FALSE)
[11:01:28.719]             base::close(...future.stdout)
[11:01:28.719]         }, add = TRUE)
[11:01:28.719]     }
[11:01:28.719]     ...future.frame <- base::sys.nframe()
[11:01:28.719]     ...future.conditions <- base::list()
[11:01:28.719]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.719]     if (FALSE) {
[11:01:28.719]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.719]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.719]     }
[11:01:28.719]     ...future.result <- base::tryCatch({
[11:01:28.719]         base::withCallingHandlers({
[11:01:28.719]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.719]             future::FutureResult(value = ...future.value$value, 
[11:01:28.719]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.719]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.719]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.719]                     ...future.globalenv.names))
[11:01:28.719]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.719]         }, condition = base::local({
[11:01:28.719]             c <- base::c
[11:01:28.719]             inherits <- base::inherits
[11:01:28.719]             invokeRestart <- base::invokeRestart
[11:01:28.719]             length <- base::length
[11:01:28.719]             list <- base::list
[11:01:28.719]             seq.int <- base::seq.int
[11:01:28.719]             signalCondition <- base::signalCondition
[11:01:28.719]             sys.calls <- base::sys.calls
[11:01:28.719]             `[[` <- base::`[[`
[11:01:28.719]             `+` <- base::`+`
[11:01:28.719]             `<<-` <- base::`<<-`
[11:01:28.719]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.719]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.719]                   3L)]
[11:01:28.719]             }
[11:01:28.719]             function(cond) {
[11:01:28.719]                 is_error <- inherits(cond, "error")
[11:01:28.719]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.719]                   NULL)
[11:01:28.719]                 if (is_error) {
[11:01:28.719]                   sessionInformation <- function() {
[11:01:28.719]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.719]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.719]                       search = base::search(), system = base::Sys.info())
[11:01:28.719]                   }
[11:01:28.719]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.719]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.719]                     cond$call), session = sessionInformation(), 
[11:01:28.719]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.719]                   signalCondition(cond)
[11:01:28.719]                 }
[11:01:28.719]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.719]                 "immediateCondition"))) {
[11:01:28.719]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.719]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.719]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.719]                   if (TRUE && !signal) {
[11:01:28.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.719]                     {
[11:01:28.719]                       inherits <- base::inherits
[11:01:28.719]                       invokeRestart <- base::invokeRestart
[11:01:28.719]                       is.null <- base::is.null
[11:01:28.719]                       muffled <- FALSE
[11:01:28.719]                       if (inherits(cond, "message")) {
[11:01:28.719]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.719]                         if (muffled) 
[11:01:28.719]                           invokeRestart("muffleMessage")
[11:01:28.719]                       }
[11:01:28.719]                       else if (inherits(cond, "warning")) {
[11:01:28.719]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.719]                         if (muffled) 
[11:01:28.719]                           invokeRestart("muffleWarning")
[11:01:28.719]                       }
[11:01:28.719]                       else if (inherits(cond, "condition")) {
[11:01:28.719]                         if (!is.null(pattern)) {
[11:01:28.719]                           computeRestarts <- base::computeRestarts
[11:01:28.719]                           grepl <- base::grepl
[11:01:28.719]                           restarts <- computeRestarts(cond)
[11:01:28.719]                           for (restart in restarts) {
[11:01:28.719]                             name <- restart$name
[11:01:28.719]                             if (is.null(name)) 
[11:01:28.719]                               next
[11:01:28.719]                             if (!grepl(pattern, name)) 
[11:01:28.719]                               next
[11:01:28.719]                             invokeRestart(restart)
[11:01:28.719]                             muffled <- TRUE
[11:01:28.719]                             break
[11:01:28.719]                           }
[11:01:28.719]                         }
[11:01:28.719]                       }
[11:01:28.719]                       invisible(muffled)
[11:01:28.719]                     }
[11:01:28.719]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.719]                   }
[11:01:28.719]                 }
[11:01:28.719]                 else {
[11:01:28.719]                   if (TRUE) {
[11:01:28.719]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.719]                     {
[11:01:28.719]                       inherits <- base::inherits
[11:01:28.719]                       invokeRestart <- base::invokeRestart
[11:01:28.719]                       is.null <- base::is.null
[11:01:28.719]                       muffled <- FALSE
[11:01:28.719]                       if (inherits(cond, "message")) {
[11:01:28.719]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.719]                         if (muffled) 
[11:01:28.719]                           invokeRestart("muffleMessage")
[11:01:28.719]                       }
[11:01:28.719]                       else if (inherits(cond, "warning")) {
[11:01:28.719]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.719]                         if (muffled) 
[11:01:28.719]                           invokeRestart("muffleWarning")
[11:01:28.719]                       }
[11:01:28.719]                       else if (inherits(cond, "condition")) {
[11:01:28.719]                         if (!is.null(pattern)) {
[11:01:28.719]                           computeRestarts <- base::computeRestarts
[11:01:28.719]                           grepl <- base::grepl
[11:01:28.719]                           restarts <- computeRestarts(cond)
[11:01:28.719]                           for (restart in restarts) {
[11:01:28.719]                             name <- restart$name
[11:01:28.719]                             if (is.null(name)) 
[11:01:28.719]                               next
[11:01:28.719]                             if (!grepl(pattern, name)) 
[11:01:28.719]                               next
[11:01:28.719]                             invokeRestart(restart)
[11:01:28.719]                             muffled <- TRUE
[11:01:28.719]                             break
[11:01:28.719]                           }
[11:01:28.719]                         }
[11:01:28.719]                       }
[11:01:28.719]                       invisible(muffled)
[11:01:28.719]                     }
[11:01:28.719]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.719]                   }
[11:01:28.719]                 }
[11:01:28.719]             }
[11:01:28.719]         }))
[11:01:28.719]     }, error = function(ex) {
[11:01:28.719]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.719]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.719]                 ...future.rng), started = ...future.startTime, 
[11:01:28.719]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.719]             version = "1.8"), class = "FutureResult")
[11:01:28.719]     }, finally = {
[11:01:28.719]         if (!identical(...future.workdir, getwd())) 
[11:01:28.719]             setwd(...future.workdir)
[11:01:28.719]         {
[11:01:28.719]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.719]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.719]             }
[11:01:28.719]             base::options(...future.oldOptions)
[11:01:28.719]             if (.Platform$OS.type == "windows") {
[11:01:28.719]                 old_names <- names(...future.oldEnvVars)
[11:01:28.719]                 envs <- base::Sys.getenv()
[11:01:28.719]                 names <- names(envs)
[11:01:28.719]                 common <- intersect(names, old_names)
[11:01:28.719]                 added <- setdiff(names, old_names)
[11:01:28.719]                 removed <- setdiff(old_names, names)
[11:01:28.719]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.719]                   envs[common]]
[11:01:28.719]                 NAMES <- toupper(changed)
[11:01:28.719]                 args <- list()
[11:01:28.719]                 for (kk in seq_along(NAMES)) {
[11:01:28.719]                   name <- changed[[kk]]
[11:01:28.719]                   NAME <- NAMES[[kk]]
[11:01:28.719]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.719]                     next
[11:01:28.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.719]                 }
[11:01:28.719]                 NAMES <- toupper(added)
[11:01:28.719]                 for (kk in seq_along(NAMES)) {
[11:01:28.719]                   name <- added[[kk]]
[11:01:28.719]                   NAME <- NAMES[[kk]]
[11:01:28.719]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.719]                     next
[11:01:28.719]                   args[[name]] <- ""
[11:01:28.719]                 }
[11:01:28.719]                 NAMES <- toupper(removed)
[11:01:28.719]                 for (kk in seq_along(NAMES)) {
[11:01:28.719]                   name <- removed[[kk]]
[11:01:28.719]                   NAME <- NAMES[[kk]]
[11:01:28.719]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.719]                     next
[11:01:28.719]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.719]                 }
[11:01:28.719]                 if (length(args) > 0) 
[11:01:28.719]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.719]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.719]             }
[11:01:28.719]             else {
[11:01:28.719]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.719]             }
[11:01:28.719]             {
[11:01:28.719]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.719]                   0L) {
[11:01:28.719]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.719]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.719]                   base::options(opts)
[11:01:28.719]                 }
[11:01:28.719]                 {
[11:01:28.719]                   {
[11:01:28.719]                     NULL
[11:01:28.719]                     RNGkind("Mersenne-Twister")
[11:01:28.719]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.719]                       inherits = FALSE)
[11:01:28.719]                   }
[11:01:28.719]                   options(future.plan = NULL)
[11:01:28.719]                   if (is.na(NA_character_)) 
[11:01:28.719]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.719]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.719]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.719]                     .init = FALSE)
[11:01:28.719]                 }
[11:01:28.719]             }
[11:01:28.719]         }
[11:01:28.719]     })
[11:01:28.719]     if (TRUE) {
[11:01:28.719]         base::sink(type = "output", split = FALSE)
[11:01:28.719]         if (TRUE) {
[11:01:28.719]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.719]         }
[11:01:28.719]         else {
[11:01:28.719]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.719]         }
[11:01:28.719]         base::close(...future.stdout)
[11:01:28.719]         ...future.stdout <- NULL
[11:01:28.719]     }
[11:01:28.719]     ...future.result$conditions <- ...future.conditions
[11:01:28.719]     ...future.result$finished <- base::Sys.time()
[11:01:28.719]     ...future.result
[11:01:28.719] }
[11:01:28.721] plan(): Setting new future strategy stack:
[11:01:28.721] List of future strategies:
[11:01:28.721] 1. sequential:
[11:01:28.721]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.721]    - tweaked: FALSE
[11:01:28.721]    - call: NULL
[11:01:28.721] plan(): nbrOfWorkers() = 1
[11:01:28.722] plan(): Setting new future strategy stack:
[11:01:28.722] List of future strategies:
[11:01:28.722] 1. sequential:
[11:01:28.722]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.722]    - tweaked: FALSE
[11:01:28.722]    - call: plan(strategy)
[11:01:28.723] plan(): nbrOfWorkers() = 1
[11:01:28.723] SequentialFuture started (and completed)
[11:01:28.723] - Launch lazy future ... done
[11:01:28.723] run() for ‘SequentialFuture’ ... done
[11:01:28.724] getGlobalsAndPackages() ...
[11:01:28.724] Searching for globals...
[11:01:28.725] - globals found: [1] ‘{’
[11:01:28.725] Searching for globals ... DONE
[11:01:28.725] Resolving globals: FALSE
[11:01:28.726] 
[11:01:28.726] 
[11:01:28.726] getGlobalsAndPackages() ... DONE
[11:01:28.726] run() for ‘Future’ ...
[11:01:28.726] - state: ‘created’
[11:01:28.726] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.727] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.727] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.727]   - Field: ‘label’
[11:01:28.727]   - Field: ‘local’
[11:01:28.727]   - Field: ‘owner’
[11:01:28.727]   - Field: ‘envir’
[11:01:28.727]   - Field: ‘packages’
[11:01:28.727]   - Field: ‘gc’
[11:01:28.727]   - Field: ‘conditions’
[11:01:28.727]   - Field: ‘expr’
[11:01:28.727]   - Field: ‘uuid’
[11:01:28.727]   - Field: ‘seed’
[11:01:28.728]   - Field: ‘version’
[11:01:28.728]   - Field: ‘result’
[11:01:28.728]   - Field: ‘asynchronous’
[11:01:28.728]   - Field: ‘calls’
[11:01:28.728]   - Field: ‘globals’
[11:01:28.728]   - Field: ‘stdout’
[11:01:28.728]   - Field: ‘earlySignal’
[11:01:28.728]   - Field: ‘lazy’
[11:01:28.728]   - Field: ‘state’
[11:01:28.728] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.728] - Launch lazy future ...
[11:01:28.729] Packages needed by the future expression (n = 0): <none>
[11:01:28.729] Packages needed by future strategies (n = 0): <none>
[11:01:28.729] {
[11:01:28.729]     {
[11:01:28.729]         {
[11:01:28.729]             ...future.startTime <- base::Sys.time()
[11:01:28.729]             {
[11:01:28.729]                 {
[11:01:28.729]                   {
[11:01:28.729]                     base::local({
[11:01:28.729]                       has_future <- base::requireNamespace("future", 
[11:01:28.729]                         quietly = TRUE)
[11:01:28.729]                       if (has_future) {
[11:01:28.729]                         ns <- base::getNamespace("future")
[11:01:28.729]                         version <- ns[[".package"]][["version"]]
[11:01:28.729]                         if (is.null(version)) 
[11:01:28.729]                           version <- utils::packageVersion("future")
[11:01:28.729]                       }
[11:01:28.729]                       else {
[11:01:28.729]                         version <- NULL
[11:01:28.729]                       }
[11:01:28.729]                       if (!has_future || version < "1.8.0") {
[11:01:28.729]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.729]                           "", base::R.version$version.string), 
[11:01:28.729]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.729]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.729]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.729]                             "release", "version")], collapse = " "), 
[11:01:28.729]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.729]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.729]                           info)
[11:01:28.729]                         info <- base::paste(info, collapse = "; ")
[11:01:28.729]                         if (!has_future) {
[11:01:28.729]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.729]                             info)
[11:01:28.729]                         }
[11:01:28.729]                         else {
[11:01:28.729]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.729]                             info, version)
[11:01:28.729]                         }
[11:01:28.729]                         base::stop(msg)
[11:01:28.729]                       }
[11:01:28.729]                     })
[11:01:28.729]                   }
[11:01:28.729]                   ...future.strategy.old <- future::plan("list")
[11:01:28.729]                   options(future.plan = NULL)
[11:01:28.729]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.729]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.729]                 }
[11:01:28.729]                 ...future.workdir <- getwd()
[11:01:28.729]             }
[11:01:28.729]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.729]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.729]         }
[11:01:28.729]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.729]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.729]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.729]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.729]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.729]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.729]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.729]             base::names(...future.oldOptions))
[11:01:28.729]     }
[11:01:28.729]     if (FALSE) {
[11:01:28.729]     }
[11:01:28.729]     else {
[11:01:28.729]         if (TRUE) {
[11:01:28.729]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.729]                 open = "w")
[11:01:28.729]         }
[11:01:28.729]         else {
[11:01:28.729]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.729]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.729]         }
[11:01:28.729]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.729]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.729]             base::sink(type = "output", split = FALSE)
[11:01:28.729]             base::close(...future.stdout)
[11:01:28.729]         }, add = TRUE)
[11:01:28.729]     }
[11:01:28.729]     ...future.frame <- base::sys.nframe()
[11:01:28.729]     ...future.conditions <- base::list()
[11:01:28.729]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.729]     if (FALSE) {
[11:01:28.729]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.729]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.729]     }
[11:01:28.729]     ...future.result <- base::tryCatch({
[11:01:28.729]         base::withCallingHandlers({
[11:01:28.729]             ...future.value <- base::withVisible(base::local({
[11:01:28.729]                 4
[11:01:28.729]             }))
[11:01:28.729]             future::FutureResult(value = ...future.value$value, 
[11:01:28.729]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.729]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.729]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.729]                     ...future.globalenv.names))
[11:01:28.729]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.729]         }, condition = base::local({
[11:01:28.729]             c <- base::c
[11:01:28.729]             inherits <- base::inherits
[11:01:28.729]             invokeRestart <- base::invokeRestart
[11:01:28.729]             length <- base::length
[11:01:28.729]             list <- base::list
[11:01:28.729]             seq.int <- base::seq.int
[11:01:28.729]             signalCondition <- base::signalCondition
[11:01:28.729]             sys.calls <- base::sys.calls
[11:01:28.729]             `[[` <- base::`[[`
[11:01:28.729]             `+` <- base::`+`
[11:01:28.729]             `<<-` <- base::`<<-`
[11:01:28.729]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.729]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.729]                   3L)]
[11:01:28.729]             }
[11:01:28.729]             function(cond) {
[11:01:28.729]                 is_error <- inherits(cond, "error")
[11:01:28.729]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.729]                   NULL)
[11:01:28.729]                 if (is_error) {
[11:01:28.729]                   sessionInformation <- function() {
[11:01:28.729]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.729]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.729]                       search = base::search(), system = base::Sys.info())
[11:01:28.729]                   }
[11:01:28.729]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.729]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.729]                     cond$call), session = sessionInformation(), 
[11:01:28.729]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.729]                   signalCondition(cond)
[11:01:28.729]                 }
[11:01:28.729]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.729]                 "immediateCondition"))) {
[11:01:28.729]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.729]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.729]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.729]                   if (TRUE && !signal) {
[11:01:28.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.729]                     {
[11:01:28.729]                       inherits <- base::inherits
[11:01:28.729]                       invokeRestart <- base::invokeRestart
[11:01:28.729]                       is.null <- base::is.null
[11:01:28.729]                       muffled <- FALSE
[11:01:28.729]                       if (inherits(cond, "message")) {
[11:01:28.729]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.729]                         if (muffled) 
[11:01:28.729]                           invokeRestart("muffleMessage")
[11:01:28.729]                       }
[11:01:28.729]                       else if (inherits(cond, "warning")) {
[11:01:28.729]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.729]                         if (muffled) 
[11:01:28.729]                           invokeRestart("muffleWarning")
[11:01:28.729]                       }
[11:01:28.729]                       else if (inherits(cond, "condition")) {
[11:01:28.729]                         if (!is.null(pattern)) {
[11:01:28.729]                           computeRestarts <- base::computeRestarts
[11:01:28.729]                           grepl <- base::grepl
[11:01:28.729]                           restarts <- computeRestarts(cond)
[11:01:28.729]                           for (restart in restarts) {
[11:01:28.729]                             name <- restart$name
[11:01:28.729]                             if (is.null(name)) 
[11:01:28.729]                               next
[11:01:28.729]                             if (!grepl(pattern, name)) 
[11:01:28.729]                               next
[11:01:28.729]                             invokeRestart(restart)
[11:01:28.729]                             muffled <- TRUE
[11:01:28.729]                             break
[11:01:28.729]                           }
[11:01:28.729]                         }
[11:01:28.729]                       }
[11:01:28.729]                       invisible(muffled)
[11:01:28.729]                     }
[11:01:28.729]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.729]                   }
[11:01:28.729]                 }
[11:01:28.729]                 else {
[11:01:28.729]                   if (TRUE) {
[11:01:28.729]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.729]                     {
[11:01:28.729]                       inherits <- base::inherits
[11:01:28.729]                       invokeRestart <- base::invokeRestart
[11:01:28.729]                       is.null <- base::is.null
[11:01:28.729]                       muffled <- FALSE
[11:01:28.729]                       if (inherits(cond, "message")) {
[11:01:28.729]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.729]                         if (muffled) 
[11:01:28.729]                           invokeRestart("muffleMessage")
[11:01:28.729]                       }
[11:01:28.729]                       else if (inherits(cond, "warning")) {
[11:01:28.729]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.729]                         if (muffled) 
[11:01:28.729]                           invokeRestart("muffleWarning")
[11:01:28.729]                       }
[11:01:28.729]                       else if (inherits(cond, "condition")) {
[11:01:28.729]                         if (!is.null(pattern)) {
[11:01:28.729]                           computeRestarts <- base::computeRestarts
[11:01:28.729]                           grepl <- base::grepl
[11:01:28.729]                           restarts <- computeRestarts(cond)
[11:01:28.729]                           for (restart in restarts) {
[11:01:28.729]                             name <- restart$name
[11:01:28.729]                             if (is.null(name)) 
[11:01:28.729]                               next
[11:01:28.729]                             if (!grepl(pattern, name)) 
[11:01:28.729]                               next
[11:01:28.729]                             invokeRestart(restart)
[11:01:28.729]                             muffled <- TRUE
[11:01:28.729]                             break
[11:01:28.729]                           }
[11:01:28.729]                         }
[11:01:28.729]                       }
[11:01:28.729]                       invisible(muffled)
[11:01:28.729]                     }
[11:01:28.729]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.729]                   }
[11:01:28.729]                 }
[11:01:28.729]             }
[11:01:28.729]         }))
[11:01:28.729]     }, error = function(ex) {
[11:01:28.729]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.729]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.729]                 ...future.rng), started = ...future.startTime, 
[11:01:28.729]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.729]             version = "1.8"), class = "FutureResult")
[11:01:28.729]     }, finally = {
[11:01:28.729]         if (!identical(...future.workdir, getwd())) 
[11:01:28.729]             setwd(...future.workdir)
[11:01:28.729]         {
[11:01:28.729]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.729]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.729]             }
[11:01:28.729]             base::options(...future.oldOptions)
[11:01:28.729]             if (.Platform$OS.type == "windows") {
[11:01:28.729]                 old_names <- names(...future.oldEnvVars)
[11:01:28.729]                 envs <- base::Sys.getenv()
[11:01:28.729]                 names <- names(envs)
[11:01:28.729]                 common <- intersect(names, old_names)
[11:01:28.729]                 added <- setdiff(names, old_names)
[11:01:28.729]                 removed <- setdiff(old_names, names)
[11:01:28.729]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.729]                   envs[common]]
[11:01:28.729]                 NAMES <- toupper(changed)
[11:01:28.729]                 args <- list()
[11:01:28.729]                 for (kk in seq_along(NAMES)) {
[11:01:28.729]                   name <- changed[[kk]]
[11:01:28.729]                   NAME <- NAMES[[kk]]
[11:01:28.729]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.729]                     next
[11:01:28.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.729]                 }
[11:01:28.729]                 NAMES <- toupper(added)
[11:01:28.729]                 for (kk in seq_along(NAMES)) {
[11:01:28.729]                   name <- added[[kk]]
[11:01:28.729]                   NAME <- NAMES[[kk]]
[11:01:28.729]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.729]                     next
[11:01:28.729]                   args[[name]] <- ""
[11:01:28.729]                 }
[11:01:28.729]                 NAMES <- toupper(removed)
[11:01:28.729]                 for (kk in seq_along(NAMES)) {
[11:01:28.729]                   name <- removed[[kk]]
[11:01:28.729]                   NAME <- NAMES[[kk]]
[11:01:28.729]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.729]                     next
[11:01:28.729]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.729]                 }
[11:01:28.729]                 if (length(args) > 0) 
[11:01:28.729]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.729]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.729]             }
[11:01:28.729]             else {
[11:01:28.729]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.729]             }
[11:01:28.729]             {
[11:01:28.729]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.729]                   0L) {
[11:01:28.729]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.729]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.729]                   base::options(opts)
[11:01:28.729]                 }
[11:01:28.729]                 {
[11:01:28.729]                   {
[11:01:28.729]                     NULL
[11:01:28.729]                     RNGkind("Mersenne-Twister")
[11:01:28.729]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.729]                       inherits = FALSE)
[11:01:28.729]                   }
[11:01:28.729]                   options(future.plan = NULL)
[11:01:28.729]                   if (is.na(NA_character_)) 
[11:01:28.729]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.729]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.729]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.729]                     .init = FALSE)
[11:01:28.729]                 }
[11:01:28.729]             }
[11:01:28.729]         }
[11:01:28.729]     })
[11:01:28.729]     if (TRUE) {
[11:01:28.729]         base::sink(type = "output", split = FALSE)
[11:01:28.729]         if (TRUE) {
[11:01:28.729]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.729]         }
[11:01:28.729]         else {
[11:01:28.729]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.729]         }
[11:01:28.729]         base::close(...future.stdout)
[11:01:28.729]         ...future.stdout <- NULL
[11:01:28.729]     }
[11:01:28.729]     ...future.result$conditions <- ...future.conditions
[11:01:28.729]     ...future.result$finished <- base::Sys.time()
[11:01:28.729]     ...future.result
[11:01:28.729] }
[11:01:28.731] plan(): Setting new future strategy stack:
[11:01:28.731] List of future strategies:
[11:01:28.731] 1. sequential:
[11:01:28.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.731]    - tweaked: FALSE
[11:01:28.731]    - call: NULL
[11:01:28.731] plan(): nbrOfWorkers() = 1
[11:01:28.733] plan(): Setting new future strategy stack:
[11:01:28.733] List of future strategies:
[11:01:28.733] 1. sequential:
[11:01:28.733]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.733]    - tweaked: FALSE
[11:01:28.733]    - call: plan(strategy)
[11:01:28.734] plan(): nbrOfWorkers() = 1
[11:01:28.734] SequentialFuture started (and completed)
[11:01:28.734] - Launch lazy future ... done
[11:01:28.734] run() for ‘SequentialFuture’ ... done
<environment: 0x55a9c490d8d8> 
<environment: 0x55a9c4f75a30> 
[11:01:28.735] resolved() for ‘SequentialFuture’ ...
[11:01:28.735] - state: ‘finished’
[11:01:28.735] - run: TRUE
[11:01:28.735] - result: ‘FutureResult’
[11:01:28.736] resolved() for ‘SequentialFuture’ ... done
[11:01:28.736] resolved() for ‘SequentialFuture’ ...
[11:01:28.736] - state: ‘finished’
[11:01:28.736] - run: TRUE
[11:01:28.736] - result: ‘FutureResult’
[11:01:28.736] resolved() for ‘SequentialFuture’ ... done
[11:01:28.736] resolved() for ‘SequentialFuture’ ...
[11:01:28.736] - state: ‘finished’
[11:01:28.736] - run: TRUE
[11:01:28.736] - result: ‘FutureResult’
[11:01:28.736] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:28.738] resolve() on environment ...
[11:01:28.738]  recursive: 0
[11:01:28.738]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:28.738] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.738] - nx: 4
[11:01:28.738] - relay: TRUE
[11:01:28.738] - stdout: TRUE
[11:01:28.739] - signal: TRUE
[11:01:28.739] - resignal: FALSE
[11:01:28.739] - force: TRUE
[11:01:28.739] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.739] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.739]  - until=2
[11:01:28.739]  - relaying element #2
[11:01:28.739] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.739] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.739] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.739]  length: 3 (resolved future 1)
[11:01:28.739] resolved() for ‘SequentialFuture’ ...
[11:01:28.739] - state: ‘finished’
[11:01:28.740] - run: TRUE
[11:01:28.740] - result: ‘FutureResult’
[11:01:28.740] resolved() for ‘SequentialFuture’ ... done
[11:01:28.740] Future #2
[11:01:28.740] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.740] - nx: 4
[11:01:28.740] - relay: TRUE
[11:01:28.740] - stdout: TRUE
[11:01:28.740] - signal: TRUE
[11:01:28.740] - resignal: FALSE
[11:01:28.740] - force: TRUE
[11:01:28.740] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.740] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.741]  - until=2
[11:01:28.741]  - relaying element #2
[11:01:28.741] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.741] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.741] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.741]  length: 2 (resolved future 2)
[11:01:28.741] resolved() for ‘SequentialFuture’ ...
[11:01:28.741] - state: ‘finished’
[11:01:28.741] - run: TRUE
[11:01:28.741] - result: ‘FutureResult’
[11:01:28.741] resolved() for ‘SequentialFuture’ ... done
[11:01:28.742] Future #3
[11:01:28.742] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.742] - nx: 4
[11:01:28.742] - relay: TRUE
[11:01:28.742] - stdout: TRUE
[11:01:28.742] - signal: TRUE
[11:01:28.742] - resignal: FALSE
[11:01:28.742] - force: TRUE
[11:01:28.742] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.742] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.742]  - until=3
[11:01:28.742]  - relaying element #3
[11:01:28.743] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.743] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.743] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.743]  length: 1 (resolved future 3)
[11:01:28.743] resolved() for ‘SequentialFuture’ ...
[11:01:28.743] - state: ‘finished’
[11:01:28.743] - run: TRUE
[11:01:28.743] - result: ‘FutureResult’
[11:01:28.743] resolved() for ‘SequentialFuture’ ... done
[11:01:28.743] Future #4
[11:01:28.743] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:28.744] - nx: 4
[11:01:28.744] - relay: TRUE
[11:01:28.744] - stdout: TRUE
[11:01:28.744] - signal: TRUE
[11:01:28.744] - resignal: FALSE
[11:01:28.744] - force: TRUE
[11:01:28.744] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.744] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.744]  - until=4
[11:01:28.744]  - relaying element #4
[11:01:28.744] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.744] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.744] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:28.745]  length: 0 (resolved future 4)
[11:01:28.745] Relaying remaining futures
[11:01:28.745] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.745] - nx: 4
[11:01:28.745] - relay: TRUE
[11:01:28.745] - stdout: TRUE
[11:01:28.745] - signal: TRUE
[11:01:28.745] - resignal: FALSE
[11:01:28.745] - force: TRUE
[11:01:28.745] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.745] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:28.745] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.746] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.746] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.746] resolve() on environment ... DONE
<environment: 0x55a9c4410280> 
Dimensions: c(1, 6)
[11:01:28.746] getGlobalsAndPackages() ...
[11:01:28.746] Searching for globals...
[11:01:28.746] 
[11:01:28.747] Searching for globals ... DONE
[11:01:28.747] - globals: [0] <none>
[11:01:28.747] getGlobalsAndPackages() ... DONE
[11:01:28.747] run() for ‘Future’ ...
[11:01:28.747] - state: ‘created’
[11:01:28.747] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.747] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.747] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.748]   - Field: ‘label’
[11:01:28.748]   - Field: ‘local’
[11:01:28.748]   - Field: ‘owner’
[11:01:28.748]   - Field: ‘envir’
[11:01:28.748]   - Field: ‘packages’
[11:01:28.748]   - Field: ‘gc’
[11:01:28.748]   - Field: ‘conditions’
[11:01:28.748]   - Field: ‘expr’
[11:01:28.748]   - Field: ‘uuid’
[11:01:28.748]   - Field: ‘seed’
[11:01:28.748]   - Field: ‘version’
[11:01:28.748]   - Field: ‘result’
[11:01:28.749]   - Field: ‘asynchronous’
[11:01:28.749]   - Field: ‘calls’
[11:01:28.749]   - Field: ‘globals’
[11:01:28.749]   - Field: ‘stdout’
[11:01:28.749]   - Field: ‘earlySignal’
[11:01:28.749]   - Field: ‘lazy’
[11:01:28.749]   - Field: ‘state’
[11:01:28.749] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.749] - Launch lazy future ...
[11:01:28.749] Packages needed by the future expression (n = 0): <none>
[11:01:28.749] Packages needed by future strategies (n = 0): <none>
[11:01:28.750] {
[11:01:28.750]     {
[11:01:28.750]         {
[11:01:28.750]             ...future.startTime <- base::Sys.time()
[11:01:28.750]             {
[11:01:28.750]                 {
[11:01:28.750]                   {
[11:01:28.750]                     base::local({
[11:01:28.750]                       has_future <- base::requireNamespace("future", 
[11:01:28.750]                         quietly = TRUE)
[11:01:28.750]                       if (has_future) {
[11:01:28.750]                         ns <- base::getNamespace("future")
[11:01:28.750]                         version <- ns[[".package"]][["version"]]
[11:01:28.750]                         if (is.null(version)) 
[11:01:28.750]                           version <- utils::packageVersion("future")
[11:01:28.750]                       }
[11:01:28.750]                       else {
[11:01:28.750]                         version <- NULL
[11:01:28.750]                       }
[11:01:28.750]                       if (!has_future || version < "1.8.0") {
[11:01:28.750]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.750]                           "", base::R.version$version.string), 
[11:01:28.750]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.750]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.750]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.750]                             "release", "version")], collapse = " "), 
[11:01:28.750]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.750]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.750]                           info)
[11:01:28.750]                         info <- base::paste(info, collapse = "; ")
[11:01:28.750]                         if (!has_future) {
[11:01:28.750]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.750]                             info)
[11:01:28.750]                         }
[11:01:28.750]                         else {
[11:01:28.750]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.750]                             info, version)
[11:01:28.750]                         }
[11:01:28.750]                         base::stop(msg)
[11:01:28.750]                       }
[11:01:28.750]                     })
[11:01:28.750]                   }
[11:01:28.750]                   ...future.strategy.old <- future::plan("list")
[11:01:28.750]                   options(future.plan = NULL)
[11:01:28.750]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.750]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.750]                 }
[11:01:28.750]                 ...future.workdir <- getwd()
[11:01:28.750]             }
[11:01:28.750]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.750]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.750]         }
[11:01:28.750]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.750]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.750]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.750]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.750]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.750]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.750]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.750]             base::names(...future.oldOptions))
[11:01:28.750]     }
[11:01:28.750]     if (FALSE) {
[11:01:28.750]     }
[11:01:28.750]     else {
[11:01:28.750]         if (TRUE) {
[11:01:28.750]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.750]                 open = "w")
[11:01:28.750]         }
[11:01:28.750]         else {
[11:01:28.750]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.750]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.750]         }
[11:01:28.750]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.750]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.750]             base::sink(type = "output", split = FALSE)
[11:01:28.750]             base::close(...future.stdout)
[11:01:28.750]         }, add = TRUE)
[11:01:28.750]     }
[11:01:28.750]     ...future.frame <- base::sys.nframe()
[11:01:28.750]     ...future.conditions <- base::list()
[11:01:28.750]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.750]     if (FALSE) {
[11:01:28.750]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.750]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.750]     }
[11:01:28.750]     ...future.result <- base::tryCatch({
[11:01:28.750]         base::withCallingHandlers({
[11:01:28.750]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.750]             future::FutureResult(value = ...future.value$value, 
[11:01:28.750]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.750]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.750]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.750]                     ...future.globalenv.names))
[11:01:28.750]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.750]         }, condition = base::local({
[11:01:28.750]             c <- base::c
[11:01:28.750]             inherits <- base::inherits
[11:01:28.750]             invokeRestart <- base::invokeRestart
[11:01:28.750]             length <- base::length
[11:01:28.750]             list <- base::list
[11:01:28.750]             seq.int <- base::seq.int
[11:01:28.750]             signalCondition <- base::signalCondition
[11:01:28.750]             sys.calls <- base::sys.calls
[11:01:28.750]             `[[` <- base::`[[`
[11:01:28.750]             `+` <- base::`+`
[11:01:28.750]             `<<-` <- base::`<<-`
[11:01:28.750]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.750]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.750]                   3L)]
[11:01:28.750]             }
[11:01:28.750]             function(cond) {
[11:01:28.750]                 is_error <- inherits(cond, "error")
[11:01:28.750]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.750]                   NULL)
[11:01:28.750]                 if (is_error) {
[11:01:28.750]                   sessionInformation <- function() {
[11:01:28.750]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.750]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.750]                       search = base::search(), system = base::Sys.info())
[11:01:28.750]                   }
[11:01:28.750]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.750]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.750]                     cond$call), session = sessionInformation(), 
[11:01:28.750]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.750]                   signalCondition(cond)
[11:01:28.750]                 }
[11:01:28.750]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.750]                 "immediateCondition"))) {
[11:01:28.750]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.750]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.750]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.750]                   if (TRUE && !signal) {
[11:01:28.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.750]                     {
[11:01:28.750]                       inherits <- base::inherits
[11:01:28.750]                       invokeRestart <- base::invokeRestart
[11:01:28.750]                       is.null <- base::is.null
[11:01:28.750]                       muffled <- FALSE
[11:01:28.750]                       if (inherits(cond, "message")) {
[11:01:28.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.750]                         if (muffled) 
[11:01:28.750]                           invokeRestart("muffleMessage")
[11:01:28.750]                       }
[11:01:28.750]                       else if (inherits(cond, "warning")) {
[11:01:28.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.750]                         if (muffled) 
[11:01:28.750]                           invokeRestart("muffleWarning")
[11:01:28.750]                       }
[11:01:28.750]                       else if (inherits(cond, "condition")) {
[11:01:28.750]                         if (!is.null(pattern)) {
[11:01:28.750]                           computeRestarts <- base::computeRestarts
[11:01:28.750]                           grepl <- base::grepl
[11:01:28.750]                           restarts <- computeRestarts(cond)
[11:01:28.750]                           for (restart in restarts) {
[11:01:28.750]                             name <- restart$name
[11:01:28.750]                             if (is.null(name)) 
[11:01:28.750]                               next
[11:01:28.750]                             if (!grepl(pattern, name)) 
[11:01:28.750]                               next
[11:01:28.750]                             invokeRestart(restart)
[11:01:28.750]                             muffled <- TRUE
[11:01:28.750]                             break
[11:01:28.750]                           }
[11:01:28.750]                         }
[11:01:28.750]                       }
[11:01:28.750]                       invisible(muffled)
[11:01:28.750]                     }
[11:01:28.750]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.750]                   }
[11:01:28.750]                 }
[11:01:28.750]                 else {
[11:01:28.750]                   if (TRUE) {
[11:01:28.750]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.750]                     {
[11:01:28.750]                       inherits <- base::inherits
[11:01:28.750]                       invokeRestart <- base::invokeRestart
[11:01:28.750]                       is.null <- base::is.null
[11:01:28.750]                       muffled <- FALSE
[11:01:28.750]                       if (inherits(cond, "message")) {
[11:01:28.750]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.750]                         if (muffled) 
[11:01:28.750]                           invokeRestart("muffleMessage")
[11:01:28.750]                       }
[11:01:28.750]                       else if (inherits(cond, "warning")) {
[11:01:28.750]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.750]                         if (muffled) 
[11:01:28.750]                           invokeRestart("muffleWarning")
[11:01:28.750]                       }
[11:01:28.750]                       else if (inherits(cond, "condition")) {
[11:01:28.750]                         if (!is.null(pattern)) {
[11:01:28.750]                           computeRestarts <- base::computeRestarts
[11:01:28.750]                           grepl <- base::grepl
[11:01:28.750]                           restarts <- computeRestarts(cond)
[11:01:28.750]                           for (restart in restarts) {
[11:01:28.750]                             name <- restart$name
[11:01:28.750]                             if (is.null(name)) 
[11:01:28.750]                               next
[11:01:28.750]                             if (!grepl(pattern, name)) 
[11:01:28.750]                               next
[11:01:28.750]                             invokeRestart(restart)
[11:01:28.750]                             muffled <- TRUE
[11:01:28.750]                             break
[11:01:28.750]                           }
[11:01:28.750]                         }
[11:01:28.750]                       }
[11:01:28.750]                       invisible(muffled)
[11:01:28.750]                     }
[11:01:28.750]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.750]                   }
[11:01:28.750]                 }
[11:01:28.750]             }
[11:01:28.750]         }))
[11:01:28.750]     }, error = function(ex) {
[11:01:28.750]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.750]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.750]                 ...future.rng), started = ...future.startTime, 
[11:01:28.750]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.750]             version = "1.8"), class = "FutureResult")
[11:01:28.750]     }, finally = {
[11:01:28.750]         if (!identical(...future.workdir, getwd())) 
[11:01:28.750]             setwd(...future.workdir)
[11:01:28.750]         {
[11:01:28.750]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.750]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.750]             }
[11:01:28.750]             base::options(...future.oldOptions)
[11:01:28.750]             if (.Platform$OS.type == "windows") {
[11:01:28.750]                 old_names <- names(...future.oldEnvVars)
[11:01:28.750]                 envs <- base::Sys.getenv()
[11:01:28.750]                 names <- names(envs)
[11:01:28.750]                 common <- intersect(names, old_names)
[11:01:28.750]                 added <- setdiff(names, old_names)
[11:01:28.750]                 removed <- setdiff(old_names, names)
[11:01:28.750]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.750]                   envs[common]]
[11:01:28.750]                 NAMES <- toupper(changed)
[11:01:28.750]                 args <- list()
[11:01:28.750]                 for (kk in seq_along(NAMES)) {
[11:01:28.750]                   name <- changed[[kk]]
[11:01:28.750]                   NAME <- NAMES[[kk]]
[11:01:28.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.750]                     next
[11:01:28.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.750]                 }
[11:01:28.750]                 NAMES <- toupper(added)
[11:01:28.750]                 for (kk in seq_along(NAMES)) {
[11:01:28.750]                   name <- added[[kk]]
[11:01:28.750]                   NAME <- NAMES[[kk]]
[11:01:28.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.750]                     next
[11:01:28.750]                   args[[name]] <- ""
[11:01:28.750]                 }
[11:01:28.750]                 NAMES <- toupper(removed)
[11:01:28.750]                 for (kk in seq_along(NAMES)) {
[11:01:28.750]                   name <- removed[[kk]]
[11:01:28.750]                   NAME <- NAMES[[kk]]
[11:01:28.750]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.750]                     next
[11:01:28.750]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.750]                 }
[11:01:28.750]                 if (length(args) > 0) 
[11:01:28.750]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.750]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.750]             }
[11:01:28.750]             else {
[11:01:28.750]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.750]             }
[11:01:28.750]             {
[11:01:28.750]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.750]                   0L) {
[11:01:28.750]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.750]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.750]                   base::options(opts)
[11:01:28.750]                 }
[11:01:28.750]                 {
[11:01:28.750]                   {
[11:01:28.750]                     NULL
[11:01:28.750]                     RNGkind("Mersenne-Twister")
[11:01:28.750]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.750]                       inherits = FALSE)
[11:01:28.750]                   }
[11:01:28.750]                   options(future.plan = NULL)
[11:01:28.750]                   if (is.na(NA_character_)) 
[11:01:28.750]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.750]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.750]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.750]                     .init = FALSE)
[11:01:28.750]                 }
[11:01:28.750]             }
[11:01:28.750]         }
[11:01:28.750]     })
[11:01:28.750]     if (TRUE) {
[11:01:28.750]         base::sink(type = "output", split = FALSE)
[11:01:28.750]         if (TRUE) {
[11:01:28.750]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.750]         }
[11:01:28.750]         else {
[11:01:28.750]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.750]         }
[11:01:28.750]         base::close(...future.stdout)
[11:01:28.750]         ...future.stdout <- NULL
[11:01:28.750]     }
[11:01:28.750]     ...future.result$conditions <- ...future.conditions
[11:01:28.750]     ...future.result$finished <- base::Sys.time()
[11:01:28.750]     ...future.result
[11:01:28.750] }
[11:01:28.751] plan(): Setting new future strategy stack:
[11:01:28.752] List of future strategies:
[11:01:28.752] 1. sequential:
[11:01:28.752]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.752]    - tweaked: FALSE
[11:01:28.752]    - call: NULL
[11:01:28.752] plan(): nbrOfWorkers() = 1
[11:01:28.753] plan(): Setting new future strategy stack:
[11:01:28.753] List of future strategies:
[11:01:28.753] 1. sequential:
[11:01:28.753]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.753]    - tweaked: FALSE
[11:01:28.753]    - call: plan(strategy)
[11:01:28.753] plan(): nbrOfWorkers() = 1
[11:01:28.753] SequentialFuture started (and completed)
[11:01:28.753] - Launch lazy future ... done
[11:01:28.753] run() for ‘SequentialFuture’ ... done
[11:01:28.754] getGlobalsAndPackages() ...
[11:01:28.754] Searching for globals...
[11:01:28.754] 
[11:01:28.754] Searching for globals ... DONE
[11:01:28.754] - globals: [0] <none>
[11:01:28.754] getGlobalsAndPackages() ... DONE
[11:01:28.754] run() for ‘Future’ ...
[11:01:28.754] - state: ‘created’
[11:01:28.755] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.755] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.755] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.755]   - Field: ‘label’
[11:01:28.755]   - Field: ‘local’
[11:01:28.755]   - Field: ‘owner’
[11:01:28.755]   - Field: ‘envir’
[11:01:28.755]   - Field: ‘packages’
[11:01:28.755]   - Field: ‘gc’
[11:01:28.755]   - Field: ‘conditions’
[11:01:28.756]   - Field: ‘expr’
[11:01:28.757]   - Field: ‘uuid’
[11:01:28.757]   - Field: ‘seed’
[11:01:28.757]   - Field: ‘version’
[11:01:28.757]   - Field: ‘result’
[11:01:28.757]   - Field: ‘asynchronous’
[11:01:28.757]   - Field: ‘calls’
[11:01:28.757]   - Field: ‘globals’
[11:01:28.757]   - Field: ‘stdout’
[11:01:28.757]   - Field: ‘earlySignal’
[11:01:28.757]   - Field: ‘lazy’
[11:01:28.757]   - Field: ‘state’
[11:01:28.757] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.758] - Launch lazy future ...
[11:01:28.758] Packages needed by the future expression (n = 0): <none>
[11:01:28.758] Packages needed by future strategies (n = 0): <none>
[11:01:28.758] {
[11:01:28.758]     {
[11:01:28.758]         {
[11:01:28.758]             ...future.startTime <- base::Sys.time()
[11:01:28.758]             {
[11:01:28.758]                 {
[11:01:28.758]                   {
[11:01:28.758]                     base::local({
[11:01:28.758]                       has_future <- base::requireNamespace("future", 
[11:01:28.758]                         quietly = TRUE)
[11:01:28.758]                       if (has_future) {
[11:01:28.758]                         ns <- base::getNamespace("future")
[11:01:28.758]                         version <- ns[[".package"]][["version"]]
[11:01:28.758]                         if (is.null(version)) 
[11:01:28.758]                           version <- utils::packageVersion("future")
[11:01:28.758]                       }
[11:01:28.758]                       else {
[11:01:28.758]                         version <- NULL
[11:01:28.758]                       }
[11:01:28.758]                       if (!has_future || version < "1.8.0") {
[11:01:28.758]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.758]                           "", base::R.version$version.string), 
[11:01:28.758]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.758]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.758]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.758]                             "release", "version")], collapse = " "), 
[11:01:28.758]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.758]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.758]                           info)
[11:01:28.758]                         info <- base::paste(info, collapse = "; ")
[11:01:28.758]                         if (!has_future) {
[11:01:28.758]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.758]                             info)
[11:01:28.758]                         }
[11:01:28.758]                         else {
[11:01:28.758]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.758]                             info, version)
[11:01:28.758]                         }
[11:01:28.758]                         base::stop(msg)
[11:01:28.758]                       }
[11:01:28.758]                     })
[11:01:28.758]                   }
[11:01:28.758]                   ...future.strategy.old <- future::plan("list")
[11:01:28.758]                   options(future.plan = NULL)
[11:01:28.758]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.758]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.758]                 }
[11:01:28.758]                 ...future.workdir <- getwd()
[11:01:28.758]             }
[11:01:28.758]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.758]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.758]         }
[11:01:28.758]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.758]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.758]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.758]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.758]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.758]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.758]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.758]             base::names(...future.oldOptions))
[11:01:28.758]     }
[11:01:28.758]     if (FALSE) {
[11:01:28.758]     }
[11:01:28.758]     else {
[11:01:28.758]         if (TRUE) {
[11:01:28.758]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.758]                 open = "w")
[11:01:28.758]         }
[11:01:28.758]         else {
[11:01:28.758]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.758]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.758]         }
[11:01:28.758]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.758]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.758]             base::sink(type = "output", split = FALSE)
[11:01:28.758]             base::close(...future.stdout)
[11:01:28.758]         }, add = TRUE)
[11:01:28.758]     }
[11:01:28.758]     ...future.frame <- base::sys.nframe()
[11:01:28.758]     ...future.conditions <- base::list()
[11:01:28.758]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.758]     if (FALSE) {
[11:01:28.758]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.758]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.758]     }
[11:01:28.758]     ...future.result <- base::tryCatch({
[11:01:28.758]         base::withCallingHandlers({
[11:01:28.758]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.758]             future::FutureResult(value = ...future.value$value, 
[11:01:28.758]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.758]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.758]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.758]                     ...future.globalenv.names))
[11:01:28.758]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.758]         }, condition = base::local({
[11:01:28.758]             c <- base::c
[11:01:28.758]             inherits <- base::inherits
[11:01:28.758]             invokeRestart <- base::invokeRestart
[11:01:28.758]             length <- base::length
[11:01:28.758]             list <- base::list
[11:01:28.758]             seq.int <- base::seq.int
[11:01:28.758]             signalCondition <- base::signalCondition
[11:01:28.758]             sys.calls <- base::sys.calls
[11:01:28.758]             `[[` <- base::`[[`
[11:01:28.758]             `+` <- base::`+`
[11:01:28.758]             `<<-` <- base::`<<-`
[11:01:28.758]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.758]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.758]                   3L)]
[11:01:28.758]             }
[11:01:28.758]             function(cond) {
[11:01:28.758]                 is_error <- inherits(cond, "error")
[11:01:28.758]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.758]                   NULL)
[11:01:28.758]                 if (is_error) {
[11:01:28.758]                   sessionInformation <- function() {
[11:01:28.758]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.758]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.758]                       search = base::search(), system = base::Sys.info())
[11:01:28.758]                   }
[11:01:28.758]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.758]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.758]                     cond$call), session = sessionInformation(), 
[11:01:28.758]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.758]                   signalCondition(cond)
[11:01:28.758]                 }
[11:01:28.758]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.758]                 "immediateCondition"))) {
[11:01:28.758]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.758]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.758]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.758]                   if (TRUE && !signal) {
[11:01:28.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.758]                     {
[11:01:28.758]                       inherits <- base::inherits
[11:01:28.758]                       invokeRestart <- base::invokeRestart
[11:01:28.758]                       is.null <- base::is.null
[11:01:28.758]                       muffled <- FALSE
[11:01:28.758]                       if (inherits(cond, "message")) {
[11:01:28.758]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.758]                         if (muffled) 
[11:01:28.758]                           invokeRestart("muffleMessage")
[11:01:28.758]                       }
[11:01:28.758]                       else if (inherits(cond, "warning")) {
[11:01:28.758]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.758]                         if (muffled) 
[11:01:28.758]                           invokeRestart("muffleWarning")
[11:01:28.758]                       }
[11:01:28.758]                       else if (inherits(cond, "condition")) {
[11:01:28.758]                         if (!is.null(pattern)) {
[11:01:28.758]                           computeRestarts <- base::computeRestarts
[11:01:28.758]                           grepl <- base::grepl
[11:01:28.758]                           restarts <- computeRestarts(cond)
[11:01:28.758]                           for (restart in restarts) {
[11:01:28.758]                             name <- restart$name
[11:01:28.758]                             if (is.null(name)) 
[11:01:28.758]                               next
[11:01:28.758]                             if (!grepl(pattern, name)) 
[11:01:28.758]                               next
[11:01:28.758]                             invokeRestart(restart)
[11:01:28.758]                             muffled <- TRUE
[11:01:28.758]                             break
[11:01:28.758]                           }
[11:01:28.758]                         }
[11:01:28.758]                       }
[11:01:28.758]                       invisible(muffled)
[11:01:28.758]                     }
[11:01:28.758]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.758]                   }
[11:01:28.758]                 }
[11:01:28.758]                 else {
[11:01:28.758]                   if (TRUE) {
[11:01:28.758]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.758]                     {
[11:01:28.758]                       inherits <- base::inherits
[11:01:28.758]                       invokeRestart <- base::invokeRestart
[11:01:28.758]                       is.null <- base::is.null
[11:01:28.758]                       muffled <- FALSE
[11:01:28.758]                       if (inherits(cond, "message")) {
[11:01:28.758]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.758]                         if (muffled) 
[11:01:28.758]                           invokeRestart("muffleMessage")
[11:01:28.758]                       }
[11:01:28.758]                       else if (inherits(cond, "warning")) {
[11:01:28.758]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.758]                         if (muffled) 
[11:01:28.758]                           invokeRestart("muffleWarning")
[11:01:28.758]                       }
[11:01:28.758]                       else if (inherits(cond, "condition")) {
[11:01:28.758]                         if (!is.null(pattern)) {
[11:01:28.758]                           computeRestarts <- base::computeRestarts
[11:01:28.758]                           grepl <- base::grepl
[11:01:28.758]                           restarts <- computeRestarts(cond)
[11:01:28.758]                           for (restart in restarts) {
[11:01:28.758]                             name <- restart$name
[11:01:28.758]                             if (is.null(name)) 
[11:01:28.758]                               next
[11:01:28.758]                             if (!grepl(pattern, name)) 
[11:01:28.758]                               next
[11:01:28.758]                             invokeRestart(restart)
[11:01:28.758]                             muffled <- TRUE
[11:01:28.758]                             break
[11:01:28.758]                           }
[11:01:28.758]                         }
[11:01:28.758]                       }
[11:01:28.758]                       invisible(muffled)
[11:01:28.758]                     }
[11:01:28.758]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.758]                   }
[11:01:28.758]                 }
[11:01:28.758]             }
[11:01:28.758]         }))
[11:01:28.758]     }, error = function(ex) {
[11:01:28.758]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.758]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.758]                 ...future.rng), started = ...future.startTime, 
[11:01:28.758]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.758]             version = "1.8"), class = "FutureResult")
[11:01:28.758]     }, finally = {
[11:01:28.758]         if (!identical(...future.workdir, getwd())) 
[11:01:28.758]             setwd(...future.workdir)
[11:01:28.758]         {
[11:01:28.758]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.758]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.758]             }
[11:01:28.758]             base::options(...future.oldOptions)
[11:01:28.758]             if (.Platform$OS.type == "windows") {
[11:01:28.758]                 old_names <- names(...future.oldEnvVars)
[11:01:28.758]                 envs <- base::Sys.getenv()
[11:01:28.758]                 names <- names(envs)
[11:01:28.758]                 common <- intersect(names, old_names)
[11:01:28.758]                 added <- setdiff(names, old_names)
[11:01:28.758]                 removed <- setdiff(old_names, names)
[11:01:28.758]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.758]                   envs[common]]
[11:01:28.758]                 NAMES <- toupper(changed)
[11:01:28.758]                 args <- list()
[11:01:28.758]                 for (kk in seq_along(NAMES)) {
[11:01:28.758]                   name <- changed[[kk]]
[11:01:28.758]                   NAME <- NAMES[[kk]]
[11:01:28.758]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.758]                     next
[11:01:28.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.758]                 }
[11:01:28.758]                 NAMES <- toupper(added)
[11:01:28.758]                 for (kk in seq_along(NAMES)) {
[11:01:28.758]                   name <- added[[kk]]
[11:01:28.758]                   NAME <- NAMES[[kk]]
[11:01:28.758]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.758]                     next
[11:01:28.758]                   args[[name]] <- ""
[11:01:28.758]                 }
[11:01:28.758]                 NAMES <- toupper(removed)
[11:01:28.758]                 for (kk in seq_along(NAMES)) {
[11:01:28.758]                   name <- removed[[kk]]
[11:01:28.758]                   NAME <- NAMES[[kk]]
[11:01:28.758]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.758]                     next
[11:01:28.758]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.758]                 }
[11:01:28.758]                 if (length(args) > 0) 
[11:01:28.758]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.758]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.758]             }
[11:01:28.758]             else {
[11:01:28.758]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.758]             }
[11:01:28.758]             {
[11:01:28.758]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.758]                   0L) {
[11:01:28.758]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.758]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.758]                   base::options(opts)
[11:01:28.758]                 }
[11:01:28.758]                 {
[11:01:28.758]                   {
[11:01:28.758]                     NULL
[11:01:28.758]                     RNGkind("Mersenne-Twister")
[11:01:28.758]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.758]                       inherits = FALSE)
[11:01:28.758]                   }
[11:01:28.758]                   options(future.plan = NULL)
[11:01:28.758]                   if (is.na(NA_character_)) 
[11:01:28.758]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.758]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.758]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.758]                     .init = FALSE)
[11:01:28.758]                 }
[11:01:28.758]             }
[11:01:28.758]         }
[11:01:28.758]     })
[11:01:28.758]     if (TRUE) {
[11:01:28.758]         base::sink(type = "output", split = FALSE)
[11:01:28.758]         if (TRUE) {
[11:01:28.758]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.758]         }
[11:01:28.758]         else {
[11:01:28.758]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.758]         }
[11:01:28.758]         base::close(...future.stdout)
[11:01:28.758]         ...future.stdout <- NULL
[11:01:28.758]     }
[11:01:28.758]     ...future.result$conditions <- ...future.conditions
[11:01:28.758]     ...future.result$finished <- base::Sys.time()
[11:01:28.758]     ...future.result
[11:01:28.758] }
[11:01:28.760] plan(): Setting new future strategy stack:
[11:01:28.760] List of future strategies:
[11:01:28.760] 1. sequential:
[11:01:28.760]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.760]    - tweaked: FALSE
[11:01:28.760]    - call: NULL
[11:01:28.760] plan(): nbrOfWorkers() = 1
[11:01:28.761] plan(): Setting new future strategy stack:
[11:01:28.761] List of future strategies:
[11:01:28.761] 1. sequential:
[11:01:28.761]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.761]    - tweaked: FALSE
[11:01:28.761]    - call: plan(strategy)
[11:01:28.762] plan(): nbrOfWorkers() = 1
[11:01:28.762] SequentialFuture started (and completed)
[11:01:28.762] - Launch lazy future ... done
[11:01:28.762] run() for ‘SequentialFuture’ ... done
[11:01:28.762] getGlobalsAndPackages() ...
[11:01:28.762] Searching for globals...
[11:01:28.763] - globals found: [1] ‘{’
[11:01:28.763] Searching for globals ... DONE
[11:01:28.763] Resolving globals: FALSE
[11:01:28.763] 
[11:01:28.763] 
[11:01:28.763] getGlobalsAndPackages() ... DONE
[11:01:28.764] run() for ‘Future’ ...
[11:01:28.764] - state: ‘created’
[11:01:28.764] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.764] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.764] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.764]   - Field: ‘label’
[11:01:28.764]   - Field: ‘local’
[11:01:28.764]   - Field: ‘owner’
[11:01:28.764]   - Field: ‘envir’
[11:01:28.765]   - Field: ‘packages’
[11:01:28.765]   - Field: ‘gc’
[11:01:28.765]   - Field: ‘conditions’
[11:01:28.765]   - Field: ‘expr’
[11:01:28.765]   - Field: ‘uuid’
[11:01:28.765]   - Field: ‘seed’
[11:01:28.765]   - Field: ‘version’
[11:01:28.765]   - Field: ‘result’
[11:01:28.765]   - Field: ‘asynchronous’
[11:01:28.765]   - Field: ‘calls’
[11:01:28.765]   - Field: ‘globals’
[11:01:28.765]   - Field: ‘stdout’
[11:01:28.766]   - Field: ‘earlySignal’
[11:01:28.766]   - Field: ‘lazy’
[11:01:28.766]   - Field: ‘state’
[11:01:28.766] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.766] - Launch lazy future ...
[11:01:28.766] Packages needed by the future expression (n = 0): <none>
[11:01:28.766] Packages needed by future strategies (n = 0): <none>
[11:01:28.766] {
[11:01:28.766]     {
[11:01:28.766]         {
[11:01:28.766]             ...future.startTime <- base::Sys.time()
[11:01:28.766]             {
[11:01:28.766]                 {
[11:01:28.766]                   {
[11:01:28.766]                     base::local({
[11:01:28.766]                       has_future <- base::requireNamespace("future", 
[11:01:28.766]                         quietly = TRUE)
[11:01:28.766]                       if (has_future) {
[11:01:28.766]                         ns <- base::getNamespace("future")
[11:01:28.766]                         version <- ns[[".package"]][["version"]]
[11:01:28.766]                         if (is.null(version)) 
[11:01:28.766]                           version <- utils::packageVersion("future")
[11:01:28.766]                       }
[11:01:28.766]                       else {
[11:01:28.766]                         version <- NULL
[11:01:28.766]                       }
[11:01:28.766]                       if (!has_future || version < "1.8.0") {
[11:01:28.766]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.766]                           "", base::R.version$version.string), 
[11:01:28.766]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.766]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.766]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.766]                             "release", "version")], collapse = " "), 
[11:01:28.766]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.766]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.766]                           info)
[11:01:28.766]                         info <- base::paste(info, collapse = "; ")
[11:01:28.766]                         if (!has_future) {
[11:01:28.766]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.766]                             info)
[11:01:28.766]                         }
[11:01:28.766]                         else {
[11:01:28.766]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.766]                             info, version)
[11:01:28.766]                         }
[11:01:28.766]                         base::stop(msg)
[11:01:28.766]                       }
[11:01:28.766]                     })
[11:01:28.766]                   }
[11:01:28.766]                   ...future.strategy.old <- future::plan("list")
[11:01:28.766]                   options(future.plan = NULL)
[11:01:28.766]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.766]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.766]                 }
[11:01:28.766]                 ...future.workdir <- getwd()
[11:01:28.766]             }
[11:01:28.766]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.766]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.766]         }
[11:01:28.766]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.766]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.766]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.766]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.766]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.766]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.766]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.766]             base::names(...future.oldOptions))
[11:01:28.766]     }
[11:01:28.766]     if (FALSE) {
[11:01:28.766]     }
[11:01:28.766]     else {
[11:01:28.766]         if (TRUE) {
[11:01:28.766]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.766]                 open = "w")
[11:01:28.766]         }
[11:01:28.766]         else {
[11:01:28.766]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.766]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.766]         }
[11:01:28.766]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.766]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.766]             base::sink(type = "output", split = FALSE)
[11:01:28.766]             base::close(...future.stdout)
[11:01:28.766]         }, add = TRUE)
[11:01:28.766]     }
[11:01:28.766]     ...future.frame <- base::sys.nframe()
[11:01:28.766]     ...future.conditions <- base::list()
[11:01:28.766]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.766]     if (FALSE) {
[11:01:28.766]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.766]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.766]     }
[11:01:28.766]     ...future.result <- base::tryCatch({
[11:01:28.766]         base::withCallingHandlers({
[11:01:28.766]             ...future.value <- base::withVisible(base::local({
[11:01:28.766]                 4
[11:01:28.766]             }))
[11:01:28.766]             future::FutureResult(value = ...future.value$value, 
[11:01:28.766]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.766]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.766]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.766]                     ...future.globalenv.names))
[11:01:28.766]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.766]         }, condition = base::local({
[11:01:28.766]             c <- base::c
[11:01:28.766]             inherits <- base::inherits
[11:01:28.766]             invokeRestart <- base::invokeRestart
[11:01:28.766]             length <- base::length
[11:01:28.766]             list <- base::list
[11:01:28.766]             seq.int <- base::seq.int
[11:01:28.766]             signalCondition <- base::signalCondition
[11:01:28.766]             sys.calls <- base::sys.calls
[11:01:28.766]             `[[` <- base::`[[`
[11:01:28.766]             `+` <- base::`+`
[11:01:28.766]             `<<-` <- base::`<<-`
[11:01:28.766]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.766]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.766]                   3L)]
[11:01:28.766]             }
[11:01:28.766]             function(cond) {
[11:01:28.766]                 is_error <- inherits(cond, "error")
[11:01:28.766]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.766]                   NULL)
[11:01:28.766]                 if (is_error) {
[11:01:28.766]                   sessionInformation <- function() {
[11:01:28.766]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.766]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.766]                       search = base::search(), system = base::Sys.info())
[11:01:28.766]                   }
[11:01:28.766]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.766]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.766]                     cond$call), session = sessionInformation(), 
[11:01:28.766]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.766]                   signalCondition(cond)
[11:01:28.766]                 }
[11:01:28.766]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.766]                 "immediateCondition"))) {
[11:01:28.766]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.766]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.766]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.766]                   if (TRUE && !signal) {
[11:01:28.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.766]                     {
[11:01:28.766]                       inherits <- base::inherits
[11:01:28.766]                       invokeRestart <- base::invokeRestart
[11:01:28.766]                       is.null <- base::is.null
[11:01:28.766]                       muffled <- FALSE
[11:01:28.766]                       if (inherits(cond, "message")) {
[11:01:28.766]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.766]                         if (muffled) 
[11:01:28.766]                           invokeRestart("muffleMessage")
[11:01:28.766]                       }
[11:01:28.766]                       else if (inherits(cond, "warning")) {
[11:01:28.766]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.766]                         if (muffled) 
[11:01:28.766]                           invokeRestart("muffleWarning")
[11:01:28.766]                       }
[11:01:28.766]                       else if (inherits(cond, "condition")) {
[11:01:28.766]                         if (!is.null(pattern)) {
[11:01:28.766]                           computeRestarts <- base::computeRestarts
[11:01:28.766]                           grepl <- base::grepl
[11:01:28.766]                           restarts <- computeRestarts(cond)
[11:01:28.766]                           for (restart in restarts) {
[11:01:28.766]                             name <- restart$name
[11:01:28.766]                             if (is.null(name)) 
[11:01:28.766]                               next
[11:01:28.766]                             if (!grepl(pattern, name)) 
[11:01:28.766]                               next
[11:01:28.766]                             invokeRestart(restart)
[11:01:28.766]                             muffled <- TRUE
[11:01:28.766]                             break
[11:01:28.766]                           }
[11:01:28.766]                         }
[11:01:28.766]                       }
[11:01:28.766]                       invisible(muffled)
[11:01:28.766]                     }
[11:01:28.766]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.766]                   }
[11:01:28.766]                 }
[11:01:28.766]                 else {
[11:01:28.766]                   if (TRUE) {
[11:01:28.766]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.766]                     {
[11:01:28.766]                       inherits <- base::inherits
[11:01:28.766]                       invokeRestart <- base::invokeRestart
[11:01:28.766]                       is.null <- base::is.null
[11:01:28.766]                       muffled <- FALSE
[11:01:28.766]                       if (inherits(cond, "message")) {
[11:01:28.766]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.766]                         if (muffled) 
[11:01:28.766]                           invokeRestart("muffleMessage")
[11:01:28.766]                       }
[11:01:28.766]                       else if (inherits(cond, "warning")) {
[11:01:28.766]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.766]                         if (muffled) 
[11:01:28.766]                           invokeRestart("muffleWarning")
[11:01:28.766]                       }
[11:01:28.766]                       else if (inherits(cond, "condition")) {
[11:01:28.766]                         if (!is.null(pattern)) {
[11:01:28.766]                           computeRestarts <- base::computeRestarts
[11:01:28.766]                           grepl <- base::grepl
[11:01:28.766]                           restarts <- computeRestarts(cond)
[11:01:28.766]                           for (restart in restarts) {
[11:01:28.766]                             name <- restart$name
[11:01:28.766]                             if (is.null(name)) 
[11:01:28.766]                               next
[11:01:28.766]                             if (!grepl(pattern, name)) 
[11:01:28.766]                               next
[11:01:28.766]                             invokeRestart(restart)
[11:01:28.766]                             muffled <- TRUE
[11:01:28.766]                             break
[11:01:28.766]                           }
[11:01:28.766]                         }
[11:01:28.766]                       }
[11:01:28.766]                       invisible(muffled)
[11:01:28.766]                     }
[11:01:28.766]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.766]                   }
[11:01:28.766]                 }
[11:01:28.766]             }
[11:01:28.766]         }))
[11:01:28.766]     }, error = function(ex) {
[11:01:28.766]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.766]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.766]                 ...future.rng), started = ...future.startTime, 
[11:01:28.766]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.766]             version = "1.8"), class = "FutureResult")
[11:01:28.766]     }, finally = {
[11:01:28.766]         if (!identical(...future.workdir, getwd())) 
[11:01:28.766]             setwd(...future.workdir)
[11:01:28.766]         {
[11:01:28.766]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.766]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.766]             }
[11:01:28.766]             base::options(...future.oldOptions)
[11:01:28.766]             if (.Platform$OS.type == "windows") {
[11:01:28.766]                 old_names <- names(...future.oldEnvVars)
[11:01:28.766]                 envs <- base::Sys.getenv()
[11:01:28.766]                 names <- names(envs)
[11:01:28.766]                 common <- intersect(names, old_names)
[11:01:28.766]                 added <- setdiff(names, old_names)
[11:01:28.766]                 removed <- setdiff(old_names, names)
[11:01:28.766]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.766]                   envs[common]]
[11:01:28.766]                 NAMES <- toupper(changed)
[11:01:28.766]                 args <- list()
[11:01:28.766]                 for (kk in seq_along(NAMES)) {
[11:01:28.766]                   name <- changed[[kk]]
[11:01:28.766]                   NAME <- NAMES[[kk]]
[11:01:28.766]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.766]                     next
[11:01:28.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.766]                 }
[11:01:28.766]                 NAMES <- toupper(added)
[11:01:28.766]                 for (kk in seq_along(NAMES)) {
[11:01:28.766]                   name <- added[[kk]]
[11:01:28.766]                   NAME <- NAMES[[kk]]
[11:01:28.766]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.766]                     next
[11:01:28.766]                   args[[name]] <- ""
[11:01:28.766]                 }
[11:01:28.766]                 NAMES <- toupper(removed)
[11:01:28.766]                 for (kk in seq_along(NAMES)) {
[11:01:28.766]                   name <- removed[[kk]]
[11:01:28.766]                   NAME <- NAMES[[kk]]
[11:01:28.766]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.766]                     next
[11:01:28.766]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.766]                 }
[11:01:28.766]                 if (length(args) > 0) 
[11:01:28.766]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.766]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.766]             }
[11:01:28.766]             else {
[11:01:28.766]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.766]             }
[11:01:28.766]             {
[11:01:28.766]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.766]                   0L) {
[11:01:28.766]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.766]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.766]                   base::options(opts)
[11:01:28.766]                 }
[11:01:28.766]                 {
[11:01:28.766]                   {
[11:01:28.766]                     NULL
[11:01:28.766]                     RNGkind("Mersenne-Twister")
[11:01:28.766]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.766]                       inherits = FALSE)
[11:01:28.766]                   }
[11:01:28.766]                   options(future.plan = NULL)
[11:01:28.766]                   if (is.na(NA_character_)) 
[11:01:28.766]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.766]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.766]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.766]                     .init = FALSE)
[11:01:28.766]                 }
[11:01:28.766]             }
[11:01:28.766]         }
[11:01:28.766]     })
[11:01:28.766]     if (TRUE) {
[11:01:28.766]         base::sink(type = "output", split = FALSE)
[11:01:28.766]         if (TRUE) {
[11:01:28.766]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.766]         }
[11:01:28.766]         else {
[11:01:28.766]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.766]         }
[11:01:28.766]         base::close(...future.stdout)
[11:01:28.766]         ...future.stdout <- NULL
[11:01:28.766]     }
[11:01:28.766]     ...future.result$conditions <- ...future.conditions
[11:01:28.766]     ...future.result$finished <- base::Sys.time()
[11:01:28.766]     ...future.result
[11:01:28.766] }
[11:01:28.768] plan(): Setting new future strategy stack:
[11:01:28.768] List of future strategies:
[11:01:28.768] 1. sequential:
[11:01:28.768]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.768]    - tweaked: FALSE
[11:01:28.768]    - call: NULL
[11:01:28.769] plan(): nbrOfWorkers() = 1
[11:01:28.769] plan(): Setting new future strategy stack:
[11:01:28.769] List of future strategies:
[11:01:28.769] 1. sequential:
[11:01:28.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.769]    - tweaked: FALSE
[11:01:28.769]    - call: plan(strategy)
[11:01:28.770] plan(): nbrOfWorkers() = 1
[11:01:28.770] SequentialFuture started (and completed)
[11:01:28.770] - Launch lazy future ... done
[11:01:28.770] run() for ‘SequentialFuture’ ... done
<environment: 0x55a9c66d5078> 
<environment: 0x55a9c652c248> 
[11:01:28.771] resolved() for ‘SequentialFuture’ ...
[11:01:28.771] - state: ‘finished’
[11:01:28.771] - run: TRUE
[11:01:28.772] - result: ‘FutureResult’
[11:01:28.772] resolved() for ‘SequentialFuture’ ... done
[11:01:28.772] resolved() for ‘SequentialFuture’ ...
[11:01:28.772] - state: ‘finished’
[11:01:28.772] - run: TRUE
[11:01:28.772] - result: ‘FutureResult’
[11:01:28.772] resolved() for ‘SequentialFuture’ ... done
[11:01:28.772] resolved() for ‘SequentialFuture’ ...
[11:01:28.772] - state: ‘finished’
[11:01:28.772] - run: TRUE
[11:01:28.772] - result: ‘FutureResult’
[11:01:28.772] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:28.773] resolve() on environment ...
[11:01:28.773]  recursive: 0
[11:01:28.774]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:28.774] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.774] - nx: 4
[11:01:28.774] - relay: TRUE
[11:01:28.774] - stdout: TRUE
[11:01:28.774] - signal: TRUE
[11:01:28.774] - resignal: FALSE
[11:01:28.774] - force: TRUE
[11:01:28.775] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.775] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.775]  - until=2
[11:01:28.775]  - relaying element #2
[11:01:28.775] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.775] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.775] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.775]  length: 3 (resolved future 1)
[11:01:28.775] resolved() for ‘SequentialFuture’ ...
[11:01:28.775] - state: ‘finished’
[11:01:28.775] - run: TRUE
[11:01:28.775] - result: ‘FutureResult’
[11:01:28.776] resolved() for ‘SequentialFuture’ ... done
[11:01:28.776] Future #2
[11:01:28.776] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.776] - nx: 4
[11:01:28.776] - relay: TRUE
[11:01:28.776] - stdout: TRUE
[11:01:28.776] - signal: TRUE
[11:01:28.776] - resignal: FALSE
[11:01:28.776] - force: TRUE
[11:01:28.776] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.776] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.776]  - until=2
[11:01:28.776]  - relaying element #2
[11:01:28.777] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.777] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.777] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.777]  length: 2 (resolved future 2)
[11:01:28.777] resolved() for ‘SequentialFuture’ ...
[11:01:28.777] - state: ‘finished’
[11:01:28.777] - run: TRUE
[11:01:28.777] - result: ‘FutureResult’
[11:01:28.777] resolved() for ‘SequentialFuture’ ... done
[11:01:28.777] Future #3
[11:01:28.778] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.778] - nx: 4
[11:01:28.778] - relay: TRUE
[11:01:28.778] - stdout: TRUE
[11:01:28.778] - signal: TRUE
[11:01:28.778] - resignal: FALSE
[11:01:28.778] - force: TRUE
[11:01:28.778] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.778] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.778]  - until=3
[11:01:28.778]  - relaying element #3
[11:01:28.778] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.778] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.779] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.779]  length: 1 (resolved future 3)
[11:01:28.779] resolved() for ‘SequentialFuture’ ...
[11:01:28.779] - state: ‘finished’
[11:01:28.779] - run: TRUE
[11:01:28.779] - result: ‘FutureResult’
[11:01:28.779] resolved() for ‘SequentialFuture’ ... done
[11:01:28.779] Future #4
[11:01:28.779] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:28.779] - nx: 4
[11:01:28.779] - relay: TRUE
[11:01:28.780] - stdout: TRUE
[11:01:28.780] - signal: TRUE
[11:01:28.780] - resignal: FALSE
[11:01:28.780] - force: TRUE
[11:01:28.780] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.780] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.780]  - until=4
[11:01:28.780]  - relaying element #4
[11:01:28.780] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.780] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.780] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:28.780]  length: 0 (resolved future 4)
[11:01:28.781] Relaying remaining futures
[11:01:28.781] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.782] - nx: 4
[11:01:28.782] - relay: TRUE
[11:01:28.782] - stdout: TRUE
[11:01:28.782] - signal: TRUE
[11:01:28.782] - resignal: FALSE
[11:01:28.782] - force: TRUE
[11:01:28.782] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.782] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:28.782] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.782] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.782] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.783] resolve() on environment ... DONE
<environment: 0x55a9c66d8eb8> 
Dimensions: c(2, 3)
[11:01:28.783] getGlobalsAndPackages() ...
[11:01:28.783] Searching for globals...
[11:01:28.783] 
[11:01:28.783] Searching for globals ... DONE
[11:01:28.784] - globals: [0] <none>
[11:01:28.784] getGlobalsAndPackages() ... DONE
[11:01:28.784] run() for ‘Future’ ...
[11:01:28.784] - state: ‘created’
[11:01:28.784] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.784] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.784] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.785]   - Field: ‘label’
[11:01:28.785]   - Field: ‘local’
[11:01:28.785]   - Field: ‘owner’
[11:01:28.785]   - Field: ‘envir’
[11:01:28.785]   - Field: ‘packages’
[11:01:28.785]   - Field: ‘gc’
[11:01:28.785]   - Field: ‘conditions’
[11:01:28.785]   - Field: ‘expr’
[11:01:28.785]   - Field: ‘uuid’
[11:01:28.785]   - Field: ‘seed’
[11:01:28.785]   - Field: ‘version’
[11:01:28.785]   - Field: ‘result’
[11:01:28.786]   - Field: ‘asynchronous’
[11:01:28.786]   - Field: ‘calls’
[11:01:28.786]   - Field: ‘globals’
[11:01:28.786]   - Field: ‘stdout’
[11:01:28.786]   - Field: ‘earlySignal’
[11:01:28.786]   - Field: ‘lazy’
[11:01:28.786]   - Field: ‘state’
[11:01:28.786] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.786] - Launch lazy future ...
[11:01:28.786] Packages needed by the future expression (n = 0): <none>
[11:01:28.786] Packages needed by future strategies (n = 0): <none>
[11:01:28.787] {
[11:01:28.787]     {
[11:01:28.787]         {
[11:01:28.787]             ...future.startTime <- base::Sys.time()
[11:01:28.787]             {
[11:01:28.787]                 {
[11:01:28.787]                   {
[11:01:28.787]                     base::local({
[11:01:28.787]                       has_future <- base::requireNamespace("future", 
[11:01:28.787]                         quietly = TRUE)
[11:01:28.787]                       if (has_future) {
[11:01:28.787]                         ns <- base::getNamespace("future")
[11:01:28.787]                         version <- ns[[".package"]][["version"]]
[11:01:28.787]                         if (is.null(version)) 
[11:01:28.787]                           version <- utils::packageVersion("future")
[11:01:28.787]                       }
[11:01:28.787]                       else {
[11:01:28.787]                         version <- NULL
[11:01:28.787]                       }
[11:01:28.787]                       if (!has_future || version < "1.8.0") {
[11:01:28.787]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.787]                           "", base::R.version$version.string), 
[11:01:28.787]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.787]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.787]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.787]                             "release", "version")], collapse = " "), 
[11:01:28.787]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.787]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.787]                           info)
[11:01:28.787]                         info <- base::paste(info, collapse = "; ")
[11:01:28.787]                         if (!has_future) {
[11:01:28.787]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.787]                             info)
[11:01:28.787]                         }
[11:01:28.787]                         else {
[11:01:28.787]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.787]                             info, version)
[11:01:28.787]                         }
[11:01:28.787]                         base::stop(msg)
[11:01:28.787]                       }
[11:01:28.787]                     })
[11:01:28.787]                   }
[11:01:28.787]                   ...future.strategy.old <- future::plan("list")
[11:01:28.787]                   options(future.plan = NULL)
[11:01:28.787]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.787]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.787]                 }
[11:01:28.787]                 ...future.workdir <- getwd()
[11:01:28.787]             }
[11:01:28.787]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.787]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.787]         }
[11:01:28.787]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.787]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.787]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.787]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.787]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.787]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.787]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.787]             base::names(...future.oldOptions))
[11:01:28.787]     }
[11:01:28.787]     if (FALSE) {
[11:01:28.787]     }
[11:01:28.787]     else {
[11:01:28.787]         if (TRUE) {
[11:01:28.787]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.787]                 open = "w")
[11:01:28.787]         }
[11:01:28.787]         else {
[11:01:28.787]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.787]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.787]         }
[11:01:28.787]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.787]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.787]             base::sink(type = "output", split = FALSE)
[11:01:28.787]             base::close(...future.stdout)
[11:01:28.787]         }, add = TRUE)
[11:01:28.787]     }
[11:01:28.787]     ...future.frame <- base::sys.nframe()
[11:01:28.787]     ...future.conditions <- base::list()
[11:01:28.787]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.787]     if (FALSE) {
[11:01:28.787]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.787]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.787]     }
[11:01:28.787]     ...future.result <- base::tryCatch({
[11:01:28.787]         base::withCallingHandlers({
[11:01:28.787]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.787]             future::FutureResult(value = ...future.value$value, 
[11:01:28.787]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.787]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.787]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.787]                     ...future.globalenv.names))
[11:01:28.787]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.787]         }, condition = base::local({
[11:01:28.787]             c <- base::c
[11:01:28.787]             inherits <- base::inherits
[11:01:28.787]             invokeRestart <- base::invokeRestart
[11:01:28.787]             length <- base::length
[11:01:28.787]             list <- base::list
[11:01:28.787]             seq.int <- base::seq.int
[11:01:28.787]             signalCondition <- base::signalCondition
[11:01:28.787]             sys.calls <- base::sys.calls
[11:01:28.787]             `[[` <- base::`[[`
[11:01:28.787]             `+` <- base::`+`
[11:01:28.787]             `<<-` <- base::`<<-`
[11:01:28.787]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.787]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.787]                   3L)]
[11:01:28.787]             }
[11:01:28.787]             function(cond) {
[11:01:28.787]                 is_error <- inherits(cond, "error")
[11:01:28.787]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.787]                   NULL)
[11:01:28.787]                 if (is_error) {
[11:01:28.787]                   sessionInformation <- function() {
[11:01:28.787]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.787]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.787]                       search = base::search(), system = base::Sys.info())
[11:01:28.787]                   }
[11:01:28.787]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.787]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.787]                     cond$call), session = sessionInformation(), 
[11:01:28.787]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.787]                   signalCondition(cond)
[11:01:28.787]                 }
[11:01:28.787]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.787]                 "immediateCondition"))) {
[11:01:28.787]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.787]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.787]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.787]                   if (TRUE && !signal) {
[11:01:28.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.787]                     {
[11:01:28.787]                       inherits <- base::inherits
[11:01:28.787]                       invokeRestart <- base::invokeRestart
[11:01:28.787]                       is.null <- base::is.null
[11:01:28.787]                       muffled <- FALSE
[11:01:28.787]                       if (inherits(cond, "message")) {
[11:01:28.787]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.787]                         if (muffled) 
[11:01:28.787]                           invokeRestart("muffleMessage")
[11:01:28.787]                       }
[11:01:28.787]                       else if (inherits(cond, "warning")) {
[11:01:28.787]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.787]                         if (muffled) 
[11:01:28.787]                           invokeRestart("muffleWarning")
[11:01:28.787]                       }
[11:01:28.787]                       else if (inherits(cond, "condition")) {
[11:01:28.787]                         if (!is.null(pattern)) {
[11:01:28.787]                           computeRestarts <- base::computeRestarts
[11:01:28.787]                           grepl <- base::grepl
[11:01:28.787]                           restarts <- computeRestarts(cond)
[11:01:28.787]                           for (restart in restarts) {
[11:01:28.787]                             name <- restart$name
[11:01:28.787]                             if (is.null(name)) 
[11:01:28.787]                               next
[11:01:28.787]                             if (!grepl(pattern, name)) 
[11:01:28.787]                               next
[11:01:28.787]                             invokeRestart(restart)
[11:01:28.787]                             muffled <- TRUE
[11:01:28.787]                             break
[11:01:28.787]                           }
[11:01:28.787]                         }
[11:01:28.787]                       }
[11:01:28.787]                       invisible(muffled)
[11:01:28.787]                     }
[11:01:28.787]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.787]                   }
[11:01:28.787]                 }
[11:01:28.787]                 else {
[11:01:28.787]                   if (TRUE) {
[11:01:28.787]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.787]                     {
[11:01:28.787]                       inherits <- base::inherits
[11:01:28.787]                       invokeRestart <- base::invokeRestart
[11:01:28.787]                       is.null <- base::is.null
[11:01:28.787]                       muffled <- FALSE
[11:01:28.787]                       if (inherits(cond, "message")) {
[11:01:28.787]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.787]                         if (muffled) 
[11:01:28.787]                           invokeRestart("muffleMessage")
[11:01:28.787]                       }
[11:01:28.787]                       else if (inherits(cond, "warning")) {
[11:01:28.787]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.787]                         if (muffled) 
[11:01:28.787]                           invokeRestart("muffleWarning")
[11:01:28.787]                       }
[11:01:28.787]                       else if (inherits(cond, "condition")) {
[11:01:28.787]                         if (!is.null(pattern)) {
[11:01:28.787]                           computeRestarts <- base::computeRestarts
[11:01:28.787]                           grepl <- base::grepl
[11:01:28.787]                           restarts <- computeRestarts(cond)
[11:01:28.787]                           for (restart in restarts) {
[11:01:28.787]                             name <- restart$name
[11:01:28.787]                             if (is.null(name)) 
[11:01:28.787]                               next
[11:01:28.787]                             if (!grepl(pattern, name)) 
[11:01:28.787]                               next
[11:01:28.787]                             invokeRestart(restart)
[11:01:28.787]                             muffled <- TRUE
[11:01:28.787]                             break
[11:01:28.787]                           }
[11:01:28.787]                         }
[11:01:28.787]                       }
[11:01:28.787]                       invisible(muffled)
[11:01:28.787]                     }
[11:01:28.787]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.787]                   }
[11:01:28.787]                 }
[11:01:28.787]             }
[11:01:28.787]         }))
[11:01:28.787]     }, error = function(ex) {
[11:01:28.787]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.787]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.787]                 ...future.rng), started = ...future.startTime, 
[11:01:28.787]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.787]             version = "1.8"), class = "FutureResult")
[11:01:28.787]     }, finally = {
[11:01:28.787]         if (!identical(...future.workdir, getwd())) 
[11:01:28.787]             setwd(...future.workdir)
[11:01:28.787]         {
[11:01:28.787]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.787]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.787]             }
[11:01:28.787]             base::options(...future.oldOptions)
[11:01:28.787]             if (.Platform$OS.type == "windows") {
[11:01:28.787]                 old_names <- names(...future.oldEnvVars)
[11:01:28.787]                 envs <- base::Sys.getenv()
[11:01:28.787]                 names <- names(envs)
[11:01:28.787]                 common <- intersect(names, old_names)
[11:01:28.787]                 added <- setdiff(names, old_names)
[11:01:28.787]                 removed <- setdiff(old_names, names)
[11:01:28.787]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.787]                   envs[common]]
[11:01:28.787]                 NAMES <- toupper(changed)
[11:01:28.787]                 args <- list()
[11:01:28.787]                 for (kk in seq_along(NAMES)) {
[11:01:28.787]                   name <- changed[[kk]]
[11:01:28.787]                   NAME <- NAMES[[kk]]
[11:01:28.787]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.787]                     next
[11:01:28.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.787]                 }
[11:01:28.787]                 NAMES <- toupper(added)
[11:01:28.787]                 for (kk in seq_along(NAMES)) {
[11:01:28.787]                   name <- added[[kk]]
[11:01:28.787]                   NAME <- NAMES[[kk]]
[11:01:28.787]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.787]                     next
[11:01:28.787]                   args[[name]] <- ""
[11:01:28.787]                 }
[11:01:28.787]                 NAMES <- toupper(removed)
[11:01:28.787]                 for (kk in seq_along(NAMES)) {
[11:01:28.787]                   name <- removed[[kk]]
[11:01:28.787]                   NAME <- NAMES[[kk]]
[11:01:28.787]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.787]                     next
[11:01:28.787]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.787]                 }
[11:01:28.787]                 if (length(args) > 0) 
[11:01:28.787]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.787]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.787]             }
[11:01:28.787]             else {
[11:01:28.787]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.787]             }
[11:01:28.787]             {
[11:01:28.787]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.787]                   0L) {
[11:01:28.787]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.787]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.787]                   base::options(opts)
[11:01:28.787]                 }
[11:01:28.787]                 {
[11:01:28.787]                   {
[11:01:28.787]                     NULL
[11:01:28.787]                     RNGkind("Mersenne-Twister")
[11:01:28.787]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.787]                       inherits = FALSE)
[11:01:28.787]                   }
[11:01:28.787]                   options(future.plan = NULL)
[11:01:28.787]                   if (is.na(NA_character_)) 
[11:01:28.787]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.787]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.787]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.787]                     .init = FALSE)
[11:01:28.787]                 }
[11:01:28.787]             }
[11:01:28.787]         }
[11:01:28.787]     })
[11:01:28.787]     if (TRUE) {
[11:01:28.787]         base::sink(type = "output", split = FALSE)
[11:01:28.787]         if (TRUE) {
[11:01:28.787]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.787]         }
[11:01:28.787]         else {
[11:01:28.787]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.787]         }
[11:01:28.787]         base::close(...future.stdout)
[11:01:28.787]         ...future.stdout <- NULL
[11:01:28.787]     }
[11:01:28.787]     ...future.result$conditions <- ...future.conditions
[11:01:28.787]     ...future.result$finished <- base::Sys.time()
[11:01:28.787]     ...future.result
[11:01:28.787] }
[11:01:28.789] plan(): Setting new future strategy stack:
[11:01:28.789] List of future strategies:
[11:01:28.789] 1. sequential:
[11:01:28.789]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.789]    - tweaked: FALSE
[11:01:28.789]    - call: NULL
[11:01:28.789] plan(): nbrOfWorkers() = 1
[11:01:28.790] plan(): Setting new future strategy stack:
[11:01:28.790] List of future strategies:
[11:01:28.790] 1. sequential:
[11:01:28.790]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.790]    - tweaked: FALSE
[11:01:28.790]    - call: plan(strategy)
[11:01:28.790] plan(): nbrOfWorkers() = 1
[11:01:28.790] SequentialFuture started (and completed)
[11:01:28.790] - Launch lazy future ... done
[11:01:28.791] run() for ‘SequentialFuture’ ... done
[11:01:28.791] getGlobalsAndPackages() ...
[11:01:28.791] Searching for globals...
[11:01:28.791] 
[11:01:28.791] Searching for globals ... DONE
[11:01:28.791] - globals: [0] <none>
[11:01:28.791] getGlobalsAndPackages() ... DONE
[11:01:28.791] run() for ‘Future’ ...
[11:01:28.792] - state: ‘created’
[11:01:28.792] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.792] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.792] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.792]   - Field: ‘label’
[11:01:28.792]   - Field: ‘local’
[11:01:28.792]   - Field: ‘owner’
[11:01:28.792]   - Field: ‘envir’
[11:01:28.792]   - Field: ‘packages’
[11:01:28.792]   - Field: ‘gc’
[11:01:28.793]   - Field: ‘conditions’
[11:01:28.793]   - Field: ‘expr’
[11:01:28.793]   - Field: ‘uuid’
[11:01:28.793]   - Field: ‘seed’
[11:01:28.793]   - Field: ‘version’
[11:01:28.793]   - Field: ‘result’
[11:01:28.793]   - Field: ‘asynchronous’
[11:01:28.793]   - Field: ‘calls’
[11:01:28.793]   - Field: ‘globals’
[11:01:28.793]   - Field: ‘stdout’
[11:01:28.793]   - Field: ‘earlySignal’
[11:01:28.793]   - Field: ‘lazy’
[11:01:28.794]   - Field: ‘state’
[11:01:28.794] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.794] - Launch lazy future ...
[11:01:28.794] Packages needed by the future expression (n = 0): <none>
[11:01:28.794] Packages needed by future strategies (n = 0): <none>
[11:01:28.794] {
[11:01:28.794]     {
[11:01:28.794]         {
[11:01:28.794]             ...future.startTime <- base::Sys.time()
[11:01:28.794]             {
[11:01:28.794]                 {
[11:01:28.794]                   {
[11:01:28.794]                     base::local({
[11:01:28.794]                       has_future <- base::requireNamespace("future", 
[11:01:28.794]                         quietly = TRUE)
[11:01:28.794]                       if (has_future) {
[11:01:28.794]                         ns <- base::getNamespace("future")
[11:01:28.794]                         version <- ns[[".package"]][["version"]]
[11:01:28.794]                         if (is.null(version)) 
[11:01:28.794]                           version <- utils::packageVersion("future")
[11:01:28.794]                       }
[11:01:28.794]                       else {
[11:01:28.794]                         version <- NULL
[11:01:28.794]                       }
[11:01:28.794]                       if (!has_future || version < "1.8.0") {
[11:01:28.794]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.794]                           "", base::R.version$version.string), 
[11:01:28.794]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.794]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.794]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.794]                             "release", "version")], collapse = " "), 
[11:01:28.794]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.794]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.794]                           info)
[11:01:28.794]                         info <- base::paste(info, collapse = "; ")
[11:01:28.794]                         if (!has_future) {
[11:01:28.794]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.794]                             info)
[11:01:28.794]                         }
[11:01:28.794]                         else {
[11:01:28.794]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.794]                             info, version)
[11:01:28.794]                         }
[11:01:28.794]                         base::stop(msg)
[11:01:28.794]                       }
[11:01:28.794]                     })
[11:01:28.794]                   }
[11:01:28.794]                   ...future.strategy.old <- future::plan("list")
[11:01:28.794]                   options(future.plan = NULL)
[11:01:28.794]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.794]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.794]                 }
[11:01:28.794]                 ...future.workdir <- getwd()
[11:01:28.794]             }
[11:01:28.794]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.794]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.794]         }
[11:01:28.794]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.794]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.794]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.794]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.794]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.794]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.794]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.794]             base::names(...future.oldOptions))
[11:01:28.794]     }
[11:01:28.794]     if (FALSE) {
[11:01:28.794]     }
[11:01:28.794]     else {
[11:01:28.794]         if (TRUE) {
[11:01:28.794]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.794]                 open = "w")
[11:01:28.794]         }
[11:01:28.794]         else {
[11:01:28.794]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.794]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.794]         }
[11:01:28.794]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.794]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.794]             base::sink(type = "output", split = FALSE)
[11:01:28.794]             base::close(...future.stdout)
[11:01:28.794]         }, add = TRUE)
[11:01:28.794]     }
[11:01:28.794]     ...future.frame <- base::sys.nframe()
[11:01:28.794]     ...future.conditions <- base::list()
[11:01:28.794]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.794]     if (FALSE) {
[11:01:28.794]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.794]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.794]     }
[11:01:28.794]     ...future.result <- base::tryCatch({
[11:01:28.794]         base::withCallingHandlers({
[11:01:28.794]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.794]             future::FutureResult(value = ...future.value$value, 
[11:01:28.794]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.794]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.794]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.794]                     ...future.globalenv.names))
[11:01:28.794]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.794]         }, condition = base::local({
[11:01:28.794]             c <- base::c
[11:01:28.794]             inherits <- base::inherits
[11:01:28.794]             invokeRestart <- base::invokeRestart
[11:01:28.794]             length <- base::length
[11:01:28.794]             list <- base::list
[11:01:28.794]             seq.int <- base::seq.int
[11:01:28.794]             signalCondition <- base::signalCondition
[11:01:28.794]             sys.calls <- base::sys.calls
[11:01:28.794]             `[[` <- base::`[[`
[11:01:28.794]             `+` <- base::`+`
[11:01:28.794]             `<<-` <- base::`<<-`
[11:01:28.794]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.794]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.794]                   3L)]
[11:01:28.794]             }
[11:01:28.794]             function(cond) {
[11:01:28.794]                 is_error <- inherits(cond, "error")
[11:01:28.794]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.794]                   NULL)
[11:01:28.794]                 if (is_error) {
[11:01:28.794]                   sessionInformation <- function() {
[11:01:28.794]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.794]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.794]                       search = base::search(), system = base::Sys.info())
[11:01:28.794]                   }
[11:01:28.794]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.794]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.794]                     cond$call), session = sessionInformation(), 
[11:01:28.794]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.794]                   signalCondition(cond)
[11:01:28.794]                 }
[11:01:28.794]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.794]                 "immediateCondition"))) {
[11:01:28.794]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.794]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.794]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.794]                   if (TRUE && !signal) {
[11:01:28.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.794]                     {
[11:01:28.794]                       inherits <- base::inherits
[11:01:28.794]                       invokeRestart <- base::invokeRestart
[11:01:28.794]                       is.null <- base::is.null
[11:01:28.794]                       muffled <- FALSE
[11:01:28.794]                       if (inherits(cond, "message")) {
[11:01:28.794]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.794]                         if (muffled) 
[11:01:28.794]                           invokeRestart("muffleMessage")
[11:01:28.794]                       }
[11:01:28.794]                       else if (inherits(cond, "warning")) {
[11:01:28.794]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.794]                         if (muffled) 
[11:01:28.794]                           invokeRestart("muffleWarning")
[11:01:28.794]                       }
[11:01:28.794]                       else if (inherits(cond, "condition")) {
[11:01:28.794]                         if (!is.null(pattern)) {
[11:01:28.794]                           computeRestarts <- base::computeRestarts
[11:01:28.794]                           grepl <- base::grepl
[11:01:28.794]                           restarts <- computeRestarts(cond)
[11:01:28.794]                           for (restart in restarts) {
[11:01:28.794]                             name <- restart$name
[11:01:28.794]                             if (is.null(name)) 
[11:01:28.794]                               next
[11:01:28.794]                             if (!grepl(pattern, name)) 
[11:01:28.794]                               next
[11:01:28.794]                             invokeRestart(restart)
[11:01:28.794]                             muffled <- TRUE
[11:01:28.794]                             break
[11:01:28.794]                           }
[11:01:28.794]                         }
[11:01:28.794]                       }
[11:01:28.794]                       invisible(muffled)
[11:01:28.794]                     }
[11:01:28.794]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.794]                   }
[11:01:28.794]                 }
[11:01:28.794]                 else {
[11:01:28.794]                   if (TRUE) {
[11:01:28.794]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.794]                     {
[11:01:28.794]                       inherits <- base::inherits
[11:01:28.794]                       invokeRestart <- base::invokeRestart
[11:01:28.794]                       is.null <- base::is.null
[11:01:28.794]                       muffled <- FALSE
[11:01:28.794]                       if (inherits(cond, "message")) {
[11:01:28.794]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.794]                         if (muffled) 
[11:01:28.794]                           invokeRestart("muffleMessage")
[11:01:28.794]                       }
[11:01:28.794]                       else if (inherits(cond, "warning")) {
[11:01:28.794]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.794]                         if (muffled) 
[11:01:28.794]                           invokeRestart("muffleWarning")
[11:01:28.794]                       }
[11:01:28.794]                       else if (inherits(cond, "condition")) {
[11:01:28.794]                         if (!is.null(pattern)) {
[11:01:28.794]                           computeRestarts <- base::computeRestarts
[11:01:28.794]                           grepl <- base::grepl
[11:01:28.794]                           restarts <- computeRestarts(cond)
[11:01:28.794]                           for (restart in restarts) {
[11:01:28.794]                             name <- restart$name
[11:01:28.794]                             if (is.null(name)) 
[11:01:28.794]                               next
[11:01:28.794]                             if (!grepl(pattern, name)) 
[11:01:28.794]                               next
[11:01:28.794]                             invokeRestart(restart)
[11:01:28.794]                             muffled <- TRUE
[11:01:28.794]                             break
[11:01:28.794]                           }
[11:01:28.794]                         }
[11:01:28.794]                       }
[11:01:28.794]                       invisible(muffled)
[11:01:28.794]                     }
[11:01:28.794]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.794]                   }
[11:01:28.794]                 }
[11:01:28.794]             }
[11:01:28.794]         }))
[11:01:28.794]     }, error = function(ex) {
[11:01:28.794]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.794]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.794]                 ...future.rng), started = ...future.startTime, 
[11:01:28.794]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.794]             version = "1.8"), class = "FutureResult")
[11:01:28.794]     }, finally = {
[11:01:28.794]         if (!identical(...future.workdir, getwd())) 
[11:01:28.794]             setwd(...future.workdir)
[11:01:28.794]         {
[11:01:28.794]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.794]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.794]             }
[11:01:28.794]             base::options(...future.oldOptions)
[11:01:28.794]             if (.Platform$OS.type == "windows") {
[11:01:28.794]                 old_names <- names(...future.oldEnvVars)
[11:01:28.794]                 envs <- base::Sys.getenv()
[11:01:28.794]                 names <- names(envs)
[11:01:28.794]                 common <- intersect(names, old_names)
[11:01:28.794]                 added <- setdiff(names, old_names)
[11:01:28.794]                 removed <- setdiff(old_names, names)
[11:01:28.794]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.794]                   envs[common]]
[11:01:28.794]                 NAMES <- toupper(changed)
[11:01:28.794]                 args <- list()
[11:01:28.794]                 for (kk in seq_along(NAMES)) {
[11:01:28.794]                   name <- changed[[kk]]
[11:01:28.794]                   NAME <- NAMES[[kk]]
[11:01:28.794]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.794]                     next
[11:01:28.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.794]                 }
[11:01:28.794]                 NAMES <- toupper(added)
[11:01:28.794]                 for (kk in seq_along(NAMES)) {
[11:01:28.794]                   name <- added[[kk]]
[11:01:28.794]                   NAME <- NAMES[[kk]]
[11:01:28.794]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.794]                     next
[11:01:28.794]                   args[[name]] <- ""
[11:01:28.794]                 }
[11:01:28.794]                 NAMES <- toupper(removed)
[11:01:28.794]                 for (kk in seq_along(NAMES)) {
[11:01:28.794]                   name <- removed[[kk]]
[11:01:28.794]                   NAME <- NAMES[[kk]]
[11:01:28.794]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.794]                     next
[11:01:28.794]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.794]                 }
[11:01:28.794]                 if (length(args) > 0) 
[11:01:28.794]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.794]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.794]             }
[11:01:28.794]             else {
[11:01:28.794]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.794]             }
[11:01:28.794]             {
[11:01:28.794]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.794]                   0L) {
[11:01:28.794]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.794]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.794]                   base::options(opts)
[11:01:28.794]                 }
[11:01:28.794]                 {
[11:01:28.794]                   {
[11:01:28.794]                     NULL
[11:01:28.794]                     RNGkind("Mersenne-Twister")
[11:01:28.794]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.794]                       inherits = FALSE)
[11:01:28.794]                   }
[11:01:28.794]                   options(future.plan = NULL)
[11:01:28.794]                   if (is.na(NA_character_)) 
[11:01:28.794]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.794]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.794]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.794]                     .init = FALSE)
[11:01:28.794]                 }
[11:01:28.794]             }
[11:01:28.794]         }
[11:01:28.794]     })
[11:01:28.794]     if (TRUE) {
[11:01:28.794]         base::sink(type = "output", split = FALSE)
[11:01:28.794]         if (TRUE) {
[11:01:28.794]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.794]         }
[11:01:28.794]         else {
[11:01:28.794]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.794]         }
[11:01:28.794]         base::close(...future.stdout)
[11:01:28.794]         ...future.stdout <- NULL
[11:01:28.794]     }
[11:01:28.794]     ...future.result$conditions <- ...future.conditions
[11:01:28.794]     ...future.result$finished <- base::Sys.time()
[11:01:28.794]     ...future.result
[11:01:28.794] }
[11:01:28.796] plan(): Setting new future strategy stack:
[11:01:28.796] List of future strategies:
[11:01:28.796] 1. sequential:
[11:01:28.796]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.796]    - tweaked: FALSE
[11:01:28.796]    - call: NULL
[11:01:28.797] plan(): nbrOfWorkers() = 1
[11:01:28.797] plan(): Setting new future strategy stack:
[11:01:28.797] List of future strategies:
[11:01:28.797] 1. sequential:
[11:01:28.797]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.797]    - tweaked: FALSE
[11:01:28.797]    - call: plan(strategy)
[11:01:28.798] plan(): nbrOfWorkers() = 1
[11:01:28.798] SequentialFuture started (and completed)
[11:01:28.798] - Launch lazy future ... done
[11:01:28.798] run() for ‘SequentialFuture’ ... done
[11:01:28.798] getGlobalsAndPackages() ...
[11:01:28.798] Searching for globals...
[11:01:28.799] - globals found: [1] ‘{’
[11:01:28.799] Searching for globals ... DONE
[11:01:28.799] Resolving globals: FALSE
[11:01:28.799] 
[11:01:28.799] 
[11:01:28.800] getGlobalsAndPackages() ... DONE
[11:01:28.800] run() for ‘Future’ ...
[11:01:28.800] - state: ‘created’
[11:01:28.800] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.800] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.800] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.800]   - Field: ‘label’
[11:01:28.800]   - Field: ‘local’
[11:01:28.801]   - Field: ‘owner’
[11:01:28.801]   - Field: ‘envir’
[11:01:28.801]   - Field: ‘packages’
[11:01:28.801]   - Field: ‘gc’
[11:01:28.801]   - Field: ‘conditions’
[11:01:28.801]   - Field: ‘expr’
[11:01:28.801]   - Field: ‘uuid’
[11:01:28.801]   - Field: ‘seed’
[11:01:28.801]   - Field: ‘version’
[11:01:28.801]   - Field: ‘result’
[11:01:28.801]   - Field: ‘asynchronous’
[11:01:28.801]   - Field: ‘calls’
[11:01:28.802]   - Field: ‘globals’
[11:01:28.802]   - Field: ‘stdout’
[11:01:28.802]   - Field: ‘earlySignal’
[11:01:28.802]   - Field: ‘lazy’
[11:01:28.802]   - Field: ‘state’
[11:01:28.802] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.802] - Launch lazy future ...
[11:01:28.802] Packages needed by the future expression (n = 0): <none>
[11:01:28.802] Packages needed by future strategies (n = 0): <none>
[11:01:28.803] {
[11:01:28.803]     {
[11:01:28.803]         {
[11:01:28.803]             ...future.startTime <- base::Sys.time()
[11:01:28.803]             {
[11:01:28.803]                 {
[11:01:28.803]                   {
[11:01:28.803]                     base::local({
[11:01:28.803]                       has_future <- base::requireNamespace("future", 
[11:01:28.803]                         quietly = TRUE)
[11:01:28.803]                       if (has_future) {
[11:01:28.803]                         ns <- base::getNamespace("future")
[11:01:28.803]                         version <- ns[[".package"]][["version"]]
[11:01:28.803]                         if (is.null(version)) 
[11:01:28.803]                           version <- utils::packageVersion("future")
[11:01:28.803]                       }
[11:01:28.803]                       else {
[11:01:28.803]                         version <- NULL
[11:01:28.803]                       }
[11:01:28.803]                       if (!has_future || version < "1.8.0") {
[11:01:28.803]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.803]                           "", base::R.version$version.string), 
[11:01:28.803]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.803]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.803]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.803]                             "release", "version")], collapse = " "), 
[11:01:28.803]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.803]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.803]                           info)
[11:01:28.803]                         info <- base::paste(info, collapse = "; ")
[11:01:28.803]                         if (!has_future) {
[11:01:28.803]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.803]                             info)
[11:01:28.803]                         }
[11:01:28.803]                         else {
[11:01:28.803]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.803]                             info, version)
[11:01:28.803]                         }
[11:01:28.803]                         base::stop(msg)
[11:01:28.803]                       }
[11:01:28.803]                     })
[11:01:28.803]                   }
[11:01:28.803]                   ...future.strategy.old <- future::plan("list")
[11:01:28.803]                   options(future.plan = NULL)
[11:01:28.803]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.803]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.803]                 }
[11:01:28.803]                 ...future.workdir <- getwd()
[11:01:28.803]             }
[11:01:28.803]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.803]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.803]         }
[11:01:28.803]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.803]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.803]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.803]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.803]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.803]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.803]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.803]             base::names(...future.oldOptions))
[11:01:28.803]     }
[11:01:28.803]     if (FALSE) {
[11:01:28.803]     }
[11:01:28.803]     else {
[11:01:28.803]         if (TRUE) {
[11:01:28.803]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.803]                 open = "w")
[11:01:28.803]         }
[11:01:28.803]         else {
[11:01:28.803]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.803]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.803]         }
[11:01:28.803]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.803]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.803]             base::sink(type = "output", split = FALSE)
[11:01:28.803]             base::close(...future.stdout)
[11:01:28.803]         }, add = TRUE)
[11:01:28.803]     }
[11:01:28.803]     ...future.frame <- base::sys.nframe()
[11:01:28.803]     ...future.conditions <- base::list()
[11:01:28.803]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.803]     if (FALSE) {
[11:01:28.803]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.803]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.803]     }
[11:01:28.803]     ...future.result <- base::tryCatch({
[11:01:28.803]         base::withCallingHandlers({
[11:01:28.803]             ...future.value <- base::withVisible(base::local({
[11:01:28.803]                 4
[11:01:28.803]             }))
[11:01:28.803]             future::FutureResult(value = ...future.value$value, 
[11:01:28.803]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.803]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.803]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.803]                     ...future.globalenv.names))
[11:01:28.803]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.803]         }, condition = base::local({
[11:01:28.803]             c <- base::c
[11:01:28.803]             inherits <- base::inherits
[11:01:28.803]             invokeRestart <- base::invokeRestart
[11:01:28.803]             length <- base::length
[11:01:28.803]             list <- base::list
[11:01:28.803]             seq.int <- base::seq.int
[11:01:28.803]             signalCondition <- base::signalCondition
[11:01:28.803]             sys.calls <- base::sys.calls
[11:01:28.803]             `[[` <- base::`[[`
[11:01:28.803]             `+` <- base::`+`
[11:01:28.803]             `<<-` <- base::`<<-`
[11:01:28.803]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.803]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.803]                   3L)]
[11:01:28.803]             }
[11:01:28.803]             function(cond) {
[11:01:28.803]                 is_error <- inherits(cond, "error")
[11:01:28.803]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.803]                   NULL)
[11:01:28.803]                 if (is_error) {
[11:01:28.803]                   sessionInformation <- function() {
[11:01:28.803]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.803]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.803]                       search = base::search(), system = base::Sys.info())
[11:01:28.803]                   }
[11:01:28.803]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.803]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.803]                     cond$call), session = sessionInformation(), 
[11:01:28.803]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.803]                   signalCondition(cond)
[11:01:28.803]                 }
[11:01:28.803]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.803]                 "immediateCondition"))) {
[11:01:28.803]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.803]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.803]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.803]                   if (TRUE && !signal) {
[11:01:28.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.803]                     {
[11:01:28.803]                       inherits <- base::inherits
[11:01:28.803]                       invokeRestart <- base::invokeRestart
[11:01:28.803]                       is.null <- base::is.null
[11:01:28.803]                       muffled <- FALSE
[11:01:28.803]                       if (inherits(cond, "message")) {
[11:01:28.803]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.803]                         if (muffled) 
[11:01:28.803]                           invokeRestart("muffleMessage")
[11:01:28.803]                       }
[11:01:28.803]                       else if (inherits(cond, "warning")) {
[11:01:28.803]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.803]                         if (muffled) 
[11:01:28.803]                           invokeRestart("muffleWarning")
[11:01:28.803]                       }
[11:01:28.803]                       else if (inherits(cond, "condition")) {
[11:01:28.803]                         if (!is.null(pattern)) {
[11:01:28.803]                           computeRestarts <- base::computeRestarts
[11:01:28.803]                           grepl <- base::grepl
[11:01:28.803]                           restarts <- computeRestarts(cond)
[11:01:28.803]                           for (restart in restarts) {
[11:01:28.803]                             name <- restart$name
[11:01:28.803]                             if (is.null(name)) 
[11:01:28.803]                               next
[11:01:28.803]                             if (!grepl(pattern, name)) 
[11:01:28.803]                               next
[11:01:28.803]                             invokeRestart(restart)
[11:01:28.803]                             muffled <- TRUE
[11:01:28.803]                             break
[11:01:28.803]                           }
[11:01:28.803]                         }
[11:01:28.803]                       }
[11:01:28.803]                       invisible(muffled)
[11:01:28.803]                     }
[11:01:28.803]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.803]                   }
[11:01:28.803]                 }
[11:01:28.803]                 else {
[11:01:28.803]                   if (TRUE) {
[11:01:28.803]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.803]                     {
[11:01:28.803]                       inherits <- base::inherits
[11:01:28.803]                       invokeRestart <- base::invokeRestart
[11:01:28.803]                       is.null <- base::is.null
[11:01:28.803]                       muffled <- FALSE
[11:01:28.803]                       if (inherits(cond, "message")) {
[11:01:28.803]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.803]                         if (muffled) 
[11:01:28.803]                           invokeRestart("muffleMessage")
[11:01:28.803]                       }
[11:01:28.803]                       else if (inherits(cond, "warning")) {
[11:01:28.803]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.803]                         if (muffled) 
[11:01:28.803]                           invokeRestart("muffleWarning")
[11:01:28.803]                       }
[11:01:28.803]                       else if (inherits(cond, "condition")) {
[11:01:28.803]                         if (!is.null(pattern)) {
[11:01:28.803]                           computeRestarts <- base::computeRestarts
[11:01:28.803]                           grepl <- base::grepl
[11:01:28.803]                           restarts <- computeRestarts(cond)
[11:01:28.803]                           for (restart in restarts) {
[11:01:28.803]                             name <- restart$name
[11:01:28.803]                             if (is.null(name)) 
[11:01:28.803]                               next
[11:01:28.803]                             if (!grepl(pattern, name)) 
[11:01:28.803]                               next
[11:01:28.803]                             invokeRestart(restart)
[11:01:28.803]                             muffled <- TRUE
[11:01:28.803]                             break
[11:01:28.803]                           }
[11:01:28.803]                         }
[11:01:28.803]                       }
[11:01:28.803]                       invisible(muffled)
[11:01:28.803]                     }
[11:01:28.803]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.803]                   }
[11:01:28.803]                 }
[11:01:28.803]             }
[11:01:28.803]         }))
[11:01:28.803]     }, error = function(ex) {
[11:01:28.803]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.803]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.803]                 ...future.rng), started = ...future.startTime, 
[11:01:28.803]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.803]             version = "1.8"), class = "FutureResult")
[11:01:28.803]     }, finally = {
[11:01:28.803]         if (!identical(...future.workdir, getwd())) 
[11:01:28.803]             setwd(...future.workdir)
[11:01:28.803]         {
[11:01:28.803]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.803]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.803]             }
[11:01:28.803]             base::options(...future.oldOptions)
[11:01:28.803]             if (.Platform$OS.type == "windows") {
[11:01:28.803]                 old_names <- names(...future.oldEnvVars)
[11:01:28.803]                 envs <- base::Sys.getenv()
[11:01:28.803]                 names <- names(envs)
[11:01:28.803]                 common <- intersect(names, old_names)
[11:01:28.803]                 added <- setdiff(names, old_names)
[11:01:28.803]                 removed <- setdiff(old_names, names)
[11:01:28.803]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.803]                   envs[common]]
[11:01:28.803]                 NAMES <- toupper(changed)
[11:01:28.803]                 args <- list()
[11:01:28.803]                 for (kk in seq_along(NAMES)) {
[11:01:28.803]                   name <- changed[[kk]]
[11:01:28.803]                   NAME <- NAMES[[kk]]
[11:01:28.803]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.803]                     next
[11:01:28.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.803]                 }
[11:01:28.803]                 NAMES <- toupper(added)
[11:01:28.803]                 for (kk in seq_along(NAMES)) {
[11:01:28.803]                   name <- added[[kk]]
[11:01:28.803]                   NAME <- NAMES[[kk]]
[11:01:28.803]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.803]                     next
[11:01:28.803]                   args[[name]] <- ""
[11:01:28.803]                 }
[11:01:28.803]                 NAMES <- toupper(removed)
[11:01:28.803]                 for (kk in seq_along(NAMES)) {
[11:01:28.803]                   name <- removed[[kk]]
[11:01:28.803]                   NAME <- NAMES[[kk]]
[11:01:28.803]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.803]                     next
[11:01:28.803]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.803]                 }
[11:01:28.803]                 if (length(args) > 0) 
[11:01:28.803]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.803]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.803]             }
[11:01:28.803]             else {
[11:01:28.803]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.803]             }
[11:01:28.803]             {
[11:01:28.803]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.803]                   0L) {
[11:01:28.803]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.803]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.803]                   base::options(opts)
[11:01:28.803]                 }
[11:01:28.803]                 {
[11:01:28.803]                   {
[11:01:28.803]                     NULL
[11:01:28.803]                     RNGkind("Mersenne-Twister")
[11:01:28.803]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.803]                       inherits = FALSE)
[11:01:28.803]                   }
[11:01:28.803]                   options(future.plan = NULL)
[11:01:28.803]                   if (is.na(NA_character_)) 
[11:01:28.803]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.803]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.803]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.803]                     .init = FALSE)
[11:01:28.803]                 }
[11:01:28.803]             }
[11:01:28.803]         }
[11:01:28.803]     })
[11:01:28.803]     if (TRUE) {
[11:01:28.803]         base::sink(type = "output", split = FALSE)
[11:01:28.803]         if (TRUE) {
[11:01:28.803]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.803]         }
[11:01:28.803]         else {
[11:01:28.803]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.803]         }
[11:01:28.803]         base::close(...future.stdout)
[11:01:28.803]         ...future.stdout <- NULL
[11:01:28.803]     }
[11:01:28.803]     ...future.result$conditions <- ...future.conditions
[11:01:28.803]     ...future.result$finished <- base::Sys.time()
[11:01:28.803]     ...future.result
[11:01:28.803] }
[11:01:28.804] plan(): Setting new future strategy stack:
[11:01:28.804] List of future strategies:
[11:01:28.804] 1. sequential:
[11:01:28.804]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.804]    - tweaked: FALSE
[11:01:28.804]    - call: NULL
[11:01:28.805] plan(): nbrOfWorkers() = 1
[11:01:28.806] plan(): Setting new future strategy stack:
[11:01:28.806] List of future strategies:
[11:01:28.806] 1. sequential:
[11:01:28.806]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.806]    - tweaked: FALSE
[11:01:28.806]    - call: plan(strategy)
[11:01:28.806] plan(): nbrOfWorkers() = 1
[11:01:28.806] SequentialFuture started (and completed)
[11:01:28.806] - Launch lazy future ... done
[11:01:28.806] run() for ‘SequentialFuture’ ... done
<environment: 0x55a9c4f85d80> 
<environment: 0x55a9c6f2eef0> 
[11:01:28.807] resolved() for ‘SequentialFuture’ ...
[11:01:28.808] - state: ‘finished’
[11:01:28.809] - run: TRUE
[11:01:28.809] - result: ‘FutureResult’
[11:01:28.809] resolved() for ‘SequentialFuture’ ... done
[11:01:28.809] resolved() for ‘SequentialFuture’ ...
[11:01:28.809] - state: ‘finished’
[11:01:28.809] - run: TRUE
[11:01:28.809] - result: ‘FutureResult’
[11:01:28.809] resolved() for ‘SequentialFuture’ ... done
[11:01:28.809] resolved() for ‘SequentialFuture’ ...
[11:01:28.810] - state: ‘finished’
[11:01:28.810] - run: TRUE
[11:01:28.810] - result: ‘FutureResult’
[11:01:28.810] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:28.811] resolve() on environment ...
[11:01:28.811]  recursive: 0
[11:01:28.811]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:28.812] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.812] - nx: 4
[11:01:28.812] - relay: TRUE
[11:01:28.812] - stdout: TRUE
[11:01:28.812] - signal: TRUE
[11:01:28.812] - resignal: FALSE
[11:01:28.812] - force: TRUE
[11:01:28.812] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.812] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.812]  - until=2
[11:01:28.812]  - relaying element #2
[11:01:28.812] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.812] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.813] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.813]  length: 3 (resolved future 1)
[11:01:28.813] resolved() for ‘SequentialFuture’ ...
[11:01:28.813] - state: ‘finished’
[11:01:28.813] - run: TRUE
[11:01:28.813] - result: ‘FutureResult’
[11:01:28.813] resolved() for ‘SequentialFuture’ ... done
[11:01:28.813] Future #2
[11:01:28.813] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.813] - nx: 4
[11:01:28.813] - relay: TRUE
[11:01:28.813] - stdout: TRUE
[11:01:28.814] - signal: TRUE
[11:01:28.814] - resignal: FALSE
[11:01:28.814] - force: TRUE
[11:01:28.814] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.814] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.814]  - until=2
[11:01:28.814]  - relaying element #2
[11:01:28.814] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.814] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.814] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.814]  length: 2 (resolved future 2)
[11:01:28.815] resolved() for ‘SequentialFuture’ ...
[11:01:28.815] - state: ‘finished’
[11:01:28.815] - run: TRUE
[11:01:28.815] - result: ‘FutureResult’
[11:01:28.815] resolved() for ‘SequentialFuture’ ... done
[11:01:28.815] Future #3
[11:01:28.815] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.815] - nx: 4
[11:01:28.815] - relay: TRUE
[11:01:28.815] - stdout: TRUE
[11:01:28.815] - signal: TRUE
[11:01:28.815] - resignal: FALSE
[11:01:28.815] - force: TRUE
[11:01:28.816] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.816] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.816]  - until=3
[11:01:28.816]  - relaying element #3
[11:01:28.816] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.816] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.816] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.816]  length: 1 (resolved future 3)
[11:01:28.816] resolved() for ‘SequentialFuture’ ...
[11:01:28.816] - state: ‘finished’
[11:01:28.816] - run: TRUE
[11:01:28.817] - result: ‘FutureResult’
[11:01:28.817] resolved() for ‘SequentialFuture’ ... done
[11:01:28.817] Future #4
[11:01:28.817] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:28.817] - nx: 4
[11:01:28.817] - relay: TRUE
[11:01:28.817] - stdout: TRUE
[11:01:28.817] - signal: TRUE
[11:01:28.817] - resignal: FALSE
[11:01:28.817] - force: TRUE
[11:01:28.817] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.817] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.817]  - until=4
[11:01:28.818]  - relaying element #4
[11:01:28.818] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.818] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.818] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:28.818]  length: 0 (resolved future 4)
[11:01:28.818] Relaying remaining futures
[11:01:28.818] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.818] - nx: 4
[11:01:28.818] - relay: TRUE
[11:01:28.818] - stdout: TRUE
[11:01:28.818] - signal: TRUE
[11:01:28.818] - resignal: FALSE
[11:01:28.819] - force: TRUE
[11:01:28.819] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.819] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:28.819] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.819] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.819] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.819] resolve() on environment ... DONE
<environment: 0x55a9c4e33cc8> 
Dimensions: c(2, 3, 1)
[11:01:28.819] getGlobalsAndPackages() ...
[11:01:28.820] Searching for globals...
[11:01:28.820] 
[11:01:28.820] Searching for globals ... DONE
[11:01:28.820] - globals: [0] <none>
[11:01:28.820] getGlobalsAndPackages() ... DONE
[11:01:28.820] run() for ‘Future’ ...
[11:01:28.820] - state: ‘created’
[11:01:28.820] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.821] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.821] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.821]   - Field: ‘label’
[11:01:28.821]   - Field: ‘local’
[11:01:28.821]   - Field: ‘owner’
[11:01:28.821]   - Field: ‘envir’
[11:01:28.821]   - Field: ‘packages’
[11:01:28.821]   - Field: ‘gc’
[11:01:28.821]   - Field: ‘conditions’
[11:01:28.821]   - Field: ‘expr’
[11:01:28.822]   - Field: ‘uuid’
[11:01:28.822]   - Field: ‘seed’
[11:01:28.822]   - Field: ‘version’
[11:01:28.822]   - Field: ‘result’
[11:01:28.822]   - Field: ‘asynchronous’
[11:01:28.822]   - Field: ‘calls’
[11:01:28.822]   - Field: ‘globals’
[11:01:28.822]   - Field: ‘stdout’
[11:01:28.822]   - Field: ‘earlySignal’
[11:01:28.822]   - Field: ‘lazy’
[11:01:28.822]   - Field: ‘state’
[11:01:28.822] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.822] - Launch lazy future ...
[11:01:28.823] Packages needed by the future expression (n = 0): <none>
[11:01:28.823] Packages needed by future strategies (n = 0): <none>
[11:01:28.823] {
[11:01:28.823]     {
[11:01:28.823]         {
[11:01:28.823]             ...future.startTime <- base::Sys.time()
[11:01:28.823]             {
[11:01:28.823]                 {
[11:01:28.823]                   {
[11:01:28.823]                     base::local({
[11:01:28.823]                       has_future <- base::requireNamespace("future", 
[11:01:28.823]                         quietly = TRUE)
[11:01:28.823]                       if (has_future) {
[11:01:28.823]                         ns <- base::getNamespace("future")
[11:01:28.823]                         version <- ns[[".package"]][["version"]]
[11:01:28.823]                         if (is.null(version)) 
[11:01:28.823]                           version <- utils::packageVersion("future")
[11:01:28.823]                       }
[11:01:28.823]                       else {
[11:01:28.823]                         version <- NULL
[11:01:28.823]                       }
[11:01:28.823]                       if (!has_future || version < "1.8.0") {
[11:01:28.823]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.823]                           "", base::R.version$version.string), 
[11:01:28.823]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.823]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.823]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.823]                             "release", "version")], collapse = " "), 
[11:01:28.823]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.823]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.823]                           info)
[11:01:28.823]                         info <- base::paste(info, collapse = "; ")
[11:01:28.823]                         if (!has_future) {
[11:01:28.823]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.823]                             info)
[11:01:28.823]                         }
[11:01:28.823]                         else {
[11:01:28.823]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.823]                             info, version)
[11:01:28.823]                         }
[11:01:28.823]                         base::stop(msg)
[11:01:28.823]                       }
[11:01:28.823]                     })
[11:01:28.823]                   }
[11:01:28.823]                   ...future.strategy.old <- future::plan("list")
[11:01:28.823]                   options(future.plan = NULL)
[11:01:28.823]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.823]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.823]                 }
[11:01:28.823]                 ...future.workdir <- getwd()
[11:01:28.823]             }
[11:01:28.823]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.823]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.823]         }
[11:01:28.823]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.823]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.823]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.823]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.823]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.823]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.823]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.823]             base::names(...future.oldOptions))
[11:01:28.823]     }
[11:01:28.823]     if (FALSE) {
[11:01:28.823]     }
[11:01:28.823]     else {
[11:01:28.823]         if (TRUE) {
[11:01:28.823]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.823]                 open = "w")
[11:01:28.823]         }
[11:01:28.823]         else {
[11:01:28.823]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.823]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.823]         }
[11:01:28.823]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.823]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.823]             base::sink(type = "output", split = FALSE)
[11:01:28.823]             base::close(...future.stdout)
[11:01:28.823]         }, add = TRUE)
[11:01:28.823]     }
[11:01:28.823]     ...future.frame <- base::sys.nframe()
[11:01:28.823]     ...future.conditions <- base::list()
[11:01:28.823]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.823]     if (FALSE) {
[11:01:28.823]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.823]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.823]     }
[11:01:28.823]     ...future.result <- base::tryCatch({
[11:01:28.823]         base::withCallingHandlers({
[11:01:28.823]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.823]             future::FutureResult(value = ...future.value$value, 
[11:01:28.823]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.823]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.823]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.823]                     ...future.globalenv.names))
[11:01:28.823]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.823]         }, condition = base::local({
[11:01:28.823]             c <- base::c
[11:01:28.823]             inherits <- base::inherits
[11:01:28.823]             invokeRestart <- base::invokeRestart
[11:01:28.823]             length <- base::length
[11:01:28.823]             list <- base::list
[11:01:28.823]             seq.int <- base::seq.int
[11:01:28.823]             signalCondition <- base::signalCondition
[11:01:28.823]             sys.calls <- base::sys.calls
[11:01:28.823]             `[[` <- base::`[[`
[11:01:28.823]             `+` <- base::`+`
[11:01:28.823]             `<<-` <- base::`<<-`
[11:01:28.823]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.823]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.823]                   3L)]
[11:01:28.823]             }
[11:01:28.823]             function(cond) {
[11:01:28.823]                 is_error <- inherits(cond, "error")
[11:01:28.823]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.823]                   NULL)
[11:01:28.823]                 if (is_error) {
[11:01:28.823]                   sessionInformation <- function() {
[11:01:28.823]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.823]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.823]                       search = base::search(), system = base::Sys.info())
[11:01:28.823]                   }
[11:01:28.823]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.823]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.823]                     cond$call), session = sessionInformation(), 
[11:01:28.823]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.823]                   signalCondition(cond)
[11:01:28.823]                 }
[11:01:28.823]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.823]                 "immediateCondition"))) {
[11:01:28.823]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.823]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.823]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.823]                   if (TRUE && !signal) {
[11:01:28.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.823]                     {
[11:01:28.823]                       inherits <- base::inherits
[11:01:28.823]                       invokeRestart <- base::invokeRestart
[11:01:28.823]                       is.null <- base::is.null
[11:01:28.823]                       muffled <- FALSE
[11:01:28.823]                       if (inherits(cond, "message")) {
[11:01:28.823]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.823]                         if (muffled) 
[11:01:28.823]                           invokeRestart("muffleMessage")
[11:01:28.823]                       }
[11:01:28.823]                       else if (inherits(cond, "warning")) {
[11:01:28.823]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.823]                         if (muffled) 
[11:01:28.823]                           invokeRestart("muffleWarning")
[11:01:28.823]                       }
[11:01:28.823]                       else if (inherits(cond, "condition")) {
[11:01:28.823]                         if (!is.null(pattern)) {
[11:01:28.823]                           computeRestarts <- base::computeRestarts
[11:01:28.823]                           grepl <- base::grepl
[11:01:28.823]                           restarts <- computeRestarts(cond)
[11:01:28.823]                           for (restart in restarts) {
[11:01:28.823]                             name <- restart$name
[11:01:28.823]                             if (is.null(name)) 
[11:01:28.823]                               next
[11:01:28.823]                             if (!grepl(pattern, name)) 
[11:01:28.823]                               next
[11:01:28.823]                             invokeRestart(restart)
[11:01:28.823]                             muffled <- TRUE
[11:01:28.823]                             break
[11:01:28.823]                           }
[11:01:28.823]                         }
[11:01:28.823]                       }
[11:01:28.823]                       invisible(muffled)
[11:01:28.823]                     }
[11:01:28.823]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.823]                   }
[11:01:28.823]                 }
[11:01:28.823]                 else {
[11:01:28.823]                   if (TRUE) {
[11:01:28.823]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.823]                     {
[11:01:28.823]                       inherits <- base::inherits
[11:01:28.823]                       invokeRestart <- base::invokeRestart
[11:01:28.823]                       is.null <- base::is.null
[11:01:28.823]                       muffled <- FALSE
[11:01:28.823]                       if (inherits(cond, "message")) {
[11:01:28.823]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.823]                         if (muffled) 
[11:01:28.823]                           invokeRestart("muffleMessage")
[11:01:28.823]                       }
[11:01:28.823]                       else if (inherits(cond, "warning")) {
[11:01:28.823]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.823]                         if (muffled) 
[11:01:28.823]                           invokeRestart("muffleWarning")
[11:01:28.823]                       }
[11:01:28.823]                       else if (inherits(cond, "condition")) {
[11:01:28.823]                         if (!is.null(pattern)) {
[11:01:28.823]                           computeRestarts <- base::computeRestarts
[11:01:28.823]                           grepl <- base::grepl
[11:01:28.823]                           restarts <- computeRestarts(cond)
[11:01:28.823]                           for (restart in restarts) {
[11:01:28.823]                             name <- restart$name
[11:01:28.823]                             if (is.null(name)) 
[11:01:28.823]                               next
[11:01:28.823]                             if (!grepl(pattern, name)) 
[11:01:28.823]                               next
[11:01:28.823]                             invokeRestart(restart)
[11:01:28.823]                             muffled <- TRUE
[11:01:28.823]                             break
[11:01:28.823]                           }
[11:01:28.823]                         }
[11:01:28.823]                       }
[11:01:28.823]                       invisible(muffled)
[11:01:28.823]                     }
[11:01:28.823]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.823]                   }
[11:01:28.823]                 }
[11:01:28.823]             }
[11:01:28.823]         }))
[11:01:28.823]     }, error = function(ex) {
[11:01:28.823]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.823]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.823]                 ...future.rng), started = ...future.startTime, 
[11:01:28.823]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.823]             version = "1.8"), class = "FutureResult")
[11:01:28.823]     }, finally = {
[11:01:28.823]         if (!identical(...future.workdir, getwd())) 
[11:01:28.823]             setwd(...future.workdir)
[11:01:28.823]         {
[11:01:28.823]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.823]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.823]             }
[11:01:28.823]             base::options(...future.oldOptions)
[11:01:28.823]             if (.Platform$OS.type == "windows") {
[11:01:28.823]                 old_names <- names(...future.oldEnvVars)
[11:01:28.823]                 envs <- base::Sys.getenv()
[11:01:28.823]                 names <- names(envs)
[11:01:28.823]                 common <- intersect(names, old_names)
[11:01:28.823]                 added <- setdiff(names, old_names)
[11:01:28.823]                 removed <- setdiff(old_names, names)
[11:01:28.823]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.823]                   envs[common]]
[11:01:28.823]                 NAMES <- toupper(changed)
[11:01:28.823]                 args <- list()
[11:01:28.823]                 for (kk in seq_along(NAMES)) {
[11:01:28.823]                   name <- changed[[kk]]
[11:01:28.823]                   NAME <- NAMES[[kk]]
[11:01:28.823]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.823]                     next
[11:01:28.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.823]                 }
[11:01:28.823]                 NAMES <- toupper(added)
[11:01:28.823]                 for (kk in seq_along(NAMES)) {
[11:01:28.823]                   name <- added[[kk]]
[11:01:28.823]                   NAME <- NAMES[[kk]]
[11:01:28.823]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.823]                     next
[11:01:28.823]                   args[[name]] <- ""
[11:01:28.823]                 }
[11:01:28.823]                 NAMES <- toupper(removed)
[11:01:28.823]                 for (kk in seq_along(NAMES)) {
[11:01:28.823]                   name <- removed[[kk]]
[11:01:28.823]                   NAME <- NAMES[[kk]]
[11:01:28.823]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.823]                     next
[11:01:28.823]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.823]                 }
[11:01:28.823]                 if (length(args) > 0) 
[11:01:28.823]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.823]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.823]             }
[11:01:28.823]             else {
[11:01:28.823]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.823]             }
[11:01:28.823]             {
[11:01:28.823]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.823]                   0L) {
[11:01:28.823]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.823]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.823]                   base::options(opts)
[11:01:28.823]                 }
[11:01:28.823]                 {
[11:01:28.823]                   {
[11:01:28.823]                     NULL
[11:01:28.823]                     RNGkind("Mersenne-Twister")
[11:01:28.823]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.823]                       inherits = FALSE)
[11:01:28.823]                   }
[11:01:28.823]                   options(future.plan = NULL)
[11:01:28.823]                   if (is.na(NA_character_)) 
[11:01:28.823]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.823]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.823]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.823]                     .init = FALSE)
[11:01:28.823]                 }
[11:01:28.823]             }
[11:01:28.823]         }
[11:01:28.823]     })
[11:01:28.823]     if (TRUE) {
[11:01:28.823]         base::sink(type = "output", split = FALSE)
[11:01:28.823]         if (TRUE) {
[11:01:28.823]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.823]         }
[11:01:28.823]         else {
[11:01:28.823]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.823]         }
[11:01:28.823]         base::close(...future.stdout)
[11:01:28.823]         ...future.stdout <- NULL
[11:01:28.823]     }
[11:01:28.823]     ...future.result$conditions <- ...future.conditions
[11:01:28.823]     ...future.result$finished <- base::Sys.time()
[11:01:28.823]     ...future.result
[11:01:28.823] }
[11:01:28.825] plan(): Setting new future strategy stack:
[11:01:28.825] List of future strategies:
[11:01:28.825] 1. sequential:
[11:01:28.825]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.825]    - tweaked: FALSE
[11:01:28.825]    - call: NULL
[11:01:28.825] plan(): nbrOfWorkers() = 1
[11:01:28.826] plan(): Setting new future strategy stack:
[11:01:28.826] List of future strategies:
[11:01:28.826] 1. sequential:
[11:01:28.826]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.826]    - tweaked: FALSE
[11:01:28.826]    - call: plan(strategy)
[11:01:28.827] plan(): nbrOfWorkers() = 1
[11:01:28.827] SequentialFuture started (and completed)
[11:01:28.827] - Launch lazy future ... done
[11:01:28.827] run() for ‘SequentialFuture’ ... done
[11:01:28.827] getGlobalsAndPackages() ...
[11:01:28.827] Searching for globals...
[11:01:28.827] 
[11:01:28.827] Searching for globals ... DONE
[11:01:28.827] - globals: [0] <none>
[11:01:28.828] getGlobalsAndPackages() ... DONE
[11:01:28.828] run() for ‘Future’ ...
[11:01:28.828] - state: ‘created’
[11:01:28.828] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.828] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.828]   - Field: ‘label’
[11:01:28.828]   - Field: ‘local’
[11:01:28.829]   - Field: ‘owner’
[11:01:28.829]   - Field: ‘envir’
[11:01:28.829]   - Field: ‘packages’
[11:01:28.829]   - Field: ‘gc’
[11:01:28.829]   - Field: ‘conditions’
[11:01:28.829]   - Field: ‘expr’
[11:01:28.829]   - Field: ‘uuid’
[11:01:28.829]   - Field: ‘seed’
[11:01:28.829]   - Field: ‘version’
[11:01:28.829]   - Field: ‘result’
[11:01:28.829]   - Field: ‘asynchronous’
[11:01:28.829]   - Field: ‘calls’
[11:01:28.830]   - Field: ‘globals’
[11:01:28.830]   - Field: ‘stdout’
[11:01:28.830]   - Field: ‘earlySignal’
[11:01:28.830]   - Field: ‘lazy’
[11:01:28.830]   - Field: ‘state’
[11:01:28.830] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.830] - Launch lazy future ...
[11:01:28.830] Packages needed by the future expression (n = 0): <none>
[11:01:28.830] Packages needed by future strategies (n = 0): <none>
[11:01:28.831] {
[11:01:28.831]     {
[11:01:28.831]         {
[11:01:28.831]             ...future.startTime <- base::Sys.time()
[11:01:28.831]             {
[11:01:28.831]                 {
[11:01:28.831]                   {
[11:01:28.831]                     base::local({
[11:01:28.831]                       has_future <- base::requireNamespace("future", 
[11:01:28.831]                         quietly = TRUE)
[11:01:28.831]                       if (has_future) {
[11:01:28.831]                         ns <- base::getNamespace("future")
[11:01:28.831]                         version <- ns[[".package"]][["version"]]
[11:01:28.831]                         if (is.null(version)) 
[11:01:28.831]                           version <- utils::packageVersion("future")
[11:01:28.831]                       }
[11:01:28.831]                       else {
[11:01:28.831]                         version <- NULL
[11:01:28.831]                       }
[11:01:28.831]                       if (!has_future || version < "1.8.0") {
[11:01:28.831]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.831]                           "", base::R.version$version.string), 
[11:01:28.831]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.831]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.831]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.831]                             "release", "version")], collapse = " "), 
[11:01:28.831]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.831]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.831]                           info)
[11:01:28.831]                         info <- base::paste(info, collapse = "; ")
[11:01:28.831]                         if (!has_future) {
[11:01:28.831]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.831]                             info)
[11:01:28.831]                         }
[11:01:28.831]                         else {
[11:01:28.831]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.831]                             info, version)
[11:01:28.831]                         }
[11:01:28.831]                         base::stop(msg)
[11:01:28.831]                       }
[11:01:28.831]                     })
[11:01:28.831]                   }
[11:01:28.831]                   ...future.strategy.old <- future::plan("list")
[11:01:28.831]                   options(future.plan = NULL)
[11:01:28.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.831]                 }
[11:01:28.831]                 ...future.workdir <- getwd()
[11:01:28.831]             }
[11:01:28.831]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.831]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.831]         }
[11:01:28.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.831]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.831]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.831]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.831]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.831]             base::names(...future.oldOptions))
[11:01:28.831]     }
[11:01:28.831]     if (FALSE) {
[11:01:28.831]     }
[11:01:28.831]     else {
[11:01:28.831]         if (TRUE) {
[11:01:28.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.831]                 open = "w")
[11:01:28.831]         }
[11:01:28.831]         else {
[11:01:28.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.831]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.831]         }
[11:01:28.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.831]             base::sink(type = "output", split = FALSE)
[11:01:28.831]             base::close(...future.stdout)
[11:01:28.831]         }, add = TRUE)
[11:01:28.831]     }
[11:01:28.831]     ...future.frame <- base::sys.nframe()
[11:01:28.831]     ...future.conditions <- base::list()
[11:01:28.831]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.831]     if (FALSE) {
[11:01:28.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.831]     }
[11:01:28.831]     ...future.result <- base::tryCatch({
[11:01:28.831]         base::withCallingHandlers({
[11:01:28.831]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.831]             future::FutureResult(value = ...future.value$value, 
[11:01:28.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.831]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.831]                     ...future.globalenv.names))
[11:01:28.831]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.831]         }, condition = base::local({
[11:01:28.831]             c <- base::c
[11:01:28.831]             inherits <- base::inherits
[11:01:28.831]             invokeRestart <- base::invokeRestart
[11:01:28.831]             length <- base::length
[11:01:28.831]             list <- base::list
[11:01:28.831]             seq.int <- base::seq.int
[11:01:28.831]             signalCondition <- base::signalCondition
[11:01:28.831]             sys.calls <- base::sys.calls
[11:01:28.831]             `[[` <- base::`[[`
[11:01:28.831]             `+` <- base::`+`
[11:01:28.831]             `<<-` <- base::`<<-`
[11:01:28.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.831]                   3L)]
[11:01:28.831]             }
[11:01:28.831]             function(cond) {
[11:01:28.831]                 is_error <- inherits(cond, "error")
[11:01:28.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.831]                   NULL)
[11:01:28.831]                 if (is_error) {
[11:01:28.831]                   sessionInformation <- function() {
[11:01:28.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.831]                       search = base::search(), system = base::Sys.info())
[11:01:28.831]                   }
[11:01:28.831]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.831]                     cond$call), session = sessionInformation(), 
[11:01:28.831]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.831]                   signalCondition(cond)
[11:01:28.831]                 }
[11:01:28.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.831]                 "immediateCondition"))) {
[11:01:28.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.831]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.831]                   if (TRUE && !signal) {
[11:01:28.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.831]                     {
[11:01:28.831]                       inherits <- base::inherits
[11:01:28.831]                       invokeRestart <- base::invokeRestart
[11:01:28.831]                       is.null <- base::is.null
[11:01:28.831]                       muffled <- FALSE
[11:01:28.831]                       if (inherits(cond, "message")) {
[11:01:28.831]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.831]                         if (muffled) 
[11:01:28.831]                           invokeRestart("muffleMessage")
[11:01:28.831]                       }
[11:01:28.831]                       else if (inherits(cond, "warning")) {
[11:01:28.831]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.831]                         if (muffled) 
[11:01:28.831]                           invokeRestart("muffleWarning")
[11:01:28.831]                       }
[11:01:28.831]                       else if (inherits(cond, "condition")) {
[11:01:28.831]                         if (!is.null(pattern)) {
[11:01:28.831]                           computeRestarts <- base::computeRestarts
[11:01:28.831]                           grepl <- base::grepl
[11:01:28.831]                           restarts <- computeRestarts(cond)
[11:01:28.831]                           for (restart in restarts) {
[11:01:28.831]                             name <- restart$name
[11:01:28.831]                             if (is.null(name)) 
[11:01:28.831]                               next
[11:01:28.831]                             if (!grepl(pattern, name)) 
[11:01:28.831]                               next
[11:01:28.831]                             invokeRestart(restart)
[11:01:28.831]                             muffled <- TRUE
[11:01:28.831]                             break
[11:01:28.831]                           }
[11:01:28.831]                         }
[11:01:28.831]                       }
[11:01:28.831]                       invisible(muffled)
[11:01:28.831]                     }
[11:01:28.831]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.831]                   }
[11:01:28.831]                 }
[11:01:28.831]                 else {
[11:01:28.831]                   if (TRUE) {
[11:01:28.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.831]                     {
[11:01:28.831]                       inherits <- base::inherits
[11:01:28.831]                       invokeRestart <- base::invokeRestart
[11:01:28.831]                       is.null <- base::is.null
[11:01:28.831]                       muffled <- FALSE
[11:01:28.831]                       if (inherits(cond, "message")) {
[11:01:28.831]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.831]                         if (muffled) 
[11:01:28.831]                           invokeRestart("muffleMessage")
[11:01:28.831]                       }
[11:01:28.831]                       else if (inherits(cond, "warning")) {
[11:01:28.831]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.831]                         if (muffled) 
[11:01:28.831]                           invokeRestart("muffleWarning")
[11:01:28.831]                       }
[11:01:28.831]                       else if (inherits(cond, "condition")) {
[11:01:28.831]                         if (!is.null(pattern)) {
[11:01:28.831]                           computeRestarts <- base::computeRestarts
[11:01:28.831]                           grepl <- base::grepl
[11:01:28.831]                           restarts <- computeRestarts(cond)
[11:01:28.831]                           for (restart in restarts) {
[11:01:28.831]                             name <- restart$name
[11:01:28.831]                             if (is.null(name)) 
[11:01:28.831]                               next
[11:01:28.831]                             if (!grepl(pattern, name)) 
[11:01:28.831]                               next
[11:01:28.831]                             invokeRestart(restart)
[11:01:28.831]                             muffled <- TRUE
[11:01:28.831]                             break
[11:01:28.831]                           }
[11:01:28.831]                         }
[11:01:28.831]                       }
[11:01:28.831]                       invisible(muffled)
[11:01:28.831]                     }
[11:01:28.831]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.831]                   }
[11:01:28.831]                 }
[11:01:28.831]             }
[11:01:28.831]         }))
[11:01:28.831]     }, error = function(ex) {
[11:01:28.831]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.831]                 ...future.rng), started = ...future.startTime, 
[11:01:28.831]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.831]             version = "1.8"), class = "FutureResult")
[11:01:28.831]     }, finally = {
[11:01:28.831]         if (!identical(...future.workdir, getwd())) 
[11:01:28.831]             setwd(...future.workdir)
[11:01:28.831]         {
[11:01:28.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.831]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.831]             }
[11:01:28.831]             base::options(...future.oldOptions)
[11:01:28.831]             if (.Platform$OS.type == "windows") {
[11:01:28.831]                 old_names <- names(...future.oldEnvVars)
[11:01:28.831]                 envs <- base::Sys.getenv()
[11:01:28.831]                 names <- names(envs)
[11:01:28.831]                 common <- intersect(names, old_names)
[11:01:28.831]                 added <- setdiff(names, old_names)
[11:01:28.831]                 removed <- setdiff(old_names, names)
[11:01:28.831]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.831]                   envs[common]]
[11:01:28.831]                 NAMES <- toupper(changed)
[11:01:28.831]                 args <- list()
[11:01:28.831]                 for (kk in seq_along(NAMES)) {
[11:01:28.831]                   name <- changed[[kk]]
[11:01:28.831]                   NAME <- NAMES[[kk]]
[11:01:28.831]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.831]                     next
[11:01:28.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.831]                 }
[11:01:28.831]                 NAMES <- toupper(added)
[11:01:28.831]                 for (kk in seq_along(NAMES)) {
[11:01:28.831]                   name <- added[[kk]]
[11:01:28.831]                   NAME <- NAMES[[kk]]
[11:01:28.831]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.831]                     next
[11:01:28.831]                   args[[name]] <- ""
[11:01:28.831]                 }
[11:01:28.831]                 NAMES <- toupper(removed)
[11:01:28.831]                 for (kk in seq_along(NAMES)) {
[11:01:28.831]                   name <- removed[[kk]]
[11:01:28.831]                   NAME <- NAMES[[kk]]
[11:01:28.831]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.831]                     next
[11:01:28.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.831]                 }
[11:01:28.831]                 if (length(args) > 0) 
[11:01:28.831]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.831]             }
[11:01:28.831]             else {
[11:01:28.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.831]             }
[11:01:28.831]             {
[11:01:28.831]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.831]                   0L) {
[11:01:28.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.831]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.831]                   base::options(opts)
[11:01:28.831]                 }
[11:01:28.831]                 {
[11:01:28.831]                   {
[11:01:28.831]                     NULL
[11:01:28.831]                     RNGkind("Mersenne-Twister")
[11:01:28.831]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.831]                       inherits = FALSE)
[11:01:28.831]                   }
[11:01:28.831]                   options(future.plan = NULL)
[11:01:28.831]                   if (is.na(NA_character_)) 
[11:01:28.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.831]                     .init = FALSE)
[11:01:28.831]                 }
[11:01:28.831]             }
[11:01:28.831]         }
[11:01:28.831]     })
[11:01:28.831]     if (TRUE) {
[11:01:28.831]         base::sink(type = "output", split = FALSE)
[11:01:28.831]         if (TRUE) {
[11:01:28.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.831]         }
[11:01:28.831]         else {
[11:01:28.831]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.831]         }
[11:01:28.831]         base::close(...future.stdout)
[11:01:28.831]         ...future.stdout <- NULL
[11:01:28.831]     }
[11:01:28.831]     ...future.result$conditions <- ...future.conditions
[11:01:28.831]     ...future.result$finished <- base::Sys.time()
[11:01:28.831]     ...future.result
[11:01:28.831] }
[11:01:28.833] plan(): Setting new future strategy stack:
[11:01:28.833] List of future strategies:
[11:01:28.833] 1. sequential:
[11:01:28.833]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.833]    - tweaked: FALSE
[11:01:28.833]    - call: NULL
[11:01:28.834] plan(): nbrOfWorkers() = 1
[11:01:28.835] plan(): Setting new future strategy stack:
[11:01:28.835] List of future strategies:
[11:01:28.835] 1. sequential:
[11:01:28.835]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.835]    - tweaked: FALSE
[11:01:28.835]    - call: plan(strategy)
[11:01:28.835] plan(): nbrOfWorkers() = 1
[11:01:28.835] SequentialFuture started (and completed)
[11:01:28.835] - Launch lazy future ... done
[11:01:28.835] run() for ‘SequentialFuture’ ... done
[11:01:28.836] getGlobalsAndPackages() ...
[11:01:28.836] Searching for globals...
[11:01:28.836] - globals found: [1] ‘{’
[11:01:28.836] Searching for globals ... DONE
[11:01:28.836] Resolving globals: FALSE
[11:01:28.837] 
[11:01:28.837] 
[11:01:28.837] getGlobalsAndPackages() ... DONE
[11:01:28.837] run() for ‘Future’ ...
[11:01:28.837] - state: ‘created’
[11:01:28.837] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.837] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.838] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.838]   - Field: ‘label’
[11:01:28.838]   - Field: ‘local’
[11:01:28.838]   - Field: ‘owner’
[11:01:28.838]   - Field: ‘envir’
[11:01:28.838]   - Field: ‘packages’
[11:01:28.838]   - Field: ‘gc’
[11:01:28.838]   - Field: ‘conditions’
[11:01:28.838]   - Field: ‘expr’
[11:01:28.838]   - Field: ‘uuid’
[11:01:28.838]   - Field: ‘seed’
[11:01:28.838]   - Field: ‘version’
[11:01:28.839]   - Field: ‘result’
[11:01:28.839]   - Field: ‘asynchronous’
[11:01:28.839]   - Field: ‘calls’
[11:01:28.839]   - Field: ‘globals’
[11:01:28.839]   - Field: ‘stdout’
[11:01:28.839]   - Field: ‘earlySignal’
[11:01:28.839]   - Field: ‘lazy’
[11:01:28.839]   - Field: ‘state’
[11:01:28.839] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.839] - Launch lazy future ...
[11:01:28.839] Packages needed by the future expression (n = 0): <none>
[11:01:28.840] Packages needed by future strategies (n = 0): <none>
[11:01:28.840] {
[11:01:28.840]     {
[11:01:28.840]         {
[11:01:28.840]             ...future.startTime <- base::Sys.time()
[11:01:28.840]             {
[11:01:28.840]                 {
[11:01:28.840]                   {
[11:01:28.840]                     base::local({
[11:01:28.840]                       has_future <- base::requireNamespace("future", 
[11:01:28.840]                         quietly = TRUE)
[11:01:28.840]                       if (has_future) {
[11:01:28.840]                         ns <- base::getNamespace("future")
[11:01:28.840]                         version <- ns[[".package"]][["version"]]
[11:01:28.840]                         if (is.null(version)) 
[11:01:28.840]                           version <- utils::packageVersion("future")
[11:01:28.840]                       }
[11:01:28.840]                       else {
[11:01:28.840]                         version <- NULL
[11:01:28.840]                       }
[11:01:28.840]                       if (!has_future || version < "1.8.0") {
[11:01:28.840]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.840]                           "", base::R.version$version.string), 
[11:01:28.840]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.840]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.840]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.840]                             "release", "version")], collapse = " "), 
[11:01:28.840]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.840]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.840]                           info)
[11:01:28.840]                         info <- base::paste(info, collapse = "; ")
[11:01:28.840]                         if (!has_future) {
[11:01:28.840]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.840]                             info)
[11:01:28.840]                         }
[11:01:28.840]                         else {
[11:01:28.840]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.840]                             info, version)
[11:01:28.840]                         }
[11:01:28.840]                         base::stop(msg)
[11:01:28.840]                       }
[11:01:28.840]                     })
[11:01:28.840]                   }
[11:01:28.840]                   ...future.strategy.old <- future::plan("list")
[11:01:28.840]                   options(future.plan = NULL)
[11:01:28.840]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.840]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.840]                 }
[11:01:28.840]                 ...future.workdir <- getwd()
[11:01:28.840]             }
[11:01:28.840]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.840]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.840]         }
[11:01:28.840]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.840]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.840]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.840]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.840]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.840]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.840]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.840]             base::names(...future.oldOptions))
[11:01:28.840]     }
[11:01:28.840]     if (FALSE) {
[11:01:28.840]     }
[11:01:28.840]     else {
[11:01:28.840]         if (TRUE) {
[11:01:28.840]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.840]                 open = "w")
[11:01:28.840]         }
[11:01:28.840]         else {
[11:01:28.840]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.840]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.840]         }
[11:01:28.840]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.840]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.840]             base::sink(type = "output", split = FALSE)
[11:01:28.840]             base::close(...future.stdout)
[11:01:28.840]         }, add = TRUE)
[11:01:28.840]     }
[11:01:28.840]     ...future.frame <- base::sys.nframe()
[11:01:28.840]     ...future.conditions <- base::list()
[11:01:28.840]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.840]     if (FALSE) {
[11:01:28.840]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.840]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.840]     }
[11:01:28.840]     ...future.result <- base::tryCatch({
[11:01:28.840]         base::withCallingHandlers({
[11:01:28.840]             ...future.value <- base::withVisible(base::local({
[11:01:28.840]                 4
[11:01:28.840]             }))
[11:01:28.840]             future::FutureResult(value = ...future.value$value, 
[11:01:28.840]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.840]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.840]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.840]                     ...future.globalenv.names))
[11:01:28.840]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.840]         }, condition = base::local({
[11:01:28.840]             c <- base::c
[11:01:28.840]             inherits <- base::inherits
[11:01:28.840]             invokeRestart <- base::invokeRestart
[11:01:28.840]             length <- base::length
[11:01:28.840]             list <- base::list
[11:01:28.840]             seq.int <- base::seq.int
[11:01:28.840]             signalCondition <- base::signalCondition
[11:01:28.840]             sys.calls <- base::sys.calls
[11:01:28.840]             `[[` <- base::`[[`
[11:01:28.840]             `+` <- base::`+`
[11:01:28.840]             `<<-` <- base::`<<-`
[11:01:28.840]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.840]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.840]                   3L)]
[11:01:28.840]             }
[11:01:28.840]             function(cond) {
[11:01:28.840]                 is_error <- inherits(cond, "error")
[11:01:28.840]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.840]                   NULL)
[11:01:28.840]                 if (is_error) {
[11:01:28.840]                   sessionInformation <- function() {
[11:01:28.840]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.840]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.840]                       search = base::search(), system = base::Sys.info())
[11:01:28.840]                   }
[11:01:28.840]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.840]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.840]                     cond$call), session = sessionInformation(), 
[11:01:28.840]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.840]                   signalCondition(cond)
[11:01:28.840]                 }
[11:01:28.840]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.840]                 "immediateCondition"))) {
[11:01:28.840]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.840]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.840]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.840]                   if (TRUE && !signal) {
[11:01:28.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.840]                     {
[11:01:28.840]                       inherits <- base::inherits
[11:01:28.840]                       invokeRestart <- base::invokeRestart
[11:01:28.840]                       is.null <- base::is.null
[11:01:28.840]                       muffled <- FALSE
[11:01:28.840]                       if (inherits(cond, "message")) {
[11:01:28.840]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.840]                         if (muffled) 
[11:01:28.840]                           invokeRestart("muffleMessage")
[11:01:28.840]                       }
[11:01:28.840]                       else if (inherits(cond, "warning")) {
[11:01:28.840]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.840]                         if (muffled) 
[11:01:28.840]                           invokeRestart("muffleWarning")
[11:01:28.840]                       }
[11:01:28.840]                       else if (inherits(cond, "condition")) {
[11:01:28.840]                         if (!is.null(pattern)) {
[11:01:28.840]                           computeRestarts <- base::computeRestarts
[11:01:28.840]                           grepl <- base::grepl
[11:01:28.840]                           restarts <- computeRestarts(cond)
[11:01:28.840]                           for (restart in restarts) {
[11:01:28.840]                             name <- restart$name
[11:01:28.840]                             if (is.null(name)) 
[11:01:28.840]                               next
[11:01:28.840]                             if (!grepl(pattern, name)) 
[11:01:28.840]                               next
[11:01:28.840]                             invokeRestart(restart)
[11:01:28.840]                             muffled <- TRUE
[11:01:28.840]                             break
[11:01:28.840]                           }
[11:01:28.840]                         }
[11:01:28.840]                       }
[11:01:28.840]                       invisible(muffled)
[11:01:28.840]                     }
[11:01:28.840]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.840]                   }
[11:01:28.840]                 }
[11:01:28.840]                 else {
[11:01:28.840]                   if (TRUE) {
[11:01:28.840]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.840]                     {
[11:01:28.840]                       inherits <- base::inherits
[11:01:28.840]                       invokeRestart <- base::invokeRestart
[11:01:28.840]                       is.null <- base::is.null
[11:01:28.840]                       muffled <- FALSE
[11:01:28.840]                       if (inherits(cond, "message")) {
[11:01:28.840]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.840]                         if (muffled) 
[11:01:28.840]                           invokeRestart("muffleMessage")
[11:01:28.840]                       }
[11:01:28.840]                       else if (inherits(cond, "warning")) {
[11:01:28.840]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.840]                         if (muffled) 
[11:01:28.840]                           invokeRestart("muffleWarning")
[11:01:28.840]                       }
[11:01:28.840]                       else if (inherits(cond, "condition")) {
[11:01:28.840]                         if (!is.null(pattern)) {
[11:01:28.840]                           computeRestarts <- base::computeRestarts
[11:01:28.840]                           grepl <- base::grepl
[11:01:28.840]                           restarts <- computeRestarts(cond)
[11:01:28.840]                           for (restart in restarts) {
[11:01:28.840]                             name <- restart$name
[11:01:28.840]                             if (is.null(name)) 
[11:01:28.840]                               next
[11:01:28.840]                             if (!grepl(pattern, name)) 
[11:01:28.840]                               next
[11:01:28.840]                             invokeRestart(restart)
[11:01:28.840]                             muffled <- TRUE
[11:01:28.840]                             break
[11:01:28.840]                           }
[11:01:28.840]                         }
[11:01:28.840]                       }
[11:01:28.840]                       invisible(muffled)
[11:01:28.840]                     }
[11:01:28.840]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.840]                   }
[11:01:28.840]                 }
[11:01:28.840]             }
[11:01:28.840]         }))
[11:01:28.840]     }, error = function(ex) {
[11:01:28.840]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.840]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.840]                 ...future.rng), started = ...future.startTime, 
[11:01:28.840]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.840]             version = "1.8"), class = "FutureResult")
[11:01:28.840]     }, finally = {
[11:01:28.840]         if (!identical(...future.workdir, getwd())) 
[11:01:28.840]             setwd(...future.workdir)
[11:01:28.840]         {
[11:01:28.840]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.840]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.840]             }
[11:01:28.840]             base::options(...future.oldOptions)
[11:01:28.840]             if (.Platform$OS.type == "windows") {
[11:01:28.840]                 old_names <- names(...future.oldEnvVars)
[11:01:28.840]                 envs <- base::Sys.getenv()
[11:01:28.840]                 names <- names(envs)
[11:01:28.840]                 common <- intersect(names, old_names)
[11:01:28.840]                 added <- setdiff(names, old_names)
[11:01:28.840]                 removed <- setdiff(old_names, names)
[11:01:28.840]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.840]                   envs[common]]
[11:01:28.840]                 NAMES <- toupper(changed)
[11:01:28.840]                 args <- list()
[11:01:28.840]                 for (kk in seq_along(NAMES)) {
[11:01:28.840]                   name <- changed[[kk]]
[11:01:28.840]                   NAME <- NAMES[[kk]]
[11:01:28.840]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.840]                     next
[11:01:28.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.840]                 }
[11:01:28.840]                 NAMES <- toupper(added)
[11:01:28.840]                 for (kk in seq_along(NAMES)) {
[11:01:28.840]                   name <- added[[kk]]
[11:01:28.840]                   NAME <- NAMES[[kk]]
[11:01:28.840]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.840]                     next
[11:01:28.840]                   args[[name]] <- ""
[11:01:28.840]                 }
[11:01:28.840]                 NAMES <- toupper(removed)
[11:01:28.840]                 for (kk in seq_along(NAMES)) {
[11:01:28.840]                   name <- removed[[kk]]
[11:01:28.840]                   NAME <- NAMES[[kk]]
[11:01:28.840]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.840]                     next
[11:01:28.840]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.840]                 }
[11:01:28.840]                 if (length(args) > 0) 
[11:01:28.840]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.840]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.840]             }
[11:01:28.840]             else {
[11:01:28.840]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.840]             }
[11:01:28.840]             {
[11:01:28.840]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.840]                   0L) {
[11:01:28.840]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.840]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.840]                   base::options(opts)
[11:01:28.840]                 }
[11:01:28.840]                 {
[11:01:28.840]                   {
[11:01:28.840]                     NULL
[11:01:28.840]                     RNGkind("Mersenne-Twister")
[11:01:28.840]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.840]                       inherits = FALSE)
[11:01:28.840]                   }
[11:01:28.840]                   options(future.plan = NULL)
[11:01:28.840]                   if (is.na(NA_character_)) 
[11:01:28.840]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.840]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.840]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.840]                     .init = FALSE)
[11:01:28.840]                 }
[11:01:28.840]             }
[11:01:28.840]         }
[11:01:28.840]     })
[11:01:28.840]     if (TRUE) {
[11:01:28.840]         base::sink(type = "output", split = FALSE)
[11:01:28.840]         if (TRUE) {
[11:01:28.840]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.840]         }
[11:01:28.840]         else {
[11:01:28.840]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.840]         }
[11:01:28.840]         base::close(...future.stdout)
[11:01:28.840]         ...future.stdout <- NULL
[11:01:28.840]     }
[11:01:28.840]     ...future.result$conditions <- ...future.conditions
[11:01:28.840]     ...future.result$finished <- base::Sys.time()
[11:01:28.840]     ...future.result
[11:01:28.840] }
[11:01:28.842] plan(): Setting new future strategy stack:
[11:01:28.842] List of future strategies:
[11:01:28.842] 1. sequential:
[11:01:28.842]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.842]    - tweaked: FALSE
[11:01:28.842]    - call: NULL
[11:01:28.842] plan(): nbrOfWorkers() = 1
[11:01:28.843] plan(): Setting new future strategy stack:
[11:01:28.843] List of future strategies:
[11:01:28.843] 1. sequential:
[11:01:28.843]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.843]    - tweaked: FALSE
[11:01:28.843]    - call: plan(strategy)
[11:01:28.843] plan(): nbrOfWorkers() = 1
[11:01:28.844] SequentialFuture started (and completed)
[11:01:28.844] - Launch lazy future ... done
[11:01:28.844] run() for ‘SequentialFuture’ ... done
<environment: 0x55a9c6572e18> 
<environment: 0x55a9c62bab80> 
[11:01:28.845] resolved() for ‘SequentialFuture’ ...
[11:01:28.845] - state: ‘finished’
[11:01:28.845] - run: TRUE
[11:01:28.845] - result: ‘FutureResult’
[11:01:28.845] resolved() for ‘SequentialFuture’ ... done
[11:01:28.845] resolved() for ‘SequentialFuture’ ...
[11:01:28.845] - state: ‘finished’
[11:01:28.845] - run: TRUE
[11:01:28.846] - result: ‘FutureResult’
[11:01:28.846] resolved() for ‘SequentialFuture’ ... done
[11:01:28.846] resolved() for ‘SequentialFuture’ ...
[11:01:28.846] - state: ‘finished’
[11:01:28.846] - run: TRUE
[11:01:28.846] - result: ‘FutureResult’
[11:01:28.846] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:28.847] resolve() on environment ...
[11:01:28.847]  recursive: 0
[11:01:28.847]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:28.848] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.848] - nx: 4
[11:01:28.848] - relay: TRUE
[11:01:28.848] - stdout: TRUE
[11:01:28.848] - signal: TRUE
[11:01:28.848] - resignal: FALSE
[11:01:28.848] - force: TRUE
[11:01:28.848] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.848] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.848]  - until=2
[11:01:28.848]  - relaying element #2
[11:01:28.848] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.849] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.849] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.849]  length: 3 (resolved future 1)
[11:01:28.849] resolved() for ‘SequentialFuture’ ...
[11:01:28.849] - state: ‘finished’
[11:01:28.849] - run: TRUE
[11:01:28.849] - result: ‘FutureResult’
[11:01:28.849] resolved() for ‘SequentialFuture’ ... done
[11:01:28.849] Future #2
[11:01:28.849] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.849] - nx: 4
[11:01:28.849] - relay: TRUE
[11:01:28.850] - stdout: TRUE
[11:01:28.850] - signal: TRUE
[11:01:28.850] - resignal: FALSE
[11:01:28.850] - force: TRUE
[11:01:28.850] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.850] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.850]  - until=2
[11:01:28.850]  - relaying element #2
[11:01:28.850] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.850] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.850] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.850]  length: 2 (resolved future 2)
[11:01:28.851] resolved() for ‘SequentialFuture’ ...
[11:01:28.851] - state: ‘finished’
[11:01:28.851] - run: TRUE
[11:01:28.851] - result: ‘FutureResult’
[11:01:28.851] resolved() for ‘SequentialFuture’ ... done
[11:01:28.851] Future #3
[11:01:28.851] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.851] - nx: 4
[11:01:28.851] - relay: TRUE
[11:01:28.851] - stdout: TRUE
[11:01:28.851] - signal: TRUE
[11:01:28.851] - resignal: FALSE
[11:01:28.852] - force: TRUE
[11:01:28.852] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.852] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.852]  - until=3
[11:01:28.852]  - relaying element #3
[11:01:28.852] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.852] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.852] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.852]  length: 1 (resolved future 3)
[11:01:28.852] resolved() for ‘SequentialFuture’ ...
[11:01:28.852] - state: ‘finished’
[11:01:28.853] - run: TRUE
[11:01:28.853] - result: ‘FutureResult’
[11:01:28.853] resolved() for ‘SequentialFuture’ ... done
[11:01:28.853] Future #4
[11:01:28.853] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:28.853] - nx: 4
[11:01:28.853] - relay: TRUE
[11:01:28.853] - stdout: TRUE
[11:01:28.853] - signal: TRUE
[11:01:28.853] - resignal: FALSE
[11:01:28.853] - force: TRUE
[11:01:28.853] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.853] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.854]  - until=4
[11:01:28.854]  - relaying element #4
[11:01:28.854] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.854] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.854] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:28.854]  length: 0 (resolved future 4)
[11:01:28.854] Relaying remaining futures
[11:01:28.854] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.854] - nx: 4
[11:01:28.854] - relay: TRUE
[11:01:28.854] - stdout: TRUE
[11:01:28.855] - signal: TRUE
[11:01:28.855] - resignal: FALSE
[11:01:28.855] - force: TRUE
[11:01:28.855] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.855] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:28.855] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.855] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.855] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.855] resolve() on environment ... DONE
<environment: 0x55a9c65b1bd8> 
Dimensions: c(2, 1, 3, 1)
[11:01:28.857] getGlobalsAndPackages() ...
[11:01:28.857] Searching for globals...
[11:01:28.857] 
[11:01:28.857] Searching for globals ... DONE
[11:01:28.857] - globals: [0] <none>
[11:01:28.857] getGlobalsAndPackages() ... DONE
[11:01:28.857] run() for ‘Future’ ...
[11:01:28.858] - state: ‘created’
[11:01:28.858] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.858] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.858] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.858]   - Field: ‘label’
[11:01:28.858]   - Field: ‘local’
[11:01:28.858]   - Field: ‘owner’
[11:01:28.858]   - Field: ‘envir’
[11:01:28.858]   - Field: ‘packages’
[11:01:28.858]   - Field: ‘gc’
[11:01:28.859]   - Field: ‘conditions’
[11:01:28.859]   - Field: ‘expr’
[11:01:28.859]   - Field: ‘uuid’
[11:01:28.859]   - Field: ‘seed’
[11:01:28.859]   - Field: ‘version’
[11:01:28.859]   - Field: ‘result’
[11:01:28.859]   - Field: ‘asynchronous’
[11:01:28.859]   - Field: ‘calls’
[11:01:28.859]   - Field: ‘globals’
[11:01:28.859]   - Field: ‘stdout’
[11:01:28.859]   - Field: ‘earlySignal’
[11:01:28.859]   - Field: ‘lazy’
[11:01:28.859]   - Field: ‘state’
[11:01:28.860] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.860] - Launch lazy future ...
[11:01:28.860] Packages needed by the future expression (n = 0): <none>
[11:01:28.860] Packages needed by future strategies (n = 0): <none>
[11:01:28.860] {
[11:01:28.860]     {
[11:01:28.860]         {
[11:01:28.860]             ...future.startTime <- base::Sys.time()
[11:01:28.860]             {
[11:01:28.860]                 {
[11:01:28.860]                   {
[11:01:28.860]                     base::local({
[11:01:28.860]                       has_future <- base::requireNamespace("future", 
[11:01:28.860]                         quietly = TRUE)
[11:01:28.860]                       if (has_future) {
[11:01:28.860]                         ns <- base::getNamespace("future")
[11:01:28.860]                         version <- ns[[".package"]][["version"]]
[11:01:28.860]                         if (is.null(version)) 
[11:01:28.860]                           version <- utils::packageVersion("future")
[11:01:28.860]                       }
[11:01:28.860]                       else {
[11:01:28.860]                         version <- NULL
[11:01:28.860]                       }
[11:01:28.860]                       if (!has_future || version < "1.8.0") {
[11:01:28.860]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.860]                           "", base::R.version$version.string), 
[11:01:28.860]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.860]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.860]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.860]                             "release", "version")], collapse = " "), 
[11:01:28.860]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.860]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.860]                           info)
[11:01:28.860]                         info <- base::paste(info, collapse = "; ")
[11:01:28.860]                         if (!has_future) {
[11:01:28.860]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.860]                             info)
[11:01:28.860]                         }
[11:01:28.860]                         else {
[11:01:28.860]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.860]                             info, version)
[11:01:28.860]                         }
[11:01:28.860]                         base::stop(msg)
[11:01:28.860]                       }
[11:01:28.860]                     })
[11:01:28.860]                   }
[11:01:28.860]                   ...future.strategy.old <- future::plan("list")
[11:01:28.860]                   options(future.plan = NULL)
[11:01:28.860]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.860]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.860]                 }
[11:01:28.860]                 ...future.workdir <- getwd()
[11:01:28.860]             }
[11:01:28.860]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.860]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.860]         }
[11:01:28.860]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.860]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.860]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.860]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.860]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.860]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.860]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.860]             base::names(...future.oldOptions))
[11:01:28.860]     }
[11:01:28.860]     if (FALSE) {
[11:01:28.860]     }
[11:01:28.860]     else {
[11:01:28.860]         if (TRUE) {
[11:01:28.860]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.860]                 open = "w")
[11:01:28.860]         }
[11:01:28.860]         else {
[11:01:28.860]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.860]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.860]         }
[11:01:28.860]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.860]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.860]             base::sink(type = "output", split = FALSE)
[11:01:28.860]             base::close(...future.stdout)
[11:01:28.860]         }, add = TRUE)
[11:01:28.860]     }
[11:01:28.860]     ...future.frame <- base::sys.nframe()
[11:01:28.860]     ...future.conditions <- base::list()
[11:01:28.860]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.860]     if (FALSE) {
[11:01:28.860]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.860]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.860]     }
[11:01:28.860]     ...future.result <- base::tryCatch({
[11:01:28.860]         base::withCallingHandlers({
[11:01:28.860]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.860]             future::FutureResult(value = ...future.value$value, 
[11:01:28.860]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.860]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.860]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.860]                     ...future.globalenv.names))
[11:01:28.860]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.860]         }, condition = base::local({
[11:01:28.860]             c <- base::c
[11:01:28.860]             inherits <- base::inherits
[11:01:28.860]             invokeRestart <- base::invokeRestart
[11:01:28.860]             length <- base::length
[11:01:28.860]             list <- base::list
[11:01:28.860]             seq.int <- base::seq.int
[11:01:28.860]             signalCondition <- base::signalCondition
[11:01:28.860]             sys.calls <- base::sys.calls
[11:01:28.860]             `[[` <- base::`[[`
[11:01:28.860]             `+` <- base::`+`
[11:01:28.860]             `<<-` <- base::`<<-`
[11:01:28.860]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.860]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.860]                   3L)]
[11:01:28.860]             }
[11:01:28.860]             function(cond) {
[11:01:28.860]                 is_error <- inherits(cond, "error")
[11:01:28.860]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.860]                   NULL)
[11:01:28.860]                 if (is_error) {
[11:01:28.860]                   sessionInformation <- function() {
[11:01:28.860]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.860]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.860]                       search = base::search(), system = base::Sys.info())
[11:01:28.860]                   }
[11:01:28.860]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.860]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.860]                     cond$call), session = sessionInformation(), 
[11:01:28.860]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.860]                   signalCondition(cond)
[11:01:28.860]                 }
[11:01:28.860]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.860]                 "immediateCondition"))) {
[11:01:28.860]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.860]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.860]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.860]                   if (TRUE && !signal) {
[11:01:28.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.860]                     {
[11:01:28.860]                       inherits <- base::inherits
[11:01:28.860]                       invokeRestart <- base::invokeRestart
[11:01:28.860]                       is.null <- base::is.null
[11:01:28.860]                       muffled <- FALSE
[11:01:28.860]                       if (inherits(cond, "message")) {
[11:01:28.860]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.860]                         if (muffled) 
[11:01:28.860]                           invokeRestart("muffleMessage")
[11:01:28.860]                       }
[11:01:28.860]                       else if (inherits(cond, "warning")) {
[11:01:28.860]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.860]                         if (muffled) 
[11:01:28.860]                           invokeRestart("muffleWarning")
[11:01:28.860]                       }
[11:01:28.860]                       else if (inherits(cond, "condition")) {
[11:01:28.860]                         if (!is.null(pattern)) {
[11:01:28.860]                           computeRestarts <- base::computeRestarts
[11:01:28.860]                           grepl <- base::grepl
[11:01:28.860]                           restarts <- computeRestarts(cond)
[11:01:28.860]                           for (restart in restarts) {
[11:01:28.860]                             name <- restart$name
[11:01:28.860]                             if (is.null(name)) 
[11:01:28.860]                               next
[11:01:28.860]                             if (!grepl(pattern, name)) 
[11:01:28.860]                               next
[11:01:28.860]                             invokeRestart(restart)
[11:01:28.860]                             muffled <- TRUE
[11:01:28.860]                             break
[11:01:28.860]                           }
[11:01:28.860]                         }
[11:01:28.860]                       }
[11:01:28.860]                       invisible(muffled)
[11:01:28.860]                     }
[11:01:28.860]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.860]                   }
[11:01:28.860]                 }
[11:01:28.860]                 else {
[11:01:28.860]                   if (TRUE) {
[11:01:28.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.860]                     {
[11:01:28.860]                       inherits <- base::inherits
[11:01:28.860]                       invokeRestart <- base::invokeRestart
[11:01:28.860]                       is.null <- base::is.null
[11:01:28.860]                       muffled <- FALSE
[11:01:28.860]                       if (inherits(cond, "message")) {
[11:01:28.860]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.860]                         if (muffled) 
[11:01:28.860]                           invokeRestart("muffleMessage")
[11:01:28.860]                       }
[11:01:28.860]                       else if (inherits(cond, "warning")) {
[11:01:28.860]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.860]                         if (muffled) 
[11:01:28.860]                           invokeRestart("muffleWarning")
[11:01:28.860]                       }
[11:01:28.860]                       else if (inherits(cond, "condition")) {
[11:01:28.860]                         if (!is.null(pattern)) {
[11:01:28.860]                           computeRestarts <- base::computeRestarts
[11:01:28.860]                           grepl <- base::grepl
[11:01:28.860]                           restarts <- computeRestarts(cond)
[11:01:28.860]                           for (restart in restarts) {
[11:01:28.860]                             name <- restart$name
[11:01:28.860]                             if (is.null(name)) 
[11:01:28.860]                               next
[11:01:28.860]                             if (!grepl(pattern, name)) 
[11:01:28.860]                               next
[11:01:28.860]                             invokeRestart(restart)
[11:01:28.860]                             muffled <- TRUE
[11:01:28.860]                             break
[11:01:28.860]                           }
[11:01:28.860]                         }
[11:01:28.860]                       }
[11:01:28.860]                       invisible(muffled)
[11:01:28.860]                     }
[11:01:28.860]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.860]                   }
[11:01:28.860]                 }
[11:01:28.860]             }
[11:01:28.860]         }))
[11:01:28.860]     }, error = function(ex) {
[11:01:28.860]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.860]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.860]                 ...future.rng), started = ...future.startTime, 
[11:01:28.860]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.860]             version = "1.8"), class = "FutureResult")
[11:01:28.860]     }, finally = {
[11:01:28.860]         if (!identical(...future.workdir, getwd())) 
[11:01:28.860]             setwd(...future.workdir)
[11:01:28.860]         {
[11:01:28.860]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.860]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.860]             }
[11:01:28.860]             base::options(...future.oldOptions)
[11:01:28.860]             if (.Platform$OS.type == "windows") {
[11:01:28.860]                 old_names <- names(...future.oldEnvVars)
[11:01:28.860]                 envs <- base::Sys.getenv()
[11:01:28.860]                 names <- names(envs)
[11:01:28.860]                 common <- intersect(names, old_names)
[11:01:28.860]                 added <- setdiff(names, old_names)
[11:01:28.860]                 removed <- setdiff(old_names, names)
[11:01:28.860]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.860]                   envs[common]]
[11:01:28.860]                 NAMES <- toupper(changed)
[11:01:28.860]                 args <- list()
[11:01:28.860]                 for (kk in seq_along(NAMES)) {
[11:01:28.860]                   name <- changed[[kk]]
[11:01:28.860]                   NAME <- NAMES[[kk]]
[11:01:28.860]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.860]                     next
[11:01:28.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.860]                 }
[11:01:28.860]                 NAMES <- toupper(added)
[11:01:28.860]                 for (kk in seq_along(NAMES)) {
[11:01:28.860]                   name <- added[[kk]]
[11:01:28.860]                   NAME <- NAMES[[kk]]
[11:01:28.860]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.860]                     next
[11:01:28.860]                   args[[name]] <- ""
[11:01:28.860]                 }
[11:01:28.860]                 NAMES <- toupper(removed)
[11:01:28.860]                 for (kk in seq_along(NAMES)) {
[11:01:28.860]                   name <- removed[[kk]]
[11:01:28.860]                   NAME <- NAMES[[kk]]
[11:01:28.860]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.860]                     next
[11:01:28.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.860]                 }
[11:01:28.860]                 if (length(args) > 0) 
[11:01:28.860]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.860]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.860]             }
[11:01:28.860]             else {
[11:01:28.860]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.860]             }
[11:01:28.860]             {
[11:01:28.860]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.860]                   0L) {
[11:01:28.860]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.860]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.860]                   base::options(opts)
[11:01:28.860]                 }
[11:01:28.860]                 {
[11:01:28.860]                   {
[11:01:28.860]                     NULL
[11:01:28.860]                     RNGkind("Mersenne-Twister")
[11:01:28.860]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.860]                       inherits = FALSE)
[11:01:28.860]                   }
[11:01:28.860]                   options(future.plan = NULL)
[11:01:28.860]                   if (is.na(NA_character_)) 
[11:01:28.860]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.860]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.860]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.860]                     .init = FALSE)
[11:01:28.860]                 }
[11:01:28.860]             }
[11:01:28.860]         }
[11:01:28.860]     })
[11:01:28.860]     if (TRUE) {
[11:01:28.860]         base::sink(type = "output", split = FALSE)
[11:01:28.860]         if (TRUE) {
[11:01:28.860]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.860]         }
[11:01:28.860]         else {
[11:01:28.860]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.860]         }
[11:01:28.860]         base::close(...future.stdout)
[11:01:28.860]         ...future.stdout <- NULL
[11:01:28.860]     }
[11:01:28.860]     ...future.result$conditions <- ...future.conditions
[11:01:28.860]     ...future.result$finished <- base::Sys.time()
[11:01:28.860]     ...future.result
[11:01:28.860] }
[11:01:28.862] plan(): Setting new future strategy stack:
[11:01:28.862] List of future strategies:
[11:01:28.862] 1. sequential:
[11:01:28.862]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.862]    - tweaked: FALSE
[11:01:28.862]    - call: NULL
[11:01:28.862] plan(): nbrOfWorkers() = 1
[11:01:28.863] plan(): Setting new future strategy stack:
[11:01:28.863] List of future strategies:
[11:01:28.863] 1. sequential:
[11:01:28.863]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.863]    - tweaked: FALSE
[11:01:28.863]    - call: plan(strategy)
[11:01:28.864] plan(): nbrOfWorkers() = 1
[11:01:28.864] SequentialFuture started (and completed)
[11:01:28.864] - Launch lazy future ... done
[11:01:28.864] run() for ‘SequentialFuture’ ... done
[11:01:28.864] getGlobalsAndPackages() ...
[11:01:28.864] Searching for globals...
[11:01:28.864] 
[11:01:28.865] Searching for globals ... DONE
[11:01:28.865] - globals: [0] <none>
[11:01:28.865] getGlobalsAndPackages() ... DONE
[11:01:28.865] run() for ‘Future’ ...
[11:01:28.865] - state: ‘created’
[11:01:28.865] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.865] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.865] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.865]   - Field: ‘label’
[11:01:28.866]   - Field: ‘local’
[11:01:28.866]   - Field: ‘owner’
[11:01:28.866]   - Field: ‘envir’
[11:01:28.866]   - Field: ‘packages’
[11:01:28.866]   - Field: ‘gc’
[11:01:28.866]   - Field: ‘conditions’
[11:01:28.866]   - Field: ‘expr’
[11:01:28.866]   - Field: ‘uuid’
[11:01:28.866]   - Field: ‘seed’
[11:01:28.866]   - Field: ‘version’
[11:01:28.866]   - Field: ‘result’
[11:01:28.866]   - Field: ‘asynchronous’
[11:01:28.867]   - Field: ‘calls’
[11:01:28.867]   - Field: ‘globals’
[11:01:28.867]   - Field: ‘stdout’
[11:01:28.867]   - Field: ‘earlySignal’
[11:01:28.867]   - Field: ‘lazy’
[11:01:28.867]   - Field: ‘state’
[11:01:28.867] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.867] - Launch lazy future ...
[11:01:28.867] Packages needed by the future expression (n = 0): <none>
[11:01:28.867] Packages needed by future strategies (n = 0): <none>
[11:01:28.868] {
[11:01:28.868]     {
[11:01:28.868]         {
[11:01:28.868]             ...future.startTime <- base::Sys.time()
[11:01:28.868]             {
[11:01:28.868]                 {
[11:01:28.868]                   {
[11:01:28.868]                     base::local({
[11:01:28.868]                       has_future <- base::requireNamespace("future", 
[11:01:28.868]                         quietly = TRUE)
[11:01:28.868]                       if (has_future) {
[11:01:28.868]                         ns <- base::getNamespace("future")
[11:01:28.868]                         version <- ns[[".package"]][["version"]]
[11:01:28.868]                         if (is.null(version)) 
[11:01:28.868]                           version <- utils::packageVersion("future")
[11:01:28.868]                       }
[11:01:28.868]                       else {
[11:01:28.868]                         version <- NULL
[11:01:28.868]                       }
[11:01:28.868]                       if (!has_future || version < "1.8.0") {
[11:01:28.868]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.868]                           "", base::R.version$version.string), 
[11:01:28.868]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.868]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.868]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.868]                             "release", "version")], collapse = " "), 
[11:01:28.868]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.868]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.868]                           info)
[11:01:28.868]                         info <- base::paste(info, collapse = "; ")
[11:01:28.868]                         if (!has_future) {
[11:01:28.868]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.868]                             info)
[11:01:28.868]                         }
[11:01:28.868]                         else {
[11:01:28.868]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.868]                             info, version)
[11:01:28.868]                         }
[11:01:28.868]                         base::stop(msg)
[11:01:28.868]                       }
[11:01:28.868]                     })
[11:01:28.868]                   }
[11:01:28.868]                   ...future.strategy.old <- future::plan("list")
[11:01:28.868]                   options(future.plan = NULL)
[11:01:28.868]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.868]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.868]                 }
[11:01:28.868]                 ...future.workdir <- getwd()
[11:01:28.868]             }
[11:01:28.868]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.868]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.868]         }
[11:01:28.868]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.868]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.868]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.868]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.868]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.868]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.868]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.868]             base::names(...future.oldOptions))
[11:01:28.868]     }
[11:01:28.868]     if (FALSE) {
[11:01:28.868]     }
[11:01:28.868]     else {
[11:01:28.868]         if (TRUE) {
[11:01:28.868]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.868]                 open = "w")
[11:01:28.868]         }
[11:01:28.868]         else {
[11:01:28.868]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.868]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.868]         }
[11:01:28.868]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.868]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.868]             base::sink(type = "output", split = FALSE)
[11:01:28.868]             base::close(...future.stdout)
[11:01:28.868]         }, add = TRUE)
[11:01:28.868]     }
[11:01:28.868]     ...future.frame <- base::sys.nframe()
[11:01:28.868]     ...future.conditions <- base::list()
[11:01:28.868]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.868]     if (FALSE) {
[11:01:28.868]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.868]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.868]     }
[11:01:28.868]     ...future.result <- base::tryCatch({
[11:01:28.868]         base::withCallingHandlers({
[11:01:28.868]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.868]             future::FutureResult(value = ...future.value$value, 
[11:01:28.868]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.868]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.868]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.868]                     ...future.globalenv.names))
[11:01:28.868]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.868]         }, condition = base::local({
[11:01:28.868]             c <- base::c
[11:01:28.868]             inherits <- base::inherits
[11:01:28.868]             invokeRestart <- base::invokeRestart
[11:01:28.868]             length <- base::length
[11:01:28.868]             list <- base::list
[11:01:28.868]             seq.int <- base::seq.int
[11:01:28.868]             signalCondition <- base::signalCondition
[11:01:28.868]             sys.calls <- base::sys.calls
[11:01:28.868]             `[[` <- base::`[[`
[11:01:28.868]             `+` <- base::`+`
[11:01:28.868]             `<<-` <- base::`<<-`
[11:01:28.868]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.868]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.868]                   3L)]
[11:01:28.868]             }
[11:01:28.868]             function(cond) {
[11:01:28.868]                 is_error <- inherits(cond, "error")
[11:01:28.868]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.868]                   NULL)
[11:01:28.868]                 if (is_error) {
[11:01:28.868]                   sessionInformation <- function() {
[11:01:28.868]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.868]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.868]                       search = base::search(), system = base::Sys.info())
[11:01:28.868]                   }
[11:01:28.868]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.868]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.868]                     cond$call), session = sessionInformation(), 
[11:01:28.868]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.868]                   signalCondition(cond)
[11:01:28.868]                 }
[11:01:28.868]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.868]                 "immediateCondition"))) {
[11:01:28.868]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.868]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.868]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.868]                   if (TRUE && !signal) {
[11:01:28.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.868]                     {
[11:01:28.868]                       inherits <- base::inherits
[11:01:28.868]                       invokeRestart <- base::invokeRestart
[11:01:28.868]                       is.null <- base::is.null
[11:01:28.868]                       muffled <- FALSE
[11:01:28.868]                       if (inherits(cond, "message")) {
[11:01:28.868]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.868]                         if (muffled) 
[11:01:28.868]                           invokeRestart("muffleMessage")
[11:01:28.868]                       }
[11:01:28.868]                       else if (inherits(cond, "warning")) {
[11:01:28.868]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.868]                         if (muffled) 
[11:01:28.868]                           invokeRestart("muffleWarning")
[11:01:28.868]                       }
[11:01:28.868]                       else if (inherits(cond, "condition")) {
[11:01:28.868]                         if (!is.null(pattern)) {
[11:01:28.868]                           computeRestarts <- base::computeRestarts
[11:01:28.868]                           grepl <- base::grepl
[11:01:28.868]                           restarts <- computeRestarts(cond)
[11:01:28.868]                           for (restart in restarts) {
[11:01:28.868]                             name <- restart$name
[11:01:28.868]                             if (is.null(name)) 
[11:01:28.868]                               next
[11:01:28.868]                             if (!grepl(pattern, name)) 
[11:01:28.868]                               next
[11:01:28.868]                             invokeRestart(restart)
[11:01:28.868]                             muffled <- TRUE
[11:01:28.868]                             break
[11:01:28.868]                           }
[11:01:28.868]                         }
[11:01:28.868]                       }
[11:01:28.868]                       invisible(muffled)
[11:01:28.868]                     }
[11:01:28.868]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.868]                   }
[11:01:28.868]                 }
[11:01:28.868]                 else {
[11:01:28.868]                   if (TRUE) {
[11:01:28.868]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.868]                     {
[11:01:28.868]                       inherits <- base::inherits
[11:01:28.868]                       invokeRestart <- base::invokeRestart
[11:01:28.868]                       is.null <- base::is.null
[11:01:28.868]                       muffled <- FALSE
[11:01:28.868]                       if (inherits(cond, "message")) {
[11:01:28.868]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.868]                         if (muffled) 
[11:01:28.868]                           invokeRestart("muffleMessage")
[11:01:28.868]                       }
[11:01:28.868]                       else if (inherits(cond, "warning")) {
[11:01:28.868]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.868]                         if (muffled) 
[11:01:28.868]                           invokeRestart("muffleWarning")
[11:01:28.868]                       }
[11:01:28.868]                       else if (inherits(cond, "condition")) {
[11:01:28.868]                         if (!is.null(pattern)) {
[11:01:28.868]                           computeRestarts <- base::computeRestarts
[11:01:28.868]                           grepl <- base::grepl
[11:01:28.868]                           restarts <- computeRestarts(cond)
[11:01:28.868]                           for (restart in restarts) {
[11:01:28.868]                             name <- restart$name
[11:01:28.868]                             if (is.null(name)) 
[11:01:28.868]                               next
[11:01:28.868]                             if (!grepl(pattern, name)) 
[11:01:28.868]                               next
[11:01:28.868]                             invokeRestart(restart)
[11:01:28.868]                             muffled <- TRUE
[11:01:28.868]                             break
[11:01:28.868]                           }
[11:01:28.868]                         }
[11:01:28.868]                       }
[11:01:28.868]                       invisible(muffled)
[11:01:28.868]                     }
[11:01:28.868]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.868]                   }
[11:01:28.868]                 }
[11:01:28.868]             }
[11:01:28.868]         }))
[11:01:28.868]     }, error = function(ex) {
[11:01:28.868]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.868]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.868]                 ...future.rng), started = ...future.startTime, 
[11:01:28.868]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.868]             version = "1.8"), class = "FutureResult")
[11:01:28.868]     }, finally = {
[11:01:28.868]         if (!identical(...future.workdir, getwd())) 
[11:01:28.868]             setwd(...future.workdir)
[11:01:28.868]         {
[11:01:28.868]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.868]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.868]             }
[11:01:28.868]             base::options(...future.oldOptions)
[11:01:28.868]             if (.Platform$OS.type == "windows") {
[11:01:28.868]                 old_names <- names(...future.oldEnvVars)
[11:01:28.868]                 envs <- base::Sys.getenv()
[11:01:28.868]                 names <- names(envs)
[11:01:28.868]                 common <- intersect(names, old_names)
[11:01:28.868]                 added <- setdiff(names, old_names)
[11:01:28.868]                 removed <- setdiff(old_names, names)
[11:01:28.868]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.868]                   envs[common]]
[11:01:28.868]                 NAMES <- toupper(changed)
[11:01:28.868]                 args <- list()
[11:01:28.868]                 for (kk in seq_along(NAMES)) {
[11:01:28.868]                   name <- changed[[kk]]
[11:01:28.868]                   NAME <- NAMES[[kk]]
[11:01:28.868]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.868]                     next
[11:01:28.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.868]                 }
[11:01:28.868]                 NAMES <- toupper(added)
[11:01:28.868]                 for (kk in seq_along(NAMES)) {
[11:01:28.868]                   name <- added[[kk]]
[11:01:28.868]                   NAME <- NAMES[[kk]]
[11:01:28.868]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.868]                     next
[11:01:28.868]                   args[[name]] <- ""
[11:01:28.868]                 }
[11:01:28.868]                 NAMES <- toupper(removed)
[11:01:28.868]                 for (kk in seq_along(NAMES)) {
[11:01:28.868]                   name <- removed[[kk]]
[11:01:28.868]                   NAME <- NAMES[[kk]]
[11:01:28.868]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.868]                     next
[11:01:28.868]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.868]                 }
[11:01:28.868]                 if (length(args) > 0) 
[11:01:28.868]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.868]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.868]             }
[11:01:28.868]             else {
[11:01:28.868]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.868]             }
[11:01:28.868]             {
[11:01:28.868]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.868]                   0L) {
[11:01:28.868]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.868]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.868]                   base::options(opts)
[11:01:28.868]                 }
[11:01:28.868]                 {
[11:01:28.868]                   {
[11:01:28.868]                     NULL
[11:01:28.868]                     RNGkind("Mersenne-Twister")
[11:01:28.868]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.868]                       inherits = FALSE)
[11:01:28.868]                   }
[11:01:28.868]                   options(future.plan = NULL)
[11:01:28.868]                   if (is.na(NA_character_)) 
[11:01:28.868]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.868]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.868]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.868]                     .init = FALSE)
[11:01:28.868]                 }
[11:01:28.868]             }
[11:01:28.868]         }
[11:01:28.868]     })
[11:01:28.868]     if (TRUE) {
[11:01:28.868]         base::sink(type = "output", split = FALSE)
[11:01:28.868]         if (TRUE) {
[11:01:28.868]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.868]         }
[11:01:28.868]         else {
[11:01:28.868]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.868]         }
[11:01:28.868]         base::close(...future.stdout)
[11:01:28.868]         ...future.stdout <- NULL
[11:01:28.868]     }
[11:01:28.868]     ...future.result$conditions <- ...future.conditions
[11:01:28.868]     ...future.result$finished <- base::Sys.time()
[11:01:28.868]     ...future.result
[11:01:28.868] }
[11:01:28.869] plan(): Setting new future strategy stack:
[11:01:28.869] List of future strategies:
[11:01:28.869] 1. sequential:
[11:01:28.869]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.869]    - tweaked: FALSE
[11:01:28.869]    - call: NULL
[11:01:28.870] plan(): nbrOfWorkers() = 1
[11:01:28.871] plan(): Setting new future strategy stack:
[11:01:28.871] List of future strategies:
[11:01:28.871] 1. sequential:
[11:01:28.871]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.871]    - tweaked: FALSE
[11:01:28.871]    - call: plan(strategy)
[11:01:28.871] plan(): nbrOfWorkers() = 1
[11:01:28.871] SequentialFuture started (and completed)
[11:01:28.871] - Launch lazy future ... done
[11:01:28.871] run() for ‘SequentialFuture’ ... done
[11:01:28.872] getGlobalsAndPackages() ...
[11:01:28.872] Searching for globals...
[11:01:28.872] - globals found: [1] ‘{’
[11:01:28.872] Searching for globals ... DONE
[11:01:28.872] Resolving globals: FALSE
[11:01:28.873] 
[11:01:28.873] 
[11:01:28.873] getGlobalsAndPackages() ... DONE
[11:01:28.873] run() for ‘Future’ ...
[11:01:28.873] - state: ‘created’
[11:01:28.873] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.873] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.874] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.874]   - Field: ‘label’
[11:01:28.874]   - Field: ‘local’
[11:01:28.874]   - Field: ‘owner’
[11:01:28.874]   - Field: ‘envir’
[11:01:28.874]   - Field: ‘packages’
[11:01:28.874]   - Field: ‘gc’
[11:01:28.874]   - Field: ‘conditions’
[11:01:28.874]   - Field: ‘expr’
[11:01:28.874]   - Field: ‘uuid’
[11:01:28.874]   - Field: ‘seed’
[11:01:28.874]   - Field: ‘version’
[11:01:28.875]   - Field: ‘result’
[11:01:28.875]   - Field: ‘asynchronous’
[11:01:28.875]   - Field: ‘calls’
[11:01:28.875]   - Field: ‘globals’
[11:01:28.875]   - Field: ‘stdout’
[11:01:28.875]   - Field: ‘earlySignal’
[11:01:28.875]   - Field: ‘lazy’
[11:01:28.875]   - Field: ‘state’
[11:01:28.875] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.875] - Launch lazy future ...
[11:01:28.875] Packages needed by the future expression (n = 0): <none>
[11:01:28.876] Packages needed by future strategies (n = 0): <none>
[11:01:28.876] {
[11:01:28.876]     {
[11:01:28.876]         {
[11:01:28.876]             ...future.startTime <- base::Sys.time()
[11:01:28.876]             {
[11:01:28.876]                 {
[11:01:28.876]                   {
[11:01:28.876]                     base::local({
[11:01:28.876]                       has_future <- base::requireNamespace("future", 
[11:01:28.876]                         quietly = TRUE)
[11:01:28.876]                       if (has_future) {
[11:01:28.876]                         ns <- base::getNamespace("future")
[11:01:28.876]                         version <- ns[[".package"]][["version"]]
[11:01:28.876]                         if (is.null(version)) 
[11:01:28.876]                           version <- utils::packageVersion("future")
[11:01:28.876]                       }
[11:01:28.876]                       else {
[11:01:28.876]                         version <- NULL
[11:01:28.876]                       }
[11:01:28.876]                       if (!has_future || version < "1.8.0") {
[11:01:28.876]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.876]                           "", base::R.version$version.string), 
[11:01:28.876]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.876]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.876]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.876]                             "release", "version")], collapse = " "), 
[11:01:28.876]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.876]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.876]                           info)
[11:01:28.876]                         info <- base::paste(info, collapse = "; ")
[11:01:28.876]                         if (!has_future) {
[11:01:28.876]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.876]                             info)
[11:01:28.876]                         }
[11:01:28.876]                         else {
[11:01:28.876]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.876]                             info, version)
[11:01:28.876]                         }
[11:01:28.876]                         base::stop(msg)
[11:01:28.876]                       }
[11:01:28.876]                     })
[11:01:28.876]                   }
[11:01:28.876]                   ...future.strategy.old <- future::plan("list")
[11:01:28.876]                   options(future.plan = NULL)
[11:01:28.876]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.876]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.876]                 }
[11:01:28.876]                 ...future.workdir <- getwd()
[11:01:28.876]             }
[11:01:28.876]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.876]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.876]         }
[11:01:28.876]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.876]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.876]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.876]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.876]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.876]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.876]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.876]             base::names(...future.oldOptions))
[11:01:28.876]     }
[11:01:28.876]     if (FALSE) {
[11:01:28.876]     }
[11:01:28.876]     else {
[11:01:28.876]         if (TRUE) {
[11:01:28.876]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.876]                 open = "w")
[11:01:28.876]         }
[11:01:28.876]         else {
[11:01:28.876]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.876]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.876]         }
[11:01:28.876]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.876]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.876]             base::sink(type = "output", split = FALSE)
[11:01:28.876]             base::close(...future.stdout)
[11:01:28.876]         }, add = TRUE)
[11:01:28.876]     }
[11:01:28.876]     ...future.frame <- base::sys.nframe()
[11:01:28.876]     ...future.conditions <- base::list()
[11:01:28.876]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.876]     if (FALSE) {
[11:01:28.876]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.876]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.876]     }
[11:01:28.876]     ...future.result <- base::tryCatch({
[11:01:28.876]         base::withCallingHandlers({
[11:01:28.876]             ...future.value <- base::withVisible(base::local({
[11:01:28.876]                 4
[11:01:28.876]             }))
[11:01:28.876]             future::FutureResult(value = ...future.value$value, 
[11:01:28.876]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.876]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.876]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.876]                     ...future.globalenv.names))
[11:01:28.876]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.876]         }, condition = base::local({
[11:01:28.876]             c <- base::c
[11:01:28.876]             inherits <- base::inherits
[11:01:28.876]             invokeRestart <- base::invokeRestart
[11:01:28.876]             length <- base::length
[11:01:28.876]             list <- base::list
[11:01:28.876]             seq.int <- base::seq.int
[11:01:28.876]             signalCondition <- base::signalCondition
[11:01:28.876]             sys.calls <- base::sys.calls
[11:01:28.876]             `[[` <- base::`[[`
[11:01:28.876]             `+` <- base::`+`
[11:01:28.876]             `<<-` <- base::`<<-`
[11:01:28.876]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.876]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.876]                   3L)]
[11:01:28.876]             }
[11:01:28.876]             function(cond) {
[11:01:28.876]                 is_error <- inherits(cond, "error")
[11:01:28.876]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.876]                   NULL)
[11:01:28.876]                 if (is_error) {
[11:01:28.876]                   sessionInformation <- function() {
[11:01:28.876]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.876]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.876]                       search = base::search(), system = base::Sys.info())
[11:01:28.876]                   }
[11:01:28.876]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.876]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.876]                     cond$call), session = sessionInformation(), 
[11:01:28.876]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.876]                   signalCondition(cond)
[11:01:28.876]                 }
[11:01:28.876]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.876]                 "immediateCondition"))) {
[11:01:28.876]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.876]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.876]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.876]                   if (TRUE && !signal) {
[11:01:28.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.876]                     {
[11:01:28.876]                       inherits <- base::inherits
[11:01:28.876]                       invokeRestart <- base::invokeRestart
[11:01:28.876]                       is.null <- base::is.null
[11:01:28.876]                       muffled <- FALSE
[11:01:28.876]                       if (inherits(cond, "message")) {
[11:01:28.876]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.876]                         if (muffled) 
[11:01:28.876]                           invokeRestart("muffleMessage")
[11:01:28.876]                       }
[11:01:28.876]                       else if (inherits(cond, "warning")) {
[11:01:28.876]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.876]                         if (muffled) 
[11:01:28.876]                           invokeRestart("muffleWarning")
[11:01:28.876]                       }
[11:01:28.876]                       else if (inherits(cond, "condition")) {
[11:01:28.876]                         if (!is.null(pattern)) {
[11:01:28.876]                           computeRestarts <- base::computeRestarts
[11:01:28.876]                           grepl <- base::grepl
[11:01:28.876]                           restarts <- computeRestarts(cond)
[11:01:28.876]                           for (restart in restarts) {
[11:01:28.876]                             name <- restart$name
[11:01:28.876]                             if (is.null(name)) 
[11:01:28.876]                               next
[11:01:28.876]                             if (!grepl(pattern, name)) 
[11:01:28.876]                               next
[11:01:28.876]                             invokeRestart(restart)
[11:01:28.876]                             muffled <- TRUE
[11:01:28.876]                             break
[11:01:28.876]                           }
[11:01:28.876]                         }
[11:01:28.876]                       }
[11:01:28.876]                       invisible(muffled)
[11:01:28.876]                     }
[11:01:28.876]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.876]                   }
[11:01:28.876]                 }
[11:01:28.876]                 else {
[11:01:28.876]                   if (TRUE) {
[11:01:28.876]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.876]                     {
[11:01:28.876]                       inherits <- base::inherits
[11:01:28.876]                       invokeRestart <- base::invokeRestart
[11:01:28.876]                       is.null <- base::is.null
[11:01:28.876]                       muffled <- FALSE
[11:01:28.876]                       if (inherits(cond, "message")) {
[11:01:28.876]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.876]                         if (muffled) 
[11:01:28.876]                           invokeRestart("muffleMessage")
[11:01:28.876]                       }
[11:01:28.876]                       else if (inherits(cond, "warning")) {
[11:01:28.876]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.876]                         if (muffled) 
[11:01:28.876]                           invokeRestart("muffleWarning")
[11:01:28.876]                       }
[11:01:28.876]                       else if (inherits(cond, "condition")) {
[11:01:28.876]                         if (!is.null(pattern)) {
[11:01:28.876]                           computeRestarts <- base::computeRestarts
[11:01:28.876]                           grepl <- base::grepl
[11:01:28.876]                           restarts <- computeRestarts(cond)
[11:01:28.876]                           for (restart in restarts) {
[11:01:28.876]                             name <- restart$name
[11:01:28.876]                             if (is.null(name)) 
[11:01:28.876]                               next
[11:01:28.876]                             if (!grepl(pattern, name)) 
[11:01:28.876]                               next
[11:01:28.876]                             invokeRestart(restart)
[11:01:28.876]                             muffled <- TRUE
[11:01:28.876]                             break
[11:01:28.876]                           }
[11:01:28.876]                         }
[11:01:28.876]                       }
[11:01:28.876]                       invisible(muffled)
[11:01:28.876]                     }
[11:01:28.876]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.876]                   }
[11:01:28.876]                 }
[11:01:28.876]             }
[11:01:28.876]         }))
[11:01:28.876]     }, error = function(ex) {
[11:01:28.876]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.876]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.876]                 ...future.rng), started = ...future.startTime, 
[11:01:28.876]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.876]             version = "1.8"), class = "FutureResult")
[11:01:28.876]     }, finally = {
[11:01:28.876]         if (!identical(...future.workdir, getwd())) 
[11:01:28.876]             setwd(...future.workdir)
[11:01:28.876]         {
[11:01:28.876]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.876]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.876]             }
[11:01:28.876]             base::options(...future.oldOptions)
[11:01:28.876]             if (.Platform$OS.type == "windows") {
[11:01:28.876]                 old_names <- names(...future.oldEnvVars)
[11:01:28.876]                 envs <- base::Sys.getenv()
[11:01:28.876]                 names <- names(envs)
[11:01:28.876]                 common <- intersect(names, old_names)
[11:01:28.876]                 added <- setdiff(names, old_names)
[11:01:28.876]                 removed <- setdiff(old_names, names)
[11:01:28.876]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.876]                   envs[common]]
[11:01:28.876]                 NAMES <- toupper(changed)
[11:01:28.876]                 args <- list()
[11:01:28.876]                 for (kk in seq_along(NAMES)) {
[11:01:28.876]                   name <- changed[[kk]]
[11:01:28.876]                   NAME <- NAMES[[kk]]
[11:01:28.876]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.876]                     next
[11:01:28.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.876]                 }
[11:01:28.876]                 NAMES <- toupper(added)
[11:01:28.876]                 for (kk in seq_along(NAMES)) {
[11:01:28.876]                   name <- added[[kk]]
[11:01:28.876]                   NAME <- NAMES[[kk]]
[11:01:28.876]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.876]                     next
[11:01:28.876]                   args[[name]] <- ""
[11:01:28.876]                 }
[11:01:28.876]                 NAMES <- toupper(removed)
[11:01:28.876]                 for (kk in seq_along(NAMES)) {
[11:01:28.876]                   name <- removed[[kk]]
[11:01:28.876]                   NAME <- NAMES[[kk]]
[11:01:28.876]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.876]                     next
[11:01:28.876]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.876]                 }
[11:01:28.876]                 if (length(args) > 0) 
[11:01:28.876]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.876]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.876]             }
[11:01:28.876]             else {
[11:01:28.876]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.876]             }
[11:01:28.876]             {
[11:01:28.876]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.876]                   0L) {
[11:01:28.876]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.876]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.876]                   base::options(opts)
[11:01:28.876]                 }
[11:01:28.876]                 {
[11:01:28.876]                   {
[11:01:28.876]                     NULL
[11:01:28.876]                     RNGkind("Mersenne-Twister")
[11:01:28.876]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.876]                       inherits = FALSE)
[11:01:28.876]                   }
[11:01:28.876]                   options(future.plan = NULL)
[11:01:28.876]                   if (is.na(NA_character_)) 
[11:01:28.876]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.876]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.876]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.876]                     .init = FALSE)
[11:01:28.876]                 }
[11:01:28.876]             }
[11:01:28.876]         }
[11:01:28.876]     })
[11:01:28.876]     if (TRUE) {
[11:01:28.876]         base::sink(type = "output", split = FALSE)
[11:01:28.876]         if (TRUE) {
[11:01:28.876]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.876]         }
[11:01:28.876]         else {
[11:01:28.876]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.876]         }
[11:01:28.876]         base::close(...future.stdout)
[11:01:28.876]         ...future.stdout <- NULL
[11:01:28.876]     }
[11:01:28.876]     ...future.result$conditions <- ...future.conditions
[11:01:28.876]     ...future.result$finished <- base::Sys.time()
[11:01:28.876]     ...future.result
[11:01:28.876] }
[11:01:28.878] plan(): Setting new future strategy stack:
[11:01:28.878] List of future strategies:
[11:01:28.878] 1. sequential:
[11:01:28.878]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.878]    - tweaked: FALSE
[11:01:28.878]    - call: NULL
[11:01:28.878] plan(): nbrOfWorkers() = 1
[11:01:28.879] plan(): Setting new future strategy stack:
[11:01:28.879] List of future strategies:
[11:01:28.879] 1. sequential:
[11:01:28.879]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.879]    - tweaked: FALSE
[11:01:28.879]    - call: plan(strategy)
[11:01:28.879] plan(): nbrOfWorkers() = 1
[11:01:28.879] SequentialFuture started (and completed)
[11:01:28.880] - Launch lazy future ... done
[11:01:28.880] run() for ‘SequentialFuture’ ... done
<environment: 0x55a9c5c666e0> 
<environment: 0x55a9c6bbb0e0> 
[11:01:28.881] resolved() for ‘SequentialFuture’ ...
[11:01:28.881] - state: ‘finished’
[11:01:28.881] - run: TRUE
[11:01:28.881] - result: ‘FutureResult’
[11:01:28.881] resolved() for ‘SequentialFuture’ ... done
[11:01:28.881] resolved() for ‘SequentialFuture’ ...
[11:01:28.881] - state: ‘finished’
[11:01:28.881] - run: TRUE
[11:01:28.881] - result: ‘FutureResult’
[11:01:28.882] resolved() for ‘SequentialFuture’ ... done
[11:01:28.882] resolved() for ‘SequentialFuture’ ...
[11:01:28.882] - state: ‘finished’
[11:01:28.883] - run: TRUE
[11:01:28.883] - result: ‘FutureResult’
[11:01:28.883] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:28.884] resolve() on environment ...
[11:01:28.884]  recursive: 0
[11:01:28.885]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:28.885] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.885] - nx: 4
[11:01:28.885] - relay: TRUE
[11:01:28.885] - stdout: TRUE
[11:01:28.885] - signal: TRUE
[11:01:28.885] - resignal: FALSE
[11:01:28.885] - force: TRUE
[11:01:28.885] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.885] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.885]  - until=2
[11:01:28.885]  - relaying element #2
[11:01:28.885] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.886] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.886] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.886]  length: 3 (resolved future 1)
[11:01:28.886] resolved() for ‘SequentialFuture’ ...
[11:01:28.886] - state: ‘finished’
[11:01:28.886] - run: TRUE
[11:01:28.886] - result: ‘FutureResult’
[11:01:28.886] resolved() for ‘SequentialFuture’ ... done
[11:01:28.886] Future #2
[11:01:28.886] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.886] - nx: 4
[11:01:28.887] - relay: TRUE
[11:01:28.887] - stdout: TRUE
[11:01:28.887] - signal: TRUE
[11:01:28.887] - resignal: FALSE
[11:01:28.887] - force: TRUE
[11:01:28.887] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:28.887] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:28.887]  - until=2
[11:01:28.887]  - relaying element #2
[11:01:28.887] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.887] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.887] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.887]  length: 2 (resolved future 2)
[11:01:28.888] resolved() for ‘SequentialFuture’ ...
[11:01:28.888] - state: ‘finished’
[11:01:28.888] - run: TRUE
[11:01:28.888] - result: ‘FutureResult’
[11:01:28.888] resolved() for ‘SequentialFuture’ ... done
[11:01:28.888] Future #3
[11:01:28.888] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.888] - nx: 4
[11:01:28.888] - relay: TRUE
[11:01:28.888] - stdout: TRUE
[11:01:28.888] - signal: TRUE
[11:01:28.888] - resignal: FALSE
[11:01:28.889] - force: TRUE
[11:01:28.889] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:28.889] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:28.889]  - until=3
[11:01:28.889]  - relaying element #3
[11:01:28.889] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.889] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.889] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.889]  length: 1 (resolved future 3)
[11:01:28.889] resolved() for ‘SequentialFuture’ ...
[11:01:28.889] - state: ‘finished’
[11:01:28.890] - run: TRUE
[11:01:28.890] - result: ‘FutureResult’
[11:01:28.890] resolved() for ‘SequentialFuture’ ... done
[11:01:28.890] Future #4
[11:01:28.890] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:28.890] - nx: 4
[11:01:28.890] - relay: TRUE
[11:01:28.890] - stdout: TRUE
[11:01:28.890] - signal: TRUE
[11:01:28.890] - resignal: FALSE
[11:01:28.890] - force: TRUE
[11:01:28.890] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:28.890] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:28.891]  - until=4
[11:01:28.891]  - relaying element #4
[11:01:28.891] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.891] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.891] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:28.891]  length: 0 (resolved future 4)
[11:01:28.891] Relaying remaining futures
[11:01:28.891] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.891] - nx: 4
[11:01:28.891] - relay: TRUE
[11:01:28.891] - stdout: TRUE
[11:01:28.891] - signal: TRUE
[11:01:28.892] - resignal: FALSE
[11:01:28.892] - force: TRUE
[11:01:28.892] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.892] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:28.892] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:28.892] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:28.892] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.892] resolve() on environment ... DONE
<environment: 0x55a9c5213c50> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: sequential
[11:01:28.893] plan(): Setting new future strategy stack:
[11:01:28.893] List of future strategies:
[11:01:28.893] 1. sequential:
[11:01:28.893]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.893]    - tweaked: FALSE
[11:01:28.893]    - call: plan(strategy)
[11:01:28.893] plan(): nbrOfWorkers() = 1
Dimensions: NULL
[11:01:28.894] getGlobalsAndPackages() ...
[11:01:28.894] Searching for globals...
[11:01:28.894] 
[11:01:28.894] Searching for globals ... DONE
[11:01:28.894] - globals: [0] <none>
[11:01:28.894] getGlobalsAndPackages() ... DONE
[11:01:28.894] run() for ‘Future’ ...
[11:01:28.895] - state: ‘created’
[11:01:28.895] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.895] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.895] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.895]   - Field: ‘label’
[11:01:28.895]   - Field: ‘local’
[11:01:28.895]   - Field: ‘owner’
[11:01:28.895]   - Field: ‘envir’
[11:01:28.895]   - Field: ‘packages’
[11:01:28.895]   - Field: ‘gc’
[11:01:28.896]   - Field: ‘conditions’
[11:01:28.896]   - Field: ‘expr’
[11:01:28.896]   - Field: ‘uuid’
[11:01:28.896]   - Field: ‘seed’
[11:01:28.896]   - Field: ‘version’
[11:01:28.896]   - Field: ‘result’
[11:01:28.896]   - Field: ‘asynchronous’
[11:01:28.896]   - Field: ‘calls’
[11:01:28.896]   - Field: ‘globals’
[11:01:28.896]   - Field: ‘stdout’
[11:01:28.896]   - Field: ‘earlySignal’
[11:01:28.896]   - Field: ‘lazy’
[11:01:28.897]   - Field: ‘state’
[11:01:28.897] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.897] - Launch lazy future ...
[11:01:28.897] Packages needed by the future expression (n = 0): <none>
[11:01:28.897] Packages needed by future strategies (n = 0): <none>
[11:01:28.897] {
[11:01:28.897]     {
[11:01:28.897]         {
[11:01:28.897]             ...future.startTime <- base::Sys.time()
[11:01:28.897]             {
[11:01:28.897]                 {
[11:01:28.897]                   {
[11:01:28.897]                     base::local({
[11:01:28.897]                       has_future <- base::requireNamespace("future", 
[11:01:28.897]                         quietly = TRUE)
[11:01:28.897]                       if (has_future) {
[11:01:28.897]                         ns <- base::getNamespace("future")
[11:01:28.897]                         version <- ns[[".package"]][["version"]]
[11:01:28.897]                         if (is.null(version)) 
[11:01:28.897]                           version <- utils::packageVersion("future")
[11:01:28.897]                       }
[11:01:28.897]                       else {
[11:01:28.897]                         version <- NULL
[11:01:28.897]                       }
[11:01:28.897]                       if (!has_future || version < "1.8.0") {
[11:01:28.897]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.897]                           "", base::R.version$version.string), 
[11:01:28.897]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.897]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.897]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.897]                             "release", "version")], collapse = " "), 
[11:01:28.897]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.897]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.897]                           info)
[11:01:28.897]                         info <- base::paste(info, collapse = "; ")
[11:01:28.897]                         if (!has_future) {
[11:01:28.897]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.897]                             info)
[11:01:28.897]                         }
[11:01:28.897]                         else {
[11:01:28.897]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.897]                             info, version)
[11:01:28.897]                         }
[11:01:28.897]                         base::stop(msg)
[11:01:28.897]                       }
[11:01:28.897]                     })
[11:01:28.897]                   }
[11:01:28.897]                   ...future.strategy.old <- future::plan("list")
[11:01:28.897]                   options(future.plan = NULL)
[11:01:28.897]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.897]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.897]                 }
[11:01:28.897]                 ...future.workdir <- getwd()
[11:01:28.897]             }
[11:01:28.897]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.897]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.897]         }
[11:01:28.897]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.897]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.897]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.897]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.897]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.897]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.897]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.897]             base::names(...future.oldOptions))
[11:01:28.897]     }
[11:01:28.897]     if (FALSE) {
[11:01:28.897]     }
[11:01:28.897]     else {
[11:01:28.897]         if (TRUE) {
[11:01:28.897]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.897]                 open = "w")
[11:01:28.897]         }
[11:01:28.897]         else {
[11:01:28.897]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.897]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.897]         }
[11:01:28.897]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.897]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.897]             base::sink(type = "output", split = FALSE)
[11:01:28.897]             base::close(...future.stdout)
[11:01:28.897]         }, add = TRUE)
[11:01:28.897]     }
[11:01:28.897]     ...future.frame <- base::sys.nframe()
[11:01:28.897]     ...future.conditions <- base::list()
[11:01:28.897]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.897]     if (FALSE) {
[11:01:28.897]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.897]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.897]     }
[11:01:28.897]     ...future.result <- base::tryCatch({
[11:01:28.897]         base::withCallingHandlers({
[11:01:28.897]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.897]             future::FutureResult(value = ...future.value$value, 
[11:01:28.897]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.897]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.897]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.897]                     ...future.globalenv.names))
[11:01:28.897]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.897]         }, condition = base::local({
[11:01:28.897]             c <- base::c
[11:01:28.897]             inherits <- base::inherits
[11:01:28.897]             invokeRestart <- base::invokeRestart
[11:01:28.897]             length <- base::length
[11:01:28.897]             list <- base::list
[11:01:28.897]             seq.int <- base::seq.int
[11:01:28.897]             signalCondition <- base::signalCondition
[11:01:28.897]             sys.calls <- base::sys.calls
[11:01:28.897]             `[[` <- base::`[[`
[11:01:28.897]             `+` <- base::`+`
[11:01:28.897]             `<<-` <- base::`<<-`
[11:01:28.897]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.897]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.897]                   3L)]
[11:01:28.897]             }
[11:01:28.897]             function(cond) {
[11:01:28.897]                 is_error <- inherits(cond, "error")
[11:01:28.897]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.897]                   NULL)
[11:01:28.897]                 if (is_error) {
[11:01:28.897]                   sessionInformation <- function() {
[11:01:28.897]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.897]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.897]                       search = base::search(), system = base::Sys.info())
[11:01:28.897]                   }
[11:01:28.897]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.897]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.897]                     cond$call), session = sessionInformation(), 
[11:01:28.897]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.897]                   signalCondition(cond)
[11:01:28.897]                 }
[11:01:28.897]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.897]                 "immediateCondition"))) {
[11:01:28.897]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.897]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.897]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.897]                   if (TRUE && !signal) {
[11:01:28.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.897]                     {
[11:01:28.897]                       inherits <- base::inherits
[11:01:28.897]                       invokeRestart <- base::invokeRestart
[11:01:28.897]                       is.null <- base::is.null
[11:01:28.897]                       muffled <- FALSE
[11:01:28.897]                       if (inherits(cond, "message")) {
[11:01:28.897]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.897]                         if (muffled) 
[11:01:28.897]                           invokeRestart("muffleMessage")
[11:01:28.897]                       }
[11:01:28.897]                       else if (inherits(cond, "warning")) {
[11:01:28.897]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.897]                         if (muffled) 
[11:01:28.897]                           invokeRestart("muffleWarning")
[11:01:28.897]                       }
[11:01:28.897]                       else if (inherits(cond, "condition")) {
[11:01:28.897]                         if (!is.null(pattern)) {
[11:01:28.897]                           computeRestarts <- base::computeRestarts
[11:01:28.897]                           grepl <- base::grepl
[11:01:28.897]                           restarts <- computeRestarts(cond)
[11:01:28.897]                           for (restart in restarts) {
[11:01:28.897]                             name <- restart$name
[11:01:28.897]                             if (is.null(name)) 
[11:01:28.897]                               next
[11:01:28.897]                             if (!grepl(pattern, name)) 
[11:01:28.897]                               next
[11:01:28.897]                             invokeRestart(restart)
[11:01:28.897]                             muffled <- TRUE
[11:01:28.897]                             break
[11:01:28.897]                           }
[11:01:28.897]                         }
[11:01:28.897]                       }
[11:01:28.897]                       invisible(muffled)
[11:01:28.897]                     }
[11:01:28.897]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.897]                   }
[11:01:28.897]                 }
[11:01:28.897]                 else {
[11:01:28.897]                   if (TRUE) {
[11:01:28.897]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.897]                     {
[11:01:28.897]                       inherits <- base::inherits
[11:01:28.897]                       invokeRestart <- base::invokeRestart
[11:01:28.897]                       is.null <- base::is.null
[11:01:28.897]                       muffled <- FALSE
[11:01:28.897]                       if (inherits(cond, "message")) {
[11:01:28.897]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.897]                         if (muffled) 
[11:01:28.897]                           invokeRestart("muffleMessage")
[11:01:28.897]                       }
[11:01:28.897]                       else if (inherits(cond, "warning")) {
[11:01:28.897]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.897]                         if (muffled) 
[11:01:28.897]                           invokeRestart("muffleWarning")
[11:01:28.897]                       }
[11:01:28.897]                       else if (inherits(cond, "condition")) {
[11:01:28.897]                         if (!is.null(pattern)) {
[11:01:28.897]                           computeRestarts <- base::computeRestarts
[11:01:28.897]                           grepl <- base::grepl
[11:01:28.897]                           restarts <- computeRestarts(cond)
[11:01:28.897]                           for (restart in restarts) {
[11:01:28.897]                             name <- restart$name
[11:01:28.897]                             if (is.null(name)) 
[11:01:28.897]                               next
[11:01:28.897]                             if (!grepl(pattern, name)) 
[11:01:28.897]                               next
[11:01:28.897]                             invokeRestart(restart)
[11:01:28.897]                             muffled <- TRUE
[11:01:28.897]                             break
[11:01:28.897]                           }
[11:01:28.897]                         }
[11:01:28.897]                       }
[11:01:28.897]                       invisible(muffled)
[11:01:28.897]                     }
[11:01:28.897]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.897]                   }
[11:01:28.897]                 }
[11:01:28.897]             }
[11:01:28.897]         }))
[11:01:28.897]     }, error = function(ex) {
[11:01:28.897]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.897]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.897]                 ...future.rng), started = ...future.startTime, 
[11:01:28.897]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.897]             version = "1.8"), class = "FutureResult")
[11:01:28.897]     }, finally = {
[11:01:28.897]         if (!identical(...future.workdir, getwd())) 
[11:01:28.897]             setwd(...future.workdir)
[11:01:28.897]         {
[11:01:28.897]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.897]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.897]             }
[11:01:28.897]             base::options(...future.oldOptions)
[11:01:28.897]             if (.Platform$OS.type == "windows") {
[11:01:28.897]                 old_names <- names(...future.oldEnvVars)
[11:01:28.897]                 envs <- base::Sys.getenv()
[11:01:28.897]                 names <- names(envs)
[11:01:28.897]                 common <- intersect(names, old_names)
[11:01:28.897]                 added <- setdiff(names, old_names)
[11:01:28.897]                 removed <- setdiff(old_names, names)
[11:01:28.897]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.897]                   envs[common]]
[11:01:28.897]                 NAMES <- toupper(changed)
[11:01:28.897]                 args <- list()
[11:01:28.897]                 for (kk in seq_along(NAMES)) {
[11:01:28.897]                   name <- changed[[kk]]
[11:01:28.897]                   NAME <- NAMES[[kk]]
[11:01:28.897]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.897]                     next
[11:01:28.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.897]                 }
[11:01:28.897]                 NAMES <- toupper(added)
[11:01:28.897]                 for (kk in seq_along(NAMES)) {
[11:01:28.897]                   name <- added[[kk]]
[11:01:28.897]                   NAME <- NAMES[[kk]]
[11:01:28.897]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.897]                     next
[11:01:28.897]                   args[[name]] <- ""
[11:01:28.897]                 }
[11:01:28.897]                 NAMES <- toupper(removed)
[11:01:28.897]                 for (kk in seq_along(NAMES)) {
[11:01:28.897]                   name <- removed[[kk]]
[11:01:28.897]                   NAME <- NAMES[[kk]]
[11:01:28.897]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.897]                     next
[11:01:28.897]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.897]                 }
[11:01:28.897]                 if (length(args) > 0) 
[11:01:28.897]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.897]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.897]             }
[11:01:28.897]             else {
[11:01:28.897]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.897]             }
[11:01:28.897]             {
[11:01:28.897]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.897]                   0L) {
[11:01:28.897]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.897]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.897]                   base::options(opts)
[11:01:28.897]                 }
[11:01:28.897]                 {
[11:01:28.897]                   {
[11:01:28.897]                     NULL
[11:01:28.897]                     RNGkind("Mersenne-Twister")
[11:01:28.897]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.897]                       inherits = FALSE)
[11:01:28.897]                   }
[11:01:28.897]                   options(future.plan = NULL)
[11:01:28.897]                   if (is.na(NA_character_)) 
[11:01:28.897]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.897]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.897]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.897]                     .init = FALSE)
[11:01:28.897]                 }
[11:01:28.897]             }
[11:01:28.897]         }
[11:01:28.897]     })
[11:01:28.897]     if (TRUE) {
[11:01:28.897]         base::sink(type = "output", split = FALSE)
[11:01:28.897]         if (TRUE) {
[11:01:28.897]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.897]         }
[11:01:28.897]         else {
[11:01:28.897]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.897]         }
[11:01:28.897]         base::close(...future.stdout)
[11:01:28.897]         ...future.stdout <- NULL
[11:01:28.897]     }
[11:01:28.897]     ...future.result$conditions <- ...future.conditions
[11:01:28.897]     ...future.result$finished <- base::Sys.time()
[11:01:28.897]     ...future.result
[11:01:28.897] }
[11:01:28.899] plan(): Setting new future strategy stack:
[11:01:28.899] List of future strategies:
[11:01:28.899] 1. sequential:
[11:01:28.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.899]    - tweaked: FALSE
[11:01:28.899]    - call: NULL
[11:01:28.900] plan(): nbrOfWorkers() = 1
[11:01:28.900] plan(): Setting new future strategy stack:
[11:01:28.900] List of future strategies:
[11:01:28.900] 1. sequential:
[11:01:28.900]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.900]    - tweaked: FALSE
[11:01:28.900]    - call: plan(strategy)
[11:01:28.901] plan(): nbrOfWorkers() = 1
[11:01:28.901] SequentialFuture started (and completed)
[11:01:28.901] - Launch lazy future ... done
[11:01:28.901] run() for ‘SequentialFuture’ ... done
[11:01:28.901] getGlobalsAndPackages() ...
[11:01:28.901] Searching for globals...
[11:01:28.901] 
[11:01:28.902] Searching for globals ... DONE
[11:01:28.902] - globals: [0] <none>
[11:01:28.902] getGlobalsAndPackages() ... DONE
[11:01:28.902] run() for ‘Future’ ...
[11:01:28.902] - state: ‘created’
[11:01:28.902] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.902] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.902] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.903]   - Field: ‘label’
[11:01:28.903]   - Field: ‘local’
[11:01:28.903]   - Field: ‘owner’
[11:01:28.903]   - Field: ‘envir’
[11:01:28.903]   - Field: ‘packages’
[11:01:28.903]   - Field: ‘gc’
[11:01:28.903]   - Field: ‘conditions’
[11:01:28.903]   - Field: ‘expr’
[11:01:28.903]   - Field: ‘uuid’
[11:01:28.903]   - Field: ‘seed’
[11:01:28.903]   - Field: ‘version’
[11:01:28.903]   - Field: ‘result’
[11:01:28.904]   - Field: ‘asynchronous’
[11:01:28.904]   - Field: ‘calls’
[11:01:28.904]   - Field: ‘globals’
[11:01:28.904]   - Field: ‘stdout’
[11:01:28.904]   - Field: ‘earlySignal’
[11:01:28.904]   - Field: ‘lazy’
[11:01:28.904]   - Field: ‘state’
[11:01:28.904] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.904] - Launch lazy future ...
[11:01:28.904] Packages needed by the future expression (n = 0): <none>
[11:01:28.905] Packages needed by future strategies (n = 0): <none>
[11:01:28.906] {
[11:01:28.906]     {
[11:01:28.906]         {
[11:01:28.906]             ...future.startTime <- base::Sys.time()
[11:01:28.906]             {
[11:01:28.906]                 {
[11:01:28.906]                   {
[11:01:28.906]                     base::local({
[11:01:28.906]                       has_future <- base::requireNamespace("future", 
[11:01:28.906]                         quietly = TRUE)
[11:01:28.906]                       if (has_future) {
[11:01:28.906]                         ns <- base::getNamespace("future")
[11:01:28.906]                         version <- ns[[".package"]][["version"]]
[11:01:28.906]                         if (is.null(version)) 
[11:01:28.906]                           version <- utils::packageVersion("future")
[11:01:28.906]                       }
[11:01:28.906]                       else {
[11:01:28.906]                         version <- NULL
[11:01:28.906]                       }
[11:01:28.906]                       if (!has_future || version < "1.8.0") {
[11:01:28.906]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.906]                           "", base::R.version$version.string), 
[11:01:28.906]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.906]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.906]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.906]                             "release", "version")], collapse = " "), 
[11:01:28.906]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.906]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.906]                           info)
[11:01:28.906]                         info <- base::paste(info, collapse = "; ")
[11:01:28.906]                         if (!has_future) {
[11:01:28.906]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.906]                             info)
[11:01:28.906]                         }
[11:01:28.906]                         else {
[11:01:28.906]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.906]                             info, version)
[11:01:28.906]                         }
[11:01:28.906]                         base::stop(msg)
[11:01:28.906]                       }
[11:01:28.906]                     })
[11:01:28.906]                   }
[11:01:28.906]                   ...future.strategy.old <- future::plan("list")
[11:01:28.906]                   options(future.plan = NULL)
[11:01:28.906]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.906]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.906]                 }
[11:01:28.906]                 ...future.workdir <- getwd()
[11:01:28.906]             }
[11:01:28.906]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.906]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.906]         }
[11:01:28.906]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.906]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.906]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.906]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.906]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.906]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.906]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.906]             base::names(...future.oldOptions))
[11:01:28.906]     }
[11:01:28.906]     if (FALSE) {
[11:01:28.906]     }
[11:01:28.906]     else {
[11:01:28.906]         if (TRUE) {
[11:01:28.906]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.906]                 open = "w")
[11:01:28.906]         }
[11:01:28.906]         else {
[11:01:28.906]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.906]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.906]         }
[11:01:28.906]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.906]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.906]             base::sink(type = "output", split = FALSE)
[11:01:28.906]             base::close(...future.stdout)
[11:01:28.906]         }, add = TRUE)
[11:01:28.906]     }
[11:01:28.906]     ...future.frame <- base::sys.nframe()
[11:01:28.906]     ...future.conditions <- base::list()
[11:01:28.906]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.906]     if (FALSE) {
[11:01:28.906]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.906]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.906]     }
[11:01:28.906]     ...future.result <- base::tryCatch({
[11:01:28.906]         base::withCallingHandlers({
[11:01:28.906]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.906]             future::FutureResult(value = ...future.value$value, 
[11:01:28.906]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.906]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.906]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.906]                     ...future.globalenv.names))
[11:01:28.906]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.906]         }, condition = base::local({
[11:01:28.906]             c <- base::c
[11:01:28.906]             inherits <- base::inherits
[11:01:28.906]             invokeRestart <- base::invokeRestart
[11:01:28.906]             length <- base::length
[11:01:28.906]             list <- base::list
[11:01:28.906]             seq.int <- base::seq.int
[11:01:28.906]             signalCondition <- base::signalCondition
[11:01:28.906]             sys.calls <- base::sys.calls
[11:01:28.906]             `[[` <- base::`[[`
[11:01:28.906]             `+` <- base::`+`
[11:01:28.906]             `<<-` <- base::`<<-`
[11:01:28.906]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.906]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.906]                   3L)]
[11:01:28.906]             }
[11:01:28.906]             function(cond) {
[11:01:28.906]                 is_error <- inherits(cond, "error")
[11:01:28.906]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.906]                   NULL)
[11:01:28.906]                 if (is_error) {
[11:01:28.906]                   sessionInformation <- function() {
[11:01:28.906]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.906]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.906]                       search = base::search(), system = base::Sys.info())
[11:01:28.906]                   }
[11:01:28.906]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.906]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.906]                     cond$call), session = sessionInformation(), 
[11:01:28.906]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.906]                   signalCondition(cond)
[11:01:28.906]                 }
[11:01:28.906]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.906]                 "immediateCondition"))) {
[11:01:28.906]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.906]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.906]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.906]                   if (TRUE && !signal) {
[11:01:28.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.906]                     {
[11:01:28.906]                       inherits <- base::inherits
[11:01:28.906]                       invokeRestart <- base::invokeRestart
[11:01:28.906]                       is.null <- base::is.null
[11:01:28.906]                       muffled <- FALSE
[11:01:28.906]                       if (inherits(cond, "message")) {
[11:01:28.906]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.906]                         if (muffled) 
[11:01:28.906]                           invokeRestart("muffleMessage")
[11:01:28.906]                       }
[11:01:28.906]                       else if (inherits(cond, "warning")) {
[11:01:28.906]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.906]                         if (muffled) 
[11:01:28.906]                           invokeRestart("muffleWarning")
[11:01:28.906]                       }
[11:01:28.906]                       else if (inherits(cond, "condition")) {
[11:01:28.906]                         if (!is.null(pattern)) {
[11:01:28.906]                           computeRestarts <- base::computeRestarts
[11:01:28.906]                           grepl <- base::grepl
[11:01:28.906]                           restarts <- computeRestarts(cond)
[11:01:28.906]                           for (restart in restarts) {
[11:01:28.906]                             name <- restart$name
[11:01:28.906]                             if (is.null(name)) 
[11:01:28.906]                               next
[11:01:28.906]                             if (!grepl(pattern, name)) 
[11:01:28.906]                               next
[11:01:28.906]                             invokeRestart(restart)
[11:01:28.906]                             muffled <- TRUE
[11:01:28.906]                             break
[11:01:28.906]                           }
[11:01:28.906]                         }
[11:01:28.906]                       }
[11:01:28.906]                       invisible(muffled)
[11:01:28.906]                     }
[11:01:28.906]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.906]                   }
[11:01:28.906]                 }
[11:01:28.906]                 else {
[11:01:28.906]                   if (TRUE) {
[11:01:28.906]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.906]                     {
[11:01:28.906]                       inherits <- base::inherits
[11:01:28.906]                       invokeRestart <- base::invokeRestart
[11:01:28.906]                       is.null <- base::is.null
[11:01:28.906]                       muffled <- FALSE
[11:01:28.906]                       if (inherits(cond, "message")) {
[11:01:28.906]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.906]                         if (muffled) 
[11:01:28.906]                           invokeRestart("muffleMessage")
[11:01:28.906]                       }
[11:01:28.906]                       else if (inherits(cond, "warning")) {
[11:01:28.906]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.906]                         if (muffled) 
[11:01:28.906]                           invokeRestart("muffleWarning")
[11:01:28.906]                       }
[11:01:28.906]                       else if (inherits(cond, "condition")) {
[11:01:28.906]                         if (!is.null(pattern)) {
[11:01:28.906]                           computeRestarts <- base::computeRestarts
[11:01:28.906]                           grepl <- base::grepl
[11:01:28.906]                           restarts <- computeRestarts(cond)
[11:01:28.906]                           for (restart in restarts) {
[11:01:28.906]                             name <- restart$name
[11:01:28.906]                             if (is.null(name)) 
[11:01:28.906]                               next
[11:01:28.906]                             if (!grepl(pattern, name)) 
[11:01:28.906]                               next
[11:01:28.906]                             invokeRestart(restart)
[11:01:28.906]                             muffled <- TRUE
[11:01:28.906]                             break
[11:01:28.906]                           }
[11:01:28.906]                         }
[11:01:28.906]                       }
[11:01:28.906]                       invisible(muffled)
[11:01:28.906]                     }
[11:01:28.906]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.906]                   }
[11:01:28.906]                 }
[11:01:28.906]             }
[11:01:28.906]         }))
[11:01:28.906]     }, error = function(ex) {
[11:01:28.906]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.906]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.906]                 ...future.rng), started = ...future.startTime, 
[11:01:28.906]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.906]             version = "1.8"), class = "FutureResult")
[11:01:28.906]     }, finally = {
[11:01:28.906]         if (!identical(...future.workdir, getwd())) 
[11:01:28.906]             setwd(...future.workdir)
[11:01:28.906]         {
[11:01:28.906]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.906]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.906]             }
[11:01:28.906]             base::options(...future.oldOptions)
[11:01:28.906]             if (.Platform$OS.type == "windows") {
[11:01:28.906]                 old_names <- names(...future.oldEnvVars)
[11:01:28.906]                 envs <- base::Sys.getenv()
[11:01:28.906]                 names <- names(envs)
[11:01:28.906]                 common <- intersect(names, old_names)
[11:01:28.906]                 added <- setdiff(names, old_names)
[11:01:28.906]                 removed <- setdiff(old_names, names)
[11:01:28.906]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.906]                   envs[common]]
[11:01:28.906]                 NAMES <- toupper(changed)
[11:01:28.906]                 args <- list()
[11:01:28.906]                 for (kk in seq_along(NAMES)) {
[11:01:28.906]                   name <- changed[[kk]]
[11:01:28.906]                   NAME <- NAMES[[kk]]
[11:01:28.906]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.906]                     next
[11:01:28.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.906]                 }
[11:01:28.906]                 NAMES <- toupper(added)
[11:01:28.906]                 for (kk in seq_along(NAMES)) {
[11:01:28.906]                   name <- added[[kk]]
[11:01:28.906]                   NAME <- NAMES[[kk]]
[11:01:28.906]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.906]                     next
[11:01:28.906]                   args[[name]] <- ""
[11:01:28.906]                 }
[11:01:28.906]                 NAMES <- toupper(removed)
[11:01:28.906]                 for (kk in seq_along(NAMES)) {
[11:01:28.906]                   name <- removed[[kk]]
[11:01:28.906]                   NAME <- NAMES[[kk]]
[11:01:28.906]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.906]                     next
[11:01:28.906]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.906]                 }
[11:01:28.906]                 if (length(args) > 0) 
[11:01:28.906]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.906]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.906]             }
[11:01:28.906]             else {
[11:01:28.906]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.906]             }
[11:01:28.906]             {
[11:01:28.906]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.906]                   0L) {
[11:01:28.906]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.906]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.906]                   base::options(opts)
[11:01:28.906]                 }
[11:01:28.906]                 {
[11:01:28.906]                   {
[11:01:28.906]                     NULL
[11:01:28.906]                     RNGkind("Mersenne-Twister")
[11:01:28.906]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.906]                       inherits = FALSE)
[11:01:28.906]                   }
[11:01:28.906]                   options(future.plan = NULL)
[11:01:28.906]                   if (is.na(NA_character_)) 
[11:01:28.906]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.906]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.906]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.906]                     .init = FALSE)
[11:01:28.906]                 }
[11:01:28.906]             }
[11:01:28.906]         }
[11:01:28.906]     })
[11:01:28.906]     if (TRUE) {
[11:01:28.906]         base::sink(type = "output", split = FALSE)
[11:01:28.906]         if (TRUE) {
[11:01:28.906]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.906]         }
[11:01:28.906]         else {
[11:01:28.906]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.906]         }
[11:01:28.906]         base::close(...future.stdout)
[11:01:28.906]         ...future.stdout <- NULL
[11:01:28.906]     }
[11:01:28.906]     ...future.result$conditions <- ...future.conditions
[11:01:28.906]     ...future.result$finished <- base::Sys.time()
[11:01:28.906]     ...future.result
[11:01:28.906] }
[11:01:28.907] plan(): Setting new future strategy stack:
[11:01:28.908] List of future strategies:
[11:01:28.908] 1. sequential:
[11:01:28.908]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.908]    - tweaked: FALSE
[11:01:28.908]    - call: NULL
[11:01:28.908] plan(): nbrOfWorkers() = 1
[11:01:28.909] plan(): Setting new future strategy stack:
[11:01:28.909] List of future strategies:
[11:01:28.909] 1. sequential:
[11:01:28.909]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.909]    - tweaked: FALSE
[11:01:28.909]    - call: plan(strategy)
[11:01:28.909] plan(): nbrOfWorkers() = 1
[11:01:28.909] SequentialFuture started (and completed)
[11:01:28.909] - Launch lazy future ... done
[11:01:28.909] run() for ‘SequentialFuture’ ... done
[11:01:28.910] getGlobalsAndPackages() ...
[11:01:28.910] Searching for globals...
[11:01:28.911] - globals found: [1] ‘{’
[11:01:28.911] Searching for globals ... DONE
[11:01:28.911] Resolving globals: FALSE
[11:01:28.911] 
[11:01:28.911] 
[11:01:28.911] getGlobalsAndPackages() ... DONE
[11:01:28.911] run() for ‘Future’ ...
[11:01:28.911] - state: ‘created’
[11:01:28.912] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.912] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.912] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.912]   - Field: ‘label’
[11:01:28.912]   - Field: ‘local’
[11:01:28.912]   - Field: ‘owner’
[11:01:28.912]   - Field: ‘envir’
[11:01:28.912]   - Field: ‘packages’
[11:01:28.912]   - Field: ‘gc’
[11:01:28.912]   - Field: ‘conditions’
[11:01:28.913]   - Field: ‘expr’
[11:01:28.913]   - Field: ‘uuid’
[11:01:28.913]   - Field: ‘seed’
[11:01:28.913]   - Field: ‘version’
[11:01:28.913]   - Field: ‘result’
[11:01:28.913]   - Field: ‘asynchronous’
[11:01:28.913]   - Field: ‘calls’
[11:01:28.913]   - Field: ‘globals’
[11:01:28.913]   - Field: ‘stdout’
[11:01:28.913]   - Field: ‘earlySignal’
[11:01:28.913]   - Field: ‘lazy’
[11:01:28.913]   - Field: ‘state’
[11:01:28.913] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.914] - Launch lazy future ...
[11:01:28.914] Packages needed by the future expression (n = 0): <none>
[11:01:28.914] Packages needed by future strategies (n = 0): <none>
[11:01:28.914] {
[11:01:28.914]     {
[11:01:28.914]         {
[11:01:28.914]             ...future.startTime <- base::Sys.time()
[11:01:28.914]             {
[11:01:28.914]                 {
[11:01:28.914]                   {
[11:01:28.914]                     base::local({
[11:01:28.914]                       has_future <- base::requireNamespace("future", 
[11:01:28.914]                         quietly = TRUE)
[11:01:28.914]                       if (has_future) {
[11:01:28.914]                         ns <- base::getNamespace("future")
[11:01:28.914]                         version <- ns[[".package"]][["version"]]
[11:01:28.914]                         if (is.null(version)) 
[11:01:28.914]                           version <- utils::packageVersion("future")
[11:01:28.914]                       }
[11:01:28.914]                       else {
[11:01:28.914]                         version <- NULL
[11:01:28.914]                       }
[11:01:28.914]                       if (!has_future || version < "1.8.0") {
[11:01:28.914]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.914]                           "", base::R.version$version.string), 
[11:01:28.914]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.914]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.914]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.914]                             "release", "version")], collapse = " "), 
[11:01:28.914]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.914]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.914]                           info)
[11:01:28.914]                         info <- base::paste(info, collapse = "; ")
[11:01:28.914]                         if (!has_future) {
[11:01:28.914]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.914]                             info)
[11:01:28.914]                         }
[11:01:28.914]                         else {
[11:01:28.914]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.914]                             info, version)
[11:01:28.914]                         }
[11:01:28.914]                         base::stop(msg)
[11:01:28.914]                       }
[11:01:28.914]                     })
[11:01:28.914]                   }
[11:01:28.914]                   ...future.strategy.old <- future::plan("list")
[11:01:28.914]                   options(future.plan = NULL)
[11:01:28.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.914]                 }
[11:01:28.914]                 ...future.workdir <- getwd()
[11:01:28.914]             }
[11:01:28.914]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.914]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.914]         }
[11:01:28.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.914]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.914]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.914]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.914]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.914]             base::names(...future.oldOptions))
[11:01:28.914]     }
[11:01:28.914]     if (FALSE) {
[11:01:28.914]     }
[11:01:28.914]     else {
[11:01:28.914]         if (TRUE) {
[11:01:28.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.914]                 open = "w")
[11:01:28.914]         }
[11:01:28.914]         else {
[11:01:28.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.914]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.914]         }
[11:01:28.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.914]             base::sink(type = "output", split = FALSE)
[11:01:28.914]             base::close(...future.stdout)
[11:01:28.914]         }, add = TRUE)
[11:01:28.914]     }
[11:01:28.914]     ...future.frame <- base::sys.nframe()
[11:01:28.914]     ...future.conditions <- base::list()
[11:01:28.914]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.914]     if (FALSE) {
[11:01:28.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.914]     }
[11:01:28.914]     ...future.result <- base::tryCatch({
[11:01:28.914]         base::withCallingHandlers({
[11:01:28.914]             ...future.value <- base::withVisible(base::local({
[11:01:28.914]                 4
[11:01:28.914]             }))
[11:01:28.914]             future::FutureResult(value = ...future.value$value, 
[11:01:28.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.914]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.914]                     ...future.globalenv.names))
[11:01:28.914]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.914]         }, condition = base::local({
[11:01:28.914]             c <- base::c
[11:01:28.914]             inherits <- base::inherits
[11:01:28.914]             invokeRestart <- base::invokeRestart
[11:01:28.914]             length <- base::length
[11:01:28.914]             list <- base::list
[11:01:28.914]             seq.int <- base::seq.int
[11:01:28.914]             signalCondition <- base::signalCondition
[11:01:28.914]             sys.calls <- base::sys.calls
[11:01:28.914]             `[[` <- base::`[[`
[11:01:28.914]             `+` <- base::`+`
[11:01:28.914]             `<<-` <- base::`<<-`
[11:01:28.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.914]                   3L)]
[11:01:28.914]             }
[11:01:28.914]             function(cond) {
[11:01:28.914]                 is_error <- inherits(cond, "error")
[11:01:28.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.914]                   NULL)
[11:01:28.914]                 if (is_error) {
[11:01:28.914]                   sessionInformation <- function() {
[11:01:28.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.914]                       search = base::search(), system = base::Sys.info())
[11:01:28.914]                   }
[11:01:28.914]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.914]                     cond$call), session = sessionInformation(), 
[11:01:28.914]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.914]                   signalCondition(cond)
[11:01:28.914]                 }
[11:01:28.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.914]                 "immediateCondition"))) {
[11:01:28.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.914]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.914]                   if (TRUE && !signal) {
[11:01:28.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.914]                     {
[11:01:28.914]                       inherits <- base::inherits
[11:01:28.914]                       invokeRestart <- base::invokeRestart
[11:01:28.914]                       is.null <- base::is.null
[11:01:28.914]                       muffled <- FALSE
[11:01:28.914]                       if (inherits(cond, "message")) {
[11:01:28.914]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.914]                         if (muffled) 
[11:01:28.914]                           invokeRestart("muffleMessage")
[11:01:28.914]                       }
[11:01:28.914]                       else if (inherits(cond, "warning")) {
[11:01:28.914]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.914]                         if (muffled) 
[11:01:28.914]                           invokeRestart("muffleWarning")
[11:01:28.914]                       }
[11:01:28.914]                       else if (inherits(cond, "condition")) {
[11:01:28.914]                         if (!is.null(pattern)) {
[11:01:28.914]                           computeRestarts <- base::computeRestarts
[11:01:28.914]                           grepl <- base::grepl
[11:01:28.914]                           restarts <- computeRestarts(cond)
[11:01:28.914]                           for (restart in restarts) {
[11:01:28.914]                             name <- restart$name
[11:01:28.914]                             if (is.null(name)) 
[11:01:28.914]                               next
[11:01:28.914]                             if (!grepl(pattern, name)) 
[11:01:28.914]                               next
[11:01:28.914]                             invokeRestart(restart)
[11:01:28.914]                             muffled <- TRUE
[11:01:28.914]                             break
[11:01:28.914]                           }
[11:01:28.914]                         }
[11:01:28.914]                       }
[11:01:28.914]                       invisible(muffled)
[11:01:28.914]                     }
[11:01:28.914]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.914]                   }
[11:01:28.914]                 }
[11:01:28.914]                 else {
[11:01:28.914]                   if (TRUE) {
[11:01:28.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.914]                     {
[11:01:28.914]                       inherits <- base::inherits
[11:01:28.914]                       invokeRestart <- base::invokeRestart
[11:01:28.914]                       is.null <- base::is.null
[11:01:28.914]                       muffled <- FALSE
[11:01:28.914]                       if (inherits(cond, "message")) {
[11:01:28.914]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.914]                         if (muffled) 
[11:01:28.914]                           invokeRestart("muffleMessage")
[11:01:28.914]                       }
[11:01:28.914]                       else if (inherits(cond, "warning")) {
[11:01:28.914]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.914]                         if (muffled) 
[11:01:28.914]                           invokeRestart("muffleWarning")
[11:01:28.914]                       }
[11:01:28.914]                       else if (inherits(cond, "condition")) {
[11:01:28.914]                         if (!is.null(pattern)) {
[11:01:28.914]                           computeRestarts <- base::computeRestarts
[11:01:28.914]                           grepl <- base::grepl
[11:01:28.914]                           restarts <- computeRestarts(cond)
[11:01:28.914]                           for (restart in restarts) {
[11:01:28.914]                             name <- restart$name
[11:01:28.914]                             if (is.null(name)) 
[11:01:28.914]                               next
[11:01:28.914]                             if (!grepl(pattern, name)) 
[11:01:28.914]                               next
[11:01:28.914]                             invokeRestart(restart)
[11:01:28.914]                             muffled <- TRUE
[11:01:28.914]                             break
[11:01:28.914]                           }
[11:01:28.914]                         }
[11:01:28.914]                       }
[11:01:28.914]                       invisible(muffled)
[11:01:28.914]                     }
[11:01:28.914]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.914]                   }
[11:01:28.914]                 }
[11:01:28.914]             }
[11:01:28.914]         }))
[11:01:28.914]     }, error = function(ex) {
[11:01:28.914]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.914]                 ...future.rng), started = ...future.startTime, 
[11:01:28.914]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.914]             version = "1.8"), class = "FutureResult")
[11:01:28.914]     }, finally = {
[11:01:28.914]         if (!identical(...future.workdir, getwd())) 
[11:01:28.914]             setwd(...future.workdir)
[11:01:28.914]         {
[11:01:28.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.914]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.914]             }
[11:01:28.914]             base::options(...future.oldOptions)
[11:01:28.914]             if (.Platform$OS.type == "windows") {
[11:01:28.914]                 old_names <- names(...future.oldEnvVars)
[11:01:28.914]                 envs <- base::Sys.getenv()
[11:01:28.914]                 names <- names(envs)
[11:01:28.914]                 common <- intersect(names, old_names)
[11:01:28.914]                 added <- setdiff(names, old_names)
[11:01:28.914]                 removed <- setdiff(old_names, names)
[11:01:28.914]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.914]                   envs[common]]
[11:01:28.914]                 NAMES <- toupper(changed)
[11:01:28.914]                 args <- list()
[11:01:28.914]                 for (kk in seq_along(NAMES)) {
[11:01:28.914]                   name <- changed[[kk]]
[11:01:28.914]                   NAME <- NAMES[[kk]]
[11:01:28.914]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.914]                     next
[11:01:28.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.914]                 }
[11:01:28.914]                 NAMES <- toupper(added)
[11:01:28.914]                 for (kk in seq_along(NAMES)) {
[11:01:28.914]                   name <- added[[kk]]
[11:01:28.914]                   NAME <- NAMES[[kk]]
[11:01:28.914]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.914]                     next
[11:01:28.914]                   args[[name]] <- ""
[11:01:28.914]                 }
[11:01:28.914]                 NAMES <- toupper(removed)
[11:01:28.914]                 for (kk in seq_along(NAMES)) {
[11:01:28.914]                   name <- removed[[kk]]
[11:01:28.914]                   NAME <- NAMES[[kk]]
[11:01:28.914]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.914]                     next
[11:01:28.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.914]                 }
[11:01:28.914]                 if (length(args) > 0) 
[11:01:28.914]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.914]             }
[11:01:28.914]             else {
[11:01:28.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.914]             }
[11:01:28.914]             {
[11:01:28.914]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.914]                   0L) {
[11:01:28.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.914]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.914]                   base::options(opts)
[11:01:28.914]                 }
[11:01:28.914]                 {
[11:01:28.914]                   {
[11:01:28.914]                     NULL
[11:01:28.914]                     RNGkind("Mersenne-Twister")
[11:01:28.914]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.914]                       inherits = FALSE)
[11:01:28.914]                   }
[11:01:28.914]                   options(future.plan = NULL)
[11:01:28.914]                   if (is.na(NA_character_)) 
[11:01:28.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.914]                     .init = FALSE)
[11:01:28.914]                 }
[11:01:28.914]             }
[11:01:28.914]         }
[11:01:28.914]     })
[11:01:28.914]     if (TRUE) {
[11:01:28.914]         base::sink(type = "output", split = FALSE)
[11:01:28.914]         if (TRUE) {
[11:01:28.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.914]         }
[11:01:28.914]         else {
[11:01:28.914]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.914]         }
[11:01:28.914]         base::close(...future.stdout)
[11:01:28.914]         ...future.stdout <- NULL
[11:01:28.914]     }
[11:01:28.914]     ...future.result$conditions <- ...future.conditions
[11:01:28.914]     ...future.result$finished <- base::Sys.time()
[11:01:28.914]     ...future.result
[11:01:28.914] }
[11:01:28.916] plan(): Setting new future strategy stack:
[11:01:28.916] List of future strategies:
[11:01:28.916] 1. sequential:
[11:01:28.916]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.916]    - tweaked: FALSE
[11:01:28.916]    - call: NULL
[11:01:28.916] plan(): nbrOfWorkers() = 1
[11:01:28.917] plan(): Setting new future strategy stack:
[11:01:28.917] List of future strategies:
[11:01:28.917] 1. sequential:
[11:01:28.917]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.917]    - tweaked: FALSE
[11:01:28.917]    - call: plan(strategy)
[11:01:28.918] plan(): nbrOfWorkers() = 1
[11:01:28.918] SequentialFuture started (and completed)
[11:01:28.918] - Launch lazy future ... done
[11:01:28.918] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c6572d00> 
Classes 'listenv', 'environment' <environment: 0x55a9c64c2ef8> 
[11:01:28.921] resolved() for ‘SequentialFuture’ ...
[11:01:28.921] - state: ‘finished’
[11:01:28.921] - run: TRUE
[11:01:28.921] - result: ‘FutureResult’
[11:01:28.921] resolved() for ‘SequentialFuture’ ... done
[11:01:28.921] resolved() for ‘SequentialFuture’ ...
[11:01:28.921] - state: ‘finished’
[11:01:28.921] - run: TRUE
[11:01:28.921] - result: ‘FutureResult’
[11:01:28.921] resolved() for ‘SequentialFuture’ ... done
[11:01:28.921] resolved() for ‘SequentialFuture’ ...
[11:01:28.922] - state: ‘finished’
[11:01:28.922] - run: TRUE
[11:01:28.922] - result: ‘FutureResult’
[11:01:28.922] resolved() for ‘SequentialFuture’ ... done
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:28.923] resolve() on list environment ...
[11:01:28.923]  recursive: 0
[11:01:28.924]  length: 6
[11:01:28.924]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:28.924] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.924] - nx: 6
[11:01:28.925] - relay: TRUE
[11:01:28.925] - stdout: TRUE
[11:01:28.925] - signal: TRUE
[11:01:28.925] - resignal: FALSE
[11:01:28.925] - force: TRUE
[11:01:28.925] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.925] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.925]  - until=2
[11:01:28.925]  - relaying element #2
[11:01:28.925] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.925] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.925] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.926]  length: 5 (resolved future 1)
[11:01:28.926] resolved() for ‘SequentialFuture’ ...
[11:01:28.926] - state: ‘finished’
[11:01:28.926] - run: TRUE
[11:01:28.926] - result: ‘FutureResult’
[11:01:28.926] resolved() for ‘SequentialFuture’ ... done
[11:01:28.926] Future #2
[11:01:28.926] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.926] - nx: 6
[11:01:28.926] - relay: TRUE
[11:01:28.926] - stdout: TRUE
[11:01:28.926] - signal: TRUE
[11:01:28.927] - resignal: FALSE
[11:01:28.927] - force: TRUE
[11:01:28.927] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.927] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.927]  - until=2
[11:01:28.927]  - relaying element #2
[11:01:28.927] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.927] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.927] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.927]  length: 4 (resolved future 2)
[11:01:28.927] resolved() for ‘SequentialFuture’ ...
[11:01:28.928] - state: ‘finished’
[11:01:28.928] - run: TRUE
[11:01:28.928] - result: ‘FutureResult’
[11:01:28.928] resolved() for ‘SequentialFuture’ ... done
[11:01:28.928] Future #3
[11:01:28.928] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.928] - nx: 6
[11:01:28.928] - relay: TRUE
[11:01:28.928] - stdout: TRUE
[11:01:28.928] - signal: TRUE
[11:01:28.928] - resignal: FALSE
[11:01:28.928] - force: TRUE
[11:01:28.930] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.930] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.930]  - until=3
[11:01:28.930]  - relaying element #3
[11:01:28.930] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.930] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.930] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.930]  length: 3 (resolved future 3)
[11:01:28.930] resolved() for ‘SequentialFuture’ ...
[11:01:28.930] - state: ‘finished’
[11:01:28.931] - run: TRUE
[11:01:28.931] - result: ‘FutureResult’
[11:01:28.931] resolved() for ‘SequentialFuture’ ... done
[11:01:28.931] Future #4
[11:01:28.931] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:28.931] - nx: 6
[11:01:28.931] - relay: TRUE
[11:01:28.931] - stdout: TRUE
[11:01:28.931] - signal: TRUE
[11:01:28.931] - resignal: FALSE
[11:01:28.931] - force: TRUE
[11:01:28.931] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.931] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.932]  - until=4
[11:01:28.932]  - relaying element #4
[11:01:28.932] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.932] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.932] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:28.932]  length: 2 (resolved future 4)
[11:01:28.932] signalConditionsASAP(NULL, pos=5) ...
[11:01:28.932] - nx: 6
[11:01:28.932] - relay: TRUE
[11:01:28.932] - stdout: TRUE
[11:01:28.932] - signal: TRUE
[11:01:28.933] - resignal: FALSE
[11:01:28.933] - force: TRUE
[11:01:28.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.933] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.933]  - until=6
[11:01:28.933]  - relaying element #6
[11:01:28.933] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.933] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.933] signalConditionsASAP(NULL, pos=5) ... done
[11:01:28.933]  length: 1 (resolved future 5)
[11:01:28.933] signalConditionsASAP(numeric, pos=6) ...
[11:01:28.933] - nx: 6
[11:01:28.933] - relay: TRUE
[11:01:28.934] - stdout: TRUE
[11:01:28.934] - signal: TRUE
[11:01:28.934] - resignal: FALSE
[11:01:28.934] - force: TRUE
[11:01:28.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.934] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.934]  - until=6
[11:01:28.934] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.934] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.934] signalConditionsASAP(numeric, pos=6) ... done
[11:01:28.934]  length: 0 (resolved future 6)
[11:01:28.934] Relaying remaining futures
[11:01:28.934] signalConditionsASAP(NULL, pos=0) ...
[11:01:28.934] - nx: 6
[11:01:28.935] - relay: TRUE
[11:01:28.935] - stdout: TRUE
[11:01:28.935] - signal: TRUE
[11:01:28.935] - resignal: FALSE
[11:01:28.935] - force: TRUE
[11:01:28.935] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.935] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:28.935] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:28.935] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.935] signalConditionsASAP(NULL, pos=0) ... done
[11:01:28.935] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a9c676e508> 
Dimensions: c(1, 6)
[11:01:28.936] getGlobalsAndPackages() ...
[11:01:28.936] Searching for globals...
[11:01:28.936] 
[11:01:28.937] Searching for globals ... DONE
[11:01:28.937] - globals: [0] <none>
[11:01:28.937] getGlobalsAndPackages() ... DONE
[11:01:28.937] run() for ‘Future’ ...
[11:01:28.937] - state: ‘created’
[11:01:28.937] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.937] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.937] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.937]   - Field: ‘label’
[11:01:28.938]   - Field: ‘local’
[11:01:28.938]   - Field: ‘owner’
[11:01:28.938]   - Field: ‘envir’
[11:01:28.938]   - Field: ‘packages’
[11:01:28.938]   - Field: ‘gc’
[11:01:28.938]   - Field: ‘conditions’
[11:01:28.938]   - Field: ‘expr’
[11:01:28.938]   - Field: ‘uuid’
[11:01:28.938]   - Field: ‘seed’
[11:01:28.938]   - Field: ‘version’
[11:01:28.938]   - Field: ‘result’
[11:01:28.938]   - Field: ‘asynchronous’
[11:01:28.939]   - Field: ‘calls’
[11:01:28.939]   - Field: ‘globals’
[11:01:28.939]   - Field: ‘stdout’
[11:01:28.939]   - Field: ‘earlySignal’
[11:01:28.939]   - Field: ‘lazy’
[11:01:28.939]   - Field: ‘state’
[11:01:28.939] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.939] - Launch lazy future ...
[11:01:28.939] Packages needed by the future expression (n = 0): <none>
[11:01:28.939] Packages needed by future strategies (n = 0): <none>
[11:01:28.940] {
[11:01:28.940]     {
[11:01:28.940]         {
[11:01:28.940]             ...future.startTime <- base::Sys.time()
[11:01:28.940]             {
[11:01:28.940]                 {
[11:01:28.940]                   {
[11:01:28.940]                     base::local({
[11:01:28.940]                       has_future <- base::requireNamespace("future", 
[11:01:28.940]                         quietly = TRUE)
[11:01:28.940]                       if (has_future) {
[11:01:28.940]                         ns <- base::getNamespace("future")
[11:01:28.940]                         version <- ns[[".package"]][["version"]]
[11:01:28.940]                         if (is.null(version)) 
[11:01:28.940]                           version <- utils::packageVersion("future")
[11:01:28.940]                       }
[11:01:28.940]                       else {
[11:01:28.940]                         version <- NULL
[11:01:28.940]                       }
[11:01:28.940]                       if (!has_future || version < "1.8.0") {
[11:01:28.940]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.940]                           "", base::R.version$version.string), 
[11:01:28.940]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.940]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.940]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.940]                             "release", "version")], collapse = " "), 
[11:01:28.940]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.940]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.940]                           info)
[11:01:28.940]                         info <- base::paste(info, collapse = "; ")
[11:01:28.940]                         if (!has_future) {
[11:01:28.940]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.940]                             info)
[11:01:28.940]                         }
[11:01:28.940]                         else {
[11:01:28.940]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.940]                             info, version)
[11:01:28.940]                         }
[11:01:28.940]                         base::stop(msg)
[11:01:28.940]                       }
[11:01:28.940]                     })
[11:01:28.940]                   }
[11:01:28.940]                   ...future.strategy.old <- future::plan("list")
[11:01:28.940]                   options(future.plan = NULL)
[11:01:28.940]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.940]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.940]                 }
[11:01:28.940]                 ...future.workdir <- getwd()
[11:01:28.940]             }
[11:01:28.940]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.940]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.940]         }
[11:01:28.940]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.940]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.940]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.940]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.940]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.940]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.940]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.940]             base::names(...future.oldOptions))
[11:01:28.940]     }
[11:01:28.940]     if (FALSE) {
[11:01:28.940]     }
[11:01:28.940]     else {
[11:01:28.940]         if (TRUE) {
[11:01:28.940]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.940]                 open = "w")
[11:01:28.940]         }
[11:01:28.940]         else {
[11:01:28.940]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.940]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.940]         }
[11:01:28.940]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.940]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.940]             base::sink(type = "output", split = FALSE)
[11:01:28.940]             base::close(...future.stdout)
[11:01:28.940]         }, add = TRUE)
[11:01:28.940]     }
[11:01:28.940]     ...future.frame <- base::sys.nframe()
[11:01:28.940]     ...future.conditions <- base::list()
[11:01:28.940]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.940]     if (FALSE) {
[11:01:28.940]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.940]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.940]     }
[11:01:28.940]     ...future.result <- base::tryCatch({
[11:01:28.940]         base::withCallingHandlers({
[11:01:28.940]             ...future.value <- base::withVisible(base::local(2))
[11:01:28.940]             future::FutureResult(value = ...future.value$value, 
[11:01:28.940]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.940]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.940]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.940]                     ...future.globalenv.names))
[11:01:28.940]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.940]         }, condition = base::local({
[11:01:28.940]             c <- base::c
[11:01:28.940]             inherits <- base::inherits
[11:01:28.940]             invokeRestart <- base::invokeRestart
[11:01:28.940]             length <- base::length
[11:01:28.940]             list <- base::list
[11:01:28.940]             seq.int <- base::seq.int
[11:01:28.940]             signalCondition <- base::signalCondition
[11:01:28.940]             sys.calls <- base::sys.calls
[11:01:28.940]             `[[` <- base::`[[`
[11:01:28.940]             `+` <- base::`+`
[11:01:28.940]             `<<-` <- base::`<<-`
[11:01:28.940]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.940]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.940]                   3L)]
[11:01:28.940]             }
[11:01:28.940]             function(cond) {
[11:01:28.940]                 is_error <- inherits(cond, "error")
[11:01:28.940]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.940]                   NULL)
[11:01:28.940]                 if (is_error) {
[11:01:28.940]                   sessionInformation <- function() {
[11:01:28.940]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.940]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.940]                       search = base::search(), system = base::Sys.info())
[11:01:28.940]                   }
[11:01:28.940]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.940]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.940]                     cond$call), session = sessionInformation(), 
[11:01:28.940]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.940]                   signalCondition(cond)
[11:01:28.940]                 }
[11:01:28.940]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.940]                 "immediateCondition"))) {
[11:01:28.940]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.940]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.940]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.940]                   if (TRUE && !signal) {
[11:01:28.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.940]                     {
[11:01:28.940]                       inherits <- base::inherits
[11:01:28.940]                       invokeRestart <- base::invokeRestart
[11:01:28.940]                       is.null <- base::is.null
[11:01:28.940]                       muffled <- FALSE
[11:01:28.940]                       if (inherits(cond, "message")) {
[11:01:28.940]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.940]                         if (muffled) 
[11:01:28.940]                           invokeRestart("muffleMessage")
[11:01:28.940]                       }
[11:01:28.940]                       else if (inherits(cond, "warning")) {
[11:01:28.940]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.940]                         if (muffled) 
[11:01:28.940]                           invokeRestart("muffleWarning")
[11:01:28.940]                       }
[11:01:28.940]                       else if (inherits(cond, "condition")) {
[11:01:28.940]                         if (!is.null(pattern)) {
[11:01:28.940]                           computeRestarts <- base::computeRestarts
[11:01:28.940]                           grepl <- base::grepl
[11:01:28.940]                           restarts <- computeRestarts(cond)
[11:01:28.940]                           for (restart in restarts) {
[11:01:28.940]                             name <- restart$name
[11:01:28.940]                             if (is.null(name)) 
[11:01:28.940]                               next
[11:01:28.940]                             if (!grepl(pattern, name)) 
[11:01:28.940]                               next
[11:01:28.940]                             invokeRestart(restart)
[11:01:28.940]                             muffled <- TRUE
[11:01:28.940]                             break
[11:01:28.940]                           }
[11:01:28.940]                         }
[11:01:28.940]                       }
[11:01:28.940]                       invisible(muffled)
[11:01:28.940]                     }
[11:01:28.940]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.940]                   }
[11:01:28.940]                 }
[11:01:28.940]                 else {
[11:01:28.940]                   if (TRUE) {
[11:01:28.940]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.940]                     {
[11:01:28.940]                       inherits <- base::inherits
[11:01:28.940]                       invokeRestart <- base::invokeRestart
[11:01:28.940]                       is.null <- base::is.null
[11:01:28.940]                       muffled <- FALSE
[11:01:28.940]                       if (inherits(cond, "message")) {
[11:01:28.940]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.940]                         if (muffled) 
[11:01:28.940]                           invokeRestart("muffleMessage")
[11:01:28.940]                       }
[11:01:28.940]                       else if (inherits(cond, "warning")) {
[11:01:28.940]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.940]                         if (muffled) 
[11:01:28.940]                           invokeRestart("muffleWarning")
[11:01:28.940]                       }
[11:01:28.940]                       else if (inherits(cond, "condition")) {
[11:01:28.940]                         if (!is.null(pattern)) {
[11:01:28.940]                           computeRestarts <- base::computeRestarts
[11:01:28.940]                           grepl <- base::grepl
[11:01:28.940]                           restarts <- computeRestarts(cond)
[11:01:28.940]                           for (restart in restarts) {
[11:01:28.940]                             name <- restart$name
[11:01:28.940]                             if (is.null(name)) 
[11:01:28.940]                               next
[11:01:28.940]                             if (!grepl(pattern, name)) 
[11:01:28.940]                               next
[11:01:28.940]                             invokeRestart(restart)
[11:01:28.940]                             muffled <- TRUE
[11:01:28.940]                             break
[11:01:28.940]                           }
[11:01:28.940]                         }
[11:01:28.940]                       }
[11:01:28.940]                       invisible(muffled)
[11:01:28.940]                     }
[11:01:28.940]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.940]                   }
[11:01:28.940]                 }
[11:01:28.940]             }
[11:01:28.940]         }))
[11:01:28.940]     }, error = function(ex) {
[11:01:28.940]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.940]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.940]                 ...future.rng), started = ...future.startTime, 
[11:01:28.940]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.940]             version = "1.8"), class = "FutureResult")
[11:01:28.940]     }, finally = {
[11:01:28.940]         if (!identical(...future.workdir, getwd())) 
[11:01:28.940]             setwd(...future.workdir)
[11:01:28.940]         {
[11:01:28.940]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.940]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.940]             }
[11:01:28.940]             base::options(...future.oldOptions)
[11:01:28.940]             if (.Platform$OS.type == "windows") {
[11:01:28.940]                 old_names <- names(...future.oldEnvVars)
[11:01:28.940]                 envs <- base::Sys.getenv()
[11:01:28.940]                 names <- names(envs)
[11:01:28.940]                 common <- intersect(names, old_names)
[11:01:28.940]                 added <- setdiff(names, old_names)
[11:01:28.940]                 removed <- setdiff(old_names, names)
[11:01:28.940]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.940]                   envs[common]]
[11:01:28.940]                 NAMES <- toupper(changed)
[11:01:28.940]                 args <- list()
[11:01:28.940]                 for (kk in seq_along(NAMES)) {
[11:01:28.940]                   name <- changed[[kk]]
[11:01:28.940]                   NAME <- NAMES[[kk]]
[11:01:28.940]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.940]                     next
[11:01:28.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.940]                 }
[11:01:28.940]                 NAMES <- toupper(added)
[11:01:28.940]                 for (kk in seq_along(NAMES)) {
[11:01:28.940]                   name <- added[[kk]]
[11:01:28.940]                   NAME <- NAMES[[kk]]
[11:01:28.940]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.940]                     next
[11:01:28.940]                   args[[name]] <- ""
[11:01:28.940]                 }
[11:01:28.940]                 NAMES <- toupper(removed)
[11:01:28.940]                 for (kk in seq_along(NAMES)) {
[11:01:28.940]                   name <- removed[[kk]]
[11:01:28.940]                   NAME <- NAMES[[kk]]
[11:01:28.940]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.940]                     next
[11:01:28.940]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.940]                 }
[11:01:28.940]                 if (length(args) > 0) 
[11:01:28.940]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.940]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.940]             }
[11:01:28.940]             else {
[11:01:28.940]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.940]             }
[11:01:28.940]             {
[11:01:28.940]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.940]                   0L) {
[11:01:28.940]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.940]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.940]                   base::options(opts)
[11:01:28.940]                 }
[11:01:28.940]                 {
[11:01:28.940]                   {
[11:01:28.940]                     NULL
[11:01:28.940]                     RNGkind("Mersenne-Twister")
[11:01:28.940]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.940]                       inherits = FALSE)
[11:01:28.940]                   }
[11:01:28.940]                   options(future.plan = NULL)
[11:01:28.940]                   if (is.na(NA_character_)) 
[11:01:28.940]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.940]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.940]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.940]                     .init = FALSE)
[11:01:28.940]                 }
[11:01:28.940]             }
[11:01:28.940]         }
[11:01:28.940]     })
[11:01:28.940]     if (TRUE) {
[11:01:28.940]         base::sink(type = "output", split = FALSE)
[11:01:28.940]         if (TRUE) {
[11:01:28.940]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.940]         }
[11:01:28.940]         else {
[11:01:28.940]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.940]         }
[11:01:28.940]         base::close(...future.stdout)
[11:01:28.940]         ...future.stdout <- NULL
[11:01:28.940]     }
[11:01:28.940]     ...future.result$conditions <- ...future.conditions
[11:01:28.940]     ...future.result$finished <- base::Sys.time()
[11:01:28.940]     ...future.result
[11:01:28.940] }
[11:01:28.941] plan(): Setting new future strategy stack:
[11:01:28.941] List of future strategies:
[11:01:28.941] 1. sequential:
[11:01:28.941]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.941]    - tweaked: FALSE
[11:01:28.941]    - call: NULL
[11:01:28.942] plan(): nbrOfWorkers() = 1
[11:01:28.943] plan(): Setting new future strategy stack:
[11:01:28.943] List of future strategies:
[11:01:28.943] 1. sequential:
[11:01:28.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.943]    - tweaked: FALSE
[11:01:28.943]    - call: plan(strategy)
[11:01:28.943] plan(): nbrOfWorkers() = 1
[11:01:28.943] SequentialFuture started (and completed)
[11:01:28.943] - Launch lazy future ... done
[11:01:28.943] run() for ‘SequentialFuture’ ... done
[11:01:28.944] getGlobalsAndPackages() ...
[11:01:28.944] Searching for globals...
[11:01:28.944] 
[11:01:28.944] Searching for globals ... DONE
[11:01:28.944] - globals: [0] <none>
[11:01:28.944] getGlobalsAndPackages() ... DONE
[11:01:28.944] run() for ‘Future’ ...
[11:01:28.944] - state: ‘created’
[11:01:28.945] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.945] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.945] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.945]   - Field: ‘label’
[11:01:28.945]   - Field: ‘local’
[11:01:28.945]   - Field: ‘owner’
[11:01:28.945]   - Field: ‘envir’
[11:01:28.945]   - Field: ‘packages’
[11:01:28.945]   - Field: ‘gc’
[11:01:28.945]   - Field: ‘conditions’
[11:01:28.945]   - Field: ‘expr’
[11:01:28.946]   - Field: ‘uuid’
[11:01:28.946]   - Field: ‘seed’
[11:01:28.946]   - Field: ‘version’
[11:01:28.946]   - Field: ‘result’
[11:01:28.946]   - Field: ‘asynchronous’
[11:01:28.946]   - Field: ‘calls’
[11:01:28.946]   - Field: ‘globals’
[11:01:28.946]   - Field: ‘stdout’
[11:01:28.946]   - Field: ‘earlySignal’
[11:01:28.946]   - Field: ‘lazy’
[11:01:28.946]   - Field: ‘state’
[11:01:28.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.947] - Launch lazy future ...
[11:01:28.947] Packages needed by the future expression (n = 0): <none>
[11:01:28.947] Packages needed by future strategies (n = 0): <none>
[11:01:28.947] {
[11:01:28.947]     {
[11:01:28.947]         {
[11:01:28.947]             ...future.startTime <- base::Sys.time()
[11:01:28.947]             {
[11:01:28.947]                 {
[11:01:28.947]                   {
[11:01:28.947]                     base::local({
[11:01:28.947]                       has_future <- base::requireNamespace("future", 
[11:01:28.947]                         quietly = TRUE)
[11:01:28.947]                       if (has_future) {
[11:01:28.947]                         ns <- base::getNamespace("future")
[11:01:28.947]                         version <- ns[[".package"]][["version"]]
[11:01:28.947]                         if (is.null(version)) 
[11:01:28.947]                           version <- utils::packageVersion("future")
[11:01:28.947]                       }
[11:01:28.947]                       else {
[11:01:28.947]                         version <- NULL
[11:01:28.947]                       }
[11:01:28.947]                       if (!has_future || version < "1.8.0") {
[11:01:28.947]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.947]                           "", base::R.version$version.string), 
[11:01:28.947]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.947]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.947]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.947]                             "release", "version")], collapse = " "), 
[11:01:28.947]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.947]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.947]                           info)
[11:01:28.947]                         info <- base::paste(info, collapse = "; ")
[11:01:28.947]                         if (!has_future) {
[11:01:28.947]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.947]                             info)
[11:01:28.947]                         }
[11:01:28.947]                         else {
[11:01:28.947]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.947]                             info, version)
[11:01:28.947]                         }
[11:01:28.947]                         base::stop(msg)
[11:01:28.947]                       }
[11:01:28.947]                     })
[11:01:28.947]                   }
[11:01:28.947]                   ...future.strategy.old <- future::plan("list")
[11:01:28.947]                   options(future.plan = NULL)
[11:01:28.947]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.947]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.947]                 }
[11:01:28.947]                 ...future.workdir <- getwd()
[11:01:28.947]             }
[11:01:28.947]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.947]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.947]         }
[11:01:28.947]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.947]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.947]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.947]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.947]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.947]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.947]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.947]             base::names(...future.oldOptions))
[11:01:28.947]     }
[11:01:28.947]     if (FALSE) {
[11:01:28.947]     }
[11:01:28.947]     else {
[11:01:28.947]         if (TRUE) {
[11:01:28.947]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.947]                 open = "w")
[11:01:28.947]         }
[11:01:28.947]         else {
[11:01:28.947]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.947]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.947]         }
[11:01:28.947]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.947]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.947]             base::sink(type = "output", split = FALSE)
[11:01:28.947]             base::close(...future.stdout)
[11:01:28.947]         }, add = TRUE)
[11:01:28.947]     }
[11:01:28.947]     ...future.frame <- base::sys.nframe()
[11:01:28.947]     ...future.conditions <- base::list()
[11:01:28.947]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.947]     if (FALSE) {
[11:01:28.947]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.947]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.947]     }
[11:01:28.947]     ...future.result <- base::tryCatch({
[11:01:28.947]         base::withCallingHandlers({
[11:01:28.947]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:28.947]             future::FutureResult(value = ...future.value$value, 
[11:01:28.947]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.947]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.947]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.947]                     ...future.globalenv.names))
[11:01:28.947]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.947]         }, condition = base::local({
[11:01:28.947]             c <- base::c
[11:01:28.947]             inherits <- base::inherits
[11:01:28.947]             invokeRestart <- base::invokeRestart
[11:01:28.947]             length <- base::length
[11:01:28.947]             list <- base::list
[11:01:28.947]             seq.int <- base::seq.int
[11:01:28.947]             signalCondition <- base::signalCondition
[11:01:28.947]             sys.calls <- base::sys.calls
[11:01:28.947]             `[[` <- base::`[[`
[11:01:28.947]             `+` <- base::`+`
[11:01:28.947]             `<<-` <- base::`<<-`
[11:01:28.947]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.947]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.947]                   3L)]
[11:01:28.947]             }
[11:01:28.947]             function(cond) {
[11:01:28.947]                 is_error <- inherits(cond, "error")
[11:01:28.947]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.947]                   NULL)
[11:01:28.947]                 if (is_error) {
[11:01:28.947]                   sessionInformation <- function() {
[11:01:28.947]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.947]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.947]                       search = base::search(), system = base::Sys.info())
[11:01:28.947]                   }
[11:01:28.947]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.947]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.947]                     cond$call), session = sessionInformation(), 
[11:01:28.947]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.947]                   signalCondition(cond)
[11:01:28.947]                 }
[11:01:28.947]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.947]                 "immediateCondition"))) {
[11:01:28.947]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.947]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.947]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.947]                   if (TRUE && !signal) {
[11:01:28.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.947]                     {
[11:01:28.947]                       inherits <- base::inherits
[11:01:28.947]                       invokeRestart <- base::invokeRestart
[11:01:28.947]                       is.null <- base::is.null
[11:01:28.947]                       muffled <- FALSE
[11:01:28.947]                       if (inherits(cond, "message")) {
[11:01:28.947]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.947]                         if (muffled) 
[11:01:28.947]                           invokeRestart("muffleMessage")
[11:01:28.947]                       }
[11:01:28.947]                       else if (inherits(cond, "warning")) {
[11:01:28.947]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.947]                         if (muffled) 
[11:01:28.947]                           invokeRestart("muffleWarning")
[11:01:28.947]                       }
[11:01:28.947]                       else if (inherits(cond, "condition")) {
[11:01:28.947]                         if (!is.null(pattern)) {
[11:01:28.947]                           computeRestarts <- base::computeRestarts
[11:01:28.947]                           grepl <- base::grepl
[11:01:28.947]                           restarts <- computeRestarts(cond)
[11:01:28.947]                           for (restart in restarts) {
[11:01:28.947]                             name <- restart$name
[11:01:28.947]                             if (is.null(name)) 
[11:01:28.947]                               next
[11:01:28.947]                             if (!grepl(pattern, name)) 
[11:01:28.947]                               next
[11:01:28.947]                             invokeRestart(restart)
[11:01:28.947]                             muffled <- TRUE
[11:01:28.947]                             break
[11:01:28.947]                           }
[11:01:28.947]                         }
[11:01:28.947]                       }
[11:01:28.947]                       invisible(muffled)
[11:01:28.947]                     }
[11:01:28.947]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.947]                   }
[11:01:28.947]                 }
[11:01:28.947]                 else {
[11:01:28.947]                   if (TRUE) {
[11:01:28.947]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.947]                     {
[11:01:28.947]                       inherits <- base::inherits
[11:01:28.947]                       invokeRestart <- base::invokeRestart
[11:01:28.947]                       is.null <- base::is.null
[11:01:28.947]                       muffled <- FALSE
[11:01:28.947]                       if (inherits(cond, "message")) {
[11:01:28.947]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.947]                         if (muffled) 
[11:01:28.947]                           invokeRestart("muffleMessage")
[11:01:28.947]                       }
[11:01:28.947]                       else if (inherits(cond, "warning")) {
[11:01:28.947]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.947]                         if (muffled) 
[11:01:28.947]                           invokeRestart("muffleWarning")
[11:01:28.947]                       }
[11:01:28.947]                       else if (inherits(cond, "condition")) {
[11:01:28.947]                         if (!is.null(pattern)) {
[11:01:28.947]                           computeRestarts <- base::computeRestarts
[11:01:28.947]                           grepl <- base::grepl
[11:01:28.947]                           restarts <- computeRestarts(cond)
[11:01:28.947]                           for (restart in restarts) {
[11:01:28.947]                             name <- restart$name
[11:01:28.947]                             if (is.null(name)) 
[11:01:28.947]                               next
[11:01:28.947]                             if (!grepl(pattern, name)) 
[11:01:28.947]                               next
[11:01:28.947]                             invokeRestart(restart)
[11:01:28.947]                             muffled <- TRUE
[11:01:28.947]                             break
[11:01:28.947]                           }
[11:01:28.947]                         }
[11:01:28.947]                       }
[11:01:28.947]                       invisible(muffled)
[11:01:28.947]                     }
[11:01:28.947]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.947]                   }
[11:01:28.947]                 }
[11:01:28.947]             }
[11:01:28.947]         }))
[11:01:28.947]     }, error = function(ex) {
[11:01:28.947]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.947]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.947]                 ...future.rng), started = ...future.startTime, 
[11:01:28.947]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.947]             version = "1.8"), class = "FutureResult")
[11:01:28.947]     }, finally = {
[11:01:28.947]         if (!identical(...future.workdir, getwd())) 
[11:01:28.947]             setwd(...future.workdir)
[11:01:28.947]         {
[11:01:28.947]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.947]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.947]             }
[11:01:28.947]             base::options(...future.oldOptions)
[11:01:28.947]             if (.Platform$OS.type == "windows") {
[11:01:28.947]                 old_names <- names(...future.oldEnvVars)
[11:01:28.947]                 envs <- base::Sys.getenv()
[11:01:28.947]                 names <- names(envs)
[11:01:28.947]                 common <- intersect(names, old_names)
[11:01:28.947]                 added <- setdiff(names, old_names)
[11:01:28.947]                 removed <- setdiff(old_names, names)
[11:01:28.947]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.947]                   envs[common]]
[11:01:28.947]                 NAMES <- toupper(changed)
[11:01:28.947]                 args <- list()
[11:01:28.947]                 for (kk in seq_along(NAMES)) {
[11:01:28.947]                   name <- changed[[kk]]
[11:01:28.947]                   NAME <- NAMES[[kk]]
[11:01:28.947]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.947]                     next
[11:01:28.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.947]                 }
[11:01:28.947]                 NAMES <- toupper(added)
[11:01:28.947]                 for (kk in seq_along(NAMES)) {
[11:01:28.947]                   name <- added[[kk]]
[11:01:28.947]                   NAME <- NAMES[[kk]]
[11:01:28.947]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.947]                     next
[11:01:28.947]                   args[[name]] <- ""
[11:01:28.947]                 }
[11:01:28.947]                 NAMES <- toupper(removed)
[11:01:28.947]                 for (kk in seq_along(NAMES)) {
[11:01:28.947]                   name <- removed[[kk]]
[11:01:28.947]                   NAME <- NAMES[[kk]]
[11:01:28.947]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.947]                     next
[11:01:28.947]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.947]                 }
[11:01:28.947]                 if (length(args) > 0) 
[11:01:28.947]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.947]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.947]             }
[11:01:28.947]             else {
[11:01:28.947]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.947]             }
[11:01:28.947]             {
[11:01:28.947]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.947]                   0L) {
[11:01:28.947]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.947]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.947]                   base::options(opts)
[11:01:28.947]                 }
[11:01:28.947]                 {
[11:01:28.947]                   {
[11:01:28.947]                     NULL
[11:01:28.947]                     RNGkind("Mersenne-Twister")
[11:01:28.947]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.947]                       inherits = FALSE)
[11:01:28.947]                   }
[11:01:28.947]                   options(future.plan = NULL)
[11:01:28.947]                   if (is.na(NA_character_)) 
[11:01:28.947]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.947]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.947]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.947]                     .init = FALSE)
[11:01:28.947]                 }
[11:01:28.947]             }
[11:01:28.947]         }
[11:01:28.947]     })
[11:01:28.947]     if (TRUE) {
[11:01:28.947]         base::sink(type = "output", split = FALSE)
[11:01:28.947]         if (TRUE) {
[11:01:28.947]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.947]         }
[11:01:28.947]         else {
[11:01:28.947]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.947]         }
[11:01:28.947]         base::close(...future.stdout)
[11:01:28.947]         ...future.stdout <- NULL
[11:01:28.947]     }
[11:01:28.947]     ...future.result$conditions <- ...future.conditions
[11:01:28.947]     ...future.result$finished <- base::Sys.time()
[11:01:28.947]     ...future.result
[11:01:28.947] }
[11:01:28.949] plan(): Setting new future strategy stack:
[11:01:28.949] List of future strategies:
[11:01:28.949] 1. sequential:
[11:01:28.949]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.949]    - tweaked: FALSE
[11:01:28.949]    - call: NULL
[11:01:28.949] plan(): nbrOfWorkers() = 1
[11:01:28.950] plan(): Setting new future strategy stack:
[11:01:28.950] List of future strategies:
[11:01:28.950] 1. sequential:
[11:01:28.950]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.950]    - tweaked: FALSE
[11:01:28.950]    - call: plan(strategy)
[11:01:28.950] plan(): nbrOfWorkers() = 1
[11:01:28.951] SequentialFuture started (and completed)
[11:01:28.951] - Launch lazy future ... done
[11:01:28.951] run() for ‘SequentialFuture’ ... done
[11:01:28.951] getGlobalsAndPackages() ...
[11:01:28.951] Searching for globals...
[11:01:28.952] - globals found: [1] ‘{’
[11:01:28.975] Searching for globals ... DONE
[11:01:28.975] Resolving globals: FALSE
[11:01:28.975] 
[11:01:28.975] 
[11:01:28.975] getGlobalsAndPackages() ... DONE
[11:01:28.975] run() for ‘Future’ ...
[11:01:28.976] - state: ‘created’
[11:01:28.976] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:28.976] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:28.976] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:28.976]   - Field: ‘label’
[11:01:28.976]   - Field: ‘local’
[11:01:28.976]   - Field: ‘owner’
[11:01:28.976]   - Field: ‘envir’
[11:01:28.977]   - Field: ‘packages’
[11:01:28.977]   - Field: ‘gc’
[11:01:28.977]   - Field: ‘conditions’
[11:01:28.977]   - Field: ‘expr’
[11:01:28.977]   - Field: ‘uuid’
[11:01:28.977]   - Field: ‘seed’
[11:01:28.977]   - Field: ‘version’
[11:01:28.977]   - Field: ‘result’
[11:01:28.977]   - Field: ‘asynchronous’
[11:01:28.977]   - Field: ‘calls’
[11:01:28.977]   - Field: ‘globals’
[11:01:28.977]   - Field: ‘stdout’
[11:01:28.978]   - Field: ‘earlySignal’
[11:01:28.978]   - Field: ‘lazy’
[11:01:28.978]   - Field: ‘state’
[11:01:28.978] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:28.978] - Launch lazy future ...
[11:01:28.978] Packages needed by the future expression (n = 0): <none>
[11:01:28.978] Packages needed by future strategies (n = 0): <none>
[11:01:28.978] {
[11:01:28.978]     {
[11:01:28.978]         {
[11:01:28.978]             ...future.startTime <- base::Sys.time()
[11:01:28.978]             {
[11:01:28.978]                 {
[11:01:28.978]                   {
[11:01:28.978]                     base::local({
[11:01:28.978]                       has_future <- base::requireNamespace("future", 
[11:01:28.978]                         quietly = TRUE)
[11:01:28.978]                       if (has_future) {
[11:01:28.978]                         ns <- base::getNamespace("future")
[11:01:28.978]                         version <- ns[[".package"]][["version"]]
[11:01:28.978]                         if (is.null(version)) 
[11:01:28.978]                           version <- utils::packageVersion("future")
[11:01:28.978]                       }
[11:01:28.978]                       else {
[11:01:28.978]                         version <- NULL
[11:01:28.978]                       }
[11:01:28.978]                       if (!has_future || version < "1.8.0") {
[11:01:28.978]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:28.978]                           "", base::R.version$version.string), 
[11:01:28.978]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:28.978]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:28.978]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:28.978]                             "release", "version")], collapse = " "), 
[11:01:28.978]                           hostname = base::Sys.info()[["nodename"]])
[11:01:28.978]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:28.978]                           info)
[11:01:28.978]                         info <- base::paste(info, collapse = "; ")
[11:01:28.978]                         if (!has_future) {
[11:01:28.978]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:28.978]                             info)
[11:01:28.978]                         }
[11:01:28.978]                         else {
[11:01:28.978]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:28.978]                             info, version)
[11:01:28.978]                         }
[11:01:28.978]                         base::stop(msg)
[11:01:28.978]                       }
[11:01:28.978]                     })
[11:01:28.978]                   }
[11:01:28.978]                   ...future.strategy.old <- future::plan("list")
[11:01:28.978]                   options(future.plan = NULL)
[11:01:28.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:28.978]                 }
[11:01:28.978]                 ...future.workdir <- getwd()
[11:01:28.978]             }
[11:01:28.978]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:28.978]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:28.978]         }
[11:01:28.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:28.978]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:28.978]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:28.978]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:28.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:28.978]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:28.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:28.978]             base::names(...future.oldOptions))
[11:01:28.978]     }
[11:01:28.978]     if (FALSE) {
[11:01:28.978]     }
[11:01:28.978]     else {
[11:01:28.978]         if (TRUE) {
[11:01:28.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:28.978]                 open = "w")
[11:01:28.978]         }
[11:01:28.978]         else {
[11:01:28.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:28.978]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:28.978]         }
[11:01:28.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:28.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:28.978]             base::sink(type = "output", split = FALSE)
[11:01:28.978]             base::close(...future.stdout)
[11:01:28.978]         }, add = TRUE)
[11:01:28.978]     }
[11:01:28.978]     ...future.frame <- base::sys.nframe()
[11:01:28.978]     ...future.conditions <- base::list()
[11:01:28.978]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:28.978]     if (FALSE) {
[11:01:28.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:28.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:28.978]     }
[11:01:28.978]     ...future.result <- base::tryCatch({
[11:01:28.978]         base::withCallingHandlers({
[11:01:28.978]             ...future.value <- base::withVisible(base::local({
[11:01:28.978]                 4
[11:01:28.978]             }))
[11:01:28.978]             future::FutureResult(value = ...future.value$value, 
[11:01:28.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.978]                   ...future.rng), globalenv = if (FALSE) 
[11:01:28.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:28.978]                     ...future.globalenv.names))
[11:01:28.978]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:28.978]         }, condition = base::local({
[11:01:28.978]             c <- base::c
[11:01:28.978]             inherits <- base::inherits
[11:01:28.978]             invokeRestart <- base::invokeRestart
[11:01:28.978]             length <- base::length
[11:01:28.978]             list <- base::list
[11:01:28.978]             seq.int <- base::seq.int
[11:01:28.978]             signalCondition <- base::signalCondition
[11:01:28.978]             sys.calls <- base::sys.calls
[11:01:28.978]             `[[` <- base::`[[`
[11:01:28.978]             `+` <- base::`+`
[11:01:28.978]             `<<-` <- base::`<<-`
[11:01:28.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:28.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:28.978]                   3L)]
[11:01:28.978]             }
[11:01:28.978]             function(cond) {
[11:01:28.978]                 is_error <- inherits(cond, "error")
[11:01:28.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:28.978]                   NULL)
[11:01:28.978]                 if (is_error) {
[11:01:28.978]                   sessionInformation <- function() {
[11:01:28.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:28.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:28.978]                       search = base::search(), system = base::Sys.info())
[11:01:28.978]                   }
[11:01:28.978]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:28.978]                     cond$call), session = sessionInformation(), 
[11:01:28.978]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:28.978]                   signalCondition(cond)
[11:01:28.978]                 }
[11:01:28.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:28.978]                 "immediateCondition"))) {
[11:01:28.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:28.978]                   ...future.conditions[[length(...future.conditions) + 
[11:01:28.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:28.978]                   if (TRUE && !signal) {
[11:01:28.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.978]                     {
[11:01:28.978]                       inherits <- base::inherits
[11:01:28.978]                       invokeRestart <- base::invokeRestart
[11:01:28.978]                       is.null <- base::is.null
[11:01:28.978]                       muffled <- FALSE
[11:01:28.978]                       if (inherits(cond, "message")) {
[11:01:28.978]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.978]                         if (muffled) 
[11:01:28.978]                           invokeRestart("muffleMessage")
[11:01:28.978]                       }
[11:01:28.978]                       else if (inherits(cond, "warning")) {
[11:01:28.978]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.978]                         if (muffled) 
[11:01:28.978]                           invokeRestart("muffleWarning")
[11:01:28.978]                       }
[11:01:28.978]                       else if (inherits(cond, "condition")) {
[11:01:28.978]                         if (!is.null(pattern)) {
[11:01:28.978]                           computeRestarts <- base::computeRestarts
[11:01:28.978]                           grepl <- base::grepl
[11:01:28.978]                           restarts <- computeRestarts(cond)
[11:01:28.978]                           for (restart in restarts) {
[11:01:28.978]                             name <- restart$name
[11:01:28.978]                             if (is.null(name)) 
[11:01:28.978]                               next
[11:01:28.978]                             if (!grepl(pattern, name)) 
[11:01:28.978]                               next
[11:01:28.978]                             invokeRestart(restart)
[11:01:28.978]                             muffled <- TRUE
[11:01:28.978]                             break
[11:01:28.978]                           }
[11:01:28.978]                         }
[11:01:28.978]                       }
[11:01:28.978]                       invisible(muffled)
[11:01:28.978]                     }
[11:01:28.978]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.978]                   }
[11:01:28.978]                 }
[11:01:28.978]                 else {
[11:01:28.978]                   if (TRUE) {
[11:01:28.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:28.978]                     {
[11:01:28.978]                       inherits <- base::inherits
[11:01:28.978]                       invokeRestart <- base::invokeRestart
[11:01:28.978]                       is.null <- base::is.null
[11:01:28.978]                       muffled <- FALSE
[11:01:28.978]                       if (inherits(cond, "message")) {
[11:01:28.978]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:28.978]                         if (muffled) 
[11:01:28.978]                           invokeRestart("muffleMessage")
[11:01:28.978]                       }
[11:01:28.978]                       else if (inherits(cond, "warning")) {
[11:01:28.978]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:28.978]                         if (muffled) 
[11:01:28.978]                           invokeRestart("muffleWarning")
[11:01:28.978]                       }
[11:01:28.978]                       else if (inherits(cond, "condition")) {
[11:01:28.978]                         if (!is.null(pattern)) {
[11:01:28.978]                           computeRestarts <- base::computeRestarts
[11:01:28.978]                           grepl <- base::grepl
[11:01:28.978]                           restarts <- computeRestarts(cond)
[11:01:28.978]                           for (restart in restarts) {
[11:01:28.978]                             name <- restart$name
[11:01:28.978]                             if (is.null(name)) 
[11:01:28.978]                               next
[11:01:28.978]                             if (!grepl(pattern, name)) 
[11:01:28.978]                               next
[11:01:28.978]                             invokeRestart(restart)
[11:01:28.978]                             muffled <- TRUE
[11:01:28.978]                             break
[11:01:28.978]                           }
[11:01:28.978]                         }
[11:01:28.978]                       }
[11:01:28.978]                       invisible(muffled)
[11:01:28.978]                     }
[11:01:28.978]                     muffleCondition(cond, pattern = "^muffle")
[11:01:28.978]                   }
[11:01:28.978]                 }
[11:01:28.978]             }
[11:01:28.978]         }))
[11:01:28.978]     }, error = function(ex) {
[11:01:28.978]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:28.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:28.978]                 ...future.rng), started = ...future.startTime, 
[11:01:28.978]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:28.978]             version = "1.8"), class = "FutureResult")
[11:01:28.978]     }, finally = {
[11:01:28.978]         if (!identical(...future.workdir, getwd())) 
[11:01:28.978]             setwd(...future.workdir)
[11:01:28.978]         {
[11:01:28.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:28.978]                 ...future.oldOptions$nwarnings <- NULL
[11:01:28.978]             }
[11:01:28.978]             base::options(...future.oldOptions)
[11:01:28.978]             if (.Platform$OS.type == "windows") {
[11:01:28.978]                 old_names <- names(...future.oldEnvVars)
[11:01:28.978]                 envs <- base::Sys.getenv()
[11:01:28.978]                 names <- names(envs)
[11:01:28.978]                 common <- intersect(names, old_names)
[11:01:28.978]                 added <- setdiff(names, old_names)
[11:01:28.978]                 removed <- setdiff(old_names, names)
[11:01:28.978]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:28.978]                   envs[common]]
[11:01:28.978]                 NAMES <- toupper(changed)
[11:01:28.978]                 args <- list()
[11:01:28.978]                 for (kk in seq_along(NAMES)) {
[11:01:28.978]                   name <- changed[[kk]]
[11:01:28.978]                   NAME <- NAMES[[kk]]
[11:01:28.978]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.978]                     next
[11:01:28.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.978]                 }
[11:01:28.978]                 NAMES <- toupper(added)
[11:01:28.978]                 for (kk in seq_along(NAMES)) {
[11:01:28.978]                   name <- added[[kk]]
[11:01:28.978]                   NAME <- NAMES[[kk]]
[11:01:28.978]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.978]                     next
[11:01:28.978]                   args[[name]] <- ""
[11:01:28.978]                 }
[11:01:28.978]                 NAMES <- toupper(removed)
[11:01:28.978]                 for (kk in seq_along(NAMES)) {
[11:01:28.978]                   name <- removed[[kk]]
[11:01:28.978]                   NAME <- NAMES[[kk]]
[11:01:28.978]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:28.978]                     next
[11:01:28.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:28.978]                 }
[11:01:28.978]                 if (length(args) > 0) 
[11:01:28.978]                   base::do.call(base::Sys.setenv, args = args)
[11:01:28.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:28.978]             }
[11:01:28.978]             else {
[11:01:28.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:28.978]             }
[11:01:28.978]             {
[11:01:28.978]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:28.978]                   0L) {
[11:01:28.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:28.978]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:28.978]                   base::options(opts)
[11:01:28.978]                 }
[11:01:28.978]                 {
[11:01:28.978]                   {
[11:01:28.978]                     NULL
[11:01:28.978]                     RNGkind("Mersenne-Twister")
[11:01:28.978]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:28.978]                       inherits = FALSE)
[11:01:28.978]                   }
[11:01:28.978]                   options(future.plan = NULL)
[11:01:28.978]                   if (is.na(NA_character_)) 
[11:01:28.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:28.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:28.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:28.978]                     .init = FALSE)
[11:01:28.978]                 }
[11:01:28.978]             }
[11:01:28.978]         }
[11:01:28.978]     })
[11:01:28.978]     if (TRUE) {
[11:01:28.978]         base::sink(type = "output", split = FALSE)
[11:01:28.978]         if (TRUE) {
[11:01:28.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:28.978]         }
[11:01:28.978]         else {
[11:01:28.978]             ...future.result["stdout"] <- base::list(NULL)
[11:01:28.978]         }
[11:01:28.978]         base::close(...future.stdout)
[11:01:28.978]         ...future.stdout <- NULL
[11:01:28.978]     }
[11:01:28.978]     ...future.result$conditions <- ...future.conditions
[11:01:28.978]     ...future.result$finished <- base::Sys.time()
[11:01:28.978]     ...future.result
[11:01:28.978] }
[11:01:28.980] plan(): Setting new future strategy stack:
[11:01:28.980] List of future strategies:
[11:01:28.980] 1. sequential:
[11:01:28.980]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.980]    - tweaked: FALSE
[11:01:28.980]    - call: NULL
[11:01:28.981] plan(): nbrOfWorkers() = 1
[11:01:28.981] plan(): Setting new future strategy stack:
[11:01:28.982] List of future strategies:
[11:01:28.982] 1. sequential:
[11:01:28.982]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:28.982]    - tweaked: FALSE
[11:01:28.982]    - call: plan(strategy)
[11:01:28.982] plan(): nbrOfWorkers() = 1
[11:01:28.982] SequentialFuture started (and completed)
[11:01:28.982] - Launch lazy future ... done
[11:01:28.982] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c5ec3008> 
Classes 'listenv', 'environment' <environment: 0x55a9c4a7c370> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[11:01:28.986] resolved() for ‘SequentialFuture’ ...
[11:01:28.986] - state: ‘finished’
[11:01:28.986] - run: TRUE
[11:01:28.986] - result: ‘FutureResult’
[11:01:28.986] resolved() for ‘SequentialFuture’ ... done
[11:01:28.986] resolved() for ‘SequentialFuture’ ...
[11:01:28.986] - state: ‘finished’
[11:01:28.986] - run: TRUE
[11:01:28.986] - result: ‘FutureResult’
[11:01:28.987] resolved() for ‘SequentialFuture’ ... done
[11:01:28.987] resolved() for ‘SequentialFuture’ ...
[11:01:28.987] - state: ‘finished’
[11:01:28.987] - run: TRUE
[11:01:28.987] - result: ‘FutureResult’
[11:01:28.987] resolved() for ‘SequentialFuture’ ... done
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:28.989] resolve() on list environment ...
[11:01:28.989]  recursive: 0
[11:01:28.990]  length: 6
[11:01:28.990]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:28.990] signalConditionsASAP(numeric, pos=1) ...
[11:01:28.990] - nx: 6
[11:01:28.990] - relay: TRUE
[11:01:28.990] - stdout: TRUE
[11:01:28.991] - signal: TRUE
[11:01:28.991] - resignal: FALSE
[11:01:28.991] - force: TRUE
[11:01:28.991] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.991] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.991]  - until=2
[11:01:28.991]  - relaying element #2
[11:01:28.991] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.991] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.991] signalConditionsASAP(NULL, pos=1) ... done
[11:01:28.991]  length: 5 (resolved future 1)
[11:01:28.991] resolved() for ‘SequentialFuture’ ...
[11:01:28.992] - state: ‘finished’
[11:01:28.992] - run: TRUE
[11:01:28.992] - result: ‘FutureResult’
[11:01:28.992] resolved() for ‘SequentialFuture’ ... done
[11:01:28.992] Future #2
[11:01:28.992] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:28.992] - nx: 6
[11:01:28.992] - relay: TRUE
[11:01:28.992] - stdout: TRUE
[11:01:28.992] - signal: TRUE
[11:01:28.992] - resignal: FALSE
[11:01:28.992] - force: TRUE
[11:01:28.993] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.993] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:28.993]  - until=2
[11:01:28.993]  - relaying element #2
[11:01:28.993] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.993] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.993] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:28.993]  length: 4 (resolved future 2)
[11:01:28.993] resolved() for ‘SequentialFuture’ ...
[11:01:28.993] - state: ‘finished’
[11:01:28.993] - run: TRUE
[11:01:28.994] - result: ‘FutureResult’
[11:01:28.994] resolved() for ‘SequentialFuture’ ... done
[11:01:28.994] Future #3
[11:01:28.994] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:28.994] - nx: 6
[11:01:28.994] - relay: TRUE
[11:01:28.994] - stdout: TRUE
[11:01:28.994] - signal: TRUE
[11:01:28.994] - resignal: FALSE
[11:01:28.994] - force: TRUE
[11:01:28.994] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.994] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:28.995]  - until=3
[11:01:28.995]  - relaying element #3
[11:01:28.995] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.995] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.995] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:28.995]  length: 3 (resolved future 3)
[11:01:28.995] resolved() for ‘SequentialFuture’ ...
[11:01:28.995] - state: ‘finished’
[11:01:28.995] - run: TRUE
[11:01:28.995] - result: ‘FutureResult’
[11:01:28.996] resolved() for ‘SequentialFuture’ ... done
[11:01:28.996] Future #4
[11:01:28.996] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:28.996] - nx: 6
[11:01:28.996] - relay: TRUE
[11:01:28.996] - stdout: TRUE
[11:01:28.996] - signal: TRUE
[11:01:28.996] - resignal: FALSE
[11:01:28.996] - force: TRUE
[11:01:28.996] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.996] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:28.996]  - until=4
[11:01:28.997]  - relaying element #4
[11:01:28.997] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.997] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.997] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:28.997]  length: 2 (resolved future 4)
[11:01:28.997] signalConditionsASAP(NULL, pos=5) ...
[11:01:28.997] - nx: 6
[11:01:28.997] - relay: TRUE
[11:01:28.997] - stdout: TRUE
[11:01:28.997] - signal: TRUE
[11:01:28.997] - resignal: FALSE
[11:01:28.997] - force: TRUE
[11:01:28.998] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.998] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.998]  - until=6
[11:01:28.998]  - relaying element #6
[11:01:28.998] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:28.998] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:28.998] signalConditionsASAP(NULL, pos=5) ... done
[11:01:28.998]  length: 1 (resolved future 5)
[11:01:28.998] signalConditionsASAP(numeric, pos=6) ...
[11:01:28.998] - nx: 6
[11:01:28.998] - relay: TRUE
[11:01:28.998] - stdout: TRUE
[11:01:28.999] - signal: TRUE
[11:01:28.999] - resignal: FALSE
[11:01:28.999] - force: TRUE
[11:01:28.999] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.000] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.000]  - until=6
[11:01:29.000] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.000] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.000] signalConditionsASAP(numeric, pos=6) ... done
[11:01:29.000]  length: 0 (resolved future 6)
[11:01:29.000] Relaying remaining futures
[11:01:29.000] signalConditionsASAP(NULL, pos=0) ...
[11:01:29.000] - nx: 6
[11:01:29.000] - relay: TRUE
[11:01:29.000] - stdout: TRUE
[11:01:29.000] - signal: TRUE
[11:01:29.001] - resignal: FALSE
[11:01:29.001] - force: TRUE
[11:01:29.001] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.001] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:29.001] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.001] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.001] signalConditionsASAP(NULL, pos=0) ... done
[11:01:29.001] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a9c658b058> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[11:01:29.003] getGlobalsAndPackages() ...
[11:01:29.003] Searching for globals...
[11:01:29.003] 
[11:01:29.003] Searching for globals ... DONE
[11:01:29.003] - globals: [0] <none>
[11:01:29.004] getGlobalsAndPackages() ... DONE
[11:01:29.004] run() for ‘Future’ ...
[11:01:29.004] - state: ‘created’
[11:01:29.004] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:29.004] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:29.004] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:29.004]   - Field: ‘label’
[11:01:29.004]   - Field: ‘local’
[11:01:29.005]   - Field: ‘owner’
[11:01:29.005]   - Field: ‘envir’
[11:01:29.005]   - Field: ‘packages’
[11:01:29.005]   - Field: ‘gc’
[11:01:29.005]   - Field: ‘conditions’
[11:01:29.005]   - Field: ‘expr’
[11:01:29.005]   - Field: ‘uuid’
[11:01:29.005]   - Field: ‘seed’
[11:01:29.005]   - Field: ‘version’
[11:01:29.005]   - Field: ‘result’
[11:01:29.005]   - Field: ‘asynchronous’
[11:01:29.005]   - Field: ‘calls’
[11:01:29.005]   - Field: ‘globals’
[11:01:29.006]   - Field: ‘stdout’
[11:01:29.006]   - Field: ‘earlySignal’
[11:01:29.006]   - Field: ‘lazy’
[11:01:29.006]   - Field: ‘state’
[11:01:29.006] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:29.006] - Launch lazy future ...
[11:01:29.006] Packages needed by the future expression (n = 0): <none>
[11:01:29.006] Packages needed by future strategies (n = 0): <none>
[11:01:29.007] {
[11:01:29.007]     {
[11:01:29.007]         {
[11:01:29.007]             ...future.startTime <- base::Sys.time()
[11:01:29.007]             {
[11:01:29.007]                 {
[11:01:29.007]                   {
[11:01:29.007]                     base::local({
[11:01:29.007]                       has_future <- base::requireNamespace("future", 
[11:01:29.007]                         quietly = TRUE)
[11:01:29.007]                       if (has_future) {
[11:01:29.007]                         ns <- base::getNamespace("future")
[11:01:29.007]                         version <- ns[[".package"]][["version"]]
[11:01:29.007]                         if (is.null(version)) 
[11:01:29.007]                           version <- utils::packageVersion("future")
[11:01:29.007]                       }
[11:01:29.007]                       else {
[11:01:29.007]                         version <- NULL
[11:01:29.007]                       }
[11:01:29.007]                       if (!has_future || version < "1.8.0") {
[11:01:29.007]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.007]                           "", base::R.version$version.string), 
[11:01:29.007]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:29.007]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.007]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.007]                             "release", "version")], collapse = " "), 
[11:01:29.007]                           hostname = base::Sys.info()[["nodename"]])
[11:01:29.007]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.007]                           info)
[11:01:29.007]                         info <- base::paste(info, collapse = "; ")
[11:01:29.007]                         if (!has_future) {
[11:01:29.007]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.007]                             info)
[11:01:29.007]                         }
[11:01:29.007]                         else {
[11:01:29.007]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.007]                             info, version)
[11:01:29.007]                         }
[11:01:29.007]                         base::stop(msg)
[11:01:29.007]                       }
[11:01:29.007]                     })
[11:01:29.007]                   }
[11:01:29.007]                   ...future.strategy.old <- future::plan("list")
[11:01:29.007]                   options(future.plan = NULL)
[11:01:29.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.007]                 }
[11:01:29.007]                 ...future.workdir <- getwd()
[11:01:29.007]             }
[11:01:29.007]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.007]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.007]         }
[11:01:29.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.007]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.007]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.007]             base::names(...future.oldOptions))
[11:01:29.007]     }
[11:01:29.007]     if (FALSE) {
[11:01:29.007]     }
[11:01:29.007]     else {
[11:01:29.007]         if (TRUE) {
[11:01:29.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.007]                 open = "w")
[11:01:29.007]         }
[11:01:29.007]         else {
[11:01:29.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.007]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.007]         }
[11:01:29.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.007]             base::sink(type = "output", split = FALSE)
[11:01:29.007]             base::close(...future.stdout)
[11:01:29.007]         }, add = TRUE)
[11:01:29.007]     }
[11:01:29.007]     ...future.frame <- base::sys.nframe()
[11:01:29.007]     ...future.conditions <- base::list()
[11:01:29.007]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.007]     if (FALSE) {
[11:01:29.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.007]     }
[11:01:29.007]     ...future.result <- base::tryCatch({
[11:01:29.007]         base::withCallingHandlers({
[11:01:29.007]             ...future.value <- base::withVisible(base::local(2))
[11:01:29.007]             future::FutureResult(value = ...future.value$value, 
[11:01:29.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.007]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.007]                     ...future.globalenv.names))
[11:01:29.007]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.007]         }, condition = base::local({
[11:01:29.007]             c <- base::c
[11:01:29.007]             inherits <- base::inherits
[11:01:29.007]             invokeRestart <- base::invokeRestart
[11:01:29.007]             length <- base::length
[11:01:29.007]             list <- base::list
[11:01:29.007]             seq.int <- base::seq.int
[11:01:29.007]             signalCondition <- base::signalCondition
[11:01:29.007]             sys.calls <- base::sys.calls
[11:01:29.007]             `[[` <- base::`[[`
[11:01:29.007]             `+` <- base::`+`
[11:01:29.007]             `<<-` <- base::`<<-`
[11:01:29.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.007]                   3L)]
[11:01:29.007]             }
[11:01:29.007]             function(cond) {
[11:01:29.007]                 is_error <- inherits(cond, "error")
[11:01:29.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.007]                   NULL)
[11:01:29.007]                 if (is_error) {
[11:01:29.007]                   sessionInformation <- function() {
[11:01:29.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.007]                       search = base::search(), system = base::Sys.info())
[11:01:29.007]                   }
[11:01:29.007]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.007]                     cond$call), session = sessionInformation(), 
[11:01:29.007]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.007]                   signalCondition(cond)
[11:01:29.007]                 }
[11:01:29.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.007]                 "immediateCondition"))) {
[11:01:29.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.007]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.007]                   if (TRUE && !signal) {
[11:01:29.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.007]                     {
[11:01:29.007]                       inherits <- base::inherits
[11:01:29.007]                       invokeRestart <- base::invokeRestart
[11:01:29.007]                       is.null <- base::is.null
[11:01:29.007]                       muffled <- FALSE
[11:01:29.007]                       if (inherits(cond, "message")) {
[11:01:29.007]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.007]                         if (muffled) 
[11:01:29.007]                           invokeRestart("muffleMessage")
[11:01:29.007]                       }
[11:01:29.007]                       else if (inherits(cond, "warning")) {
[11:01:29.007]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.007]                         if (muffled) 
[11:01:29.007]                           invokeRestart("muffleWarning")
[11:01:29.007]                       }
[11:01:29.007]                       else if (inherits(cond, "condition")) {
[11:01:29.007]                         if (!is.null(pattern)) {
[11:01:29.007]                           computeRestarts <- base::computeRestarts
[11:01:29.007]                           grepl <- base::grepl
[11:01:29.007]                           restarts <- computeRestarts(cond)
[11:01:29.007]                           for (restart in restarts) {
[11:01:29.007]                             name <- restart$name
[11:01:29.007]                             if (is.null(name)) 
[11:01:29.007]                               next
[11:01:29.007]                             if (!grepl(pattern, name)) 
[11:01:29.007]                               next
[11:01:29.007]                             invokeRestart(restart)
[11:01:29.007]                             muffled <- TRUE
[11:01:29.007]                             break
[11:01:29.007]                           }
[11:01:29.007]                         }
[11:01:29.007]                       }
[11:01:29.007]                       invisible(muffled)
[11:01:29.007]                     }
[11:01:29.007]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.007]                   }
[11:01:29.007]                 }
[11:01:29.007]                 else {
[11:01:29.007]                   if (TRUE) {
[11:01:29.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.007]                     {
[11:01:29.007]                       inherits <- base::inherits
[11:01:29.007]                       invokeRestart <- base::invokeRestart
[11:01:29.007]                       is.null <- base::is.null
[11:01:29.007]                       muffled <- FALSE
[11:01:29.007]                       if (inherits(cond, "message")) {
[11:01:29.007]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.007]                         if (muffled) 
[11:01:29.007]                           invokeRestart("muffleMessage")
[11:01:29.007]                       }
[11:01:29.007]                       else if (inherits(cond, "warning")) {
[11:01:29.007]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.007]                         if (muffled) 
[11:01:29.007]                           invokeRestart("muffleWarning")
[11:01:29.007]                       }
[11:01:29.007]                       else if (inherits(cond, "condition")) {
[11:01:29.007]                         if (!is.null(pattern)) {
[11:01:29.007]                           computeRestarts <- base::computeRestarts
[11:01:29.007]                           grepl <- base::grepl
[11:01:29.007]                           restarts <- computeRestarts(cond)
[11:01:29.007]                           for (restart in restarts) {
[11:01:29.007]                             name <- restart$name
[11:01:29.007]                             if (is.null(name)) 
[11:01:29.007]                               next
[11:01:29.007]                             if (!grepl(pattern, name)) 
[11:01:29.007]                               next
[11:01:29.007]                             invokeRestart(restart)
[11:01:29.007]                             muffled <- TRUE
[11:01:29.007]                             break
[11:01:29.007]                           }
[11:01:29.007]                         }
[11:01:29.007]                       }
[11:01:29.007]                       invisible(muffled)
[11:01:29.007]                     }
[11:01:29.007]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.007]                   }
[11:01:29.007]                 }
[11:01:29.007]             }
[11:01:29.007]         }))
[11:01:29.007]     }, error = function(ex) {
[11:01:29.007]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.007]                 ...future.rng), started = ...future.startTime, 
[11:01:29.007]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.007]             version = "1.8"), class = "FutureResult")
[11:01:29.007]     }, finally = {
[11:01:29.007]         if (!identical(...future.workdir, getwd())) 
[11:01:29.007]             setwd(...future.workdir)
[11:01:29.007]         {
[11:01:29.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.007]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.007]             }
[11:01:29.007]             base::options(...future.oldOptions)
[11:01:29.007]             if (.Platform$OS.type == "windows") {
[11:01:29.007]                 old_names <- names(...future.oldEnvVars)
[11:01:29.007]                 envs <- base::Sys.getenv()
[11:01:29.007]                 names <- names(envs)
[11:01:29.007]                 common <- intersect(names, old_names)
[11:01:29.007]                 added <- setdiff(names, old_names)
[11:01:29.007]                 removed <- setdiff(old_names, names)
[11:01:29.007]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.007]                   envs[common]]
[11:01:29.007]                 NAMES <- toupper(changed)
[11:01:29.007]                 args <- list()
[11:01:29.007]                 for (kk in seq_along(NAMES)) {
[11:01:29.007]                   name <- changed[[kk]]
[11:01:29.007]                   NAME <- NAMES[[kk]]
[11:01:29.007]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.007]                     next
[11:01:29.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.007]                 }
[11:01:29.007]                 NAMES <- toupper(added)
[11:01:29.007]                 for (kk in seq_along(NAMES)) {
[11:01:29.007]                   name <- added[[kk]]
[11:01:29.007]                   NAME <- NAMES[[kk]]
[11:01:29.007]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.007]                     next
[11:01:29.007]                   args[[name]] <- ""
[11:01:29.007]                 }
[11:01:29.007]                 NAMES <- toupper(removed)
[11:01:29.007]                 for (kk in seq_along(NAMES)) {
[11:01:29.007]                   name <- removed[[kk]]
[11:01:29.007]                   NAME <- NAMES[[kk]]
[11:01:29.007]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.007]                     next
[11:01:29.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.007]                 }
[11:01:29.007]                 if (length(args) > 0) 
[11:01:29.007]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.007]             }
[11:01:29.007]             else {
[11:01:29.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.007]             }
[11:01:29.007]             {
[11:01:29.007]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.007]                   0L) {
[11:01:29.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.007]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.007]                   base::options(opts)
[11:01:29.007]                 }
[11:01:29.007]                 {
[11:01:29.007]                   {
[11:01:29.007]                     NULL
[11:01:29.007]                     RNGkind("Mersenne-Twister")
[11:01:29.007]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:29.007]                       inherits = FALSE)
[11:01:29.007]                   }
[11:01:29.007]                   options(future.plan = NULL)
[11:01:29.007]                   if (is.na(NA_character_)) 
[11:01:29.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.007]                     .init = FALSE)
[11:01:29.007]                 }
[11:01:29.007]             }
[11:01:29.007]         }
[11:01:29.007]     })
[11:01:29.007]     if (TRUE) {
[11:01:29.007]         base::sink(type = "output", split = FALSE)
[11:01:29.007]         if (TRUE) {
[11:01:29.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.007]         }
[11:01:29.007]         else {
[11:01:29.007]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.007]         }
[11:01:29.007]         base::close(...future.stdout)
[11:01:29.007]         ...future.stdout <- NULL
[11:01:29.007]     }
[11:01:29.007]     ...future.result$conditions <- ...future.conditions
[11:01:29.007]     ...future.result$finished <- base::Sys.time()
[11:01:29.007]     ...future.result
[11:01:29.007] }
[11:01:29.008] plan(): Setting new future strategy stack:
[11:01:29.008] List of future strategies:
[11:01:29.008] 1. sequential:
[11:01:29.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.008]    - tweaked: FALSE
[11:01:29.008]    - call: NULL
[11:01:29.009] plan(): nbrOfWorkers() = 1
[11:01:29.009] plan(): Setting new future strategy stack:
[11:01:29.010] List of future strategies:
[11:01:29.010] 1. sequential:
[11:01:29.010]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.010]    - tweaked: FALSE
[11:01:29.010]    - call: plan(strategy)
[11:01:29.010] plan(): nbrOfWorkers() = 1
[11:01:29.010] SequentialFuture started (and completed)
[11:01:29.010] - Launch lazy future ... done
[11:01:29.010] run() for ‘SequentialFuture’ ... done
[11:01:29.010] getGlobalsAndPackages() ...
[11:01:29.011] Searching for globals...
[11:01:29.011] 
[11:01:29.011] Searching for globals ... DONE
[11:01:29.011] - globals: [0] <none>
[11:01:29.011] getGlobalsAndPackages() ... DONE
[11:01:29.011] run() for ‘Future’ ...
[11:01:29.011] - state: ‘created’
[11:01:29.011] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:29.012] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:29.012] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:29.012]   - Field: ‘label’
[11:01:29.012]   - Field: ‘local’
[11:01:29.012]   - Field: ‘owner’
[11:01:29.012]   - Field: ‘envir’
[11:01:29.012]   - Field: ‘packages’
[11:01:29.012]   - Field: ‘gc’
[11:01:29.012]   - Field: ‘conditions’
[11:01:29.012]   - Field: ‘expr’
[11:01:29.013]   - Field: ‘uuid’
[11:01:29.013]   - Field: ‘seed’
[11:01:29.013]   - Field: ‘version’
[11:01:29.013]   - Field: ‘result’
[11:01:29.013]   - Field: ‘asynchronous’
[11:01:29.013]   - Field: ‘calls’
[11:01:29.013]   - Field: ‘globals’
[11:01:29.013]   - Field: ‘stdout’
[11:01:29.013]   - Field: ‘earlySignal’
[11:01:29.013]   - Field: ‘lazy’
[11:01:29.013]   - Field: ‘state’
[11:01:29.013] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:29.014] - Launch lazy future ...
[11:01:29.014] Packages needed by the future expression (n = 0): <none>
[11:01:29.014] Packages needed by future strategies (n = 0): <none>
[11:01:29.014] {
[11:01:29.014]     {
[11:01:29.014]         {
[11:01:29.014]             ...future.startTime <- base::Sys.time()
[11:01:29.014]             {
[11:01:29.014]                 {
[11:01:29.014]                   {
[11:01:29.014]                     base::local({
[11:01:29.014]                       has_future <- base::requireNamespace("future", 
[11:01:29.014]                         quietly = TRUE)
[11:01:29.014]                       if (has_future) {
[11:01:29.014]                         ns <- base::getNamespace("future")
[11:01:29.014]                         version <- ns[[".package"]][["version"]]
[11:01:29.014]                         if (is.null(version)) 
[11:01:29.014]                           version <- utils::packageVersion("future")
[11:01:29.014]                       }
[11:01:29.014]                       else {
[11:01:29.014]                         version <- NULL
[11:01:29.014]                       }
[11:01:29.014]                       if (!has_future || version < "1.8.0") {
[11:01:29.014]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.014]                           "", base::R.version$version.string), 
[11:01:29.014]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:29.014]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.014]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.014]                             "release", "version")], collapse = " "), 
[11:01:29.014]                           hostname = base::Sys.info()[["nodename"]])
[11:01:29.014]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.014]                           info)
[11:01:29.014]                         info <- base::paste(info, collapse = "; ")
[11:01:29.014]                         if (!has_future) {
[11:01:29.014]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.014]                             info)
[11:01:29.014]                         }
[11:01:29.014]                         else {
[11:01:29.014]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.014]                             info, version)
[11:01:29.014]                         }
[11:01:29.014]                         base::stop(msg)
[11:01:29.014]                       }
[11:01:29.014]                     })
[11:01:29.014]                   }
[11:01:29.014]                   ...future.strategy.old <- future::plan("list")
[11:01:29.014]                   options(future.plan = NULL)
[11:01:29.014]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.014]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.014]                 }
[11:01:29.014]                 ...future.workdir <- getwd()
[11:01:29.014]             }
[11:01:29.014]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.014]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.014]         }
[11:01:29.014]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.014]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.014]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.014]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.014]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.014]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.014]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.014]             base::names(...future.oldOptions))
[11:01:29.014]     }
[11:01:29.014]     if (FALSE) {
[11:01:29.014]     }
[11:01:29.014]     else {
[11:01:29.014]         if (TRUE) {
[11:01:29.014]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.014]                 open = "w")
[11:01:29.014]         }
[11:01:29.014]         else {
[11:01:29.014]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.014]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.014]         }
[11:01:29.014]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.014]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.014]             base::sink(type = "output", split = FALSE)
[11:01:29.014]             base::close(...future.stdout)
[11:01:29.014]         }, add = TRUE)
[11:01:29.014]     }
[11:01:29.014]     ...future.frame <- base::sys.nframe()
[11:01:29.014]     ...future.conditions <- base::list()
[11:01:29.014]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.014]     if (FALSE) {
[11:01:29.014]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.014]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.014]     }
[11:01:29.014]     ...future.result <- base::tryCatch({
[11:01:29.014]         base::withCallingHandlers({
[11:01:29.014]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:29.014]             future::FutureResult(value = ...future.value$value, 
[11:01:29.014]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.014]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.014]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.014]                     ...future.globalenv.names))
[11:01:29.014]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.014]         }, condition = base::local({
[11:01:29.014]             c <- base::c
[11:01:29.014]             inherits <- base::inherits
[11:01:29.014]             invokeRestart <- base::invokeRestart
[11:01:29.014]             length <- base::length
[11:01:29.014]             list <- base::list
[11:01:29.014]             seq.int <- base::seq.int
[11:01:29.014]             signalCondition <- base::signalCondition
[11:01:29.014]             sys.calls <- base::sys.calls
[11:01:29.014]             `[[` <- base::`[[`
[11:01:29.014]             `+` <- base::`+`
[11:01:29.014]             `<<-` <- base::`<<-`
[11:01:29.014]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.014]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.014]                   3L)]
[11:01:29.014]             }
[11:01:29.014]             function(cond) {
[11:01:29.014]                 is_error <- inherits(cond, "error")
[11:01:29.014]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.014]                   NULL)
[11:01:29.014]                 if (is_error) {
[11:01:29.014]                   sessionInformation <- function() {
[11:01:29.014]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.014]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.014]                       search = base::search(), system = base::Sys.info())
[11:01:29.014]                   }
[11:01:29.014]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.014]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.014]                     cond$call), session = sessionInformation(), 
[11:01:29.014]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.014]                   signalCondition(cond)
[11:01:29.014]                 }
[11:01:29.014]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.014]                 "immediateCondition"))) {
[11:01:29.014]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.014]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.014]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.014]                   if (TRUE && !signal) {
[11:01:29.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.014]                     {
[11:01:29.014]                       inherits <- base::inherits
[11:01:29.014]                       invokeRestart <- base::invokeRestart
[11:01:29.014]                       is.null <- base::is.null
[11:01:29.014]                       muffled <- FALSE
[11:01:29.014]                       if (inherits(cond, "message")) {
[11:01:29.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.014]                         if (muffled) 
[11:01:29.014]                           invokeRestart("muffleMessage")
[11:01:29.014]                       }
[11:01:29.014]                       else if (inherits(cond, "warning")) {
[11:01:29.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.014]                         if (muffled) 
[11:01:29.014]                           invokeRestart("muffleWarning")
[11:01:29.014]                       }
[11:01:29.014]                       else if (inherits(cond, "condition")) {
[11:01:29.014]                         if (!is.null(pattern)) {
[11:01:29.014]                           computeRestarts <- base::computeRestarts
[11:01:29.014]                           grepl <- base::grepl
[11:01:29.014]                           restarts <- computeRestarts(cond)
[11:01:29.014]                           for (restart in restarts) {
[11:01:29.014]                             name <- restart$name
[11:01:29.014]                             if (is.null(name)) 
[11:01:29.014]                               next
[11:01:29.014]                             if (!grepl(pattern, name)) 
[11:01:29.014]                               next
[11:01:29.014]                             invokeRestart(restart)
[11:01:29.014]                             muffled <- TRUE
[11:01:29.014]                             break
[11:01:29.014]                           }
[11:01:29.014]                         }
[11:01:29.014]                       }
[11:01:29.014]                       invisible(muffled)
[11:01:29.014]                     }
[11:01:29.014]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.014]                   }
[11:01:29.014]                 }
[11:01:29.014]                 else {
[11:01:29.014]                   if (TRUE) {
[11:01:29.014]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.014]                     {
[11:01:29.014]                       inherits <- base::inherits
[11:01:29.014]                       invokeRestart <- base::invokeRestart
[11:01:29.014]                       is.null <- base::is.null
[11:01:29.014]                       muffled <- FALSE
[11:01:29.014]                       if (inherits(cond, "message")) {
[11:01:29.014]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.014]                         if (muffled) 
[11:01:29.014]                           invokeRestart("muffleMessage")
[11:01:29.014]                       }
[11:01:29.014]                       else if (inherits(cond, "warning")) {
[11:01:29.014]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.014]                         if (muffled) 
[11:01:29.014]                           invokeRestart("muffleWarning")
[11:01:29.014]                       }
[11:01:29.014]                       else if (inherits(cond, "condition")) {
[11:01:29.014]                         if (!is.null(pattern)) {
[11:01:29.014]                           computeRestarts <- base::computeRestarts
[11:01:29.014]                           grepl <- base::grepl
[11:01:29.014]                           restarts <- computeRestarts(cond)
[11:01:29.014]                           for (restart in restarts) {
[11:01:29.014]                             name <- restart$name
[11:01:29.014]                             if (is.null(name)) 
[11:01:29.014]                               next
[11:01:29.014]                             if (!grepl(pattern, name)) 
[11:01:29.014]                               next
[11:01:29.014]                             invokeRestart(restart)
[11:01:29.014]                             muffled <- TRUE
[11:01:29.014]                             break
[11:01:29.014]                           }
[11:01:29.014]                         }
[11:01:29.014]                       }
[11:01:29.014]                       invisible(muffled)
[11:01:29.014]                     }
[11:01:29.014]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.014]                   }
[11:01:29.014]                 }
[11:01:29.014]             }
[11:01:29.014]         }))
[11:01:29.014]     }, error = function(ex) {
[11:01:29.014]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.014]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.014]                 ...future.rng), started = ...future.startTime, 
[11:01:29.014]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.014]             version = "1.8"), class = "FutureResult")
[11:01:29.014]     }, finally = {
[11:01:29.014]         if (!identical(...future.workdir, getwd())) 
[11:01:29.014]             setwd(...future.workdir)
[11:01:29.014]         {
[11:01:29.014]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.014]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.014]             }
[11:01:29.014]             base::options(...future.oldOptions)
[11:01:29.014]             if (.Platform$OS.type == "windows") {
[11:01:29.014]                 old_names <- names(...future.oldEnvVars)
[11:01:29.014]                 envs <- base::Sys.getenv()
[11:01:29.014]                 names <- names(envs)
[11:01:29.014]                 common <- intersect(names, old_names)
[11:01:29.014]                 added <- setdiff(names, old_names)
[11:01:29.014]                 removed <- setdiff(old_names, names)
[11:01:29.014]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.014]                   envs[common]]
[11:01:29.014]                 NAMES <- toupper(changed)
[11:01:29.014]                 args <- list()
[11:01:29.014]                 for (kk in seq_along(NAMES)) {
[11:01:29.014]                   name <- changed[[kk]]
[11:01:29.014]                   NAME <- NAMES[[kk]]
[11:01:29.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.014]                     next
[11:01:29.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.014]                 }
[11:01:29.014]                 NAMES <- toupper(added)
[11:01:29.014]                 for (kk in seq_along(NAMES)) {
[11:01:29.014]                   name <- added[[kk]]
[11:01:29.014]                   NAME <- NAMES[[kk]]
[11:01:29.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.014]                     next
[11:01:29.014]                   args[[name]] <- ""
[11:01:29.014]                 }
[11:01:29.014]                 NAMES <- toupper(removed)
[11:01:29.014]                 for (kk in seq_along(NAMES)) {
[11:01:29.014]                   name <- removed[[kk]]
[11:01:29.014]                   NAME <- NAMES[[kk]]
[11:01:29.014]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.014]                     next
[11:01:29.014]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.014]                 }
[11:01:29.014]                 if (length(args) > 0) 
[11:01:29.014]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.014]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.014]             }
[11:01:29.014]             else {
[11:01:29.014]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.014]             }
[11:01:29.014]             {
[11:01:29.014]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.014]                   0L) {
[11:01:29.014]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.014]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.014]                   base::options(opts)
[11:01:29.014]                 }
[11:01:29.014]                 {
[11:01:29.014]                   {
[11:01:29.014]                     NULL
[11:01:29.014]                     RNGkind("Mersenne-Twister")
[11:01:29.014]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:29.014]                       inherits = FALSE)
[11:01:29.014]                   }
[11:01:29.014]                   options(future.plan = NULL)
[11:01:29.014]                   if (is.na(NA_character_)) 
[11:01:29.014]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.014]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.014]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.014]                     .init = FALSE)
[11:01:29.014]                 }
[11:01:29.014]             }
[11:01:29.014]         }
[11:01:29.014]     })
[11:01:29.014]     if (TRUE) {
[11:01:29.014]         base::sink(type = "output", split = FALSE)
[11:01:29.014]         if (TRUE) {
[11:01:29.014]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.014]         }
[11:01:29.014]         else {
[11:01:29.014]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.014]         }
[11:01:29.014]         base::close(...future.stdout)
[11:01:29.014]         ...future.stdout <- NULL
[11:01:29.014]     }
[11:01:29.014]     ...future.result$conditions <- ...future.conditions
[11:01:29.014]     ...future.result$finished <- base::Sys.time()
[11:01:29.014]     ...future.result
[11:01:29.014] }
[11:01:29.016] plan(): Setting new future strategy stack:
[11:01:29.016] List of future strategies:
[11:01:29.016] 1. sequential:
[11:01:29.016]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.016]    - tweaked: FALSE
[11:01:29.016]    - call: NULL
[11:01:29.016] plan(): nbrOfWorkers() = 1
[11:01:29.017] plan(): Setting new future strategy stack:
[11:01:29.017] List of future strategies:
[11:01:29.017] 1. sequential:
[11:01:29.017]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.017]    - tweaked: FALSE
[11:01:29.017]    - call: plan(strategy)
[11:01:29.018] plan(): nbrOfWorkers() = 1
[11:01:29.018] SequentialFuture started (and completed)
[11:01:29.018] - Launch lazy future ... done
[11:01:29.018] run() for ‘SequentialFuture’ ... done
[11:01:29.018] getGlobalsAndPackages() ...
[11:01:29.018] Searching for globals...
[11:01:29.019] - globals found: [1] ‘{’
[11:01:29.019] Searching for globals ... DONE
[11:01:29.019] Resolving globals: FALSE
[11:01:29.019] 
[11:01:29.019] 
[11:01:29.019] getGlobalsAndPackages() ... DONE
[11:01:29.020] run() for ‘Future’ ...
[11:01:29.020] - state: ‘created’
[11:01:29.020] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:29.020] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:29.020] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:29.020]   - Field: ‘label’
[11:01:29.020]   - Field: ‘local’
[11:01:29.021]   - Field: ‘owner’
[11:01:29.021]   - Field: ‘envir’
[11:01:29.021]   - Field: ‘packages’
[11:01:29.021]   - Field: ‘gc’
[11:01:29.021]   - Field: ‘conditions’
[11:01:29.021]   - Field: ‘expr’
[11:01:29.021]   - Field: ‘uuid’
[11:01:29.021]   - Field: ‘seed’
[11:01:29.021]   - Field: ‘version’
[11:01:29.021]   - Field: ‘result’
[11:01:29.021]   - Field: ‘asynchronous’
[11:01:29.021]   - Field: ‘calls’
[11:01:29.021]   - Field: ‘globals’
[11:01:29.022]   - Field: ‘stdout’
[11:01:29.022]   - Field: ‘earlySignal’
[11:01:29.022]   - Field: ‘lazy’
[11:01:29.022]   - Field: ‘state’
[11:01:29.022] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:29.022] - Launch lazy future ...
[11:01:29.022] Packages needed by the future expression (n = 0): <none>
[11:01:29.022] Packages needed by future strategies (n = 0): <none>
[11:01:29.023] {
[11:01:29.023]     {
[11:01:29.023]         {
[11:01:29.023]             ...future.startTime <- base::Sys.time()
[11:01:29.023]             {
[11:01:29.023]                 {
[11:01:29.023]                   {
[11:01:29.023]                     base::local({
[11:01:29.023]                       has_future <- base::requireNamespace("future", 
[11:01:29.023]                         quietly = TRUE)
[11:01:29.023]                       if (has_future) {
[11:01:29.023]                         ns <- base::getNamespace("future")
[11:01:29.023]                         version <- ns[[".package"]][["version"]]
[11:01:29.023]                         if (is.null(version)) 
[11:01:29.023]                           version <- utils::packageVersion("future")
[11:01:29.023]                       }
[11:01:29.023]                       else {
[11:01:29.023]                         version <- NULL
[11:01:29.023]                       }
[11:01:29.023]                       if (!has_future || version < "1.8.0") {
[11:01:29.023]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.023]                           "", base::R.version$version.string), 
[11:01:29.023]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:29.023]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.023]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.023]                             "release", "version")], collapse = " "), 
[11:01:29.023]                           hostname = base::Sys.info()[["nodename"]])
[11:01:29.023]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.023]                           info)
[11:01:29.023]                         info <- base::paste(info, collapse = "; ")
[11:01:29.023]                         if (!has_future) {
[11:01:29.023]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.023]                             info)
[11:01:29.023]                         }
[11:01:29.023]                         else {
[11:01:29.023]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.023]                             info, version)
[11:01:29.023]                         }
[11:01:29.023]                         base::stop(msg)
[11:01:29.023]                       }
[11:01:29.023]                     })
[11:01:29.023]                   }
[11:01:29.023]                   ...future.strategy.old <- future::plan("list")
[11:01:29.023]                   options(future.plan = NULL)
[11:01:29.023]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.023]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.023]                 }
[11:01:29.023]                 ...future.workdir <- getwd()
[11:01:29.023]             }
[11:01:29.023]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.023]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.023]         }
[11:01:29.023]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.023]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.023]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.023]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.023]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.023]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.023]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.023]             base::names(...future.oldOptions))
[11:01:29.023]     }
[11:01:29.023]     if (FALSE) {
[11:01:29.023]     }
[11:01:29.023]     else {
[11:01:29.023]         if (TRUE) {
[11:01:29.023]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.023]                 open = "w")
[11:01:29.023]         }
[11:01:29.023]         else {
[11:01:29.023]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.023]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.023]         }
[11:01:29.023]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.023]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.023]             base::sink(type = "output", split = FALSE)
[11:01:29.023]             base::close(...future.stdout)
[11:01:29.023]         }, add = TRUE)
[11:01:29.023]     }
[11:01:29.023]     ...future.frame <- base::sys.nframe()
[11:01:29.023]     ...future.conditions <- base::list()
[11:01:29.023]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.023]     if (FALSE) {
[11:01:29.023]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.023]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.023]     }
[11:01:29.023]     ...future.result <- base::tryCatch({
[11:01:29.023]         base::withCallingHandlers({
[11:01:29.023]             ...future.value <- base::withVisible(base::local({
[11:01:29.023]                 4
[11:01:29.023]             }))
[11:01:29.023]             future::FutureResult(value = ...future.value$value, 
[11:01:29.023]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.023]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.023]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.023]                     ...future.globalenv.names))
[11:01:29.023]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.023]         }, condition = base::local({
[11:01:29.023]             c <- base::c
[11:01:29.023]             inherits <- base::inherits
[11:01:29.023]             invokeRestart <- base::invokeRestart
[11:01:29.023]             length <- base::length
[11:01:29.023]             list <- base::list
[11:01:29.023]             seq.int <- base::seq.int
[11:01:29.023]             signalCondition <- base::signalCondition
[11:01:29.023]             sys.calls <- base::sys.calls
[11:01:29.023]             `[[` <- base::`[[`
[11:01:29.023]             `+` <- base::`+`
[11:01:29.023]             `<<-` <- base::`<<-`
[11:01:29.023]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.023]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.023]                   3L)]
[11:01:29.023]             }
[11:01:29.023]             function(cond) {
[11:01:29.023]                 is_error <- inherits(cond, "error")
[11:01:29.023]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.023]                   NULL)
[11:01:29.023]                 if (is_error) {
[11:01:29.023]                   sessionInformation <- function() {
[11:01:29.023]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.023]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.023]                       search = base::search(), system = base::Sys.info())
[11:01:29.023]                   }
[11:01:29.023]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.023]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.023]                     cond$call), session = sessionInformation(), 
[11:01:29.023]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.023]                   signalCondition(cond)
[11:01:29.023]                 }
[11:01:29.023]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.023]                 "immediateCondition"))) {
[11:01:29.023]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.023]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.023]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.023]                   if (TRUE && !signal) {
[11:01:29.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.023]                     {
[11:01:29.023]                       inherits <- base::inherits
[11:01:29.023]                       invokeRestart <- base::invokeRestart
[11:01:29.023]                       is.null <- base::is.null
[11:01:29.023]                       muffled <- FALSE
[11:01:29.023]                       if (inherits(cond, "message")) {
[11:01:29.023]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.023]                         if (muffled) 
[11:01:29.023]                           invokeRestart("muffleMessage")
[11:01:29.023]                       }
[11:01:29.023]                       else if (inherits(cond, "warning")) {
[11:01:29.023]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.023]                         if (muffled) 
[11:01:29.023]                           invokeRestart("muffleWarning")
[11:01:29.023]                       }
[11:01:29.023]                       else if (inherits(cond, "condition")) {
[11:01:29.023]                         if (!is.null(pattern)) {
[11:01:29.023]                           computeRestarts <- base::computeRestarts
[11:01:29.023]                           grepl <- base::grepl
[11:01:29.023]                           restarts <- computeRestarts(cond)
[11:01:29.023]                           for (restart in restarts) {
[11:01:29.023]                             name <- restart$name
[11:01:29.023]                             if (is.null(name)) 
[11:01:29.023]                               next
[11:01:29.023]                             if (!grepl(pattern, name)) 
[11:01:29.023]                               next
[11:01:29.023]                             invokeRestart(restart)
[11:01:29.023]                             muffled <- TRUE
[11:01:29.023]                             break
[11:01:29.023]                           }
[11:01:29.023]                         }
[11:01:29.023]                       }
[11:01:29.023]                       invisible(muffled)
[11:01:29.023]                     }
[11:01:29.023]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.023]                   }
[11:01:29.023]                 }
[11:01:29.023]                 else {
[11:01:29.023]                   if (TRUE) {
[11:01:29.023]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.023]                     {
[11:01:29.023]                       inherits <- base::inherits
[11:01:29.023]                       invokeRestart <- base::invokeRestart
[11:01:29.023]                       is.null <- base::is.null
[11:01:29.023]                       muffled <- FALSE
[11:01:29.023]                       if (inherits(cond, "message")) {
[11:01:29.023]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.023]                         if (muffled) 
[11:01:29.023]                           invokeRestart("muffleMessage")
[11:01:29.023]                       }
[11:01:29.023]                       else if (inherits(cond, "warning")) {
[11:01:29.023]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.023]                         if (muffled) 
[11:01:29.023]                           invokeRestart("muffleWarning")
[11:01:29.023]                       }
[11:01:29.023]                       else if (inherits(cond, "condition")) {
[11:01:29.023]                         if (!is.null(pattern)) {
[11:01:29.023]                           computeRestarts <- base::computeRestarts
[11:01:29.023]                           grepl <- base::grepl
[11:01:29.023]                           restarts <- computeRestarts(cond)
[11:01:29.023]                           for (restart in restarts) {
[11:01:29.023]                             name <- restart$name
[11:01:29.023]                             if (is.null(name)) 
[11:01:29.023]                               next
[11:01:29.023]                             if (!grepl(pattern, name)) 
[11:01:29.023]                               next
[11:01:29.023]                             invokeRestart(restart)
[11:01:29.023]                             muffled <- TRUE
[11:01:29.023]                             break
[11:01:29.023]                           }
[11:01:29.023]                         }
[11:01:29.023]                       }
[11:01:29.023]                       invisible(muffled)
[11:01:29.023]                     }
[11:01:29.023]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.023]                   }
[11:01:29.023]                 }
[11:01:29.023]             }
[11:01:29.023]         }))
[11:01:29.023]     }, error = function(ex) {
[11:01:29.023]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.023]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.023]                 ...future.rng), started = ...future.startTime, 
[11:01:29.023]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.023]             version = "1.8"), class = "FutureResult")
[11:01:29.023]     }, finally = {
[11:01:29.023]         if (!identical(...future.workdir, getwd())) 
[11:01:29.023]             setwd(...future.workdir)
[11:01:29.023]         {
[11:01:29.023]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.023]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.023]             }
[11:01:29.023]             base::options(...future.oldOptions)
[11:01:29.023]             if (.Platform$OS.type == "windows") {
[11:01:29.023]                 old_names <- names(...future.oldEnvVars)
[11:01:29.023]                 envs <- base::Sys.getenv()
[11:01:29.023]                 names <- names(envs)
[11:01:29.023]                 common <- intersect(names, old_names)
[11:01:29.023]                 added <- setdiff(names, old_names)
[11:01:29.023]                 removed <- setdiff(old_names, names)
[11:01:29.023]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.023]                   envs[common]]
[11:01:29.023]                 NAMES <- toupper(changed)
[11:01:29.023]                 args <- list()
[11:01:29.023]                 for (kk in seq_along(NAMES)) {
[11:01:29.023]                   name <- changed[[kk]]
[11:01:29.023]                   NAME <- NAMES[[kk]]
[11:01:29.023]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.023]                     next
[11:01:29.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.023]                 }
[11:01:29.023]                 NAMES <- toupper(added)
[11:01:29.023]                 for (kk in seq_along(NAMES)) {
[11:01:29.023]                   name <- added[[kk]]
[11:01:29.023]                   NAME <- NAMES[[kk]]
[11:01:29.023]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.023]                     next
[11:01:29.023]                   args[[name]] <- ""
[11:01:29.023]                 }
[11:01:29.023]                 NAMES <- toupper(removed)
[11:01:29.023]                 for (kk in seq_along(NAMES)) {
[11:01:29.023]                   name <- removed[[kk]]
[11:01:29.023]                   NAME <- NAMES[[kk]]
[11:01:29.023]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.023]                     next
[11:01:29.023]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.023]                 }
[11:01:29.023]                 if (length(args) > 0) 
[11:01:29.023]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.023]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.023]             }
[11:01:29.023]             else {
[11:01:29.023]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.023]             }
[11:01:29.023]             {
[11:01:29.023]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.023]                   0L) {
[11:01:29.023]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.023]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.023]                   base::options(opts)
[11:01:29.023]                 }
[11:01:29.023]                 {
[11:01:29.023]                   {
[11:01:29.023]                     NULL
[11:01:29.023]                     RNGkind("Mersenne-Twister")
[11:01:29.023]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:29.023]                       inherits = FALSE)
[11:01:29.023]                   }
[11:01:29.023]                   options(future.plan = NULL)
[11:01:29.023]                   if (is.na(NA_character_)) 
[11:01:29.023]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.023]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.023]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.023]                     .init = FALSE)
[11:01:29.023]                 }
[11:01:29.023]             }
[11:01:29.023]         }
[11:01:29.023]     })
[11:01:29.023]     if (TRUE) {
[11:01:29.023]         base::sink(type = "output", split = FALSE)
[11:01:29.023]         if (TRUE) {
[11:01:29.023]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.023]         }
[11:01:29.023]         else {
[11:01:29.023]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.023]         }
[11:01:29.023]         base::close(...future.stdout)
[11:01:29.023]         ...future.stdout <- NULL
[11:01:29.023]     }
[11:01:29.023]     ...future.result$conditions <- ...future.conditions
[11:01:29.023]     ...future.result$finished <- base::Sys.time()
[11:01:29.023]     ...future.result
[11:01:29.023] }
[11:01:29.024] plan(): Setting new future strategy stack:
[11:01:29.024] List of future strategies:
[11:01:29.024] 1. sequential:
[11:01:29.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.024]    - tweaked: FALSE
[11:01:29.024]    - call: NULL
[11:01:29.025] plan(): nbrOfWorkers() = 1
[11:01:29.026] plan(): Setting new future strategy stack:
[11:01:29.026] List of future strategies:
[11:01:29.026] 1. sequential:
[11:01:29.026]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.026]    - tweaked: FALSE
[11:01:29.026]    - call: plan(strategy)
[11:01:29.026] plan(): nbrOfWorkers() = 1
[11:01:29.026] SequentialFuture started (and completed)
[11:01:29.026] - Launch lazy future ... done
[11:01:29.026] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c4dd0908> 
Classes 'listenv', 'environment' <environment: 0x55a9c6bf41a0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[11:01:29.030] resolved() for ‘SequentialFuture’ ...
[11:01:29.031] - state: ‘finished’
[11:01:29.031] - run: TRUE
[11:01:29.031] - result: ‘FutureResult’
[11:01:29.031] resolved() for ‘SequentialFuture’ ... done
[11:01:29.031] resolved() for ‘SequentialFuture’ ...
[11:01:29.031] - state: ‘finished’
[11:01:29.031] - run: TRUE
[11:01:29.031] - result: ‘FutureResult’
[11:01:29.031] resolved() for ‘SequentialFuture’ ... done
[11:01:29.031] resolved() for ‘SequentialFuture’ ...
[11:01:29.031] - state: ‘finished’
[11:01:29.031] - run: TRUE
[11:01:29.032] - result: ‘FutureResult’
[11:01:29.032] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:29.034] resolve() on list environment ...
[11:01:29.034]  recursive: 0
[11:01:29.035]  length: 6
[11:01:29.035]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:29.035] signalConditionsASAP(numeric, pos=1) ...
[11:01:29.035] - nx: 6
[11:01:29.035] - relay: TRUE
[11:01:29.035] - stdout: TRUE
[11:01:29.035] - signal: TRUE
[11:01:29.035] - resignal: FALSE
[11:01:29.035] - force: TRUE
[11:01:29.035] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.035] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.036]  - until=2
[11:01:29.036]  - relaying element #2
[11:01:29.036] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.036] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.036] signalConditionsASAP(NULL, pos=1) ... done
[11:01:29.036]  length: 5 (resolved future 1)
[11:01:29.036] resolved() for ‘SequentialFuture’ ...
[11:01:29.036] - state: ‘finished’
[11:01:29.036] - run: TRUE
[11:01:29.036] - result: ‘FutureResult’
[11:01:29.036] resolved() for ‘SequentialFuture’ ... done
[11:01:29.036] Future #2
[11:01:29.037] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:29.037] - nx: 6
[11:01:29.037] - relay: TRUE
[11:01:29.037] - stdout: TRUE
[11:01:29.037] - signal: TRUE
[11:01:29.037] - resignal: FALSE
[11:01:29.037] - force: TRUE
[11:01:29.037] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.037] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.037]  - until=2
[11:01:29.037]  - relaying element #2
[11:01:29.037] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.038] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.038] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:29.038]  length: 4 (resolved future 2)
[11:01:29.038] resolved() for ‘SequentialFuture’ ...
[11:01:29.038] - state: ‘finished’
[11:01:29.038] - run: TRUE
[11:01:29.038] - result: ‘FutureResult’
[11:01:29.038] resolved() for ‘SequentialFuture’ ... done
[11:01:29.038] Future #3
[11:01:29.038] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:29.038] - nx: 6
[11:01:29.039] - relay: TRUE
[11:01:29.039] - stdout: TRUE
[11:01:29.039] - signal: TRUE
[11:01:29.039] - resignal: FALSE
[11:01:29.039] - force: TRUE
[11:01:29.039] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.039] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.039]  - until=3
[11:01:29.039]  - relaying element #3
[11:01:29.039] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.039] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.039] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:29.040]  length: 3 (resolved future 3)
[11:01:29.040] resolved() for ‘SequentialFuture’ ...
[11:01:29.040] - state: ‘finished’
[11:01:29.040] - run: TRUE
[11:01:29.040] - result: ‘FutureResult’
[11:01:29.040] resolved() for ‘SequentialFuture’ ... done
[11:01:29.040] Future #4
[11:01:29.040] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:29.040] - nx: 6
[11:01:29.040] - relay: TRUE
[11:01:29.040] - stdout: TRUE
[11:01:29.040] - signal: TRUE
[11:01:29.041] - resignal: FALSE
[11:01:29.041] - force: TRUE
[11:01:29.041] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.041] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.041]  - until=4
[11:01:29.041]  - relaying element #4
[11:01:29.041] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.041] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.041] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:29.041]  length: 2 (resolved future 4)
[11:01:29.041] signalConditionsASAP(NULL, pos=5) ...
[11:01:29.042] - nx: 6
[11:01:29.042] - relay: TRUE
[11:01:29.042] - stdout: TRUE
[11:01:29.042] - signal: TRUE
[11:01:29.042] - resignal: FALSE
[11:01:29.042] - force: TRUE
[11:01:29.042] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.042] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.042]  - until=6
[11:01:29.042]  - relaying element #6
[11:01:29.042] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.042] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.042] signalConditionsASAP(NULL, pos=5) ... done
[11:01:29.043]  length: 1 (resolved future 5)
[11:01:29.043] signalConditionsASAP(numeric, pos=6) ...
[11:01:29.043] - nx: 6
[11:01:29.043] - relay: TRUE
[11:01:29.043] - stdout: TRUE
[11:01:29.043] - signal: TRUE
[11:01:29.043] - resignal: FALSE
[11:01:29.043] - force: TRUE
[11:01:29.043] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.043] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.043]  - until=6
[11:01:29.043] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.043] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.044] signalConditionsASAP(numeric, pos=6) ... done
[11:01:29.044]  length: 0 (resolved future 6)
[11:01:29.044] Relaying remaining futures
[11:01:29.044] signalConditionsASAP(NULL, pos=0) ...
[11:01:29.044] - nx: 6
[11:01:29.044] - relay: TRUE
[11:01:29.044] - stdout: TRUE
[11:01:29.044] - signal: TRUE
[11:01:29.044] - resignal: FALSE
[11:01:29.044] - force: TRUE
[11:01:29.044] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.044] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:29.044] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.045] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.045] signalConditionsASAP(NULL, pos=0) ... done
[11:01:29.045] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a9c4488650> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[11:01:29.046] getGlobalsAndPackages() ...
[11:01:29.047] Searching for globals...
[11:01:29.047] 
[11:01:29.047] Searching for globals ... DONE
[11:01:29.047] - globals: [0] <none>
[11:01:29.047] getGlobalsAndPackages() ... DONE
[11:01:29.047] run() for ‘Future’ ...
[11:01:29.047] - state: ‘created’
[11:01:29.048] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:29.048] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:29.048] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:29.048]   - Field: ‘label’
[11:01:29.048]   - Field: ‘local’
[11:01:29.048]   - Field: ‘owner’
[11:01:29.048]   - Field: ‘envir’
[11:01:29.048]   - Field: ‘packages’
[11:01:29.048]   - Field: ‘gc’
[11:01:29.048]   - Field: ‘conditions’
[11:01:29.049]   - Field: ‘expr’
[11:01:29.049]   - Field: ‘uuid’
[11:01:29.049]   - Field: ‘seed’
[11:01:29.049]   - Field: ‘version’
[11:01:29.050]   - Field: ‘result’
[11:01:29.050]   - Field: ‘asynchronous’
[11:01:29.050]   - Field: ‘calls’
[11:01:29.050]   - Field: ‘globals’
[11:01:29.050]   - Field: ‘stdout’
[11:01:29.050]   - Field: ‘earlySignal’
[11:01:29.050]   - Field: ‘lazy’
[11:01:29.050]   - Field: ‘state’
[11:01:29.050] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:29.050] - Launch lazy future ...
[11:01:29.051] Packages needed by the future expression (n = 0): <none>
[11:01:29.051] Packages needed by future strategies (n = 0): <none>
[11:01:29.051] {
[11:01:29.051]     {
[11:01:29.051]         {
[11:01:29.051]             ...future.startTime <- base::Sys.time()
[11:01:29.051]             {
[11:01:29.051]                 {
[11:01:29.051]                   {
[11:01:29.051]                     base::local({
[11:01:29.051]                       has_future <- base::requireNamespace("future", 
[11:01:29.051]                         quietly = TRUE)
[11:01:29.051]                       if (has_future) {
[11:01:29.051]                         ns <- base::getNamespace("future")
[11:01:29.051]                         version <- ns[[".package"]][["version"]]
[11:01:29.051]                         if (is.null(version)) 
[11:01:29.051]                           version <- utils::packageVersion("future")
[11:01:29.051]                       }
[11:01:29.051]                       else {
[11:01:29.051]                         version <- NULL
[11:01:29.051]                       }
[11:01:29.051]                       if (!has_future || version < "1.8.0") {
[11:01:29.051]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.051]                           "", base::R.version$version.string), 
[11:01:29.051]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:29.051]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.051]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.051]                             "release", "version")], collapse = " "), 
[11:01:29.051]                           hostname = base::Sys.info()[["nodename"]])
[11:01:29.051]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.051]                           info)
[11:01:29.051]                         info <- base::paste(info, collapse = "; ")
[11:01:29.051]                         if (!has_future) {
[11:01:29.051]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.051]                             info)
[11:01:29.051]                         }
[11:01:29.051]                         else {
[11:01:29.051]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.051]                             info, version)
[11:01:29.051]                         }
[11:01:29.051]                         base::stop(msg)
[11:01:29.051]                       }
[11:01:29.051]                     })
[11:01:29.051]                   }
[11:01:29.051]                   ...future.strategy.old <- future::plan("list")
[11:01:29.051]                   options(future.plan = NULL)
[11:01:29.051]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.051]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.051]                 }
[11:01:29.051]                 ...future.workdir <- getwd()
[11:01:29.051]             }
[11:01:29.051]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.051]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.051]         }
[11:01:29.051]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.051]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.051]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.051]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.051]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.051]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.051]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.051]             base::names(...future.oldOptions))
[11:01:29.051]     }
[11:01:29.051]     if (FALSE) {
[11:01:29.051]     }
[11:01:29.051]     else {
[11:01:29.051]         if (TRUE) {
[11:01:29.051]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.051]                 open = "w")
[11:01:29.051]         }
[11:01:29.051]         else {
[11:01:29.051]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.051]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.051]         }
[11:01:29.051]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.051]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.051]             base::sink(type = "output", split = FALSE)
[11:01:29.051]             base::close(...future.stdout)
[11:01:29.051]         }, add = TRUE)
[11:01:29.051]     }
[11:01:29.051]     ...future.frame <- base::sys.nframe()
[11:01:29.051]     ...future.conditions <- base::list()
[11:01:29.051]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.051]     if (FALSE) {
[11:01:29.051]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.051]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.051]     }
[11:01:29.051]     ...future.result <- base::tryCatch({
[11:01:29.051]         base::withCallingHandlers({
[11:01:29.051]             ...future.value <- base::withVisible(base::local(2))
[11:01:29.051]             future::FutureResult(value = ...future.value$value, 
[11:01:29.051]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.051]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.051]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.051]                     ...future.globalenv.names))
[11:01:29.051]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.051]         }, condition = base::local({
[11:01:29.051]             c <- base::c
[11:01:29.051]             inherits <- base::inherits
[11:01:29.051]             invokeRestart <- base::invokeRestart
[11:01:29.051]             length <- base::length
[11:01:29.051]             list <- base::list
[11:01:29.051]             seq.int <- base::seq.int
[11:01:29.051]             signalCondition <- base::signalCondition
[11:01:29.051]             sys.calls <- base::sys.calls
[11:01:29.051]             `[[` <- base::`[[`
[11:01:29.051]             `+` <- base::`+`
[11:01:29.051]             `<<-` <- base::`<<-`
[11:01:29.051]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.051]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.051]                   3L)]
[11:01:29.051]             }
[11:01:29.051]             function(cond) {
[11:01:29.051]                 is_error <- inherits(cond, "error")
[11:01:29.051]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.051]                   NULL)
[11:01:29.051]                 if (is_error) {
[11:01:29.051]                   sessionInformation <- function() {
[11:01:29.051]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.051]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.051]                       search = base::search(), system = base::Sys.info())
[11:01:29.051]                   }
[11:01:29.051]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.051]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.051]                     cond$call), session = sessionInformation(), 
[11:01:29.051]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.051]                   signalCondition(cond)
[11:01:29.051]                 }
[11:01:29.051]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.051]                 "immediateCondition"))) {
[11:01:29.051]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.051]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.051]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.051]                   if (TRUE && !signal) {
[11:01:29.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.051]                     {
[11:01:29.051]                       inherits <- base::inherits
[11:01:29.051]                       invokeRestart <- base::invokeRestart
[11:01:29.051]                       is.null <- base::is.null
[11:01:29.051]                       muffled <- FALSE
[11:01:29.051]                       if (inherits(cond, "message")) {
[11:01:29.051]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.051]                         if (muffled) 
[11:01:29.051]                           invokeRestart("muffleMessage")
[11:01:29.051]                       }
[11:01:29.051]                       else if (inherits(cond, "warning")) {
[11:01:29.051]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.051]                         if (muffled) 
[11:01:29.051]                           invokeRestart("muffleWarning")
[11:01:29.051]                       }
[11:01:29.051]                       else if (inherits(cond, "condition")) {
[11:01:29.051]                         if (!is.null(pattern)) {
[11:01:29.051]                           computeRestarts <- base::computeRestarts
[11:01:29.051]                           grepl <- base::grepl
[11:01:29.051]                           restarts <- computeRestarts(cond)
[11:01:29.051]                           for (restart in restarts) {
[11:01:29.051]                             name <- restart$name
[11:01:29.051]                             if (is.null(name)) 
[11:01:29.051]                               next
[11:01:29.051]                             if (!grepl(pattern, name)) 
[11:01:29.051]                               next
[11:01:29.051]                             invokeRestart(restart)
[11:01:29.051]                             muffled <- TRUE
[11:01:29.051]                             break
[11:01:29.051]                           }
[11:01:29.051]                         }
[11:01:29.051]                       }
[11:01:29.051]                       invisible(muffled)
[11:01:29.051]                     }
[11:01:29.051]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.051]                   }
[11:01:29.051]                 }
[11:01:29.051]                 else {
[11:01:29.051]                   if (TRUE) {
[11:01:29.051]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.051]                     {
[11:01:29.051]                       inherits <- base::inherits
[11:01:29.051]                       invokeRestart <- base::invokeRestart
[11:01:29.051]                       is.null <- base::is.null
[11:01:29.051]                       muffled <- FALSE
[11:01:29.051]                       if (inherits(cond, "message")) {
[11:01:29.051]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.051]                         if (muffled) 
[11:01:29.051]                           invokeRestart("muffleMessage")
[11:01:29.051]                       }
[11:01:29.051]                       else if (inherits(cond, "warning")) {
[11:01:29.051]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.051]                         if (muffled) 
[11:01:29.051]                           invokeRestart("muffleWarning")
[11:01:29.051]                       }
[11:01:29.051]                       else if (inherits(cond, "condition")) {
[11:01:29.051]                         if (!is.null(pattern)) {
[11:01:29.051]                           computeRestarts <- base::computeRestarts
[11:01:29.051]                           grepl <- base::grepl
[11:01:29.051]                           restarts <- computeRestarts(cond)
[11:01:29.051]                           for (restart in restarts) {
[11:01:29.051]                             name <- restart$name
[11:01:29.051]                             if (is.null(name)) 
[11:01:29.051]                               next
[11:01:29.051]                             if (!grepl(pattern, name)) 
[11:01:29.051]                               next
[11:01:29.051]                             invokeRestart(restart)
[11:01:29.051]                             muffled <- TRUE
[11:01:29.051]                             break
[11:01:29.051]                           }
[11:01:29.051]                         }
[11:01:29.051]                       }
[11:01:29.051]                       invisible(muffled)
[11:01:29.051]                     }
[11:01:29.051]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.051]                   }
[11:01:29.051]                 }
[11:01:29.051]             }
[11:01:29.051]         }))
[11:01:29.051]     }, error = function(ex) {
[11:01:29.051]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.051]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.051]                 ...future.rng), started = ...future.startTime, 
[11:01:29.051]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.051]             version = "1.8"), class = "FutureResult")
[11:01:29.051]     }, finally = {
[11:01:29.051]         if (!identical(...future.workdir, getwd())) 
[11:01:29.051]             setwd(...future.workdir)
[11:01:29.051]         {
[11:01:29.051]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.051]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.051]             }
[11:01:29.051]             base::options(...future.oldOptions)
[11:01:29.051]             if (.Platform$OS.type == "windows") {
[11:01:29.051]                 old_names <- names(...future.oldEnvVars)
[11:01:29.051]                 envs <- base::Sys.getenv()
[11:01:29.051]                 names <- names(envs)
[11:01:29.051]                 common <- intersect(names, old_names)
[11:01:29.051]                 added <- setdiff(names, old_names)
[11:01:29.051]                 removed <- setdiff(old_names, names)
[11:01:29.051]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.051]                   envs[common]]
[11:01:29.051]                 NAMES <- toupper(changed)
[11:01:29.051]                 args <- list()
[11:01:29.051]                 for (kk in seq_along(NAMES)) {
[11:01:29.051]                   name <- changed[[kk]]
[11:01:29.051]                   NAME <- NAMES[[kk]]
[11:01:29.051]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.051]                     next
[11:01:29.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.051]                 }
[11:01:29.051]                 NAMES <- toupper(added)
[11:01:29.051]                 for (kk in seq_along(NAMES)) {
[11:01:29.051]                   name <- added[[kk]]
[11:01:29.051]                   NAME <- NAMES[[kk]]
[11:01:29.051]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.051]                     next
[11:01:29.051]                   args[[name]] <- ""
[11:01:29.051]                 }
[11:01:29.051]                 NAMES <- toupper(removed)
[11:01:29.051]                 for (kk in seq_along(NAMES)) {
[11:01:29.051]                   name <- removed[[kk]]
[11:01:29.051]                   NAME <- NAMES[[kk]]
[11:01:29.051]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.051]                     next
[11:01:29.051]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.051]                 }
[11:01:29.051]                 if (length(args) > 0) 
[11:01:29.051]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.051]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.051]             }
[11:01:29.051]             else {
[11:01:29.051]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.051]             }
[11:01:29.051]             {
[11:01:29.051]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.051]                   0L) {
[11:01:29.051]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.051]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.051]                   base::options(opts)
[11:01:29.051]                 }
[11:01:29.051]                 {
[11:01:29.051]                   {
[11:01:29.051]                     NULL
[11:01:29.051]                     RNGkind("Mersenne-Twister")
[11:01:29.051]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:29.051]                       inherits = FALSE)
[11:01:29.051]                   }
[11:01:29.051]                   options(future.plan = NULL)
[11:01:29.051]                   if (is.na(NA_character_)) 
[11:01:29.051]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.051]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.051]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.051]                     .init = FALSE)
[11:01:29.051]                 }
[11:01:29.051]             }
[11:01:29.051]         }
[11:01:29.051]     })
[11:01:29.051]     if (TRUE) {
[11:01:29.051]         base::sink(type = "output", split = FALSE)
[11:01:29.051]         if (TRUE) {
[11:01:29.051]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.051]         }
[11:01:29.051]         else {
[11:01:29.051]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.051]         }
[11:01:29.051]         base::close(...future.stdout)
[11:01:29.051]         ...future.stdout <- NULL
[11:01:29.051]     }
[11:01:29.051]     ...future.result$conditions <- ...future.conditions
[11:01:29.051]     ...future.result$finished <- base::Sys.time()
[11:01:29.051]     ...future.result
[11:01:29.051] }
[11:01:29.053] plan(): Setting new future strategy stack:
[11:01:29.053] List of future strategies:
[11:01:29.053] 1. sequential:
[11:01:29.053]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.053]    - tweaked: FALSE
[11:01:29.053]    - call: NULL
[11:01:29.053] plan(): nbrOfWorkers() = 1
[11:01:29.054] plan(): Setting new future strategy stack:
[11:01:29.054] List of future strategies:
[11:01:29.054] 1. sequential:
[11:01:29.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.054]    - tweaked: FALSE
[11:01:29.054]    - call: plan(strategy)
[11:01:29.054] plan(): nbrOfWorkers() = 1
[11:01:29.055] SequentialFuture started (and completed)
[11:01:29.055] - Launch lazy future ... done
[11:01:29.055] run() for ‘SequentialFuture’ ... done
[11:01:29.055] getGlobalsAndPackages() ...
[11:01:29.055] Searching for globals...
[11:01:29.055] 
[11:01:29.055] Searching for globals ... DONE
[11:01:29.055] - globals: [0] <none>
[11:01:29.056] getGlobalsAndPackages() ... DONE
[11:01:29.056] run() for ‘Future’ ...
[11:01:29.056] - state: ‘created’
[11:01:29.056] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:29.056] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:29.056] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:29.056]   - Field: ‘label’
[11:01:29.056]   - Field: ‘local’
[11:01:29.056]   - Field: ‘owner’
[11:01:29.057]   - Field: ‘envir’
[11:01:29.057]   - Field: ‘packages’
[11:01:29.057]   - Field: ‘gc’
[11:01:29.057]   - Field: ‘conditions’
[11:01:29.057]   - Field: ‘expr’
[11:01:29.057]   - Field: ‘uuid’
[11:01:29.057]   - Field: ‘seed’
[11:01:29.057]   - Field: ‘version’
[11:01:29.057]   - Field: ‘result’
[11:01:29.057]   - Field: ‘asynchronous’
[11:01:29.057]   - Field: ‘calls’
[11:01:29.057]   - Field: ‘globals’
[11:01:29.058]   - Field: ‘stdout’
[11:01:29.058]   - Field: ‘earlySignal’
[11:01:29.058]   - Field: ‘lazy’
[11:01:29.058]   - Field: ‘state’
[11:01:29.058] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:29.058] - Launch lazy future ...
[11:01:29.058] Packages needed by the future expression (n = 0): <none>
[11:01:29.058] Packages needed by future strategies (n = 0): <none>
[11:01:29.059] {
[11:01:29.059]     {
[11:01:29.059]         {
[11:01:29.059]             ...future.startTime <- base::Sys.time()
[11:01:29.059]             {
[11:01:29.059]                 {
[11:01:29.059]                   {
[11:01:29.059]                     base::local({
[11:01:29.059]                       has_future <- base::requireNamespace("future", 
[11:01:29.059]                         quietly = TRUE)
[11:01:29.059]                       if (has_future) {
[11:01:29.059]                         ns <- base::getNamespace("future")
[11:01:29.059]                         version <- ns[[".package"]][["version"]]
[11:01:29.059]                         if (is.null(version)) 
[11:01:29.059]                           version <- utils::packageVersion("future")
[11:01:29.059]                       }
[11:01:29.059]                       else {
[11:01:29.059]                         version <- NULL
[11:01:29.059]                       }
[11:01:29.059]                       if (!has_future || version < "1.8.0") {
[11:01:29.059]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.059]                           "", base::R.version$version.string), 
[11:01:29.059]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:29.059]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.059]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.059]                             "release", "version")], collapse = " "), 
[11:01:29.059]                           hostname = base::Sys.info()[["nodename"]])
[11:01:29.059]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.059]                           info)
[11:01:29.059]                         info <- base::paste(info, collapse = "; ")
[11:01:29.059]                         if (!has_future) {
[11:01:29.059]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.059]                             info)
[11:01:29.059]                         }
[11:01:29.059]                         else {
[11:01:29.059]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.059]                             info, version)
[11:01:29.059]                         }
[11:01:29.059]                         base::stop(msg)
[11:01:29.059]                       }
[11:01:29.059]                     })
[11:01:29.059]                   }
[11:01:29.059]                   ...future.strategy.old <- future::plan("list")
[11:01:29.059]                   options(future.plan = NULL)
[11:01:29.059]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.059]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.059]                 }
[11:01:29.059]                 ...future.workdir <- getwd()
[11:01:29.059]             }
[11:01:29.059]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.059]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.059]         }
[11:01:29.059]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.059]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.059]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.059]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.059]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.059]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.059]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.059]             base::names(...future.oldOptions))
[11:01:29.059]     }
[11:01:29.059]     if (FALSE) {
[11:01:29.059]     }
[11:01:29.059]     else {
[11:01:29.059]         if (TRUE) {
[11:01:29.059]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.059]                 open = "w")
[11:01:29.059]         }
[11:01:29.059]         else {
[11:01:29.059]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.059]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.059]         }
[11:01:29.059]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.059]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.059]             base::sink(type = "output", split = FALSE)
[11:01:29.059]             base::close(...future.stdout)
[11:01:29.059]         }, add = TRUE)
[11:01:29.059]     }
[11:01:29.059]     ...future.frame <- base::sys.nframe()
[11:01:29.059]     ...future.conditions <- base::list()
[11:01:29.059]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.059]     if (FALSE) {
[11:01:29.059]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.059]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.059]     }
[11:01:29.059]     ...future.result <- base::tryCatch({
[11:01:29.059]         base::withCallingHandlers({
[11:01:29.059]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:29.059]             future::FutureResult(value = ...future.value$value, 
[11:01:29.059]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.059]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.059]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.059]                     ...future.globalenv.names))
[11:01:29.059]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.059]         }, condition = base::local({
[11:01:29.059]             c <- base::c
[11:01:29.059]             inherits <- base::inherits
[11:01:29.059]             invokeRestart <- base::invokeRestart
[11:01:29.059]             length <- base::length
[11:01:29.059]             list <- base::list
[11:01:29.059]             seq.int <- base::seq.int
[11:01:29.059]             signalCondition <- base::signalCondition
[11:01:29.059]             sys.calls <- base::sys.calls
[11:01:29.059]             `[[` <- base::`[[`
[11:01:29.059]             `+` <- base::`+`
[11:01:29.059]             `<<-` <- base::`<<-`
[11:01:29.059]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.059]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.059]                   3L)]
[11:01:29.059]             }
[11:01:29.059]             function(cond) {
[11:01:29.059]                 is_error <- inherits(cond, "error")
[11:01:29.059]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.059]                   NULL)
[11:01:29.059]                 if (is_error) {
[11:01:29.059]                   sessionInformation <- function() {
[11:01:29.059]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.059]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.059]                       search = base::search(), system = base::Sys.info())
[11:01:29.059]                   }
[11:01:29.059]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.059]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.059]                     cond$call), session = sessionInformation(), 
[11:01:29.059]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.059]                   signalCondition(cond)
[11:01:29.059]                 }
[11:01:29.059]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.059]                 "immediateCondition"))) {
[11:01:29.059]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.059]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.059]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.059]                   if (TRUE && !signal) {
[11:01:29.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.059]                     {
[11:01:29.059]                       inherits <- base::inherits
[11:01:29.059]                       invokeRestart <- base::invokeRestart
[11:01:29.059]                       is.null <- base::is.null
[11:01:29.059]                       muffled <- FALSE
[11:01:29.059]                       if (inherits(cond, "message")) {
[11:01:29.059]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.059]                         if (muffled) 
[11:01:29.059]                           invokeRestart("muffleMessage")
[11:01:29.059]                       }
[11:01:29.059]                       else if (inherits(cond, "warning")) {
[11:01:29.059]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.059]                         if (muffled) 
[11:01:29.059]                           invokeRestart("muffleWarning")
[11:01:29.059]                       }
[11:01:29.059]                       else if (inherits(cond, "condition")) {
[11:01:29.059]                         if (!is.null(pattern)) {
[11:01:29.059]                           computeRestarts <- base::computeRestarts
[11:01:29.059]                           grepl <- base::grepl
[11:01:29.059]                           restarts <- computeRestarts(cond)
[11:01:29.059]                           for (restart in restarts) {
[11:01:29.059]                             name <- restart$name
[11:01:29.059]                             if (is.null(name)) 
[11:01:29.059]                               next
[11:01:29.059]                             if (!grepl(pattern, name)) 
[11:01:29.059]                               next
[11:01:29.059]                             invokeRestart(restart)
[11:01:29.059]                             muffled <- TRUE
[11:01:29.059]                             break
[11:01:29.059]                           }
[11:01:29.059]                         }
[11:01:29.059]                       }
[11:01:29.059]                       invisible(muffled)
[11:01:29.059]                     }
[11:01:29.059]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.059]                   }
[11:01:29.059]                 }
[11:01:29.059]                 else {
[11:01:29.059]                   if (TRUE) {
[11:01:29.059]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.059]                     {
[11:01:29.059]                       inherits <- base::inherits
[11:01:29.059]                       invokeRestart <- base::invokeRestart
[11:01:29.059]                       is.null <- base::is.null
[11:01:29.059]                       muffled <- FALSE
[11:01:29.059]                       if (inherits(cond, "message")) {
[11:01:29.059]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.059]                         if (muffled) 
[11:01:29.059]                           invokeRestart("muffleMessage")
[11:01:29.059]                       }
[11:01:29.059]                       else if (inherits(cond, "warning")) {
[11:01:29.059]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.059]                         if (muffled) 
[11:01:29.059]                           invokeRestart("muffleWarning")
[11:01:29.059]                       }
[11:01:29.059]                       else if (inherits(cond, "condition")) {
[11:01:29.059]                         if (!is.null(pattern)) {
[11:01:29.059]                           computeRestarts <- base::computeRestarts
[11:01:29.059]                           grepl <- base::grepl
[11:01:29.059]                           restarts <- computeRestarts(cond)
[11:01:29.059]                           for (restart in restarts) {
[11:01:29.059]                             name <- restart$name
[11:01:29.059]                             if (is.null(name)) 
[11:01:29.059]                               next
[11:01:29.059]                             if (!grepl(pattern, name)) 
[11:01:29.059]                               next
[11:01:29.059]                             invokeRestart(restart)
[11:01:29.059]                             muffled <- TRUE
[11:01:29.059]                             break
[11:01:29.059]                           }
[11:01:29.059]                         }
[11:01:29.059]                       }
[11:01:29.059]                       invisible(muffled)
[11:01:29.059]                     }
[11:01:29.059]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.059]                   }
[11:01:29.059]                 }
[11:01:29.059]             }
[11:01:29.059]         }))
[11:01:29.059]     }, error = function(ex) {
[11:01:29.059]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.059]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.059]                 ...future.rng), started = ...future.startTime, 
[11:01:29.059]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.059]             version = "1.8"), class = "FutureResult")
[11:01:29.059]     }, finally = {
[11:01:29.059]         if (!identical(...future.workdir, getwd())) 
[11:01:29.059]             setwd(...future.workdir)
[11:01:29.059]         {
[11:01:29.059]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.059]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.059]             }
[11:01:29.059]             base::options(...future.oldOptions)
[11:01:29.059]             if (.Platform$OS.type == "windows") {
[11:01:29.059]                 old_names <- names(...future.oldEnvVars)
[11:01:29.059]                 envs <- base::Sys.getenv()
[11:01:29.059]                 names <- names(envs)
[11:01:29.059]                 common <- intersect(names, old_names)
[11:01:29.059]                 added <- setdiff(names, old_names)
[11:01:29.059]                 removed <- setdiff(old_names, names)
[11:01:29.059]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.059]                   envs[common]]
[11:01:29.059]                 NAMES <- toupper(changed)
[11:01:29.059]                 args <- list()
[11:01:29.059]                 for (kk in seq_along(NAMES)) {
[11:01:29.059]                   name <- changed[[kk]]
[11:01:29.059]                   NAME <- NAMES[[kk]]
[11:01:29.059]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.059]                     next
[11:01:29.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.059]                 }
[11:01:29.059]                 NAMES <- toupper(added)
[11:01:29.059]                 for (kk in seq_along(NAMES)) {
[11:01:29.059]                   name <- added[[kk]]
[11:01:29.059]                   NAME <- NAMES[[kk]]
[11:01:29.059]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.059]                     next
[11:01:29.059]                   args[[name]] <- ""
[11:01:29.059]                 }
[11:01:29.059]                 NAMES <- toupper(removed)
[11:01:29.059]                 for (kk in seq_along(NAMES)) {
[11:01:29.059]                   name <- removed[[kk]]
[11:01:29.059]                   NAME <- NAMES[[kk]]
[11:01:29.059]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.059]                     next
[11:01:29.059]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.059]                 }
[11:01:29.059]                 if (length(args) > 0) 
[11:01:29.059]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.059]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.059]             }
[11:01:29.059]             else {
[11:01:29.059]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.059]             }
[11:01:29.059]             {
[11:01:29.059]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.059]                   0L) {
[11:01:29.059]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.059]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.059]                   base::options(opts)
[11:01:29.059]                 }
[11:01:29.059]                 {
[11:01:29.059]                   {
[11:01:29.059]                     NULL
[11:01:29.059]                     RNGkind("Mersenne-Twister")
[11:01:29.059]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:29.059]                       inherits = FALSE)
[11:01:29.059]                   }
[11:01:29.059]                   options(future.plan = NULL)
[11:01:29.059]                   if (is.na(NA_character_)) 
[11:01:29.059]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.059]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.059]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.059]                     .init = FALSE)
[11:01:29.059]                 }
[11:01:29.059]             }
[11:01:29.059]         }
[11:01:29.059]     })
[11:01:29.059]     if (TRUE) {
[11:01:29.059]         base::sink(type = "output", split = FALSE)
[11:01:29.059]         if (TRUE) {
[11:01:29.059]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.059]         }
[11:01:29.059]         else {
[11:01:29.059]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.059]         }
[11:01:29.059]         base::close(...future.stdout)
[11:01:29.059]         ...future.stdout <- NULL
[11:01:29.059]     }
[11:01:29.059]     ...future.result$conditions <- ...future.conditions
[11:01:29.059]     ...future.result$finished <- base::Sys.time()
[11:01:29.059]     ...future.result
[11:01:29.059] }
[11:01:29.060] plan(): Setting new future strategy stack:
[11:01:29.060] List of future strategies:
[11:01:29.060] 1. sequential:
[11:01:29.060]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.060]    - tweaked: FALSE
[11:01:29.060]    - call: NULL
[11:01:29.061] plan(): nbrOfWorkers() = 1
[11:01:29.061] plan(): Setting new future strategy stack:
[11:01:29.062] List of future strategies:
[11:01:29.062] 1. sequential:
[11:01:29.062]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.062]    - tweaked: FALSE
[11:01:29.062]    - call: plan(strategy)
[11:01:29.062] plan(): nbrOfWorkers() = 1
[11:01:29.062] SequentialFuture started (and completed)
[11:01:29.062] - Launch lazy future ... done
[11:01:29.062] run() for ‘SequentialFuture’ ... done
[11:01:29.063] getGlobalsAndPackages() ...
[11:01:29.063] Searching for globals...
[11:01:29.063] - globals found: [1] ‘{’
[11:01:29.063] Searching for globals ... DONE
[11:01:29.063] Resolving globals: FALSE
[11:01:29.064] 
[11:01:29.064] 
[11:01:29.064] getGlobalsAndPackages() ... DONE
[11:01:29.064] run() for ‘Future’ ...
[11:01:29.064] - state: ‘created’
[11:01:29.064] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:29.064] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:29.065] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:29.065]   - Field: ‘label’
[11:01:29.065]   - Field: ‘local’
[11:01:29.065]   - Field: ‘owner’
[11:01:29.065]   - Field: ‘envir’
[11:01:29.065]   - Field: ‘packages’
[11:01:29.065]   - Field: ‘gc’
[11:01:29.065]   - Field: ‘conditions’
[11:01:29.065]   - Field: ‘expr’
[11:01:29.065]   - Field: ‘uuid’
[11:01:29.065]   - Field: ‘seed’
[11:01:29.065]   - Field: ‘version’
[11:01:29.066]   - Field: ‘result’
[11:01:29.066]   - Field: ‘asynchronous’
[11:01:29.066]   - Field: ‘calls’
[11:01:29.066]   - Field: ‘globals’
[11:01:29.066]   - Field: ‘stdout’
[11:01:29.066]   - Field: ‘earlySignal’
[11:01:29.066]   - Field: ‘lazy’
[11:01:29.066]   - Field: ‘state’
[11:01:29.066] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:29.066] - Launch lazy future ...
[11:01:29.066] Packages needed by the future expression (n = 0): <none>
[11:01:29.067] Packages needed by future strategies (n = 0): <none>
[11:01:29.067] {
[11:01:29.067]     {
[11:01:29.067]         {
[11:01:29.067]             ...future.startTime <- base::Sys.time()
[11:01:29.067]             {
[11:01:29.067]                 {
[11:01:29.067]                   {
[11:01:29.067]                     base::local({
[11:01:29.067]                       has_future <- base::requireNamespace("future", 
[11:01:29.067]                         quietly = TRUE)
[11:01:29.067]                       if (has_future) {
[11:01:29.067]                         ns <- base::getNamespace("future")
[11:01:29.067]                         version <- ns[[".package"]][["version"]]
[11:01:29.067]                         if (is.null(version)) 
[11:01:29.067]                           version <- utils::packageVersion("future")
[11:01:29.067]                       }
[11:01:29.067]                       else {
[11:01:29.067]                         version <- NULL
[11:01:29.067]                       }
[11:01:29.067]                       if (!has_future || version < "1.8.0") {
[11:01:29.067]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.067]                           "", base::R.version$version.string), 
[11:01:29.067]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:29.067]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.067]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.067]                             "release", "version")], collapse = " "), 
[11:01:29.067]                           hostname = base::Sys.info()[["nodename"]])
[11:01:29.067]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.067]                           info)
[11:01:29.067]                         info <- base::paste(info, collapse = "; ")
[11:01:29.067]                         if (!has_future) {
[11:01:29.067]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.067]                             info)
[11:01:29.067]                         }
[11:01:29.067]                         else {
[11:01:29.067]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.067]                             info, version)
[11:01:29.067]                         }
[11:01:29.067]                         base::stop(msg)
[11:01:29.067]                       }
[11:01:29.067]                     })
[11:01:29.067]                   }
[11:01:29.067]                   ...future.strategy.old <- future::plan("list")
[11:01:29.067]                   options(future.plan = NULL)
[11:01:29.067]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.067]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.067]                 }
[11:01:29.067]                 ...future.workdir <- getwd()
[11:01:29.067]             }
[11:01:29.067]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.067]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.067]         }
[11:01:29.067]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.067]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.067]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.067]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.067]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.067]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.067]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.067]             base::names(...future.oldOptions))
[11:01:29.067]     }
[11:01:29.067]     if (FALSE) {
[11:01:29.067]     }
[11:01:29.067]     else {
[11:01:29.067]         if (TRUE) {
[11:01:29.067]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.067]                 open = "w")
[11:01:29.067]         }
[11:01:29.067]         else {
[11:01:29.067]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.067]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.067]         }
[11:01:29.067]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.067]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.067]             base::sink(type = "output", split = FALSE)
[11:01:29.067]             base::close(...future.stdout)
[11:01:29.067]         }, add = TRUE)
[11:01:29.067]     }
[11:01:29.067]     ...future.frame <- base::sys.nframe()
[11:01:29.067]     ...future.conditions <- base::list()
[11:01:29.067]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.067]     if (FALSE) {
[11:01:29.067]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.067]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.067]     }
[11:01:29.067]     ...future.result <- base::tryCatch({
[11:01:29.067]         base::withCallingHandlers({
[11:01:29.067]             ...future.value <- base::withVisible(base::local({
[11:01:29.067]                 4
[11:01:29.067]             }))
[11:01:29.067]             future::FutureResult(value = ...future.value$value, 
[11:01:29.067]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.067]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.067]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.067]                     ...future.globalenv.names))
[11:01:29.067]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.067]         }, condition = base::local({
[11:01:29.067]             c <- base::c
[11:01:29.067]             inherits <- base::inherits
[11:01:29.067]             invokeRestart <- base::invokeRestart
[11:01:29.067]             length <- base::length
[11:01:29.067]             list <- base::list
[11:01:29.067]             seq.int <- base::seq.int
[11:01:29.067]             signalCondition <- base::signalCondition
[11:01:29.067]             sys.calls <- base::sys.calls
[11:01:29.067]             `[[` <- base::`[[`
[11:01:29.067]             `+` <- base::`+`
[11:01:29.067]             `<<-` <- base::`<<-`
[11:01:29.067]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.067]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.067]                   3L)]
[11:01:29.067]             }
[11:01:29.067]             function(cond) {
[11:01:29.067]                 is_error <- inherits(cond, "error")
[11:01:29.067]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.067]                   NULL)
[11:01:29.067]                 if (is_error) {
[11:01:29.067]                   sessionInformation <- function() {
[11:01:29.067]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.067]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.067]                       search = base::search(), system = base::Sys.info())
[11:01:29.067]                   }
[11:01:29.067]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.067]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.067]                     cond$call), session = sessionInformation(), 
[11:01:29.067]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.067]                   signalCondition(cond)
[11:01:29.067]                 }
[11:01:29.067]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.067]                 "immediateCondition"))) {
[11:01:29.067]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.067]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.067]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.067]                   if (TRUE && !signal) {
[11:01:29.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.067]                     {
[11:01:29.067]                       inherits <- base::inherits
[11:01:29.067]                       invokeRestart <- base::invokeRestart
[11:01:29.067]                       is.null <- base::is.null
[11:01:29.067]                       muffled <- FALSE
[11:01:29.067]                       if (inherits(cond, "message")) {
[11:01:29.067]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.067]                         if (muffled) 
[11:01:29.067]                           invokeRestart("muffleMessage")
[11:01:29.067]                       }
[11:01:29.067]                       else if (inherits(cond, "warning")) {
[11:01:29.067]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.067]                         if (muffled) 
[11:01:29.067]                           invokeRestart("muffleWarning")
[11:01:29.067]                       }
[11:01:29.067]                       else if (inherits(cond, "condition")) {
[11:01:29.067]                         if (!is.null(pattern)) {
[11:01:29.067]                           computeRestarts <- base::computeRestarts
[11:01:29.067]                           grepl <- base::grepl
[11:01:29.067]                           restarts <- computeRestarts(cond)
[11:01:29.067]                           for (restart in restarts) {
[11:01:29.067]                             name <- restart$name
[11:01:29.067]                             if (is.null(name)) 
[11:01:29.067]                               next
[11:01:29.067]                             if (!grepl(pattern, name)) 
[11:01:29.067]                               next
[11:01:29.067]                             invokeRestart(restart)
[11:01:29.067]                             muffled <- TRUE
[11:01:29.067]                             break
[11:01:29.067]                           }
[11:01:29.067]                         }
[11:01:29.067]                       }
[11:01:29.067]                       invisible(muffled)
[11:01:29.067]                     }
[11:01:29.067]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.067]                   }
[11:01:29.067]                 }
[11:01:29.067]                 else {
[11:01:29.067]                   if (TRUE) {
[11:01:29.067]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.067]                     {
[11:01:29.067]                       inherits <- base::inherits
[11:01:29.067]                       invokeRestart <- base::invokeRestart
[11:01:29.067]                       is.null <- base::is.null
[11:01:29.067]                       muffled <- FALSE
[11:01:29.067]                       if (inherits(cond, "message")) {
[11:01:29.067]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.067]                         if (muffled) 
[11:01:29.067]                           invokeRestart("muffleMessage")
[11:01:29.067]                       }
[11:01:29.067]                       else if (inherits(cond, "warning")) {
[11:01:29.067]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.067]                         if (muffled) 
[11:01:29.067]                           invokeRestart("muffleWarning")
[11:01:29.067]                       }
[11:01:29.067]                       else if (inherits(cond, "condition")) {
[11:01:29.067]                         if (!is.null(pattern)) {
[11:01:29.067]                           computeRestarts <- base::computeRestarts
[11:01:29.067]                           grepl <- base::grepl
[11:01:29.067]                           restarts <- computeRestarts(cond)
[11:01:29.067]                           for (restart in restarts) {
[11:01:29.067]                             name <- restart$name
[11:01:29.067]                             if (is.null(name)) 
[11:01:29.067]                               next
[11:01:29.067]                             if (!grepl(pattern, name)) 
[11:01:29.067]                               next
[11:01:29.067]                             invokeRestart(restart)
[11:01:29.067]                             muffled <- TRUE
[11:01:29.067]                             break
[11:01:29.067]                           }
[11:01:29.067]                         }
[11:01:29.067]                       }
[11:01:29.067]                       invisible(muffled)
[11:01:29.067]                     }
[11:01:29.067]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.067]                   }
[11:01:29.067]                 }
[11:01:29.067]             }
[11:01:29.067]         }))
[11:01:29.067]     }, error = function(ex) {
[11:01:29.067]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.067]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.067]                 ...future.rng), started = ...future.startTime, 
[11:01:29.067]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.067]             version = "1.8"), class = "FutureResult")
[11:01:29.067]     }, finally = {
[11:01:29.067]         if (!identical(...future.workdir, getwd())) 
[11:01:29.067]             setwd(...future.workdir)
[11:01:29.067]         {
[11:01:29.067]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.067]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.067]             }
[11:01:29.067]             base::options(...future.oldOptions)
[11:01:29.067]             if (.Platform$OS.type == "windows") {
[11:01:29.067]                 old_names <- names(...future.oldEnvVars)
[11:01:29.067]                 envs <- base::Sys.getenv()
[11:01:29.067]                 names <- names(envs)
[11:01:29.067]                 common <- intersect(names, old_names)
[11:01:29.067]                 added <- setdiff(names, old_names)
[11:01:29.067]                 removed <- setdiff(old_names, names)
[11:01:29.067]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.067]                   envs[common]]
[11:01:29.067]                 NAMES <- toupper(changed)
[11:01:29.067]                 args <- list()
[11:01:29.067]                 for (kk in seq_along(NAMES)) {
[11:01:29.067]                   name <- changed[[kk]]
[11:01:29.067]                   NAME <- NAMES[[kk]]
[11:01:29.067]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.067]                     next
[11:01:29.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.067]                 }
[11:01:29.067]                 NAMES <- toupper(added)
[11:01:29.067]                 for (kk in seq_along(NAMES)) {
[11:01:29.067]                   name <- added[[kk]]
[11:01:29.067]                   NAME <- NAMES[[kk]]
[11:01:29.067]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.067]                     next
[11:01:29.067]                   args[[name]] <- ""
[11:01:29.067]                 }
[11:01:29.067]                 NAMES <- toupper(removed)
[11:01:29.067]                 for (kk in seq_along(NAMES)) {
[11:01:29.067]                   name <- removed[[kk]]
[11:01:29.067]                   NAME <- NAMES[[kk]]
[11:01:29.067]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.067]                     next
[11:01:29.067]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.067]                 }
[11:01:29.067]                 if (length(args) > 0) 
[11:01:29.067]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.067]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.067]             }
[11:01:29.067]             else {
[11:01:29.067]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.067]             }
[11:01:29.067]             {
[11:01:29.067]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.067]                   0L) {
[11:01:29.067]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.067]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.067]                   base::options(opts)
[11:01:29.067]                 }
[11:01:29.067]                 {
[11:01:29.067]                   {
[11:01:29.067]                     NULL
[11:01:29.067]                     RNGkind("Mersenne-Twister")
[11:01:29.067]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:29.067]                       inherits = FALSE)
[11:01:29.067]                   }
[11:01:29.067]                   options(future.plan = NULL)
[11:01:29.067]                   if (is.na(NA_character_)) 
[11:01:29.067]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.067]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.067]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.067]                     .init = FALSE)
[11:01:29.067]                 }
[11:01:29.067]             }
[11:01:29.067]         }
[11:01:29.067]     })
[11:01:29.067]     if (TRUE) {
[11:01:29.067]         base::sink(type = "output", split = FALSE)
[11:01:29.067]         if (TRUE) {
[11:01:29.067]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.067]         }
[11:01:29.067]         else {
[11:01:29.067]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.067]         }
[11:01:29.067]         base::close(...future.stdout)
[11:01:29.067]         ...future.stdout <- NULL
[11:01:29.067]     }
[11:01:29.067]     ...future.result$conditions <- ...future.conditions
[11:01:29.067]     ...future.result$finished <- base::Sys.time()
[11:01:29.067]     ...future.result
[11:01:29.067] }
[11:01:29.069] plan(): Setting new future strategy stack:
[11:01:29.069] List of future strategies:
[11:01:29.069] 1. sequential:
[11:01:29.069]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.069]    - tweaked: FALSE
[11:01:29.069]    - call: NULL
[11:01:29.069] plan(): nbrOfWorkers() = 1
[11:01:29.070] plan(): Setting new future strategy stack:
[11:01:29.070] List of future strategies:
[11:01:29.070] 1. sequential:
[11:01:29.070]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.070]    - tweaked: FALSE
[11:01:29.070]    - call: plan(strategy)
[11:01:29.070] plan(): nbrOfWorkers() = 1
[11:01:29.070] SequentialFuture started (and completed)
[11:01:29.071] - Launch lazy future ... done
[11:01:29.071] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c6c0e280> 
Classes 'listenv', 'environment' <environment: 0x55a9c69a1858> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[11:01:29.074] resolved() for ‘SequentialFuture’ ...
[11:01:29.074] - state: ‘finished’
[11:01:29.074] - run: TRUE
[11:01:29.074] - result: ‘FutureResult’
[11:01:29.074] resolved() for ‘SequentialFuture’ ... done
[11:01:29.075] resolved() for ‘SequentialFuture’ ...
[11:01:29.075] - state: ‘finished’
[11:01:29.075] - run: TRUE
[11:01:29.075] - result: ‘FutureResult’
[11:01:29.075] resolved() for ‘SequentialFuture’ ... done
[11:01:29.075] resolved() for ‘SequentialFuture’ ...
[11:01:29.075] - state: ‘finished’
[11:01:29.075] - run: TRUE
[11:01:29.075] - result: ‘FutureResult’
[11:01:29.075] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:29.078] resolve() on list environment ...
[11:01:29.078]  recursive: 0
[11:01:29.079]  length: 6
[11:01:29.079]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:29.080] signalConditionsASAP(numeric, pos=1) ...
[11:01:29.080] - nx: 6
[11:01:29.080] - relay: TRUE
[11:01:29.080] - stdout: TRUE
[11:01:29.080] - signal: TRUE
[11:01:29.080] - resignal: FALSE
[11:01:29.080] - force: TRUE
[11:01:29.080] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.080] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.080]  - until=2
[11:01:29.080]  - relaying element #2
[11:01:29.080] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.080] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.081] signalConditionsASAP(NULL, pos=1) ... done
[11:01:29.081]  length: 5 (resolved future 1)
[11:01:29.081] resolved() for ‘SequentialFuture’ ...
[11:01:29.081] - state: ‘finished’
[11:01:29.081] - run: TRUE
[11:01:29.081] - result: ‘FutureResult’
[11:01:29.081] resolved() for ‘SequentialFuture’ ... done
[11:01:29.081] Future #2
[11:01:29.081] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:29.081] - nx: 6
[11:01:29.081] - relay: TRUE
[11:01:29.081] - stdout: TRUE
[11:01:29.082] - signal: TRUE
[11:01:29.082] - resignal: FALSE
[11:01:29.082] - force: TRUE
[11:01:29.082] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.082] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.082]  - until=2
[11:01:29.082]  - relaying element #2
[11:01:29.082] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.082] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.082] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:29.082]  length: 4 (resolved future 2)
[11:01:29.083] resolved() for ‘SequentialFuture’ ...
[11:01:29.083] - state: ‘finished’
[11:01:29.083] - run: TRUE
[11:01:29.083] - result: ‘FutureResult’
[11:01:29.083] resolved() for ‘SequentialFuture’ ... done
[11:01:29.083] Future #3
[11:01:29.083] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:29.083] - nx: 6
[11:01:29.083] - relay: TRUE
[11:01:29.083] - stdout: TRUE
[11:01:29.083] - signal: TRUE
[11:01:29.083] - resignal: FALSE
[11:01:29.083] - force: TRUE
[11:01:29.084] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.084] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.084]  - until=3
[11:01:29.084]  - relaying element #3
[11:01:29.084] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.084] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.084] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:29.084]  length: 3 (resolved future 3)
[11:01:29.084] resolved() for ‘SequentialFuture’ ...
[11:01:29.084] - state: ‘finished’
[11:01:29.084] - run: TRUE
[11:01:29.085] - result: ‘FutureResult’
[11:01:29.085] resolved() for ‘SequentialFuture’ ... done
[11:01:29.085] Future #4
[11:01:29.085] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:29.085] - nx: 6
[11:01:29.085] - relay: TRUE
[11:01:29.085] - stdout: TRUE
[11:01:29.085] - signal: TRUE
[11:01:29.085] - resignal: FALSE
[11:01:29.085] - force: TRUE
[11:01:29.085] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.085] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.085]  - until=4
[11:01:29.086]  - relaying element #4
[11:01:29.086] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.086] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.086] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:29.086]  length: 2 (resolved future 4)
[11:01:29.086] signalConditionsASAP(NULL, pos=5) ...
[11:01:29.086] - nx: 6
[11:01:29.086] - relay: TRUE
[11:01:29.086] - stdout: TRUE
[11:01:29.086] - signal: TRUE
[11:01:29.086] - resignal: FALSE
[11:01:29.086] - force: TRUE
[11:01:29.087] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.087] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.087]  - until=6
[11:01:29.087]  - relaying element #6
[11:01:29.087] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.087] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.087] signalConditionsASAP(NULL, pos=5) ... done
[11:01:29.087]  length: 1 (resolved future 5)
[11:01:29.087] signalConditionsASAP(numeric, pos=6) ...
[11:01:29.087] - nx: 6
[11:01:29.087] - relay: TRUE
[11:01:29.087] - stdout: TRUE
[11:01:29.087] - signal: TRUE
[11:01:29.088] - resignal: FALSE
[11:01:29.088] - force: TRUE
[11:01:29.088] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.088] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.088]  - until=6
[11:01:29.088] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.088] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.088] signalConditionsASAP(numeric, pos=6) ... done
[11:01:29.088]  length: 0 (resolved future 6)
[11:01:29.088] Relaying remaining futures
[11:01:29.088] signalConditionsASAP(NULL, pos=0) ...
[11:01:29.088] - nx: 6
[11:01:29.088] - relay: TRUE
[11:01:29.089] - stdout: TRUE
[11:01:29.089] - signal: TRUE
[11:01:29.089] - resignal: FALSE
[11:01:29.089] - force: TRUE
[11:01:29.089] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.089] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:29.089] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.089] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.089] signalConditionsASAP(NULL, pos=0) ... done
[11:01:29.089] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a9c4ddd328> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[11:01:29.091] getGlobalsAndPackages() ...
[11:01:29.091] Searching for globals...
[11:01:29.092] 
[11:01:29.092] Searching for globals ... DONE
[11:01:29.092] - globals: [0] <none>
[11:01:29.092] getGlobalsAndPackages() ... DONE
[11:01:29.092] run() for ‘Future’ ...
[11:01:29.092] - state: ‘created’
[11:01:29.092] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:29.092] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:29.093] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:29.093]   - Field: ‘label’
[11:01:29.093]   - Field: ‘local’
[11:01:29.093]   - Field: ‘owner’
[11:01:29.093]   - Field: ‘envir’
[11:01:29.093]   - Field: ‘packages’
[11:01:29.093]   - Field: ‘gc’
[11:01:29.093]   - Field: ‘conditions’
[11:01:29.093]   - Field: ‘expr’
[11:01:29.093]   - Field: ‘uuid’
[11:01:29.093]   - Field: ‘seed’
[11:01:29.094]   - Field: ‘version’
[11:01:29.094]   - Field: ‘result’
[11:01:29.094]   - Field: ‘asynchronous’
[11:01:29.094]   - Field: ‘calls’
[11:01:29.094]   - Field: ‘globals’
[11:01:29.094]   - Field: ‘stdout’
[11:01:29.094]   - Field: ‘earlySignal’
[11:01:29.094]   - Field: ‘lazy’
[11:01:29.094]   - Field: ‘state’
[11:01:29.094] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:29.094] - Launch lazy future ...
[11:01:29.094] Packages needed by the future expression (n = 0): <none>
[11:01:29.095] Packages needed by future strategies (n = 0): <none>
[11:01:29.095] {
[11:01:29.095]     {
[11:01:29.095]         {
[11:01:29.095]             ...future.startTime <- base::Sys.time()
[11:01:29.095]             {
[11:01:29.095]                 {
[11:01:29.095]                   {
[11:01:29.095]                     base::local({
[11:01:29.095]                       has_future <- base::requireNamespace("future", 
[11:01:29.095]                         quietly = TRUE)
[11:01:29.095]                       if (has_future) {
[11:01:29.095]                         ns <- base::getNamespace("future")
[11:01:29.095]                         version <- ns[[".package"]][["version"]]
[11:01:29.095]                         if (is.null(version)) 
[11:01:29.095]                           version <- utils::packageVersion("future")
[11:01:29.095]                       }
[11:01:29.095]                       else {
[11:01:29.095]                         version <- NULL
[11:01:29.095]                       }
[11:01:29.095]                       if (!has_future || version < "1.8.0") {
[11:01:29.095]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.095]                           "", base::R.version$version.string), 
[11:01:29.095]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:29.095]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.095]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.095]                             "release", "version")], collapse = " "), 
[11:01:29.095]                           hostname = base::Sys.info()[["nodename"]])
[11:01:29.095]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.095]                           info)
[11:01:29.095]                         info <- base::paste(info, collapse = "; ")
[11:01:29.095]                         if (!has_future) {
[11:01:29.095]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.095]                             info)
[11:01:29.095]                         }
[11:01:29.095]                         else {
[11:01:29.095]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.095]                             info, version)
[11:01:29.095]                         }
[11:01:29.095]                         base::stop(msg)
[11:01:29.095]                       }
[11:01:29.095]                     })
[11:01:29.095]                   }
[11:01:29.095]                   ...future.strategy.old <- future::plan("list")
[11:01:29.095]                   options(future.plan = NULL)
[11:01:29.095]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.095]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.095]                 }
[11:01:29.095]                 ...future.workdir <- getwd()
[11:01:29.095]             }
[11:01:29.095]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.095]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.095]         }
[11:01:29.095]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.095]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.095]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.095]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.095]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.095]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.095]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.095]             base::names(...future.oldOptions))
[11:01:29.095]     }
[11:01:29.095]     if (FALSE) {
[11:01:29.095]     }
[11:01:29.095]     else {
[11:01:29.095]         if (TRUE) {
[11:01:29.095]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.095]                 open = "w")
[11:01:29.095]         }
[11:01:29.095]         else {
[11:01:29.095]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.095]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.095]         }
[11:01:29.095]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.095]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.095]             base::sink(type = "output", split = FALSE)
[11:01:29.095]             base::close(...future.stdout)
[11:01:29.095]         }, add = TRUE)
[11:01:29.095]     }
[11:01:29.095]     ...future.frame <- base::sys.nframe()
[11:01:29.095]     ...future.conditions <- base::list()
[11:01:29.095]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.095]     if (FALSE) {
[11:01:29.095]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.095]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.095]     }
[11:01:29.095]     ...future.result <- base::tryCatch({
[11:01:29.095]         base::withCallingHandlers({
[11:01:29.095]             ...future.value <- base::withVisible(base::local(2))
[11:01:29.095]             future::FutureResult(value = ...future.value$value, 
[11:01:29.095]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.095]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.095]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.095]                     ...future.globalenv.names))
[11:01:29.095]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.095]         }, condition = base::local({
[11:01:29.095]             c <- base::c
[11:01:29.095]             inherits <- base::inherits
[11:01:29.095]             invokeRestart <- base::invokeRestart
[11:01:29.095]             length <- base::length
[11:01:29.095]             list <- base::list
[11:01:29.095]             seq.int <- base::seq.int
[11:01:29.095]             signalCondition <- base::signalCondition
[11:01:29.095]             sys.calls <- base::sys.calls
[11:01:29.095]             `[[` <- base::`[[`
[11:01:29.095]             `+` <- base::`+`
[11:01:29.095]             `<<-` <- base::`<<-`
[11:01:29.095]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.095]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.095]                   3L)]
[11:01:29.095]             }
[11:01:29.095]             function(cond) {
[11:01:29.095]                 is_error <- inherits(cond, "error")
[11:01:29.095]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.095]                   NULL)
[11:01:29.095]                 if (is_error) {
[11:01:29.095]                   sessionInformation <- function() {
[11:01:29.095]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.095]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.095]                       search = base::search(), system = base::Sys.info())
[11:01:29.095]                   }
[11:01:29.095]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.095]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.095]                     cond$call), session = sessionInformation(), 
[11:01:29.095]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.095]                   signalCondition(cond)
[11:01:29.095]                 }
[11:01:29.095]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.095]                 "immediateCondition"))) {
[11:01:29.095]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.095]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.095]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.095]                   if (TRUE && !signal) {
[11:01:29.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.095]                     {
[11:01:29.095]                       inherits <- base::inherits
[11:01:29.095]                       invokeRestart <- base::invokeRestart
[11:01:29.095]                       is.null <- base::is.null
[11:01:29.095]                       muffled <- FALSE
[11:01:29.095]                       if (inherits(cond, "message")) {
[11:01:29.095]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.095]                         if (muffled) 
[11:01:29.095]                           invokeRestart("muffleMessage")
[11:01:29.095]                       }
[11:01:29.095]                       else if (inherits(cond, "warning")) {
[11:01:29.095]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.095]                         if (muffled) 
[11:01:29.095]                           invokeRestart("muffleWarning")
[11:01:29.095]                       }
[11:01:29.095]                       else if (inherits(cond, "condition")) {
[11:01:29.095]                         if (!is.null(pattern)) {
[11:01:29.095]                           computeRestarts <- base::computeRestarts
[11:01:29.095]                           grepl <- base::grepl
[11:01:29.095]                           restarts <- computeRestarts(cond)
[11:01:29.095]                           for (restart in restarts) {
[11:01:29.095]                             name <- restart$name
[11:01:29.095]                             if (is.null(name)) 
[11:01:29.095]                               next
[11:01:29.095]                             if (!grepl(pattern, name)) 
[11:01:29.095]                               next
[11:01:29.095]                             invokeRestart(restart)
[11:01:29.095]                             muffled <- TRUE
[11:01:29.095]                             break
[11:01:29.095]                           }
[11:01:29.095]                         }
[11:01:29.095]                       }
[11:01:29.095]                       invisible(muffled)
[11:01:29.095]                     }
[11:01:29.095]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.095]                   }
[11:01:29.095]                 }
[11:01:29.095]                 else {
[11:01:29.095]                   if (TRUE) {
[11:01:29.095]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.095]                     {
[11:01:29.095]                       inherits <- base::inherits
[11:01:29.095]                       invokeRestart <- base::invokeRestart
[11:01:29.095]                       is.null <- base::is.null
[11:01:29.095]                       muffled <- FALSE
[11:01:29.095]                       if (inherits(cond, "message")) {
[11:01:29.095]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.095]                         if (muffled) 
[11:01:29.095]                           invokeRestart("muffleMessage")
[11:01:29.095]                       }
[11:01:29.095]                       else if (inherits(cond, "warning")) {
[11:01:29.095]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.095]                         if (muffled) 
[11:01:29.095]                           invokeRestart("muffleWarning")
[11:01:29.095]                       }
[11:01:29.095]                       else if (inherits(cond, "condition")) {
[11:01:29.095]                         if (!is.null(pattern)) {
[11:01:29.095]                           computeRestarts <- base::computeRestarts
[11:01:29.095]                           grepl <- base::grepl
[11:01:29.095]                           restarts <- computeRestarts(cond)
[11:01:29.095]                           for (restart in restarts) {
[11:01:29.095]                             name <- restart$name
[11:01:29.095]                             if (is.null(name)) 
[11:01:29.095]                               next
[11:01:29.095]                             if (!grepl(pattern, name)) 
[11:01:29.095]                               next
[11:01:29.095]                             invokeRestart(restart)
[11:01:29.095]                             muffled <- TRUE
[11:01:29.095]                             break
[11:01:29.095]                           }
[11:01:29.095]                         }
[11:01:29.095]                       }
[11:01:29.095]                       invisible(muffled)
[11:01:29.095]                     }
[11:01:29.095]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.095]                   }
[11:01:29.095]                 }
[11:01:29.095]             }
[11:01:29.095]         }))
[11:01:29.095]     }, error = function(ex) {
[11:01:29.095]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.095]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.095]                 ...future.rng), started = ...future.startTime, 
[11:01:29.095]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.095]             version = "1.8"), class = "FutureResult")
[11:01:29.095]     }, finally = {
[11:01:29.095]         if (!identical(...future.workdir, getwd())) 
[11:01:29.095]             setwd(...future.workdir)
[11:01:29.095]         {
[11:01:29.095]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.095]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.095]             }
[11:01:29.095]             base::options(...future.oldOptions)
[11:01:29.095]             if (.Platform$OS.type == "windows") {
[11:01:29.095]                 old_names <- names(...future.oldEnvVars)
[11:01:29.095]                 envs <- base::Sys.getenv()
[11:01:29.095]                 names <- names(envs)
[11:01:29.095]                 common <- intersect(names, old_names)
[11:01:29.095]                 added <- setdiff(names, old_names)
[11:01:29.095]                 removed <- setdiff(old_names, names)
[11:01:29.095]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.095]                   envs[common]]
[11:01:29.095]                 NAMES <- toupper(changed)
[11:01:29.095]                 args <- list()
[11:01:29.095]                 for (kk in seq_along(NAMES)) {
[11:01:29.095]                   name <- changed[[kk]]
[11:01:29.095]                   NAME <- NAMES[[kk]]
[11:01:29.095]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.095]                     next
[11:01:29.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.095]                 }
[11:01:29.095]                 NAMES <- toupper(added)
[11:01:29.095]                 for (kk in seq_along(NAMES)) {
[11:01:29.095]                   name <- added[[kk]]
[11:01:29.095]                   NAME <- NAMES[[kk]]
[11:01:29.095]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.095]                     next
[11:01:29.095]                   args[[name]] <- ""
[11:01:29.095]                 }
[11:01:29.095]                 NAMES <- toupper(removed)
[11:01:29.095]                 for (kk in seq_along(NAMES)) {
[11:01:29.095]                   name <- removed[[kk]]
[11:01:29.095]                   NAME <- NAMES[[kk]]
[11:01:29.095]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.095]                     next
[11:01:29.095]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.095]                 }
[11:01:29.095]                 if (length(args) > 0) 
[11:01:29.095]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.095]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.095]             }
[11:01:29.095]             else {
[11:01:29.095]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.095]             }
[11:01:29.095]             {
[11:01:29.095]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.095]                   0L) {
[11:01:29.095]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.095]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.095]                   base::options(opts)
[11:01:29.095]                 }
[11:01:29.095]                 {
[11:01:29.095]                   {
[11:01:29.095]                     NULL
[11:01:29.095]                     RNGkind("Mersenne-Twister")
[11:01:29.095]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:29.095]                       inherits = FALSE)
[11:01:29.095]                   }
[11:01:29.095]                   options(future.plan = NULL)
[11:01:29.095]                   if (is.na(NA_character_)) 
[11:01:29.095]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.095]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.095]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.095]                     .init = FALSE)
[11:01:29.095]                 }
[11:01:29.095]             }
[11:01:29.095]         }
[11:01:29.095]     })
[11:01:29.095]     if (TRUE) {
[11:01:29.095]         base::sink(type = "output", split = FALSE)
[11:01:29.095]         if (TRUE) {
[11:01:29.095]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.095]         }
[11:01:29.095]         else {
[11:01:29.095]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.095]         }
[11:01:29.095]         base::close(...future.stdout)
[11:01:29.095]         ...future.stdout <- NULL
[11:01:29.095]     }
[11:01:29.095]     ...future.result$conditions <- ...future.conditions
[11:01:29.095]     ...future.result$finished <- base::Sys.time()
[11:01:29.095]     ...future.result
[11:01:29.095] }
[11:01:29.097] plan(): Setting new future strategy stack:
[11:01:29.097] List of future strategies:
[11:01:29.097] 1. sequential:
[11:01:29.097]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.097]    - tweaked: FALSE
[11:01:29.097]    - call: NULL
[11:01:29.097] plan(): nbrOfWorkers() = 1
[11:01:29.098] plan(): Setting new future strategy stack:
[11:01:29.098] List of future strategies:
[11:01:29.098] 1. sequential:
[11:01:29.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.098]    - tweaked: FALSE
[11:01:29.098]    - call: plan(strategy)
[11:01:29.098] plan(): nbrOfWorkers() = 1
[11:01:29.098] SequentialFuture started (and completed)
[11:01:29.099] - Launch lazy future ... done
[11:01:29.099] run() for ‘SequentialFuture’ ... done
[11:01:29.099] getGlobalsAndPackages() ...
[11:01:29.099] Searching for globals...
[11:01:29.099] 
[11:01:29.099] Searching for globals ... DONE
[11:01:29.099] - globals: [0] <none>
[11:01:29.099] getGlobalsAndPackages() ... DONE
[11:01:29.100] run() for ‘Future’ ...
[11:01:29.100] - state: ‘created’
[11:01:29.101] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:29.101] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:29.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:29.101]   - Field: ‘label’
[11:01:29.101]   - Field: ‘local’
[11:01:29.101]   - Field: ‘owner’
[11:01:29.101]   - Field: ‘envir’
[11:01:29.101]   - Field: ‘packages’
[11:01:29.101]   - Field: ‘gc’
[11:01:29.101]   - Field: ‘conditions’
[11:01:29.102]   - Field: ‘expr’
[11:01:29.102]   - Field: ‘uuid’
[11:01:29.102]   - Field: ‘seed’
[11:01:29.102]   - Field: ‘version’
[11:01:29.102]   - Field: ‘result’
[11:01:29.102]   - Field: ‘asynchronous’
[11:01:29.102]   - Field: ‘calls’
[11:01:29.102]   - Field: ‘globals’
[11:01:29.102]   - Field: ‘stdout’
[11:01:29.102]   - Field: ‘earlySignal’
[11:01:29.102]   - Field: ‘lazy’
[11:01:29.102]   - Field: ‘state’
[11:01:29.103] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:29.103] - Launch lazy future ...
[11:01:29.103] Packages needed by the future expression (n = 0): <none>
[11:01:29.103] Packages needed by future strategies (n = 0): <none>
[11:01:29.103] {
[11:01:29.103]     {
[11:01:29.103]         {
[11:01:29.103]             ...future.startTime <- base::Sys.time()
[11:01:29.103]             {
[11:01:29.103]                 {
[11:01:29.103]                   {
[11:01:29.103]                     base::local({
[11:01:29.103]                       has_future <- base::requireNamespace("future", 
[11:01:29.103]                         quietly = TRUE)
[11:01:29.103]                       if (has_future) {
[11:01:29.103]                         ns <- base::getNamespace("future")
[11:01:29.103]                         version <- ns[[".package"]][["version"]]
[11:01:29.103]                         if (is.null(version)) 
[11:01:29.103]                           version <- utils::packageVersion("future")
[11:01:29.103]                       }
[11:01:29.103]                       else {
[11:01:29.103]                         version <- NULL
[11:01:29.103]                       }
[11:01:29.103]                       if (!has_future || version < "1.8.0") {
[11:01:29.103]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.103]                           "", base::R.version$version.string), 
[11:01:29.103]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:29.103]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.103]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.103]                             "release", "version")], collapse = " "), 
[11:01:29.103]                           hostname = base::Sys.info()[["nodename"]])
[11:01:29.103]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.103]                           info)
[11:01:29.103]                         info <- base::paste(info, collapse = "; ")
[11:01:29.103]                         if (!has_future) {
[11:01:29.103]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.103]                             info)
[11:01:29.103]                         }
[11:01:29.103]                         else {
[11:01:29.103]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.103]                             info, version)
[11:01:29.103]                         }
[11:01:29.103]                         base::stop(msg)
[11:01:29.103]                       }
[11:01:29.103]                     })
[11:01:29.103]                   }
[11:01:29.103]                   ...future.strategy.old <- future::plan("list")
[11:01:29.103]                   options(future.plan = NULL)
[11:01:29.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.103]                 }
[11:01:29.103]                 ...future.workdir <- getwd()
[11:01:29.103]             }
[11:01:29.103]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.103]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.103]         }
[11:01:29.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.103]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.103]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.103]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.103]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.103]             base::names(...future.oldOptions))
[11:01:29.103]     }
[11:01:29.103]     if (FALSE) {
[11:01:29.103]     }
[11:01:29.103]     else {
[11:01:29.103]         if (TRUE) {
[11:01:29.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.103]                 open = "w")
[11:01:29.103]         }
[11:01:29.103]         else {
[11:01:29.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.103]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.103]         }
[11:01:29.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.103]             base::sink(type = "output", split = FALSE)
[11:01:29.103]             base::close(...future.stdout)
[11:01:29.103]         }, add = TRUE)
[11:01:29.103]     }
[11:01:29.103]     ...future.frame <- base::sys.nframe()
[11:01:29.103]     ...future.conditions <- base::list()
[11:01:29.103]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.103]     if (FALSE) {
[11:01:29.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.103]     }
[11:01:29.103]     ...future.result <- base::tryCatch({
[11:01:29.103]         base::withCallingHandlers({
[11:01:29.103]             ...future.value <- base::withVisible(base::local(NULL))
[11:01:29.103]             future::FutureResult(value = ...future.value$value, 
[11:01:29.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.103]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.103]                     ...future.globalenv.names))
[11:01:29.103]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.103]         }, condition = base::local({
[11:01:29.103]             c <- base::c
[11:01:29.103]             inherits <- base::inherits
[11:01:29.103]             invokeRestart <- base::invokeRestart
[11:01:29.103]             length <- base::length
[11:01:29.103]             list <- base::list
[11:01:29.103]             seq.int <- base::seq.int
[11:01:29.103]             signalCondition <- base::signalCondition
[11:01:29.103]             sys.calls <- base::sys.calls
[11:01:29.103]             `[[` <- base::`[[`
[11:01:29.103]             `+` <- base::`+`
[11:01:29.103]             `<<-` <- base::`<<-`
[11:01:29.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.103]                   3L)]
[11:01:29.103]             }
[11:01:29.103]             function(cond) {
[11:01:29.103]                 is_error <- inherits(cond, "error")
[11:01:29.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.103]                   NULL)
[11:01:29.103]                 if (is_error) {
[11:01:29.103]                   sessionInformation <- function() {
[11:01:29.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.103]                       search = base::search(), system = base::Sys.info())
[11:01:29.103]                   }
[11:01:29.103]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.103]                     cond$call), session = sessionInformation(), 
[11:01:29.103]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.103]                   signalCondition(cond)
[11:01:29.103]                 }
[11:01:29.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.103]                 "immediateCondition"))) {
[11:01:29.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.103]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.103]                   if (TRUE && !signal) {
[11:01:29.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.103]                     {
[11:01:29.103]                       inherits <- base::inherits
[11:01:29.103]                       invokeRestart <- base::invokeRestart
[11:01:29.103]                       is.null <- base::is.null
[11:01:29.103]                       muffled <- FALSE
[11:01:29.103]                       if (inherits(cond, "message")) {
[11:01:29.103]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.103]                         if (muffled) 
[11:01:29.103]                           invokeRestart("muffleMessage")
[11:01:29.103]                       }
[11:01:29.103]                       else if (inherits(cond, "warning")) {
[11:01:29.103]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.103]                         if (muffled) 
[11:01:29.103]                           invokeRestart("muffleWarning")
[11:01:29.103]                       }
[11:01:29.103]                       else if (inherits(cond, "condition")) {
[11:01:29.103]                         if (!is.null(pattern)) {
[11:01:29.103]                           computeRestarts <- base::computeRestarts
[11:01:29.103]                           grepl <- base::grepl
[11:01:29.103]                           restarts <- computeRestarts(cond)
[11:01:29.103]                           for (restart in restarts) {
[11:01:29.103]                             name <- restart$name
[11:01:29.103]                             if (is.null(name)) 
[11:01:29.103]                               next
[11:01:29.103]                             if (!grepl(pattern, name)) 
[11:01:29.103]                               next
[11:01:29.103]                             invokeRestart(restart)
[11:01:29.103]                             muffled <- TRUE
[11:01:29.103]                             break
[11:01:29.103]                           }
[11:01:29.103]                         }
[11:01:29.103]                       }
[11:01:29.103]                       invisible(muffled)
[11:01:29.103]                     }
[11:01:29.103]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.103]                   }
[11:01:29.103]                 }
[11:01:29.103]                 else {
[11:01:29.103]                   if (TRUE) {
[11:01:29.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.103]                     {
[11:01:29.103]                       inherits <- base::inherits
[11:01:29.103]                       invokeRestart <- base::invokeRestart
[11:01:29.103]                       is.null <- base::is.null
[11:01:29.103]                       muffled <- FALSE
[11:01:29.103]                       if (inherits(cond, "message")) {
[11:01:29.103]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.103]                         if (muffled) 
[11:01:29.103]                           invokeRestart("muffleMessage")
[11:01:29.103]                       }
[11:01:29.103]                       else if (inherits(cond, "warning")) {
[11:01:29.103]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.103]                         if (muffled) 
[11:01:29.103]                           invokeRestart("muffleWarning")
[11:01:29.103]                       }
[11:01:29.103]                       else if (inherits(cond, "condition")) {
[11:01:29.103]                         if (!is.null(pattern)) {
[11:01:29.103]                           computeRestarts <- base::computeRestarts
[11:01:29.103]                           grepl <- base::grepl
[11:01:29.103]                           restarts <- computeRestarts(cond)
[11:01:29.103]                           for (restart in restarts) {
[11:01:29.103]                             name <- restart$name
[11:01:29.103]                             if (is.null(name)) 
[11:01:29.103]                               next
[11:01:29.103]                             if (!grepl(pattern, name)) 
[11:01:29.103]                               next
[11:01:29.103]                             invokeRestart(restart)
[11:01:29.103]                             muffled <- TRUE
[11:01:29.103]                             break
[11:01:29.103]                           }
[11:01:29.103]                         }
[11:01:29.103]                       }
[11:01:29.103]                       invisible(muffled)
[11:01:29.103]                     }
[11:01:29.103]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.103]                   }
[11:01:29.103]                 }
[11:01:29.103]             }
[11:01:29.103]         }))
[11:01:29.103]     }, error = function(ex) {
[11:01:29.103]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.103]                 ...future.rng), started = ...future.startTime, 
[11:01:29.103]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.103]             version = "1.8"), class = "FutureResult")
[11:01:29.103]     }, finally = {
[11:01:29.103]         if (!identical(...future.workdir, getwd())) 
[11:01:29.103]             setwd(...future.workdir)
[11:01:29.103]         {
[11:01:29.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.103]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.103]             }
[11:01:29.103]             base::options(...future.oldOptions)
[11:01:29.103]             if (.Platform$OS.type == "windows") {
[11:01:29.103]                 old_names <- names(...future.oldEnvVars)
[11:01:29.103]                 envs <- base::Sys.getenv()
[11:01:29.103]                 names <- names(envs)
[11:01:29.103]                 common <- intersect(names, old_names)
[11:01:29.103]                 added <- setdiff(names, old_names)
[11:01:29.103]                 removed <- setdiff(old_names, names)
[11:01:29.103]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.103]                   envs[common]]
[11:01:29.103]                 NAMES <- toupper(changed)
[11:01:29.103]                 args <- list()
[11:01:29.103]                 for (kk in seq_along(NAMES)) {
[11:01:29.103]                   name <- changed[[kk]]
[11:01:29.103]                   NAME <- NAMES[[kk]]
[11:01:29.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.103]                     next
[11:01:29.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.103]                 }
[11:01:29.103]                 NAMES <- toupper(added)
[11:01:29.103]                 for (kk in seq_along(NAMES)) {
[11:01:29.103]                   name <- added[[kk]]
[11:01:29.103]                   NAME <- NAMES[[kk]]
[11:01:29.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.103]                     next
[11:01:29.103]                   args[[name]] <- ""
[11:01:29.103]                 }
[11:01:29.103]                 NAMES <- toupper(removed)
[11:01:29.103]                 for (kk in seq_along(NAMES)) {
[11:01:29.103]                   name <- removed[[kk]]
[11:01:29.103]                   NAME <- NAMES[[kk]]
[11:01:29.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.103]                     next
[11:01:29.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.103]                 }
[11:01:29.103]                 if (length(args) > 0) 
[11:01:29.103]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.103]             }
[11:01:29.103]             else {
[11:01:29.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.103]             }
[11:01:29.103]             {
[11:01:29.103]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.103]                   0L) {
[11:01:29.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.103]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.103]                   base::options(opts)
[11:01:29.103]                 }
[11:01:29.103]                 {
[11:01:29.103]                   {
[11:01:29.103]                     NULL
[11:01:29.103]                     RNGkind("Mersenne-Twister")
[11:01:29.103]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:29.103]                       inherits = FALSE)
[11:01:29.103]                   }
[11:01:29.103]                   options(future.plan = NULL)
[11:01:29.103]                   if (is.na(NA_character_)) 
[11:01:29.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.103]                     .init = FALSE)
[11:01:29.103]                 }
[11:01:29.103]             }
[11:01:29.103]         }
[11:01:29.103]     })
[11:01:29.103]     if (TRUE) {
[11:01:29.103]         base::sink(type = "output", split = FALSE)
[11:01:29.103]         if (TRUE) {
[11:01:29.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.103]         }
[11:01:29.103]         else {
[11:01:29.103]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.103]         }
[11:01:29.103]         base::close(...future.stdout)
[11:01:29.103]         ...future.stdout <- NULL
[11:01:29.103]     }
[11:01:29.103]     ...future.result$conditions <- ...future.conditions
[11:01:29.103]     ...future.result$finished <- base::Sys.time()
[11:01:29.103]     ...future.result
[11:01:29.103] }
[11:01:29.105] plan(): Setting new future strategy stack:
[11:01:29.105] List of future strategies:
[11:01:29.105] 1. sequential:
[11:01:29.105]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.105]    - tweaked: FALSE
[11:01:29.105]    - call: NULL
[11:01:29.105] plan(): nbrOfWorkers() = 1
[11:01:29.106] plan(): Setting new future strategy stack:
[11:01:29.106] List of future strategies:
[11:01:29.106] 1. sequential:
[11:01:29.106]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.106]    - tweaked: FALSE
[11:01:29.106]    - call: plan(strategy)
[11:01:29.107] plan(): nbrOfWorkers() = 1
[11:01:29.107] SequentialFuture started (and completed)
[11:01:29.107] - Launch lazy future ... done
[11:01:29.107] run() for ‘SequentialFuture’ ... done
[11:01:29.107] getGlobalsAndPackages() ...
[11:01:29.107] Searching for globals...
[11:01:29.108] - globals found: [1] ‘{’
[11:01:29.108] Searching for globals ... DONE
[11:01:29.108] Resolving globals: FALSE
[11:01:29.108] 
[11:01:29.108] 
[11:01:29.109] getGlobalsAndPackages() ... DONE
[11:01:29.109] run() for ‘Future’ ...
[11:01:29.109] - state: ‘created’
[11:01:29.109] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:29.109] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:29.109] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:29.109]   - Field: ‘label’
[11:01:29.109]   - Field: ‘local’
[11:01:29.110]   - Field: ‘owner’
[11:01:29.110]   - Field: ‘envir’
[11:01:29.110]   - Field: ‘packages’
[11:01:29.110]   - Field: ‘gc’
[11:01:29.110]   - Field: ‘conditions’
[11:01:29.110]   - Field: ‘expr’
[11:01:29.110]   - Field: ‘uuid’
[11:01:29.110]   - Field: ‘seed’
[11:01:29.110]   - Field: ‘version’
[11:01:29.110]   - Field: ‘result’
[11:01:29.110]   - Field: ‘asynchronous’
[11:01:29.110]   - Field: ‘calls’
[11:01:29.110]   - Field: ‘globals’
[11:01:29.111]   - Field: ‘stdout’
[11:01:29.111]   - Field: ‘earlySignal’
[11:01:29.111]   - Field: ‘lazy’
[11:01:29.111]   - Field: ‘state’
[11:01:29.111] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:29.111] - Launch lazy future ...
[11:01:29.111] Packages needed by the future expression (n = 0): <none>
[11:01:29.111] Packages needed by future strategies (n = 0): <none>
[11:01:29.112] {
[11:01:29.112]     {
[11:01:29.112]         {
[11:01:29.112]             ...future.startTime <- base::Sys.time()
[11:01:29.112]             {
[11:01:29.112]                 {
[11:01:29.112]                   {
[11:01:29.112]                     base::local({
[11:01:29.112]                       has_future <- base::requireNamespace("future", 
[11:01:29.112]                         quietly = TRUE)
[11:01:29.112]                       if (has_future) {
[11:01:29.112]                         ns <- base::getNamespace("future")
[11:01:29.112]                         version <- ns[[".package"]][["version"]]
[11:01:29.112]                         if (is.null(version)) 
[11:01:29.112]                           version <- utils::packageVersion("future")
[11:01:29.112]                       }
[11:01:29.112]                       else {
[11:01:29.112]                         version <- NULL
[11:01:29.112]                       }
[11:01:29.112]                       if (!has_future || version < "1.8.0") {
[11:01:29.112]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.112]                           "", base::R.version$version.string), 
[11:01:29.112]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:29.112]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.112]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.112]                             "release", "version")], collapse = " "), 
[11:01:29.112]                           hostname = base::Sys.info()[["nodename"]])
[11:01:29.112]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.112]                           info)
[11:01:29.112]                         info <- base::paste(info, collapse = "; ")
[11:01:29.112]                         if (!has_future) {
[11:01:29.112]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.112]                             info)
[11:01:29.112]                         }
[11:01:29.112]                         else {
[11:01:29.112]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.112]                             info, version)
[11:01:29.112]                         }
[11:01:29.112]                         base::stop(msg)
[11:01:29.112]                       }
[11:01:29.112]                     })
[11:01:29.112]                   }
[11:01:29.112]                   ...future.strategy.old <- future::plan("list")
[11:01:29.112]                   options(future.plan = NULL)
[11:01:29.112]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.112]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.112]                 }
[11:01:29.112]                 ...future.workdir <- getwd()
[11:01:29.112]             }
[11:01:29.112]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.112]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.112]         }
[11:01:29.112]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.112]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.112]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.112]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.112]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.112]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.112]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.112]             base::names(...future.oldOptions))
[11:01:29.112]     }
[11:01:29.112]     if (FALSE) {
[11:01:29.112]     }
[11:01:29.112]     else {
[11:01:29.112]         if (TRUE) {
[11:01:29.112]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.112]                 open = "w")
[11:01:29.112]         }
[11:01:29.112]         else {
[11:01:29.112]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.112]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.112]         }
[11:01:29.112]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.112]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.112]             base::sink(type = "output", split = FALSE)
[11:01:29.112]             base::close(...future.stdout)
[11:01:29.112]         }, add = TRUE)
[11:01:29.112]     }
[11:01:29.112]     ...future.frame <- base::sys.nframe()
[11:01:29.112]     ...future.conditions <- base::list()
[11:01:29.112]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.112]     if (FALSE) {
[11:01:29.112]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.112]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.112]     }
[11:01:29.112]     ...future.result <- base::tryCatch({
[11:01:29.112]         base::withCallingHandlers({
[11:01:29.112]             ...future.value <- base::withVisible(base::local({
[11:01:29.112]                 4
[11:01:29.112]             }))
[11:01:29.112]             future::FutureResult(value = ...future.value$value, 
[11:01:29.112]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.112]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.112]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.112]                     ...future.globalenv.names))
[11:01:29.112]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.112]         }, condition = base::local({
[11:01:29.112]             c <- base::c
[11:01:29.112]             inherits <- base::inherits
[11:01:29.112]             invokeRestart <- base::invokeRestart
[11:01:29.112]             length <- base::length
[11:01:29.112]             list <- base::list
[11:01:29.112]             seq.int <- base::seq.int
[11:01:29.112]             signalCondition <- base::signalCondition
[11:01:29.112]             sys.calls <- base::sys.calls
[11:01:29.112]             `[[` <- base::`[[`
[11:01:29.112]             `+` <- base::`+`
[11:01:29.112]             `<<-` <- base::`<<-`
[11:01:29.112]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.112]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.112]                   3L)]
[11:01:29.112]             }
[11:01:29.112]             function(cond) {
[11:01:29.112]                 is_error <- inherits(cond, "error")
[11:01:29.112]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.112]                   NULL)
[11:01:29.112]                 if (is_error) {
[11:01:29.112]                   sessionInformation <- function() {
[11:01:29.112]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.112]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.112]                       search = base::search(), system = base::Sys.info())
[11:01:29.112]                   }
[11:01:29.112]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.112]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.112]                     cond$call), session = sessionInformation(), 
[11:01:29.112]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.112]                   signalCondition(cond)
[11:01:29.112]                 }
[11:01:29.112]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.112]                 "immediateCondition"))) {
[11:01:29.112]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.112]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.112]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.112]                   if (TRUE && !signal) {
[11:01:29.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.112]                     {
[11:01:29.112]                       inherits <- base::inherits
[11:01:29.112]                       invokeRestart <- base::invokeRestart
[11:01:29.112]                       is.null <- base::is.null
[11:01:29.112]                       muffled <- FALSE
[11:01:29.112]                       if (inherits(cond, "message")) {
[11:01:29.112]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.112]                         if (muffled) 
[11:01:29.112]                           invokeRestart("muffleMessage")
[11:01:29.112]                       }
[11:01:29.112]                       else if (inherits(cond, "warning")) {
[11:01:29.112]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.112]                         if (muffled) 
[11:01:29.112]                           invokeRestart("muffleWarning")
[11:01:29.112]                       }
[11:01:29.112]                       else if (inherits(cond, "condition")) {
[11:01:29.112]                         if (!is.null(pattern)) {
[11:01:29.112]                           computeRestarts <- base::computeRestarts
[11:01:29.112]                           grepl <- base::grepl
[11:01:29.112]                           restarts <- computeRestarts(cond)
[11:01:29.112]                           for (restart in restarts) {
[11:01:29.112]                             name <- restart$name
[11:01:29.112]                             if (is.null(name)) 
[11:01:29.112]                               next
[11:01:29.112]                             if (!grepl(pattern, name)) 
[11:01:29.112]                               next
[11:01:29.112]                             invokeRestart(restart)
[11:01:29.112]                             muffled <- TRUE
[11:01:29.112]                             break
[11:01:29.112]                           }
[11:01:29.112]                         }
[11:01:29.112]                       }
[11:01:29.112]                       invisible(muffled)
[11:01:29.112]                     }
[11:01:29.112]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.112]                   }
[11:01:29.112]                 }
[11:01:29.112]                 else {
[11:01:29.112]                   if (TRUE) {
[11:01:29.112]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.112]                     {
[11:01:29.112]                       inherits <- base::inherits
[11:01:29.112]                       invokeRestart <- base::invokeRestart
[11:01:29.112]                       is.null <- base::is.null
[11:01:29.112]                       muffled <- FALSE
[11:01:29.112]                       if (inherits(cond, "message")) {
[11:01:29.112]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.112]                         if (muffled) 
[11:01:29.112]                           invokeRestart("muffleMessage")
[11:01:29.112]                       }
[11:01:29.112]                       else if (inherits(cond, "warning")) {
[11:01:29.112]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.112]                         if (muffled) 
[11:01:29.112]                           invokeRestart("muffleWarning")
[11:01:29.112]                       }
[11:01:29.112]                       else if (inherits(cond, "condition")) {
[11:01:29.112]                         if (!is.null(pattern)) {
[11:01:29.112]                           computeRestarts <- base::computeRestarts
[11:01:29.112]                           grepl <- base::grepl
[11:01:29.112]                           restarts <- computeRestarts(cond)
[11:01:29.112]                           for (restart in restarts) {
[11:01:29.112]                             name <- restart$name
[11:01:29.112]                             if (is.null(name)) 
[11:01:29.112]                               next
[11:01:29.112]                             if (!grepl(pattern, name)) 
[11:01:29.112]                               next
[11:01:29.112]                             invokeRestart(restart)
[11:01:29.112]                             muffled <- TRUE
[11:01:29.112]                             break
[11:01:29.112]                           }
[11:01:29.112]                         }
[11:01:29.112]                       }
[11:01:29.112]                       invisible(muffled)
[11:01:29.112]                     }
[11:01:29.112]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.112]                   }
[11:01:29.112]                 }
[11:01:29.112]             }
[11:01:29.112]         }))
[11:01:29.112]     }, error = function(ex) {
[11:01:29.112]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.112]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.112]                 ...future.rng), started = ...future.startTime, 
[11:01:29.112]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.112]             version = "1.8"), class = "FutureResult")
[11:01:29.112]     }, finally = {
[11:01:29.112]         if (!identical(...future.workdir, getwd())) 
[11:01:29.112]             setwd(...future.workdir)
[11:01:29.112]         {
[11:01:29.112]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.112]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.112]             }
[11:01:29.112]             base::options(...future.oldOptions)
[11:01:29.112]             if (.Platform$OS.type == "windows") {
[11:01:29.112]                 old_names <- names(...future.oldEnvVars)
[11:01:29.112]                 envs <- base::Sys.getenv()
[11:01:29.112]                 names <- names(envs)
[11:01:29.112]                 common <- intersect(names, old_names)
[11:01:29.112]                 added <- setdiff(names, old_names)
[11:01:29.112]                 removed <- setdiff(old_names, names)
[11:01:29.112]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.112]                   envs[common]]
[11:01:29.112]                 NAMES <- toupper(changed)
[11:01:29.112]                 args <- list()
[11:01:29.112]                 for (kk in seq_along(NAMES)) {
[11:01:29.112]                   name <- changed[[kk]]
[11:01:29.112]                   NAME <- NAMES[[kk]]
[11:01:29.112]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.112]                     next
[11:01:29.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.112]                 }
[11:01:29.112]                 NAMES <- toupper(added)
[11:01:29.112]                 for (kk in seq_along(NAMES)) {
[11:01:29.112]                   name <- added[[kk]]
[11:01:29.112]                   NAME <- NAMES[[kk]]
[11:01:29.112]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.112]                     next
[11:01:29.112]                   args[[name]] <- ""
[11:01:29.112]                 }
[11:01:29.112]                 NAMES <- toupper(removed)
[11:01:29.112]                 for (kk in seq_along(NAMES)) {
[11:01:29.112]                   name <- removed[[kk]]
[11:01:29.112]                   NAME <- NAMES[[kk]]
[11:01:29.112]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.112]                     next
[11:01:29.112]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.112]                 }
[11:01:29.112]                 if (length(args) > 0) 
[11:01:29.112]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.112]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.112]             }
[11:01:29.112]             else {
[11:01:29.112]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.112]             }
[11:01:29.112]             {
[11:01:29.112]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.112]                   0L) {
[11:01:29.112]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.112]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.112]                   base::options(opts)
[11:01:29.112]                 }
[11:01:29.112]                 {
[11:01:29.112]                   {
[11:01:29.112]                     NULL
[11:01:29.112]                     RNGkind("Mersenne-Twister")
[11:01:29.112]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:29.112]                       inherits = FALSE)
[11:01:29.112]                   }
[11:01:29.112]                   options(future.plan = NULL)
[11:01:29.112]                   if (is.na(NA_character_)) 
[11:01:29.112]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.112]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.112]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.112]                     .init = FALSE)
[11:01:29.112]                 }
[11:01:29.112]             }
[11:01:29.112]         }
[11:01:29.112]     })
[11:01:29.112]     if (TRUE) {
[11:01:29.112]         base::sink(type = "output", split = FALSE)
[11:01:29.112]         if (TRUE) {
[11:01:29.112]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.112]         }
[11:01:29.112]         else {
[11:01:29.112]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.112]         }
[11:01:29.112]         base::close(...future.stdout)
[11:01:29.112]         ...future.stdout <- NULL
[11:01:29.112]     }
[11:01:29.112]     ...future.result$conditions <- ...future.conditions
[11:01:29.112]     ...future.result$finished <- base::Sys.time()
[11:01:29.112]     ...future.result
[11:01:29.112] }
[11:01:29.113] plan(): Setting new future strategy stack:
[11:01:29.113] List of future strategies:
[11:01:29.113] 1. sequential:
[11:01:29.113]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.113]    - tweaked: FALSE
[11:01:29.113]    - call: NULL
[11:01:29.114] plan(): nbrOfWorkers() = 1
[11:01:29.114] plan(): Setting new future strategy stack:
[11:01:29.115] List of future strategies:
[11:01:29.115] 1. sequential:
[11:01:29.115]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.115]    - tweaked: FALSE
[11:01:29.115]    - call: plan(strategy)
[11:01:29.115] plan(): nbrOfWorkers() = 1
[11:01:29.115] SequentialFuture started (and completed)
[11:01:29.115] - Launch lazy future ... done
[11:01:29.115] run() for ‘SequentialFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c67b6580> 
Classes 'listenv', 'environment' <environment: 0x55a9c65a86c8> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[11:01:29.119] resolved() for ‘SequentialFuture’ ...
[11:01:29.119] - state: ‘finished’
[11:01:29.119] - run: TRUE
[11:01:29.119] - result: ‘FutureResult’
[11:01:29.119] resolved() for ‘SequentialFuture’ ... done
[11:01:29.119] resolved() for ‘SequentialFuture’ ...
[11:01:29.119] - state: ‘finished’
[11:01:29.120] - run: TRUE
[11:01:29.120] - result: ‘FutureResult’
[11:01:29.120] resolved() for ‘SequentialFuture’ ... done
[11:01:29.120] resolved() for ‘SequentialFuture’ ...
[11:01:29.120] - state: ‘finished’
[11:01:29.120] - run: TRUE
[11:01:29.120] - result: ‘FutureResult’
[11:01:29.120] resolved() for ‘SequentialFuture’ ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:29.123] resolve() on list environment ...
[11:01:29.123]  recursive: 0
[11:01:29.124]  length: 6
[11:01:29.124]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:29.124] signalConditionsASAP(numeric, pos=1) ...
[11:01:29.124] - nx: 6
[11:01:29.124] - relay: TRUE
[11:01:29.124] - stdout: TRUE
[11:01:29.124] - signal: TRUE
[11:01:29.124] - resignal: FALSE
[11:01:29.124] - force: TRUE
[11:01:29.124] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.124] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.124]  - until=2
[11:01:29.124]  - relaying element #2
[11:01:29.125] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.125] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.125] signalConditionsASAP(NULL, pos=1) ... done
[11:01:29.126]  length: 5 (resolved future 1)
[11:01:29.126] resolved() for ‘SequentialFuture’ ...
[11:01:29.126] - state: ‘finished’
[11:01:29.126] - run: TRUE
[11:01:29.126] - result: ‘FutureResult’
[11:01:29.126] resolved() for ‘SequentialFuture’ ... done
[11:01:29.126] Future #2
[11:01:29.126] signalConditionsASAP(SequentialFuture, pos=2) ...
[11:01:29.126] - nx: 6
[11:01:29.126] - relay: TRUE
[11:01:29.127] - stdout: TRUE
[11:01:29.127] - signal: TRUE
[11:01:29.127] - resignal: FALSE
[11:01:29.127] - force: TRUE
[11:01:29.127] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.127] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.127]  - until=2
[11:01:29.127]  - relaying element #2
[11:01:29.127] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.127] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.127] signalConditionsASAP(SequentialFuture, pos=2) ... done
[11:01:29.127]  length: 4 (resolved future 2)
[11:01:29.128] resolved() for ‘SequentialFuture’ ...
[11:01:29.128] - state: ‘finished’
[11:01:29.128] - run: TRUE
[11:01:29.128] - result: ‘FutureResult’
[11:01:29.128] resolved() for ‘SequentialFuture’ ... done
[11:01:29.128] Future #3
[11:01:29.128] signalConditionsASAP(SequentialFuture, pos=3) ...
[11:01:29.128] - nx: 6
[11:01:29.128] - relay: TRUE
[11:01:29.128] - stdout: TRUE
[11:01:29.128] - signal: TRUE
[11:01:29.128] - resignal: FALSE
[11:01:29.129] - force: TRUE
[11:01:29.129] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.129] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.129]  - until=3
[11:01:29.129]  - relaying element #3
[11:01:29.129] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.129] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.129] signalConditionsASAP(SequentialFuture, pos=3) ... done
[11:01:29.129]  length: 3 (resolved future 3)
[11:01:29.129] resolved() for ‘SequentialFuture’ ...
[11:01:29.129] - state: ‘finished’
[11:01:29.130] - run: TRUE
[11:01:29.130] - result: ‘FutureResult’
[11:01:29.130] resolved() for ‘SequentialFuture’ ... done
[11:01:29.130] Future #4
[11:01:29.130] signalConditionsASAP(SequentialFuture, pos=4) ...
[11:01:29.130] - nx: 6
[11:01:29.130] - relay: TRUE
[11:01:29.130] - stdout: TRUE
[11:01:29.130] - signal: TRUE
[11:01:29.130] - resignal: FALSE
[11:01:29.130] - force: TRUE
[11:01:29.130] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.130] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.131]  - until=4
[11:01:29.131]  - relaying element #4
[11:01:29.131] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.131] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.131] signalConditionsASAP(SequentialFuture, pos=4) ... done
[11:01:29.131]  length: 2 (resolved future 4)
[11:01:29.131] signalConditionsASAP(NULL, pos=5) ...
[11:01:29.131] - nx: 6
[11:01:29.131] - relay: TRUE
[11:01:29.131] - stdout: TRUE
[11:01:29.131] - signal: TRUE
[11:01:29.131] - resignal: FALSE
[11:01:29.132] - force: TRUE
[11:01:29.132] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.132] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.132]  - until=6
[11:01:29.132]  - relaying element #6
[11:01:29.132] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.132] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.132] signalConditionsASAP(NULL, pos=5) ... done
[11:01:29.132]  length: 1 (resolved future 5)
[11:01:29.132] signalConditionsASAP(numeric, pos=6) ...
[11:01:29.132] - nx: 6
[11:01:29.132] - relay: TRUE
[11:01:29.132] - stdout: TRUE
[11:01:29.133] - signal: TRUE
[11:01:29.133] - resignal: FALSE
[11:01:29.133] - force: TRUE
[11:01:29.133] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.133] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.133]  - until=6
[11:01:29.133] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.133] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.133] signalConditionsASAP(numeric, pos=6) ... done
[11:01:29.133]  length: 0 (resolved future 6)
[11:01:29.133] Relaying remaining futures
[11:01:29.133] signalConditionsASAP(NULL, pos=0) ...
[11:01:29.133] - nx: 6
[11:01:29.134] - relay: TRUE
[11:01:29.134] - stdout: TRUE
[11:01:29.134] - signal: TRUE
[11:01:29.134] - resignal: FALSE
[11:01:29.134] - force: TRUE
[11:01:29.134] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.134] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:29.134] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.134] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.134] signalConditionsASAP(NULL, pos=0) ... done
[11:01:29.134] resolve() on list environment ... DONE
Classes 'listenv', 'environment' <environment: 0x55a9c6b7e290> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 1 cores ... DONE
Testing with 2 cores ...
Type of object: list
Type of future: multicore
[11:01:29.137] plan(): Setting new future strategy stack:
[11:01:29.137] List of future strategies:
[11:01:29.137] 1. multicore:
[11:01:29.137]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.137]    - tweaked: FALSE
[11:01:29.137]    - call: plan(strategy)
[11:01:29.139] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[11:01:29.139] getGlobalsAndPackages() ...
[11:01:29.139] Searching for globals...
[11:01:29.139] 
[11:01:29.139] Searching for globals ... DONE
[11:01:29.139] - globals: [0] <none>
[11:01:29.139] getGlobalsAndPackages() ... DONE
[11:01:29.140] run() for ‘Future’ ...
[11:01:29.140] - state: ‘created’
[11:01:29.140] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.141] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.141] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.142]   - Field: ‘label’
[11:01:29.142]   - Field: ‘local’
[11:01:29.142]   - Field: ‘owner’
[11:01:29.142]   - Field: ‘envir’
[11:01:29.142]   - Field: ‘workers’
[11:01:29.142]   - Field: ‘packages’
[11:01:29.142]   - Field: ‘gc’
[11:01:29.142]   - Field: ‘job’
[11:01:29.142]   - Field: ‘conditions’
[11:01:29.142]   - Field: ‘expr’
[11:01:29.142]   - Field: ‘uuid’
[11:01:29.142]   - Field: ‘seed’
[11:01:29.143]   - Field: ‘version’
[11:01:29.143]   - Field: ‘result’
[11:01:29.143]   - Field: ‘asynchronous’
[11:01:29.143]   - Field: ‘calls’
[11:01:29.143]   - Field: ‘globals’
[11:01:29.143]   - Field: ‘stdout’
[11:01:29.143]   - Field: ‘earlySignal’
[11:01:29.143]   - Field: ‘lazy’
[11:01:29.143]   - Field: ‘state’
[11:01:29.143] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.143] - Launch lazy future ...
[11:01:29.144] Packages needed by the future expression (n = 0): <none>
[11:01:29.144] Packages needed by future strategies (n = 0): <none>
[11:01:29.145] {
[11:01:29.145]     {
[11:01:29.145]         {
[11:01:29.145]             ...future.startTime <- base::Sys.time()
[11:01:29.145]             {
[11:01:29.145]                 {
[11:01:29.145]                   {
[11:01:29.145]                     {
[11:01:29.145]                       base::local({
[11:01:29.145]                         has_future <- base::requireNamespace("future", 
[11:01:29.145]                           quietly = TRUE)
[11:01:29.145]                         if (has_future) {
[11:01:29.145]                           ns <- base::getNamespace("future")
[11:01:29.145]                           version <- ns[[".package"]][["version"]]
[11:01:29.145]                           if (is.null(version)) 
[11:01:29.145]                             version <- utils::packageVersion("future")
[11:01:29.145]                         }
[11:01:29.145]                         else {
[11:01:29.145]                           version <- NULL
[11:01:29.145]                         }
[11:01:29.145]                         if (!has_future || version < "1.8.0") {
[11:01:29.145]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.145]                             "", base::R.version$version.string), 
[11:01:29.145]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.145]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.145]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.145]                               "release", "version")], collapse = " "), 
[11:01:29.145]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.145]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.145]                             info)
[11:01:29.145]                           info <- base::paste(info, collapse = "; ")
[11:01:29.145]                           if (!has_future) {
[11:01:29.145]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.145]                               info)
[11:01:29.145]                           }
[11:01:29.145]                           else {
[11:01:29.145]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.145]                               info, version)
[11:01:29.145]                           }
[11:01:29.145]                           base::stop(msg)
[11:01:29.145]                         }
[11:01:29.145]                       })
[11:01:29.145]                     }
[11:01:29.145]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.145]                     base::options(mc.cores = 1L)
[11:01:29.145]                   }
[11:01:29.145]                   ...future.strategy.old <- future::plan("list")
[11:01:29.145]                   options(future.plan = NULL)
[11:01:29.145]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.145]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.145]                 }
[11:01:29.145]                 ...future.workdir <- getwd()
[11:01:29.145]             }
[11:01:29.145]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.145]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.145]         }
[11:01:29.145]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.145]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.145]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.145]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.145]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.145]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.145]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.145]             base::names(...future.oldOptions))
[11:01:29.145]     }
[11:01:29.145]     if (FALSE) {
[11:01:29.145]     }
[11:01:29.145]     else {
[11:01:29.145]         if (TRUE) {
[11:01:29.145]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.145]                 open = "w")
[11:01:29.145]         }
[11:01:29.145]         else {
[11:01:29.145]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.145]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.145]         }
[11:01:29.145]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.145]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.145]             base::sink(type = "output", split = FALSE)
[11:01:29.145]             base::close(...future.stdout)
[11:01:29.145]         }, add = TRUE)
[11:01:29.145]     }
[11:01:29.145]     ...future.frame <- base::sys.nframe()
[11:01:29.145]     ...future.conditions <- base::list()
[11:01:29.145]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.145]     if (FALSE) {
[11:01:29.145]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.145]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.145]     }
[11:01:29.145]     ...future.result <- base::tryCatch({
[11:01:29.145]         base::withCallingHandlers({
[11:01:29.145]             ...future.value <- base::withVisible(base::local({
[11:01:29.145]                 withCallingHandlers({
[11:01:29.145]                   2
[11:01:29.145]                 }, immediateCondition = function(cond) {
[11:01:29.145]                   save_rds <- function (object, pathname, ...) 
[11:01:29.145]                   {
[11:01:29.145]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.145]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.145]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.145]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.145]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.145]                         fi_tmp[["mtime"]])
[11:01:29.145]                     }
[11:01:29.145]                     tryCatch({
[11:01:29.145]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.145]                     }, error = function(ex) {
[11:01:29.145]                       msg <- conditionMessage(ex)
[11:01:29.145]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.145]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.145]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.145]                         fi_tmp[["mtime"]], msg)
[11:01:29.145]                       ex$message <- msg
[11:01:29.145]                       stop(ex)
[11:01:29.145]                     })
[11:01:29.145]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.145]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.145]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.145]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.145]                       fi <- file.info(pathname)
[11:01:29.145]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.145]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.145]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.145]                         fi[["size"]], fi[["mtime"]])
[11:01:29.145]                       stop(msg)
[11:01:29.145]                     }
[11:01:29.145]                     invisible(pathname)
[11:01:29.145]                   }
[11:01:29.145]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.145]                     rootPath = tempdir()) 
[11:01:29.145]                   {
[11:01:29.145]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.145]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.145]                       tmpdir = path, fileext = ".rds")
[11:01:29.145]                     save_rds(obj, file)
[11:01:29.145]                   }
[11:01:29.145]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.145]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.145]                   {
[11:01:29.145]                     inherits <- base::inherits
[11:01:29.145]                     invokeRestart <- base::invokeRestart
[11:01:29.145]                     is.null <- base::is.null
[11:01:29.145]                     muffled <- FALSE
[11:01:29.145]                     if (inherits(cond, "message")) {
[11:01:29.145]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.145]                       if (muffled) 
[11:01:29.145]                         invokeRestart("muffleMessage")
[11:01:29.145]                     }
[11:01:29.145]                     else if (inherits(cond, "warning")) {
[11:01:29.145]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.145]                       if (muffled) 
[11:01:29.145]                         invokeRestart("muffleWarning")
[11:01:29.145]                     }
[11:01:29.145]                     else if (inherits(cond, "condition")) {
[11:01:29.145]                       if (!is.null(pattern)) {
[11:01:29.145]                         computeRestarts <- base::computeRestarts
[11:01:29.145]                         grepl <- base::grepl
[11:01:29.145]                         restarts <- computeRestarts(cond)
[11:01:29.145]                         for (restart in restarts) {
[11:01:29.145]                           name <- restart$name
[11:01:29.145]                           if (is.null(name)) 
[11:01:29.145]                             next
[11:01:29.145]                           if (!grepl(pattern, name)) 
[11:01:29.145]                             next
[11:01:29.145]                           invokeRestart(restart)
[11:01:29.145]                           muffled <- TRUE
[11:01:29.145]                           break
[11:01:29.145]                         }
[11:01:29.145]                       }
[11:01:29.145]                     }
[11:01:29.145]                     invisible(muffled)
[11:01:29.145]                   }
[11:01:29.145]                   muffleCondition(cond)
[11:01:29.145]                 })
[11:01:29.145]             }))
[11:01:29.145]             future::FutureResult(value = ...future.value$value, 
[11:01:29.145]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.145]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.145]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.145]                     ...future.globalenv.names))
[11:01:29.145]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.145]         }, condition = base::local({
[11:01:29.145]             c <- base::c
[11:01:29.145]             inherits <- base::inherits
[11:01:29.145]             invokeRestart <- base::invokeRestart
[11:01:29.145]             length <- base::length
[11:01:29.145]             list <- base::list
[11:01:29.145]             seq.int <- base::seq.int
[11:01:29.145]             signalCondition <- base::signalCondition
[11:01:29.145]             sys.calls <- base::sys.calls
[11:01:29.145]             `[[` <- base::`[[`
[11:01:29.145]             `+` <- base::`+`
[11:01:29.145]             `<<-` <- base::`<<-`
[11:01:29.145]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.145]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.145]                   3L)]
[11:01:29.145]             }
[11:01:29.145]             function(cond) {
[11:01:29.145]                 is_error <- inherits(cond, "error")
[11:01:29.145]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.145]                   NULL)
[11:01:29.145]                 if (is_error) {
[11:01:29.145]                   sessionInformation <- function() {
[11:01:29.145]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.145]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.145]                       search = base::search(), system = base::Sys.info())
[11:01:29.145]                   }
[11:01:29.145]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.145]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.145]                     cond$call), session = sessionInformation(), 
[11:01:29.145]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.145]                   signalCondition(cond)
[11:01:29.145]                 }
[11:01:29.145]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.145]                 "immediateCondition"))) {
[11:01:29.145]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.145]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.145]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.145]                   if (TRUE && !signal) {
[11:01:29.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.145]                     {
[11:01:29.145]                       inherits <- base::inherits
[11:01:29.145]                       invokeRestart <- base::invokeRestart
[11:01:29.145]                       is.null <- base::is.null
[11:01:29.145]                       muffled <- FALSE
[11:01:29.145]                       if (inherits(cond, "message")) {
[11:01:29.145]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.145]                         if (muffled) 
[11:01:29.145]                           invokeRestart("muffleMessage")
[11:01:29.145]                       }
[11:01:29.145]                       else if (inherits(cond, "warning")) {
[11:01:29.145]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.145]                         if (muffled) 
[11:01:29.145]                           invokeRestart("muffleWarning")
[11:01:29.145]                       }
[11:01:29.145]                       else if (inherits(cond, "condition")) {
[11:01:29.145]                         if (!is.null(pattern)) {
[11:01:29.145]                           computeRestarts <- base::computeRestarts
[11:01:29.145]                           grepl <- base::grepl
[11:01:29.145]                           restarts <- computeRestarts(cond)
[11:01:29.145]                           for (restart in restarts) {
[11:01:29.145]                             name <- restart$name
[11:01:29.145]                             if (is.null(name)) 
[11:01:29.145]                               next
[11:01:29.145]                             if (!grepl(pattern, name)) 
[11:01:29.145]                               next
[11:01:29.145]                             invokeRestart(restart)
[11:01:29.145]                             muffled <- TRUE
[11:01:29.145]                             break
[11:01:29.145]                           }
[11:01:29.145]                         }
[11:01:29.145]                       }
[11:01:29.145]                       invisible(muffled)
[11:01:29.145]                     }
[11:01:29.145]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.145]                   }
[11:01:29.145]                 }
[11:01:29.145]                 else {
[11:01:29.145]                   if (TRUE) {
[11:01:29.145]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.145]                     {
[11:01:29.145]                       inherits <- base::inherits
[11:01:29.145]                       invokeRestart <- base::invokeRestart
[11:01:29.145]                       is.null <- base::is.null
[11:01:29.145]                       muffled <- FALSE
[11:01:29.145]                       if (inherits(cond, "message")) {
[11:01:29.145]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.145]                         if (muffled) 
[11:01:29.145]                           invokeRestart("muffleMessage")
[11:01:29.145]                       }
[11:01:29.145]                       else if (inherits(cond, "warning")) {
[11:01:29.145]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.145]                         if (muffled) 
[11:01:29.145]                           invokeRestart("muffleWarning")
[11:01:29.145]                       }
[11:01:29.145]                       else if (inherits(cond, "condition")) {
[11:01:29.145]                         if (!is.null(pattern)) {
[11:01:29.145]                           computeRestarts <- base::computeRestarts
[11:01:29.145]                           grepl <- base::grepl
[11:01:29.145]                           restarts <- computeRestarts(cond)
[11:01:29.145]                           for (restart in restarts) {
[11:01:29.145]                             name <- restart$name
[11:01:29.145]                             if (is.null(name)) 
[11:01:29.145]                               next
[11:01:29.145]                             if (!grepl(pattern, name)) 
[11:01:29.145]                               next
[11:01:29.145]                             invokeRestart(restart)
[11:01:29.145]                             muffled <- TRUE
[11:01:29.145]                             break
[11:01:29.145]                           }
[11:01:29.145]                         }
[11:01:29.145]                       }
[11:01:29.145]                       invisible(muffled)
[11:01:29.145]                     }
[11:01:29.145]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.145]                   }
[11:01:29.145]                 }
[11:01:29.145]             }
[11:01:29.145]         }))
[11:01:29.145]     }, error = function(ex) {
[11:01:29.145]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.145]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.145]                 ...future.rng), started = ...future.startTime, 
[11:01:29.145]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.145]             version = "1.8"), class = "FutureResult")
[11:01:29.145]     }, finally = {
[11:01:29.145]         if (!identical(...future.workdir, getwd())) 
[11:01:29.145]             setwd(...future.workdir)
[11:01:29.145]         {
[11:01:29.145]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.145]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.145]             }
[11:01:29.145]             base::options(...future.oldOptions)
[11:01:29.145]             if (.Platform$OS.type == "windows") {
[11:01:29.145]                 old_names <- names(...future.oldEnvVars)
[11:01:29.145]                 envs <- base::Sys.getenv()
[11:01:29.145]                 names <- names(envs)
[11:01:29.145]                 common <- intersect(names, old_names)
[11:01:29.145]                 added <- setdiff(names, old_names)
[11:01:29.145]                 removed <- setdiff(old_names, names)
[11:01:29.145]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.145]                   envs[common]]
[11:01:29.145]                 NAMES <- toupper(changed)
[11:01:29.145]                 args <- list()
[11:01:29.145]                 for (kk in seq_along(NAMES)) {
[11:01:29.145]                   name <- changed[[kk]]
[11:01:29.145]                   NAME <- NAMES[[kk]]
[11:01:29.145]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.145]                     next
[11:01:29.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.145]                 }
[11:01:29.145]                 NAMES <- toupper(added)
[11:01:29.145]                 for (kk in seq_along(NAMES)) {
[11:01:29.145]                   name <- added[[kk]]
[11:01:29.145]                   NAME <- NAMES[[kk]]
[11:01:29.145]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.145]                     next
[11:01:29.145]                   args[[name]] <- ""
[11:01:29.145]                 }
[11:01:29.145]                 NAMES <- toupper(removed)
[11:01:29.145]                 for (kk in seq_along(NAMES)) {
[11:01:29.145]                   name <- removed[[kk]]
[11:01:29.145]                   NAME <- NAMES[[kk]]
[11:01:29.145]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.145]                     next
[11:01:29.145]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.145]                 }
[11:01:29.145]                 if (length(args) > 0) 
[11:01:29.145]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.145]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.145]             }
[11:01:29.145]             else {
[11:01:29.145]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.145]             }
[11:01:29.145]             {
[11:01:29.145]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.145]                   0L) {
[11:01:29.145]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.145]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.145]                   base::options(opts)
[11:01:29.145]                 }
[11:01:29.145]                 {
[11:01:29.145]                   {
[11:01:29.145]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.145]                     NULL
[11:01:29.145]                   }
[11:01:29.145]                   options(future.plan = NULL)
[11:01:29.145]                   if (is.na(NA_character_)) 
[11:01:29.145]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.145]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.145]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.145]                     .init = FALSE)
[11:01:29.145]                 }
[11:01:29.145]             }
[11:01:29.145]         }
[11:01:29.145]     })
[11:01:29.145]     if (TRUE) {
[11:01:29.145]         base::sink(type = "output", split = FALSE)
[11:01:29.145]         if (TRUE) {
[11:01:29.145]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.145]         }
[11:01:29.145]         else {
[11:01:29.145]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.145]         }
[11:01:29.145]         base::close(...future.stdout)
[11:01:29.145]         ...future.stdout <- NULL
[11:01:29.145]     }
[11:01:29.145]     ...future.result$conditions <- ...future.conditions
[11:01:29.145]     ...future.result$finished <- base::Sys.time()
[11:01:29.145]     ...future.result
[11:01:29.145] }
[11:01:29.147] requestCore(): workers = 2
[11:01:29.150] MulticoreFuture started
[11:01:29.150] - Launch lazy future ... done
[11:01:29.150] plan(): Setting new future strategy stack:
[11:01:29.150] run() for ‘MulticoreFuture’ ... done
[11:01:29.151] getGlobalsAndPackages() ...
[11:01:29.151] Searching for globals...
[11:01:29.151] List of future strategies:
[11:01:29.151] 1. sequential:
[11:01:29.151]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.151]    - tweaked: FALSE
[11:01:29.151]    - call: NULL
[11:01:29.152] plan(): nbrOfWorkers() = 1
[11:01:29.152] 
[11:01:29.152] Searching for globals ... DONE
[11:01:29.152] - globals: [0] <none>
[11:01:29.153] getGlobalsAndPackages() ... DONE
[11:01:29.153] run() for ‘Future’ ...
[11:01:29.153] - state: ‘created’
[11:01:29.154] plan(): Setting new future strategy stack:
[11:01:29.154] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.154] List of future strategies:
[11:01:29.154] 1. multicore:
[11:01:29.154]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.154]    - tweaked: FALSE
[11:01:29.154]    - call: plan(strategy)
[11:01:29.156] plan(): nbrOfWorkers() = 2
[11:01:29.157] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.157] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.157]   - Field: ‘label’
[11:01:29.157]   - Field: ‘local’
[11:01:29.158]   - Field: ‘owner’
[11:01:29.158]   - Field: ‘envir’
[11:01:29.163]   - Field: ‘workers’
[11:01:29.163]   - Field: ‘packages’
[11:01:29.164]   - Field: ‘gc’
[11:01:29.164]   - Field: ‘job’
[11:01:29.165]   - Field: ‘conditions’
[11:01:29.165]   - Field: ‘expr’
[11:01:29.166]   - Field: ‘uuid’
[11:01:29.166]   - Field: ‘seed’
[11:01:29.167]   - Field: ‘version’
[11:01:29.167]   - Field: ‘result’
[11:01:29.168]   - Field: ‘asynchronous’
[11:01:29.168]   - Field: ‘calls’
[11:01:29.168]   - Field: ‘globals’
[11:01:29.169]   - Field: ‘stdout’
[11:01:29.169]   - Field: ‘earlySignal’
[11:01:29.170]   - Field: ‘lazy’
[11:01:29.170]   - Field: ‘state’
[11:01:29.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.170] - Launch lazy future ...
[11:01:29.171] Packages needed by the future expression (n = 0): <none>
[11:01:29.171] Packages needed by future strategies (n = 0): <none>
[11:01:29.172] {
[11:01:29.172]     {
[11:01:29.172]         {
[11:01:29.172]             ...future.startTime <- base::Sys.time()
[11:01:29.172]             {
[11:01:29.172]                 {
[11:01:29.172]                   {
[11:01:29.172]                     {
[11:01:29.172]                       base::local({
[11:01:29.172]                         has_future <- base::requireNamespace("future", 
[11:01:29.172]                           quietly = TRUE)
[11:01:29.172]                         if (has_future) {
[11:01:29.172]                           ns <- base::getNamespace("future")
[11:01:29.172]                           version <- ns[[".package"]][["version"]]
[11:01:29.172]                           if (is.null(version)) 
[11:01:29.172]                             version <- utils::packageVersion("future")
[11:01:29.172]                         }
[11:01:29.172]                         else {
[11:01:29.172]                           version <- NULL
[11:01:29.172]                         }
[11:01:29.172]                         if (!has_future || version < "1.8.0") {
[11:01:29.172]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.172]                             "", base::R.version$version.string), 
[11:01:29.172]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.172]                               "release", "version")], collapse = " "), 
[11:01:29.172]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.172]                             info)
[11:01:29.172]                           info <- base::paste(info, collapse = "; ")
[11:01:29.172]                           if (!has_future) {
[11:01:29.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.172]                               info)
[11:01:29.172]                           }
[11:01:29.172]                           else {
[11:01:29.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.172]                               info, version)
[11:01:29.172]                           }
[11:01:29.172]                           base::stop(msg)
[11:01:29.172]                         }
[11:01:29.172]                       })
[11:01:29.172]                     }
[11:01:29.172]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.172]                     base::options(mc.cores = 1L)
[11:01:29.172]                   }
[11:01:29.172]                   ...future.strategy.old <- future::plan("list")
[11:01:29.172]                   options(future.plan = NULL)
[11:01:29.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.172]                 }
[11:01:29.172]                 ...future.workdir <- getwd()
[11:01:29.172]             }
[11:01:29.172]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.172]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.172]         }
[11:01:29.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.172]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.172]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.172]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.172]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.172]             base::names(...future.oldOptions))
[11:01:29.172]     }
[11:01:29.172]     if (FALSE) {
[11:01:29.172]     }
[11:01:29.172]     else {
[11:01:29.172]         if (TRUE) {
[11:01:29.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.172]                 open = "w")
[11:01:29.172]         }
[11:01:29.172]         else {
[11:01:29.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.172]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.172]         }
[11:01:29.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.172]             base::sink(type = "output", split = FALSE)
[11:01:29.172]             base::close(...future.stdout)
[11:01:29.172]         }, add = TRUE)
[11:01:29.172]     }
[11:01:29.172]     ...future.frame <- base::sys.nframe()
[11:01:29.172]     ...future.conditions <- base::list()
[11:01:29.172]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.172]     if (FALSE) {
[11:01:29.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.172]     }
[11:01:29.172]     ...future.result <- base::tryCatch({
[11:01:29.172]         base::withCallingHandlers({
[11:01:29.172]             ...future.value <- base::withVisible(base::local({
[11:01:29.172]                 withCallingHandlers({
[11:01:29.172]                   NULL
[11:01:29.172]                 }, immediateCondition = function(cond) {
[11:01:29.172]                   save_rds <- function (object, pathname, ...) 
[11:01:29.172]                   {
[11:01:29.172]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.172]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.172]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.172]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.172]                         fi_tmp[["mtime"]])
[11:01:29.172]                     }
[11:01:29.172]                     tryCatch({
[11:01:29.172]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.172]                     }, error = function(ex) {
[11:01:29.172]                       msg <- conditionMessage(ex)
[11:01:29.172]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.172]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.172]                         fi_tmp[["mtime"]], msg)
[11:01:29.172]                       ex$message <- msg
[11:01:29.172]                       stop(ex)
[11:01:29.172]                     })
[11:01:29.172]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.172]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.172]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.172]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.172]                       fi <- file.info(pathname)
[11:01:29.172]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.172]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.172]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.172]                         fi[["size"]], fi[["mtime"]])
[11:01:29.172]                       stop(msg)
[11:01:29.172]                     }
[11:01:29.172]                     invisible(pathname)
[11:01:29.172]                   }
[11:01:29.172]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.172]                     rootPath = tempdir()) 
[11:01:29.172]                   {
[11:01:29.172]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.172]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.172]                       tmpdir = path, fileext = ".rds")
[11:01:29.172]                     save_rds(obj, file)
[11:01:29.172]                   }
[11:01:29.172]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.172]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.172]                   {
[11:01:29.172]                     inherits <- base::inherits
[11:01:29.172]                     invokeRestart <- base::invokeRestart
[11:01:29.172]                     is.null <- base::is.null
[11:01:29.172]                     muffled <- FALSE
[11:01:29.172]                     if (inherits(cond, "message")) {
[11:01:29.172]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.172]                       if (muffled) 
[11:01:29.172]                         invokeRestart("muffleMessage")
[11:01:29.172]                     }
[11:01:29.172]                     else if (inherits(cond, "warning")) {
[11:01:29.172]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.172]                       if (muffled) 
[11:01:29.172]                         invokeRestart("muffleWarning")
[11:01:29.172]                     }
[11:01:29.172]                     else if (inherits(cond, "condition")) {
[11:01:29.172]                       if (!is.null(pattern)) {
[11:01:29.172]                         computeRestarts <- base::computeRestarts
[11:01:29.172]                         grepl <- base::grepl
[11:01:29.172]                         restarts <- computeRestarts(cond)
[11:01:29.172]                         for (restart in restarts) {
[11:01:29.172]                           name <- restart$name
[11:01:29.172]                           if (is.null(name)) 
[11:01:29.172]                             next
[11:01:29.172]                           if (!grepl(pattern, name)) 
[11:01:29.172]                             next
[11:01:29.172]                           invokeRestart(restart)
[11:01:29.172]                           muffled <- TRUE
[11:01:29.172]                           break
[11:01:29.172]                         }
[11:01:29.172]                       }
[11:01:29.172]                     }
[11:01:29.172]                     invisible(muffled)
[11:01:29.172]                   }
[11:01:29.172]                   muffleCondition(cond)
[11:01:29.172]                 })
[11:01:29.172]             }))
[11:01:29.172]             future::FutureResult(value = ...future.value$value, 
[11:01:29.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.172]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.172]                     ...future.globalenv.names))
[11:01:29.172]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.172]         }, condition = base::local({
[11:01:29.172]             c <- base::c
[11:01:29.172]             inherits <- base::inherits
[11:01:29.172]             invokeRestart <- base::invokeRestart
[11:01:29.172]             length <- base::length
[11:01:29.172]             list <- base::list
[11:01:29.172]             seq.int <- base::seq.int
[11:01:29.172]             signalCondition <- base::signalCondition
[11:01:29.172]             sys.calls <- base::sys.calls
[11:01:29.172]             `[[` <- base::`[[`
[11:01:29.172]             `+` <- base::`+`
[11:01:29.172]             `<<-` <- base::`<<-`
[11:01:29.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.172]                   3L)]
[11:01:29.172]             }
[11:01:29.172]             function(cond) {
[11:01:29.172]                 is_error <- inherits(cond, "error")
[11:01:29.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.172]                   NULL)
[11:01:29.172]                 if (is_error) {
[11:01:29.172]                   sessionInformation <- function() {
[11:01:29.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.172]                       search = base::search(), system = base::Sys.info())
[11:01:29.172]                   }
[11:01:29.172]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.172]                     cond$call), session = sessionInformation(), 
[11:01:29.172]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.172]                   signalCondition(cond)
[11:01:29.172]                 }
[11:01:29.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.172]                 "immediateCondition"))) {
[11:01:29.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.172]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.172]                   if (TRUE && !signal) {
[11:01:29.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.172]                     {
[11:01:29.172]                       inherits <- base::inherits
[11:01:29.172]                       invokeRestart <- base::invokeRestart
[11:01:29.172]                       is.null <- base::is.null
[11:01:29.172]                       muffled <- FALSE
[11:01:29.172]                       if (inherits(cond, "message")) {
[11:01:29.172]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.172]                         if (muffled) 
[11:01:29.172]                           invokeRestart("muffleMessage")
[11:01:29.172]                       }
[11:01:29.172]                       else if (inherits(cond, "warning")) {
[11:01:29.172]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.172]                         if (muffled) 
[11:01:29.172]                           invokeRestart("muffleWarning")
[11:01:29.172]                       }
[11:01:29.172]                       else if (inherits(cond, "condition")) {
[11:01:29.172]                         if (!is.null(pattern)) {
[11:01:29.172]                           computeRestarts <- base::computeRestarts
[11:01:29.172]                           grepl <- base::grepl
[11:01:29.172]                           restarts <- computeRestarts(cond)
[11:01:29.172]                           for (restart in restarts) {
[11:01:29.172]                             name <- restart$name
[11:01:29.172]                             if (is.null(name)) 
[11:01:29.172]                               next
[11:01:29.172]                             if (!grepl(pattern, name)) 
[11:01:29.172]                               next
[11:01:29.172]                             invokeRestart(restart)
[11:01:29.172]                             muffled <- TRUE
[11:01:29.172]                             break
[11:01:29.172]                           }
[11:01:29.172]                         }
[11:01:29.172]                       }
[11:01:29.172]                       invisible(muffled)
[11:01:29.172]                     }
[11:01:29.172]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.172]                   }
[11:01:29.172]                 }
[11:01:29.172]                 else {
[11:01:29.172]                   if (TRUE) {
[11:01:29.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.172]                     {
[11:01:29.172]                       inherits <- base::inherits
[11:01:29.172]                       invokeRestart <- base::invokeRestart
[11:01:29.172]                       is.null <- base::is.null
[11:01:29.172]                       muffled <- FALSE
[11:01:29.172]                       if (inherits(cond, "message")) {
[11:01:29.172]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.172]                         if (muffled) 
[11:01:29.172]                           invokeRestart("muffleMessage")
[11:01:29.172]                       }
[11:01:29.172]                       else if (inherits(cond, "warning")) {
[11:01:29.172]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.172]                         if (muffled) 
[11:01:29.172]                           invokeRestart("muffleWarning")
[11:01:29.172]                       }
[11:01:29.172]                       else if (inherits(cond, "condition")) {
[11:01:29.172]                         if (!is.null(pattern)) {
[11:01:29.172]                           computeRestarts <- base::computeRestarts
[11:01:29.172]                           grepl <- base::grepl
[11:01:29.172]                           restarts <- computeRestarts(cond)
[11:01:29.172]                           for (restart in restarts) {
[11:01:29.172]                             name <- restart$name
[11:01:29.172]                             if (is.null(name)) 
[11:01:29.172]                               next
[11:01:29.172]                             if (!grepl(pattern, name)) 
[11:01:29.172]                               next
[11:01:29.172]                             invokeRestart(restart)
[11:01:29.172]                             muffled <- TRUE
[11:01:29.172]                             break
[11:01:29.172]                           }
[11:01:29.172]                         }
[11:01:29.172]                       }
[11:01:29.172]                       invisible(muffled)
[11:01:29.172]                     }
[11:01:29.172]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.172]                   }
[11:01:29.172]                 }
[11:01:29.172]             }
[11:01:29.172]         }))
[11:01:29.172]     }, error = function(ex) {
[11:01:29.172]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.172]                 ...future.rng), started = ...future.startTime, 
[11:01:29.172]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.172]             version = "1.8"), class = "FutureResult")
[11:01:29.172]     }, finally = {
[11:01:29.172]         if (!identical(...future.workdir, getwd())) 
[11:01:29.172]             setwd(...future.workdir)
[11:01:29.172]         {
[11:01:29.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.172]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.172]             }
[11:01:29.172]             base::options(...future.oldOptions)
[11:01:29.172]             if (.Platform$OS.type == "windows") {
[11:01:29.172]                 old_names <- names(...future.oldEnvVars)
[11:01:29.172]                 envs <- base::Sys.getenv()
[11:01:29.172]                 names <- names(envs)
[11:01:29.172]                 common <- intersect(names, old_names)
[11:01:29.172]                 added <- setdiff(names, old_names)
[11:01:29.172]                 removed <- setdiff(old_names, names)
[11:01:29.172]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.172]                   envs[common]]
[11:01:29.172]                 NAMES <- toupper(changed)
[11:01:29.172]                 args <- list()
[11:01:29.172]                 for (kk in seq_along(NAMES)) {
[11:01:29.172]                   name <- changed[[kk]]
[11:01:29.172]                   NAME <- NAMES[[kk]]
[11:01:29.172]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.172]                     next
[11:01:29.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.172]                 }
[11:01:29.172]                 NAMES <- toupper(added)
[11:01:29.172]                 for (kk in seq_along(NAMES)) {
[11:01:29.172]                   name <- added[[kk]]
[11:01:29.172]                   NAME <- NAMES[[kk]]
[11:01:29.172]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.172]                     next
[11:01:29.172]                   args[[name]] <- ""
[11:01:29.172]                 }
[11:01:29.172]                 NAMES <- toupper(removed)
[11:01:29.172]                 for (kk in seq_along(NAMES)) {
[11:01:29.172]                   name <- removed[[kk]]
[11:01:29.172]                   NAME <- NAMES[[kk]]
[11:01:29.172]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.172]                     next
[11:01:29.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.172]                 }
[11:01:29.172]                 if (length(args) > 0) 
[11:01:29.172]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.172]             }
[11:01:29.172]             else {
[11:01:29.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.172]             }
[11:01:29.172]             {
[11:01:29.172]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.172]                   0L) {
[11:01:29.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.172]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.172]                   base::options(opts)
[11:01:29.172]                 }
[11:01:29.172]                 {
[11:01:29.172]                   {
[11:01:29.172]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.172]                     NULL
[11:01:29.172]                   }
[11:01:29.172]                   options(future.plan = NULL)
[11:01:29.172]                   if (is.na(NA_character_)) 
[11:01:29.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.172]                     .init = FALSE)
[11:01:29.172]                 }
[11:01:29.172]             }
[11:01:29.172]         }
[11:01:29.172]     })
[11:01:29.172]     if (TRUE) {
[11:01:29.172]         base::sink(type = "output", split = FALSE)
[11:01:29.172]         if (TRUE) {
[11:01:29.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.172]         }
[11:01:29.172]         else {
[11:01:29.172]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.172]         }
[11:01:29.172]         base::close(...future.stdout)
[11:01:29.172]         ...future.stdout <- NULL
[11:01:29.172]     }
[11:01:29.172]     ...future.result$conditions <- ...future.conditions
[11:01:29.172]     ...future.result$finished <- base::Sys.time()
[11:01:29.172]     ...future.result
[11:01:29.172] }
[11:01:29.175] requestCore(): workers = 2
[11:01:29.183] MulticoreFuture started
[11:01:29.183] - Launch lazy future ... done
[11:01:29.184] run() for ‘MulticoreFuture’ ... done
[11:01:29.184] plan(): Setting new future strategy stack:
List of 6
 $ a:[11:01:29.184] List of future strategies:
[11:01:29.184] 1. sequential:
[11:01:29.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.184]    - tweaked: FALSE
[11:01:29.184]    - call: NULL
[11:01:29.185] plan(): nbrOfWorkers() = 1
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c66d1e40> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c6bf1630> 
 $  : NULL
 $  :[11:01:29.187] plan(): Setting new future strategy stack:
 NULL
 $  :[11:01:29.188] List of future strategies:
[11:01:29.188] 1. multicore:
[11:01:29.188]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.188]    - tweaked: FALSE
[11:01:29.188]    - call: plan(strategy)
 num 6
List of 6
 $ a: num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c66d1e40> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c6bf1630> 
 $  : NULL
 $  : NULL
 $  :[11:01:29.191] plan(): nbrOfWorkers() = 2
 num 6
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:29.194] resolve() on list ...
[11:01:29.194]  recursive: 0
[11:01:29.194]  length: 6
[11:01:29.194]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:29.195] signalConditionsASAP(numeric, pos=1) ...
[11:01:29.195] - nx: 6
[11:01:29.195] - relay: TRUE
[11:01:29.195] - stdout: TRUE
[11:01:29.195] - signal: TRUE
[11:01:29.195] - resignal: FALSE
[11:01:29.195] - force: TRUE
[11:01:29.196] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.196] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.196]  - until=2
[11:01:29.196]  - relaying element #2
[11:01:29.196] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.196] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.196] signalConditionsASAP(NULL, pos=1) ... done
[11:01:29.197]  length: 5 (resolved future 1)
[11:01:29.197] Future #2
[11:01:29.197] result() for MulticoreFuture ...
[11:01:29.199] result() for MulticoreFuture ...
[11:01:29.199] result() for MulticoreFuture ... done
[11:01:29.199] result() for MulticoreFuture ... done
[11:01:29.199] result() for MulticoreFuture ...
[11:01:29.200] result() for MulticoreFuture ... done
[11:01:29.200] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:29.200] - nx: 6
[11:01:29.200] - relay: TRUE
[11:01:29.200] - stdout: TRUE
[11:01:29.200] - signal: TRUE
[11:01:29.200] - resignal: FALSE
[11:01:29.201] - force: TRUE
[11:01:29.201] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.201] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.201]  - until=2
[11:01:29.201]  - relaying element #2
[11:01:29.201] result() for MulticoreFuture ...
[11:01:29.201] result() for MulticoreFuture ... done
[11:01:29.201] result() for MulticoreFuture ...
[11:01:29.202] result() for MulticoreFuture ... done
[11:01:29.202] result() for MulticoreFuture ...
[11:01:29.202] result() for MulticoreFuture ... done
[11:01:29.202] result() for MulticoreFuture ...
[11:01:29.202] result() for MulticoreFuture ... done
[11:01:29.202] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.202] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.203] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:29.203]  length: 4 (resolved future 2)
[11:01:29.203] Future #3
[11:01:29.203] result() for MulticoreFuture ...
[11:01:29.204] result() for MulticoreFuture ...
[11:01:29.204] result() for MulticoreFuture ... done
[11:01:29.204] result() for MulticoreFuture ... done
[11:01:29.204] result() for MulticoreFuture ...
[11:01:29.204] result() for MulticoreFuture ... done
[11:01:29.205] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:29.205] - nx: 6
[11:01:29.205] - relay: TRUE
[11:01:29.205] - stdout: TRUE
[11:01:29.205] - signal: TRUE
[11:01:29.205] - resignal: FALSE
[11:01:29.205] - force: TRUE
[11:01:29.205] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.206] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.206]  - until=3
[11:01:29.206]  - relaying element #3
[11:01:29.206] result() for MulticoreFuture ...
[11:01:29.206] result() for MulticoreFuture ... done
[11:01:29.206] result() for MulticoreFuture ...
[11:01:29.206] result() for MulticoreFuture ... done
[11:01:29.206] result() for MulticoreFuture ...
[11:01:29.207] result() for MulticoreFuture ... done
[11:01:29.207] result() for MulticoreFuture ...
[11:01:29.207] result() for MulticoreFuture ... done
[11:01:29.207] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.207] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.207] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:29.207]  length: 3 (resolved future 3)
[11:01:29.207] signalConditionsASAP(NULL, pos=4) ...
[11:01:29.207] - nx: 6
[11:01:29.208] - relay: TRUE
[11:01:29.208] - stdout: TRUE
[11:01:29.208] - signal: TRUE
[11:01:29.208] - resignal: FALSE
[11:01:29.208] - force: TRUE
[11:01:29.208] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.208] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.208]  - until=5
[11:01:29.208]  - relaying element #5
[11:01:29.208] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.209] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.209] signalConditionsASAP(NULL, pos=4) ... done
[11:01:29.209]  length: 2 (resolved future 4)
[11:01:29.209] signalConditionsASAP(NULL, pos=5) ...
[11:01:29.209] - nx: 6
[11:01:29.209] - relay: TRUE
[11:01:29.209] - stdout: TRUE
[11:01:29.209] - signal: TRUE
[11:01:29.209] - resignal: FALSE
[11:01:29.209] - force: TRUE
[11:01:29.209] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.210] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.210]  - until=6
[11:01:29.210]  - relaying element #6
[11:01:29.210] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.210] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.210] signalConditionsASAP(NULL, pos=5) ... done
[11:01:29.210]  length: 1 (resolved future 5)
[11:01:29.210] signalConditionsASAP(numeric, pos=6) ...
[11:01:29.210] - nx: 6
[11:01:29.210] - relay: TRUE
[11:01:29.211] - stdout: TRUE
[11:01:29.211] - signal: TRUE
[11:01:29.211] - resignal: FALSE
[11:01:29.211] - force: TRUE
[11:01:29.211] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.211] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.211]  - until=6
[11:01:29.211] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.211] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.211] signalConditionsASAP(numeric, pos=6) ... done
[11:01:29.212]  length: 0 (resolved future 6)
[11:01:29.212] Relaying remaining futures
[11:01:29.212] signalConditionsASAP(NULL, pos=0) ...
[11:01:29.212] - nx: 6
[11:01:29.212] - relay: TRUE
[11:01:29.212] - stdout: TRUE
[11:01:29.212] - signal: TRUE
[11:01:29.214] - resignal: FALSE
[11:01:29.214] - force: TRUE
[11:01:29.215] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.215] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:29.215] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.215] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.215] signalConditionsASAP(NULL, pos=0) ... done
[11:01:29.215] resolve() on list ... DONE
[11:01:29.216] result() for MulticoreFuture ...
[11:01:29.216] result() for MulticoreFuture ... done
[11:01:29.216] result() for MulticoreFuture ...
[11:01:29.216] result() for MulticoreFuture ... done
[11:01:29.216] result() for MulticoreFuture ...
[11:01:29.216] result() for MulticoreFuture ... done
[11:01:29.216] result() for MulticoreFuture ...
[11:01:29.216] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[11:01:29.219] getGlobalsAndPackages() ...
[11:01:29.219] Searching for globals...
[11:01:29.219] 
[11:01:29.220] Searching for globals ... DONE
[11:01:29.220] - globals: [0] <none>
[11:01:29.220] getGlobalsAndPackages() ... DONE
[11:01:29.220] run() for ‘Future’ ...
[11:01:29.220] - state: ‘created’
[11:01:29.220] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.222] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.222] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.223]   - Field: ‘label’
[11:01:29.223]   - Field: ‘local’
[11:01:29.223]   - Field: ‘owner’
[11:01:29.223]   - Field: ‘envir’
[11:01:29.223]   - Field: ‘workers’
[11:01:29.223]   - Field: ‘packages’
[11:01:29.223]   - Field: ‘gc’
[11:01:29.223]   - Field: ‘job’
[11:01:29.223]   - Field: ‘conditions’
[11:01:29.223]   - Field: ‘expr’
[11:01:29.224]   - Field: ‘uuid’
[11:01:29.224]   - Field: ‘seed’
[11:01:29.224]   - Field: ‘version’
[11:01:29.224]   - Field: ‘result’
[11:01:29.224]   - Field: ‘asynchronous’
[11:01:29.224]   - Field: ‘calls’
[11:01:29.224]   - Field: ‘globals’
[11:01:29.224]   - Field: ‘stdout’
[11:01:29.224]   - Field: ‘earlySignal’
[11:01:29.224]   - Field: ‘lazy’
[11:01:29.224]   - Field: ‘state’
[11:01:29.224] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.225] - Launch lazy future ...
[11:01:29.225] Packages needed by the future expression (n = 0): <none>
[11:01:29.225] Packages needed by future strategies (n = 0): <none>
[11:01:29.225] {
[11:01:29.225]     {
[11:01:29.225]         {
[11:01:29.225]             ...future.startTime <- base::Sys.time()
[11:01:29.225]             {
[11:01:29.225]                 {
[11:01:29.225]                   {
[11:01:29.225]                     {
[11:01:29.225]                       base::local({
[11:01:29.225]                         has_future <- base::requireNamespace("future", 
[11:01:29.225]                           quietly = TRUE)
[11:01:29.225]                         if (has_future) {
[11:01:29.225]                           ns <- base::getNamespace("future")
[11:01:29.225]                           version <- ns[[".package"]][["version"]]
[11:01:29.225]                           if (is.null(version)) 
[11:01:29.225]                             version <- utils::packageVersion("future")
[11:01:29.225]                         }
[11:01:29.225]                         else {
[11:01:29.225]                           version <- NULL
[11:01:29.225]                         }
[11:01:29.225]                         if (!has_future || version < "1.8.0") {
[11:01:29.225]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.225]                             "", base::R.version$version.string), 
[11:01:29.225]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.225]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.225]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.225]                               "release", "version")], collapse = " "), 
[11:01:29.225]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.225]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.225]                             info)
[11:01:29.225]                           info <- base::paste(info, collapse = "; ")
[11:01:29.225]                           if (!has_future) {
[11:01:29.225]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.225]                               info)
[11:01:29.225]                           }
[11:01:29.225]                           else {
[11:01:29.225]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.225]                               info, version)
[11:01:29.225]                           }
[11:01:29.225]                           base::stop(msg)
[11:01:29.225]                         }
[11:01:29.225]                       })
[11:01:29.225]                     }
[11:01:29.225]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.225]                     base::options(mc.cores = 1L)
[11:01:29.225]                   }
[11:01:29.225]                   ...future.strategy.old <- future::plan("list")
[11:01:29.225]                   options(future.plan = NULL)
[11:01:29.225]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.225]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.225]                 }
[11:01:29.225]                 ...future.workdir <- getwd()
[11:01:29.225]             }
[11:01:29.225]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.225]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.225]         }
[11:01:29.225]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.225]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.225]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.225]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.225]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.225]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.225]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.225]             base::names(...future.oldOptions))
[11:01:29.225]     }
[11:01:29.225]     if (FALSE) {
[11:01:29.225]     }
[11:01:29.225]     else {
[11:01:29.225]         if (TRUE) {
[11:01:29.225]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.225]                 open = "w")
[11:01:29.225]         }
[11:01:29.225]         else {
[11:01:29.225]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.225]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.225]         }
[11:01:29.225]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.225]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.225]             base::sink(type = "output", split = FALSE)
[11:01:29.225]             base::close(...future.stdout)
[11:01:29.225]         }, add = TRUE)
[11:01:29.225]     }
[11:01:29.225]     ...future.frame <- base::sys.nframe()
[11:01:29.225]     ...future.conditions <- base::list()
[11:01:29.225]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.225]     if (FALSE) {
[11:01:29.225]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.225]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.225]     }
[11:01:29.225]     ...future.result <- base::tryCatch({
[11:01:29.225]         base::withCallingHandlers({
[11:01:29.225]             ...future.value <- base::withVisible(base::local({
[11:01:29.225]                 withCallingHandlers({
[11:01:29.225]                   2
[11:01:29.225]                 }, immediateCondition = function(cond) {
[11:01:29.225]                   save_rds <- function (object, pathname, ...) 
[11:01:29.225]                   {
[11:01:29.225]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.225]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.225]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.225]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.225]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.225]                         fi_tmp[["mtime"]])
[11:01:29.225]                     }
[11:01:29.225]                     tryCatch({
[11:01:29.225]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.225]                     }, error = function(ex) {
[11:01:29.225]                       msg <- conditionMessage(ex)
[11:01:29.225]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.225]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.225]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.225]                         fi_tmp[["mtime"]], msg)
[11:01:29.225]                       ex$message <- msg
[11:01:29.225]                       stop(ex)
[11:01:29.225]                     })
[11:01:29.225]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.225]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.225]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.225]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.225]                       fi <- file.info(pathname)
[11:01:29.225]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.225]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.225]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.225]                         fi[["size"]], fi[["mtime"]])
[11:01:29.225]                       stop(msg)
[11:01:29.225]                     }
[11:01:29.225]                     invisible(pathname)
[11:01:29.225]                   }
[11:01:29.225]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.225]                     rootPath = tempdir()) 
[11:01:29.225]                   {
[11:01:29.225]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.225]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.225]                       tmpdir = path, fileext = ".rds")
[11:01:29.225]                     save_rds(obj, file)
[11:01:29.225]                   }
[11:01:29.225]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.225]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.225]                   {
[11:01:29.225]                     inherits <- base::inherits
[11:01:29.225]                     invokeRestart <- base::invokeRestart
[11:01:29.225]                     is.null <- base::is.null
[11:01:29.225]                     muffled <- FALSE
[11:01:29.225]                     if (inherits(cond, "message")) {
[11:01:29.225]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.225]                       if (muffled) 
[11:01:29.225]                         invokeRestart("muffleMessage")
[11:01:29.225]                     }
[11:01:29.225]                     else if (inherits(cond, "warning")) {
[11:01:29.225]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.225]                       if (muffled) 
[11:01:29.225]                         invokeRestart("muffleWarning")
[11:01:29.225]                     }
[11:01:29.225]                     else if (inherits(cond, "condition")) {
[11:01:29.225]                       if (!is.null(pattern)) {
[11:01:29.225]                         computeRestarts <- base::computeRestarts
[11:01:29.225]                         grepl <- base::grepl
[11:01:29.225]                         restarts <- computeRestarts(cond)
[11:01:29.225]                         for (restart in restarts) {
[11:01:29.225]                           name <- restart$name
[11:01:29.225]                           if (is.null(name)) 
[11:01:29.225]                             next
[11:01:29.225]                           if (!grepl(pattern, name)) 
[11:01:29.225]                             next
[11:01:29.225]                           invokeRestart(restart)
[11:01:29.225]                           muffled <- TRUE
[11:01:29.225]                           break
[11:01:29.225]                         }
[11:01:29.225]                       }
[11:01:29.225]                     }
[11:01:29.225]                     invisible(muffled)
[11:01:29.225]                   }
[11:01:29.225]                   muffleCondition(cond)
[11:01:29.225]                 })
[11:01:29.225]             }))
[11:01:29.225]             future::FutureResult(value = ...future.value$value, 
[11:01:29.225]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.225]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.225]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.225]                     ...future.globalenv.names))
[11:01:29.225]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.225]         }, condition = base::local({
[11:01:29.225]             c <- base::c
[11:01:29.225]             inherits <- base::inherits
[11:01:29.225]             invokeRestart <- base::invokeRestart
[11:01:29.225]             length <- base::length
[11:01:29.225]             list <- base::list
[11:01:29.225]             seq.int <- base::seq.int
[11:01:29.225]             signalCondition <- base::signalCondition
[11:01:29.225]             sys.calls <- base::sys.calls
[11:01:29.225]             `[[` <- base::`[[`
[11:01:29.225]             `+` <- base::`+`
[11:01:29.225]             `<<-` <- base::`<<-`
[11:01:29.225]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.225]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.225]                   3L)]
[11:01:29.225]             }
[11:01:29.225]             function(cond) {
[11:01:29.225]                 is_error <- inherits(cond, "error")
[11:01:29.225]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.225]                   NULL)
[11:01:29.225]                 if (is_error) {
[11:01:29.225]                   sessionInformation <- function() {
[11:01:29.225]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.225]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.225]                       search = base::search(), system = base::Sys.info())
[11:01:29.225]                   }
[11:01:29.225]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.225]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.225]                     cond$call), session = sessionInformation(), 
[11:01:29.225]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.225]                   signalCondition(cond)
[11:01:29.225]                 }
[11:01:29.225]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.225]                 "immediateCondition"))) {
[11:01:29.225]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.225]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.225]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.225]                   if (TRUE && !signal) {
[11:01:29.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.225]                     {
[11:01:29.225]                       inherits <- base::inherits
[11:01:29.225]                       invokeRestart <- base::invokeRestart
[11:01:29.225]                       is.null <- base::is.null
[11:01:29.225]                       muffled <- FALSE
[11:01:29.225]                       if (inherits(cond, "message")) {
[11:01:29.225]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.225]                         if (muffled) 
[11:01:29.225]                           invokeRestart("muffleMessage")
[11:01:29.225]                       }
[11:01:29.225]                       else if (inherits(cond, "warning")) {
[11:01:29.225]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.225]                         if (muffled) 
[11:01:29.225]                           invokeRestart("muffleWarning")
[11:01:29.225]                       }
[11:01:29.225]                       else if (inherits(cond, "condition")) {
[11:01:29.225]                         if (!is.null(pattern)) {
[11:01:29.225]                           computeRestarts <- base::computeRestarts
[11:01:29.225]                           grepl <- base::grepl
[11:01:29.225]                           restarts <- computeRestarts(cond)
[11:01:29.225]                           for (restart in restarts) {
[11:01:29.225]                             name <- restart$name
[11:01:29.225]                             if (is.null(name)) 
[11:01:29.225]                               next
[11:01:29.225]                             if (!grepl(pattern, name)) 
[11:01:29.225]                               next
[11:01:29.225]                             invokeRestart(restart)
[11:01:29.225]                             muffled <- TRUE
[11:01:29.225]                             break
[11:01:29.225]                           }
[11:01:29.225]                         }
[11:01:29.225]                       }
[11:01:29.225]                       invisible(muffled)
[11:01:29.225]                     }
[11:01:29.225]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.225]                   }
[11:01:29.225]                 }
[11:01:29.225]                 else {
[11:01:29.225]                   if (TRUE) {
[11:01:29.225]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.225]                     {
[11:01:29.225]                       inherits <- base::inherits
[11:01:29.225]                       invokeRestart <- base::invokeRestart
[11:01:29.225]                       is.null <- base::is.null
[11:01:29.225]                       muffled <- FALSE
[11:01:29.225]                       if (inherits(cond, "message")) {
[11:01:29.225]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.225]                         if (muffled) 
[11:01:29.225]                           invokeRestart("muffleMessage")
[11:01:29.225]                       }
[11:01:29.225]                       else if (inherits(cond, "warning")) {
[11:01:29.225]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.225]                         if (muffled) 
[11:01:29.225]                           invokeRestart("muffleWarning")
[11:01:29.225]                       }
[11:01:29.225]                       else if (inherits(cond, "condition")) {
[11:01:29.225]                         if (!is.null(pattern)) {
[11:01:29.225]                           computeRestarts <- base::computeRestarts
[11:01:29.225]                           grepl <- base::grepl
[11:01:29.225]                           restarts <- computeRestarts(cond)
[11:01:29.225]                           for (restart in restarts) {
[11:01:29.225]                             name <- restart$name
[11:01:29.225]                             if (is.null(name)) 
[11:01:29.225]                               next
[11:01:29.225]                             if (!grepl(pattern, name)) 
[11:01:29.225]                               next
[11:01:29.225]                             invokeRestart(restart)
[11:01:29.225]                             muffled <- TRUE
[11:01:29.225]                             break
[11:01:29.225]                           }
[11:01:29.225]                         }
[11:01:29.225]                       }
[11:01:29.225]                       invisible(muffled)
[11:01:29.225]                     }
[11:01:29.225]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.225]                   }
[11:01:29.225]                 }
[11:01:29.225]             }
[11:01:29.225]         }))
[11:01:29.225]     }, error = function(ex) {
[11:01:29.225]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.225]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.225]                 ...future.rng), started = ...future.startTime, 
[11:01:29.225]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.225]             version = "1.8"), class = "FutureResult")
[11:01:29.225]     }, finally = {
[11:01:29.225]         if (!identical(...future.workdir, getwd())) 
[11:01:29.225]             setwd(...future.workdir)
[11:01:29.225]         {
[11:01:29.225]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.225]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.225]             }
[11:01:29.225]             base::options(...future.oldOptions)
[11:01:29.225]             if (.Platform$OS.type == "windows") {
[11:01:29.225]                 old_names <- names(...future.oldEnvVars)
[11:01:29.225]                 envs <- base::Sys.getenv()
[11:01:29.225]                 names <- names(envs)
[11:01:29.225]                 common <- intersect(names, old_names)
[11:01:29.225]                 added <- setdiff(names, old_names)
[11:01:29.225]                 removed <- setdiff(old_names, names)
[11:01:29.225]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.225]                   envs[common]]
[11:01:29.225]                 NAMES <- toupper(changed)
[11:01:29.225]                 args <- list()
[11:01:29.225]                 for (kk in seq_along(NAMES)) {
[11:01:29.225]                   name <- changed[[kk]]
[11:01:29.225]                   NAME <- NAMES[[kk]]
[11:01:29.225]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.225]                     next
[11:01:29.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.225]                 }
[11:01:29.225]                 NAMES <- toupper(added)
[11:01:29.225]                 for (kk in seq_along(NAMES)) {
[11:01:29.225]                   name <- added[[kk]]
[11:01:29.225]                   NAME <- NAMES[[kk]]
[11:01:29.225]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.225]                     next
[11:01:29.225]                   args[[name]] <- ""
[11:01:29.225]                 }
[11:01:29.225]                 NAMES <- toupper(removed)
[11:01:29.225]                 for (kk in seq_along(NAMES)) {
[11:01:29.225]                   name <- removed[[kk]]
[11:01:29.225]                   NAME <- NAMES[[kk]]
[11:01:29.225]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.225]                     next
[11:01:29.225]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.225]                 }
[11:01:29.225]                 if (length(args) > 0) 
[11:01:29.225]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.225]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.225]             }
[11:01:29.225]             else {
[11:01:29.225]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.225]             }
[11:01:29.225]             {
[11:01:29.225]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.225]                   0L) {
[11:01:29.225]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.225]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.225]                   base::options(opts)
[11:01:29.225]                 }
[11:01:29.225]                 {
[11:01:29.225]                   {
[11:01:29.225]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.225]                     NULL
[11:01:29.225]                   }
[11:01:29.225]                   options(future.plan = NULL)
[11:01:29.225]                   if (is.na(NA_character_)) 
[11:01:29.225]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.225]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.225]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.225]                     .init = FALSE)
[11:01:29.225]                 }
[11:01:29.225]             }
[11:01:29.225]         }
[11:01:29.225]     })
[11:01:29.225]     if (TRUE) {
[11:01:29.225]         base::sink(type = "output", split = FALSE)
[11:01:29.225]         if (TRUE) {
[11:01:29.225]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.225]         }
[11:01:29.225]         else {
[11:01:29.225]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.225]         }
[11:01:29.225]         base::close(...future.stdout)
[11:01:29.225]         ...future.stdout <- NULL
[11:01:29.225]     }
[11:01:29.225]     ...future.result$conditions <- ...future.conditions
[11:01:29.225]     ...future.result$finished <- base::Sys.time()
[11:01:29.225]     ...future.result
[11:01:29.225] }
[11:01:29.228] requestCore(): workers = 2
[11:01:29.229] MulticoreFuture started
[11:01:29.230] - Launch lazy future ... done
[11:01:29.230] run() for ‘MulticoreFuture’ ... done
[11:01:29.230] getGlobalsAndPackages() ...
[11:01:29.230] Searching for globals...
[11:01:29.230] plan(): Setting new future strategy stack:
[11:01:29.231] 
[11:01:29.231] List of future strategies:
[11:01:29.231] 1. sequential:
[11:01:29.231]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.231]    - tweaked: FALSE
[11:01:29.231]    - call: NULL
[11:01:29.231] Searching for globals ... DONE
[11:01:29.232] - globals: [0] <none>
[11:01:29.232] plan(): nbrOfWorkers() = 1
[11:01:29.232] getGlobalsAndPackages() ... DONE
[11:01:29.232] run() for ‘Future’ ...
[11:01:29.233] - state: ‘created’
[11:01:29.233] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.233] plan(): Setting new future strategy stack:
[11:01:29.234] List of future strategies:
[11:01:29.234] 1. multicore:
[11:01:29.234]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.234]    - tweaked: FALSE
[11:01:29.234]    - call: plan(strategy)
[11:01:29.236] plan(): nbrOfWorkers() = 2
[11:01:29.236] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.236] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.236]   - Field: ‘label’
[11:01:29.236]   - Field: ‘local’
[11:01:29.237]   - Field: ‘owner’
[11:01:29.237]   - Field: ‘envir’
[11:01:29.237]   - Field: ‘workers’
[11:01:29.237]   - Field: ‘packages’
[11:01:29.237]   - Field: ‘gc’
[11:01:29.237]   - Field: ‘job’
[11:01:29.237]   - Field: ‘conditions’
[11:01:29.238]   - Field: ‘expr’
[11:01:29.238]   - Field: ‘uuid’
[11:01:29.238]   - Field: ‘seed’
[11:01:29.238]   - Field: ‘version’
[11:01:29.238]   - Field: ‘result’
[11:01:29.238]   - Field: ‘asynchronous’
[11:01:29.238]   - Field: ‘calls’
[11:01:29.239]   - Field: ‘globals’
[11:01:29.239]   - Field: ‘stdout’
[11:01:29.239]   - Field: ‘earlySignal’
[11:01:29.239]   - Field: ‘lazy’
[11:01:29.239]   - Field: ‘state’
[11:01:29.239] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.239] - Launch lazy future ...
[11:01:29.240] Packages needed by the future expression (n = 0): <none>
[11:01:29.240] Packages needed by future strategies (n = 0): <none>
[11:01:29.241] {
[11:01:29.241]     {
[11:01:29.241]         {
[11:01:29.241]             ...future.startTime <- base::Sys.time()
[11:01:29.241]             {
[11:01:29.241]                 {
[11:01:29.241]                   {
[11:01:29.241]                     {
[11:01:29.241]                       base::local({
[11:01:29.241]                         has_future <- base::requireNamespace("future", 
[11:01:29.241]                           quietly = TRUE)
[11:01:29.241]                         if (has_future) {
[11:01:29.241]                           ns <- base::getNamespace("future")
[11:01:29.241]                           version <- ns[[".package"]][["version"]]
[11:01:29.241]                           if (is.null(version)) 
[11:01:29.241]                             version <- utils::packageVersion("future")
[11:01:29.241]                         }
[11:01:29.241]                         else {
[11:01:29.241]                           version <- NULL
[11:01:29.241]                         }
[11:01:29.241]                         if (!has_future || version < "1.8.0") {
[11:01:29.241]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.241]                             "", base::R.version$version.string), 
[11:01:29.241]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.241]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.241]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.241]                               "release", "version")], collapse = " "), 
[11:01:29.241]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.241]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.241]                             info)
[11:01:29.241]                           info <- base::paste(info, collapse = "; ")
[11:01:29.241]                           if (!has_future) {
[11:01:29.241]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.241]                               info)
[11:01:29.241]                           }
[11:01:29.241]                           else {
[11:01:29.241]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.241]                               info, version)
[11:01:29.241]                           }
[11:01:29.241]                           base::stop(msg)
[11:01:29.241]                         }
[11:01:29.241]                       })
[11:01:29.241]                     }
[11:01:29.241]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.241]                     base::options(mc.cores = 1L)
[11:01:29.241]                   }
[11:01:29.241]                   ...future.strategy.old <- future::plan("list")
[11:01:29.241]                   options(future.plan = NULL)
[11:01:29.241]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.241]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.241]                 }
[11:01:29.241]                 ...future.workdir <- getwd()
[11:01:29.241]             }
[11:01:29.241]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.241]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.241]         }
[11:01:29.241]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.241]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.241]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.241]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.241]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.241]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.241]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.241]             base::names(...future.oldOptions))
[11:01:29.241]     }
[11:01:29.241]     if (FALSE) {
[11:01:29.241]     }
[11:01:29.241]     else {
[11:01:29.241]         if (TRUE) {
[11:01:29.241]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.241]                 open = "w")
[11:01:29.241]         }
[11:01:29.241]         else {
[11:01:29.241]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.241]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.241]         }
[11:01:29.241]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.241]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.241]             base::sink(type = "output", split = FALSE)
[11:01:29.241]             base::close(...future.stdout)
[11:01:29.241]         }, add = TRUE)
[11:01:29.241]     }
[11:01:29.241]     ...future.frame <- base::sys.nframe()
[11:01:29.241]     ...future.conditions <- base::list()
[11:01:29.241]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.241]     if (FALSE) {
[11:01:29.241]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.241]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.241]     }
[11:01:29.241]     ...future.result <- base::tryCatch({
[11:01:29.241]         base::withCallingHandlers({
[11:01:29.241]             ...future.value <- base::withVisible(base::local({
[11:01:29.241]                 withCallingHandlers({
[11:01:29.241]                   NULL
[11:01:29.241]                 }, immediateCondition = function(cond) {
[11:01:29.241]                   save_rds <- function (object, pathname, ...) 
[11:01:29.241]                   {
[11:01:29.241]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.241]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.241]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.241]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.241]                         fi_tmp[["mtime"]])
[11:01:29.241]                     }
[11:01:29.241]                     tryCatch({
[11:01:29.241]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.241]                     }, error = function(ex) {
[11:01:29.241]                       msg <- conditionMessage(ex)
[11:01:29.241]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.241]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.241]                         fi_tmp[["mtime"]], msg)
[11:01:29.241]                       ex$message <- msg
[11:01:29.241]                       stop(ex)
[11:01:29.241]                     })
[11:01:29.241]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.241]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.241]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.241]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.241]                       fi <- file.info(pathname)
[11:01:29.241]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.241]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.241]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.241]                         fi[["size"]], fi[["mtime"]])
[11:01:29.241]                       stop(msg)
[11:01:29.241]                     }
[11:01:29.241]                     invisible(pathname)
[11:01:29.241]                   }
[11:01:29.241]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.241]                     rootPath = tempdir()) 
[11:01:29.241]                   {
[11:01:29.241]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.241]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.241]                       tmpdir = path, fileext = ".rds")
[11:01:29.241]                     save_rds(obj, file)
[11:01:29.241]                   }
[11:01:29.241]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.241]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.241]                   {
[11:01:29.241]                     inherits <- base::inherits
[11:01:29.241]                     invokeRestart <- base::invokeRestart
[11:01:29.241]                     is.null <- base::is.null
[11:01:29.241]                     muffled <- FALSE
[11:01:29.241]                     if (inherits(cond, "message")) {
[11:01:29.241]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.241]                       if (muffled) 
[11:01:29.241]                         invokeRestart("muffleMessage")
[11:01:29.241]                     }
[11:01:29.241]                     else if (inherits(cond, "warning")) {
[11:01:29.241]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.241]                       if (muffled) 
[11:01:29.241]                         invokeRestart("muffleWarning")
[11:01:29.241]                     }
[11:01:29.241]                     else if (inherits(cond, "condition")) {
[11:01:29.241]                       if (!is.null(pattern)) {
[11:01:29.241]                         computeRestarts <- base::computeRestarts
[11:01:29.241]                         grepl <- base::grepl
[11:01:29.241]                         restarts <- computeRestarts(cond)
[11:01:29.241]                         for (restart in restarts) {
[11:01:29.241]                           name <- restart$name
[11:01:29.241]                           if (is.null(name)) 
[11:01:29.241]                             next
[11:01:29.241]                           if (!grepl(pattern, name)) 
[11:01:29.241]                             next
[11:01:29.241]                           invokeRestart(restart)
[11:01:29.241]                           muffled <- TRUE
[11:01:29.241]                           break
[11:01:29.241]                         }
[11:01:29.241]                       }
[11:01:29.241]                     }
[11:01:29.241]                     invisible(muffled)
[11:01:29.241]                   }
[11:01:29.241]                   muffleCondition(cond)
[11:01:29.241]                 })
[11:01:29.241]             }))
[11:01:29.241]             future::FutureResult(value = ...future.value$value, 
[11:01:29.241]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.241]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.241]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.241]                     ...future.globalenv.names))
[11:01:29.241]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.241]         }, condition = base::local({
[11:01:29.241]             c <- base::c
[11:01:29.241]             inherits <- base::inherits
[11:01:29.241]             invokeRestart <- base::invokeRestart
[11:01:29.241]             length <- base::length
[11:01:29.241]             list <- base::list
[11:01:29.241]             seq.int <- base::seq.int
[11:01:29.241]             signalCondition <- base::signalCondition
[11:01:29.241]             sys.calls <- base::sys.calls
[11:01:29.241]             `[[` <- base::`[[`
[11:01:29.241]             `+` <- base::`+`
[11:01:29.241]             `<<-` <- base::`<<-`
[11:01:29.241]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.241]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.241]                   3L)]
[11:01:29.241]             }
[11:01:29.241]             function(cond) {
[11:01:29.241]                 is_error <- inherits(cond, "error")
[11:01:29.241]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.241]                   NULL)
[11:01:29.241]                 if (is_error) {
[11:01:29.241]                   sessionInformation <- function() {
[11:01:29.241]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.241]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.241]                       search = base::search(), system = base::Sys.info())
[11:01:29.241]                   }
[11:01:29.241]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.241]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.241]                     cond$call), session = sessionInformation(), 
[11:01:29.241]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.241]                   signalCondition(cond)
[11:01:29.241]                 }
[11:01:29.241]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.241]                 "immediateCondition"))) {
[11:01:29.241]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.241]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.241]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.241]                   if (TRUE && !signal) {
[11:01:29.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.241]                     {
[11:01:29.241]                       inherits <- base::inherits
[11:01:29.241]                       invokeRestart <- base::invokeRestart
[11:01:29.241]                       is.null <- base::is.null
[11:01:29.241]                       muffled <- FALSE
[11:01:29.241]                       if (inherits(cond, "message")) {
[11:01:29.241]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.241]                         if (muffled) 
[11:01:29.241]                           invokeRestart("muffleMessage")
[11:01:29.241]                       }
[11:01:29.241]                       else if (inherits(cond, "warning")) {
[11:01:29.241]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.241]                         if (muffled) 
[11:01:29.241]                           invokeRestart("muffleWarning")
[11:01:29.241]                       }
[11:01:29.241]                       else if (inherits(cond, "condition")) {
[11:01:29.241]                         if (!is.null(pattern)) {
[11:01:29.241]                           computeRestarts <- base::computeRestarts
[11:01:29.241]                           grepl <- base::grepl
[11:01:29.241]                           restarts <- computeRestarts(cond)
[11:01:29.241]                           for (restart in restarts) {
[11:01:29.241]                             name <- restart$name
[11:01:29.241]                             if (is.null(name)) 
[11:01:29.241]                               next
[11:01:29.241]                             if (!grepl(pattern, name)) 
[11:01:29.241]                               next
[11:01:29.241]                             invokeRestart(restart)
[11:01:29.241]                             muffled <- TRUE
[11:01:29.241]                             break
[11:01:29.241]                           }
[11:01:29.241]                         }
[11:01:29.241]                       }
[11:01:29.241]                       invisible(muffled)
[11:01:29.241]                     }
[11:01:29.241]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.241]                   }
[11:01:29.241]                 }
[11:01:29.241]                 else {
[11:01:29.241]                   if (TRUE) {
[11:01:29.241]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.241]                     {
[11:01:29.241]                       inherits <- base::inherits
[11:01:29.241]                       invokeRestart <- base::invokeRestart
[11:01:29.241]                       is.null <- base::is.null
[11:01:29.241]                       muffled <- FALSE
[11:01:29.241]                       if (inherits(cond, "message")) {
[11:01:29.241]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.241]                         if (muffled) 
[11:01:29.241]                           invokeRestart("muffleMessage")
[11:01:29.241]                       }
[11:01:29.241]                       else if (inherits(cond, "warning")) {
[11:01:29.241]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.241]                         if (muffled) 
[11:01:29.241]                           invokeRestart("muffleWarning")
[11:01:29.241]                       }
[11:01:29.241]                       else if (inherits(cond, "condition")) {
[11:01:29.241]                         if (!is.null(pattern)) {
[11:01:29.241]                           computeRestarts <- base::computeRestarts
[11:01:29.241]                           grepl <- base::grepl
[11:01:29.241]                           restarts <- computeRestarts(cond)
[11:01:29.241]                           for (restart in restarts) {
[11:01:29.241]                             name <- restart$name
[11:01:29.241]                             if (is.null(name)) 
[11:01:29.241]                               next
[11:01:29.241]                             if (!grepl(pattern, name)) 
[11:01:29.241]                               next
[11:01:29.241]                             invokeRestart(restart)
[11:01:29.241]                             muffled <- TRUE
[11:01:29.241]                             break
[11:01:29.241]                           }
[11:01:29.241]                         }
[11:01:29.241]                       }
[11:01:29.241]                       invisible(muffled)
[11:01:29.241]                     }
[11:01:29.241]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.241]                   }
[11:01:29.241]                 }
[11:01:29.241]             }
[11:01:29.241]         }))
[11:01:29.241]     }, error = function(ex) {
[11:01:29.241]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.241]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.241]                 ...future.rng), started = ...future.startTime, 
[11:01:29.241]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.241]             version = "1.8"), class = "FutureResult")
[11:01:29.241]     }, finally = {
[11:01:29.241]         if (!identical(...future.workdir, getwd())) 
[11:01:29.241]             setwd(...future.workdir)
[11:01:29.241]         {
[11:01:29.241]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.241]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.241]             }
[11:01:29.241]             base::options(...future.oldOptions)
[11:01:29.241]             if (.Platform$OS.type == "windows") {
[11:01:29.241]                 old_names <- names(...future.oldEnvVars)
[11:01:29.241]                 envs <- base::Sys.getenv()
[11:01:29.241]                 names <- names(envs)
[11:01:29.241]                 common <- intersect(names, old_names)
[11:01:29.241]                 added <- setdiff(names, old_names)
[11:01:29.241]                 removed <- setdiff(old_names, names)
[11:01:29.241]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.241]                   envs[common]]
[11:01:29.241]                 NAMES <- toupper(changed)
[11:01:29.241]                 args <- list()
[11:01:29.241]                 for (kk in seq_along(NAMES)) {
[11:01:29.241]                   name <- changed[[kk]]
[11:01:29.241]                   NAME <- NAMES[[kk]]
[11:01:29.241]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.241]                     next
[11:01:29.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.241]                 }
[11:01:29.241]                 NAMES <- toupper(added)
[11:01:29.241]                 for (kk in seq_along(NAMES)) {
[11:01:29.241]                   name <- added[[kk]]
[11:01:29.241]                   NAME <- NAMES[[kk]]
[11:01:29.241]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.241]                     next
[11:01:29.241]                   args[[name]] <- ""
[11:01:29.241]                 }
[11:01:29.241]                 NAMES <- toupper(removed)
[11:01:29.241]                 for (kk in seq_along(NAMES)) {
[11:01:29.241]                   name <- removed[[kk]]
[11:01:29.241]                   NAME <- NAMES[[kk]]
[11:01:29.241]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.241]                     next
[11:01:29.241]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.241]                 }
[11:01:29.241]                 if (length(args) > 0) 
[11:01:29.241]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.241]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.241]             }
[11:01:29.241]             else {
[11:01:29.241]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.241]             }
[11:01:29.241]             {
[11:01:29.241]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.241]                   0L) {
[11:01:29.241]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.241]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.241]                   base::options(opts)
[11:01:29.241]                 }
[11:01:29.241]                 {
[11:01:29.241]                   {
[11:01:29.241]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.241]                     NULL
[11:01:29.241]                   }
[11:01:29.241]                   options(future.plan = NULL)
[11:01:29.241]                   if (is.na(NA_character_)) 
[11:01:29.241]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.241]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.241]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.241]                     .init = FALSE)
[11:01:29.241]                 }
[11:01:29.241]             }
[11:01:29.241]         }
[11:01:29.241]     })
[11:01:29.241]     if (TRUE) {
[11:01:29.241]         base::sink(type = "output", split = FALSE)
[11:01:29.241]         if (TRUE) {
[11:01:29.241]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.241]         }
[11:01:29.241]         else {
[11:01:29.241]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.241]         }
[11:01:29.241]         base::close(...future.stdout)
[11:01:29.241]         ...future.stdout <- NULL
[11:01:29.241]     }
[11:01:29.241]     ...future.result$conditions <- ...future.conditions
[11:01:29.241]     ...future.result$finished <- base::Sys.time()
[11:01:29.241]     ...future.result
[11:01:29.241] }
[11:01:29.244] requestCore(): workers = 2
[11:01:29.246] MulticoreFuture started
[11:01:29.246] - Launch lazy future ... done
[11:01:29.247] run() for ‘MulticoreFuture’ ... done
List of 6
[11:01:29.247] plan(): Setting new future strategy stack:
 $ a: num 1
[11:01:29.247] List of future strategies:
[11:01:29.247] 1. sequential:
[11:01:29.247]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.247]    - tweaked: FALSE
[11:01:29.247]    - call: NULL
 $ b:[11:01:29.248] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4d3d7c0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c62508b8> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
[11:01:29.250] plan(): Setting new future strategy stack:
 $ a:[11:01:29.250] List of future strategies:
[11:01:29.250] 1. multicore:
[11:01:29.250]    - args: function (..., workers = availa num bleCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.250]    - tweaked: FALSE
[11:01:29.250]    - call: plan(s1trategy)

 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4d3d7c0> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c62508b8> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=[11:01:29.254] plan(): nbrOfWorkers() = 2
List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:29.257] resolve() on list ...
[11:01:29.258]  recursive: 0
[11:01:29.258]  length: 6
[11:01:29.258]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:29.258] signalConditionsASAP(numeric, pos=1) ...
[11:01:29.258] - nx: 6
[11:01:29.258] - relay: TRUE
[11:01:29.259] - stdout: TRUE
[11:01:29.259] - signal: TRUE
[11:01:29.259] - resignal: FALSE
[11:01:29.259] - force: TRUE
[11:01:29.259] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.263] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.263]  - until=2
[11:01:29.263]  - relaying element #2
[11:01:29.264] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.264] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.264] signalConditionsASAP(NULL, pos=1) ... done
[11:01:29.264]  length: 5 (resolved future 1)
[11:01:29.265] Future #2
[11:01:29.265] result() for MulticoreFuture ...
[11:01:29.266] result() for MulticoreFuture ...
[11:01:29.267] result() for MulticoreFuture ... done
[11:01:29.267] result() for MulticoreFuture ... done
[11:01:29.267] result() for MulticoreFuture ...
[11:01:29.267] result() for MulticoreFuture ... done
[11:01:29.268] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:29.268] - nx: 6
[11:01:29.268] - relay: TRUE
[11:01:29.268] - stdout: TRUE
[11:01:29.268] - signal: TRUE
[11:01:29.268] - resignal: FALSE
[11:01:29.268] - force: TRUE
[11:01:29.269] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.269] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.269]  - until=2
[11:01:29.269]  - relaying element #2
[11:01:29.269] result() for MulticoreFuture ...
[11:01:29.269] result() for MulticoreFuture ... done
[11:01:29.269] result() for MulticoreFuture ...
[11:01:29.270] result() for MulticoreFuture ... done
[11:01:29.270] result() for MulticoreFuture ...
[11:01:29.270] result() for MulticoreFuture ... done
[11:01:29.270] result() for MulticoreFuture ...
[11:01:29.270] result() for MulticoreFuture ... done
[11:01:29.270] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.271] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.271] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:29.271]  length: 4 (resolved future 2)
[11:01:29.271] Future #3
[11:01:29.271] result() for MulticoreFuture ...
[11:01:29.272] result() for MulticoreFuture ...
[11:01:29.272] result() for MulticoreFuture ... done
[11:01:29.272] result() for MulticoreFuture ... done
[11:01:29.273] result() for MulticoreFuture ...
[11:01:29.273] result() for MulticoreFuture ... done
[11:01:29.273] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:29.273] - nx: 6
[11:01:29.273] - relay: TRUE
[11:01:29.273] - stdout: TRUE
[11:01:29.273] - signal: TRUE
[11:01:29.273] - resignal: FALSE
[11:01:29.273] - force: TRUE
[11:01:29.273] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.274] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.274]  - until=3
[11:01:29.274]  - relaying element #3
[11:01:29.274] result() for MulticoreFuture ...
[11:01:29.274] result() for MulticoreFuture ... done
[11:01:29.274] result() for MulticoreFuture ...
[11:01:29.274] result() for MulticoreFuture ... done
[11:01:29.274] result() for MulticoreFuture ...
[11:01:29.275] result() for MulticoreFuture ... done
[11:01:29.275] result() for MulticoreFuture ...
[11:01:29.275] result() for MulticoreFuture ... done
[11:01:29.275] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.275] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.275] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:29.275]  length: 3 (resolved future 3)
[11:01:29.275] signalConditionsASAP(NULL, pos=4) ...
[11:01:29.275] - nx: 6
[11:01:29.276] - relay: TRUE
[11:01:29.276] - stdout: TRUE
[11:01:29.276] - signal: TRUE
[11:01:29.276] - resignal: FALSE
[11:01:29.276] - force: TRUE
[11:01:29.276] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.276] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.276]  - until=5
[11:01:29.276]  - relaying element #5
[11:01:29.276] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.276] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.277] signalConditionsASAP(NULL, pos=4) ... done
[11:01:29.277]  length: 2 (resolved future 4)
[11:01:29.277] signalConditionsASAP(NULL, pos=5) ...
[11:01:29.277] - nx: 6
[11:01:29.277] - relay: TRUE
[11:01:29.277] - stdout: TRUE
[11:01:29.277] - signal: TRUE
[11:01:29.277] - resignal: FALSE
[11:01:29.277] - force: TRUE
[11:01:29.277] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.277] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.278]  - until=6
[11:01:29.278]  - relaying element #6
[11:01:29.278] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.278] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.278] signalConditionsASAP(NULL, pos=5) ... done
[11:01:29.278]  length: 1 (resolved future 5)
[11:01:29.278] signalConditionsASAP(numeric, pos=6) ...
[11:01:29.278] - nx: 6
[11:01:29.278] - relay: TRUE
[11:01:29.278] - stdout: TRUE
[11:01:29.279] - signal: TRUE
[11:01:29.279] - resignal: FALSE
[11:01:29.279] - force: TRUE
[11:01:29.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.279] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.279]  - until=6
[11:01:29.279] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.279] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.279] signalConditionsASAP(numeric, pos=6) ... done
[11:01:29.279]  length: 0 (resolved future 6)
[11:01:29.280] Relaying remaining futures
[11:01:29.280] signalConditionsASAP(NULL, pos=0) ...
[11:01:29.280] - nx: 6
[11:01:29.280] - relay: TRUE
[11:01:29.280] - stdout: TRUE
[11:01:29.280] - signal: TRUE
[11:01:29.280] - resignal: FALSE
[11:01:29.280] - force: TRUE
[11:01:29.280] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.280] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:29.281] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.281] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.281] signalConditionsASAP(NULL, pos=0) ... done
[11:01:29.281] resolve() on list ... DONE
[11:01:29.281] result() for MulticoreFuture ...
[11:01:29.281] result() for MulticoreFuture ... done
[11:01:29.281] result() for MulticoreFuture ...
[11:01:29.281] result() for MulticoreFuture ... done
[11:01:29.281] result() for MulticoreFuture ...
[11:01:29.281] result() for MulticoreFuture ... done
[11:01:29.282] result() for MulticoreFuture ...
[11:01:29.282] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[11:01:29.285] getGlobalsAndPackages() ...
[11:01:29.285] Searching for globals...
[11:01:29.285] 
[11:01:29.285] Searching for globals ... DONE
[11:01:29.286] - globals: [0] <none>
[11:01:29.286] getGlobalsAndPackages() ... DONE
[11:01:29.286] run() for ‘Future’ ...
[11:01:29.286] - state: ‘created’
[11:01:29.286] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.288] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.288] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.288]   - Field: ‘label’
[11:01:29.288]   - Field: ‘local’
[11:01:29.288]   - Field: ‘owner’
[11:01:29.288]   - Field: ‘envir’
[11:01:29.288]   - Field: ‘workers’
[11:01:29.289]   - Field: ‘packages’
[11:01:29.289]   - Field: ‘gc’
[11:01:29.289]   - Field: ‘job’
[11:01:29.289]   - Field: ‘conditions’
[11:01:29.289]   - Field: ‘expr’
[11:01:29.289]   - Field: ‘uuid’
[11:01:29.289]   - Field: ‘seed’
[11:01:29.289]   - Field: ‘version’
[11:01:29.289]   - Field: ‘result’
[11:01:29.289]   - Field: ‘asynchronous’
[11:01:29.289]   - Field: ‘calls’
[11:01:29.290]   - Field: ‘globals’
[11:01:29.290]   - Field: ‘stdout’
[11:01:29.290]   - Field: ‘earlySignal’
[11:01:29.290]   - Field: ‘lazy’
[11:01:29.290]   - Field: ‘state’
[11:01:29.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.290] - Launch lazy future ...
[11:01:29.290] Packages needed by the future expression (n = 0): <none>
[11:01:29.290] Packages needed by future strategies (n = 0): <none>
[11:01:29.291] {
[11:01:29.291]     {
[11:01:29.291]         {
[11:01:29.291]             ...future.startTime <- base::Sys.time()
[11:01:29.291]             {
[11:01:29.291]                 {
[11:01:29.291]                   {
[11:01:29.291]                     {
[11:01:29.291]                       base::local({
[11:01:29.291]                         has_future <- base::requireNamespace("future", 
[11:01:29.291]                           quietly = TRUE)
[11:01:29.291]                         if (has_future) {
[11:01:29.291]                           ns <- base::getNamespace("future")
[11:01:29.291]                           version <- ns[[".package"]][["version"]]
[11:01:29.291]                           if (is.null(version)) 
[11:01:29.291]                             version <- utils::packageVersion("future")
[11:01:29.291]                         }
[11:01:29.291]                         else {
[11:01:29.291]                           version <- NULL
[11:01:29.291]                         }
[11:01:29.291]                         if (!has_future || version < "1.8.0") {
[11:01:29.291]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.291]                             "", base::R.version$version.string), 
[11:01:29.291]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.291]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.291]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.291]                               "release", "version")], collapse = " "), 
[11:01:29.291]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.291]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.291]                             info)
[11:01:29.291]                           info <- base::paste(info, collapse = "; ")
[11:01:29.291]                           if (!has_future) {
[11:01:29.291]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.291]                               info)
[11:01:29.291]                           }
[11:01:29.291]                           else {
[11:01:29.291]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.291]                               info, version)
[11:01:29.291]                           }
[11:01:29.291]                           base::stop(msg)
[11:01:29.291]                         }
[11:01:29.291]                       })
[11:01:29.291]                     }
[11:01:29.291]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.291]                     base::options(mc.cores = 1L)
[11:01:29.291]                   }
[11:01:29.291]                   ...future.strategy.old <- future::plan("list")
[11:01:29.291]                   options(future.plan = NULL)
[11:01:29.291]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.291]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.291]                 }
[11:01:29.291]                 ...future.workdir <- getwd()
[11:01:29.291]             }
[11:01:29.291]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.291]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.291]         }
[11:01:29.291]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.291]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.291]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.291]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.291]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.291]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.291]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.291]             base::names(...future.oldOptions))
[11:01:29.291]     }
[11:01:29.291]     if (FALSE) {
[11:01:29.291]     }
[11:01:29.291]     else {
[11:01:29.291]         if (TRUE) {
[11:01:29.291]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.291]                 open = "w")
[11:01:29.291]         }
[11:01:29.291]         else {
[11:01:29.291]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.291]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.291]         }
[11:01:29.291]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.291]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.291]             base::sink(type = "output", split = FALSE)
[11:01:29.291]             base::close(...future.stdout)
[11:01:29.291]         }, add = TRUE)
[11:01:29.291]     }
[11:01:29.291]     ...future.frame <- base::sys.nframe()
[11:01:29.291]     ...future.conditions <- base::list()
[11:01:29.291]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.291]     if (FALSE) {
[11:01:29.291]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.291]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.291]     }
[11:01:29.291]     ...future.result <- base::tryCatch({
[11:01:29.291]         base::withCallingHandlers({
[11:01:29.291]             ...future.value <- base::withVisible(base::local({
[11:01:29.291]                 withCallingHandlers({
[11:01:29.291]                   2
[11:01:29.291]                 }, immediateCondition = function(cond) {
[11:01:29.291]                   save_rds <- function (object, pathname, ...) 
[11:01:29.291]                   {
[11:01:29.291]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.291]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.291]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.291]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.291]                         fi_tmp[["mtime"]])
[11:01:29.291]                     }
[11:01:29.291]                     tryCatch({
[11:01:29.291]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.291]                     }, error = function(ex) {
[11:01:29.291]                       msg <- conditionMessage(ex)
[11:01:29.291]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.291]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.291]                         fi_tmp[["mtime"]], msg)
[11:01:29.291]                       ex$message <- msg
[11:01:29.291]                       stop(ex)
[11:01:29.291]                     })
[11:01:29.291]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.291]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.291]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.291]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.291]                       fi <- file.info(pathname)
[11:01:29.291]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.291]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.291]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.291]                         fi[["size"]], fi[["mtime"]])
[11:01:29.291]                       stop(msg)
[11:01:29.291]                     }
[11:01:29.291]                     invisible(pathname)
[11:01:29.291]                   }
[11:01:29.291]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.291]                     rootPath = tempdir()) 
[11:01:29.291]                   {
[11:01:29.291]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.291]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.291]                       tmpdir = path, fileext = ".rds")
[11:01:29.291]                     save_rds(obj, file)
[11:01:29.291]                   }
[11:01:29.291]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.291]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.291]                   {
[11:01:29.291]                     inherits <- base::inherits
[11:01:29.291]                     invokeRestart <- base::invokeRestart
[11:01:29.291]                     is.null <- base::is.null
[11:01:29.291]                     muffled <- FALSE
[11:01:29.291]                     if (inherits(cond, "message")) {
[11:01:29.291]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.291]                       if (muffled) 
[11:01:29.291]                         invokeRestart("muffleMessage")
[11:01:29.291]                     }
[11:01:29.291]                     else if (inherits(cond, "warning")) {
[11:01:29.291]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.291]                       if (muffled) 
[11:01:29.291]                         invokeRestart("muffleWarning")
[11:01:29.291]                     }
[11:01:29.291]                     else if (inherits(cond, "condition")) {
[11:01:29.291]                       if (!is.null(pattern)) {
[11:01:29.291]                         computeRestarts <- base::computeRestarts
[11:01:29.291]                         grepl <- base::grepl
[11:01:29.291]                         restarts <- computeRestarts(cond)
[11:01:29.291]                         for (restart in restarts) {
[11:01:29.291]                           name <- restart$name
[11:01:29.291]                           if (is.null(name)) 
[11:01:29.291]                             next
[11:01:29.291]                           if (!grepl(pattern, name)) 
[11:01:29.291]                             next
[11:01:29.291]                           invokeRestart(restart)
[11:01:29.291]                           muffled <- TRUE
[11:01:29.291]                           break
[11:01:29.291]                         }
[11:01:29.291]                       }
[11:01:29.291]                     }
[11:01:29.291]                     invisible(muffled)
[11:01:29.291]                   }
[11:01:29.291]                   muffleCondition(cond)
[11:01:29.291]                 })
[11:01:29.291]             }))
[11:01:29.291]             future::FutureResult(value = ...future.value$value, 
[11:01:29.291]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.291]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.291]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.291]                     ...future.globalenv.names))
[11:01:29.291]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.291]         }, condition = base::local({
[11:01:29.291]             c <- base::c
[11:01:29.291]             inherits <- base::inherits
[11:01:29.291]             invokeRestart <- base::invokeRestart
[11:01:29.291]             length <- base::length
[11:01:29.291]             list <- base::list
[11:01:29.291]             seq.int <- base::seq.int
[11:01:29.291]             signalCondition <- base::signalCondition
[11:01:29.291]             sys.calls <- base::sys.calls
[11:01:29.291]             `[[` <- base::`[[`
[11:01:29.291]             `+` <- base::`+`
[11:01:29.291]             `<<-` <- base::`<<-`
[11:01:29.291]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.291]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.291]                   3L)]
[11:01:29.291]             }
[11:01:29.291]             function(cond) {
[11:01:29.291]                 is_error <- inherits(cond, "error")
[11:01:29.291]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.291]                   NULL)
[11:01:29.291]                 if (is_error) {
[11:01:29.291]                   sessionInformation <- function() {
[11:01:29.291]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.291]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.291]                       search = base::search(), system = base::Sys.info())
[11:01:29.291]                   }
[11:01:29.291]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.291]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.291]                     cond$call), session = sessionInformation(), 
[11:01:29.291]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.291]                   signalCondition(cond)
[11:01:29.291]                 }
[11:01:29.291]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.291]                 "immediateCondition"))) {
[11:01:29.291]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.291]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.291]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.291]                   if (TRUE && !signal) {
[11:01:29.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.291]                     {
[11:01:29.291]                       inherits <- base::inherits
[11:01:29.291]                       invokeRestart <- base::invokeRestart
[11:01:29.291]                       is.null <- base::is.null
[11:01:29.291]                       muffled <- FALSE
[11:01:29.291]                       if (inherits(cond, "message")) {
[11:01:29.291]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.291]                         if (muffled) 
[11:01:29.291]                           invokeRestart("muffleMessage")
[11:01:29.291]                       }
[11:01:29.291]                       else if (inherits(cond, "warning")) {
[11:01:29.291]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.291]                         if (muffled) 
[11:01:29.291]                           invokeRestart("muffleWarning")
[11:01:29.291]                       }
[11:01:29.291]                       else if (inherits(cond, "condition")) {
[11:01:29.291]                         if (!is.null(pattern)) {
[11:01:29.291]                           computeRestarts <- base::computeRestarts
[11:01:29.291]                           grepl <- base::grepl
[11:01:29.291]                           restarts <- computeRestarts(cond)
[11:01:29.291]                           for (restart in restarts) {
[11:01:29.291]                             name <- restart$name
[11:01:29.291]                             if (is.null(name)) 
[11:01:29.291]                               next
[11:01:29.291]                             if (!grepl(pattern, name)) 
[11:01:29.291]                               next
[11:01:29.291]                             invokeRestart(restart)
[11:01:29.291]                             muffled <- TRUE
[11:01:29.291]                             break
[11:01:29.291]                           }
[11:01:29.291]                         }
[11:01:29.291]                       }
[11:01:29.291]                       invisible(muffled)
[11:01:29.291]                     }
[11:01:29.291]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.291]                   }
[11:01:29.291]                 }
[11:01:29.291]                 else {
[11:01:29.291]                   if (TRUE) {
[11:01:29.291]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.291]                     {
[11:01:29.291]                       inherits <- base::inherits
[11:01:29.291]                       invokeRestart <- base::invokeRestart
[11:01:29.291]                       is.null <- base::is.null
[11:01:29.291]                       muffled <- FALSE
[11:01:29.291]                       if (inherits(cond, "message")) {
[11:01:29.291]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.291]                         if (muffled) 
[11:01:29.291]                           invokeRestart("muffleMessage")
[11:01:29.291]                       }
[11:01:29.291]                       else if (inherits(cond, "warning")) {
[11:01:29.291]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.291]                         if (muffled) 
[11:01:29.291]                           invokeRestart("muffleWarning")
[11:01:29.291]                       }
[11:01:29.291]                       else if (inherits(cond, "condition")) {
[11:01:29.291]                         if (!is.null(pattern)) {
[11:01:29.291]                           computeRestarts <- base::computeRestarts
[11:01:29.291]                           grepl <- base::grepl
[11:01:29.291]                           restarts <- computeRestarts(cond)
[11:01:29.291]                           for (restart in restarts) {
[11:01:29.291]                             name <- restart$name
[11:01:29.291]                             if (is.null(name)) 
[11:01:29.291]                               next
[11:01:29.291]                             if (!grepl(pattern, name)) 
[11:01:29.291]                               next
[11:01:29.291]                             invokeRestart(restart)
[11:01:29.291]                             muffled <- TRUE
[11:01:29.291]                             break
[11:01:29.291]                           }
[11:01:29.291]                         }
[11:01:29.291]                       }
[11:01:29.291]                       invisible(muffled)
[11:01:29.291]                     }
[11:01:29.291]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.291]                   }
[11:01:29.291]                 }
[11:01:29.291]             }
[11:01:29.291]         }))
[11:01:29.291]     }, error = function(ex) {
[11:01:29.291]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.291]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.291]                 ...future.rng), started = ...future.startTime, 
[11:01:29.291]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.291]             version = "1.8"), class = "FutureResult")
[11:01:29.291]     }, finally = {
[11:01:29.291]         if (!identical(...future.workdir, getwd())) 
[11:01:29.291]             setwd(...future.workdir)
[11:01:29.291]         {
[11:01:29.291]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.291]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.291]             }
[11:01:29.291]             base::options(...future.oldOptions)
[11:01:29.291]             if (.Platform$OS.type == "windows") {
[11:01:29.291]                 old_names <- names(...future.oldEnvVars)
[11:01:29.291]                 envs <- base::Sys.getenv()
[11:01:29.291]                 names <- names(envs)
[11:01:29.291]                 common <- intersect(names, old_names)
[11:01:29.291]                 added <- setdiff(names, old_names)
[11:01:29.291]                 removed <- setdiff(old_names, names)
[11:01:29.291]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.291]                   envs[common]]
[11:01:29.291]                 NAMES <- toupper(changed)
[11:01:29.291]                 args <- list()
[11:01:29.291]                 for (kk in seq_along(NAMES)) {
[11:01:29.291]                   name <- changed[[kk]]
[11:01:29.291]                   NAME <- NAMES[[kk]]
[11:01:29.291]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.291]                     next
[11:01:29.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.291]                 }
[11:01:29.291]                 NAMES <- toupper(added)
[11:01:29.291]                 for (kk in seq_along(NAMES)) {
[11:01:29.291]                   name <- added[[kk]]
[11:01:29.291]                   NAME <- NAMES[[kk]]
[11:01:29.291]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.291]                     next
[11:01:29.291]                   args[[name]] <- ""
[11:01:29.291]                 }
[11:01:29.291]                 NAMES <- toupper(removed)
[11:01:29.291]                 for (kk in seq_along(NAMES)) {
[11:01:29.291]                   name <- removed[[kk]]
[11:01:29.291]                   NAME <- NAMES[[kk]]
[11:01:29.291]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.291]                     next
[11:01:29.291]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.291]                 }
[11:01:29.291]                 if (length(args) > 0) 
[11:01:29.291]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.291]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.291]             }
[11:01:29.291]             else {
[11:01:29.291]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.291]             }
[11:01:29.291]             {
[11:01:29.291]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.291]                   0L) {
[11:01:29.291]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.291]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.291]                   base::options(opts)
[11:01:29.291]                 }
[11:01:29.291]                 {
[11:01:29.291]                   {
[11:01:29.291]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.291]                     NULL
[11:01:29.291]                   }
[11:01:29.291]                   options(future.plan = NULL)
[11:01:29.291]                   if (is.na(NA_character_)) 
[11:01:29.291]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.291]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.291]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.291]                     .init = FALSE)
[11:01:29.291]                 }
[11:01:29.291]             }
[11:01:29.291]         }
[11:01:29.291]     })
[11:01:29.291]     if (TRUE) {
[11:01:29.291]         base::sink(type = "output", split = FALSE)
[11:01:29.291]         if (TRUE) {
[11:01:29.291]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.291]         }
[11:01:29.291]         else {
[11:01:29.291]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.291]         }
[11:01:29.291]         base::close(...future.stdout)
[11:01:29.291]         ...future.stdout <- NULL
[11:01:29.291]     }
[11:01:29.291]     ...future.result$conditions <- ...future.conditions
[11:01:29.291]     ...future.result$finished <- base::Sys.time()
[11:01:29.291]     ...future.result
[11:01:29.291] }
[11:01:29.293] requestCore(): workers = 2
[11:01:29.295] MulticoreFuture started
[11:01:29.295] - Launch lazy future ... done
[11:01:29.296] run() for ‘MulticoreFuture’ ... done
[11:01:29.296] getGlobalsAndPackages() ...
[11:01:29.296] Searching for globals...
[11:01:29.296] plan(): Setting new future strategy stack:
[11:01:29.297] 
[11:01:29.296] List of future strategies:
[11:01:29.296] 1. sequential:
[11:01:29.296]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.296]    - tweaked: FALSE
[11:01:29.296]    - call: NULL
[11:01:29.297] Searching for globals ... DONE
[11:01:29.297] plan(): nbrOfWorkers() = 1
[11:01:29.301] - globals: [0] <none>
[11:01:29.301] getGlobalsAndPackages() ... DONE
[11:01:29.302] run() for ‘Future’ ...
[11:01:29.302] plan(): Setting new future strategy stack:
[11:01:29.302] - state: ‘created’
[11:01:29.302] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.302] List of future strategies:
[11:01:29.302] 1. multicore:
[11:01:29.302]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.302]    - tweaked: FALSE
[11:01:29.302]    - call: plan(strategy)
[11:01:29.306] plan(): nbrOfWorkers() = 2
[11:01:29.306] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.307] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.307]   - Field: ‘label’
[11:01:29.307]   - Field: ‘local’
[11:01:29.307]   - Field: ‘owner’
[11:01:29.307]   - Field: ‘envir’
[11:01:29.308]   - Field: ‘workers’
[11:01:29.308]   - Field: ‘packages’
[11:01:29.308]   - Field: ‘gc’
[11:01:29.308]   - Field: ‘job’
[11:01:29.308]   - Field: ‘conditions’
[11:01:29.308]   - Field: ‘expr’
[11:01:29.309]   - Field: ‘uuid’
[11:01:29.309]   - Field: ‘seed’
[11:01:29.309]   - Field: ‘version’
[11:01:29.309]   - Field: ‘result’
[11:01:29.309]   - Field: ‘asynchronous’
[11:01:29.309]   - Field: ‘calls’
[11:01:29.310]   - Field: ‘globals’
[11:01:29.310]   - Field: ‘stdout’
[11:01:29.310]   - Field: ‘earlySignal’
[11:01:29.310]   - Field: ‘lazy’
[11:01:29.310]   - Field: ‘state’
[11:01:29.310] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.311] - Launch lazy future ...
[11:01:29.311] Packages needed by the future expression (n = 0): <none>
[11:01:29.311] Packages needed by future strategies (n = 0): <none>
[11:01:29.312] {
[11:01:29.312]     {
[11:01:29.312]         {
[11:01:29.312]             ...future.startTime <- base::Sys.time()
[11:01:29.312]             {
[11:01:29.312]                 {
[11:01:29.312]                   {
[11:01:29.312]                     {
[11:01:29.312]                       base::local({
[11:01:29.312]                         has_future <- base::requireNamespace("future", 
[11:01:29.312]                           quietly = TRUE)
[11:01:29.312]                         if (has_future) {
[11:01:29.312]                           ns <- base::getNamespace("future")
[11:01:29.312]                           version <- ns[[".package"]][["version"]]
[11:01:29.312]                           if (is.null(version)) 
[11:01:29.312]                             version <- utils::packageVersion("future")
[11:01:29.312]                         }
[11:01:29.312]                         else {
[11:01:29.312]                           version <- NULL
[11:01:29.312]                         }
[11:01:29.312]                         if (!has_future || version < "1.8.0") {
[11:01:29.312]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.312]                             "", base::R.version$version.string), 
[11:01:29.312]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.312]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.312]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.312]                               "release", "version")], collapse = " "), 
[11:01:29.312]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.312]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.312]                             info)
[11:01:29.312]                           info <- base::paste(info, collapse = "; ")
[11:01:29.312]                           if (!has_future) {
[11:01:29.312]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.312]                               info)
[11:01:29.312]                           }
[11:01:29.312]                           else {
[11:01:29.312]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.312]                               info, version)
[11:01:29.312]                           }
[11:01:29.312]                           base::stop(msg)
[11:01:29.312]                         }
[11:01:29.312]                       })
[11:01:29.312]                     }
[11:01:29.312]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.312]                     base::options(mc.cores = 1L)
[11:01:29.312]                   }
[11:01:29.312]                   ...future.strategy.old <- future::plan("list")
[11:01:29.312]                   options(future.plan = NULL)
[11:01:29.312]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.312]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.312]                 }
[11:01:29.312]                 ...future.workdir <- getwd()
[11:01:29.312]             }
[11:01:29.312]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.312]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.312]         }
[11:01:29.312]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.312]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.312]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.312]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.312]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.312]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.312]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.312]             base::names(...future.oldOptions))
[11:01:29.312]     }
[11:01:29.312]     if (FALSE) {
[11:01:29.312]     }
[11:01:29.312]     else {
[11:01:29.312]         if (TRUE) {
[11:01:29.312]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.312]                 open = "w")
[11:01:29.312]         }
[11:01:29.312]         else {
[11:01:29.312]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.312]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.312]         }
[11:01:29.312]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.312]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.312]             base::sink(type = "output", split = FALSE)
[11:01:29.312]             base::close(...future.stdout)
[11:01:29.312]         }, add = TRUE)
[11:01:29.312]     }
[11:01:29.312]     ...future.frame <- base::sys.nframe()
[11:01:29.312]     ...future.conditions <- base::list()
[11:01:29.312]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.312]     if (FALSE) {
[11:01:29.312]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.312]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.312]     }
[11:01:29.312]     ...future.result <- base::tryCatch({
[11:01:29.312]         base::withCallingHandlers({
[11:01:29.312]             ...future.value <- base::withVisible(base::local({
[11:01:29.312]                 withCallingHandlers({
[11:01:29.312]                   NULL
[11:01:29.312]                 }, immediateCondition = function(cond) {
[11:01:29.312]                   save_rds <- function (object, pathname, ...) 
[11:01:29.312]                   {
[11:01:29.312]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.312]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.312]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.312]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.312]                         fi_tmp[["mtime"]])
[11:01:29.312]                     }
[11:01:29.312]                     tryCatch({
[11:01:29.312]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.312]                     }, error = function(ex) {
[11:01:29.312]                       msg <- conditionMessage(ex)
[11:01:29.312]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.312]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.312]                         fi_tmp[["mtime"]], msg)
[11:01:29.312]                       ex$message <- msg
[11:01:29.312]                       stop(ex)
[11:01:29.312]                     })
[11:01:29.312]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.312]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.312]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.312]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.312]                       fi <- file.info(pathname)
[11:01:29.312]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.312]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.312]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.312]                         fi[["size"]], fi[["mtime"]])
[11:01:29.312]                       stop(msg)
[11:01:29.312]                     }
[11:01:29.312]                     invisible(pathname)
[11:01:29.312]                   }
[11:01:29.312]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.312]                     rootPath = tempdir()) 
[11:01:29.312]                   {
[11:01:29.312]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.312]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.312]                       tmpdir = path, fileext = ".rds")
[11:01:29.312]                     save_rds(obj, file)
[11:01:29.312]                   }
[11:01:29.312]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.312]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.312]                   {
[11:01:29.312]                     inherits <- base::inherits
[11:01:29.312]                     invokeRestart <- base::invokeRestart
[11:01:29.312]                     is.null <- base::is.null
[11:01:29.312]                     muffled <- FALSE
[11:01:29.312]                     if (inherits(cond, "message")) {
[11:01:29.312]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.312]                       if (muffled) 
[11:01:29.312]                         invokeRestart("muffleMessage")
[11:01:29.312]                     }
[11:01:29.312]                     else if (inherits(cond, "warning")) {
[11:01:29.312]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.312]                       if (muffled) 
[11:01:29.312]                         invokeRestart("muffleWarning")
[11:01:29.312]                     }
[11:01:29.312]                     else if (inherits(cond, "condition")) {
[11:01:29.312]                       if (!is.null(pattern)) {
[11:01:29.312]                         computeRestarts <- base::computeRestarts
[11:01:29.312]                         grepl <- base::grepl
[11:01:29.312]                         restarts <- computeRestarts(cond)
[11:01:29.312]                         for (restart in restarts) {
[11:01:29.312]                           name <- restart$name
[11:01:29.312]                           if (is.null(name)) 
[11:01:29.312]                             next
[11:01:29.312]                           if (!grepl(pattern, name)) 
[11:01:29.312]                             next
[11:01:29.312]                           invokeRestart(restart)
[11:01:29.312]                           muffled <- TRUE
[11:01:29.312]                           break
[11:01:29.312]                         }
[11:01:29.312]                       }
[11:01:29.312]                     }
[11:01:29.312]                     invisible(muffled)
[11:01:29.312]                   }
[11:01:29.312]                   muffleCondition(cond)
[11:01:29.312]                 })
[11:01:29.312]             }))
[11:01:29.312]             future::FutureResult(value = ...future.value$value, 
[11:01:29.312]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.312]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.312]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.312]                     ...future.globalenv.names))
[11:01:29.312]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.312]         }, condition = base::local({
[11:01:29.312]             c <- base::c
[11:01:29.312]             inherits <- base::inherits
[11:01:29.312]             invokeRestart <- base::invokeRestart
[11:01:29.312]             length <- base::length
[11:01:29.312]             list <- base::list
[11:01:29.312]             seq.int <- base::seq.int
[11:01:29.312]             signalCondition <- base::signalCondition
[11:01:29.312]             sys.calls <- base::sys.calls
[11:01:29.312]             `[[` <- base::`[[`
[11:01:29.312]             `+` <- base::`+`
[11:01:29.312]             `<<-` <- base::`<<-`
[11:01:29.312]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.312]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.312]                   3L)]
[11:01:29.312]             }
[11:01:29.312]             function(cond) {
[11:01:29.312]                 is_error <- inherits(cond, "error")
[11:01:29.312]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.312]                   NULL)
[11:01:29.312]                 if (is_error) {
[11:01:29.312]                   sessionInformation <- function() {
[11:01:29.312]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.312]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.312]                       search = base::search(), system = base::Sys.info())
[11:01:29.312]                   }
[11:01:29.312]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.312]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.312]                     cond$call), session = sessionInformation(), 
[11:01:29.312]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.312]                   signalCondition(cond)
[11:01:29.312]                 }
[11:01:29.312]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.312]                 "immediateCondition"))) {
[11:01:29.312]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.312]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.312]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.312]                   if (TRUE && !signal) {
[11:01:29.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.312]                     {
[11:01:29.312]                       inherits <- base::inherits
[11:01:29.312]                       invokeRestart <- base::invokeRestart
[11:01:29.312]                       is.null <- base::is.null
[11:01:29.312]                       muffled <- FALSE
[11:01:29.312]                       if (inherits(cond, "message")) {
[11:01:29.312]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.312]                         if (muffled) 
[11:01:29.312]                           invokeRestart("muffleMessage")
[11:01:29.312]                       }
[11:01:29.312]                       else if (inherits(cond, "warning")) {
[11:01:29.312]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.312]                         if (muffled) 
[11:01:29.312]                           invokeRestart("muffleWarning")
[11:01:29.312]                       }
[11:01:29.312]                       else if (inherits(cond, "condition")) {
[11:01:29.312]                         if (!is.null(pattern)) {
[11:01:29.312]                           computeRestarts <- base::computeRestarts
[11:01:29.312]                           grepl <- base::grepl
[11:01:29.312]                           restarts <- computeRestarts(cond)
[11:01:29.312]                           for (restart in restarts) {
[11:01:29.312]                             name <- restart$name
[11:01:29.312]                             if (is.null(name)) 
[11:01:29.312]                               next
[11:01:29.312]                             if (!grepl(pattern, name)) 
[11:01:29.312]                               next
[11:01:29.312]                             invokeRestart(restart)
[11:01:29.312]                             muffled <- TRUE
[11:01:29.312]                             break
[11:01:29.312]                           }
[11:01:29.312]                         }
[11:01:29.312]                       }
[11:01:29.312]                       invisible(muffled)
[11:01:29.312]                     }
[11:01:29.312]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.312]                   }
[11:01:29.312]                 }
[11:01:29.312]                 else {
[11:01:29.312]                   if (TRUE) {
[11:01:29.312]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.312]                     {
[11:01:29.312]                       inherits <- base::inherits
[11:01:29.312]                       invokeRestart <- base::invokeRestart
[11:01:29.312]                       is.null <- base::is.null
[11:01:29.312]                       muffled <- FALSE
[11:01:29.312]                       if (inherits(cond, "message")) {
[11:01:29.312]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.312]                         if (muffled) 
[11:01:29.312]                           invokeRestart("muffleMessage")
[11:01:29.312]                       }
[11:01:29.312]                       else if (inherits(cond, "warning")) {
[11:01:29.312]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.312]                         if (muffled) 
[11:01:29.312]                           invokeRestart("muffleWarning")
[11:01:29.312]                       }
[11:01:29.312]                       else if (inherits(cond, "condition")) {
[11:01:29.312]                         if (!is.null(pattern)) {
[11:01:29.312]                           computeRestarts <- base::computeRestarts
[11:01:29.312]                           grepl <- base::grepl
[11:01:29.312]                           restarts <- computeRestarts(cond)
[11:01:29.312]                           for (restart in restarts) {
[11:01:29.312]                             name <- restart$name
[11:01:29.312]                             if (is.null(name)) 
[11:01:29.312]                               next
[11:01:29.312]                             if (!grepl(pattern, name)) 
[11:01:29.312]                               next
[11:01:29.312]                             invokeRestart(restart)
[11:01:29.312]                             muffled <- TRUE
[11:01:29.312]                             break
[11:01:29.312]                           }
[11:01:29.312]                         }
[11:01:29.312]                       }
[11:01:29.312]                       invisible(muffled)
[11:01:29.312]                     }
[11:01:29.312]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.312]                   }
[11:01:29.312]                 }
[11:01:29.312]             }
[11:01:29.312]         }))
[11:01:29.312]     }, error = function(ex) {
[11:01:29.312]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.312]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.312]                 ...future.rng), started = ...future.startTime, 
[11:01:29.312]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.312]             version = "1.8"), class = "FutureResult")
[11:01:29.312]     }, finally = {
[11:01:29.312]         if (!identical(...future.workdir, getwd())) 
[11:01:29.312]             setwd(...future.workdir)
[11:01:29.312]         {
[11:01:29.312]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.312]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.312]             }
[11:01:29.312]             base::options(...future.oldOptions)
[11:01:29.312]             if (.Platform$OS.type == "windows") {
[11:01:29.312]                 old_names <- names(...future.oldEnvVars)
[11:01:29.312]                 envs <- base::Sys.getenv()
[11:01:29.312]                 names <- names(envs)
[11:01:29.312]                 common <- intersect(names, old_names)
[11:01:29.312]                 added <- setdiff(names, old_names)
[11:01:29.312]                 removed <- setdiff(old_names, names)
[11:01:29.312]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.312]                   envs[common]]
[11:01:29.312]                 NAMES <- toupper(changed)
[11:01:29.312]                 args <- list()
[11:01:29.312]                 for (kk in seq_along(NAMES)) {
[11:01:29.312]                   name <- changed[[kk]]
[11:01:29.312]                   NAME <- NAMES[[kk]]
[11:01:29.312]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.312]                     next
[11:01:29.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.312]                 }
[11:01:29.312]                 NAMES <- toupper(added)
[11:01:29.312]                 for (kk in seq_along(NAMES)) {
[11:01:29.312]                   name <- added[[kk]]
[11:01:29.312]                   NAME <- NAMES[[kk]]
[11:01:29.312]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.312]                     next
[11:01:29.312]                   args[[name]] <- ""
[11:01:29.312]                 }
[11:01:29.312]                 NAMES <- toupper(removed)
[11:01:29.312]                 for (kk in seq_along(NAMES)) {
[11:01:29.312]                   name <- removed[[kk]]
[11:01:29.312]                   NAME <- NAMES[[kk]]
[11:01:29.312]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.312]                     next
[11:01:29.312]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.312]                 }
[11:01:29.312]                 if (length(args) > 0) 
[11:01:29.312]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.312]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.312]             }
[11:01:29.312]             else {
[11:01:29.312]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.312]             }
[11:01:29.312]             {
[11:01:29.312]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.312]                   0L) {
[11:01:29.312]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.312]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.312]                   base::options(opts)
[11:01:29.312]                 }
[11:01:29.312]                 {
[11:01:29.312]                   {
[11:01:29.312]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.312]                     NULL
[11:01:29.312]                   }
[11:01:29.312]                   options(future.plan = NULL)
[11:01:29.312]                   if (is.na(NA_character_)) 
[11:01:29.312]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.312]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.312]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.312]                     .init = FALSE)
[11:01:29.312]                 }
[11:01:29.312]             }
[11:01:29.312]         }
[11:01:29.312]     })
[11:01:29.312]     if (TRUE) {
[11:01:29.312]         base::sink(type = "output", split = FALSE)
[11:01:29.312]         if (TRUE) {
[11:01:29.312]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.312]         }
[11:01:29.312]         else {
[11:01:29.312]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.312]         }
[11:01:29.312]         base::close(...future.stdout)
[11:01:29.312]         ...future.stdout <- NULL
[11:01:29.312]     }
[11:01:29.312]     ...future.result$conditions <- ...future.conditions
[11:01:29.312]     ...future.result$finished <- base::Sys.time()
[11:01:29.312]     ...future.result
[11:01:29.312] }
[11:01:29.315] requestCore(): workers = 2
[11:01:29.317] MulticoreFuture started
[11:01:29.317] - Launch lazy future ... done
[11:01:29.317] run() for ‘MulticoreFuture’ ... done
List of 6
[11:01:29.318] plan(): Setting new future strategy stack:
 $ a: num 1
[11:01:29.318] List of future strategies:
[11:01:29.318] 1. sequential:
[11:01:29.318]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.318]    - tweaked: FALSE
[11:01:29.318]    - call: NULL
 $ b:[11:01:29.319] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c6846880> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c5a19e98> 
 $  : NULL
 $  : NULL
 $  :[11:01:29.321] plan(): Setting new future strategy stack:
 num 6
List of 6
 $ a:[11:01:29.322] List of future strategies:
[11:01:29.322] 1. multicore:
[11:01:29.322]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.322]    - tweaked: FALSE
[11:01:29.322]    - call: plan(strategy)
 num 1
 $ b:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c6846880> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c5a19e98> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")=[11:01:29.324] plan(): nbrOfWorkers() = 2
 int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:29.329] resolve() on list ...
[11:01:29.329]  recursive: 0
[11:01:29.329]  length: 6
[11:01:29.330]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:29.330] signalConditionsASAP(numeric, pos=1) ...
[11:01:29.330] - nx: 6
[11:01:29.330] - relay: TRUE
[11:01:29.330] - stdout: TRUE
[11:01:29.330] - signal: TRUE
[11:01:29.330] - resignal: FALSE
[11:01:29.330] - force: TRUE
[11:01:29.331] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.331] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.331]  - until=2
[11:01:29.331]  - relaying element #2
[11:01:29.331] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.331] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.331] signalConditionsASAP(NULL, pos=1) ... done
[11:01:29.332]  length: 5 (resolved future 1)
[11:01:29.332] Future #2
[11:01:29.332] result() for MulticoreFuture ...
[11:01:29.333] result() for MulticoreFuture ...
[11:01:29.333] result() for MulticoreFuture ... done
[11:01:29.333] result() for MulticoreFuture ... done
[11:01:29.333] result() for MulticoreFuture ...
[11:01:29.333] result() for MulticoreFuture ... done
[11:01:29.334] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:29.334] - nx: 6
[11:01:29.334] - relay: TRUE
[11:01:29.334] - stdout: TRUE
[11:01:29.334] - signal: TRUE
[11:01:29.334] - resignal: FALSE
[11:01:29.334] - force: TRUE
[11:01:29.334] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.335] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.335]  - until=2
[11:01:29.335]  - relaying element #2
[11:01:29.335] result() for MulticoreFuture ...
[11:01:29.335] result() for MulticoreFuture ... done
[11:01:29.335] result() for MulticoreFuture ...
[11:01:29.335] result() for MulticoreFuture ... done
[11:01:29.336] result() for MulticoreFuture ...
[11:01:29.336] result() for MulticoreFuture ... done
[11:01:29.336] result() for MulticoreFuture ...
[11:01:29.336] result() for MulticoreFuture ... done
[11:01:29.336] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.336] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.336] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:29.337]  length: 4 (resolved future 2)
[11:01:29.337] Future #3
[11:01:29.337] result() for MulticoreFuture ...
[11:01:29.338] result() for MulticoreFuture ...
[11:01:29.338] result() for MulticoreFuture ... done
[11:01:29.338] result() for MulticoreFuture ... done
[11:01:29.338] result() for MulticoreFuture ...
[11:01:29.338] result() for MulticoreFuture ... done
[11:01:29.338] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:29.338] - nx: 6
[11:01:29.339] - relay: TRUE
[11:01:29.339] - stdout: TRUE
[11:01:29.339] - signal: TRUE
[11:01:29.339] - resignal: FALSE
[11:01:29.339] - force: TRUE
[11:01:29.339] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.339] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.339]  - until=3
[11:01:29.340]  - relaying element #3
[11:01:29.340] result() for MulticoreFuture ...
[11:01:29.340] result() for MulticoreFuture ... done
[11:01:29.340] result() for MulticoreFuture ...
[11:01:29.340] result() for MulticoreFuture ... done
[11:01:29.340] result() for MulticoreFuture ...
[11:01:29.340] result() for MulticoreFuture ... done
[11:01:29.341] result() for MulticoreFuture ...
[11:01:29.341] result() for MulticoreFuture ... done
[11:01:29.341] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.341] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.341] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:29.341]  length: 3 (resolved future 3)
[11:01:29.341] signalConditionsASAP(NULL, pos=4) ...
[11:01:29.341] - nx: 6
[11:01:29.341] - relay: TRUE
[11:01:29.341] - stdout: TRUE
[11:01:29.342] - signal: TRUE
[11:01:29.342] - resignal: FALSE
[11:01:29.342] - force: TRUE
[11:01:29.342] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.342] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.342]  - until=5
[11:01:29.342]  - relaying element #5
[11:01:29.342] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.342] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.343] signalConditionsASAP(NULL, pos=4) ... done
[11:01:29.343]  length: 2 (resolved future 4)
[11:01:29.343] signalConditionsASAP(NULL, pos=5) ...
[11:01:29.343] - nx: 6
[11:01:29.343] - relay: TRUE
[11:01:29.343] - stdout: TRUE
[11:01:29.343] - signal: TRUE
[11:01:29.343] - resignal: FALSE
[11:01:29.343] - force: TRUE
[11:01:29.343] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.343] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.344]  - until=6
[11:01:29.344]  - relaying element #6
[11:01:29.344] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.344] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.344] signalConditionsASAP(NULL, pos=5) ... done
[11:01:29.344]  length: 1 (resolved future 5)
[11:01:29.344] signalConditionsASAP(numeric, pos=6) ...
[11:01:29.344] - nx: 6
[11:01:29.346] - relay: TRUE
[11:01:29.346] - stdout: TRUE
[11:01:29.347] - signal: TRUE
[11:01:29.347] - resignal: FALSE
[11:01:29.347] - force: TRUE
[11:01:29.347] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.347] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.347]  - until=6
[11:01:29.347] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.348] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.348] signalConditionsASAP(numeric, pos=6) ... done
[11:01:29.348]  length: 0 (resolved future 6)
[11:01:29.348] Relaying remaining futures
[11:01:29.348] signalConditionsASAP(NULL, pos=0) ...
[11:01:29.348] - nx: 6
[11:01:29.348] - relay: TRUE
[11:01:29.348] - stdout: TRUE
[11:01:29.349] - signal: TRUE
[11:01:29.349] - resignal: FALSE
[11:01:29.349] - force: TRUE
[11:01:29.349] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.349] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:29.349] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.349] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.349] signalConditionsASAP(NULL, pos=0) ... done
[11:01:29.349] resolve() on list ... DONE
[11:01:29.350] result() for MulticoreFuture ...
[11:01:29.350] result() for MulticoreFuture ... done
[11:01:29.350] result() for MulticoreFuture ...
[11:01:29.350] result() for MulticoreFuture ... done
[11:01:29.350] result() for MulticoreFuture ...
[11:01:29.350] result() for MulticoreFuture ... done
[11:01:29.350] result() for MulticoreFuture ...
[11:01:29.350] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[11:01:29.354] getGlobalsAndPackages() ...
[11:01:29.354] Searching for globals...
[11:01:29.354] 
[11:01:29.355] Searching for globals ... DONE
[11:01:29.355] - globals: [0] <none>
[11:01:29.355] getGlobalsAndPackages() ... DONE
[11:01:29.355] run() for ‘Future’ ...
[11:01:29.355] - state: ‘created’
[11:01:29.355] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.357] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.357] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.357]   - Field: ‘label’
[11:01:29.357]   - Field: ‘local’
[11:01:29.357]   - Field: ‘owner’
[11:01:29.357]   - Field: ‘envir’
[11:01:29.358]   - Field: ‘workers’
[11:01:29.358]   - Field: ‘packages’
[11:01:29.358]   - Field: ‘gc’
[11:01:29.358]   - Field: ‘job’
[11:01:29.358]   - Field: ‘conditions’
[11:01:29.358]   - Field: ‘expr’
[11:01:29.358]   - Field: ‘uuid’
[11:01:29.358]   - Field: ‘seed’
[11:01:29.358]   - Field: ‘version’
[11:01:29.358]   - Field: ‘result’
[11:01:29.358]   - Field: ‘asynchronous’
[11:01:29.359]   - Field: ‘calls’
[11:01:29.359]   - Field: ‘globals’
[11:01:29.359]   - Field: ‘stdout’
[11:01:29.359]   - Field: ‘earlySignal’
[11:01:29.359]   - Field: ‘lazy’
[11:01:29.359]   - Field: ‘state’
[11:01:29.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.359] - Launch lazy future ...
[11:01:29.359] Packages needed by the future expression (n = 0): <none>
[11:01:29.359] Packages needed by future strategies (n = 0): <none>
[11:01:29.360] {
[11:01:29.360]     {
[11:01:29.360]         {
[11:01:29.360]             ...future.startTime <- base::Sys.time()
[11:01:29.360]             {
[11:01:29.360]                 {
[11:01:29.360]                   {
[11:01:29.360]                     {
[11:01:29.360]                       base::local({
[11:01:29.360]                         has_future <- base::requireNamespace("future", 
[11:01:29.360]                           quietly = TRUE)
[11:01:29.360]                         if (has_future) {
[11:01:29.360]                           ns <- base::getNamespace("future")
[11:01:29.360]                           version <- ns[[".package"]][["version"]]
[11:01:29.360]                           if (is.null(version)) 
[11:01:29.360]                             version <- utils::packageVersion("future")
[11:01:29.360]                         }
[11:01:29.360]                         else {
[11:01:29.360]                           version <- NULL
[11:01:29.360]                         }
[11:01:29.360]                         if (!has_future || version < "1.8.0") {
[11:01:29.360]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.360]                             "", base::R.version$version.string), 
[11:01:29.360]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.360]                               "release", "version")], collapse = " "), 
[11:01:29.360]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.360]                             info)
[11:01:29.360]                           info <- base::paste(info, collapse = "; ")
[11:01:29.360]                           if (!has_future) {
[11:01:29.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.360]                               info)
[11:01:29.360]                           }
[11:01:29.360]                           else {
[11:01:29.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.360]                               info, version)
[11:01:29.360]                           }
[11:01:29.360]                           base::stop(msg)
[11:01:29.360]                         }
[11:01:29.360]                       })
[11:01:29.360]                     }
[11:01:29.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.360]                     base::options(mc.cores = 1L)
[11:01:29.360]                   }
[11:01:29.360]                   ...future.strategy.old <- future::plan("list")
[11:01:29.360]                   options(future.plan = NULL)
[11:01:29.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.360]                 }
[11:01:29.360]                 ...future.workdir <- getwd()
[11:01:29.360]             }
[11:01:29.360]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.360]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.360]         }
[11:01:29.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.360]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.360]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.360]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.360]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.360]             base::names(...future.oldOptions))
[11:01:29.360]     }
[11:01:29.360]     if (FALSE) {
[11:01:29.360]     }
[11:01:29.360]     else {
[11:01:29.360]         if (TRUE) {
[11:01:29.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.360]                 open = "w")
[11:01:29.360]         }
[11:01:29.360]         else {
[11:01:29.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.360]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.360]         }
[11:01:29.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.360]             base::sink(type = "output", split = FALSE)
[11:01:29.360]             base::close(...future.stdout)
[11:01:29.360]         }, add = TRUE)
[11:01:29.360]     }
[11:01:29.360]     ...future.frame <- base::sys.nframe()
[11:01:29.360]     ...future.conditions <- base::list()
[11:01:29.360]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.360]     if (FALSE) {
[11:01:29.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.360]     }
[11:01:29.360]     ...future.result <- base::tryCatch({
[11:01:29.360]         base::withCallingHandlers({
[11:01:29.360]             ...future.value <- base::withVisible(base::local({
[11:01:29.360]                 withCallingHandlers({
[11:01:29.360]                   2
[11:01:29.360]                 }, immediateCondition = function(cond) {
[11:01:29.360]                   save_rds <- function (object, pathname, ...) 
[11:01:29.360]                   {
[11:01:29.360]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.360]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.360]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.360]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.360]                         fi_tmp[["mtime"]])
[11:01:29.360]                     }
[11:01:29.360]                     tryCatch({
[11:01:29.360]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.360]                     }, error = function(ex) {
[11:01:29.360]                       msg <- conditionMessage(ex)
[11:01:29.360]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.360]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.360]                         fi_tmp[["mtime"]], msg)
[11:01:29.360]                       ex$message <- msg
[11:01:29.360]                       stop(ex)
[11:01:29.360]                     })
[11:01:29.360]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.360]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.360]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.360]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.360]                       fi <- file.info(pathname)
[11:01:29.360]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.360]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.360]                         fi[["size"]], fi[["mtime"]])
[11:01:29.360]                       stop(msg)
[11:01:29.360]                     }
[11:01:29.360]                     invisible(pathname)
[11:01:29.360]                   }
[11:01:29.360]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.360]                     rootPath = tempdir()) 
[11:01:29.360]                   {
[11:01:29.360]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.360]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.360]                       tmpdir = path, fileext = ".rds")
[11:01:29.360]                     save_rds(obj, file)
[11:01:29.360]                   }
[11:01:29.360]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.360]                   {
[11:01:29.360]                     inherits <- base::inherits
[11:01:29.360]                     invokeRestart <- base::invokeRestart
[11:01:29.360]                     is.null <- base::is.null
[11:01:29.360]                     muffled <- FALSE
[11:01:29.360]                     if (inherits(cond, "message")) {
[11:01:29.360]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.360]                       if (muffled) 
[11:01:29.360]                         invokeRestart("muffleMessage")
[11:01:29.360]                     }
[11:01:29.360]                     else if (inherits(cond, "warning")) {
[11:01:29.360]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.360]                       if (muffled) 
[11:01:29.360]                         invokeRestart("muffleWarning")
[11:01:29.360]                     }
[11:01:29.360]                     else if (inherits(cond, "condition")) {
[11:01:29.360]                       if (!is.null(pattern)) {
[11:01:29.360]                         computeRestarts <- base::computeRestarts
[11:01:29.360]                         grepl <- base::grepl
[11:01:29.360]                         restarts <- computeRestarts(cond)
[11:01:29.360]                         for (restart in restarts) {
[11:01:29.360]                           name <- restart$name
[11:01:29.360]                           if (is.null(name)) 
[11:01:29.360]                             next
[11:01:29.360]                           if (!grepl(pattern, name)) 
[11:01:29.360]                             next
[11:01:29.360]                           invokeRestart(restart)
[11:01:29.360]                           muffled <- TRUE
[11:01:29.360]                           break
[11:01:29.360]                         }
[11:01:29.360]                       }
[11:01:29.360]                     }
[11:01:29.360]                     invisible(muffled)
[11:01:29.360]                   }
[11:01:29.360]                   muffleCondition(cond)
[11:01:29.360]                 })
[11:01:29.360]             }))
[11:01:29.360]             future::FutureResult(value = ...future.value$value, 
[11:01:29.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.360]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.360]                     ...future.globalenv.names))
[11:01:29.360]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.360]         }, condition = base::local({
[11:01:29.360]             c <- base::c
[11:01:29.360]             inherits <- base::inherits
[11:01:29.360]             invokeRestart <- base::invokeRestart
[11:01:29.360]             length <- base::length
[11:01:29.360]             list <- base::list
[11:01:29.360]             seq.int <- base::seq.int
[11:01:29.360]             signalCondition <- base::signalCondition
[11:01:29.360]             sys.calls <- base::sys.calls
[11:01:29.360]             `[[` <- base::`[[`
[11:01:29.360]             `+` <- base::`+`
[11:01:29.360]             `<<-` <- base::`<<-`
[11:01:29.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.360]                   3L)]
[11:01:29.360]             }
[11:01:29.360]             function(cond) {
[11:01:29.360]                 is_error <- inherits(cond, "error")
[11:01:29.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.360]                   NULL)
[11:01:29.360]                 if (is_error) {
[11:01:29.360]                   sessionInformation <- function() {
[11:01:29.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.360]                       search = base::search(), system = base::Sys.info())
[11:01:29.360]                   }
[11:01:29.360]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.360]                     cond$call), session = sessionInformation(), 
[11:01:29.360]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.360]                   signalCondition(cond)
[11:01:29.360]                 }
[11:01:29.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.360]                 "immediateCondition"))) {
[11:01:29.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.360]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.360]                   if (TRUE && !signal) {
[11:01:29.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.360]                     {
[11:01:29.360]                       inherits <- base::inherits
[11:01:29.360]                       invokeRestart <- base::invokeRestart
[11:01:29.360]                       is.null <- base::is.null
[11:01:29.360]                       muffled <- FALSE
[11:01:29.360]                       if (inherits(cond, "message")) {
[11:01:29.360]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.360]                         if (muffled) 
[11:01:29.360]                           invokeRestart("muffleMessage")
[11:01:29.360]                       }
[11:01:29.360]                       else if (inherits(cond, "warning")) {
[11:01:29.360]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.360]                         if (muffled) 
[11:01:29.360]                           invokeRestart("muffleWarning")
[11:01:29.360]                       }
[11:01:29.360]                       else if (inherits(cond, "condition")) {
[11:01:29.360]                         if (!is.null(pattern)) {
[11:01:29.360]                           computeRestarts <- base::computeRestarts
[11:01:29.360]                           grepl <- base::grepl
[11:01:29.360]                           restarts <- computeRestarts(cond)
[11:01:29.360]                           for (restart in restarts) {
[11:01:29.360]                             name <- restart$name
[11:01:29.360]                             if (is.null(name)) 
[11:01:29.360]                               next
[11:01:29.360]                             if (!grepl(pattern, name)) 
[11:01:29.360]                               next
[11:01:29.360]                             invokeRestart(restart)
[11:01:29.360]                             muffled <- TRUE
[11:01:29.360]                             break
[11:01:29.360]                           }
[11:01:29.360]                         }
[11:01:29.360]                       }
[11:01:29.360]                       invisible(muffled)
[11:01:29.360]                     }
[11:01:29.360]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.360]                   }
[11:01:29.360]                 }
[11:01:29.360]                 else {
[11:01:29.360]                   if (TRUE) {
[11:01:29.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.360]                     {
[11:01:29.360]                       inherits <- base::inherits
[11:01:29.360]                       invokeRestart <- base::invokeRestart
[11:01:29.360]                       is.null <- base::is.null
[11:01:29.360]                       muffled <- FALSE
[11:01:29.360]                       if (inherits(cond, "message")) {
[11:01:29.360]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.360]                         if (muffled) 
[11:01:29.360]                           invokeRestart("muffleMessage")
[11:01:29.360]                       }
[11:01:29.360]                       else if (inherits(cond, "warning")) {
[11:01:29.360]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.360]                         if (muffled) 
[11:01:29.360]                           invokeRestart("muffleWarning")
[11:01:29.360]                       }
[11:01:29.360]                       else if (inherits(cond, "condition")) {
[11:01:29.360]                         if (!is.null(pattern)) {
[11:01:29.360]                           computeRestarts <- base::computeRestarts
[11:01:29.360]                           grepl <- base::grepl
[11:01:29.360]                           restarts <- computeRestarts(cond)
[11:01:29.360]                           for (restart in restarts) {
[11:01:29.360]                             name <- restart$name
[11:01:29.360]                             if (is.null(name)) 
[11:01:29.360]                               next
[11:01:29.360]                             if (!grepl(pattern, name)) 
[11:01:29.360]                               next
[11:01:29.360]                             invokeRestart(restart)
[11:01:29.360]                             muffled <- TRUE
[11:01:29.360]                             break
[11:01:29.360]                           }
[11:01:29.360]                         }
[11:01:29.360]                       }
[11:01:29.360]                       invisible(muffled)
[11:01:29.360]                     }
[11:01:29.360]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.360]                   }
[11:01:29.360]                 }
[11:01:29.360]             }
[11:01:29.360]         }))
[11:01:29.360]     }, error = function(ex) {
[11:01:29.360]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.360]                 ...future.rng), started = ...future.startTime, 
[11:01:29.360]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.360]             version = "1.8"), class = "FutureResult")
[11:01:29.360]     }, finally = {
[11:01:29.360]         if (!identical(...future.workdir, getwd())) 
[11:01:29.360]             setwd(...future.workdir)
[11:01:29.360]         {
[11:01:29.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.360]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.360]             }
[11:01:29.360]             base::options(...future.oldOptions)
[11:01:29.360]             if (.Platform$OS.type == "windows") {
[11:01:29.360]                 old_names <- names(...future.oldEnvVars)
[11:01:29.360]                 envs <- base::Sys.getenv()
[11:01:29.360]                 names <- names(envs)
[11:01:29.360]                 common <- intersect(names, old_names)
[11:01:29.360]                 added <- setdiff(names, old_names)
[11:01:29.360]                 removed <- setdiff(old_names, names)
[11:01:29.360]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.360]                   envs[common]]
[11:01:29.360]                 NAMES <- toupper(changed)
[11:01:29.360]                 args <- list()
[11:01:29.360]                 for (kk in seq_along(NAMES)) {
[11:01:29.360]                   name <- changed[[kk]]
[11:01:29.360]                   NAME <- NAMES[[kk]]
[11:01:29.360]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.360]                     next
[11:01:29.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.360]                 }
[11:01:29.360]                 NAMES <- toupper(added)
[11:01:29.360]                 for (kk in seq_along(NAMES)) {
[11:01:29.360]                   name <- added[[kk]]
[11:01:29.360]                   NAME <- NAMES[[kk]]
[11:01:29.360]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.360]                     next
[11:01:29.360]                   args[[name]] <- ""
[11:01:29.360]                 }
[11:01:29.360]                 NAMES <- toupper(removed)
[11:01:29.360]                 for (kk in seq_along(NAMES)) {
[11:01:29.360]                   name <- removed[[kk]]
[11:01:29.360]                   NAME <- NAMES[[kk]]
[11:01:29.360]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.360]                     next
[11:01:29.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.360]                 }
[11:01:29.360]                 if (length(args) > 0) 
[11:01:29.360]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.360]             }
[11:01:29.360]             else {
[11:01:29.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.360]             }
[11:01:29.360]             {
[11:01:29.360]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.360]                   0L) {
[11:01:29.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.360]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.360]                   base::options(opts)
[11:01:29.360]                 }
[11:01:29.360]                 {
[11:01:29.360]                   {
[11:01:29.360]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.360]                     NULL
[11:01:29.360]                   }
[11:01:29.360]                   options(future.plan = NULL)
[11:01:29.360]                   if (is.na(NA_character_)) 
[11:01:29.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.360]                     .init = FALSE)
[11:01:29.360]                 }
[11:01:29.360]             }
[11:01:29.360]         }
[11:01:29.360]     })
[11:01:29.360]     if (TRUE) {
[11:01:29.360]         base::sink(type = "output", split = FALSE)
[11:01:29.360]         if (TRUE) {
[11:01:29.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.360]         }
[11:01:29.360]         else {
[11:01:29.360]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.360]         }
[11:01:29.360]         base::close(...future.stdout)
[11:01:29.360]         ...future.stdout <- NULL
[11:01:29.360]     }
[11:01:29.360]     ...future.result$conditions <- ...future.conditions
[11:01:29.360]     ...future.result$finished <- base::Sys.time()
[11:01:29.360]     ...future.result
[11:01:29.360] }
[11:01:29.362] requestCore(): workers = 2
[11:01:29.364] MulticoreFuture started
[11:01:29.364] - Launch lazy future ... done
[11:01:29.364] run() for ‘MulticoreFuture’ ... done
[11:01:29.365] getGlobalsAndPackages() ...
[11:01:29.365] Searching for globals...
[11:01:29.365] plan(): Setting new future strategy stack:
[11:01:29.366] 
[11:01:29.365] List of future strategies:
[11:01:29.365] 1. sequential:
[11:01:29.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.365]    - tweaked: FALSE
[11:01:29.365]    - call: NULL
[11:01:29.366] Searching for globals ... DONE
[11:01:29.366] - globals: [0] <none>
[11:01:29.366] plan(): nbrOfWorkers() = 1
[11:01:29.366] getGlobalsAndPackages() ... DONE
[11:01:29.367] run() for ‘Future’ ...
[11:01:29.367] - state: ‘created’
[11:01:29.367] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.368] plan(): Setting new future strategy stack:
[11:01:29.368] List of future strategies:
[11:01:29.368] 1. multicore:
[11:01:29.368]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.368]    - tweaked: FALSE
[11:01:29.368]    - call: plan(strategy)
[11:01:29.371] plan(): nbrOfWorkers() = 2
[11:01:29.371] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.371] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.371]   - Field: ‘label’
[11:01:29.371]   - Field: ‘local’
[11:01:29.372]   - Field: ‘owner’
[11:01:29.372]   - Field: ‘envir’
[11:01:29.372]   - Field: ‘workers’
[11:01:29.372]   - Field: ‘packages’
[11:01:29.372]   - Field: ‘gc’
[11:01:29.373]   - Field: ‘job’
[11:01:29.373]   - Field: ‘conditions’
[11:01:29.373]   - Field: ‘expr’
[11:01:29.373]   - Field: ‘uuid’
[11:01:29.373]   - Field: ‘seed’
[11:01:29.374]   - Field: ‘version’
[11:01:29.374]   - Field: ‘result’
[11:01:29.374]   - Field: ‘asynchronous’
[11:01:29.374]   - Field: ‘calls’
[11:01:29.374]   - Field: ‘globals’
[11:01:29.375]   - Field: ‘stdout’
[11:01:29.375]   - Field: ‘earlySignal’
[11:01:29.375]   - Field: ‘lazy’
[11:01:29.375]   - Field: ‘state’
[11:01:29.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.376] - Launch lazy future ...
[11:01:29.376] Packages needed by the future expression (n = 0): <none>
[11:01:29.376] Packages needed by future strategies (n = 0): <none>
[11:01:29.377] {
[11:01:29.377]     {
[11:01:29.377]         {
[11:01:29.377]             ...future.startTime <- base::Sys.time()
[11:01:29.377]             {
[11:01:29.377]                 {
[11:01:29.377]                   {
[11:01:29.377]                     {
[11:01:29.377]                       base::local({
[11:01:29.377]                         has_future <- base::requireNamespace("future", 
[11:01:29.377]                           quietly = TRUE)
[11:01:29.377]                         if (has_future) {
[11:01:29.377]                           ns <- base::getNamespace("future")
[11:01:29.377]                           version <- ns[[".package"]][["version"]]
[11:01:29.377]                           if (is.null(version)) 
[11:01:29.377]                             version <- utils::packageVersion("future")
[11:01:29.377]                         }
[11:01:29.377]                         else {
[11:01:29.377]                           version <- NULL
[11:01:29.377]                         }
[11:01:29.377]                         if (!has_future || version < "1.8.0") {
[11:01:29.377]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.377]                             "", base::R.version$version.string), 
[11:01:29.377]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.377]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.377]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.377]                               "release", "version")], collapse = " "), 
[11:01:29.377]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.377]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.377]                             info)
[11:01:29.377]                           info <- base::paste(info, collapse = "; ")
[11:01:29.377]                           if (!has_future) {
[11:01:29.377]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.377]                               info)
[11:01:29.377]                           }
[11:01:29.377]                           else {
[11:01:29.377]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.377]                               info, version)
[11:01:29.377]                           }
[11:01:29.377]                           base::stop(msg)
[11:01:29.377]                         }
[11:01:29.377]                       })
[11:01:29.377]                     }
[11:01:29.377]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.377]                     base::options(mc.cores = 1L)
[11:01:29.377]                   }
[11:01:29.377]                   ...future.strategy.old <- future::plan("list")
[11:01:29.377]                   options(future.plan = NULL)
[11:01:29.377]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.377]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.377]                 }
[11:01:29.377]                 ...future.workdir <- getwd()
[11:01:29.377]             }
[11:01:29.377]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.377]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.377]         }
[11:01:29.377]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.377]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.377]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.377]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.377]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.377]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.377]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.377]             base::names(...future.oldOptions))
[11:01:29.377]     }
[11:01:29.377]     if (FALSE) {
[11:01:29.377]     }
[11:01:29.377]     else {
[11:01:29.377]         if (TRUE) {
[11:01:29.377]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.377]                 open = "w")
[11:01:29.377]         }
[11:01:29.377]         else {
[11:01:29.377]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.377]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.377]         }
[11:01:29.377]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.377]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.377]             base::sink(type = "output", split = FALSE)
[11:01:29.377]             base::close(...future.stdout)
[11:01:29.377]         }, add = TRUE)
[11:01:29.377]     }
[11:01:29.377]     ...future.frame <- base::sys.nframe()
[11:01:29.377]     ...future.conditions <- base::list()
[11:01:29.377]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.377]     if (FALSE) {
[11:01:29.377]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.377]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.377]     }
[11:01:29.377]     ...future.result <- base::tryCatch({
[11:01:29.377]         base::withCallingHandlers({
[11:01:29.377]             ...future.value <- base::withVisible(base::local({
[11:01:29.377]                 withCallingHandlers({
[11:01:29.377]                   NULL
[11:01:29.377]                 }, immediateCondition = function(cond) {
[11:01:29.377]                   save_rds <- function (object, pathname, ...) 
[11:01:29.377]                   {
[11:01:29.377]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.377]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.377]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.377]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.377]                         fi_tmp[["mtime"]])
[11:01:29.377]                     }
[11:01:29.377]                     tryCatch({
[11:01:29.377]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.377]                     }, error = function(ex) {
[11:01:29.377]                       msg <- conditionMessage(ex)
[11:01:29.377]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.377]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.377]                         fi_tmp[["mtime"]], msg)
[11:01:29.377]                       ex$message <- msg
[11:01:29.377]                       stop(ex)
[11:01:29.377]                     })
[11:01:29.377]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.377]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.377]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.377]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.377]                       fi <- file.info(pathname)
[11:01:29.377]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.377]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.377]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.377]                         fi[["size"]], fi[["mtime"]])
[11:01:29.377]                       stop(msg)
[11:01:29.377]                     }
[11:01:29.377]                     invisible(pathname)
[11:01:29.377]                   }
[11:01:29.377]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.377]                     rootPath = tempdir()) 
[11:01:29.377]                   {
[11:01:29.377]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.377]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.377]                       tmpdir = path, fileext = ".rds")
[11:01:29.377]                     save_rds(obj, file)
[11:01:29.377]                   }
[11:01:29.377]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.377]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.377]                   {
[11:01:29.377]                     inherits <- base::inherits
[11:01:29.377]                     invokeRestart <- base::invokeRestart
[11:01:29.377]                     is.null <- base::is.null
[11:01:29.377]                     muffled <- FALSE
[11:01:29.377]                     if (inherits(cond, "message")) {
[11:01:29.377]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.377]                       if (muffled) 
[11:01:29.377]                         invokeRestart("muffleMessage")
[11:01:29.377]                     }
[11:01:29.377]                     else if (inherits(cond, "warning")) {
[11:01:29.377]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.377]                       if (muffled) 
[11:01:29.377]                         invokeRestart("muffleWarning")
[11:01:29.377]                     }
[11:01:29.377]                     else if (inherits(cond, "condition")) {
[11:01:29.377]                       if (!is.null(pattern)) {
[11:01:29.377]                         computeRestarts <- base::computeRestarts
[11:01:29.377]                         grepl <- base::grepl
[11:01:29.377]                         restarts <- computeRestarts(cond)
[11:01:29.377]                         for (restart in restarts) {
[11:01:29.377]                           name <- restart$name
[11:01:29.377]                           if (is.null(name)) 
[11:01:29.377]                             next
[11:01:29.377]                           if (!grepl(pattern, name)) 
[11:01:29.377]                             next
[11:01:29.377]                           invokeRestart(restart)
[11:01:29.377]                           muffled <- TRUE
[11:01:29.377]                           break
[11:01:29.377]                         }
[11:01:29.377]                       }
[11:01:29.377]                     }
[11:01:29.377]                     invisible(muffled)
[11:01:29.377]                   }
[11:01:29.377]                   muffleCondition(cond)
[11:01:29.377]                 })
[11:01:29.377]             }))
[11:01:29.377]             future::FutureResult(value = ...future.value$value, 
[11:01:29.377]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.377]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.377]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.377]                     ...future.globalenv.names))
[11:01:29.377]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.377]         }, condition = base::local({
[11:01:29.377]             c <- base::c
[11:01:29.377]             inherits <- base::inherits
[11:01:29.377]             invokeRestart <- base::invokeRestart
[11:01:29.377]             length <- base::length
[11:01:29.377]             list <- base::list
[11:01:29.377]             seq.int <- base::seq.int
[11:01:29.377]             signalCondition <- base::signalCondition
[11:01:29.377]             sys.calls <- base::sys.calls
[11:01:29.377]             `[[` <- base::`[[`
[11:01:29.377]             `+` <- base::`+`
[11:01:29.377]             `<<-` <- base::`<<-`
[11:01:29.377]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.377]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.377]                   3L)]
[11:01:29.377]             }
[11:01:29.377]             function(cond) {
[11:01:29.377]                 is_error <- inherits(cond, "error")
[11:01:29.377]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.377]                   NULL)
[11:01:29.377]                 if (is_error) {
[11:01:29.377]                   sessionInformation <- function() {
[11:01:29.377]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.377]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.377]                       search = base::search(), system = base::Sys.info())
[11:01:29.377]                   }
[11:01:29.377]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.377]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.377]                     cond$call), session = sessionInformation(), 
[11:01:29.377]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.377]                   signalCondition(cond)
[11:01:29.377]                 }
[11:01:29.377]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.377]                 "immediateCondition"))) {
[11:01:29.377]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.377]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.377]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.377]                   if (TRUE && !signal) {
[11:01:29.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.377]                     {
[11:01:29.377]                       inherits <- base::inherits
[11:01:29.377]                       invokeRestart <- base::invokeRestart
[11:01:29.377]                       is.null <- base::is.null
[11:01:29.377]                       muffled <- FALSE
[11:01:29.377]                       if (inherits(cond, "message")) {
[11:01:29.377]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.377]                         if (muffled) 
[11:01:29.377]                           invokeRestart("muffleMessage")
[11:01:29.377]                       }
[11:01:29.377]                       else if (inherits(cond, "warning")) {
[11:01:29.377]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.377]                         if (muffled) 
[11:01:29.377]                           invokeRestart("muffleWarning")
[11:01:29.377]                       }
[11:01:29.377]                       else if (inherits(cond, "condition")) {
[11:01:29.377]                         if (!is.null(pattern)) {
[11:01:29.377]                           computeRestarts <- base::computeRestarts
[11:01:29.377]                           grepl <- base::grepl
[11:01:29.377]                           restarts <- computeRestarts(cond)
[11:01:29.377]                           for (restart in restarts) {
[11:01:29.377]                             name <- restart$name
[11:01:29.377]                             if (is.null(name)) 
[11:01:29.377]                               next
[11:01:29.377]                             if (!grepl(pattern, name)) 
[11:01:29.377]                               next
[11:01:29.377]                             invokeRestart(restart)
[11:01:29.377]                             muffled <- TRUE
[11:01:29.377]                             break
[11:01:29.377]                           }
[11:01:29.377]                         }
[11:01:29.377]                       }
[11:01:29.377]                       invisible(muffled)
[11:01:29.377]                     }
[11:01:29.377]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.377]                   }
[11:01:29.377]                 }
[11:01:29.377]                 else {
[11:01:29.377]                   if (TRUE) {
[11:01:29.377]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.377]                     {
[11:01:29.377]                       inherits <- base::inherits
[11:01:29.377]                       invokeRestart <- base::invokeRestart
[11:01:29.377]                       is.null <- base::is.null
[11:01:29.377]                       muffled <- FALSE
[11:01:29.377]                       if (inherits(cond, "message")) {
[11:01:29.377]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.377]                         if (muffled) 
[11:01:29.377]                           invokeRestart("muffleMessage")
[11:01:29.377]                       }
[11:01:29.377]                       else if (inherits(cond, "warning")) {
[11:01:29.377]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.377]                         if (muffled) 
[11:01:29.377]                           invokeRestart("muffleWarning")
[11:01:29.377]                       }
[11:01:29.377]                       else if (inherits(cond, "condition")) {
[11:01:29.377]                         if (!is.null(pattern)) {
[11:01:29.377]                           computeRestarts <- base::computeRestarts
[11:01:29.377]                           grepl <- base::grepl
[11:01:29.377]                           restarts <- computeRestarts(cond)
[11:01:29.377]                           for (restart in restarts) {
[11:01:29.377]                             name <- restart$name
[11:01:29.377]                             if (is.null(name)) 
[11:01:29.377]                               next
[11:01:29.377]                             if (!grepl(pattern, name)) 
[11:01:29.377]                               next
[11:01:29.377]                             invokeRestart(restart)
[11:01:29.377]                             muffled <- TRUE
[11:01:29.377]                             break
[11:01:29.377]                           }
[11:01:29.377]                         }
[11:01:29.377]                       }
[11:01:29.377]                       invisible(muffled)
[11:01:29.377]                     }
[11:01:29.377]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.377]                   }
[11:01:29.377]                 }
[11:01:29.377]             }
[11:01:29.377]         }))
[11:01:29.377]     }, error = function(ex) {
[11:01:29.377]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.377]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.377]                 ...future.rng), started = ...future.startTime, 
[11:01:29.377]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.377]             version = "1.8"), class = "FutureResult")
[11:01:29.377]     }, finally = {
[11:01:29.377]         if (!identical(...future.workdir, getwd())) 
[11:01:29.377]             setwd(...future.workdir)
[11:01:29.377]         {
[11:01:29.377]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.377]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.377]             }
[11:01:29.377]             base::options(...future.oldOptions)
[11:01:29.377]             if (.Platform$OS.type == "windows") {
[11:01:29.377]                 old_names <- names(...future.oldEnvVars)
[11:01:29.377]                 envs <- base::Sys.getenv()
[11:01:29.377]                 names <- names(envs)
[11:01:29.377]                 common <- intersect(names, old_names)
[11:01:29.377]                 added <- setdiff(names, old_names)
[11:01:29.377]                 removed <- setdiff(old_names, names)
[11:01:29.377]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.377]                   envs[common]]
[11:01:29.377]                 NAMES <- toupper(changed)
[11:01:29.377]                 args <- list()
[11:01:29.377]                 for (kk in seq_along(NAMES)) {
[11:01:29.377]                   name <- changed[[kk]]
[11:01:29.377]                   NAME <- NAMES[[kk]]
[11:01:29.377]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.377]                     next
[11:01:29.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.377]                 }
[11:01:29.377]                 NAMES <- toupper(added)
[11:01:29.377]                 for (kk in seq_along(NAMES)) {
[11:01:29.377]                   name <- added[[kk]]
[11:01:29.377]                   NAME <- NAMES[[kk]]
[11:01:29.377]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.377]                     next
[11:01:29.377]                   args[[name]] <- ""
[11:01:29.377]                 }
[11:01:29.377]                 NAMES <- toupper(removed)
[11:01:29.377]                 for (kk in seq_along(NAMES)) {
[11:01:29.377]                   name <- removed[[kk]]
[11:01:29.377]                   NAME <- NAMES[[kk]]
[11:01:29.377]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.377]                     next
[11:01:29.377]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.377]                 }
[11:01:29.377]                 if (length(args) > 0) 
[11:01:29.377]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.377]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.377]             }
[11:01:29.377]             else {
[11:01:29.377]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.377]             }
[11:01:29.377]             {
[11:01:29.377]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.377]                   0L) {
[11:01:29.377]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.377]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.377]                   base::options(opts)
[11:01:29.377]                 }
[11:01:29.377]                 {
[11:01:29.377]                   {
[11:01:29.377]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.377]                     NULL
[11:01:29.377]                   }
[11:01:29.377]                   options(future.plan = NULL)
[11:01:29.377]                   if (is.na(NA_character_)) 
[11:01:29.377]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.377]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.377]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.377]                     .init = FALSE)
[11:01:29.377]                 }
[11:01:29.377]             }
[11:01:29.377]         }
[11:01:29.377]     })
[11:01:29.377]     if (TRUE) {
[11:01:29.377]         base::sink(type = "output", split = FALSE)
[11:01:29.377]         if (TRUE) {
[11:01:29.377]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.377]         }
[11:01:29.377]         else {
[11:01:29.377]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.377]         }
[11:01:29.377]         base::close(...future.stdout)
[11:01:29.377]         ...future.stdout <- NULL
[11:01:29.377]     }
[11:01:29.377]     ...future.result$conditions <- ...future.conditions
[11:01:29.377]     ...future.result$finished <- base::Sys.time()
[11:01:29.377]     ...future.result
[11:01:29.377] }
[11:01:29.381] requestCore(): workers = 2
[11:01:29.383] MulticoreFuture started
[11:01:29.383] - Launch lazy future ... done
[11:01:29.384] run() for ‘MulticoreFuture’ ... done
List of 6
[11:01:29.384] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[11:01:29.384] List of future strategies:
[11:01:29.384] 1. sequential:
[11:01:29.384]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.384]    - tweaked: FALSE
[11:01:29.384]    - call: NULL
[11:01:29.385] plan(): nbrOfWorkers() = 1
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4a7a060> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c6598670> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
[11:01:29.387] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[11:01:29.387] List of future strategies:
[11:01:29.387] 1. multicore:
[11:01:29.387]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.387]    - tweaked: FALSE
[11:01:29.387]    - call: plan(strategy)
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4a7a060> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c6598670> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ :[11:01:29.391] plan(): nbrOfWorkers() = 2
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:29.401] resolve() on list ...
[11:01:29.401]  recursive: 0
[11:01:29.402]  length: 6
[11:01:29.402]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:29.402] signalConditionsASAP(numeric, pos=1) ...
[11:01:29.402] - nx: 6
[11:01:29.402] - relay: TRUE
[11:01:29.402] - stdout: TRUE
[11:01:29.403] - signal: TRUE
[11:01:29.403] - resignal: FALSE
[11:01:29.403] - force: TRUE
[11:01:29.403] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.403] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.403]  - until=2
[11:01:29.403]  - relaying element #2
[11:01:29.404] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.404] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.404] signalConditionsASAP(NULL, pos=1) ... done
[11:01:29.404]  length: 5 (resolved future 1)
[11:01:29.404] Future #2
[11:01:29.405] result() for MulticoreFuture ...
[11:01:29.406] result() for MulticoreFuture ...
[11:01:29.406] result() for MulticoreFuture ... done
[11:01:29.406] result() for MulticoreFuture ... done
[11:01:29.406] result() for MulticoreFuture ...
[11:01:29.406] result() for MulticoreFuture ... done
[11:01:29.406] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:29.406] - nx: 6
[11:01:29.406] - relay: TRUE
[11:01:29.407] - stdout: TRUE
[11:01:29.407] - signal: TRUE
[11:01:29.407] - resignal: FALSE
[11:01:29.407] - force: TRUE
[11:01:29.407] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.407] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.407]  - until=2
[11:01:29.407]  - relaying element #2
[11:01:29.408] result() for MulticoreFuture ...
[11:01:29.408] result() for MulticoreFuture ... done
[11:01:29.408] result() for MulticoreFuture ...
[11:01:29.408] result() for MulticoreFuture ... done
[11:01:29.408] result() for MulticoreFuture ...
[11:01:29.408] result() for MulticoreFuture ... done
[11:01:29.408] result() for MulticoreFuture ...
[11:01:29.409] result() for MulticoreFuture ... done
[11:01:29.409] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.409] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.409] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:29.409]  length: 4 (resolved future 2)
[11:01:29.409] Future #3
[11:01:29.409] result() for MulticoreFuture ...
[11:01:29.410] result() for MulticoreFuture ...
[11:01:29.410] result() for MulticoreFuture ... done
[11:01:29.410] result() for MulticoreFuture ... done
[11:01:29.410] result() for MulticoreFuture ...
[11:01:29.411] result() for MulticoreFuture ... done
[11:01:29.411] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:29.411] - nx: 6
[11:01:29.411] - relay: TRUE
[11:01:29.411] - stdout: TRUE
[11:01:29.411] - signal: TRUE
[11:01:29.411] - resignal: FALSE
[11:01:29.411] - force: TRUE
[11:01:29.411] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.412] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.412]  - until=3
[11:01:29.412]  - relaying element #3
[11:01:29.412] result() for MulticoreFuture ...
[11:01:29.412] result() for MulticoreFuture ... done
[11:01:29.412] result() for MulticoreFuture ...
[11:01:29.412] result() for MulticoreFuture ... done
[11:01:29.412] result() for MulticoreFuture ...
[11:01:29.412] result() for MulticoreFuture ... done
[11:01:29.413] result() for MulticoreFuture ...
[11:01:29.413] result() for MulticoreFuture ... done
[11:01:29.413] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.413] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.413] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:29.413]  length: 3 (resolved future 3)
[11:01:29.413] signalConditionsASAP(NULL, pos=4) ...
[11:01:29.413] - nx: 6
[11:01:29.413] - relay: TRUE
[11:01:29.414] - stdout: TRUE
[11:01:29.414] - signal: TRUE
[11:01:29.414] - resignal: FALSE
[11:01:29.414] - force: TRUE
[11:01:29.414] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.414] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.414]  - until=5
[11:01:29.414]  - relaying element #5
[11:01:29.414] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.414] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.414] signalConditionsASAP(NULL, pos=4) ... done
[11:01:29.415]  length: 2 (resolved future 4)
[11:01:29.415] signalConditionsASAP(NULL, pos=5) ...
[11:01:29.415] - nx: 6
[11:01:29.415] - relay: TRUE
[11:01:29.415] - stdout: TRUE
[11:01:29.415] - signal: TRUE
[11:01:29.415] - resignal: FALSE
[11:01:29.415] - force: TRUE
[11:01:29.415] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.415] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.415]  - until=6
[11:01:29.416]  - relaying element #6
[11:01:29.416] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.416] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.416] signalConditionsASAP(NULL, pos=5) ... done
[11:01:29.416]  length: 1 (resolved future 5)
[11:01:29.416] signalConditionsASAP(numeric, pos=6) ...
[11:01:29.416] - nx: 6
[11:01:29.416] - relay: TRUE
[11:01:29.416] - stdout: TRUE
[11:01:29.416] - signal: TRUE
[11:01:29.416] - resignal: FALSE
[11:01:29.417] - force: TRUE
[11:01:29.417] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.417] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.417]  - until=6
[11:01:29.417] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.417] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.417] signalConditionsASAP(numeric, pos=6) ... done
[11:01:29.417]  length: 0 (resolved future 6)
[11:01:29.417] Relaying remaining futures
[11:01:29.417] signalConditionsASAP(NULL, pos=0) ...
[11:01:29.417] - nx: 6
[11:01:29.418] - relay: TRUE
[11:01:29.418] - stdout: TRUE
[11:01:29.418] - signal: TRUE
[11:01:29.418] - resignal: FALSE
[11:01:29.418] - force: TRUE
[11:01:29.418] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.418] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:29.418] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.418] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.418] signalConditionsASAP(NULL, pos=0) ... done
[11:01:29.419] resolve() on list ... DONE
[11:01:29.419] result() for MulticoreFuture ...
[11:01:29.419] result() for MulticoreFuture ... done
[11:01:29.419] result() for MulticoreFuture ...
[11:01:29.419] result() for MulticoreFuture ... done
[11:01:29.419] result() for MulticoreFuture ...
[11:01:29.419] result() for MulticoreFuture ... done
[11:01:29.419] result() for MulticoreFuture ...
[11:01:29.419] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[11:01:29.423] getGlobalsAndPackages() ...
[11:01:29.423] Searching for globals...
[11:01:29.423] 
[11:01:29.423] Searching for globals ... DONE
[11:01:29.423] - globals: [0] <none>
[11:01:29.424] getGlobalsAndPackages() ... DONE
[11:01:29.424] run() for ‘Future’ ...
[11:01:29.424] - state: ‘created’
[11:01:29.424] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.426] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.426] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.426]   - Field: ‘label’
[11:01:29.426]   - Field: ‘local’
[11:01:29.428]   - Field: ‘owner’
[11:01:29.428]   - Field: ‘envir’
[11:01:29.428]   - Field: ‘workers’
[11:01:29.428]   - Field: ‘packages’
[11:01:29.428]   - Field: ‘gc’
[11:01:29.428]   - Field: ‘job’
[11:01:29.428]   - Field: ‘conditions’
[11:01:29.428]   - Field: ‘expr’
[11:01:29.428]   - Field: ‘uuid’
[11:01:29.428]   - Field: ‘seed’
[11:01:29.428]   - Field: ‘version’
[11:01:29.429]   - Field: ‘result’
[11:01:29.429]   - Field: ‘asynchronous’
[11:01:29.429]   - Field: ‘calls’
[11:01:29.429]   - Field: ‘globals’
[11:01:29.429]   - Field: ‘stdout’
[11:01:29.429]   - Field: ‘earlySignal’
[11:01:29.429]   - Field: ‘lazy’
[11:01:29.429]   - Field: ‘state’
[11:01:29.429] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.429] - Launch lazy future ...
[11:01:29.430] Packages needed by the future expression (n = 0): <none>
[11:01:29.430] Packages needed by future strategies (n = 0): <none>
[11:01:29.430] {
[11:01:29.430]     {
[11:01:29.430]         {
[11:01:29.430]             ...future.startTime <- base::Sys.time()
[11:01:29.430]             {
[11:01:29.430]                 {
[11:01:29.430]                   {
[11:01:29.430]                     {
[11:01:29.430]                       base::local({
[11:01:29.430]                         has_future <- base::requireNamespace("future", 
[11:01:29.430]                           quietly = TRUE)
[11:01:29.430]                         if (has_future) {
[11:01:29.430]                           ns <- base::getNamespace("future")
[11:01:29.430]                           version <- ns[[".package"]][["version"]]
[11:01:29.430]                           if (is.null(version)) 
[11:01:29.430]                             version <- utils::packageVersion("future")
[11:01:29.430]                         }
[11:01:29.430]                         else {
[11:01:29.430]                           version <- NULL
[11:01:29.430]                         }
[11:01:29.430]                         if (!has_future || version < "1.8.0") {
[11:01:29.430]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.430]                             "", base::R.version$version.string), 
[11:01:29.430]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.430]                               "release", "version")], collapse = " "), 
[11:01:29.430]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.430]                             info)
[11:01:29.430]                           info <- base::paste(info, collapse = "; ")
[11:01:29.430]                           if (!has_future) {
[11:01:29.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.430]                               info)
[11:01:29.430]                           }
[11:01:29.430]                           else {
[11:01:29.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.430]                               info, version)
[11:01:29.430]                           }
[11:01:29.430]                           base::stop(msg)
[11:01:29.430]                         }
[11:01:29.430]                       })
[11:01:29.430]                     }
[11:01:29.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.430]                     base::options(mc.cores = 1L)
[11:01:29.430]                   }
[11:01:29.430]                   ...future.strategy.old <- future::plan("list")
[11:01:29.430]                   options(future.plan = NULL)
[11:01:29.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.430]                 }
[11:01:29.430]                 ...future.workdir <- getwd()
[11:01:29.430]             }
[11:01:29.430]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.430]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.430]         }
[11:01:29.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.430]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.430]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.430]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.430]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.430]             base::names(...future.oldOptions))
[11:01:29.430]     }
[11:01:29.430]     if (FALSE) {
[11:01:29.430]     }
[11:01:29.430]     else {
[11:01:29.430]         if (TRUE) {
[11:01:29.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.430]                 open = "w")
[11:01:29.430]         }
[11:01:29.430]         else {
[11:01:29.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.430]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.430]         }
[11:01:29.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.430]             base::sink(type = "output", split = FALSE)
[11:01:29.430]             base::close(...future.stdout)
[11:01:29.430]         }, add = TRUE)
[11:01:29.430]     }
[11:01:29.430]     ...future.frame <- base::sys.nframe()
[11:01:29.430]     ...future.conditions <- base::list()
[11:01:29.430]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.430]     if (FALSE) {
[11:01:29.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.430]     }
[11:01:29.430]     ...future.result <- base::tryCatch({
[11:01:29.430]         base::withCallingHandlers({
[11:01:29.430]             ...future.value <- base::withVisible(base::local({
[11:01:29.430]                 withCallingHandlers({
[11:01:29.430]                   2
[11:01:29.430]                 }, immediateCondition = function(cond) {
[11:01:29.430]                   save_rds <- function (object, pathname, ...) 
[11:01:29.430]                   {
[11:01:29.430]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.430]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.430]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.430]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.430]                         fi_tmp[["mtime"]])
[11:01:29.430]                     }
[11:01:29.430]                     tryCatch({
[11:01:29.430]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.430]                     }, error = function(ex) {
[11:01:29.430]                       msg <- conditionMessage(ex)
[11:01:29.430]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.430]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.430]                         fi_tmp[["mtime"]], msg)
[11:01:29.430]                       ex$message <- msg
[11:01:29.430]                       stop(ex)
[11:01:29.430]                     })
[11:01:29.430]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.430]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.430]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.430]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.430]                       fi <- file.info(pathname)
[11:01:29.430]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.430]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.430]                         fi[["size"]], fi[["mtime"]])
[11:01:29.430]                       stop(msg)
[11:01:29.430]                     }
[11:01:29.430]                     invisible(pathname)
[11:01:29.430]                   }
[11:01:29.430]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.430]                     rootPath = tempdir()) 
[11:01:29.430]                   {
[11:01:29.430]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.430]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.430]                       tmpdir = path, fileext = ".rds")
[11:01:29.430]                     save_rds(obj, file)
[11:01:29.430]                   }
[11:01:29.430]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.430]                   {
[11:01:29.430]                     inherits <- base::inherits
[11:01:29.430]                     invokeRestart <- base::invokeRestart
[11:01:29.430]                     is.null <- base::is.null
[11:01:29.430]                     muffled <- FALSE
[11:01:29.430]                     if (inherits(cond, "message")) {
[11:01:29.430]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.430]                       if (muffled) 
[11:01:29.430]                         invokeRestart("muffleMessage")
[11:01:29.430]                     }
[11:01:29.430]                     else if (inherits(cond, "warning")) {
[11:01:29.430]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.430]                       if (muffled) 
[11:01:29.430]                         invokeRestart("muffleWarning")
[11:01:29.430]                     }
[11:01:29.430]                     else if (inherits(cond, "condition")) {
[11:01:29.430]                       if (!is.null(pattern)) {
[11:01:29.430]                         computeRestarts <- base::computeRestarts
[11:01:29.430]                         grepl <- base::grepl
[11:01:29.430]                         restarts <- computeRestarts(cond)
[11:01:29.430]                         for (restart in restarts) {
[11:01:29.430]                           name <- restart$name
[11:01:29.430]                           if (is.null(name)) 
[11:01:29.430]                             next
[11:01:29.430]                           if (!grepl(pattern, name)) 
[11:01:29.430]                             next
[11:01:29.430]                           invokeRestart(restart)
[11:01:29.430]                           muffled <- TRUE
[11:01:29.430]                           break
[11:01:29.430]                         }
[11:01:29.430]                       }
[11:01:29.430]                     }
[11:01:29.430]                     invisible(muffled)
[11:01:29.430]                   }
[11:01:29.430]                   muffleCondition(cond)
[11:01:29.430]                 })
[11:01:29.430]             }))
[11:01:29.430]             future::FutureResult(value = ...future.value$value, 
[11:01:29.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.430]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.430]                     ...future.globalenv.names))
[11:01:29.430]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.430]         }, condition = base::local({
[11:01:29.430]             c <- base::c
[11:01:29.430]             inherits <- base::inherits
[11:01:29.430]             invokeRestart <- base::invokeRestart
[11:01:29.430]             length <- base::length
[11:01:29.430]             list <- base::list
[11:01:29.430]             seq.int <- base::seq.int
[11:01:29.430]             signalCondition <- base::signalCondition
[11:01:29.430]             sys.calls <- base::sys.calls
[11:01:29.430]             `[[` <- base::`[[`
[11:01:29.430]             `+` <- base::`+`
[11:01:29.430]             `<<-` <- base::`<<-`
[11:01:29.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.430]                   3L)]
[11:01:29.430]             }
[11:01:29.430]             function(cond) {
[11:01:29.430]                 is_error <- inherits(cond, "error")
[11:01:29.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.430]                   NULL)
[11:01:29.430]                 if (is_error) {
[11:01:29.430]                   sessionInformation <- function() {
[11:01:29.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.430]                       search = base::search(), system = base::Sys.info())
[11:01:29.430]                   }
[11:01:29.430]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.430]                     cond$call), session = sessionInformation(), 
[11:01:29.430]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.430]                   signalCondition(cond)
[11:01:29.430]                 }
[11:01:29.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.430]                 "immediateCondition"))) {
[11:01:29.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.430]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.430]                   if (TRUE && !signal) {
[11:01:29.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.430]                     {
[11:01:29.430]                       inherits <- base::inherits
[11:01:29.430]                       invokeRestart <- base::invokeRestart
[11:01:29.430]                       is.null <- base::is.null
[11:01:29.430]                       muffled <- FALSE
[11:01:29.430]                       if (inherits(cond, "message")) {
[11:01:29.430]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.430]                         if (muffled) 
[11:01:29.430]                           invokeRestart("muffleMessage")
[11:01:29.430]                       }
[11:01:29.430]                       else if (inherits(cond, "warning")) {
[11:01:29.430]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.430]                         if (muffled) 
[11:01:29.430]                           invokeRestart("muffleWarning")
[11:01:29.430]                       }
[11:01:29.430]                       else if (inherits(cond, "condition")) {
[11:01:29.430]                         if (!is.null(pattern)) {
[11:01:29.430]                           computeRestarts <- base::computeRestarts
[11:01:29.430]                           grepl <- base::grepl
[11:01:29.430]                           restarts <- computeRestarts(cond)
[11:01:29.430]                           for (restart in restarts) {
[11:01:29.430]                             name <- restart$name
[11:01:29.430]                             if (is.null(name)) 
[11:01:29.430]                               next
[11:01:29.430]                             if (!grepl(pattern, name)) 
[11:01:29.430]                               next
[11:01:29.430]                             invokeRestart(restart)
[11:01:29.430]                             muffled <- TRUE
[11:01:29.430]                             break
[11:01:29.430]                           }
[11:01:29.430]                         }
[11:01:29.430]                       }
[11:01:29.430]                       invisible(muffled)
[11:01:29.430]                     }
[11:01:29.430]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.430]                   }
[11:01:29.430]                 }
[11:01:29.430]                 else {
[11:01:29.430]                   if (TRUE) {
[11:01:29.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.430]                     {
[11:01:29.430]                       inherits <- base::inherits
[11:01:29.430]                       invokeRestart <- base::invokeRestart
[11:01:29.430]                       is.null <- base::is.null
[11:01:29.430]                       muffled <- FALSE
[11:01:29.430]                       if (inherits(cond, "message")) {
[11:01:29.430]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.430]                         if (muffled) 
[11:01:29.430]                           invokeRestart("muffleMessage")
[11:01:29.430]                       }
[11:01:29.430]                       else if (inherits(cond, "warning")) {
[11:01:29.430]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.430]                         if (muffled) 
[11:01:29.430]                           invokeRestart("muffleWarning")
[11:01:29.430]                       }
[11:01:29.430]                       else if (inherits(cond, "condition")) {
[11:01:29.430]                         if (!is.null(pattern)) {
[11:01:29.430]                           computeRestarts <- base::computeRestarts
[11:01:29.430]                           grepl <- base::grepl
[11:01:29.430]                           restarts <- computeRestarts(cond)
[11:01:29.430]                           for (restart in restarts) {
[11:01:29.430]                             name <- restart$name
[11:01:29.430]                             if (is.null(name)) 
[11:01:29.430]                               next
[11:01:29.430]                             if (!grepl(pattern, name)) 
[11:01:29.430]                               next
[11:01:29.430]                             invokeRestart(restart)
[11:01:29.430]                             muffled <- TRUE
[11:01:29.430]                             break
[11:01:29.430]                           }
[11:01:29.430]                         }
[11:01:29.430]                       }
[11:01:29.430]                       invisible(muffled)
[11:01:29.430]                     }
[11:01:29.430]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.430]                   }
[11:01:29.430]                 }
[11:01:29.430]             }
[11:01:29.430]         }))
[11:01:29.430]     }, error = function(ex) {
[11:01:29.430]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.430]                 ...future.rng), started = ...future.startTime, 
[11:01:29.430]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.430]             version = "1.8"), class = "FutureResult")
[11:01:29.430]     }, finally = {
[11:01:29.430]         if (!identical(...future.workdir, getwd())) 
[11:01:29.430]             setwd(...future.workdir)
[11:01:29.430]         {
[11:01:29.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.430]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.430]             }
[11:01:29.430]             base::options(...future.oldOptions)
[11:01:29.430]             if (.Platform$OS.type == "windows") {
[11:01:29.430]                 old_names <- names(...future.oldEnvVars)
[11:01:29.430]                 envs <- base::Sys.getenv()
[11:01:29.430]                 names <- names(envs)
[11:01:29.430]                 common <- intersect(names, old_names)
[11:01:29.430]                 added <- setdiff(names, old_names)
[11:01:29.430]                 removed <- setdiff(old_names, names)
[11:01:29.430]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.430]                   envs[common]]
[11:01:29.430]                 NAMES <- toupper(changed)
[11:01:29.430]                 args <- list()
[11:01:29.430]                 for (kk in seq_along(NAMES)) {
[11:01:29.430]                   name <- changed[[kk]]
[11:01:29.430]                   NAME <- NAMES[[kk]]
[11:01:29.430]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.430]                     next
[11:01:29.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.430]                 }
[11:01:29.430]                 NAMES <- toupper(added)
[11:01:29.430]                 for (kk in seq_along(NAMES)) {
[11:01:29.430]                   name <- added[[kk]]
[11:01:29.430]                   NAME <- NAMES[[kk]]
[11:01:29.430]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.430]                     next
[11:01:29.430]                   args[[name]] <- ""
[11:01:29.430]                 }
[11:01:29.430]                 NAMES <- toupper(removed)
[11:01:29.430]                 for (kk in seq_along(NAMES)) {
[11:01:29.430]                   name <- removed[[kk]]
[11:01:29.430]                   NAME <- NAMES[[kk]]
[11:01:29.430]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.430]                     next
[11:01:29.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.430]                 }
[11:01:29.430]                 if (length(args) > 0) 
[11:01:29.430]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.430]             }
[11:01:29.430]             else {
[11:01:29.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.430]             }
[11:01:29.430]             {
[11:01:29.430]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.430]                   0L) {
[11:01:29.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.430]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.430]                   base::options(opts)
[11:01:29.430]                 }
[11:01:29.430]                 {
[11:01:29.430]                   {
[11:01:29.430]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.430]                     NULL
[11:01:29.430]                   }
[11:01:29.430]                   options(future.plan = NULL)
[11:01:29.430]                   if (is.na(NA_character_)) 
[11:01:29.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.430]                     .init = FALSE)
[11:01:29.430]                 }
[11:01:29.430]             }
[11:01:29.430]         }
[11:01:29.430]     })
[11:01:29.430]     if (TRUE) {
[11:01:29.430]         base::sink(type = "output", split = FALSE)
[11:01:29.430]         if (TRUE) {
[11:01:29.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.430]         }
[11:01:29.430]         else {
[11:01:29.430]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.430]         }
[11:01:29.430]         base::close(...future.stdout)
[11:01:29.430]         ...future.stdout <- NULL
[11:01:29.430]     }
[11:01:29.430]     ...future.result$conditions <- ...future.conditions
[11:01:29.430]     ...future.result$finished <- base::Sys.time()
[11:01:29.430]     ...future.result
[11:01:29.430] }
[11:01:29.432] requestCore(): workers = 2
[11:01:29.434] MulticoreFuture started
[11:01:29.435] - Launch lazy future ... done
[11:01:29.435] run() for ‘MulticoreFuture’ ... done
[11:01:29.435] plan(): Setting new future strategy stack:
[11:01:29.435] getGlobalsAndPackages() ...
[11:01:29.436] Searching for globals...
[11:01:29.435] List of future strategies:
[11:01:29.435] 1. sequential:
[11:01:29.435]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.435]    - tweaked: FALSE
[11:01:29.435]    - call: NULL
[11:01:29.437] 
[11:01:29.437] plan(): nbrOfWorkers() = 1
[11:01:29.437] Searching for globals ... DONE
[11:01:29.437] - globals: [0] <none>
[11:01:29.437] getGlobalsAndPackages() ... DONE
[11:01:29.438] run() for ‘Future’ ...
[11:01:29.438] - state: ‘created’
[11:01:29.438] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:29.439] plan(): Setting new future strategy stack:
[11:01:29.439] List of future strategies:
[11:01:29.439] 1. multicore:
[11:01:29.439]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.439]    - tweaked: FALSE
[11:01:29.439]    - call: plan(strategy)
[11:01:29.441] plan(): nbrOfWorkers() = 2
[11:01:29.441] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:29.441] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:29.442]   - Field: ‘label’
[11:01:29.442]   - Field: ‘local’
[11:01:29.442]   - Field: ‘owner’
[11:01:29.442]   - Field: ‘envir’
[11:01:29.442]   - Field: ‘workers’
[11:01:29.442]   - Field: ‘packages’
[11:01:29.443]   - Field: ‘gc’
[11:01:29.443]   - Field: ‘job’
[11:01:29.443]   - Field: ‘conditions’
[11:01:29.443]   - Field: ‘expr’
[11:01:29.443]   - Field: ‘uuid’
[11:01:29.443]   - Field: ‘seed’
[11:01:29.444]   - Field: ‘version’
[11:01:29.444]   - Field: ‘result’
[11:01:29.444]   - Field: ‘asynchronous’
[11:01:29.444]   - Field: ‘calls’
[11:01:29.444]   - Field: ‘globals’
[11:01:29.444]   - Field: ‘stdout’
[11:01:29.444]   - Field: ‘earlySignal’
[11:01:29.444]   - Field: ‘lazy’
[11:01:29.445]   - Field: ‘state’
[11:01:29.445] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:29.445] - Launch lazy future ...
[11:01:29.445] Packages needed by the future expression (n = 0): <none>
[11:01:29.446] Packages needed by future strategies (n = 0): <none>
[11:01:29.446] {
[11:01:29.446]     {
[11:01:29.446]         {
[11:01:29.446]             ...future.startTime <- base::Sys.time()
[11:01:29.446]             {
[11:01:29.446]                 {
[11:01:29.446]                   {
[11:01:29.446]                     {
[11:01:29.446]                       base::local({
[11:01:29.446]                         has_future <- base::requireNamespace("future", 
[11:01:29.446]                           quietly = TRUE)
[11:01:29.446]                         if (has_future) {
[11:01:29.446]                           ns <- base::getNamespace("future")
[11:01:29.446]                           version <- ns[[".package"]][["version"]]
[11:01:29.446]                           if (is.null(version)) 
[11:01:29.446]                             version <- utils::packageVersion("future")
[11:01:29.446]                         }
[11:01:29.446]                         else {
[11:01:29.446]                           version <- NULL
[11:01:29.446]                         }
[11:01:29.446]                         if (!has_future || version < "1.8.0") {
[11:01:29.446]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.446]                             "", base::R.version$version.string), 
[11:01:29.446]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.446]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.446]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.446]                               "release", "version")], collapse = " "), 
[11:01:29.446]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.446]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.446]                             info)
[11:01:29.446]                           info <- base::paste(info, collapse = "; ")
[11:01:29.446]                           if (!has_future) {
[11:01:29.446]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.446]                               info)
[11:01:29.446]                           }
[11:01:29.446]                           else {
[11:01:29.446]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.446]                               info, version)
[11:01:29.446]                           }
[11:01:29.446]                           base::stop(msg)
[11:01:29.446]                         }
[11:01:29.446]                       })
[11:01:29.446]                     }
[11:01:29.446]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.446]                     base::options(mc.cores = 1L)
[11:01:29.446]                   }
[11:01:29.446]                   ...future.strategy.old <- future::plan("list")
[11:01:29.446]                   options(future.plan = NULL)
[11:01:29.446]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.446]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.446]                 }
[11:01:29.446]                 ...future.workdir <- getwd()
[11:01:29.446]             }
[11:01:29.446]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.446]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.446]         }
[11:01:29.446]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.446]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.446]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.446]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.446]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.446]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.446]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.446]             base::names(...future.oldOptions))
[11:01:29.446]     }
[11:01:29.446]     if (FALSE) {
[11:01:29.446]     }
[11:01:29.446]     else {
[11:01:29.446]         if (TRUE) {
[11:01:29.446]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.446]                 open = "w")
[11:01:29.446]         }
[11:01:29.446]         else {
[11:01:29.446]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.446]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.446]         }
[11:01:29.446]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.446]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.446]             base::sink(type = "output", split = FALSE)
[11:01:29.446]             base::close(...future.stdout)
[11:01:29.446]         }, add = TRUE)
[11:01:29.446]     }
[11:01:29.446]     ...future.frame <- base::sys.nframe()
[11:01:29.446]     ...future.conditions <- base::list()
[11:01:29.446]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.446]     if (FALSE) {
[11:01:29.446]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.446]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.446]     }
[11:01:29.446]     ...future.result <- base::tryCatch({
[11:01:29.446]         base::withCallingHandlers({
[11:01:29.446]             ...future.value <- base::withVisible(base::local({
[11:01:29.446]                 withCallingHandlers({
[11:01:29.446]                   NULL
[11:01:29.446]                 }, immediateCondition = function(cond) {
[11:01:29.446]                   save_rds <- function (object, pathname, ...) 
[11:01:29.446]                   {
[11:01:29.446]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:29.446]                     if (file_test("-f", pathname_tmp)) {
[11:01:29.446]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.446]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:29.446]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.446]                         fi_tmp[["mtime"]])
[11:01:29.446]                     }
[11:01:29.446]                     tryCatch({
[11:01:29.446]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:29.446]                     }, error = function(ex) {
[11:01:29.446]                       msg <- conditionMessage(ex)
[11:01:29.446]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.446]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:29.446]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.446]                         fi_tmp[["mtime"]], msg)
[11:01:29.446]                       ex$message <- msg
[11:01:29.446]                       stop(ex)
[11:01:29.446]                     })
[11:01:29.446]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:29.446]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:29.446]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:29.446]                       fi_tmp <- file.info(pathname_tmp)
[11:01:29.446]                       fi <- file.info(pathname)
[11:01:29.446]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:29.446]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:29.446]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:29.446]                         fi[["size"]], fi[["mtime"]])
[11:01:29.446]                       stop(msg)
[11:01:29.446]                     }
[11:01:29.446]                     invisible(pathname)
[11:01:29.446]                   }
[11:01:29.446]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:29.446]                     rootPath = tempdir()) 
[11:01:29.446]                   {
[11:01:29.446]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:29.446]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:29.446]                       tmpdir = path, fileext = ".rds")
[11:01:29.446]                     save_rds(obj, file)
[11:01:29.446]                   }
[11:01:29.446]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:29.446]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.446]                   {
[11:01:29.446]                     inherits <- base::inherits
[11:01:29.446]                     invokeRestart <- base::invokeRestart
[11:01:29.446]                     is.null <- base::is.null
[11:01:29.446]                     muffled <- FALSE
[11:01:29.446]                     if (inherits(cond, "message")) {
[11:01:29.446]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.446]                       if (muffled) 
[11:01:29.446]                         invokeRestart("muffleMessage")
[11:01:29.446]                     }
[11:01:29.446]                     else if (inherits(cond, "warning")) {
[11:01:29.446]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.446]                       if (muffled) 
[11:01:29.446]                         invokeRestart("muffleWarning")
[11:01:29.446]                     }
[11:01:29.446]                     else if (inherits(cond, "condition")) {
[11:01:29.446]                       if (!is.null(pattern)) {
[11:01:29.446]                         computeRestarts <- base::computeRestarts
[11:01:29.446]                         grepl <- base::grepl
[11:01:29.446]                         restarts <- computeRestarts(cond)
[11:01:29.446]                         for (restart in restarts) {
[11:01:29.446]                           name <- restart$name
[11:01:29.446]                           if (is.null(name)) 
[11:01:29.446]                             next
[11:01:29.446]                           if (!grepl(pattern, name)) 
[11:01:29.446]                             next
[11:01:29.446]                           invokeRestart(restart)
[11:01:29.446]                           muffled <- TRUE
[11:01:29.446]                           break
[11:01:29.446]                         }
[11:01:29.446]                       }
[11:01:29.446]                     }
[11:01:29.446]                     invisible(muffled)
[11:01:29.446]                   }
[11:01:29.446]                   muffleCondition(cond)
[11:01:29.446]                 })
[11:01:29.446]             }))
[11:01:29.446]             future::FutureResult(value = ...future.value$value, 
[11:01:29.446]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.446]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.446]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.446]                     ...future.globalenv.names))
[11:01:29.446]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.446]         }, condition = base::local({
[11:01:29.446]             c <- base::c
[11:01:29.446]             inherits <- base::inherits
[11:01:29.446]             invokeRestart <- base::invokeRestart
[11:01:29.446]             length <- base::length
[11:01:29.446]             list <- base::list
[11:01:29.446]             seq.int <- base::seq.int
[11:01:29.446]             signalCondition <- base::signalCondition
[11:01:29.446]             sys.calls <- base::sys.calls
[11:01:29.446]             `[[` <- base::`[[`
[11:01:29.446]             `+` <- base::`+`
[11:01:29.446]             `<<-` <- base::`<<-`
[11:01:29.446]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.446]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.446]                   3L)]
[11:01:29.446]             }
[11:01:29.446]             function(cond) {
[11:01:29.446]                 is_error <- inherits(cond, "error")
[11:01:29.446]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.446]                   NULL)
[11:01:29.446]                 if (is_error) {
[11:01:29.446]                   sessionInformation <- function() {
[11:01:29.446]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.446]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.446]                       search = base::search(), system = base::Sys.info())
[11:01:29.446]                   }
[11:01:29.446]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.446]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.446]                     cond$call), session = sessionInformation(), 
[11:01:29.446]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.446]                   signalCondition(cond)
[11:01:29.446]                 }
[11:01:29.446]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.446]                 "immediateCondition"))) {
[11:01:29.446]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.446]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.446]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.446]                   if (TRUE && !signal) {
[11:01:29.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.446]                     {
[11:01:29.446]                       inherits <- base::inherits
[11:01:29.446]                       invokeRestart <- base::invokeRestart
[11:01:29.446]                       is.null <- base::is.null
[11:01:29.446]                       muffled <- FALSE
[11:01:29.446]                       if (inherits(cond, "message")) {
[11:01:29.446]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.446]                         if (muffled) 
[11:01:29.446]                           invokeRestart("muffleMessage")
[11:01:29.446]                       }
[11:01:29.446]                       else if (inherits(cond, "warning")) {
[11:01:29.446]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.446]                         if (muffled) 
[11:01:29.446]                           invokeRestart("muffleWarning")
[11:01:29.446]                       }
[11:01:29.446]                       else if (inherits(cond, "condition")) {
[11:01:29.446]                         if (!is.null(pattern)) {
[11:01:29.446]                           computeRestarts <- base::computeRestarts
[11:01:29.446]                           grepl <- base::grepl
[11:01:29.446]                           restarts <- computeRestarts(cond)
[11:01:29.446]                           for (restart in restarts) {
[11:01:29.446]                             name <- restart$name
[11:01:29.446]                             if (is.null(name)) 
[11:01:29.446]                               next
[11:01:29.446]                             if (!grepl(pattern, name)) 
[11:01:29.446]                               next
[11:01:29.446]                             invokeRestart(restart)
[11:01:29.446]                             muffled <- TRUE
[11:01:29.446]                             break
[11:01:29.446]                           }
[11:01:29.446]                         }
[11:01:29.446]                       }
[11:01:29.446]                       invisible(muffled)
[11:01:29.446]                     }
[11:01:29.446]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.446]                   }
[11:01:29.446]                 }
[11:01:29.446]                 else {
[11:01:29.446]                   if (TRUE) {
[11:01:29.446]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.446]                     {
[11:01:29.446]                       inherits <- base::inherits
[11:01:29.446]                       invokeRestart <- base::invokeRestart
[11:01:29.446]                       is.null <- base::is.null
[11:01:29.446]                       muffled <- FALSE
[11:01:29.446]                       if (inherits(cond, "message")) {
[11:01:29.446]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.446]                         if (muffled) 
[11:01:29.446]                           invokeRestart("muffleMessage")
[11:01:29.446]                       }
[11:01:29.446]                       else if (inherits(cond, "warning")) {
[11:01:29.446]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.446]                         if (muffled) 
[11:01:29.446]                           invokeRestart("muffleWarning")
[11:01:29.446]                       }
[11:01:29.446]                       else if (inherits(cond, "condition")) {
[11:01:29.446]                         if (!is.null(pattern)) {
[11:01:29.446]                           computeRestarts <- base::computeRestarts
[11:01:29.446]                           grepl <- base::grepl
[11:01:29.446]                           restarts <- computeRestarts(cond)
[11:01:29.446]                           for (restart in restarts) {
[11:01:29.446]                             name <- restart$name
[11:01:29.446]                             if (is.null(name)) 
[11:01:29.446]                               next
[11:01:29.446]                             if (!grepl(pattern, name)) 
[11:01:29.446]                               next
[11:01:29.446]                             invokeRestart(restart)
[11:01:29.446]                             muffled <- TRUE
[11:01:29.446]                             break
[11:01:29.446]                           }
[11:01:29.446]                         }
[11:01:29.446]                       }
[11:01:29.446]                       invisible(muffled)
[11:01:29.446]                     }
[11:01:29.446]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.446]                   }
[11:01:29.446]                 }
[11:01:29.446]             }
[11:01:29.446]         }))
[11:01:29.446]     }, error = function(ex) {
[11:01:29.446]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.446]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.446]                 ...future.rng), started = ...future.startTime, 
[11:01:29.446]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.446]             version = "1.8"), class = "FutureResult")
[11:01:29.446]     }, finally = {
[11:01:29.446]         if (!identical(...future.workdir, getwd())) 
[11:01:29.446]             setwd(...future.workdir)
[11:01:29.446]         {
[11:01:29.446]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.446]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.446]             }
[11:01:29.446]             base::options(...future.oldOptions)
[11:01:29.446]             if (.Platform$OS.type == "windows") {
[11:01:29.446]                 old_names <- names(...future.oldEnvVars)
[11:01:29.446]                 envs <- base::Sys.getenv()
[11:01:29.446]                 names <- names(envs)
[11:01:29.446]                 common <- intersect(names, old_names)
[11:01:29.446]                 added <- setdiff(names, old_names)
[11:01:29.446]                 removed <- setdiff(old_names, names)
[11:01:29.446]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.446]                   envs[common]]
[11:01:29.446]                 NAMES <- toupper(changed)
[11:01:29.446]                 args <- list()
[11:01:29.446]                 for (kk in seq_along(NAMES)) {
[11:01:29.446]                   name <- changed[[kk]]
[11:01:29.446]                   NAME <- NAMES[[kk]]
[11:01:29.446]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.446]                     next
[11:01:29.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.446]                 }
[11:01:29.446]                 NAMES <- toupper(added)
[11:01:29.446]                 for (kk in seq_along(NAMES)) {
[11:01:29.446]                   name <- added[[kk]]
[11:01:29.446]                   NAME <- NAMES[[kk]]
[11:01:29.446]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.446]                     next
[11:01:29.446]                   args[[name]] <- ""
[11:01:29.446]                 }
[11:01:29.446]                 NAMES <- toupper(removed)
[11:01:29.446]                 for (kk in seq_along(NAMES)) {
[11:01:29.446]                   name <- removed[[kk]]
[11:01:29.446]                   NAME <- NAMES[[kk]]
[11:01:29.446]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.446]                     next
[11:01:29.446]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.446]                 }
[11:01:29.446]                 if (length(args) > 0) 
[11:01:29.446]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.446]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.446]             }
[11:01:29.446]             else {
[11:01:29.446]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.446]             }
[11:01:29.446]             {
[11:01:29.446]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.446]                   0L) {
[11:01:29.446]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.446]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.446]                   base::options(opts)
[11:01:29.446]                 }
[11:01:29.446]                 {
[11:01:29.446]                   {
[11:01:29.446]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.446]                     NULL
[11:01:29.446]                   }
[11:01:29.446]                   options(future.plan = NULL)
[11:01:29.446]                   if (is.na(NA_character_)) 
[11:01:29.446]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.446]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.446]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.446]                     .init = FALSE)
[11:01:29.446]                 }
[11:01:29.446]             }
[11:01:29.446]         }
[11:01:29.446]     })
[11:01:29.446]     if (TRUE) {
[11:01:29.446]         base::sink(type = "output", split = FALSE)
[11:01:29.446]         if (TRUE) {
[11:01:29.446]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.446]         }
[11:01:29.446]         else {
[11:01:29.446]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.446]         }
[11:01:29.446]         base::close(...future.stdout)
[11:01:29.446]         ...future.stdout <- NULL
[11:01:29.446]     }
[11:01:29.446]     ...future.result$conditions <- ...future.conditions
[11:01:29.446]     ...future.result$finished <- base::Sys.time()
[11:01:29.446]     ...future.result
[11:01:29.446] }
[11:01:29.450] requestCore(): workers = 2
[11:01:29.452] MulticoreFuture started
[11:01:29.452] - Launch lazy future ... done
[11:01:29.452] run() for ‘MulticoreFuture’ ... done
List of 6
[11:01:29.453] plan(): Setting new future strategy stack:
 $ a: num 1
 $ b:[11:01:29.453] List of future strategies:
[11:01:29.453] 1. sequential:
[11:01:29.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:29.453]    - tweaked: FALSE
[11:01:29.453]    - call: NULL
Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' [11:01:29.454] plan(): nbrOfWorkers() = 1
<environment: 0x55a9c6bd4a28> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4d5e118> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a:[11:01:29.456] plan(): Setting new future strategy stack:
 num 1
 [11:01:29.456] List of future strategies:
[11:01:29.456] 1. multicore:
[11:01:29.456]    - args: function (..., workers = availa$ bleCores(constraints = "multicore"), envir = parent.frame())
[11:01:29.456]    - tweaked: FALSE
[11:01:29.456]    - call: plan(sbtrategy)
:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c6bd4a28> 
 $ c:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4d5e118> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=[11:01:29.459] plan(): nbrOfWorkers() = 2
List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:29.464] resolve() on list ...
[11:01:29.464]  recursive: 0
[11:01:29.465]  length: 6
[11:01:29.465]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:29.465] signalConditionsASAP(numeric, pos=1) ...
[11:01:29.465] - nx: 6
[11:01:29.465] - relay: TRUE
[11:01:29.465] - stdout: TRUE
[11:01:29.465] - signal: TRUE
[11:01:29.466] - resignal: FALSE
[11:01:29.466] - force: TRUE
[11:01:29.466] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.466] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.466]  - until=2
[11:01:29.466]  - relaying element #2
[11:01:29.466] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.467] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.467] signalConditionsASAP(NULL, pos=1) ... done
[11:01:29.467]  length: 5 (resolved future 1)
[11:01:29.467] Future #2
[11:01:29.467] result() for MulticoreFuture ...
[11:01:29.468] result() for MulticoreFuture ...
[11:01:29.468] result() for MulticoreFuture ... done
[11:01:29.469] result() for MulticoreFuture ... done
[11:01:29.469] result() for MulticoreFuture ...
[11:01:29.469] result() for MulticoreFuture ... done
[11:01:29.469] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:29.469] - nx: 6
[11:01:29.469] - relay: TRUE
[11:01:29.469] - stdout: TRUE
[11:01:29.469] - signal: TRUE
[11:01:29.470] - resignal: FALSE
[11:01:29.470] - force: TRUE
[11:01:29.470] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.470] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:29.470]  - until=2
[11:01:29.470]  - relaying element #2
[11:01:29.470] result() for MulticoreFuture ...
[11:01:29.470] result() for MulticoreFuture ... done
[11:01:29.471] result() for MulticoreFuture ...
[11:01:29.471] result() for MulticoreFuture ... done
[11:01:29.471] result() for MulticoreFuture ...
[11:01:29.471] result() for MulticoreFuture ... done
[11:01:29.471] result() for MulticoreFuture ...
[11:01:29.471] result() for MulticoreFuture ... done
[11:01:29.471] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.472] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.472] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:29.472]  length: 4 (resolved future 2)
[11:01:29.472] Future #3
[11:01:29.472] result() for MulticoreFuture ...
[11:01:29.475] result() for MulticoreFuture ...
[11:01:29.476] result() for MulticoreFuture ... done
[11:01:29.476] result() for MulticoreFuture ... done
[11:01:29.476] result() for MulticoreFuture ...
[11:01:29.476] result() for MulticoreFuture ... done
[11:01:29.476] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:29.476] - nx: 6
[11:01:29.477] - relay: TRUE
[11:01:29.477] - stdout: TRUE
[11:01:29.477] - signal: TRUE
[11:01:29.477] - resignal: FALSE
[11:01:29.477] - force: TRUE
[11:01:29.477] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.477] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:29.478]  - until=3
[11:01:29.478]  - relaying element #3
[11:01:29.478] result() for MulticoreFuture ...
[11:01:29.478] result() for MulticoreFuture ... done
[11:01:29.478] result() for MulticoreFuture ...
[11:01:29.478] result() for MulticoreFuture ... done
[11:01:29.478] result() for MulticoreFuture ...
[11:01:29.478] result() for MulticoreFuture ... done
[11:01:29.479] result() for MulticoreFuture ...
[11:01:29.479] result() for MulticoreFuture ... done
[11:01:29.479] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.479] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.479] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:29.479]  length: 3 (resolved future 3)
[11:01:29.479] signalConditionsASAP(NULL, pos=4) ...
[11:01:29.479] - nx: 6
[11:01:29.479] - relay: TRUE
[11:01:29.480] - stdout: TRUE
[11:01:29.480] - signal: TRUE
[11:01:29.480] - resignal: FALSE
[11:01:29.480] - force: TRUE
[11:01:29.480] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.480] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.480]  - until=5
[11:01:29.480]  - relaying element #5
[11:01:29.480] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.481] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.481] signalConditionsASAP(NULL, pos=4) ... done
[11:01:29.481]  length: 2 (resolved future 4)
[11:01:29.481] signalConditionsASAP(NULL, pos=5) ...
[11:01:29.481] - nx: 6
[11:01:29.481] - relay: TRUE
[11:01:29.481] - stdout: TRUE
[11:01:29.481] - signal: TRUE
[11:01:29.481] - resignal: FALSE
[11:01:29.482] - force: TRUE
[11:01:29.482] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:29.482] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.482]  - until=6
[11:01:29.482]  - relaying element #6
[11:01:29.482] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.482] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.482] signalConditionsASAP(NULL, pos=5) ... done
[11:01:29.482]  length: 1 (resolved future 5)
[11:01:29.482] signalConditionsASAP(numeric, pos=6) ...
[11:01:29.483] - nx: 6
[11:01:29.483] - relay: TRUE
[11:01:29.483] - stdout: TRUE
[11:01:29.483] - signal: TRUE
[11:01:29.483] - resignal: FALSE
[11:01:29.483] - force: TRUE
[11:01:29.483] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:29.483] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.483]  - until=6
[11:01:29.483] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.484] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.484] signalConditionsASAP(numeric, pos=6) ... done
[11:01:29.484]  length: 0 (resolved future 6)
[11:01:29.484] Relaying remaining futures
[11:01:29.484] signalConditionsASAP(NULL, pos=0) ...
[11:01:29.484] - nx: 6
[11:01:29.484] - relay: TRUE
[11:01:29.484] - stdout: TRUE
[11:01:29.484] - signal: TRUE
[11:01:29.484] - resignal: FALSE
[11:01:29.485] - force: TRUE
[11:01:29.485] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.485] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:29.485] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:29.485] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:29.485] signalConditionsASAP(NULL, pos=0) ... done
[11:01:29.485] resolve() on list ... DONE
[11:01:29.485] result() for MulticoreFuture ...
[11:01:29.485] result() for MulticoreFuture ... done
[11:01:29.485] result() for MulticoreFuture ...
[11:01:29.486] result() for MulticoreFuture ... done
[11:01:29.486] result() for MulticoreFuture ...
[11:01:29.486] result() for MulticoreFuture ... done
[11:01:29.486] result() for MulticoreFuture ...
[11:01:29.486] result() for MulticoreFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[11:01:29.490] plan(): Setting new future strategy stack:
[11:01:29.490] List of future strategies:
[11:01:29.490] 1. multisession:
[11:01:29.490]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:29.490]    - tweaked: FALSE
[11:01:29.490]    - call: plan(strategy)
[11:01:29.490] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:01:29.490] multisession:
[11:01:29.490] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:29.490] - tweaked: FALSE
[11:01:29.490] - call: plan(strategy)
[11:01:29.494] getGlobalsAndPackages() ...
[11:01:29.494] Not searching for globals
[11:01:29.494] - globals: [0] <none>
[11:01:29.494] getGlobalsAndPackages() ... DONE
[11:01:29.972] Packages needed by the future expression (n = 0): <none>
[11:01:29.973] Packages needed by future strategies (n = 0): <none>
[11:01:29.973] {
[11:01:29.973]     {
[11:01:29.973]         {
[11:01:29.973]             ...future.startTime <- base::Sys.time()
[11:01:29.973]             {
[11:01:29.973]                 {
[11:01:29.973]                   {
[11:01:29.973]                     {
[11:01:29.973]                       base::local({
[11:01:29.973]                         has_future <- base::requireNamespace("future", 
[11:01:29.973]                           quietly = TRUE)
[11:01:29.973]                         if (has_future) {
[11:01:29.973]                           ns <- base::getNamespace("future")
[11:01:29.973]                           version <- ns[[".package"]][["version"]]
[11:01:29.973]                           if (is.null(version)) 
[11:01:29.973]                             version <- utils::packageVersion("future")
[11:01:29.973]                         }
[11:01:29.973]                         else {
[11:01:29.973]                           version <- NULL
[11:01:29.973]                         }
[11:01:29.973]                         if (!has_future || version < "1.8.0") {
[11:01:29.973]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:29.973]                             "", base::R.version$version.string), 
[11:01:29.973]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:29.973]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:29.973]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:29.973]                               "release", "version")], collapse = " "), 
[11:01:29.973]                             hostname = base::Sys.info()[["nodename"]])
[11:01:29.973]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:29.973]                             info)
[11:01:29.973]                           info <- base::paste(info, collapse = "; ")
[11:01:29.973]                           if (!has_future) {
[11:01:29.973]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:29.973]                               info)
[11:01:29.973]                           }
[11:01:29.973]                           else {
[11:01:29.973]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:29.973]                               info, version)
[11:01:29.973]                           }
[11:01:29.973]                           base::stop(msg)
[11:01:29.973]                         }
[11:01:29.973]                       })
[11:01:29.973]                     }
[11:01:29.973]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:29.973]                     base::options(mc.cores = 1L)
[11:01:29.973]                   }
[11:01:29.973]                   ...future.strategy.old <- future::plan("list")
[11:01:29.973]                   options(future.plan = NULL)
[11:01:29.973]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.973]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:29.973]                 }
[11:01:29.973]                 ...future.workdir <- getwd()
[11:01:29.973]             }
[11:01:29.973]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:29.973]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:29.973]         }
[11:01:29.973]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:29.973]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:29.973]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:29.973]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:29.973]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:29.973]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:29.973]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:29.973]             base::names(...future.oldOptions))
[11:01:29.973]     }
[11:01:29.973]     if (FALSE) {
[11:01:29.973]     }
[11:01:29.973]     else {
[11:01:29.973]         if (TRUE) {
[11:01:29.973]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:29.973]                 open = "w")
[11:01:29.973]         }
[11:01:29.973]         else {
[11:01:29.973]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:29.973]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:29.973]         }
[11:01:29.973]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:29.973]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:29.973]             base::sink(type = "output", split = FALSE)
[11:01:29.973]             base::close(...future.stdout)
[11:01:29.973]         }, add = TRUE)
[11:01:29.973]     }
[11:01:29.973]     ...future.frame <- base::sys.nframe()
[11:01:29.973]     ...future.conditions <- base::list()
[11:01:29.973]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:29.973]     if (FALSE) {
[11:01:29.973]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:29.973]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:29.973]     }
[11:01:29.973]     ...future.result <- base::tryCatch({
[11:01:29.973]         base::withCallingHandlers({
[11:01:29.973]             ...future.value <- base::withVisible(base::local({
[11:01:29.973]                 ...future.makeSendCondition <- base::local({
[11:01:29.973]                   sendCondition <- NULL
[11:01:29.973]                   function(frame = 1L) {
[11:01:29.973]                     if (is.function(sendCondition)) 
[11:01:29.973]                       return(sendCondition)
[11:01:29.973]                     ns <- getNamespace("parallel")
[11:01:29.973]                     if (exists("sendData", mode = "function", 
[11:01:29.973]                       envir = ns)) {
[11:01:29.973]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:29.973]                         envir = ns)
[11:01:29.973]                       envir <- sys.frame(frame)
[11:01:29.973]                       master <- NULL
[11:01:29.973]                       while (!identical(envir, .GlobalEnv) && 
[11:01:29.973]                         !identical(envir, emptyenv())) {
[11:01:29.973]                         if (exists("master", mode = "list", envir = envir, 
[11:01:29.973]                           inherits = FALSE)) {
[11:01:29.973]                           master <- get("master", mode = "list", 
[11:01:29.973]                             envir = envir, inherits = FALSE)
[11:01:29.973]                           if (inherits(master, c("SOCKnode", 
[11:01:29.973]                             "SOCK0node"))) {
[11:01:29.973]                             sendCondition <<- function(cond) {
[11:01:29.973]                               data <- list(type = "VALUE", value = cond, 
[11:01:29.973]                                 success = TRUE)
[11:01:29.973]                               parallel_sendData(master, data)
[11:01:29.973]                             }
[11:01:29.973]                             return(sendCondition)
[11:01:29.973]                           }
[11:01:29.973]                         }
[11:01:29.973]                         frame <- frame + 1L
[11:01:29.973]                         envir <- sys.frame(frame)
[11:01:29.973]                       }
[11:01:29.973]                     }
[11:01:29.973]                     sendCondition <<- function(cond) NULL
[11:01:29.973]                   }
[11:01:29.973]                 })
[11:01:29.973]                 withCallingHandlers({
[11:01:29.973]                   NA
[11:01:29.973]                 }, immediateCondition = function(cond) {
[11:01:29.973]                   sendCondition <- ...future.makeSendCondition()
[11:01:29.973]                   sendCondition(cond)
[11:01:29.973]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.973]                   {
[11:01:29.973]                     inherits <- base::inherits
[11:01:29.973]                     invokeRestart <- base::invokeRestart
[11:01:29.973]                     is.null <- base::is.null
[11:01:29.973]                     muffled <- FALSE
[11:01:29.973]                     if (inherits(cond, "message")) {
[11:01:29.973]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:29.973]                       if (muffled) 
[11:01:29.973]                         invokeRestart("muffleMessage")
[11:01:29.973]                     }
[11:01:29.973]                     else if (inherits(cond, "warning")) {
[11:01:29.973]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:29.973]                       if (muffled) 
[11:01:29.973]                         invokeRestart("muffleWarning")
[11:01:29.973]                     }
[11:01:29.973]                     else if (inherits(cond, "condition")) {
[11:01:29.973]                       if (!is.null(pattern)) {
[11:01:29.973]                         computeRestarts <- base::computeRestarts
[11:01:29.973]                         grepl <- base::grepl
[11:01:29.973]                         restarts <- computeRestarts(cond)
[11:01:29.973]                         for (restart in restarts) {
[11:01:29.973]                           name <- restart$name
[11:01:29.973]                           if (is.null(name)) 
[11:01:29.973]                             next
[11:01:29.973]                           if (!grepl(pattern, name)) 
[11:01:29.973]                             next
[11:01:29.973]                           invokeRestart(restart)
[11:01:29.973]                           muffled <- TRUE
[11:01:29.973]                           break
[11:01:29.973]                         }
[11:01:29.973]                       }
[11:01:29.973]                     }
[11:01:29.973]                     invisible(muffled)
[11:01:29.973]                   }
[11:01:29.973]                   muffleCondition(cond)
[11:01:29.973]                 })
[11:01:29.973]             }))
[11:01:29.973]             future::FutureResult(value = ...future.value$value, 
[11:01:29.973]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.973]                   ...future.rng), globalenv = if (FALSE) 
[11:01:29.973]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:29.973]                     ...future.globalenv.names))
[11:01:29.973]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:29.973]         }, condition = base::local({
[11:01:29.973]             c <- base::c
[11:01:29.973]             inherits <- base::inherits
[11:01:29.973]             invokeRestart <- base::invokeRestart
[11:01:29.973]             length <- base::length
[11:01:29.973]             list <- base::list
[11:01:29.973]             seq.int <- base::seq.int
[11:01:29.973]             signalCondition <- base::signalCondition
[11:01:29.973]             sys.calls <- base::sys.calls
[11:01:29.973]             `[[` <- base::`[[`
[11:01:29.973]             `+` <- base::`+`
[11:01:29.973]             `<<-` <- base::`<<-`
[11:01:29.973]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:29.973]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:29.973]                   3L)]
[11:01:29.973]             }
[11:01:29.973]             function(cond) {
[11:01:29.973]                 is_error <- inherits(cond, "error")
[11:01:29.973]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:29.973]                   NULL)
[11:01:29.973]                 if (is_error) {
[11:01:29.973]                   sessionInformation <- function() {
[11:01:29.973]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:29.973]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:29.973]                       search = base::search(), system = base::Sys.info())
[11:01:29.973]                   }
[11:01:29.973]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.973]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:29.973]                     cond$call), session = sessionInformation(), 
[11:01:29.973]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:29.973]                   signalCondition(cond)
[11:01:29.973]                 }
[11:01:29.973]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:29.973]                 "immediateCondition"))) {
[11:01:29.973]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:29.973]                   ...future.conditions[[length(...future.conditions) + 
[11:01:29.973]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:29.973]                   if (TRUE && !signal) {
[11:01:29.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.973]                     {
[11:01:29.973]                       inherits <- base::inherits
[11:01:29.973]                       invokeRestart <- base::invokeRestart
[11:01:29.973]                       is.null <- base::is.null
[11:01:29.973]                       muffled <- FALSE
[11:01:29.973]                       if (inherits(cond, "message")) {
[11:01:29.973]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.973]                         if (muffled) 
[11:01:29.973]                           invokeRestart("muffleMessage")
[11:01:29.973]                       }
[11:01:29.973]                       else if (inherits(cond, "warning")) {
[11:01:29.973]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.973]                         if (muffled) 
[11:01:29.973]                           invokeRestart("muffleWarning")
[11:01:29.973]                       }
[11:01:29.973]                       else if (inherits(cond, "condition")) {
[11:01:29.973]                         if (!is.null(pattern)) {
[11:01:29.973]                           computeRestarts <- base::computeRestarts
[11:01:29.973]                           grepl <- base::grepl
[11:01:29.973]                           restarts <- computeRestarts(cond)
[11:01:29.973]                           for (restart in restarts) {
[11:01:29.973]                             name <- restart$name
[11:01:29.973]                             if (is.null(name)) 
[11:01:29.973]                               next
[11:01:29.973]                             if (!grepl(pattern, name)) 
[11:01:29.973]                               next
[11:01:29.973]                             invokeRestart(restart)
[11:01:29.973]                             muffled <- TRUE
[11:01:29.973]                             break
[11:01:29.973]                           }
[11:01:29.973]                         }
[11:01:29.973]                       }
[11:01:29.973]                       invisible(muffled)
[11:01:29.973]                     }
[11:01:29.973]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.973]                   }
[11:01:29.973]                 }
[11:01:29.973]                 else {
[11:01:29.973]                   if (TRUE) {
[11:01:29.973]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:29.973]                     {
[11:01:29.973]                       inherits <- base::inherits
[11:01:29.973]                       invokeRestart <- base::invokeRestart
[11:01:29.973]                       is.null <- base::is.null
[11:01:29.973]                       muffled <- FALSE
[11:01:29.973]                       if (inherits(cond, "message")) {
[11:01:29.973]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:29.973]                         if (muffled) 
[11:01:29.973]                           invokeRestart("muffleMessage")
[11:01:29.973]                       }
[11:01:29.973]                       else if (inherits(cond, "warning")) {
[11:01:29.973]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:29.973]                         if (muffled) 
[11:01:29.973]                           invokeRestart("muffleWarning")
[11:01:29.973]                       }
[11:01:29.973]                       else if (inherits(cond, "condition")) {
[11:01:29.973]                         if (!is.null(pattern)) {
[11:01:29.973]                           computeRestarts <- base::computeRestarts
[11:01:29.973]                           grepl <- base::grepl
[11:01:29.973]                           restarts <- computeRestarts(cond)
[11:01:29.973]                           for (restart in restarts) {
[11:01:29.973]                             name <- restart$name
[11:01:29.973]                             if (is.null(name)) 
[11:01:29.973]                               next
[11:01:29.973]                             if (!grepl(pattern, name)) 
[11:01:29.973]                               next
[11:01:29.973]                             invokeRestart(restart)
[11:01:29.973]                             muffled <- TRUE
[11:01:29.973]                             break
[11:01:29.973]                           }
[11:01:29.973]                         }
[11:01:29.973]                       }
[11:01:29.973]                       invisible(muffled)
[11:01:29.973]                     }
[11:01:29.973]                     muffleCondition(cond, pattern = "^muffle")
[11:01:29.973]                   }
[11:01:29.973]                 }
[11:01:29.973]             }
[11:01:29.973]         }))
[11:01:29.973]     }, error = function(ex) {
[11:01:29.973]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:29.973]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:29.973]                 ...future.rng), started = ...future.startTime, 
[11:01:29.973]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:29.973]             version = "1.8"), class = "FutureResult")
[11:01:29.973]     }, finally = {
[11:01:29.973]         if (!identical(...future.workdir, getwd())) 
[11:01:29.973]             setwd(...future.workdir)
[11:01:29.973]         {
[11:01:29.973]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:29.973]                 ...future.oldOptions$nwarnings <- NULL
[11:01:29.973]             }
[11:01:29.973]             base::options(...future.oldOptions)
[11:01:29.973]             if (.Platform$OS.type == "windows") {
[11:01:29.973]                 old_names <- names(...future.oldEnvVars)
[11:01:29.973]                 envs <- base::Sys.getenv()
[11:01:29.973]                 names <- names(envs)
[11:01:29.973]                 common <- intersect(names, old_names)
[11:01:29.973]                 added <- setdiff(names, old_names)
[11:01:29.973]                 removed <- setdiff(old_names, names)
[11:01:29.973]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:29.973]                   envs[common]]
[11:01:29.973]                 NAMES <- toupper(changed)
[11:01:29.973]                 args <- list()
[11:01:29.973]                 for (kk in seq_along(NAMES)) {
[11:01:29.973]                   name <- changed[[kk]]
[11:01:29.973]                   NAME <- NAMES[[kk]]
[11:01:29.973]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.973]                     next
[11:01:29.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.973]                 }
[11:01:29.973]                 NAMES <- toupper(added)
[11:01:29.973]                 for (kk in seq_along(NAMES)) {
[11:01:29.973]                   name <- added[[kk]]
[11:01:29.973]                   NAME <- NAMES[[kk]]
[11:01:29.973]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.973]                     next
[11:01:29.973]                   args[[name]] <- ""
[11:01:29.973]                 }
[11:01:29.973]                 NAMES <- toupper(removed)
[11:01:29.973]                 for (kk in seq_along(NAMES)) {
[11:01:29.973]                   name <- removed[[kk]]
[11:01:29.973]                   NAME <- NAMES[[kk]]
[11:01:29.973]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:29.973]                     next
[11:01:29.973]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:29.973]                 }
[11:01:29.973]                 if (length(args) > 0) 
[11:01:29.973]                   base::do.call(base::Sys.setenv, args = args)
[11:01:29.973]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:29.973]             }
[11:01:29.973]             else {
[11:01:29.973]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:29.973]             }
[11:01:29.973]             {
[11:01:29.973]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:29.973]                   0L) {
[11:01:29.973]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:29.973]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:29.973]                   base::options(opts)
[11:01:29.973]                 }
[11:01:29.973]                 {
[11:01:29.973]                   {
[11:01:29.973]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:29.973]                     NULL
[11:01:29.973]                   }
[11:01:29.973]                   options(future.plan = NULL)
[11:01:29.973]                   if (is.na(NA_character_)) 
[11:01:29.973]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:29.973]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:29.973]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:29.973]                     .init = FALSE)
[11:01:29.973]                 }
[11:01:29.973]             }
[11:01:29.973]         }
[11:01:29.973]     })
[11:01:29.973]     if (TRUE) {
[11:01:29.973]         base::sink(type = "output", split = FALSE)
[11:01:29.973]         if (TRUE) {
[11:01:29.973]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:29.973]         }
[11:01:29.973]         else {
[11:01:29.973]             ...future.result["stdout"] <- base::list(NULL)
[11:01:29.973]         }
[11:01:29.973]         base::close(...future.stdout)
[11:01:29.973]         ...future.stdout <- NULL
[11:01:29.973]     }
[11:01:29.973]     ...future.result$conditions <- ...future.conditions
[11:01:29.973]     ...future.result$finished <- base::Sys.time()
[11:01:29.973]     ...future.result
[11:01:29.973] }
[11:01:30.024] MultisessionFuture started
[11:01:30.024] result() for ClusterFuture ...
[11:01:30.024] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.025] - Validating connection of MultisessionFuture
[11:01:30.055] - received message: FutureResult
[11:01:30.055] - Received FutureResult
[11:01:30.055] - Erased future from FutureRegistry
[11:01:30.055] result() for ClusterFuture ...
[11:01:30.055] - result already collected: FutureResult
[11:01:30.055] result() for ClusterFuture ... done
[11:01:30.056] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.056] result() for ClusterFuture ... done
[11:01:30.056] result() for ClusterFuture ...
[11:01:30.056] - result already collected: FutureResult
[11:01:30.056] result() for ClusterFuture ... done
[11:01:30.056] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:01:30.058] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[11:01:30.058] getGlobalsAndPackages() ...
[11:01:30.058] Searching for globals...
[11:01:30.058] 
[11:01:30.058] Searching for globals ... DONE
[11:01:30.058] - globals: [0] <none>
[11:01:30.058] getGlobalsAndPackages() ... DONE
[11:01:30.059] run() for ‘Future’ ...
[11:01:30.059] - state: ‘created’
[11:01:30.059] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.073] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.073] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.074]   - Field: ‘node’
[11:01:30.074]   - Field: ‘label’
[11:01:30.074]   - Field: ‘local’
[11:01:30.074]   - Field: ‘owner’
[11:01:30.074]   - Field: ‘envir’
[11:01:30.074]   - Field: ‘workers’
[11:01:30.074]   - Field: ‘packages’
[11:01:30.074]   - Field: ‘gc’
[11:01:30.074]   - Field: ‘conditions’
[11:01:30.074]   - Field: ‘persistent’
[11:01:30.074]   - Field: ‘expr’
[11:01:30.075]   - Field: ‘uuid’
[11:01:30.075]   - Field: ‘seed’
[11:01:30.075]   - Field: ‘version’
[11:01:30.075]   - Field: ‘result’
[11:01:30.075]   - Field: ‘asynchronous’
[11:01:30.075]   - Field: ‘calls’
[11:01:30.075]   - Field: ‘globals’
[11:01:30.075]   - Field: ‘stdout’
[11:01:30.075]   - Field: ‘earlySignal’
[11:01:30.075]   - Field: ‘lazy’
[11:01:30.075]   - Field: ‘state’
[11:01:30.075] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.076] - Launch lazy future ...
[11:01:30.076] Packages needed by the future expression (n = 0): <none>
[11:01:30.076] Packages needed by future strategies (n = 0): <none>
[11:01:30.076] {
[11:01:30.076]     {
[11:01:30.076]         {
[11:01:30.076]             ...future.startTime <- base::Sys.time()
[11:01:30.076]             {
[11:01:30.076]                 {
[11:01:30.076]                   {
[11:01:30.076]                     {
[11:01:30.076]                       base::local({
[11:01:30.076]                         has_future <- base::requireNamespace("future", 
[11:01:30.076]                           quietly = TRUE)
[11:01:30.076]                         if (has_future) {
[11:01:30.076]                           ns <- base::getNamespace("future")
[11:01:30.076]                           version <- ns[[".package"]][["version"]]
[11:01:30.076]                           if (is.null(version)) 
[11:01:30.076]                             version <- utils::packageVersion("future")
[11:01:30.076]                         }
[11:01:30.076]                         else {
[11:01:30.076]                           version <- NULL
[11:01:30.076]                         }
[11:01:30.076]                         if (!has_future || version < "1.8.0") {
[11:01:30.076]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.076]                             "", base::R.version$version.string), 
[11:01:30.076]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.076]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.076]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.076]                               "release", "version")], collapse = " "), 
[11:01:30.076]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.076]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.076]                             info)
[11:01:30.076]                           info <- base::paste(info, collapse = "; ")
[11:01:30.076]                           if (!has_future) {
[11:01:30.076]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.076]                               info)
[11:01:30.076]                           }
[11:01:30.076]                           else {
[11:01:30.076]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.076]                               info, version)
[11:01:30.076]                           }
[11:01:30.076]                           base::stop(msg)
[11:01:30.076]                         }
[11:01:30.076]                       })
[11:01:30.076]                     }
[11:01:30.076]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.076]                     base::options(mc.cores = 1L)
[11:01:30.076]                   }
[11:01:30.076]                   ...future.strategy.old <- future::plan("list")
[11:01:30.076]                   options(future.plan = NULL)
[11:01:30.076]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.076]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.076]                 }
[11:01:30.076]                 ...future.workdir <- getwd()
[11:01:30.076]             }
[11:01:30.076]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.076]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.076]         }
[11:01:30.076]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.076]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.076]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.076]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.076]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.076]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.076]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.076]             base::names(...future.oldOptions))
[11:01:30.076]     }
[11:01:30.076]     if (FALSE) {
[11:01:30.076]     }
[11:01:30.076]     else {
[11:01:30.076]         if (TRUE) {
[11:01:30.076]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.076]                 open = "w")
[11:01:30.076]         }
[11:01:30.076]         else {
[11:01:30.076]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.076]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.076]         }
[11:01:30.076]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.076]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.076]             base::sink(type = "output", split = FALSE)
[11:01:30.076]             base::close(...future.stdout)
[11:01:30.076]         }, add = TRUE)
[11:01:30.076]     }
[11:01:30.076]     ...future.frame <- base::sys.nframe()
[11:01:30.076]     ...future.conditions <- base::list()
[11:01:30.076]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.076]     if (FALSE) {
[11:01:30.076]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.076]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.076]     }
[11:01:30.076]     ...future.result <- base::tryCatch({
[11:01:30.076]         base::withCallingHandlers({
[11:01:30.076]             ...future.value <- base::withVisible(base::local({
[11:01:30.076]                 ...future.makeSendCondition <- base::local({
[11:01:30.076]                   sendCondition <- NULL
[11:01:30.076]                   function(frame = 1L) {
[11:01:30.076]                     if (is.function(sendCondition)) 
[11:01:30.076]                       return(sendCondition)
[11:01:30.076]                     ns <- getNamespace("parallel")
[11:01:30.076]                     if (exists("sendData", mode = "function", 
[11:01:30.076]                       envir = ns)) {
[11:01:30.076]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.076]                         envir = ns)
[11:01:30.076]                       envir <- sys.frame(frame)
[11:01:30.076]                       master <- NULL
[11:01:30.076]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.076]                         !identical(envir, emptyenv())) {
[11:01:30.076]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.076]                           inherits = FALSE)) {
[11:01:30.076]                           master <- get("master", mode = "list", 
[11:01:30.076]                             envir = envir, inherits = FALSE)
[11:01:30.076]                           if (inherits(master, c("SOCKnode", 
[11:01:30.076]                             "SOCK0node"))) {
[11:01:30.076]                             sendCondition <<- function(cond) {
[11:01:30.076]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.076]                                 success = TRUE)
[11:01:30.076]                               parallel_sendData(master, data)
[11:01:30.076]                             }
[11:01:30.076]                             return(sendCondition)
[11:01:30.076]                           }
[11:01:30.076]                         }
[11:01:30.076]                         frame <- frame + 1L
[11:01:30.076]                         envir <- sys.frame(frame)
[11:01:30.076]                       }
[11:01:30.076]                     }
[11:01:30.076]                     sendCondition <<- function(cond) NULL
[11:01:30.076]                   }
[11:01:30.076]                 })
[11:01:30.076]                 withCallingHandlers({
[11:01:30.076]                   2
[11:01:30.076]                 }, immediateCondition = function(cond) {
[11:01:30.076]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.076]                   sendCondition(cond)
[11:01:30.076]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.076]                   {
[11:01:30.076]                     inherits <- base::inherits
[11:01:30.076]                     invokeRestart <- base::invokeRestart
[11:01:30.076]                     is.null <- base::is.null
[11:01:30.076]                     muffled <- FALSE
[11:01:30.076]                     if (inherits(cond, "message")) {
[11:01:30.076]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.076]                       if (muffled) 
[11:01:30.076]                         invokeRestart("muffleMessage")
[11:01:30.076]                     }
[11:01:30.076]                     else if (inherits(cond, "warning")) {
[11:01:30.076]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.076]                       if (muffled) 
[11:01:30.076]                         invokeRestart("muffleWarning")
[11:01:30.076]                     }
[11:01:30.076]                     else if (inherits(cond, "condition")) {
[11:01:30.076]                       if (!is.null(pattern)) {
[11:01:30.076]                         computeRestarts <- base::computeRestarts
[11:01:30.076]                         grepl <- base::grepl
[11:01:30.076]                         restarts <- computeRestarts(cond)
[11:01:30.076]                         for (restart in restarts) {
[11:01:30.076]                           name <- restart$name
[11:01:30.076]                           if (is.null(name)) 
[11:01:30.076]                             next
[11:01:30.076]                           if (!grepl(pattern, name)) 
[11:01:30.076]                             next
[11:01:30.076]                           invokeRestart(restart)
[11:01:30.076]                           muffled <- TRUE
[11:01:30.076]                           break
[11:01:30.076]                         }
[11:01:30.076]                       }
[11:01:30.076]                     }
[11:01:30.076]                     invisible(muffled)
[11:01:30.076]                   }
[11:01:30.076]                   muffleCondition(cond)
[11:01:30.076]                 })
[11:01:30.076]             }))
[11:01:30.076]             future::FutureResult(value = ...future.value$value, 
[11:01:30.076]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.076]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.076]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.076]                     ...future.globalenv.names))
[11:01:30.076]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.076]         }, condition = base::local({
[11:01:30.076]             c <- base::c
[11:01:30.076]             inherits <- base::inherits
[11:01:30.076]             invokeRestart <- base::invokeRestart
[11:01:30.076]             length <- base::length
[11:01:30.076]             list <- base::list
[11:01:30.076]             seq.int <- base::seq.int
[11:01:30.076]             signalCondition <- base::signalCondition
[11:01:30.076]             sys.calls <- base::sys.calls
[11:01:30.076]             `[[` <- base::`[[`
[11:01:30.076]             `+` <- base::`+`
[11:01:30.076]             `<<-` <- base::`<<-`
[11:01:30.076]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.076]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.076]                   3L)]
[11:01:30.076]             }
[11:01:30.076]             function(cond) {
[11:01:30.076]                 is_error <- inherits(cond, "error")
[11:01:30.076]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.076]                   NULL)
[11:01:30.076]                 if (is_error) {
[11:01:30.076]                   sessionInformation <- function() {
[11:01:30.076]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.076]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.076]                       search = base::search(), system = base::Sys.info())
[11:01:30.076]                   }
[11:01:30.076]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.076]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.076]                     cond$call), session = sessionInformation(), 
[11:01:30.076]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.076]                   signalCondition(cond)
[11:01:30.076]                 }
[11:01:30.076]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.076]                 "immediateCondition"))) {
[11:01:30.076]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.076]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.076]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.076]                   if (TRUE && !signal) {
[11:01:30.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.076]                     {
[11:01:30.076]                       inherits <- base::inherits
[11:01:30.076]                       invokeRestart <- base::invokeRestart
[11:01:30.076]                       is.null <- base::is.null
[11:01:30.076]                       muffled <- FALSE
[11:01:30.076]                       if (inherits(cond, "message")) {
[11:01:30.076]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.076]                         if (muffled) 
[11:01:30.076]                           invokeRestart("muffleMessage")
[11:01:30.076]                       }
[11:01:30.076]                       else if (inherits(cond, "warning")) {
[11:01:30.076]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.076]                         if (muffled) 
[11:01:30.076]                           invokeRestart("muffleWarning")
[11:01:30.076]                       }
[11:01:30.076]                       else if (inherits(cond, "condition")) {
[11:01:30.076]                         if (!is.null(pattern)) {
[11:01:30.076]                           computeRestarts <- base::computeRestarts
[11:01:30.076]                           grepl <- base::grepl
[11:01:30.076]                           restarts <- computeRestarts(cond)
[11:01:30.076]                           for (restart in restarts) {
[11:01:30.076]                             name <- restart$name
[11:01:30.076]                             if (is.null(name)) 
[11:01:30.076]                               next
[11:01:30.076]                             if (!grepl(pattern, name)) 
[11:01:30.076]                               next
[11:01:30.076]                             invokeRestart(restart)
[11:01:30.076]                             muffled <- TRUE
[11:01:30.076]                             break
[11:01:30.076]                           }
[11:01:30.076]                         }
[11:01:30.076]                       }
[11:01:30.076]                       invisible(muffled)
[11:01:30.076]                     }
[11:01:30.076]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.076]                   }
[11:01:30.076]                 }
[11:01:30.076]                 else {
[11:01:30.076]                   if (TRUE) {
[11:01:30.076]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.076]                     {
[11:01:30.076]                       inherits <- base::inherits
[11:01:30.076]                       invokeRestart <- base::invokeRestart
[11:01:30.076]                       is.null <- base::is.null
[11:01:30.076]                       muffled <- FALSE
[11:01:30.076]                       if (inherits(cond, "message")) {
[11:01:30.076]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.076]                         if (muffled) 
[11:01:30.076]                           invokeRestart("muffleMessage")
[11:01:30.076]                       }
[11:01:30.076]                       else if (inherits(cond, "warning")) {
[11:01:30.076]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.076]                         if (muffled) 
[11:01:30.076]                           invokeRestart("muffleWarning")
[11:01:30.076]                       }
[11:01:30.076]                       else if (inherits(cond, "condition")) {
[11:01:30.076]                         if (!is.null(pattern)) {
[11:01:30.076]                           computeRestarts <- base::computeRestarts
[11:01:30.076]                           grepl <- base::grepl
[11:01:30.076]                           restarts <- computeRestarts(cond)
[11:01:30.076]                           for (restart in restarts) {
[11:01:30.076]                             name <- restart$name
[11:01:30.076]                             if (is.null(name)) 
[11:01:30.076]                               next
[11:01:30.076]                             if (!grepl(pattern, name)) 
[11:01:30.076]                               next
[11:01:30.076]                             invokeRestart(restart)
[11:01:30.076]                             muffled <- TRUE
[11:01:30.076]                             break
[11:01:30.076]                           }
[11:01:30.076]                         }
[11:01:30.076]                       }
[11:01:30.076]                       invisible(muffled)
[11:01:30.076]                     }
[11:01:30.076]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.076]                   }
[11:01:30.076]                 }
[11:01:30.076]             }
[11:01:30.076]         }))
[11:01:30.076]     }, error = function(ex) {
[11:01:30.076]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.076]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.076]                 ...future.rng), started = ...future.startTime, 
[11:01:30.076]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.076]             version = "1.8"), class = "FutureResult")
[11:01:30.076]     }, finally = {
[11:01:30.076]         if (!identical(...future.workdir, getwd())) 
[11:01:30.076]             setwd(...future.workdir)
[11:01:30.076]         {
[11:01:30.076]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.076]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.076]             }
[11:01:30.076]             base::options(...future.oldOptions)
[11:01:30.076]             if (.Platform$OS.type == "windows") {
[11:01:30.076]                 old_names <- names(...future.oldEnvVars)
[11:01:30.076]                 envs <- base::Sys.getenv()
[11:01:30.076]                 names <- names(envs)
[11:01:30.076]                 common <- intersect(names, old_names)
[11:01:30.076]                 added <- setdiff(names, old_names)
[11:01:30.076]                 removed <- setdiff(old_names, names)
[11:01:30.076]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.076]                   envs[common]]
[11:01:30.076]                 NAMES <- toupper(changed)
[11:01:30.076]                 args <- list()
[11:01:30.076]                 for (kk in seq_along(NAMES)) {
[11:01:30.076]                   name <- changed[[kk]]
[11:01:30.076]                   NAME <- NAMES[[kk]]
[11:01:30.076]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.076]                     next
[11:01:30.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.076]                 }
[11:01:30.076]                 NAMES <- toupper(added)
[11:01:30.076]                 for (kk in seq_along(NAMES)) {
[11:01:30.076]                   name <- added[[kk]]
[11:01:30.076]                   NAME <- NAMES[[kk]]
[11:01:30.076]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.076]                     next
[11:01:30.076]                   args[[name]] <- ""
[11:01:30.076]                 }
[11:01:30.076]                 NAMES <- toupper(removed)
[11:01:30.076]                 for (kk in seq_along(NAMES)) {
[11:01:30.076]                   name <- removed[[kk]]
[11:01:30.076]                   NAME <- NAMES[[kk]]
[11:01:30.076]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.076]                     next
[11:01:30.076]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.076]                 }
[11:01:30.076]                 if (length(args) > 0) 
[11:01:30.076]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.076]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.076]             }
[11:01:30.076]             else {
[11:01:30.076]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.076]             }
[11:01:30.076]             {
[11:01:30.076]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.076]                   0L) {
[11:01:30.076]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.076]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.076]                   base::options(opts)
[11:01:30.076]                 }
[11:01:30.076]                 {
[11:01:30.076]                   {
[11:01:30.076]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.076]                     NULL
[11:01:30.076]                   }
[11:01:30.076]                   options(future.plan = NULL)
[11:01:30.076]                   if (is.na(NA_character_)) 
[11:01:30.076]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.076]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.076]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.076]                     .init = FALSE)
[11:01:30.076]                 }
[11:01:30.076]             }
[11:01:30.076]         }
[11:01:30.076]     })
[11:01:30.076]     if (TRUE) {
[11:01:30.076]         base::sink(type = "output", split = FALSE)
[11:01:30.076]         if (TRUE) {
[11:01:30.076]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.076]         }
[11:01:30.076]         else {
[11:01:30.076]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.076]         }
[11:01:30.076]         base::close(...future.stdout)
[11:01:30.076]         ...future.stdout <- NULL
[11:01:30.076]     }
[11:01:30.076]     ...future.result$conditions <- ...future.conditions
[11:01:30.076]     ...future.result$finished <- base::Sys.time()
[11:01:30.076]     ...future.result
[11:01:30.076] }
[11:01:30.079] MultisessionFuture started
[11:01:30.079] - Launch lazy future ... done
[11:01:30.079] run() for ‘MultisessionFuture’ ... done
[11:01:30.080] getGlobalsAndPackages() ...
[11:01:30.080] Searching for globals...
[11:01:30.080] 
[11:01:30.080] Searching for globals ... DONE
[11:01:30.080] - globals: [0] <none>
[11:01:30.080] getGlobalsAndPackages() ... DONE
[11:01:30.080] run() for ‘Future’ ...
[11:01:30.081] - state: ‘created’
[11:01:30.081] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.096] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.096]   - Field: ‘node’
[11:01:30.096]   - Field: ‘label’
[11:01:30.096]   - Field: ‘local’
[11:01:30.097]   - Field: ‘owner’
[11:01:30.097]   - Field: ‘envir’
[11:01:30.097]   - Field: ‘workers’
[11:01:30.097]   - Field: ‘packages’
[11:01:30.097]   - Field: ‘gc’
[11:01:30.097]   - Field: ‘conditions’
[11:01:30.097]   - Field: ‘persistent’
[11:01:30.097]   - Field: ‘expr’
[11:01:30.097]   - Field: ‘uuid’
[11:01:30.097]   - Field: ‘seed’
[11:01:30.097]   - Field: ‘version’
[11:01:30.097]   - Field: ‘result’
[11:01:30.098]   - Field: ‘asynchronous’
[11:01:30.098]   - Field: ‘calls’
[11:01:30.098]   - Field: ‘globals’
[11:01:30.098]   - Field: ‘stdout’
[11:01:30.098]   - Field: ‘earlySignal’
[11:01:30.098]   - Field: ‘lazy’
[11:01:30.098]   - Field: ‘state’
[11:01:30.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.098] - Launch lazy future ...
[11:01:30.098] Packages needed by the future expression (n = 0): <none>
[11:01:30.099] Packages needed by future strategies (n = 0): <none>
[11:01:30.099] {
[11:01:30.099]     {
[11:01:30.099]         {
[11:01:30.099]             ...future.startTime <- base::Sys.time()
[11:01:30.099]             {
[11:01:30.099]                 {
[11:01:30.099]                   {
[11:01:30.099]                     {
[11:01:30.099]                       base::local({
[11:01:30.099]                         has_future <- base::requireNamespace("future", 
[11:01:30.099]                           quietly = TRUE)
[11:01:30.099]                         if (has_future) {
[11:01:30.099]                           ns <- base::getNamespace("future")
[11:01:30.099]                           version <- ns[[".package"]][["version"]]
[11:01:30.099]                           if (is.null(version)) 
[11:01:30.099]                             version <- utils::packageVersion("future")
[11:01:30.099]                         }
[11:01:30.099]                         else {
[11:01:30.099]                           version <- NULL
[11:01:30.099]                         }
[11:01:30.099]                         if (!has_future || version < "1.8.0") {
[11:01:30.099]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.099]                             "", base::R.version$version.string), 
[11:01:30.099]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.099]                               "release", "version")], collapse = " "), 
[11:01:30.099]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.099]                             info)
[11:01:30.099]                           info <- base::paste(info, collapse = "; ")
[11:01:30.099]                           if (!has_future) {
[11:01:30.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.099]                               info)
[11:01:30.099]                           }
[11:01:30.099]                           else {
[11:01:30.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.099]                               info, version)
[11:01:30.099]                           }
[11:01:30.099]                           base::stop(msg)
[11:01:30.099]                         }
[11:01:30.099]                       })
[11:01:30.099]                     }
[11:01:30.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.099]                     base::options(mc.cores = 1L)
[11:01:30.099]                   }
[11:01:30.099]                   ...future.strategy.old <- future::plan("list")
[11:01:30.099]                   options(future.plan = NULL)
[11:01:30.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.099]                 }
[11:01:30.099]                 ...future.workdir <- getwd()
[11:01:30.099]             }
[11:01:30.099]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.099]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.099]         }
[11:01:30.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.099]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.099]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.099]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.099]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.099]             base::names(...future.oldOptions))
[11:01:30.099]     }
[11:01:30.099]     if (FALSE) {
[11:01:30.099]     }
[11:01:30.099]     else {
[11:01:30.099]         if (TRUE) {
[11:01:30.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.099]                 open = "w")
[11:01:30.099]         }
[11:01:30.099]         else {
[11:01:30.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.099]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.099]         }
[11:01:30.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.099]             base::sink(type = "output", split = FALSE)
[11:01:30.099]             base::close(...future.stdout)
[11:01:30.099]         }, add = TRUE)
[11:01:30.099]     }
[11:01:30.099]     ...future.frame <- base::sys.nframe()
[11:01:30.099]     ...future.conditions <- base::list()
[11:01:30.099]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.099]     if (FALSE) {
[11:01:30.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.099]     }
[11:01:30.099]     ...future.result <- base::tryCatch({
[11:01:30.099]         base::withCallingHandlers({
[11:01:30.099]             ...future.value <- base::withVisible(base::local({
[11:01:30.099]                 ...future.makeSendCondition <- base::local({
[11:01:30.099]                   sendCondition <- NULL
[11:01:30.099]                   function(frame = 1L) {
[11:01:30.099]                     if (is.function(sendCondition)) 
[11:01:30.099]                       return(sendCondition)
[11:01:30.099]                     ns <- getNamespace("parallel")
[11:01:30.099]                     if (exists("sendData", mode = "function", 
[11:01:30.099]                       envir = ns)) {
[11:01:30.099]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.099]                         envir = ns)
[11:01:30.099]                       envir <- sys.frame(frame)
[11:01:30.099]                       master <- NULL
[11:01:30.099]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.099]                         !identical(envir, emptyenv())) {
[11:01:30.099]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.099]                           inherits = FALSE)) {
[11:01:30.099]                           master <- get("master", mode = "list", 
[11:01:30.099]                             envir = envir, inherits = FALSE)
[11:01:30.099]                           if (inherits(master, c("SOCKnode", 
[11:01:30.099]                             "SOCK0node"))) {
[11:01:30.099]                             sendCondition <<- function(cond) {
[11:01:30.099]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.099]                                 success = TRUE)
[11:01:30.099]                               parallel_sendData(master, data)
[11:01:30.099]                             }
[11:01:30.099]                             return(sendCondition)
[11:01:30.099]                           }
[11:01:30.099]                         }
[11:01:30.099]                         frame <- frame + 1L
[11:01:30.099]                         envir <- sys.frame(frame)
[11:01:30.099]                       }
[11:01:30.099]                     }
[11:01:30.099]                     sendCondition <<- function(cond) NULL
[11:01:30.099]                   }
[11:01:30.099]                 })
[11:01:30.099]                 withCallingHandlers({
[11:01:30.099]                   NULL
[11:01:30.099]                 }, immediateCondition = function(cond) {
[11:01:30.099]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.099]                   sendCondition(cond)
[11:01:30.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.099]                   {
[11:01:30.099]                     inherits <- base::inherits
[11:01:30.099]                     invokeRestart <- base::invokeRestart
[11:01:30.099]                     is.null <- base::is.null
[11:01:30.099]                     muffled <- FALSE
[11:01:30.099]                     if (inherits(cond, "message")) {
[11:01:30.099]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.099]                       if (muffled) 
[11:01:30.099]                         invokeRestart("muffleMessage")
[11:01:30.099]                     }
[11:01:30.099]                     else if (inherits(cond, "warning")) {
[11:01:30.099]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.099]                       if (muffled) 
[11:01:30.099]                         invokeRestart("muffleWarning")
[11:01:30.099]                     }
[11:01:30.099]                     else if (inherits(cond, "condition")) {
[11:01:30.099]                       if (!is.null(pattern)) {
[11:01:30.099]                         computeRestarts <- base::computeRestarts
[11:01:30.099]                         grepl <- base::grepl
[11:01:30.099]                         restarts <- computeRestarts(cond)
[11:01:30.099]                         for (restart in restarts) {
[11:01:30.099]                           name <- restart$name
[11:01:30.099]                           if (is.null(name)) 
[11:01:30.099]                             next
[11:01:30.099]                           if (!grepl(pattern, name)) 
[11:01:30.099]                             next
[11:01:30.099]                           invokeRestart(restart)
[11:01:30.099]                           muffled <- TRUE
[11:01:30.099]                           break
[11:01:30.099]                         }
[11:01:30.099]                       }
[11:01:30.099]                     }
[11:01:30.099]                     invisible(muffled)
[11:01:30.099]                   }
[11:01:30.099]                   muffleCondition(cond)
[11:01:30.099]                 })
[11:01:30.099]             }))
[11:01:30.099]             future::FutureResult(value = ...future.value$value, 
[11:01:30.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.099]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.099]                     ...future.globalenv.names))
[11:01:30.099]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.099]         }, condition = base::local({
[11:01:30.099]             c <- base::c
[11:01:30.099]             inherits <- base::inherits
[11:01:30.099]             invokeRestart <- base::invokeRestart
[11:01:30.099]             length <- base::length
[11:01:30.099]             list <- base::list
[11:01:30.099]             seq.int <- base::seq.int
[11:01:30.099]             signalCondition <- base::signalCondition
[11:01:30.099]             sys.calls <- base::sys.calls
[11:01:30.099]             `[[` <- base::`[[`
[11:01:30.099]             `+` <- base::`+`
[11:01:30.099]             `<<-` <- base::`<<-`
[11:01:30.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.099]                   3L)]
[11:01:30.099]             }
[11:01:30.099]             function(cond) {
[11:01:30.099]                 is_error <- inherits(cond, "error")
[11:01:30.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.099]                   NULL)
[11:01:30.099]                 if (is_error) {
[11:01:30.099]                   sessionInformation <- function() {
[11:01:30.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.099]                       search = base::search(), system = base::Sys.info())
[11:01:30.099]                   }
[11:01:30.099]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.099]                     cond$call), session = sessionInformation(), 
[11:01:30.099]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.099]                   signalCondition(cond)
[11:01:30.099]                 }
[11:01:30.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.099]                 "immediateCondition"))) {
[11:01:30.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.099]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.099]                   if (TRUE && !signal) {
[11:01:30.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.099]                     {
[11:01:30.099]                       inherits <- base::inherits
[11:01:30.099]                       invokeRestart <- base::invokeRestart
[11:01:30.099]                       is.null <- base::is.null
[11:01:30.099]                       muffled <- FALSE
[11:01:30.099]                       if (inherits(cond, "message")) {
[11:01:30.099]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.099]                         if (muffled) 
[11:01:30.099]                           invokeRestart("muffleMessage")
[11:01:30.099]                       }
[11:01:30.099]                       else if (inherits(cond, "warning")) {
[11:01:30.099]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.099]                         if (muffled) 
[11:01:30.099]                           invokeRestart("muffleWarning")
[11:01:30.099]                       }
[11:01:30.099]                       else if (inherits(cond, "condition")) {
[11:01:30.099]                         if (!is.null(pattern)) {
[11:01:30.099]                           computeRestarts <- base::computeRestarts
[11:01:30.099]                           grepl <- base::grepl
[11:01:30.099]                           restarts <- computeRestarts(cond)
[11:01:30.099]                           for (restart in restarts) {
[11:01:30.099]                             name <- restart$name
[11:01:30.099]                             if (is.null(name)) 
[11:01:30.099]                               next
[11:01:30.099]                             if (!grepl(pattern, name)) 
[11:01:30.099]                               next
[11:01:30.099]                             invokeRestart(restart)
[11:01:30.099]                             muffled <- TRUE
[11:01:30.099]                             break
[11:01:30.099]                           }
[11:01:30.099]                         }
[11:01:30.099]                       }
[11:01:30.099]                       invisible(muffled)
[11:01:30.099]                     }
[11:01:30.099]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.099]                   }
[11:01:30.099]                 }
[11:01:30.099]                 else {
[11:01:30.099]                   if (TRUE) {
[11:01:30.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.099]                     {
[11:01:30.099]                       inherits <- base::inherits
[11:01:30.099]                       invokeRestart <- base::invokeRestart
[11:01:30.099]                       is.null <- base::is.null
[11:01:30.099]                       muffled <- FALSE
[11:01:30.099]                       if (inherits(cond, "message")) {
[11:01:30.099]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.099]                         if (muffled) 
[11:01:30.099]                           invokeRestart("muffleMessage")
[11:01:30.099]                       }
[11:01:30.099]                       else if (inherits(cond, "warning")) {
[11:01:30.099]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.099]                         if (muffled) 
[11:01:30.099]                           invokeRestart("muffleWarning")
[11:01:30.099]                       }
[11:01:30.099]                       else if (inherits(cond, "condition")) {
[11:01:30.099]                         if (!is.null(pattern)) {
[11:01:30.099]                           computeRestarts <- base::computeRestarts
[11:01:30.099]                           grepl <- base::grepl
[11:01:30.099]                           restarts <- computeRestarts(cond)
[11:01:30.099]                           for (restart in restarts) {
[11:01:30.099]                             name <- restart$name
[11:01:30.099]                             if (is.null(name)) 
[11:01:30.099]                               next
[11:01:30.099]                             if (!grepl(pattern, name)) 
[11:01:30.099]                               next
[11:01:30.099]                             invokeRestart(restart)
[11:01:30.099]                             muffled <- TRUE
[11:01:30.099]                             break
[11:01:30.099]                           }
[11:01:30.099]                         }
[11:01:30.099]                       }
[11:01:30.099]                       invisible(muffled)
[11:01:30.099]                     }
[11:01:30.099]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.099]                   }
[11:01:30.099]                 }
[11:01:30.099]             }
[11:01:30.099]         }))
[11:01:30.099]     }, error = function(ex) {
[11:01:30.099]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.099]                 ...future.rng), started = ...future.startTime, 
[11:01:30.099]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.099]             version = "1.8"), class = "FutureResult")
[11:01:30.099]     }, finally = {
[11:01:30.099]         if (!identical(...future.workdir, getwd())) 
[11:01:30.099]             setwd(...future.workdir)
[11:01:30.099]         {
[11:01:30.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.099]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.099]             }
[11:01:30.099]             base::options(...future.oldOptions)
[11:01:30.099]             if (.Platform$OS.type == "windows") {
[11:01:30.099]                 old_names <- names(...future.oldEnvVars)
[11:01:30.099]                 envs <- base::Sys.getenv()
[11:01:30.099]                 names <- names(envs)
[11:01:30.099]                 common <- intersect(names, old_names)
[11:01:30.099]                 added <- setdiff(names, old_names)
[11:01:30.099]                 removed <- setdiff(old_names, names)
[11:01:30.099]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.099]                   envs[common]]
[11:01:30.099]                 NAMES <- toupper(changed)
[11:01:30.099]                 args <- list()
[11:01:30.099]                 for (kk in seq_along(NAMES)) {
[11:01:30.099]                   name <- changed[[kk]]
[11:01:30.099]                   NAME <- NAMES[[kk]]
[11:01:30.099]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.099]                     next
[11:01:30.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.099]                 }
[11:01:30.099]                 NAMES <- toupper(added)
[11:01:30.099]                 for (kk in seq_along(NAMES)) {
[11:01:30.099]                   name <- added[[kk]]
[11:01:30.099]                   NAME <- NAMES[[kk]]
[11:01:30.099]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.099]                     next
[11:01:30.099]                   args[[name]] <- ""
[11:01:30.099]                 }
[11:01:30.099]                 NAMES <- toupper(removed)
[11:01:30.099]                 for (kk in seq_along(NAMES)) {
[11:01:30.099]                   name <- removed[[kk]]
[11:01:30.099]                   NAME <- NAMES[[kk]]
[11:01:30.099]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.099]                     next
[11:01:30.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.099]                 }
[11:01:30.099]                 if (length(args) > 0) 
[11:01:30.099]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.099]             }
[11:01:30.099]             else {
[11:01:30.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.099]             }
[11:01:30.099]             {
[11:01:30.099]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.099]                   0L) {
[11:01:30.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.099]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.099]                   base::options(opts)
[11:01:30.099]                 }
[11:01:30.099]                 {
[11:01:30.099]                   {
[11:01:30.099]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.099]                     NULL
[11:01:30.099]                   }
[11:01:30.099]                   options(future.plan = NULL)
[11:01:30.099]                   if (is.na(NA_character_)) 
[11:01:30.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.099]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.099]                     .init = FALSE)
[11:01:30.099]                 }
[11:01:30.099]             }
[11:01:30.099]         }
[11:01:30.099]     })
[11:01:30.099]     if (TRUE) {
[11:01:30.099]         base::sink(type = "output", split = FALSE)
[11:01:30.099]         if (TRUE) {
[11:01:30.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.099]         }
[11:01:30.099]         else {
[11:01:30.099]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.099]         }
[11:01:30.099]         base::close(...future.stdout)
[11:01:30.099]         ...future.stdout <- NULL
[11:01:30.099]     }
[11:01:30.099]     ...future.result$conditions <- ...future.conditions
[11:01:30.099]     ...future.result$finished <- base::Sys.time()
[11:01:30.099]     ...future.result
[11:01:30.099] }
[11:01:30.150] MultisessionFuture started
[11:01:30.151] - Launch lazy future ... done
[11:01:30.151] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c665d910> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4a6c8b0> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c665d910> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4a6c8b0> 
 $  : NULL
 $  : NULL
 $  : num 6
[11:01:30.159] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.159] - Validating connection of MultisessionFuture
[11:01:30.160] - received message: FutureResult
[11:01:30.160] - Received FutureResult
[11:01:30.160] - Erased future from FutureRegistry
[11:01:30.160] result() for ClusterFuture ...
[11:01:30.160] - result already collected: FutureResult
[11:01:30.160] result() for ClusterFuture ... done
[11:01:30.161] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE FALSE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:30.172] resolve() on list ...
[11:01:30.173]  recursive: 0
[11:01:30.173]  length: 6
[11:01:30.173]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:30.173] signalConditionsASAP(numeric, pos=1) ...
[11:01:30.173] - nx: 6
[11:01:30.174] - relay: TRUE
[11:01:30.174] - stdout: TRUE
[11:01:30.174] - signal: TRUE
[11:01:30.174] - resignal: FALSE
[11:01:30.174] - force: TRUE
[11:01:30.175] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.175] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.175]  - until=2
[11:01:30.175]  - relaying element #2
[11:01:30.175] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.175] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.176] signalConditionsASAP(NULL, pos=1) ... done
[11:01:30.176]  length: 5 (resolved future 1)
[11:01:30.176] Future #2
[11:01:30.176] result() for ClusterFuture ...
[11:01:30.176] - result already collected: FutureResult
[11:01:30.177] result() for ClusterFuture ... done
[11:01:30.177] result() for ClusterFuture ...
[11:01:30.177] - result already collected: FutureResult
[11:01:30.177] result() for ClusterFuture ... done
[11:01:30.177] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:30.178] - nx: 6
[11:01:30.178] - relay: TRUE
[11:01:30.178] - stdout: TRUE
[11:01:30.178] - signal: TRUE
[11:01:30.178] - resignal: FALSE
[11:01:30.179] - force: TRUE
[11:01:30.179] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.179] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.179]  - until=2
[11:01:30.179]  - relaying element #2
[11:01:30.179] result() for ClusterFuture ...
[11:01:30.180] - result already collected: FutureResult
[11:01:30.180] result() for ClusterFuture ... done
[11:01:30.180] result() for ClusterFuture ...
[11:01:30.180] - result already collected: FutureResult
[11:01:30.180] result() for ClusterFuture ... done
[11:01:30.181] result() for ClusterFuture ...
[11:01:30.181] - result already collected: FutureResult
[11:01:30.181] result() for ClusterFuture ... done
[11:01:30.181] result() for ClusterFuture ...
[11:01:30.181] - result already collected: FutureResult
[11:01:30.181] result() for ClusterFuture ... done
[11:01:30.182] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.182] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.182] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:30.182]  length: 4 (resolved future 2)
[11:01:30.192] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.192] - Validating connection of MultisessionFuture
[11:01:30.192] - received message: FutureResult
[11:01:30.192] - Received FutureResult
[11:01:30.192] - Erased future from FutureRegistry
[11:01:30.193] result() for ClusterFuture ...
[11:01:30.193] - result already collected: FutureResult
[11:01:30.193] result() for ClusterFuture ... done
[11:01:30.193] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.193] Future #3
[11:01:30.193] result() for ClusterFuture ...
[11:01:30.193] - result already collected: FutureResult
[11:01:30.193] result() for ClusterFuture ... done
[11:01:30.193] result() for ClusterFuture ...
[11:01:30.194] - result already collected: FutureResult
[11:01:30.194] result() for ClusterFuture ... done
[11:01:30.194] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:30.194] - nx: 6
[11:01:30.194] - relay: TRUE
[11:01:30.194] - stdout: TRUE
[11:01:30.194] - signal: TRUE
[11:01:30.194] - resignal: FALSE
[11:01:30.194] - force: TRUE
[11:01:30.195] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.195] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.195]  - until=3
[11:01:30.195]  - relaying element #3
[11:01:30.195] result() for ClusterFuture ...
[11:01:30.195] - result already collected: FutureResult
[11:01:30.195] result() for ClusterFuture ... done
[11:01:30.195] result() for ClusterFuture ...
[11:01:30.195] - result already collected: FutureResult
[11:01:30.195] result() for ClusterFuture ... done
[11:01:30.196] result() for ClusterFuture ...
[11:01:30.196] - result already collected: FutureResult
[11:01:30.196] result() for ClusterFuture ... done
[11:01:30.196] result() for ClusterFuture ...
[11:01:30.196] - result already collected: FutureResult
[11:01:30.196] result() for ClusterFuture ... done
[11:01:30.196] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.196] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.196] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:30.197]  length: 3 (resolved future 3)
[11:01:30.197] signalConditionsASAP(NULL, pos=4) ...
[11:01:30.197] - nx: 6
[11:01:30.197] - relay: TRUE
[11:01:30.197] - stdout: TRUE
[11:01:30.197] - signal: TRUE
[11:01:30.197] - resignal: FALSE
[11:01:30.197] - force: TRUE
[11:01:30.197] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.197] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.198]  - until=5
[11:01:30.198]  - relaying element #5
[11:01:30.198] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.198] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.198] signalConditionsASAP(NULL, pos=4) ... done
[11:01:30.198]  length: 2 (resolved future 4)
[11:01:30.198] signalConditionsASAP(NULL, pos=5) ...
[11:01:30.198] - nx: 6
[11:01:30.198] - relay: TRUE
[11:01:30.198] - stdout: TRUE
[11:01:30.199] - signal: TRUE
[11:01:30.199] - resignal: FALSE
[11:01:30.199] - force: TRUE
[11:01:30.199] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.199] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.199]  - until=6
[11:01:30.199]  - relaying element #6
[11:01:30.199] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.199] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.199] signalConditionsASAP(NULL, pos=5) ... done
[11:01:30.200]  length: 1 (resolved future 5)
[11:01:30.200] signalConditionsASAP(numeric, pos=6) ...
[11:01:30.200] - nx: 6
[11:01:30.200] - relay: TRUE
[11:01:30.200] - stdout: TRUE
[11:01:30.200] - signal: TRUE
[11:01:30.200] - resignal: FALSE
[11:01:30.200] - force: TRUE
[11:01:30.200] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.200] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.201]  - until=6
[11:01:30.201] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.201] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.201] signalConditionsASAP(numeric, pos=6) ... done
[11:01:30.201]  length: 0 (resolved future 6)
[11:01:30.201] Relaying remaining futures
[11:01:30.201] signalConditionsASAP(NULL, pos=0) ...
[11:01:30.201] - nx: 6
[11:01:30.201] - relay: TRUE
[11:01:30.201] - stdout: TRUE
[11:01:30.202] - signal: TRUE
[11:01:30.202] - resignal: FALSE
[11:01:30.202] - force: TRUE
[11:01:30.202] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.202] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:30.202] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.202] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.202] signalConditionsASAP(NULL, pos=0) ... done
[11:01:30.202] resolve() on list ... DONE
[11:01:30.203] result() for ClusterFuture ...
[11:01:30.203] - result already collected: FutureResult
[11:01:30.203] result() for ClusterFuture ... done
[11:01:30.203] result() for ClusterFuture ...
[11:01:30.203] - result already collected: FutureResult
[11:01:30.203] result() for ClusterFuture ... done
[11:01:30.203] result() for ClusterFuture ...
[11:01:30.203] - result already collected: FutureResult
[11:01:30.203] result() for ClusterFuture ... done
[11:01:30.204] result() for ClusterFuture ...
[11:01:30.204] - result already collected: FutureResult
[11:01:30.204] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
Dimensions: c(1, 6)
[11:01:30.206] getGlobalsAndPackages() ...
[11:01:30.206] Searching for globals...
[11:01:30.207] 
[11:01:30.207] Searching for globals ... DONE
[11:01:30.207] - globals: [0] <none>
[11:01:30.207] getGlobalsAndPackages() ... DONE
[11:01:30.207] run() for ‘Future’ ...
[11:01:30.207] - state: ‘created’
[11:01:30.208] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.222] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.222] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.222]   - Field: ‘node’
[11:01:30.223]   - Field: ‘label’
[11:01:30.223]   - Field: ‘local’
[11:01:30.223]   - Field: ‘owner’
[11:01:30.223]   - Field: ‘envir’
[11:01:30.223]   - Field: ‘workers’
[11:01:30.223]   - Field: ‘packages’
[11:01:30.223]   - Field: ‘gc’
[11:01:30.223]   - Field: ‘conditions’
[11:01:30.223]   - Field: ‘persistent’
[11:01:30.223]   - Field: ‘expr’
[11:01:30.224]   - Field: ‘uuid’
[11:01:30.224]   - Field: ‘seed’
[11:01:30.224]   - Field: ‘version’
[11:01:30.224]   - Field: ‘result’
[11:01:30.224]   - Field: ‘asynchronous’
[11:01:30.224]   - Field: ‘calls’
[11:01:30.224]   - Field: ‘globals’
[11:01:30.224]   - Field: ‘stdout’
[11:01:30.224]   - Field: ‘earlySignal’
[11:01:30.225]   - Field: ‘lazy’
[11:01:30.225]   - Field: ‘state’
[11:01:30.225] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.225] - Launch lazy future ...
[11:01:30.225] Packages needed by the future expression (n = 0): <none>
[11:01:30.225] Packages needed by future strategies (n = 0): <none>
[11:01:30.226] {
[11:01:30.226]     {
[11:01:30.226]         {
[11:01:30.226]             ...future.startTime <- base::Sys.time()
[11:01:30.226]             {
[11:01:30.226]                 {
[11:01:30.226]                   {
[11:01:30.226]                     {
[11:01:30.226]                       base::local({
[11:01:30.226]                         has_future <- base::requireNamespace("future", 
[11:01:30.226]                           quietly = TRUE)
[11:01:30.226]                         if (has_future) {
[11:01:30.226]                           ns <- base::getNamespace("future")
[11:01:30.226]                           version <- ns[[".package"]][["version"]]
[11:01:30.226]                           if (is.null(version)) 
[11:01:30.226]                             version <- utils::packageVersion("future")
[11:01:30.226]                         }
[11:01:30.226]                         else {
[11:01:30.226]                           version <- NULL
[11:01:30.226]                         }
[11:01:30.226]                         if (!has_future || version < "1.8.0") {
[11:01:30.226]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.226]                             "", base::R.version$version.string), 
[11:01:30.226]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.226]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.226]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.226]                               "release", "version")], collapse = " "), 
[11:01:30.226]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.226]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.226]                             info)
[11:01:30.226]                           info <- base::paste(info, collapse = "; ")
[11:01:30.226]                           if (!has_future) {
[11:01:30.226]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.226]                               info)
[11:01:30.226]                           }
[11:01:30.226]                           else {
[11:01:30.226]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.226]                               info, version)
[11:01:30.226]                           }
[11:01:30.226]                           base::stop(msg)
[11:01:30.226]                         }
[11:01:30.226]                       })
[11:01:30.226]                     }
[11:01:30.226]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.226]                     base::options(mc.cores = 1L)
[11:01:30.226]                   }
[11:01:30.226]                   ...future.strategy.old <- future::plan("list")
[11:01:30.226]                   options(future.plan = NULL)
[11:01:30.226]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.226]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.226]                 }
[11:01:30.226]                 ...future.workdir <- getwd()
[11:01:30.226]             }
[11:01:30.226]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.226]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.226]         }
[11:01:30.226]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.226]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.226]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.226]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.226]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.226]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.226]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.226]             base::names(...future.oldOptions))
[11:01:30.226]     }
[11:01:30.226]     if (FALSE) {
[11:01:30.226]     }
[11:01:30.226]     else {
[11:01:30.226]         if (TRUE) {
[11:01:30.226]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.226]                 open = "w")
[11:01:30.226]         }
[11:01:30.226]         else {
[11:01:30.226]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.226]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.226]         }
[11:01:30.226]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.226]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.226]             base::sink(type = "output", split = FALSE)
[11:01:30.226]             base::close(...future.stdout)
[11:01:30.226]         }, add = TRUE)
[11:01:30.226]     }
[11:01:30.226]     ...future.frame <- base::sys.nframe()
[11:01:30.226]     ...future.conditions <- base::list()
[11:01:30.226]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.226]     if (FALSE) {
[11:01:30.226]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.226]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.226]     }
[11:01:30.226]     ...future.result <- base::tryCatch({
[11:01:30.226]         base::withCallingHandlers({
[11:01:30.226]             ...future.value <- base::withVisible(base::local({
[11:01:30.226]                 ...future.makeSendCondition <- base::local({
[11:01:30.226]                   sendCondition <- NULL
[11:01:30.226]                   function(frame = 1L) {
[11:01:30.226]                     if (is.function(sendCondition)) 
[11:01:30.226]                       return(sendCondition)
[11:01:30.226]                     ns <- getNamespace("parallel")
[11:01:30.226]                     if (exists("sendData", mode = "function", 
[11:01:30.226]                       envir = ns)) {
[11:01:30.226]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.226]                         envir = ns)
[11:01:30.226]                       envir <- sys.frame(frame)
[11:01:30.226]                       master <- NULL
[11:01:30.226]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.226]                         !identical(envir, emptyenv())) {
[11:01:30.226]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.226]                           inherits = FALSE)) {
[11:01:30.226]                           master <- get("master", mode = "list", 
[11:01:30.226]                             envir = envir, inherits = FALSE)
[11:01:30.226]                           if (inherits(master, c("SOCKnode", 
[11:01:30.226]                             "SOCK0node"))) {
[11:01:30.226]                             sendCondition <<- function(cond) {
[11:01:30.226]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.226]                                 success = TRUE)
[11:01:30.226]                               parallel_sendData(master, data)
[11:01:30.226]                             }
[11:01:30.226]                             return(sendCondition)
[11:01:30.226]                           }
[11:01:30.226]                         }
[11:01:30.226]                         frame <- frame + 1L
[11:01:30.226]                         envir <- sys.frame(frame)
[11:01:30.226]                       }
[11:01:30.226]                     }
[11:01:30.226]                     sendCondition <<- function(cond) NULL
[11:01:30.226]                   }
[11:01:30.226]                 })
[11:01:30.226]                 withCallingHandlers({
[11:01:30.226]                   2
[11:01:30.226]                 }, immediateCondition = function(cond) {
[11:01:30.226]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.226]                   sendCondition(cond)
[11:01:30.226]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.226]                   {
[11:01:30.226]                     inherits <- base::inherits
[11:01:30.226]                     invokeRestart <- base::invokeRestart
[11:01:30.226]                     is.null <- base::is.null
[11:01:30.226]                     muffled <- FALSE
[11:01:30.226]                     if (inherits(cond, "message")) {
[11:01:30.226]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.226]                       if (muffled) 
[11:01:30.226]                         invokeRestart("muffleMessage")
[11:01:30.226]                     }
[11:01:30.226]                     else if (inherits(cond, "warning")) {
[11:01:30.226]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.226]                       if (muffled) 
[11:01:30.226]                         invokeRestart("muffleWarning")
[11:01:30.226]                     }
[11:01:30.226]                     else if (inherits(cond, "condition")) {
[11:01:30.226]                       if (!is.null(pattern)) {
[11:01:30.226]                         computeRestarts <- base::computeRestarts
[11:01:30.226]                         grepl <- base::grepl
[11:01:30.226]                         restarts <- computeRestarts(cond)
[11:01:30.226]                         for (restart in restarts) {
[11:01:30.226]                           name <- restart$name
[11:01:30.226]                           if (is.null(name)) 
[11:01:30.226]                             next
[11:01:30.226]                           if (!grepl(pattern, name)) 
[11:01:30.226]                             next
[11:01:30.226]                           invokeRestart(restart)
[11:01:30.226]                           muffled <- TRUE
[11:01:30.226]                           break
[11:01:30.226]                         }
[11:01:30.226]                       }
[11:01:30.226]                     }
[11:01:30.226]                     invisible(muffled)
[11:01:30.226]                   }
[11:01:30.226]                   muffleCondition(cond)
[11:01:30.226]                 })
[11:01:30.226]             }))
[11:01:30.226]             future::FutureResult(value = ...future.value$value, 
[11:01:30.226]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.226]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.226]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.226]                     ...future.globalenv.names))
[11:01:30.226]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.226]         }, condition = base::local({
[11:01:30.226]             c <- base::c
[11:01:30.226]             inherits <- base::inherits
[11:01:30.226]             invokeRestart <- base::invokeRestart
[11:01:30.226]             length <- base::length
[11:01:30.226]             list <- base::list
[11:01:30.226]             seq.int <- base::seq.int
[11:01:30.226]             signalCondition <- base::signalCondition
[11:01:30.226]             sys.calls <- base::sys.calls
[11:01:30.226]             `[[` <- base::`[[`
[11:01:30.226]             `+` <- base::`+`
[11:01:30.226]             `<<-` <- base::`<<-`
[11:01:30.226]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.226]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.226]                   3L)]
[11:01:30.226]             }
[11:01:30.226]             function(cond) {
[11:01:30.226]                 is_error <- inherits(cond, "error")
[11:01:30.226]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.226]                   NULL)
[11:01:30.226]                 if (is_error) {
[11:01:30.226]                   sessionInformation <- function() {
[11:01:30.226]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.226]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.226]                       search = base::search(), system = base::Sys.info())
[11:01:30.226]                   }
[11:01:30.226]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.226]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.226]                     cond$call), session = sessionInformation(), 
[11:01:30.226]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.226]                   signalCondition(cond)
[11:01:30.226]                 }
[11:01:30.226]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.226]                 "immediateCondition"))) {
[11:01:30.226]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.226]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.226]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.226]                   if (TRUE && !signal) {
[11:01:30.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.226]                     {
[11:01:30.226]                       inherits <- base::inherits
[11:01:30.226]                       invokeRestart <- base::invokeRestart
[11:01:30.226]                       is.null <- base::is.null
[11:01:30.226]                       muffled <- FALSE
[11:01:30.226]                       if (inherits(cond, "message")) {
[11:01:30.226]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.226]                         if (muffled) 
[11:01:30.226]                           invokeRestart("muffleMessage")
[11:01:30.226]                       }
[11:01:30.226]                       else if (inherits(cond, "warning")) {
[11:01:30.226]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.226]                         if (muffled) 
[11:01:30.226]                           invokeRestart("muffleWarning")
[11:01:30.226]                       }
[11:01:30.226]                       else if (inherits(cond, "condition")) {
[11:01:30.226]                         if (!is.null(pattern)) {
[11:01:30.226]                           computeRestarts <- base::computeRestarts
[11:01:30.226]                           grepl <- base::grepl
[11:01:30.226]                           restarts <- computeRestarts(cond)
[11:01:30.226]                           for (restart in restarts) {
[11:01:30.226]                             name <- restart$name
[11:01:30.226]                             if (is.null(name)) 
[11:01:30.226]                               next
[11:01:30.226]                             if (!grepl(pattern, name)) 
[11:01:30.226]                               next
[11:01:30.226]                             invokeRestart(restart)
[11:01:30.226]                             muffled <- TRUE
[11:01:30.226]                             break
[11:01:30.226]                           }
[11:01:30.226]                         }
[11:01:30.226]                       }
[11:01:30.226]                       invisible(muffled)
[11:01:30.226]                     }
[11:01:30.226]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.226]                   }
[11:01:30.226]                 }
[11:01:30.226]                 else {
[11:01:30.226]                   if (TRUE) {
[11:01:30.226]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.226]                     {
[11:01:30.226]                       inherits <- base::inherits
[11:01:30.226]                       invokeRestart <- base::invokeRestart
[11:01:30.226]                       is.null <- base::is.null
[11:01:30.226]                       muffled <- FALSE
[11:01:30.226]                       if (inherits(cond, "message")) {
[11:01:30.226]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.226]                         if (muffled) 
[11:01:30.226]                           invokeRestart("muffleMessage")
[11:01:30.226]                       }
[11:01:30.226]                       else if (inherits(cond, "warning")) {
[11:01:30.226]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.226]                         if (muffled) 
[11:01:30.226]                           invokeRestart("muffleWarning")
[11:01:30.226]                       }
[11:01:30.226]                       else if (inherits(cond, "condition")) {
[11:01:30.226]                         if (!is.null(pattern)) {
[11:01:30.226]                           computeRestarts <- base::computeRestarts
[11:01:30.226]                           grepl <- base::grepl
[11:01:30.226]                           restarts <- computeRestarts(cond)
[11:01:30.226]                           for (restart in restarts) {
[11:01:30.226]                             name <- restart$name
[11:01:30.226]                             if (is.null(name)) 
[11:01:30.226]                               next
[11:01:30.226]                             if (!grepl(pattern, name)) 
[11:01:30.226]                               next
[11:01:30.226]                             invokeRestart(restart)
[11:01:30.226]                             muffled <- TRUE
[11:01:30.226]                             break
[11:01:30.226]                           }
[11:01:30.226]                         }
[11:01:30.226]                       }
[11:01:30.226]                       invisible(muffled)
[11:01:30.226]                     }
[11:01:30.226]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.226]                   }
[11:01:30.226]                 }
[11:01:30.226]             }
[11:01:30.226]         }))
[11:01:30.226]     }, error = function(ex) {
[11:01:30.226]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.226]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.226]                 ...future.rng), started = ...future.startTime, 
[11:01:30.226]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.226]             version = "1.8"), class = "FutureResult")
[11:01:30.226]     }, finally = {
[11:01:30.226]         if (!identical(...future.workdir, getwd())) 
[11:01:30.226]             setwd(...future.workdir)
[11:01:30.226]         {
[11:01:30.226]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.226]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.226]             }
[11:01:30.226]             base::options(...future.oldOptions)
[11:01:30.226]             if (.Platform$OS.type == "windows") {
[11:01:30.226]                 old_names <- names(...future.oldEnvVars)
[11:01:30.226]                 envs <- base::Sys.getenv()
[11:01:30.226]                 names <- names(envs)
[11:01:30.226]                 common <- intersect(names, old_names)
[11:01:30.226]                 added <- setdiff(names, old_names)
[11:01:30.226]                 removed <- setdiff(old_names, names)
[11:01:30.226]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.226]                   envs[common]]
[11:01:30.226]                 NAMES <- toupper(changed)
[11:01:30.226]                 args <- list()
[11:01:30.226]                 for (kk in seq_along(NAMES)) {
[11:01:30.226]                   name <- changed[[kk]]
[11:01:30.226]                   NAME <- NAMES[[kk]]
[11:01:30.226]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.226]                     next
[11:01:30.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.226]                 }
[11:01:30.226]                 NAMES <- toupper(added)
[11:01:30.226]                 for (kk in seq_along(NAMES)) {
[11:01:30.226]                   name <- added[[kk]]
[11:01:30.226]                   NAME <- NAMES[[kk]]
[11:01:30.226]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.226]                     next
[11:01:30.226]                   args[[name]] <- ""
[11:01:30.226]                 }
[11:01:30.226]                 NAMES <- toupper(removed)
[11:01:30.226]                 for (kk in seq_along(NAMES)) {
[11:01:30.226]                   name <- removed[[kk]]
[11:01:30.226]                   NAME <- NAMES[[kk]]
[11:01:30.226]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.226]                     next
[11:01:30.226]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.226]                 }
[11:01:30.226]                 if (length(args) > 0) 
[11:01:30.226]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.226]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.226]             }
[11:01:30.226]             else {
[11:01:30.226]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.226]             }
[11:01:30.226]             {
[11:01:30.226]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.226]                   0L) {
[11:01:30.226]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.226]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.226]                   base::options(opts)
[11:01:30.226]                 }
[11:01:30.226]                 {
[11:01:30.226]                   {
[11:01:30.226]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.226]                     NULL
[11:01:30.226]                   }
[11:01:30.226]                   options(future.plan = NULL)
[11:01:30.226]                   if (is.na(NA_character_)) 
[11:01:30.226]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.226]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.226]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.226]                     .init = FALSE)
[11:01:30.226]                 }
[11:01:30.226]             }
[11:01:30.226]         }
[11:01:30.226]     })
[11:01:30.226]     if (TRUE) {
[11:01:30.226]         base::sink(type = "output", split = FALSE)
[11:01:30.226]         if (TRUE) {
[11:01:30.226]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.226]         }
[11:01:30.226]         else {
[11:01:30.226]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.226]         }
[11:01:30.226]         base::close(...future.stdout)
[11:01:30.226]         ...future.stdout <- NULL
[11:01:30.226]     }
[11:01:30.226]     ...future.result$conditions <- ...future.conditions
[11:01:30.226]     ...future.result$finished <- base::Sys.time()
[11:01:30.226]     ...future.result
[11:01:30.226] }
[11:01:30.229] MultisessionFuture started
[11:01:30.229] - Launch lazy future ... done
[11:01:30.229] run() for ‘MultisessionFuture’ ... done
[11:01:30.229] getGlobalsAndPackages() ...
[11:01:30.230] Searching for globals...
[11:01:30.230] 
[11:01:30.230] Searching for globals ... DONE
[11:01:30.230] - globals: [0] <none>
[11:01:30.230] getGlobalsAndPackages() ... DONE
[11:01:30.231] run() for ‘Future’ ...
[11:01:30.231] - state: ‘created’
[11:01:30.231] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.245] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.245]   - Field: ‘node’
[11:01:30.245]   - Field: ‘label’
[11:01:30.245]   - Field: ‘local’
[11:01:30.246]   - Field: ‘owner’
[11:01:30.246]   - Field: ‘envir’
[11:01:30.246]   - Field: ‘workers’
[11:01:30.246]   - Field: ‘packages’
[11:01:30.246]   - Field: ‘gc’
[11:01:30.246]   - Field: ‘conditions’
[11:01:30.246]   - Field: ‘persistent’
[11:01:30.246]   - Field: ‘expr’
[11:01:30.246]   - Field: ‘uuid’
[11:01:30.247]   - Field: ‘seed’
[11:01:30.247]   - Field: ‘version’
[11:01:30.247]   - Field: ‘result’
[11:01:30.247]   - Field: ‘asynchronous’
[11:01:30.247]   - Field: ‘calls’
[11:01:30.247]   - Field: ‘globals’
[11:01:30.247]   - Field: ‘stdout’
[11:01:30.247]   - Field: ‘earlySignal’
[11:01:30.247]   - Field: ‘lazy’
[11:01:30.247]   - Field: ‘state’
[11:01:30.248] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.248] - Launch lazy future ...
[11:01:30.248] Packages needed by the future expression (n = 0): <none>
[11:01:30.248] Packages needed by future strategies (n = 0): <none>
[11:01:30.249] {
[11:01:30.249]     {
[11:01:30.249]         {
[11:01:30.249]             ...future.startTime <- base::Sys.time()
[11:01:30.249]             {
[11:01:30.249]                 {
[11:01:30.249]                   {
[11:01:30.249]                     {
[11:01:30.249]                       base::local({
[11:01:30.249]                         has_future <- base::requireNamespace("future", 
[11:01:30.249]                           quietly = TRUE)
[11:01:30.249]                         if (has_future) {
[11:01:30.249]                           ns <- base::getNamespace("future")
[11:01:30.249]                           version <- ns[[".package"]][["version"]]
[11:01:30.249]                           if (is.null(version)) 
[11:01:30.249]                             version <- utils::packageVersion("future")
[11:01:30.249]                         }
[11:01:30.249]                         else {
[11:01:30.249]                           version <- NULL
[11:01:30.249]                         }
[11:01:30.249]                         if (!has_future || version < "1.8.0") {
[11:01:30.249]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.249]                             "", base::R.version$version.string), 
[11:01:30.249]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.249]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.249]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.249]                               "release", "version")], collapse = " "), 
[11:01:30.249]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.249]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.249]                             info)
[11:01:30.249]                           info <- base::paste(info, collapse = "; ")
[11:01:30.249]                           if (!has_future) {
[11:01:30.249]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.249]                               info)
[11:01:30.249]                           }
[11:01:30.249]                           else {
[11:01:30.249]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.249]                               info, version)
[11:01:30.249]                           }
[11:01:30.249]                           base::stop(msg)
[11:01:30.249]                         }
[11:01:30.249]                       })
[11:01:30.249]                     }
[11:01:30.249]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.249]                     base::options(mc.cores = 1L)
[11:01:30.249]                   }
[11:01:30.249]                   ...future.strategy.old <- future::plan("list")
[11:01:30.249]                   options(future.plan = NULL)
[11:01:30.249]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.249]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.249]                 }
[11:01:30.249]                 ...future.workdir <- getwd()
[11:01:30.249]             }
[11:01:30.249]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.249]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.249]         }
[11:01:30.249]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.249]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.249]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.249]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.249]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.249]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.249]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.249]             base::names(...future.oldOptions))
[11:01:30.249]     }
[11:01:30.249]     if (FALSE) {
[11:01:30.249]     }
[11:01:30.249]     else {
[11:01:30.249]         if (TRUE) {
[11:01:30.249]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.249]                 open = "w")
[11:01:30.249]         }
[11:01:30.249]         else {
[11:01:30.249]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.249]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.249]         }
[11:01:30.249]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.249]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.249]             base::sink(type = "output", split = FALSE)
[11:01:30.249]             base::close(...future.stdout)
[11:01:30.249]         }, add = TRUE)
[11:01:30.249]     }
[11:01:30.249]     ...future.frame <- base::sys.nframe()
[11:01:30.249]     ...future.conditions <- base::list()
[11:01:30.249]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.249]     if (FALSE) {
[11:01:30.249]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.249]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.249]     }
[11:01:30.249]     ...future.result <- base::tryCatch({
[11:01:30.249]         base::withCallingHandlers({
[11:01:30.249]             ...future.value <- base::withVisible(base::local({
[11:01:30.249]                 ...future.makeSendCondition <- base::local({
[11:01:30.249]                   sendCondition <- NULL
[11:01:30.249]                   function(frame = 1L) {
[11:01:30.249]                     if (is.function(sendCondition)) 
[11:01:30.249]                       return(sendCondition)
[11:01:30.249]                     ns <- getNamespace("parallel")
[11:01:30.249]                     if (exists("sendData", mode = "function", 
[11:01:30.249]                       envir = ns)) {
[11:01:30.249]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.249]                         envir = ns)
[11:01:30.249]                       envir <- sys.frame(frame)
[11:01:30.249]                       master <- NULL
[11:01:30.249]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.249]                         !identical(envir, emptyenv())) {
[11:01:30.249]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.249]                           inherits = FALSE)) {
[11:01:30.249]                           master <- get("master", mode = "list", 
[11:01:30.249]                             envir = envir, inherits = FALSE)
[11:01:30.249]                           if (inherits(master, c("SOCKnode", 
[11:01:30.249]                             "SOCK0node"))) {
[11:01:30.249]                             sendCondition <<- function(cond) {
[11:01:30.249]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.249]                                 success = TRUE)
[11:01:30.249]                               parallel_sendData(master, data)
[11:01:30.249]                             }
[11:01:30.249]                             return(sendCondition)
[11:01:30.249]                           }
[11:01:30.249]                         }
[11:01:30.249]                         frame <- frame + 1L
[11:01:30.249]                         envir <- sys.frame(frame)
[11:01:30.249]                       }
[11:01:30.249]                     }
[11:01:30.249]                     sendCondition <<- function(cond) NULL
[11:01:30.249]                   }
[11:01:30.249]                 })
[11:01:30.249]                 withCallingHandlers({
[11:01:30.249]                   NULL
[11:01:30.249]                 }, immediateCondition = function(cond) {
[11:01:30.249]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.249]                   sendCondition(cond)
[11:01:30.249]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.249]                   {
[11:01:30.249]                     inherits <- base::inherits
[11:01:30.249]                     invokeRestart <- base::invokeRestart
[11:01:30.249]                     is.null <- base::is.null
[11:01:30.249]                     muffled <- FALSE
[11:01:30.249]                     if (inherits(cond, "message")) {
[11:01:30.249]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.249]                       if (muffled) 
[11:01:30.249]                         invokeRestart("muffleMessage")
[11:01:30.249]                     }
[11:01:30.249]                     else if (inherits(cond, "warning")) {
[11:01:30.249]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.249]                       if (muffled) 
[11:01:30.249]                         invokeRestart("muffleWarning")
[11:01:30.249]                     }
[11:01:30.249]                     else if (inherits(cond, "condition")) {
[11:01:30.249]                       if (!is.null(pattern)) {
[11:01:30.249]                         computeRestarts <- base::computeRestarts
[11:01:30.249]                         grepl <- base::grepl
[11:01:30.249]                         restarts <- computeRestarts(cond)
[11:01:30.249]                         for (restart in restarts) {
[11:01:30.249]                           name <- restart$name
[11:01:30.249]                           if (is.null(name)) 
[11:01:30.249]                             next
[11:01:30.249]                           if (!grepl(pattern, name)) 
[11:01:30.249]                             next
[11:01:30.249]                           invokeRestart(restart)
[11:01:30.249]                           muffled <- TRUE
[11:01:30.249]                           break
[11:01:30.249]                         }
[11:01:30.249]                       }
[11:01:30.249]                     }
[11:01:30.249]                     invisible(muffled)
[11:01:30.249]                   }
[11:01:30.249]                   muffleCondition(cond)
[11:01:30.249]                 })
[11:01:30.249]             }))
[11:01:30.249]             future::FutureResult(value = ...future.value$value, 
[11:01:30.249]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.249]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.249]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.249]                     ...future.globalenv.names))
[11:01:30.249]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.249]         }, condition = base::local({
[11:01:30.249]             c <- base::c
[11:01:30.249]             inherits <- base::inherits
[11:01:30.249]             invokeRestart <- base::invokeRestart
[11:01:30.249]             length <- base::length
[11:01:30.249]             list <- base::list
[11:01:30.249]             seq.int <- base::seq.int
[11:01:30.249]             signalCondition <- base::signalCondition
[11:01:30.249]             sys.calls <- base::sys.calls
[11:01:30.249]             `[[` <- base::`[[`
[11:01:30.249]             `+` <- base::`+`
[11:01:30.249]             `<<-` <- base::`<<-`
[11:01:30.249]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.249]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.249]                   3L)]
[11:01:30.249]             }
[11:01:30.249]             function(cond) {
[11:01:30.249]                 is_error <- inherits(cond, "error")
[11:01:30.249]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.249]                   NULL)
[11:01:30.249]                 if (is_error) {
[11:01:30.249]                   sessionInformation <- function() {
[11:01:30.249]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.249]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.249]                       search = base::search(), system = base::Sys.info())
[11:01:30.249]                   }
[11:01:30.249]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.249]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.249]                     cond$call), session = sessionInformation(), 
[11:01:30.249]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.249]                   signalCondition(cond)
[11:01:30.249]                 }
[11:01:30.249]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.249]                 "immediateCondition"))) {
[11:01:30.249]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.249]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.249]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.249]                   if (TRUE && !signal) {
[11:01:30.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.249]                     {
[11:01:30.249]                       inherits <- base::inherits
[11:01:30.249]                       invokeRestart <- base::invokeRestart
[11:01:30.249]                       is.null <- base::is.null
[11:01:30.249]                       muffled <- FALSE
[11:01:30.249]                       if (inherits(cond, "message")) {
[11:01:30.249]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.249]                         if (muffled) 
[11:01:30.249]                           invokeRestart("muffleMessage")
[11:01:30.249]                       }
[11:01:30.249]                       else if (inherits(cond, "warning")) {
[11:01:30.249]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.249]                         if (muffled) 
[11:01:30.249]                           invokeRestart("muffleWarning")
[11:01:30.249]                       }
[11:01:30.249]                       else if (inherits(cond, "condition")) {
[11:01:30.249]                         if (!is.null(pattern)) {
[11:01:30.249]                           computeRestarts <- base::computeRestarts
[11:01:30.249]                           grepl <- base::grepl
[11:01:30.249]                           restarts <- computeRestarts(cond)
[11:01:30.249]                           for (restart in restarts) {
[11:01:30.249]                             name <- restart$name
[11:01:30.249]                             if (is.null(name)) 
[11:01:30.249]                               next
[11:01:30.249]                             if (!grepl(pattern, name)) 
[11:01:30.249]                               next
[11:01:30.249]                             invokeRestart(restart)
[11:01:30.249]                             muffled <- TRUE
[11:01:30.249]                             break
[11:01:30.249]                           }
[11:01:30.249]                         }
[11:01:30.249]                       }
[11:01:30.249]                       invisible(muffled)
[11:01:30.249]                     }
[11:01:30.249]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.249]                   }
[11:01:30.249]                 }
[11:01:30.249]                 else {
[11:01:30.249]                   if (TRUE) {
[11:01:30.249]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.249]                     {
[11:01:30.249]                       inherits <- base::inherits
[11:01:30.249]                       invokeRestart <- base::invokeRestart
[11:01:30.249]                       is.null <- base::is.null
[11:01:30.249]                       muffled <- FALSE
[11:01:30.249]                       if (inherits(cond, "message")) {
[11:01:30.249]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.249]                         if (muffled) 
[11:01:30.249]                           invokeRestart("muffleMessage")
[11:01:30.249]                       }
[11:01:30.249]                       else if (inherits(cond, "warning")) {
[11:01:30.249]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.249]                         if (muffled) 
[11:01:30.249]                           invokeRestart("muffleWarning")
[11:01:30.249]                       }
[11:01:30.249]                       else if (inherits(cond, "condition")) {
[11:01:30.249]                         if (!is.null(pattern)) {
[11:01:30.249]                           computeRestarts <- base::computeRestarts
[11:01:30.249]                           grepl <- base::grepl
[11:01:30.249]                           restarts <- computeRestarts(cond)
[11:01:30.249]                           for (restart in restarts) {
[11:01:30.249]                             name <- restart$name
[11:01:30.249]                             if (is.null(name)) 
[11:01:30.249]                               next
[11:01:30.249]                             if (!grepl(pattern, name)) 
[11:01:30.249]                               next
[11:01:30.249]                             invokeRestart(restart)
[11:01:30.249]                             muffled <- TRUE
[11:01:30.249]                             break
[11:01:30.249]                           }
[11:01:30.249]                         }
[11:01:30.249]                       }
[11:01:30.249]                       invisible(muffled)
[11:01:30.249]                     }
[11:01:30.249]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.249]                   }
[11:01:30.249]                 }
[11:01:30.249]             }
[11:01:30.249]         }))
[11:01:30.249]     }, error = function(ex) {
[11:01:30.249]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.249]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.249]                 ...future.rng), started = ...future.startTime, 
[11:01:30.249]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.249]             version = "1.8"), class = "FutureResult")
[11:01:30.249]     }, finally = {
[11:01:30.249]         if (!identical(...future.workdir, getwd())) 
[11:01:30.249]             setwd(...future.workdir)
[11:01:30.249]         {
[11:01:30.249]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.249]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.249]             }
[11:01:30.249]             base::options(...future.oldOptions)
[11:01:30.249]             if (.Platform$OS.type == "windows") {
[11:01:30.249]                 old_names <- names(...future.oldEnvVars)
[11:01:30.249]                 envs <- base::Sys.getenv()
[11:01:30.249]                 names <- names(envs)
[11:01:30.249]                 common <- intersect(names, old_names)
[11:01:30.249]                 added <- setdiff(names, old_names)
[11:01:30.249]                 removed <- setdiff(old_names, names)
[11:01:30.249]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.249]                   envs[common]]
[11:01:30.249]                 NAMES <- toupper(changed)
[11:01:30.249]                 args <- list()
[11:01:30.249]                 for (kk in seq_along(NAMES)) {
[11:01:30.249]                   name <- changed[[kk]]
[11:01:30.249]                   NAME <- NAMES[[kk]]
[11:01:30.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.249]                     next
[11:01:30.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.249]                 }
[11:01:30.249]                 NAMES <- toupper(added)
[11:01:30.249]                 for (kk in seq_along(NAMES)) {
[11:01:30.249]                   name <- added[[kk]]
[11:01:30.249]                   NAME <- NAMES[[kk]]
[11:01:30.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.249]                     next
[11:01:30.249]                   args[[name]] <- ""
[11:01:30.249]                 }
[11:01:30.249]                 NAMES <- toupper(removed)
[11:01:30.249]                 for (kk in seq_along(NAMES)) {
[11:01:30.249]                   name <- removed[[kk]]
[11:01:30.249]                   NAME <- NAMES[[kk]]
[11:01:30.249]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.249]                     next
[11:01:30.249]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.249]                 }
[11:01:30.249]                 if (length(args) > 0) 
[11:01:30.249]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.249]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.249]             }
[11:01:30.249]             else {
[11:01:30.249]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.249]             }
[11:01:30.249]             {
[11:01:30.249]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.249]                   0L) {
[11:01:30.249]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.249]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.249]                   base::options(opts)
[11:01:30.249]                 }
[11:01:30.249]                 {
[11:01:30.249]                   {
[11:01:30.249]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.249]                     NULL
[11:01:30.249]                   }
[11:01:30.249]                   options(future.plan = NULL)
[11:01:30.249]                   if (is.na(NA_character_)) 
[11:01:30.249]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.249]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.249]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.249]                     .init = FALSE)
[11:01:30.249]                 }
[11:01:30.249]             }
[11:01:30.249]         }
[11:01:30.249]     })
[11:01:30.249]     if (TRUE) {
[11:01:30.249]         base::sink(type = "output", split = FALSE)
[11:01:30.249]         if (TRUE) {
[11:01:30.249]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.249]         }
[11:01:30.249]         else {
[11:01:30.249]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.249]         }
[11:01:30.249]         base::close(...future.stdout)
[11:01:30.249]         ...future.stdout <- NULL
[11:01:30.249]     }
[11:01:30.249]     ...future.result$conditions <- ...future.conditions
[11:01:30.249]     ...future.result$finished <- base::Sys.time()
[11:01:30.249]     ...future.result
[11:01:30.249] }
[11:01:30.252] MultisessionFuture started
[11:01:30.252] - Launch lazy future ... done
[11:01:30.252] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c8473648> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c88f8c18> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c8473648> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c88f8c18> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 logi [1, 1:6] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:30.283] resolve() on list ...
[11:01:30.283]  recursive: 0
[11:01:30.283]  length: 6
[11:01:30.283]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:30.283] signalConditionsASAP(numeric, pos=1) ...
[11:01:30.283] - nx: 6
[11:01:30.283] - relay: TRUE
[11:01:30.283] - stdout: TRUE
[11:01:30.283] - signal: TRUE
[11:01:30.284] - resignal: FALSE
[11:01:30.284] - force: TRUE
[11:01:30.284] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.284] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.284]  - until=2
[11:01:30.284]  - relaying element #2
[11:01:30.284] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.284] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.284] signalConditionsASAP(NULL, pos=1) ... done
[11:01:30.284]  length: 5 (resolved future 1)
[11:01:30.285] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.285] - Validating connection of MultisessionFuture
[11:01:30.285] - received message: FutureResult
[11:01:30.285] - Received FutureResult
[11:01:30.285] - Erased future from FutureRegistry
[11:01:30.285] result() for ClusterFuture ...
[11:01:30.285] - result already collected: FutureResult
[11:01:30.285] result() for ClusterFuture ... done
[11:01:30.286] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.286] Future #2
[11:01:30.286] result() for ClusterFuture ...
[11:01:30.286] - result already collected: FutureResult
[11:01:30.286] result() for ClusterFuture ... done
[11:01:30.286] result() for ClusterFuture ...
[11:01:30.286] - result already collected: FutureResult
[11:01:30.286] result() for ClusterFuture ... done
[11:01:30.286] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:30.286] - nx: 6
[11:01:30.286] - relay: TRUE
[11:01:30.286] - stdout: TRUE
[11:01:30.286] - signal: TRUE
[11:01:30.287] - resignal: FALSE
[11:01:30.287] - force: TRUE
[11:01:30.287] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.287] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.287]  - until=2
[11:01:30.287]  - relaying element #2
[11:01:30.287] result() for ClusterFuture ...
[11:01:30.287] - result already collected: FutureResult
[11:01:30.287] result() for ClusterFuture ... done
[11:01:30.287] result() for ClusterFuture ...
[11:01:30.287] - result already collected: FutureResult
[11:01:30.287] result() for ClusterFuture ... done
[11:01:30.287] result() for ClusterFuture ...
[11:01:30.288] - result already collected: FutureResult
[11:01:30.288] result() for ClusterFuture ... done
[11:01:30.288] result() for ClusterFuture ...
[11:01:30.288] - result already collected: FutureResult
[11:01:30.288] result() for ClusterFuture ... done
[11:01:30.288] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.288] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.288] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:30.288]  length: 4 (resolved future 2)
[11:01:30.294] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.294] - Validating connection of MultisessionFuture
[11:01:30.295] - received message: FutureResult
[11:01:30.295] - Received FutureResult
[11:01:30.295] - Erased future from FutureRegistry
[11:01:30.295] result() for ClusterFuture ...
[11:01:30.295] - result already collected: FutureResult
[11:01:30.295] result() for ClusterFuture ... done
[11:01:30.295] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.295] Future #3
[11:01:30.295] result() for ClusterFuture ...
[11:01:30.295] - result already collected: FutureResult
[11:01:30.295] result() for ClusterFuture ... done
[11:01:30.296] result() for ClusterFuture ...
[11:01:30.296] - result already collected: FutureResult
[11:01:30.296] result() for ClusterFuture ... done
[11:01:30.296] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:30.296] - nx: 6
[11:01:30.296] - relay: TRUE
[11:01:30.296] - stdout: TRUE
[11:01:30.296] - signal: TRUE
[11:01:30.296] - resignal: FALSE
[11:01:30.296] - force: TRUE
[11:01:30.296] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.296] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.296]  - until=3
[11:01:30.297]  - relaying element #3
[11:01:30.297] result() for ClusterFuture ...
[11:01:30.297] - result already collected: FutureResult
[11:01:30.297] result() for ClusterFuture ... done
[11:01:30.297] result() for ClusterFuture ...
[11:01:30.297] - result already collected: FutureResult
[11:01:30.297] result() for ClusterFuture ... done
[11:01:30.297] result() for ClusterFuture ...
[11:01:30.297] - result already collected: FutureResult
[11:01:30.297] result() for ClusterFuture ... done
[11:01:30.297] result() for ClusterFuture ...
[11:01:30.297] - result already collected: FutureResult
[11:01:30.298] result() for ClusterFuture ... done
[11:01:30.298] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.298] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.298] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:30.298]  length: 3 (resolved future 3)
[11:01:30.298] signalConditionsASAP(NULL, pos=4) ...
[11:01:30.298] - nx: 6
[11:01:30.298] - relay: TRUE
[11:01:30.298] - stdout: TRUE
[11:01:30.298] - signal: TRUE
[11:01:30.298] - resignal: FALSE
[11:01:30.298] - force: TRUE
[11:01:30.299] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.299] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.299]  - until=5
[11:01:30.299]  - relaying element #5
[11:01:30.299] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.299] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.299] signalConditionsASAP(NULL, pos=4) ... done
[11:01:30.299]  length: 2 (resolved future 4)
[11:01:30.299] signalConditionsASAP(NULL, pos=5) ...
[11:01:30.299] - nx: 6
[11:01:30.299] - relay: TRUE
[11:01:30.299] - stdout: TRUE
[11:01:30.299] - signal: TRUE
[11:01:30.300] - resignal: FALSE
[11:01:30.300] - force: TRUE
[11:01:30.300] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.300] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.300]  - until=6
[11:01:30.300]  - relaying element #6
[11:01:30.300] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.300] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.300] signalConditionsASAP(NULL, pos=5) ... done
[11:01:30.300]  length: 1 (resolved future 5)
[11:01:30.300] signalConditionsASAP(numeric, pos=6) ...
[11:01:30.300] - nx: 6
[11:01:30.300] - relay: TRUE
[11:01:30.301] - stdout: TRUE
[11:01:30.301] - signal: TRUE
[11:01:30.301] - resignal: FALSE
[11:01:30.301] - force: TRUE
[11:01:30.301] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.301] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.301]  - until=6
[11:01:30.301] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.301] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.301] signalConditionsASAP(numeric, pos=6) ... done
[11:01:30.301]  length: 0 (resolved future 6)
[11:01:30.301] Relaying remaining futures
[11:01:30.301] signalConditionsASAP(NULL, pos=0) ...
[11:01:30.302] - nx: 6
[11:01:30.302] - relay: TRUE
[11:01:30.302] - stdout: TRUE
[11:01:30.302] - signal: TRUE
[11:01:30.302] - resignal: FALSE
[11:01:30.302] - force: TRUE
[11:01:30.302] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.302] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:30.302] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.302] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.302] signalConditionsASAP(NULL, pos=0) ... done
[11:01:30.302] resolve() on list ... DONE
[11:01:30.303] result() for ClusterFuture ...
[11:01:30.303] - result already collected: FutureResult
[11:01:30.303] result() for ClusterFuture ... done
[11:01:30.303] result() for ClusterFuture ...
[11:01:30.303] - result already collected: FutureResult
[11:01:30.303] result() for ClusterFuture ... done
[11:01:30.303] result() for ClusterFuture ...
[11:01:30.303] - result already collected: FutureResult
[11:01:30.303] result() for ClusterFuture ... done
[11:01:30.303] result() for ClusterFuture ...
[11:01:30.303] - result already collected: FutureResult
[11:01:30.303] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 1 6
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[11:01:30.306] getGlobalsAndPackages() ...
[11:01:30.306] Searching for globals...
[11:01:30.307] 
[11:01:30.307] Searching for globals ... DONE
[11:01:30.307] - globals: [0] <none>
[11:01:30.307] getGlobalsAndPackages() ... DONE
[11:01:30.307] run() for ‘Future’ ...
[11:01:30.307] - state: ‘created’
[11:01:30.307] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.323] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.323] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.323]   - Field: ‘node’
[11:01:30.323]   - Field: ‘label’
[11:01:30.323]   - Field: ‘local’
[11:01:30.323]   - Field: ‘owner’
[11:01:30.323]   - Field: ‘envir’
[11:01:30.324]   - Field: ‘workers’
[11:01:30.324]   - Field: ‘packages’
[11:01:30.324]   - Field: ‘gc’
[11:01:30.324]   - Field: ‘conditions’
[11:01:30.324]   - Field: ‘persistent’
[11:01:30.324]   - Field: ‘expr’
[11:01:30.324]   - Field: ‘uuid’
[11:01:30.324]   - Field: ‘seed’
[11:01:30.324]   - Field: ‘version’
[11:01:30.324]   - Field: ‘result’
[11:01:30.324]   - Field: ‘asynchronous’
[11:01:30.324]   - Field: ‘calls’
[11:01:30.325]   - Field: ‘globals’
[11:01:30.325]   - Field: ‘stdout’
[11:01:30.325]   - Field: ‘earlySignal’
[11:01:30.325]   - Field: ‘lazy’
[11:01:30.325]   - Field: ‘state’
[11:01:30.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.325] - Launch lazy future ...
[11:01:30.325] Packages needed by the future expression (n = 0): <none>
[11:01:30.325] Packages needed by future strategies (n = 0): <none>
[11:01:30.326] {
[11:01:30.326]     {
[11:01:30.326]         {
[11:01:30.326]             ...future.startTime <- base::Sys.time()
[11:01:30.326]             {
[11:01:30.326]                 {
[11:01:30.326]                   {
[11:01:30.326]                     {
[11:01:30.326]                       base::local({
[11:01:30.326]                         has_future <- base::requireNamespace("future", 
[11:01:30.326]                           quietly = TRUE)
[11:01:30.326]                         if (has_future) {
[11:01:30.326]                           ns <- base::getNamespace("future")
[11:01:30.326]                           version <- ns[[".package"]][["version"]]
[11:01:30.326]                           if (is.null(version)) 
[11:01:30.326]                             version <- utils::packageVersion("future")
[11:01:30.326]                         }
[11:01:30.326]                         else {
[11:01:30.326]                           version <- NULL
[11:01:30.326]                         }
[11:01:30.326]                         if (!has_future || version < "1.8.0") {
[11:01:30.326]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.326]                             "", base::R.version$version.string), 
[11:01:30.326]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.326]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.326]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.326]                               "release", "version")], collapse = " "), 
[11:01:30.326]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.326]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.326]                             info)
[11:01:30.326]                           info <- base::paste(info, collapse = "; ")
[11:01:30.326]                           if (!has_future) {
[11:01:30.326]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.326]                               info)
[11:01:30.326]                           }
[11:01:30.326]                           else {
[11:01:30.326]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.326]                               info, version)
[11:01:30.326]                           }
[11:01:30.326]                           base::stop(msg)
[11:01:30.326]                         }
[11:01:30.326]                       })
[11:01:30.326]                     }
[11:01:30.326]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.326]                     base::options(mc.cores = 1L)
[11:01:30.326]                   }
[11:01:30.326]                   ...future.strategy.old <- future::plan("list")
[11:01:30.326]                   options(future.plan = NULL)
[11:01:30.326]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.326]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.326]                 }
[11:01:30.326]                 ...future.workdir <- getwd()
[11:01:30.326]             }
[11:01:30.326]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.326]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.326]         }
[11:01:30.326]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.326]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.326]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.326]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.326]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.326]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.326]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.326]             base::names(...future.oldOptions))
[11:01:30.326]     }
[11:01:30.326]     if (FALSE) {
[11:01:30.326]     }
[11:01:30.326]     else {
[11:01:30.326]         if (TRUE) {
[11:01:30.326]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.326]                 open = "w")
[11:01:30.326]         }
[11:01:30.326]         else {
[11:01:30.326]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.326]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.326]         }
[11:01:30.326]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.326]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.326]             base::sink(type = "output", split = FALSE)
[11:01:30.326]             base::close(...future.stdout)
[11:01:30.326]         }, add = TRUE)
[11:01:30.326]     }
[11:01:30.326]     ...future.frame <- base::sys.nframe()
[11:01:30.326]     ...future.conditions <- base::list()
[11:01:30.326]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.326]     if (FALSE) {
[11:01:30.326]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.326]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.326]     }
[11:01:30.326]     ...future.result <- base::tryCatch({
[11:01:30.326]         base::withCallingHandlers({
[11:01:30.326]             ...future.value <- base::withVisible(base::local({
[11:01:30.326]                 ...future.makeSendCondition <- base::local({
[11:01:30.326]                   sendCondition <- NULL
[11:01:30.326]                   function(frame = 1L) {
[11:01:30.326]                     if (is.function(sendCondition)) 
[11:01:30.326]                       return(sendCondition)
[11:01:30.326]                     ns <- getNamespace("parallel")
[11:01:30.326]                     if (exists("sendData", mode = "function", 
[11:01:30.326]                       envir = ns)) {
[11:01:30.326]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.326]                         envir = ns)
[11:01:30.326]                       envir <- sys.frame(frame)
[11:01:30.326]                       master <- NULL
[11:01:30.326]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.326]                         !identical(envir, emptyenv())) {
[11:01:30.326]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.326]                           inherits = FALSE)) {
[11:01:30.326]                           master <- get("master", mode = "list", 
[11:01:30.326]                             envir = envir, inherits = FALSE)
[11:01:30.326]                           if (inherits(master, c("SOCKnode", 
[11:01:30.326]                             "SOCK0node"))) {
[11:01:30.326]                             sendCondition <<- function(cond) {
[11:01:30.326]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.326]                                 success = TRUE)
[11:01:30.326]                               parallel_sendData(master, data)
[11:01:30.326]                             }
[11:01:30.326]                             return(sendCondition)
[11:01:30.326]                           }
[11:01:30.326]                         }
[11:01:30.326]                         frame <- frame + 1L
[11:01:30.326]                         envir <- sys.frame(frame)
[11:01:30.326]                       }
[11:01:30.326]                     }
[11:01:30.326]                     sendCondition <<- function(cond) NULL
[11:01:30.326]                   }
[11:01:30.326]                 })
[11:01:30.326]                 withCallingHandlers({
[11:01:30.326]                   2
[11:01:30.326]                 }, immediateCondition = function(cond) {
[11:01:30.326]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.326]                   sendCondition(cond)
[11:01:30.326]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.326]                   {
[11:01:30.326]                     inherits <- base::inherits
[11:01:30.326]                     invokeRestart <- base::invokeRestart
[11:01:30.326]                     is.null <- base::is.null
[11:01:30.326]                     muffled <- FALSE
[11:01:30.326]                     if (inherits(cond, "message")) {
[11:01:30.326]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.326]                       if (muffled) 
[11:01:30.326]                         invokeRestart("muffleMessage")
[11:01:30.326]                     }
[11:01:30.326]                     else if (inherits(cond, "warning")) {
[11:01:30.326]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.326]                       if (muffled) 
[11:01:30.326]                         invokeRestart("muffleWarning")
[11:01:30.326]                     }
[11:01:30.326]                     else if (inherits(cond, "condition")) {
[11:01:30.326]                       if (!is.null(pattern)) {
[11:01:30.326]                         computeRestarts <- base::computeRestarts
[11:01:30.326]                         grepl <- base::grepl
[11:01:30.326]                         restarts <- computeRestarts(cond)
[11:01:30.326]                         for (restart in restarts) {
[11:01:30.326]                           name <- restart$name
[11:01:30.326]                           if (is.null(name)) 
[11:01:30.326]                             next
[11:01:30.326]                           if (!grepl(pattern, name)) 
[11:01:30.326]                             next
[11:01:30.326]                           invokeRestart(restart)
[11:01:30.326]                           muffled <- TRUE
[11:01:30.326]                           break
[11:01:30.326]                         }
[11:01:30.326]                       }
[11:01:30.326]                     }
[11:01:30.326]                     invisible(muffled)
[11:01:30.326]                   }
[11:01:30.326]                   muffleCondition(cond)
[11:01:30.326]                 })
[11:01:30.326]             }))
[11:01:30.326]             future::FutureResult(value = ...future.value$value, 
[11:01:30.326]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.326]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.326]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.326]                     ...future.globalenv.names))
[11:01:30.326]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.326]         }, condition = base::local({
[11:01:30.326]             c <- base::c
[11:01:30.326]             inherits <- base::inherits
[11:01:30.326]             invokeRestart <- base::invokeRestart
[11:01:30.326]             length <- base::length
[11:01:30.326]             list <- base::list
[11:01:30.326]             seq.int <- base::seq.int
[11:01:30.326]             signalCondition <- base::signalCondition
[11:01:30.326]             sys.calls <- base::sys.calls
[11:01:30.326]             `[[` <- base::`[[`
[11:01:30.326]             `+` <- base::`+`
[11:01:30.326]             `<<-` <- base::`<<-`
[11:01:30.326]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.326]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.326]                   3L)]
[11:01:30.326]             }
[11:01:30.326]             function(cond) {
[11:01:30.326]                 is_error <- inherits(cond, "error")
[11:01:30.326]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.326]                   NULL)
[11:01:30.326]                 if (is_error) {
[11:01:30.326]                   sessionInformation <- function() {
[11:01:30.326]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.326]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.326]                       search = base::search(), system = base::Sys.info())
[11:01:30.326]                   }
[11:01:30.326]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.326]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.326]                     cond$call), session = sessionInformation(), 
[11:01:30.326]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.326]                   signalCondition(cond)
[11:01:30.326]                 }
[11:01:30.326]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.326]                 "immediateCondition"))) {
[11:01:30.326]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.326]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.326]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.326]                   if (TRUE && !signal) {
[11:01:30.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.326]                     {
[11:01:30.326]                       inherits <- base::inherits
[11:01:30.326]                       invokeRestart <- base::invokeRestart
[11:01:30.326]                       is.null <- base::is.null
[11:01:30.326]                       muffled <- FALSE
[11:01:30.326]                       if (inherits(cond, "message")) {
[11:01:30.326]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.326]                         if (muffled) 
[11:01:30.326]                           invokeRestart("muffleMessage")
[11:01:30.326]                       }
[11:01:30.326]                       else if (inherits(cond, "warning")) {
[11:01:30.326]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.326]                         if (muffled) 
[11:01:30.326]                           invokeRestart("muffleWarning")
[11:01:30.326]                       }
[11:01:30.326]                       else if (inherits(cond, "condition")) {
[11:01:30.326]                         if (!is.null(pattern)) {
[11:01:30.326]                           computeRestarts <- base::computeRestarts
[11:01:30.326]                           grepl <- base::grepl
[11:01:30.326]                           restarts <- computeRestarts(cond)
[11:01:30.326]                           for (restart in restarts) {
[11:01:30.326]                             name <- restart$name
[11:01:30.326]                             if (is.null(name)) 
[11:01:30.326]                               next
[11:01:30.326]                             if (!grepl(pattern, name)) 
[11:01:30.326]                               next
[11:01:30.326]                             invokeRestart(restart)
[11:01:30.326]                             muffled <- TRUE
[11:01:30.326]                             break
[11:01:30.326]                           }
[11:01:30.326]                         }
[11:01:30.326]                       }
[11:01:30.326]                       invisible(muffled)
[11:01:30.326]                     }
[11:01:30.326]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.326]                   }
[11:01:30.326]                 }
[11:01:30.326]                 else {
[11:01:30.326]                   if (TRUE) {
[11:01:30.326]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.326]                     {
[11:01:30.326]                       inherits <- base::inherits
[11:01:30.326]                       invokeRestart <- base::invokeRestart
[11:01:30.326]                       is.null <- base::is.null
[11:01:30.326]                       muffled <- FALSE
[11:01:30.326]                       if (inherits(cond, "message")) {
[11:01:30.326]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.326]                         if (muffled) 
[11:01:30.326]                           invokeRestart("muffleMessage")
[11:01:30.326]                       }
[11:01:30.326]                       else if (inherits(cond, "warning")) {
[11:01:30.326]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.326]                         if (muffled) 
[11:01:30.326]                           invokeRestart("muffleWarning")
[11:01:30.326]                       }
[11:01:30.326]                       else if (inherits(cond, "condition")) {
[11:01:30.326]                         if (!is.null(pattern)) {
[11:01:30.326]                           computeRestarts <- base::computeRestarts
[11:01:30.326]                           grepl <- base::grepl
[11:01:30.326]                           restarts <- computeRestarts(cond)
[11:01:30.326]                           for (restart in restarts) {
[11:01:30.326]                             name <- restart$name
[11:01:30.326]                             if (is.null(name)) 
[11:01:30.326]                               next
[11:01:30.326]                             if (!grepl(pattern, name)) 
[11:01:30.326]                               next
[11:01:30.326]                             invokeRestart(restart)
[11:01:30.326]                             muffled <- TRUE
[11:01:30.326]                             break
[11:01:30.326]                           }
[11:01:30.326]                         }
[11:01:30.326]                       }
[11:01:30.326]                       invisible(muffled)
[11:01:30.326]                     }
[11:01:30.326]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.326]                   }
[11:01:30.326]                 }
[11:01:30.326]             }
[11:01:30.326]         }))
[11:01:30.326]     }, error = function(ex) {
[11:01:30.326]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.326]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.326]                 ...future.rng), started = ...future.startTime, 
[11:01:30.326]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.326]             version = "1.8"), class = "FutureResult")
[11:01:30.326]     }, finally = {
[11:01:30.326]         if (!identical(...future.workdir, getwd())) 
[11:01:30.326]             setwd(...future.workdir)
[11:01:30.326]         {
[11:01:30.326]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.326]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.326]             }
[11:01:30.326]             base::options(...future.oldOptions)
[11:01:30.326]             if (.Platform$OS.type == "windows") {
[11:01:30.326]                 old_names <- names(...future.oldEnvVars)
[11:01:30.326]                 envs <- base::Sys.getenv()
[11:01:30.326]                 names <- names(envs)
[11:01:30.326]                 common <- intersect(names, old_names)
[11:01:30.326]                 added <- setdiff(names, old_names)
[11:01:30.326]                 removed <- setdiff(old_names, names)
[11:01:30.326]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.326]                   envs[common]]
[11:01:30.326]                 NAMES <- toupper(changed)
[11:01:30.326]                 args <- list()
[11:01:30.326]                 for (kk in seq_along(NAMES)) {
[11:01:30.326]                   name <- changed[[kk]]
[11:01:30.326]                   NAME <- NAMES[[kk]]
[11:01:30.326]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.326]                     next
[11:01:30.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.326]                 }
[11:01:30.326]                 NAMES <- toupper(added)
[11:01:30.326]                 for (kk in seq_along(NAMES)) {
[11:01:30.326]                   name <- added[[kk]]
[11:01:30.326]                   NAME <- NAMES[[kk]]
[11:01:30.326]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.326]                     next
[11:01:30.326]                   args[[name]] <- ""
[11:01:30.326]                 }
[11:01:30.326]                 NAMES <- toupper(removed)
[11:01:30.326]                 for (kk in seq_along(NAMES)) {
[11:01:30.326]                   name <- removed[[kk]]
[11:01:30.326]                   NAME <- NAMES[[kk]]
[11:01:30.326]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.326]                     next
[11:01:30.326]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.326]                 }
[11:01:30.326]                 if (length(args) > 0) 
[11:01:30.326]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.326]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.326]             }
[11:01:30.326]             else {
[11:01:30.326]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.326]             }
[11:01:30.326]             {
[11:01:30.326]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.326]                   0L) {
[11:01:30.326]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.326]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.326]                   base::options(opts)
[11:01:30.326]                 }
[11:01:30.326]                 {
[11:01:30.326]                   {
[11:01:30.326]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.326]                     NULL
[11:01:30.326]                   }
[11:01:30.326]                   options(future.plan = NULL)
[11:01:30.326]                   if (is.na(NA_character_)) 
[11:01:30.326]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.326]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.326]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.326]                     .init = FALSE)
[11:01:30.326]                 }
[11:01:30.326]             }
[11:01:30.326]         }
[11:01:30.326]     })
[11:01:30.326]     if (TRUE) {
[11:01:30.326]         base::sink(type = "output", split = FALSE)
[11:01:30.326]         if (TRUE) {
[11:01:30.326]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.326]         }
[11:01:30.326]         else {
[11:01:30.326]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.326]         }
[11:01:30.326]         base::close(...future.stdout)
[11:01:30.326]         ...future.stdout <- NULL
[11:01:30.326]     }
[11:01:30.326]     ...future.result$conditions <- ...future.conditions
[11:01:30.326]     ...future.result$finished <- base::Sys.time()
[11:01:30.326]     ...future.result
[11:01:30.326] }
[11:01:30.329] MultisessionFuture started
[11:01:30.329] - Launch lazy future ... done
[11:01:30.329] run() for ‘MultisessionFuture’ ... done
[11:01:30.329] getGlobalsAndPackages() ...
[11:01:30.329] Searching for globals...
[11:01:30.329] 
[11:01:30.329] Searching for globals ... DONE
[11:01:30.329] - globals: [0] <none>
[11:01:30.330] getGlobalsAndPackages() ... DONE
[11:01:30.330] run() for ‘Future’ ...
[11:01:30.330] - state: ‘created’
[11:01:30.330] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.343] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.343] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.344]   - Field: ‘node’
[11:01:30.344]   - Field: ‘label’
[11:01:30.344]   - Field: ‘local’
[11:01:30.344]   - Field: ‘owner’
[11:01:30.344]   - Field: ‘envir’
[11:01:30.344]   - Field: ‘workers’
[11:01:30.344]   - Field: ‘packages’
[11:01:30.344]   - Field: ‘gc’
[11:01:30.344]   - Field: ‘conditions’
[11:01:30.344]   - Field: ‘persistent’
[11:01:30.344]   - Field: ‘expr’
[11:01:30.345]   - Field: ‘uuid’
[11:01:30.345]   - Field: ‘seed’
[11:01:30.345]   - Field: ‘version’
[11:01:30.345]   - Field: ‘result’
[11:01:30.345]   - Field: ‘asynchronous’
[11:01:30.345]   - Field: ‘calls’
[11:01:30.345]   - Field: ‘globals’
[11:01:30.345]   - Field: ‘stdout’
[11:01:30.345]   - Field: ‘earlySignal’
[11:01:30.345]   - Field: ‘lazy’
[11:01:30.345]   - Field: ‘state’
[11:01:30.345] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.346] - Launch lazy future ...
[11:01:30.346] Packages needed by the future expression (n = 0): <none>
[11:01:30.346] Packages needed by future strategies (n = 0): <none>
[11:01:30.346] {
[11:01:30.346]     {
[11:01:30.346]         {
[11:01:30.346]             ...future.startTime <- base::Sys.time()
[11:01:30.346]             {
[11:01:30.346]                 {
[11:01:30.346]                   {
[11:01:30.346]                     {
[11:01:30.346]                       base::local({
[11:01:30.346]                         has_future <- base::requireNamespace("future", 
[11:01:30.346]                           quietly = TRUE)
[11:01:30.346]                         if (has_future) {
[11:01:30.346]                           ns <- base::getNamespace("future")
[11:01:30.346]                           version <- ns[[".package"]][["version"]]
[11:01:30.346]                           if (is.null(version)) 
[11:01:30.346]                             version <- utils::packageVersion("future")
[11:01:30.346]                         }
[11:01:30.346]                         else {
[11:01:30.346]                           version <- NULL
[11:01:30.346]                         }
[11:01:30.346]                         if (!has_future || version < "1.8.0") {
[11:01:30.346]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.346]                             "", base::R.version$version.string), 
[11:01:30.346]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.346]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.346]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.346]                               "release", "version")], collapse = " "), 
[11:01:30.346]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.346]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.346]                             info)
[11:01:30.346]                           info <- base::paste(info, collapse = "; ")
[11:01:30.346]                           if (!has_future) {
[11:01:30.346]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.346]                               info)
[11:01:30.346]                           }
[11:01:30.346]                           else {
[11:01:30.346]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.346]                               info, version)
[11:01:30.346]                           }
[11:01:30.346]                           base::stop(msg)
[11:01:30.346]                         }
[11:01:30.346]                       })
[11:01:30.346]                     }
[11:01:30.346]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.346]                     base::options(mc.cores = 1L)
[11:01:30.346]                   }
[11:01:30.346]                   ...future.strategy.old <- future::plan("list")
[11:01:30.346]                   options(future.plan = NULL)
[11:01:30.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.346]                 }
[11:01:30.346]                 ...future.workdir <- getwd()
[11:01:30.346]             }
[11:01:30.346]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.346]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.346]         }
[11:01:30.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.346]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.346]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.346]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.346]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.346]             base::names(...future.oldOptions))
[11:01:30.346]     }
[11:01:30.346]     if (FALSE) {
[11:01:30.346]     }
[11:01:30.346]     else {
[11:01:30.346]         if (TRUE) {
[11:01:30.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.346]                 open = "w")
[11:01:30.346]         }
[11:01:30.346]         else {
[11:01:30.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.346]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.346]         }
[11:01:30.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.346]             base::sink(type = "output", split = FALSE)
[11:01:30.346]             base::close(...future.stdout)
[11:01:30.346]         }, add = TRUE)
[11:01:30.346]     }
[11:01:30.346]     ...future.frame <- base::sys.nframe()
[11:01:30.346]     ...future.conditions <- base::list()
[11:01:30.346]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.346]     if (FALSE) {
[11:01:30.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.346]     }
[11:01:30.346]     ...future.result <- base::tryCatch({
[11:01:30.346]         base::withCallingHandlers({
[11:01:30.346]             ...future.value <- base::withVisible(base::local({
[11:01:30.346]                 ...future.makeSendCondition <- base::local({
[11:01:30.346]                   sendCondition <- NULL
[11:01:30.346]                   function(frame = 1L) {
[11:01:30.346]                     if (is.function(sendCondition)) 
[11:01:30.346]                       return(sendCondition)
[11:01:30.346]                     ns <- getNamespace("parallel")
[11:01:30.346]                     if (exists("sendData", mode = "function", 
[11:01:30.346]                       envir = ns)) {
[11:01:30.346]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.346]                         envir = ns)
[11:01:30.346]                       envir <- sys.frame(frame)
[11:01:30.346]                       master <- NULL
[11:01:30.346]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.346]                         !identical(envir, emptyenv())) {
[11:01:30.346]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.346]                           inherits = FALSE)) {
[11:01:30.346]                           master <- get("master", mode = "list", 
[11:01:30.346]                             envir = envir, inherits = FALSE)
[11:01:30.346]                           if (inherits(master, c("SOCKnode", 
[11:01:30.346]                             "SOCK0node"))) {
[11:01:30.346]                             sendCondition <<- function(cond) {
[11:01:30.346]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.346]                                 success = TRUE)
[11:01:30.346]                               parallel_sendData(master, data)
[11:01:30.346]                             }
[11:01:30.346]                             return(sendCondition)
[11:01:30.346]                           }
[11:01:30.346]                         }
[11:01:30.346]                         frame <- frame + 1L
[11:01:30.346]                         envir <- sys.frame(frame)
[11:01:30.346]                       }
[11:01:30.346]                     }
[11:01:30.346]                     sendCondition <<- function(cond) NULL
[11:01:30.346]                   }
[11:01:30.346]                 })
[11:01:30.346]                 withCallingHandlers({
[11:01:30.346]                   NULL
[11:01:30.346]                 }, immediateCondition = function(cond) {
[11:01:30.346]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.346]                   sendCondition(cond)
[11:01:30.346]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.346]                   {
[11:01:30.346]                     inherits <- base::inherits
[11:01:30.346]                     invokeRestart <- base::invokeRestart
[11:01:30.346]                     is.null <- base::is.null
[11:01:30.346]                     muffled <- FALSE
[11:01:30.346]                     if (inherits(cond, "message")) {
[11:01:30.346]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.346]                       if (muffled) 
[11:01:30.346]                         invokeRestart("muffleMessage")
[11:01:30.346]                     }
[11:01:30.346]                     else if (inherits(cond, "warning")) {
[11:01:30.346]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.346]                       if (muffled) 
[11:01:30.346]                         invokeRestart("muffleWarning")
[11:01:30.346]                     }
[11:01:30.346]                     else if (inherits(cond, "condition")) {
[11:01:30.346]                       if (!is.null(pattern)) {
[11:01:30.346]                         computeRestarts <- base::computeRestarts
[11:01:30.346]                         grepl <- base::grepl
[11:01:30.346]                         restarts <- computeRestarts(cond)
[11:01:30.346]                         for (restart in restarts) {
[11:01:30.346]                           name <- restart$name
[11:01:30.346]                           if (is.null(name)) 
[11:01:30.346]                             next
[11:01:30.346]                           if (!grepl(pattern, name)) 
[11:01:30.346]                             next
[11:01:30.346]                           invokeRestart(restart)
[11:01:30.346]                           muffled <- TRUE
[11:01:30.346]                           break
[11:01:30.346]                         }
[11:01:30.346]                       }
[11:01:30.346]                     }
[11:01:30.346]                     invisible(muffled)
[11:01:30.346]                   }
[11:01:30.346]                   muffleCondition(cond)
[11:01:30.346]                 })
[11:01:30.346]             }))
[11:01:30.346]             future::FutureResult(value = ...future.value$value, 
[11:01:30.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.346]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.346]                     ...future.globalenv.names))
[11:01:30.346]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.346]         }, condition = base::local({
[11:01:30.346]             c <- base::c
[11:01:30.346]             inherits <- base::inherits
[11:01:30.346]             invokeRestart <- base::invokeRestart
[11:01:30.346]             length <- base::length
[11:01:30.346]             list <- base::list
[11:01:30.346]             seq.int <- base::seq.int
[11:01:30.346]             signalCondition <- base::signalCondition
[11:01:30.346]             sys.calls <- base::sys.calls
[11:01:30.346]             `[[` <- base::`[[`
[11:01:30.346]             `+` <- base::`+`
[11:01:30.346]             `<<-` <- base::`<<-`
[11:01:30.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.346]                   3L)]
[11:01:30.346]             }
[11:01:30.346]             function(cond) {
[11:01:30.346]                 is_error <- inherits(cond, "error")
[11:01:30.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.346]                   NULL)
[11:01:30.346]                 if (is_error) {
[11:01:30.346]                   sessionInformation <- function() {
[11:01:30.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.346]                       search = base::search(), system = base::Sys.info())
[11:01:30.346]                   }
[11:01:30.346]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.346]                     cond$call), session = sessionInformation(), 
[11:01:30.346]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.346]                   signalCondition(cond)
[11:01:30.346]                 }
[11:01:30.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.346]                 "immediateCondition"))) {
[11:01:30.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.346]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.346]                   if (TRUE && !signal) {
[11:01:30.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.346]                     {
[11:01:30.346]                       inherits <- base::inherits
[11:01:30.346]                       invokeRestart <- base::invokeRestart
[11:01:30.346]                       is.null <- base::is.null
[11:01:30.346]                       muffled <- FALSE
[11:01:30.346]                       if (inherits(cond, "message")) {
[11:01:30.346]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.346]                         if (muffled) 
[11:01:30.346]                           invokeRestart("muffleMessage")
[11:01:30.346]                       }
[11:01:30.346]                       else if (inherits(cond, "warning")) {
[11:01:30.346]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.346]                         if (muffled) 
[11:01:30.346]                           invokeRestart("muffleWarning")
[11:01:30.346]                       }
[11:01:30.346]                       else if (inherits(cond, "condition")) {
[11:01:30.346]                         if (!is.null(pattern)) {
[11:01:30.346]                           computeRestarts <- base::computeRestarts
[11:01:30.346]                           grepl <- base::grepl
[11:01:30.346]                           restarts <- computeRestarts(cond)
[11:01:30.346]                           for (restart in restarts) {
[11:01:30.346]                             name <- restart$name
[11:01:30.346]                             if (is.null(name)) 
[11:01:30.346]                               next
[11:01:30.346]                             if (!grepl(pattern, name)) 
[11:01:30.346]                               next
[11:01:30.346]                             invokeRestart(restart)
[11:01:30.346]                             muffled <- TRUE
[11:01:30.346]                             break
[11:01:30.346]                           }
[11:01:30.346]                         }
[11:01:30.346]                       }
[11:01:30.346]                       invisible(muffled)
[11:01:30.346]                     }
[11:01:30.346]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.346]                   }
[11:01:30.346]                 }
[11:01:30.346]                 else {
[11:01:30.346]                   if (TRUE) {
[11:01:30.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.346]                     {
[11:01:30.346]                       inherits <- base::inherits
[11:01:30.346]                       invokeRestart <- base::invokeRestart
[11:01:30.346]                       is.null <- base::is.null
[11:01:30.346]                       muffled <- FALSE
[11:01:30.346]                       if (inherits(cond, "message")) {
[11:01:30.346]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.346]                         if (muffled) 
[11:01:30.346]                           invokeRestart("muffleMessage")
[11:01:30.346]                       }
[11:01:30.346]                       else if (inherits(cond, "warning")) {
[11:01:30.346]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.346]                         if (muffled) 
[11:01:30.346]                           invokeRestart("muffleWarning")
[11:01:30.346]                       }
[11:01:30.346]                       else if (inherits(cond, "condition")) {
[11:01:30.346]                         if (!is.null(pattern)) {
[11:01:30.346]                           computeRestarts <- base::computeRestarts
[11:01:30.346]                           grepl <- base::grepl
[11:01:30.346]                           restarts <- computeRestarts(cond)
[11:01:30.346]                           for (restart in restarts) {
[11:01:30.346]                             name <- restart$name
[11:01:30.346]                             if (is.null(name)) 
[11:01:30.346]                               next
[11:01:30.346]                             if (!grepl(pattern, name)) 
[11:01:30.346]                               next
[11:01:30.346]                             invokeRestart(restart)
[11:01:30.346]                             muffled <- TRUE
[11:01:30.346]                             break
[11:01:30.346]                           }
[11:01:30.346]                         }
[11:01:30.346]                       }
[11:01:30.346]                       invisible(muffled)
[11:01:30.346]                     }
[11:01:30.346]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.346]                   }
[11:01:30.346]                 }
[11:01:30.346]             }
[11:01:30.346]         }))
[11:01:30.346]     }, error = function(ex) {
[11:01:30.346]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.346]                 ...future.rng), started = ...future.startTime, 
[11:01:30.346]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.346]             version = "1.8"), class = "FutureResult")
[11:01:30.346]     }, finally = {
[11:01:30.346]         if (!identical(...future.workdir, getwd())) 
[11:01:30.346]             setwd(...future.workdir)
[11:01:30.346]         {
[11:01:30.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.346]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.346]             }
[11:01:30.346]             base::options(...future.oldOptions)
[11:01:30.346]             if (.Platform$OS.type == "windows") {
[11:01:30.346]                 old_names <- names(...future.oldEnvVars)
[11:01:30.346]                 envs <- base::Sys.getenv()
[11:01:30.346]                 names <- names(envs)
[11:01:30.346]                 common <- intersect(names, old_names)
[11:01:30.346]                 added <- setdiff(names, old_names)
[11:01:30.346]                 removed <- setdiff(old_names, names)
[11:01:30.346]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.346]                   envs[common]]
[11:01:30.346]                 NAMES <- toupper(changed)
[11:01:30.346]                 args <- list()
[11:01:30.346]                 for (kk in seq_along(NAMES)) {
[11:01:30.346]                   name <- changed[[kk]]
[11:01:30.346]                   NAME <- NAMES[[kk]]
[11:01:30.346]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.346]                     next
[11:01:30.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.346]                 }
[11:01:30.346]                 NAMES <- toupper(added)
[11:01:30.346]                 for (kk in seq_along(NAMES)) {
[11:01:30.346]                   name <- added[[kk]]
[11:01:30.346]                   NAME <- NAMES[[kk]]
[11:01:30.346]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.346]                     next
[11:01:30.346]                   args[[name]] <- ""
[11:01:30.346]                 }
[11:01:30.346]                 NAMES <- toupper(removed)
[11:01:30.346]                 for (kk in seq_along(NAMES)) {
[11:01:30.346]                   name <- removed[[kk]]
[11:01:30.346]                   NAME <- NAMES[[kk]]
[11:01:30.346]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.346]                     next
[11:01:30.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.346]                 }
[11:01:30.346]                 if (length(args) > 0) 
[11:01:30.346]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.346]             }
[11:01:30.346]             else {
[11:01:30.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.346]             }
[11:01:30.346]             {
[11:01:30.346]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.346]                   0L) {
[11:01:30.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.346]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.346]                   base::options(opts)
[11:01:30.346]                 }
[11:01:30.346]                 {
[11:01:30.346]                   {
[11:01:30.346]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.346]                     NULL
[11:01:30.346]                   }
[11:01:30.346]                   options(future.plan = NULL)
[11:01:30.346]                   if (is.na(NA_character_)) 
[11:01:30.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.346]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.346]                     .init = FALSE)
[11:01:30.346]                 }
[11:01:30.346]             }
[11:01:30.346]         }
[11:01:30.346]     })
[11:01:30.346]     if (TRUE) {
[11:01:30.346]         base::sink(type = "output", split = FALSE)
[11:01:30.346]         if (TRUE) {
[11:01:30.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.346]         }
[11:01:30.346]         else {
[11:01:30.346]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.346]         }
[11:01:30.346]         base::close(...future.stdout)
[11:01:30.346]         ...future.stdout <- NULL
[11:01:30.346]     }
[11:01:30.346]     ...future.result$conditions <- ...future.conditions
[11:01:30.346]     ...future.result$finished <- base::Sys.time()
[11:01:30.346]     ...future.result
[11:01:30.346] }
[11:01:30.349] MultisessionFuture started
[11:01:30.349] - Launch lazy future ... done
[11:01:30.349] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4d71f28> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c7bf4a20> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c4d71f28> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c7bf4a20> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 logi [1:2, 1:3] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:30.378] resolve() on list ...
[11:01:30.378]  recursive: 0
[11:01:30.378]  length: 6
[11:01:30.379]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:30.379] signalConditionsASAP(numeric, pos=1) ...
[11:01:30.379] - nx: 6
[11:01:30.379] - relay: TRUE
[11:01:30.379] - stdout: TRUE
[11:01:30.379] - signal: TRUE
[11:01:30.379] - resignal: FALSE
[11:01:30.379] - force: TRUE
[11:01:30.379] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.380] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.380]  - until=2
[11:01:30.380]  - relaying element #2
[11:01:30.380] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.380] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.380] signalConditionsASAP(NULL, pos=1) ... done
[11:01:30.380]  length: 5 (resolved future 1)
[11:01:30.381] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.381] - Validating connection of MultisessionFuture
[11:01:30.381] - received message: FutureResult
[11:01:30.382] - Received FutureResult
[11:01:30.382] - Erased future from FutureRegistry
[11:01:30.382] result() for ClusterFuture ...
[11:01:30.382] - result already collected: FutureResult
[11:01:30.382] result() for ClusterFuture ... done
[11:01:30.382] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.382] Future #2
[11:01:30.382] result() for ClusterFuture ...
[11:01:30.383] - result already collected: FutureResult
[11:01:30.383] result() for ClusterFuture ... done
[11:01:30.383] result() for ClusterFuture ...
[11:01:30.383] - result already collected: FutureResult
[11:01:30.383] result() for ClusterFuture ... done
[11:01:30.383] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:30.383] - nx: 6
[11:01:30.383] - relay: TRUE
[11:01:30.383] - stdout: TRUE
[11:01:30.383] - signal: TRUE
[11:01:30.383] - resignal: FALSE
[11:01:30.383] - force: TRUE
[11:01:30.383] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.384] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.384]  - until=2
[11:01:30.384]  - relaying element #2
[11:01:30.384] result() for ClusterFuture ...
[11:01:30.384] - result already collected: FutureResult
[11:01:30.384] result() for ClusterFuture ... done
[11:01:30.384] result() for ClusterFuture ...
[11:01:30.384] - result already collected: FutureResult
[11:01:30.384] result() for ClusterFuture ... done
[11:01:30.384] result() for ClusterFuture ...
[11:01:30.384] - result already collected: FutureResult
[11:01:30.384] result() for ClusterFuture ... done
[11:01:30.385] result() for ClusterFuture ...
[11:01:30.385] - result already collected: FutureResult
[11:01:30.385] result() for ClusterFuture ... done
[11:01:30.385] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.385] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.385] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:30.385]  length: 4 (resolved future 2)
[11:01:30.391] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.391] - Validating connection of MultisessionFuture
[11:01:30.391] - received message: FutureResult
[11:01:30.392] - Received FutureResult
[11:01:30.392] - Erased future from FutureRegistry
[11:01:30.392] result() for ClusterFuture ...
[11:01:30.392] - result already collected: FutureResult
[11:01:30.392] result() for ClusterFuture ... done
[11:01:30.392] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.392] Future #3
[11:01:30.392] result() for ClusterFuture ...
[11:01:30.392] - result already collected: FutureResult
[11:01:30.392] result() for ClusterFuture ... done
[11:01:30.392] result() for ClusterFuture ...
[11:01:30.393] - result already collected: FutureResult
[11:01:30.393] result() for ClusterFuture ... done
[11:01:30.393] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:30.393] - nx: 6
[11:01:30.393] - relay: TRUE
[11:01:30.393] - stdout: TRUE
[11:01:30.393] - signal: TRUE
[11:01:30.393] - resignal: FALSE
[11:01:30.393] - force: TRUE
[11:01:30.393] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.393] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.393]  - until=3
[11:01:30.394]  - relaying element #3
[11:01:30.394] result() for ClusterFuture ...
[11:01:30.394] - result already collected: FutureResult
[11:01:30.394] result() for ClusterFuture ... done
[11:01:30.394] result() for ClusterFuture ...
[11:01:30.394] - result already collected: FutureResult
[11:01:30.394] result() for ClusterFuture ... done
[11:01:30.394] result() for ClusterFuture ...
[11:01:30.394] - result already collected: FutureResult
[11:01:30.394] result() for ClusterFuture ... done
[11:01:30.394] result() for ClusterFuture ...
[11:01:30.394] - result already collected: FutureResult
[11:01:30.395] result() for ClusterFuture ... done
[11:01:30.395] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.395] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.395] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:30.395]  length: 3 (resolved future 3)
[11:01:30.395] signalConditionsASAP(NULL, pos=4) ...
[11:01:30.395] - nx: 6
[11:01:30.395] - relay: TRUE
[11:01:30.395] - stdout: TRUE
[11:01:30.395] - signal: TRUE
[11:01:30.395] - resignal: FALSE
[11:01:30.395] - force: TRUE
[11:01:30.396] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.396] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.396]  - until=5
[11:01:30.396]  - relaying element #5
[11:01:30.396] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.396] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.396] signalConditionsASAP(NULL, pos=4) ... done
[11:01:30.396]  length: 2 (resolved future 4)
[11:01:30.396] signalConditionsASAP(NULL, pos=5) ...
[11:01:30.396] - nx: 6
[11:01:30.396] - relay: TRUE
[11:01:30.396] - stdout: TRUE
[11:01:30.396] - signal: TRUE
[11:01:30.397] - resignal: FALSE
[11:01:30.397] - force: TRUE
[11:01:30.397] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.397] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.397]  - until=6
[11:01:30.397]  - relaying element #6
[11:01:30.397] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.397] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.397] signalConditionsASAP(NULL, pos=5) ... done
[11:01:30.397]  length: 1 (resolved future 5)
[11:01:30.397] signalConditionsASAP(numeric, pos=6) ...
[11:01:30.397] - nx: 6
[11:01:30.398] - relay: TRUE
[11:01:30.398] - stdout: TRUE
[11:01:30.398] - signal: TRUE
[11:01:30.398] - resignal: FALSE
[11:01:30.398] - force: TRUE
[11:01:30.398] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.398] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.398]  - until=6
[11:01:30.398] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.398] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.398] signalConditionsASAP(numeric, pos=6) ... done
[11:01:30.398]  length: 0 (resolved future 6)
[11:01:30.398] Relaying remaining futures
[11:01:30.399] signalConditionsASAP(NULL, pos=0) ...
[11:01:30.399] - nx: 6
[11:01:30.399] - relay: TRUE
[11:01:30.399] - stdout: TRUE
[11:01:30.399] - signal: TRUE
[11:01:30.399] - resignal: FALSE
[11:01:30.399] - force: TRUE
[11:01:30.399] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.399] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:30.399] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.399] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.399] signalConditionsASAP(NULL, pos=0) ... done
[11:01:30.399] resolve() on list ... DONE
[11:01:30.400] result() for ClusterFuture ...
[11:01:30.400] - result already collected: FutureResult
[11:01:30.400] result() for ClusterFuture ... done
[11:01:30.400] result() for ClusterFuture ...
[11:01:30.400] - result already collected: FutureResult
[11:01:30.400] result() for ClusterFuture ... done
[11:01:30.400] result() for ClusterFuture ...
[11:01:30.400] - result already collected: FutureResult
[11:01:30.400] result() for ClusterFuture ... done
[11:01:30.400] result() for ClusterFuture ...
[11:01:30.400] - result already collected: FutureResult
[11:01:30.400] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:2] 2 3
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[11:01:30.403] getGlobalsAndPackages() ...
[11:01:30.403] Searching for globals...
[11:01:30.404] 
[11:01:30.404] Searching for globals ... DONE
[11:01:30.404] - globals: [0] <none>
[11:01:30.404] getGlobalsAndPackages() ... DONE
[11:01:30.404] run() for ‘Future’ ...
[11:01:30.404] - state: ‘created’
[11:01:30.404] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.418] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.418] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.418]   - Field: ‘node’
[11:01:30.418]   - Field: ‘label’
[11:01:30.419]   - Field: ‘local’
[11:01:30.419]   - Field: ‘owner’
[11:01:30.419]   - Field: ‘envir’
[11:01:30.419]   - Field: ‘workers’
[11:01:30.419]   - Field: ‘packages’
[11:01:30.419]   - Field: ‘gc’
[11:01:30.419]   - Field: ‘conditions’
[11:01:30.419]   - Field: ‘persistent’
[11:01:30.419]   - Field: ‘expr’
[11:01:30.419]   - Field: ‘uuid’
[11:01:30.419]   - Field: ‘seed’
[11:01:30.419]   - Field: ‘version’
[11:01:30.420]   - Field: ‘result’
[11:01:30.420]   - Field: ‘asynchronous’
[11:01:30.420]   - Field: ‘calls’
[11:01:30.420]   - Field: ‘globals’
[11:01:30.420]   - Field: ‘stdout’
[11:01:30.420]   - Field: ‘earlySignal’
[11:01:30.422]   - Field: ‘lazy’
[11:01:30.422]   - Field: ‘state’
[11:01:30.422] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.422] - Launch lazy future ...
[11:01:30.422] Packages needed by the future expression (n = 0): <none>
[11:01:30.422] Packages needed by future strategies (n = 0): <none>
[11:01:30.423] {
[11:01:30.423]     {
[11:01:30.423]         {
[11:01:30.423]             ...future.startTime <- base::Sys.time()
[11:01:30.423]             {
[11:01:30.423]                 {
[11:01:30.423]                   {
[11:01:30.423]                     {
[11:01:30.423]                       base::local({
[11:01:30.423]                         has_future <- base::requireNamespace("future", 
[11:01:30.423]                           quietly = TRUE)
[11:01:30.423]                         if (has_future) {
[11:01:30.423]                           ns <- base::getNamespace("future")
[11:01:30.423]                           version <- ns[[".package"]][["version"]]
[11:01:30.423]                           if (is.null(version)) 
[11:01:30.423]                             version <- utils::packageVersion("future")
[11:01:30.423]                         }
[11:01:30.423]                         else {
[11:01:30.423]                           version <- NULL
[11:01:30.423]                         }
[11:01:30.423]                         if (!has_future || version < "1.8.0") {
[11:01:30.423]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.423]                             "", base::R.version$version.string), 
[11:01:30.423]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.423]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.423]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.423]                               "release", "version")], collapse = " "), 
[11:01:30.423]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.423]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.423]                             info)
[11:01:30.423]                           info <- base::paste(info, collapse = "; ")
[11:01:30.423]                           if (!has_future) {
[11:01:30.423]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.423]                               info)
[11:01:30.423]                           }
[11:01:30.423]                           else {
[11:01:30.423]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.423]                               info, version)
[11:01:30.423]                           }
[11:01:30.423]                           base::stop(msg)
[11:01:30.423]                         }
[11:01:30.423]                       })
[11:01:30.423]                     }
[11:01:30.423]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.423]                     base::options(mc.cores = 1L)
[11:01:30.423]                   }
[11:01:30.423]                   ...future.strategy.old <- future::plan("list")
[11:01:30.423]                   options(future.plan = NULL)
[11:01:30.423]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.423]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.423]                 }
[11:01:30.423]                 ...future.workdir <- getwd()
[11:01:30.423]             }
[11:01:30.423]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.423]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.423]         }
[11:01:30.423]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.423]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.423]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.423]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.423]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.423]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.423]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.423]             base::names(...future.oldOptions))
[11:01:30.423]     }
[11:01:30.423]     if (FALSE) {
[11:01:30.423]     }
[11:01:30.423]     else {
[11:01:30.423]         if (TRUE) {
[11:01:30.423]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.423]                 open = "w")
[11:01:30.423]         }
[11:01:30.423]         else {
[11:01:30.423]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.423]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.423]         }
[11:01:30.423]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.423]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.423]             base::sink(type = "output", split = FALSE)
[11:01:30.423]             base::close(...future.stdout)
[11:01:30.423]         }, add = TRUE)
[11:01:30.423]     }
[11:01:30.423]     ...future.frame <- base::sys.nframe()
[11:01:30.423]     ...future.conditions <- base::list()
[11:01:30.423]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.423]     if (FALSE) {
[11:01:30.423]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.423]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.423]     }
[11:01:30.423]     ...future.result <- base::tryCatch({
[11:01:30.423]         base::withCallingHandlers({
[11:01:30.423]             ...future.value <- base::withVisible(base::local({
[11:01:30.423]                 ...future.makeSendCondition <- base::local({
[11:01:30.423]                   sendCondition <- NULL
[11:01:30.423]                   function(frame = 1L) {
[11:01:30.423]                     if (is.function(sendCondition)) 
[11:01:30.423]                       return(sendCondition)
[11:01:30.423]                     ns <- getNamespace("parallel")
[11:01:30.423]                     if (exists("sendData", mode = "function", 
[11:01:30.423]                       envir = ns)) {
[11:01:30.423]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.423]                         envir = ns)
[11:01:30.423]                       envir <- sys.frame(frame)
[11:01:30.423]                       master <- NULL
[11:01:30.423]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.423]                         !identical(envir, emptyenv())) {
[11:01:30.423]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.423]                           inherits = FALSE)) {
[11:01:30.423]                           master <- get("master", mode = "list", 
[11:01:30.423]                             envir = envir, inherits = FALSE)
[11:01:30.423]                           if (inherits(master, c("SOCKnode", 
[11:01:30.423]                             "SOCK0node"))) {
[11:01:30.423]                             sendCondition <<- function(cond) {
[11:01:30.423]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.423]                                 success = TRUE)
[11:01:30.423]                               parallel_sendData(master, data)
[11:01:30.423]                             }
[11:01:30.423]                             return(sendCondition)
[11:01:30.423]                           }
[11:01:30.423]                         }
[11:01:30.423]                         frame <- frame + 1L
[11:01:30.423]                         envir <- sys.frame(frame)
[11:01:30.423]                       }
[11:01:30.423]                     }
[11:01:30.423]                     sendCondition <<- function(cond) NULL
[11:01:30.423]                   }
[11:01:30.423]                 })
[11:01:30.423]                 withCallingHandlers({
[11:01:30.423]                   2
[11:01:30.423]                 }, immediateCondition = function(cond) {
[11:01:30.423]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.423]                   sendCondition(cond)
[11:01:30.423]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.423]                   {
[11:01:30.423]                     inherits <- base::inherits
[11:01:30.423]                     invokeRestart <- base::invokeRestart
[11:01:30.423]                     is.null <- base::is.null
[11:01:30.423]                     muffled <- FALSE
[11:01:30.423]                     if (inherits(cond, "message")) {
[11:01:30.423]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.423]                       if (muffled) 
[11:01:30.423]                         invokeRestart("muffleMessage")
[11:01:30.423]                     }
[11:01:30.423]                     else if (inherits(cond, "warning")) {
[11:01:30.423]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.423]                       if (muffled) 
[11:01:30.423]                         invokeRestart("muffleWarning")
[11:01:30.423]                     }
[11:01:30.423]                     else if (inherits(cond, "condition")) {
[11:01:30.423]                       if (!is.null(pattern)) {
[11:01:30.423]                         computeRestarts <- base::computeRestarts
[11:01:30.423]                         grepl <- base::grepl
[11:01:30.423]                         restarts <- computeRestarts(cond)
[11:01:30.423]                         for (restart in restarts) {
[11:01:30.423]                           name <- restart$name
[11:01:30.423]                           if (is.null(name)) 
[11:01:30.423]                             next
[11:01:30.423]                           if (!grepl(pattern, name)) 
[11:01:30.423]                             next
[11:01:30.423]                           invokeRestart(restart)
[11:01:30.423]                           muffled <- TRUE
[11:01:30.423]                           break
[11:01:30.423]                         }
[11:01:30.423]                       }
[11:01:30.423]                     }
[11:01:30.423]                     invisible(muffled)
[11:01:30.423]                   }
[11:01:30.423]                   muffleCondition(cond)
[11:01:30.423]                 })
[11:01:30.423]             }))
[11:01:30.423]             future::FutureResult(value = ...future.value$value, 
[11:01:30.423]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.423]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.423]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.423]                     ...future.globalenv.names))
[11:01:30.423]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.423]         }, condition = base::local({
[11:01:30.423]             c <- base::c
[11:01:30.423]             inherits <- base::inherits
[11:01:30.423]             invokeRestart <- base::invokeRestart
[11:01:30.423]             length <- base::length
[11:01:30.423]             list <- base::list
[11:01:30.423]             seq.int <- base::seq.int
[11:01:30.423]             signalCondition <- base::signalCondition
[11:01:30.423]             sys.calls <- base::sys.calls
[11:01:30.423]             `[[` <- base::`[[`
[11:01:30.423]             `+` <- base::`+`
[11:01:30.423]             `<<-` <- base::`<<-`
[11:01:30.423]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.423]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.423]                   3L)]
[11:01:30.423]             }
[11:01:30.423]             function(cond) {
[11:01:30.423]                 is_error <- inherits(cond, "error")
[11:01:30.423]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.423]                   NULL)
[11:01:30.423]                 if (is_error) {
[11:01:30.423]                   sessionInformation <- function() {
[11:01:30.423]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.423]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.423]                       search = base::search(), system = base::Sys.info())
[11:01:30.423]                   }
[11:01:30.423]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.423]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.423]                     cond$call), session = sessionInformation(), 
[11:01:30.423]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.423]                   signalCondition(cond)
[11:01:30.423]                 }
[11:01:30.423]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.423]                 "immediateCondition"))) {
[11:01:30.423]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.423]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.423]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.423]                   if (TRUE && !signal) {
[11:01:30.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.423]                     {
[11:01:30.423]                       inherits <- base::inherits
[11:01:30.423]                       invokeRestart <- base::invokeRestart
[11:01:30.423]                       is.null <- base::is.null
[11:01:30.423]                       muffled <- FALSE
[11:01:30.423]                       if (inherits(cond, "message")) {
[11:01:30.423]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.423]                         if (muffled) 
[11:01:30.423]                           invokeRestart("muffleMessage")
[11:01:30.423]                       }
[11:01:30.423]                       else if (inherits(cond, "warning")) {
[11:01:30.423]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.423]                         if (muffled) 
[11:01:30.423]                           invokeRestart("muffleWarning")
[11:01:30.423]                       }
[11:01:30.423]                       else if (inherits(cond, "condition")) {
[11:01:30.423]                         if (!is.null(pattern)) {
[11:01:30.423]                           computeRestarts <- base::computeRestarts
[11:01:30.423]                           grepl <- base::grepl
[11:01:30.423]                           restarts <- computeRestarts(cond)
[11:01:30.423]                           for (restart in restarts) {
[11:01:30.423]                             name <- restart$name
[11:01:30.423]                             if (is.null(name)) 
[11:01:30.423]                               next
[11:01:30.423]                             if (!grepl(pattern, name)) 
[11:01:30.423]                               next
[11:01:30.423]                             invokeRestart(restart)
[11:01:30.423]                             muffled <- TRUE
[11:01:30.423]                             break
[11:01:30.423]                           }
[11:01:30.423]                         }
[11:01:30.423]                       }
[11:01:30.423]                       invisible(muffled)
[11:01:30.423]                     }
[11:01:30.423]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.423]                   }
[11:01:30.423]                 }
[11:01:30.423]                 else {
[11:01:30.423]                   if (TRUE) {
[11:01:30.423]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.423]                     {
[11:01:30.423]                       inherits <- base::inherits
[11:01:30.423]                       invokeRestart <- base::invokeRestart
[11:01:30.423]                       is.null <- base::is.null
[11:01:30.423]                       muffled <- FALSE
[11:01:30.423]                       if (inherits(cond, "message")) {
[11:01:30.423]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.423]                         if (muffled) 
[11:01:30.423]                           invokeRestart("muffleMessage")
[11:01:30.423]                       }
[11:01:30.423]                       else if (inherits(cond, "warning")) {
[11:01:30.423]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.423]                         if (muffled) 
[11:01:30.423]                           invokeRestart("muffleWarning")
[11:01:30.423]                       }
[11:01:30.423]                       else if (inherits(cond, "condition")) {
[11:01:30.423]                         if (!is.null(pattern)) {
[11:01:30.423]                           computeRestarts <- base::computeRestarts
[11:01:30.423]                           grepl <- base::grepl
[11:01:30.423]                           restarts <- computeRestarts(cond)
[11:01:30.423]                           for (restart in restarts) {
[11:01:30.423]                             name <- restart$name
[11:01:30.423]                             if (is.null(name)) 
[11:01:30.423]                               next
[11:01:30.423]                             if (!grepl(pattern, name)) 
[11:01:30.423]                               next
[11:01:30.423]                             invokeRestart(restart)
[11:01:30.423]                             muffled <- TRUE
[11:01:30.423]                             break
[11:01:30.423]                           }
[11:01:30.423]                         }
[11:01:30.423]                       }
[11:01:30.423]                       invisible(muffled)
[11:01:30.423]                     }
[11:01:30.423]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.423]                   }
[11:01:30.423]                 }
[11:01:30.423]             }
[11:01:30.423]         }))
[11:01:30.423]     }, error = function(ex) {
[11:01:30.423]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.423]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.423]                 ...future.rng), started = ...future.startTime, 
[11:01:30.423]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.423]             version = "1.8"), class = "FutureResult")
[11:01:30.423]     }, finally = {
[11:01:30.423]         if (!identical(...future.workdir, getwd())) 
[11:01:30.423]             setwd(...future.workdir)
[11:01:30.423]         {
[11:01:30.423]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.423]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.423]             }
[11:01:30.423]             base::options(...future.oldOptions)
[11:01:30.423]             if (.Platform$OS.type == "windows") {
[11:01:30.423]                 old_names <- names(...future.oldEnvVars)
[11:01:30.423]                 envs <- base::Sys.getenv()
[11:01:30.423]                 names <- names(envs)
[11:01:30.423]                 common <- intersect(names, old_names)
[11:01:30.423]                 added <- setdiff(names, old_names)
[11:01:30.423]                 removed <- setdiff(old_names, names)
[11:01:30.423]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.423]                   envs[common]]
[11:01:30.423]                 NAMES <- toupper(changed)
[11:01:30.423]                 args <- list()
[11:01:30.423]                 for (kk in seq_along(NAMES)) {
[11:01:30.423]                   name <- changed[[kk]]
[11:01:30.423]                   NAME <- NAMES[[kk]]
[11:01:30.423]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.423]                     next
[11:01:30.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.423]                 }
[11:01:30.423]                 NAMES <- toupper(added)
[11:01:30.423]                 for (kk in seq_along(NAMES)) {
[11:01:30.423]                   name <- added[[kk]]
[11:01:30.423]                   NAME <- NAMES[[kk]]
[11:01:30.423]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.423]                     next
[11:01:30.423]                   args[[name]] <- ""
[11:01:30.423]                 }
[11:01:30.423]                 NAMES <- toupper(removed)
[11:01:30.423]                 for (kk in seq_along(NAMES)) {
[11:01:30.423]                   name <- removed[[kk]]
[11:01:30.423]                   NAME <- NAMES[[kk]]
[11:01:30.423]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.423]                     next
[11:01:30.423]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.423]                 }
[11:01:30.423]                 if (length(args) > 0) 
[11:01:30.423]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.423]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.423]             }
[11:01:30.423]             else {
[11:01:30.423]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.423]             }
[11:01:30.423]             {
[11:01:30.423]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.423]                   0L) {
[11:01:30.423]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.423]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.423]                   base::options(opts)
[11:01:30.423]                 }
[11:01:30.423]                 {
[11:01:30.423]                   {
[11:01:30.423]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.423]                     NULL
[11:01:30.423]                   }
[11:01:30.423]                   options(future.plan = NULL)
[11:01:30.423]                   if (is.na(NA_character_)) 
[11:01:30.423]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.423]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.423]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.423]                     .init = FALSE)
[11:01:30.423]                 }
[11:01:30.423]             }
[11:01:30.423]         }
[11:01:30.423]     })
[11:01:30.423]     if (TRUE) {
[11:01:30.423]         base::sink(type = "output", split = FALSE)
[11:01:30.423]         if (TRUE) {
[11:01:30.423]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.423]         }
[11:01:30.423]         else {
[11:01:30.423]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.423]         }
[11:01:30.423]         base::close(...future.stdout)
[11:01:30.423]         ...future.stdout <- NULL
[11:01:30.423]     }
[11:01:30.423]     ...future.result$conditions <- ...future.conditions
[11:01:30.423]     ...future.result$finished <- base::Sys.time()
[11:01:30.423]     ...future.result
[11:01:30.423] }
[11:01:30.425] MultisessionFuture started
[11:01:30.426] - Launch lazy future ... done
[11:01:30.426] run() for ‘MultisessionFuture’ ... done
[11:01:30.426] getGlobalsAndPackages() ...
[11:01:30.426] Searching for globals...
[11:01:30.426] 
[11:01:30.426] Searching for globals ... DONE
[11:01:30.426] - globals: [0] <none>
[11:01:30.426] getGlobalsAndPackages() ... DONE
[11:01:30.427] run() for ‘Future’ ...
[11:01:30.427] - state: ‘created’
[11:01:30.427] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.441] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.441] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.441]   - Field: ‘node’
[11:01:30.441]   - Field: ‘label’
[11:01:30.441]   - Field: ‘local’
[11:01:30.441]   - Field: ‘owner’
[11:01:30.441]   - Field: ‘envir’
[11:01:30.441]   - Field: ‘workers’
[11:01:30.441]   - Field: ‘packages’
[11:01:30.441]   - Field: ‘gc’
[11:01:30.442]   - Field: ‘conditions’
[11:01:30.442]   - Field: ‘persistent’
[11:01:30.442]   - Field: ‘expr’
[11:01:30.442]   - Field: ‘uuid’
[11:01:30.442]   - Field: ‘seed’
[11:01:30.442]   - Field: ‘version’
[11:01:30.442]   - Field: ‘result’
[11:01:30.442]   - Field: ‘asynchronous’
[11:01:30.442]   - Field: ‘calls’
[11:01:30.442]   - Field: ‘globals’
[11:01:30.442]   - Field: ‘stdout’
[11:01:30.442]   - Field: ‘earlySignal’
[11:01:30.443]   - Field: ‘lazy’
[11:01:30.443]   - Field: ‘state’
[11:01:30.443] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.443] - Launch lazy future ...
[11:01:30.443] Packages needed by the future expression (n = 0): <none>
[11:01:30.443] Packages needed by future strategies (n = 0): <none>
[11:01:30.444] {
[11:01:30.444]     {
[11:01:30.444]         {
[11:01:30.444]             ...future.startTime <- base::Sys.time()
[11:01:30.444]             {
[11:01:30.444]                 {
[11:01:30.444]                   {
[11:01:30.444]                     {
[11:01:30.444]                       base::local({
[11:01:30.444]                         has_future <- base::requireNamespace("future", 
[11:01:30.444]                           quietly = TRUE)
[11:01:30.444]                         if (has_future) {
[11:01:30.444]                           ns <- base::getNamespace("future")
[11:01:30.444]                           version <- ns[[".package"]][["version"]]
[11:01:30.444]                           if (is.null(version)) 
[11:01:30.444]                             version <- utils::packageVersion("future")
[11:01:30.444]                         }
[11:01:30.444]                         else {
[11:01:30.444]                           version <- NULL
[11:01:30.444]                         }
[11:01:30.444]                         if (!has_future || version < "1.8.0") {
[11:01:30.444]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.444]                             "", base::R.version$version.string), 
[11:01:30.444]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.444]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.444]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.444]                               "release", "version")], collapse = " "), 
[11:01:30.444]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.444]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.444]                             info)
[11:01:30.444]                           info <- base::paste(info, collapse = "; ")
[11:01:30.444]                           if (!has_future) {
[11:01:30.444]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.444]                               info)
[11:01:30.444]                           }
[11:01:30.444]                           else {
[11:01:30.444]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.444]                               info, version)
[11:01:30.444]                           }
[11:01:30.444]                           base::stop(msg)
[11:01:30.444]                         }
[11:01:30.444]                       })
[11:01:30.444]                     }
[11:01:30.444]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.444]                     base::options(mc.cores = 1L)
[11:01:30.444]                   }
[11:01:30.444]                   ...future.strategy.old <- future::plan("list")
[11:01:30.444]                   options(future.plan = NULL)
[11:01:30.444]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.444]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.444]                 }
[11:01:30.444]                 ...future.workdir <- getwd()
[11:01:30.444]             }
[11:01:30.444]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.444]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.444]         }
[11:01:30.444]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.444]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.444]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.444]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.444]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.444]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.444]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.444]             base::names(...future.oldOptions))
[11:01:30.444]     }
[11:01:30.444]     if (FALSE) {
[11:01:30.444]     }
[11:01:30.444]     else {
[11:01:30.444]         if (TRUE) {
[11:01:30.444]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.444]                 open = "w")
[11:01:30.444]         }
[11:01:30.444]         else {
[11:01:30.444]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.444]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.444]         }
[11:01:30.444]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.444]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.444]             base::sink(type = "output", split = FALSE)
[11:01:30.444]             base::close(...future.stdout)
[11:01:30.444]         }, add = TRUE)
[11:01:30.444]     }
[11:01:30.444]     ...future.frame <- base::sys.nframe()
[11:01:30.444]     ...future.conditions <- base::list()
[11:01:30.444]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.444]     if (FALSE) {
[11:01:30.444]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.444]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.444]     }
[11:01:30.444]     ...future.result <- base::tryCatch({
[11:01:30.444]         base::withCallingHandlers({
[11:01:30.444]             ...future.value <- base::withVisible(base::local({
[11:01:30.444]                 ...future.makeSendCondition <- base::local({
[11:01:30.444]                   sendCondition <- NULL
[11:01:30.444]                   function(frame = 1L) {
[11:01:30.444]                     if (is.function(sendCondition)) 
[11:01:30.444]                       return(sendCondition)
[11:01:30.444]                     ns <- getNamespace("parallel")
[11:01:30.444]                     if (exists("sendData", mode = "function", 
[11:01:30.444]                       envir = ns)) {
[11:01:30.444]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.444]                         envir = ns)
[11:01:30.444]                       envir <- sys.frame(frame)
[11:01:30.444]                       master <- NULL
[11:01:30.444]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.444]                         !identical(envir, emptyenv())) {
[11:01:30.444]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.444]                           inherits = FALSE)) {
[11:01:30.444]                           master <- get("master", mode = "list", 
[11:01:30.444]                             envir = envir, inherits = FALSE)
[11:01:30.444]                           if (inherits(master, c("SOCKnode", 
[11:01:30.444]                             "SOCK0node"))) {
[11:01:30.444]                             sendCondition <<- function(cond) {
[11:01:30.444]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.444]                                 success = TRUE)
[11:01:30.444]                               parallel_sendData(master, data)
[11:01:30.444]                             }
[11:01:30.444]                             return(sendCondition)
[11:01:30.444]                           }
[11:01:30.444]                         }
[11:01:30.444]                         frame <- frame + 1L
[11:01:30.444]                         envir <- sys.frame(frame)
[11:01:30.444]                       }
[11:01:30.444]                     }
[11:01:30.444]                     sendCondition <<- function(cond) NULL
[11:01:30.444]                   }
[11:01:30.444]                 })
[11:01:30.444]                 withCallingHandlers({
[11:01:30.444]                   NULL
[11:01:30.444]                 }, immediateCondition = function(cond) {
[11:01:30.444]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.444]                   sendCondition(cond)
[11:01:30.444]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.444]                   {
[11:01:30.444]                     inherits <- base::inherits
[11:01:30.444]                     invokeRestart <- base::invokeRestart
[11:01:30.444]                     is.null <- base::is.null
[11:01:30.444]                     muffled <- FALSE
[11:01:30.444]                     if (inherits(cond, "message")) {
[11:01:30.444]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.444]                       if (muffled) 
[11:01:30.444]                         invokeRestart("muffleMessage")
[11:01:30.444]                     }
[11:01:30.444]                     else if (inherits(cond, "warning")) {
[11:01:30.444]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.444]                       if (muffled) 
[11:01:30.444]                         invokeRestart("muffleWarning")
[11:01:30.444]                     }
[11:01:30.444]                     else if (inherits(cond, "condition")) {
[11:01:30.444]                       if (!is.null(pattern)) {
[11:01:30.444]                         computeRestarts <- base::computeRestarts
[11:01:30.444]                         grepl <- base::grepl
[11:01:30.444]                         restarts <- computeRestarts(cond)
[11:01:30.444]                         for (restart in restarts) {
[11:01:30.444]                           name <- restart$name
[11:01:30.444]                           if (is.null(name)) 
[11:01:30.444]                             next
[11:01:30.444]                           if (!grepl(pattern, name)) 
[11:01:30.444]                             next
[11:01:30.444]                           invokeRestart(restart)
[11:01:30.444]                           muffled <- TRUE
[11:01:30.444]                           break
[11:01:30.444]                         }
[11:01:30.444]                       }
[11:01:30.444]                     }
[11:01:30.444]                     invisible(muffled)
[11:01:30.444]                   }
[11:01:30.444]                   muffleCondition(cond)
[11:01:30.444]                 })
[11:01:30.444]             }))
[11:01:30.444]             future::FutureResult(value = ...future.value$value, 
[11:01:30.444]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.444]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.444]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.444]                     ...future.globalenv.names))
[11:01:30.444]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.444]         }, condition = base::local({
[11:01:30.444]             c <- base::c
[11:01:30.444]             inherits <- base::inherits
[11:01:30.444]             invokeRestart <- base::invokeRestart
[11:01:30.444]             length <- base::length
[11:01:30.444]             list <- base::list
[11:01:30.444]             seq.int <- base::seq.int
[11:01:30.444]             signalCondition <- base::signalCondition
[11:01:30.444]             sys.calls <- base::sys.calls
[11:01:30.444]             `[[` <- base::`[[`
[11:01:30.444]             `+` <- base::`+`
[11:01:30.444]             `<<-` <- base::`<<-`
[11:01:30.444]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.444]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.444]                   3L)]
[11:01:30.444]             }
[11:01:30.444]             function(cond) {
[11:01:30.444]                 is_error <- inherits(cond, "error")
[11:01:30.444]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.444]                   NULL)
[11:01:30.444]                 if (is_error) {
[11:01:30.444]                   sessionInformation <- function() {
[11:01:30.444]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.444]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.444]                       search = base::search(), system = base::Sys.info())
[11:01:30.444]                   }
[11:01:30.444]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.444]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.444]                     cond$call), session = sessionInformation(), 
[11:01:30.444]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.444]                   signalCondition(cond)
[11:01:30.444]                 }
[11:01:30.444]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.444]                 "immediateCondition"))) {
[11:01:30.444]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.444]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.444]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.444]                   if (TRUE && !signal) {
[11:01:30.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.444]                     {
[11:01:30.444]                       inherits <- base::inherits
[11:01:30.444]                       invokeRestart <- base::invokeRestart
[11:01:30.444]                       is.null <- base::is.null
[11:01:30.444]                       muffled <- FALSE
[11:01:30.444]                       if (inherits(cond, "message")) {
[11:01:30.444]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.444]                         if (muffled) 
[11:01:30.444]                           invokeRestart("muffleMessage")
[11:01:30.444]                       }
[11:01:30.444]                       else if (inherits(cond, "warning")) {
[11:01:30.444]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.444]                         if (muffled) 
[11:01:30.444]                           invokeRestart("muffleWarning")
[11:01:30.444]                       }
[11:01:30.444]                       else if (inherits(cond, "condition")) {
[11:01:30.444]                         if (!is.null(pattern)) {
[11:01:30.444]                           computeRestarts <- base::computeRestarts
[11:01:30.444]                           grepl <- base::grepl
[11:01:30.444]                           restarts <- computeRestarts(cond)
[11:01:30.444]                           for (restart in restarts) {
[11:01:30.444]                             name <- restart$name
[11:01:30.444]                             if (is.null(name)) 
[11:01:30.444]                               next
[11:01:30.444]                             if (!grepl(pattern, name)) 
[11:01:30.444]                               next
[11:01:30.444]                             invokeRestart(restart)
[11:01:30.444]                             muffled <- TRUE
[11:01:30.444]                             break
[11:01:30.444]                           }
[11:01:30.444]                         }
[11:01:30.444]                       }
[11:01:30.444]                       invisible(muffled)
[11:01:30.444]                     }
[11:01:30.444]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.444]                   }
[11:01:30.444]                 }
[11:01:30.444]                 else {
[11:01:30.444]                   if (TRUE) {
[11:01:30.444]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.444]                     {
[11:01:30.444]                       inherits <- base::inherits
[11:01:30.444]                       invokeRestart <- base::invokeRestart
[11:01:30.444]                       is.null <- base::is.null
[11:01:30.444]                       muffled <- FALSE
[11:01:30.444]                       if (inherits(cond, "message")) {
[11:01:30.444]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.444]                         if (muffled) 
[11:01:30.444]                           invokeRestart("muffleMessage")
[11:01:30.444]                       }
[11:01:30.444]                       else if (inherits(cond, "warning")) {
[11:01:30.444]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.444]                         if (muffled) 
[11:01:30.444]                           invokeRestart("muffleWarning")
[11:01:30.444]                       }
[11:01:30.444]                       else if (inherits(cond, "condition")) {
[11:01:30.444]                         if (!is.null(pattern)) {
[11:01:30.444]                           computeRestarts <- base::computeRestarts
[11:01:30.444]                           grepl <- base::grepl
[11:01:30.444]                           restarts <- computeRestarts(cond)
[11:01:30.444]                           for (restart in restarts) {
[11:01:30.444]                             name <- restart$name
[11:01:30.444]                             if (is.null(name)) 
[11:01:30.444]                               next
[11:01:30.444]                             if (!grepl(pattern, name)) 
[11:01:30.444]                               next
[11:01:30.444]                             invokeRestart(restart)
[11:01:30.444]                             muffled <- TRUE
[11:01:30.444]                             break
[11:01:30.444]                           }
[11:01:30.444]                         }
[11:01:30.444]                       }
[11:01:30.444]                       invisible(muffled)
[11:01:30.444]                     }
[11:01:30.444]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.444]                   }
[11:01:30.444]                 }
[11:01:30.444]             }
[11:01:30.444]         }))
[11:01:30.444]     }, error = function(ex) {
[11:01:30.444]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.444]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.444]                 ...future.rng), started = ...future.startTime, 
[11:01:30.444]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.444]             version = "1.8"), class = "FutureResult")
[11:01:30.444]     }, finally = {
[11:01:30.444]         if (!identical(...future.workdir, getwd())) 
[11:01:30.444]             setwd(...future.workdir)
[11:01:30.444]         {
[11:01:30.444]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.444]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.444]             }
[11:01:30.444]             base::options(...future.oldOptions)
[11:01:30.444]             if (.Platform$OS.type == "windows") {
[11:01:30.444]                 old_names <- names(...future.oldEnvVars)
[11:01:30.444]                 envs <- base::Sys.getenv()
[11:01:30.444]                 names <- names(envs)
[11:01:30.444]                 common <- intersect(names, old_names)
[11:01:30.444]                 added <- setdiff(names, old_names)
[11:01:30.444]                 removed <- setdiff(old_names, names)
[11:01:30.444]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.444]                   envs[common]]
[11:01:30.444]                 NAMES <- toupper(changed)
[11:01:30.444]                 args <- list()
[11:01:30.444]                 for (kk in seq_along(NAMES)) {
[11:01:30.444]                   name <- changed[[kk]]
[11:01:30.444]                   NAME <- NAMES[[kk]]
[11:01:30.444]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.444]                     next
[11:01:30.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.444]                 }
[11:01:30.444]                 NAMES <- toupper(added)
[11:01:30.444]                 for (kk in seq_along(NAMES)) {
[11:01:30.444]                   name <- added[[kk]]
[11:01:30.444]                   NAME <- NAMES[[kk]]
[11:01:30.444]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.444]                     next
[11:01:30.444]                   args[[name]] <- ""
[11:01:30.444]                 }
[11:01:30.444]                 NAMES <- toupper(removed)
[11:01:30.444]                 for (kk in seq_along(NAMES)) {
[11:01:30.444]                   name <- removed[[kk]]
[11:01:30.444]                   NAME <- NAMES[[kk]]
[11:01:30.444]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.444]                     next
[11:01:30.444]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.444]                 }
[11:01:30.444]                 if (length(args) > 0) 
[11:01:30.444]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.444]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.444]             }
[11:01:30.444]             else {
[11:01:30.444]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.444]             }
[11:01:30.444]             {
[11:01:30.444]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.444]                   0L) {
[11:01:30.444]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.444]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.444]                   base::options(opts)
[11:01:30.444]                 }
[11:01:30.444]                 {
[11:01:30.444]                   {
[11:01:30.444]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.444]                     NULL
[11:01:30.444]                   }
[11:01:30.444]                   options(future.plan = NULL)
[11:01:30.444]                   if (is.na(NA_character_)) 
[11:01:30.444]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.444]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.444]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.444]                     .init = FALSE)
[11:01:30.444]                 }
[11:01:30.444]             }
[11:01:30.444]         }
[11:01:30.444]     })
[11:01:30.444]     if (TRUE) {
[11:01:30.444]         base::sink(type = "output", split = FALSE)
[11:01:30.444]         if (TRUE) {
[11:01:30.444]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.444]         }
[11:01:30.444]         else {
[11:01:30.444]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.444]         }
[11:01:30.444]         base::close(...future.stdout)
[11:01:30.444]         ...future.stdout <- NULL
[11:01:30.444]     }
[11:01:30.444]     ...future.result$conditions <- ...future.conditions
[11:01:30.444]     ...future.result$finished <- base::Sys.time()
[11:01:30.444]     ...future.result
[11:01:30.444] }
[11:01:30.446] MultisessionFuture started
[11:01:30.446] - Launch lazy future ... done
[11:01:30.447] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c8d9c4f0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c7057590> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c8d9c4f0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c7057590> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:30.474] resolve() on list ...
[11:01:30.474]  recursive: 0
[11:01:30.474]  length: 6
[11:01:30.474]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:30.474] signalConditionsASAP(numeric, pos=1) ...
[11:01:30.474] - nx: 6
[11:01:30.474] - relay: TRUE
[11:01:30.474] - stdout: TRUE
[11:01:30.474] - signal: TRUE
[11:01:30.475] - resignal: FALSE
[11:01:30.475] - force: TRUE
[11:01:30.475] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.475] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.475]  - until=2
[11:01:30.475]  - relaying element #2
[11:01:30.475] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.475] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.475] signalConditionsASAP(NULL, pos=1) ... done
[11:01:30.475]  length: 5 (resolved future 1)
[11:01:30.476] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.476] - Validating connection of MultisessionFuture
[11:01:30.476] - received message: FutureResult
[11:01:30.476] - Received FutureResult
[11:01:30.476] - Erased future from FutureRegistry
[11:01:30.476] result() for ClusterFuture ...
[11:01:30.476] - result already collected: FutureResult
[11:01:30.476] result() for ClusterFuture ... done
[11:01:30.476] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.477] Future #2
[11:01:30.477] result() for ClusterFuture ...
[11:01:30.477] - result already collected: FutureResult
[11:01:30.477] result() for ClusterFuture ... done
[11:01:30.477] result() for ClusterFuture ...
[11:01:30.477] - result already collected: FutureResult
[11:01:30.477] result() for ClusterFuture ... done
[11:01:30.477] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:30.477] - nx: 6
[11:01:30.477] - relay: TRUE
[11:01:30.477] - stdout: TRUE
[11:01:30.477] - signal: TRUE
[11:01:30.478] - resignal: FALSE
[11:01:30.478] - force: TRUE
[11:01:30.478] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.478] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.478]  - until=2
[11:01:30.478]  - relaying element #2
[11:01:30.478] result() for ClusterFuture ...
[11:01:30.478] - result already collected: FutureResult
[11:01:30.478] result() for ClusterFuture ... done
[11:01:30.478] result() for ClusterFuture ...
[11:01:30.478] - result already collected: FutureResult
[11:01:30.478] result() for ClusterFuture ... done
[11:01:30.479] result() for ClusterFuture ...
[11:01:30.479] - result already collected: FutureResult
[11:01:30.479] result() for ClusterFuture ... done
[11:01:30.479] result() for ClusterFuture ...
[11:01:30.479] - result already collected: FutureResult
[11:01:30.479] result() for ClusterFuture ... done
[11:01:30.479] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.479] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.479] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:30.479]  length: 4 (resolved future 2)
[11:01:30.488] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.488] - Validating connection of MultisessionFuture
[11:01:30.488] - received message: FutureResult
[11:01:30.489] - Received FutureResult
[11:01:30.489] - Erased future from FutureRegistry
[11:01:30.489] result() for ClusterFuture ...
[11:01:30.489] - result already collected: FutureResult
[11:01:30.489] result() for ClusterFuture ... done
[11:01:30.489] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.489] Future #3
[11:01:30.489] result() for ClusterFuture ...
[11:01:30.489] - result already collected: FutureResult
[11:01:30.489] result() for ClusterFuture ... done
[11:01:30.489] result() for ClusterFuture ...
[11:01:30.490] - result already collected: FutureResult
[11:01:30.490] result() for ClusterFuture ... done
[11:01:30.490] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:30.490] - nx: 6
[11:01:30.490] - relay: TRUE
[11:01:30.490] - stdout: TRUE
[11:01:30.490] - signal: TRUE
[11:01:30.490] - resignal: FALSE
[11:01:30.490] - force: TRUE
[11:01:30.490] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.490] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.490]  - until=3
[11:01:30.491]  - relaying element #3
[11:01:30.491] result() for ClusterFuture ...
[11:01:30.491] - result already collected: FutureResult
[11:01:30.491] result() for ClusterFuture ... done
[11:01:30.491] result() for ClusterFuture ...
[11:01:30.491] - result already collected: FutureResult
[11:01:30.491] result() for ClusterFuture ... done
[11:01:30.491] result() for ClusterFuture ...
[11:01:30.491] - result already collected: FutureResult
[11:01:30.491] result() for ClusterFuture ... done
[11:01:30.491] result() for ClusterFuture ...
[11:01:30.491] - result already collected: FutureResult
[11:01:30.492] result() for ClusterFuture ... done
[11:01:30.492] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.492] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.492] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:30.492]  length: 3 (resolved future 3)
[11:01:30.492] signalConditionsASAP(NULL, pos=4) ...
[11:01:30.492] - nx: 6
[11:01:30.492] - relay: TRUE
[11:01:30.492] - stdout: TRUE
[11:01:30.492] - signal: TRUE
[11:01:30.492] - resignal: FALSE
[11:01:30.492] - force: TRUE
[11:01:30.493] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.493] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.493]  - until=5
[11:01:30.493]  - relaying element #5
[11:01:30.493] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.493] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.493] signalConditionsASAP(NULL, pos=4) ... done
[11:01:30.493]  length: 2 (resolved future 4)
[11:01:30.493] signalConditionsASAP(NULL, pos=5) ...
[11:01:30.493] - nx: 6
[11:01:30.493] - relay: TRUE
[11:01:30.493] - stdout: TRUE
[11:01:30.493] - signal: TRUE
[11:01:30.494] - resignal: FALSE
[11:01:30.494] - force: TRUE
[11:01:30.494] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.494] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.494]  - until=6
[11:01:30.494]  - relaying element #6
[11:01:30.494] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.494] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.494] signalConditionsASAP(NULL, pos=5) ... done
[11:01:30.494]  length: 1 (resolved future 5)
[11:01:30.494] signalConditionsASAP(numeric, pos=6) ...
[11:01:30.494] - nx: 6
[11:01:30.495] - relay: TRUE
[11:01:30.495] - stdout: TRUE
[11:01:30.495] - signal: TRUE
[11:01:30.495] - resignal: FALSE
[11:01:30.495] - force: TRUE
[11:01:30.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.495] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.495]  - until=6
[11:01:30.495] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.495] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.495] signalConditionsASAP(numeric, pos=6) ... done
[11:01:30.495]  length: 0 (resolved future 6)
[11:01:30.495] Relaying remaining futures
[11:01:30.496] signalConditionsASAP(NULL, pos=0) ...
[11:01:30.496] - nx: 6
[11:01:30.496] - relay: TRUE
[11:01:30.496] - stdout: TRUE
[11:01:30.496] - signal: TRUE
[11:01:30.496] - resignal: FALSE
[11:01:30.496] - force: TRUE
[11:01:30.496] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.496] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:30.496] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.496] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.496] signalConditionsASAP(NULL, pos=0) ... done
[11:01:30.497] resolve() on list ... DONE
[11:01:30.497] result() for ClusterFuture ...
[11:01:30.497] - result already collected: FutureResult
[11:01:30.497] result() for ClusterFuture ... done
[11:01:30.497] result() for ClusterFuture ...
[11:01:30.497] - result already collected: FutureResult
[11:01:30.497] result() for ClusterFuture ... done
[11:01:30.497] result() for ClusterFuture ...
[11:01:30.497] - result already collected: FutureResult
[11:01:30.497] result() for ClusterFuture ... done
[11:01:30.497] result() for ClusterFuture ...
[11:01:30.497] - result already collected: FutureResult
[11:01:30.497] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:3] 2 3 1
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[11:01:30.501] getGlobalsAndPackages() ...
[11:01:30.501] Searching for globals...
[11:01:30.501] 
[11:01:30.501] Searching for globals ... DONE
[11:01:30.501] - globals: [0] <none>
[11:01:30.501] getGlobalsAndPackages() ... DONE
[11:01:30.502] run() for ‘Future’ ...
[11:01:30.502] - state: ‘created’
[11:01:30.502] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.515] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.516]   - Field: ‘node’
[11:01:30.516]   - Field: ‘label’
[11:01:30.516]   - Field: ‘local’
[11:01:30.516]   - Field: ‘owner’
[11:01:30.516]   - Field: ‘envir’
[11:01:30.516]   - Field: ‘workers’
[11:01:30.516]   - Field: ‘packages’
[11:01:30.516]   - Field: ‘gc’
[11:01:30.516]   - Field: ‘conditions’
[11:01:30.516]   - Field: ‘persistent’
[11:01:30.517]   - Field: ‘expr’
[11:01:30.517]   - Field: ‘uuid’
[11:01:30.517]   - Field: ‘seed’
[11:01:30.517]   - Field: ‘version’
[11:01:30.517]   - Field: ‘result’
[11:01:30.517]   - Field: ‘asynchronous’
[11:01:30.517]   - Field: ‘calls’
[11:01:30.517]   - Field: ‘globals’
[11:01:30.517]   - Field: ‘stdout’
[11:01:30.517]   - Field: ‘earlySignal’
[11:01:30.517]   - Field: ‘lazy’
[11:01:30.517]   - Field: ‘state’
[11:01:30.518] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.518] - Launch lazy future ...
[11:01:30.518] Packages needed by the future expression (n = 0): <none>
[11:01:30.518] Packages needed by future strategies (n = 0): <none>
[11:01:30.518] {
[11:01:30.518]     {
[11:01:30.518]         {
[11:01:30.518]             ...future.startTime <- base::Sys.time()
[11:01:30.518]             {
[11:01:30.518]                 {
[11:01:30.518]                   {
[11:01:30.518]                     {
[11:01:30.518]                       base::local({
[11:01:30.518]                         has_future <- base::requireNamespace("future", 
[11:01:30.518]                           quietly = TRUE)
[11:01:30.518]                         if (has_future) {
[11:01:30.518]                           ns <- base::getNamespace("future")
[11:01:30.518]                           version <- ns[[".package"]][["version"]]
[11:01:30.518]                           if (is.null(version)) 
[11:01:30.518]                             version <- utils::packageVersion("future")
[11:01:30.518]                         }
[11:01:30.518]                         else {
[11:01:30.518]                           version <- NULL
[11:01:30.518]                         }
[11:01:30.518]                         if (!has_future || version < "1.8.0") {
[11:01:30.518]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.518]                             "", base::R.version$version.string), 
[11:01:30.518]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.518]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.518]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.518]                               "release", "version")], collapse = " "), 
[11:01:30.518]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.518]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.518]                             info)
[11:01:30.518]                           info <- base::paste(info, collapse = "; ")
[11:01:30.518]                           if (!has_future) {
[11:01:30.518]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.518]                               info)
[11:01:30.518]                           }
[11:01:30.518]                           else {
[11:01:30.518]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.518]                               info, version)
[11:01:30.518]                           }
[11:01:30.518]                           base::stop(msg)
[11:01:30.518]                         }
[11:01:30.518]                       })
[11:01:30.518]                     }
[11:01:30.518]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.518]                     base::options(mc.cores = 1L)
[11:01:30.518]                   }
[11:01:30.518]                   ...future.strategy.old <- future::plan("list")
[11:01:30.518]                   options(future.plan = NULL)
[11:01:30.518]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.518]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.518]                 }
[11:01:30.518]                 ...future.workdir <- getwd()
[11:01:30.518]             }
[11:01:30.518]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.518]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.518]         }
[11:01:30.518]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.518]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.518]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.518]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.518]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.518]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.518]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.518]             base::names(...future.oldOptions))
[11:01:30.518]     }
[11:01:30.518]     if (FALSE) {
[11:01:30.518]     }
[11:01:30.518]     else {
[11:01:30.518]         if (TRUE) {
[11:01:30.518]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.518]                 open = "w")
[11:01:30.518]         }
[11:01:30.518]         else {
[11:01:30.518]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.518]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.518]         }
[11:01:30.518]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.518]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.518]             base::sink(type = "output", split = FALSE)
[11:01:30.518]             base::close(...future.stdout)
[11:01:30.518]         }, add = TRUE)
[11:01:30.518]     }
[11:01:30.518]     ...future.frame <- base::sys.nframe()
[11:01:30.518]     ...future.conditions <- base::list()
[11:01:30.518]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.518]     if (FALSE) {
[11:01:30.518]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.518]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.518]     }
[11:01:30.518]     ...future.result <- base::tryCatch({
[11:01:30.518]         base::withCallingHandlers({
[11:01:30.518]             ...future.value <- base::withVisible(base::local({
[11:01:30.518]                 ...future.makeSendCondition <- base::local({
[11:01:30.518]                   sendCondition <- NULL
[11:01:30.518]                   function(frame = 1L) {
[11:01:30.518]                     if (is.function(sendCondition)) 
[11:01:30.518]                       return(sendCondition)
[11:01:30.518]                     ns <- getNamespace("parallel")
[11:01:30.518]                     if (exists("sendData", mode = "function", 
[11:01:30.518]                       envir = ns)) {
[11:01:30.518]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.518]                         envir = ns)
[11:01:30.518]                       envir <- sys.frame(frame)
[11:01:30.518]                       master <- NULL
[11:01:30.518]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.518]                         !identical(envir, emptyenv())) {
[11:01:30.518]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.518]                           inherits = FALSE)) {
[11:01:30.518]                           master <- get("master", mode = "list", 
[11:01:30.518]                             envir = envir, inherits = FALSE)
[11:01:30.518]                           if (inherits(master, c("SOCKnode", 
[11:01:30.518]                             "SOCK0node"))) {
[11:01:30.518]                             sendCondition <<- function(cond) {
[11:01:30.518]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.518]                                 success = TRUE)
[11:01:30.518]                               parallel_sendData(master, data)
[11:01:30.518]                             }
[11:01:30.518]                             return(sendCondition)
[11:01:30.518]                           }
[11:01:30.518]                         }
[11:01:30.518]                         frame <- frame + 1L
[11:01:30.518]                         envir <- sys.frame(frame)
[11:01:30.518]                       }
[11:01:30.518]                     }
[11:01:30.518]                     sendCondition <<- function(cond) NULL
[11:01:30.518]                   }
[11:01:30.518]                 })
[11:01:30.518]                 withCallingHandlers({
[11:01:30.518]                   2
[11:01:30.518]                 }, immediateCondition = function(cond) {
[11:01:30.518]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.518]                   sendCondition(cond)
[11:01:30.518]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.518]                   {
[11:01:30.518]                     inherits <- base::inherits
[11:01:30.518]                     invokeRestart <- base::invokeRestart
[11:01:30.518]                     is.null <- base::is.null
[11:01:30.518]                     muffled <- FALSE
[11:01:30.518]                     if (inherits(cond, "message")) {
[11:01:30.518]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.518]                       if (muffled) 
[11:01:30.518]                         invokeRestart("muffleMessage")
[11:01:30.518]                     }
[11:01:30.518]                     else if (inherits(cond, "warning")) {
[11:01:30.518]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.518]                       if (muffled) 
[11:01:30.518]                         invokeRestart("muffleWarning")
[11:01:30.518]                     }
[11:01:30.518]                     else if (inherits(cond, "condition")) {
[11:01:30.518]                       if (!is.null(pattern)) {
[11:01:30.518]                         computeRestarts <- base::computeRestarts
[11:01:30.518]                         grepl <- base::grepl
[11:01:30.518]                         restarts <- computeRestarts(cond)
[11:01:30.518]                         for (restart in restarts) {
[11:01:30.518]                           name <- restart$name
[11:01:30.518]                           if (is.null(name)) 
[11:01:30.518]                             next
[11:01:30.518]                           if (!grepl(pattern, name)) 
[11:01:30.518]                             next
[11:01:30.518]                           invokeRestart(restart)
[11:01:30.518]                           muffled <- TRUE
[11:01:30.518]                           break
[11:01:30.518]                         }
[11:01:30.518]                       }
[11:01:30.518]                     }
[11:01:30.518]                     invisible(muffled)
[11:01:30.518]                   }
[11:01:30.518]                   muffleCondition(cond)
[11:01:30.518]                 })
[11:01:30.518]             }))
[11:01:30.518]             future::FutureResult(value = ...future.value$value, 
[11:01:30.518]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.518]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.518]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.518]                     ...future.globalenv.names))
[11:01:30.518]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.518]         }, condition = base::local({
[11:01:30.518]             c <- base::c
[11:01:30.518]             inherits <- base::inherits
[11:01:30.518]             invokeRestart <- base::invokeRestart
[11:01:30.518]             length <- base::length
[11:01:30.518]             list <- base::list
[11:01:30.518]             seq.int <- base::seq.int
[11:01:30.518]             signalCondition <- base::signalCondition
[11:01:30.518]             sys.calls <- base::sys.calls
[11:01:30.518]             `[[` <- base::`[[`
[11:01:30.518]             `+` <- base::`+`
[11:01:30.518]             `<<-` <- base::`<<-`
[11:01:30.518]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.518]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.518]                   3L)]
[11:01:30.518]             }
[11:01:30.518]             function(cond) {
[11:01:30.518]                 is_error <- inherits(cond, "error")
[11:01:30.518]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.518]                   NULL)
[11:01:30.518]                 if (is_error) {
[11:01:30.518]                   sessionInformation <- function() {
[11:01:30.518]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.518]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.518]                       search = base::search(), system = base::Sys.info())
[11:01:30.518]                   }
[11:01:30.518]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.518]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.518]                     cond$call), session = sessionInformation(), 
[11:01:30.518]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.518]                   signalCondition(cond)
[11:01:30.518]                 }
[11:01:30.518]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.518]                 "immediateCondition"))) {
[11:01:30.518]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.518]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.518]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.518]                   if (TRUE && !signal) {
[11:01:30.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.518]                     {
[11:01:30.518]                       inherits <- base::inherits
[11:01:30.518]                       invokeRestart <- base::invokeRestart
[11:01:30.518]                       is.null <- base::is.null
[11:01:30.518]                       muffled <- FALSE
[11:01:30.518]                       if (inherits(cond, "message")) {
[11:01:30.518]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.518]                         if (muffled) 
[11:01:30.518]                           invokeRestart("muffleMessage")
[11:01:30.518]                       }
[11:01:30.518]                       else if (inherits(cond, "warning")) {
[11:01:30.518]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.518]                         if (muffled) 
[11:01:30.518]                           invokeRestart("muffleWarning")
[11:01:30.518]                       }
[11:01:30.518]                       else if (inherits(cond, "condition")) {
[11:01:30.518]                         if (!is.null(pattern)) {
[11:01:30.518]                           computeRestarts <- base::computeRestarts
[11:01:30.518]                           grepl <- base::grepl
[11:01:30.518]                           restarts <- computeRestarts(cond)
[11:01:30.518]                           for (restart in restarts) {
[11:01:30.518]                             name <- restart$name
[11:01:30.518]                             if (is.null(name)) 
[11:01:30.518]                               next
[11:01:30.518]                             if (!grepl(pattern, name)) 
[11:01:30.518]                               next
[11:01:30.518]                             invokeRestart(restart)
[11:01:30.518]                             muffled <- TRUE
[11:01:30.518]                             break
[11:01:30.518]                           }
[11:01:30.518]                         }
[11:01:30.518]                       }
[11:01:30.518]                       invisible(muffled)
[11:01:30.518]                     }
[11:01:30.518]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.518]                   }
[11:01:30.518]                 }
[11:01:30.518]                 else {
[11:01:30.518]                   if (TRUE) {
[11:01:30.518]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.518]                     {
[11:01:30.518]                       inherits <- base::inherits
[11:01:30.518]                       invokeRestart <- base::invokeRestart
[11:01:30.518]                       is.null <- base::is.null
[11:01:30.518]                       muffled <- FALSE
[11:01:30.518]                       if (inherits(cond, "message")) {
[11:01:30.518]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.518]                         if (muffled) 
[11:01:30.518]                           invokeRestart("muffleMessage")
[11:01:30.518]                       }
[11:01:30.518]                       else if (inherits(cond, "warning")) {
[11:01:30.518]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.518]                         if (muffled) 
[11:01:30.518]                           invokeRestart("muffleWarning")
[11:01:30.518]                       }
[11:01:30.518]                       else if (inherits(cond, "condition")) {
[11:01:30.518]                         if (!is.null(pattern)) {
[11:01:30.518]                           computeRestarts <- base::computeRestarts
[11:01:30.518]                           grepl <- base::grepl
[11:01:30.518]                           restarts <- computeRestarts(cond)
[11:01:30.518]                           for (restart in restarts) {
[11:01:30.518]                             name <- restart$name
[11:01:30.518]                             if (is.null(name)) 
[11:01:30.518]                               next
[11:01:30.518]                             if (!grepl(pattern, name)) 
[11:01:30.518]                               next
[11:01:30.518]                             invokeRestart(restart)
[11:01:30.518]                             muffled <- TRUE
[11:01:30.518]                             break
[11:01:30.518]                           }
[11:01:30.518]                         }
[11:01:30.518]                       }
[11:01:30.518]                       invisible(muffled)
[11:01:30.518]                     }
[11:01:30.518]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.518]                   }
[11:01:30.518]                 }
[11:01:30.518]             }
[11:01:30.518]         }))
[11:01:30.518]     }, error = function(ex) {
[11:01:30.518]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.518]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.518]                 ...future.rng), started = ...future.startTime, 
[11:01:30.518]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.518]             version = "1.8"), class = "FutureResult")
[11:01:30.518]     }, finally = {
[11:01:30.518]         if (!identical(...future.workdir, getwd())) 
[11:01:30.518]             setwd(...future.workdir)
[11:01:30.518]         {
[11:01:30.518]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.518]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.518]             }
[11:01:30.518]             base::options(...future.oldOptions)
[11:01:30.518]             if (.Platform$OS.type == "windows") {
[11:01:30.518]                 old_names <- names(...future.oldEnvVars)
[11:01:30.518]                 envs <- base::Sys.getenv()
[11:01:30.518]                 names <- names(envs)
[11:01:30.518]                 common <- intersect(names, old_names)
[11:01:30.518]                 added <- setdiff(names, old_names)
[11:01:30.518]                 removed <- setdiff(old_names, names)
[11:01:30.518]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.518]                   envs[common]]
[11:01:30.518]                 NAMES <- toupper(changed)
[11:01:30.518]                 args <- list()
[11:01:30.518]                 for (kk in seq_along(NAMES)) {
[11:01:30.518]                   name <- changed[[kk]]
[11:01:30.518]                   NAME <- NAMES[[kk]]
[11:01:30.518]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.518]                     next
[11:01:30.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.518]                 }
[11:01:30.518]                 NAMES <- toupper(added)
[11:01:30.518]                 for (kk in seq_along(NAMES)) {
[11:01:30.518]                   name <- added[[kk]]
[11:01:30.518]                   NAME <- NAMES[[kk]]
[11:01:30.518]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.518]                     next
[11:01:30.518]                   args[[name]] <- ""
[11:01:30.518]                 }
[11:01:30.518]                 NAMES <- toupper(removed)
[11:01:30.518]                 for (kk in seq_along(NAMES)) {
[11:01:30.518]                   name <- removed[[kk]]
[11:01:30.518]                   NAME <- NAMES[[kk]]
[11:01:30.518]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.518]                     next
[11:01:30.518]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.518]                 }
[11:01:30.518]                 if (length(args) > 0) 
[11:01:30.518]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.518]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.518]             }
[11:01:30.518]             else {
[11:01:30.518]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.518]             }
[11:01:30.518]             {
[11:01:30.518]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.518]                   0L) {
[11:01:30.518]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.518]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.518]                   base::options(opts)
[11:01:30.518]                 }
[11:01:30.518]                 {
[11:01:30.518]                   {
[11:01:30.518]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.518]                     NULL
[11:01:30.518]                   }
[11:01:30.518]                   options(future.plan = NULL)
[11:01:30.518]                   if (is.na(NA_character_)) 
[11:01:30.518]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.518]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.518]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.518]                     .init = FALSE)
[11:01:30.518]                 }
[11:01:30.518]             }
[11:01:30.518]         }
[11:01:30.518]     })
[11:01:30.518]     if (TRUE) {
[11:01:30.518]         base::sink(type = "output", split = FALSE)
[11:01:30.518]         if (TRUE) {
[11:01:30.518]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.518]         }
[11:01:30.518]         else {
[11:01:30.518]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.518]         }
[11:01:30.518]         base::close(...future.stdout)
[11:01:30.518]         ...future.stdout <- NULL
[11:01:30.518]     }
[11:01:30.518]     ...future.result$conditions <- ...future.conditions
[11:01:30.518]     ...future.result$finished <- base::Sys.time()
[11:01:30.518]     ...future.result
[11:01:30.518] }
[11:01:30.521] MultisessionFuture started
[11:01:30.521] - Launch lazy future ... done
[11:01:30.521] run() for ‘MultisessionFuture’ ... done
[11:01:30.522] getGlobalsAndPackages() ...
[11:01:30.522] Searching for globals...
[11:01:30.522] 
[11:01:30.522] Searching for globals ... DONE
[11:01:30.522] - globals: [0] <none>
[11:01:30.522] getGlobalsAndPackages() ... DONE
[11:01:30.522] run() for ‘Future’ ...
[11:01:30.522] - state: ‘created’
[11:01:30.523] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.536] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.536] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:30.536]   - Field: ‘node’
[11:01:30.536]   - Field: ‘label’
[11:01:30.536]   - Field: ‘local’
[11:01:30.536]   - Field: ‘owner’
[11:01:30.537]   - Field: ‘envir’
[11:01:30.537]   - Field: ‘workers’
[11:01:30.537]   - Field: ‘packages’
[11:01:30.537]   - Field: ‘gc’
[11:01:30.537]   - Field: ‘conditions’
[11:01:30.537]   - Field: ‘persistent’
[11:01:30.537]   - Field: ‘expr’
[11:01:30.537]   - Field: ‘uuid’
[11:01:30.537]   - Field: ‘seed’
[11:01:30.537]   - Field: ‘version’
[11:01:30.537]   - Field: ‘result’
[11:01:30.537]   - Field: ‘asynchronous’
[11:01:30.538]   - Field: ‘calls’
[11:01:30.538]   - Field: ‘globals’
[11:01:30.538]   - Field: ‘stdout’
[11:01:30.538]   - Field: ‘earlySignal’
[11:01:30.538]   - Field: ‘lazy’
[11:01:30.538]   - Field: ‘state’
[11:01:30.538] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:30.538] - Launch lazy future ...
[11:01:30.538] Packages needed by the future expression (n = 0): <none>
[11:01:30.539] Packages needed by future strategies (n = 0): <none>
[11:01:30.539] {
[11:01:30.539]     {
[11:01:30.539]         {
[11:01:30.539]             ...future.startTime <- base::Sys.time()
[11:01:30.539]             {
[11:01:30.539]                 {
[11:01:30.539]                   {
[11:01:30.539]                     {
[11:01:30.539]                       base::local({
[11:01:30.539]                         has_future <- base::requireNamespace("future", 
[11:01:30.539]                           quietly = TRUE)
[11:01:30.539]                         if (has_future) {
[11:01:30.539]                           ns <- base::getNamespace("future")
[11:01:30.539]                           version <- ns[[".package"]][["version"]]
[11:01:30.539]                           if (is.null(version)) 
[11:01:30.539]                             version <- utils::packageVersion("future")
[11:01:30.539]                         }
[11:01:30.539]                         else {
[11:01:30.539]                           version <- NULL
[11:01:30.539]                         }
[11:01:30.539]                         if (!has_future || version < "1.8.0") {
[11:01:30.539]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.539]                             "", base::R.version$version.string), 
[11:01:30.539]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.539]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.539]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.539]                               "release", "version")], collapse = " "), 
[11:01:30.539]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.539]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.539]                             info)
[11:01:30.539]                           info <- base::paste(info, collapse = "; ")
[11:01:30.539]                           if (!has_future) {
[11:01:30.539]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.539]                               info)
[11:01:30.539]                           }
[11:01:30.539]                           else {
[11:01:30.539]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.539]                               info, version)
[11:01:30.539]                           }
[11:01:30.539]                           base::stop(msg)
[11:01:30.539]                         }
[11:01:30.539]                       })
[11:01:30.539]                     }
[11:01:30.539]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.539]                     base::options(mc.cores = 1L)
[11:01:30.539]                   }
[11:01:30.539]                   ...future.strategy.old <- future::plan("list")
[11:01:30.539]                   options(future.plan = NULL)
[11:01:30.539]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.539]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.539]                 }
[11:01:30.539]                 ...future.workdir <- getwd()
[11:01:30.539]             }
[11:01:30.539]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.539]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.539]         }
[11:01:30.539]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.539]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.539]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.539]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.539]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.539]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.539]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.539]             base::names(...future.oldOptions))
[11:01:30.539]     }
[11:01:30.539]     if (FALSE) {
[11:01:30.539]     }
[11:01:30.539]     else {
[11:01:30.539]         if (TRUE) {
[11:01:30.539]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.539]                 open = "w")
[11:01:30.539]         }
[11:01:30.539]         else {
[11:01:30.539]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.539]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.539]         }
[11:01:30.539]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.539]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.539]             base::sink(type = "output", split = FALSE)
[11:01:30.539]             base::close(...future.stdout)
[11:01:30.539]         }, add = TRUE)
[11:01:30.539]     }
[11:01:30.539]     ...future.frame <- base::sys.nframe()
[11:01:30.539]     ...future.conditions <- base::list()
[11:01:30.539]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.539]     if (FALSE) {
[11:01:30.539]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.539]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.539]     }
[11:01:30.539]     ...future.result <- base::tryCatch({
[11:01:30.539]         base::withCallingHandlers({
[11:01:30.539]             ...future.value <- base::withVisible(base::local({
[11:01:30.539]                 ...future.makeSendCondition <- base::local({
[11:01:30.539]                   sendCondition <- NULL
[11:01:30.539]                   function(frame = 1L) {
[11:01:30.539]                     if (is.function(sendCondition)) 
[11:01:30.539]                       return(sendCondition)
[11:01:30.539]                     ns <- getNamespace("parallel")
[11:01:30.539]                     if (exists("sendData", mode = "function", 
[11:01:30.539]                       envir = ns)) {
[11:01:30.539]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:30.539]                         envir = ns)
[11:01:30.539]                       envir <- sys.frame(frame)
[11:01:30.539]                       master <- NULL
[11:01:30.539]                       while (!identical(envir, .GlobalEnv) && 
[11:01:30.539]                         !identical(envir, emptyenv())) {
[11:01:30.539]                         if (exists("master", mode = "list", envir = envir, 
[11:01:30.539]                           inherits = FALSE)) {
[11:01:30.539]                           master <- get("master", mode = "list", 
[11:01:30.539]                             envir = envir, inherits = FALSE)
[11:01:30.539]                           if (inherits(master, c("SOCKnode", 
[11:01:30.539]                             "SOCK0node"))) {
[11:01:30.539]                             sendCondition <<- function(cond) {
[11:01:30.539]                               data <- list(type = "VALUE", value = cond, 
[11:01:30.539]                                 success = TRUE)
[11:01:30.539]                               parallel_sendData(master, data)
[11:01:30.539]                             }
[11:01:30.539]                             return(sendCondition)
[11:01:30.539]                           }
[11:01:30.539]                         }
[11:01:30.539]                         frame <- frame + 1L
[11:01:30.539]                         envir <- sys.frame(frame)
[11:01:30.539]                       }
[11:01:30.539]                     }
[11:01:30.539]                     sendCondition <<- function(cond) NULL
[11:01:30.539]                   }
[11:01:30.539]                 })
[11:01:30.539]                 withCallingHandlers({
[11:01:30.539]                   NULL
[11:01:30.539]                 }, immediateCondition = function(cond) {
[11:01:30.539]                   sendCondition <- ...future.makeSendCondition()
[11:01:30.539]                   sendCondition(cond)
[11:01:30.539]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.539]                   {
[11:01:30.539]                     inherits <- base::inherits
[11:01:30.539]                     invokeRestart <- base::invokeRestart
[11:01:30.539]                     is.null <- base::is.null
[11:01:30.539]                     muffled <- FALSE
[11:01:30.539]                     if (inherits(cond, "message")) {
[11:01:30.539]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.539]                       if (muffled) 
[11:01:30.539]                         invokeRestart("muffleMessage")
[11:01:30.539]                     }
[11:01:30.539]                     else if (inherits(cond, "warning")) {
[11:01:30.539]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.539]                       if (muffled) 
[11:01:30.539]                         invokeRestart("muffleWarning")
[11:01:30.539]                     }
[11:01:30.539]                     else if (inherits(cond, "condition")) {
[11:01:30.539]                       if (!is.null(pattern)) {
[11:01:30.539]                         computeRestarts <- base::computeRestarts
[11:01:30.539]                         grepl <- base::grepl
[11:01:30.539]                         restarts <- computeRestarts(cond)
[11:01:30.539]                         for (restart in restarts) {
[11:01:30.539]                           name <- restart$name
[11:01:30.539]                           if (is.null(name)) 
[11:01:30.539]                             next
[11:01:30.539]                           if (!grepl(pattern, name)) 
[11:01:30.539]                             next
[11:01:30.539]                           invokeRestart(restart)
[11:01:30.539]                           muffled <- TRUE
[11:01:30.539]                           break
[11:01:30.539]                         }
[11:01:30.539]                       }
[11:01:30.539]                     }
[11:01:30.539]                     invisible(muffled)
[11:01:30.539]                   }
[11:01:30.539]                   muffleCondition(cond)
[11:01:30.539]                 })
[11:01:30.539]             }))
[11:01:30.539]             future::FutureResult(value = ...future.value$value, 
[11:01:30.539]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.539]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.539]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.539]                     ...future.globalenv.names))
[11:01:30.539]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.539]         }, condition = base::local({
[11:01:30.539]             c <- base::c
[11:01:30.539]             inherits <- base::inherits
[11:01:30.539]             invokeRestart <- base::invokeRestart
[11:01:30.539]             length <- base::length
[11:01:30.539]             list <- base::list
[11:01:30.539]             seq.int <- base::seq.int
[11:01:30.539]             signalCondition <- base::signalCondition
[11:01:30.539]             sys.calls <- base::sys.calls
[11:01:30.539]             `[[` <- base::`[[`
[11:01:30.539]             `+` <- base::`+`
[11:01:30.539]             `<<-` <- base::`<<-`
[11:01:30.539]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.539]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.539]                   3L)]
[11:01:30.539]             }
[11:01:30.539]             function(cond) {
[11:01:30.539]                 is_error <- inherits(cond, "error")
[11:01:30.539]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.539]                   NULL)
[11:01:30.539]                 if (is_error) {
[11:01:30.539]                   sessionInformation <- function() {
[11:01:30.539]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.539]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.539]                       search = base::search(), system = base::Sys.info())
[11:01:30.539]                   }
[11:01:30.539]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.539]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.539]                     cond$call), session = sessionInformation(), 
[11:01:30.539]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.539]                   signalCondition(cond)
[11:01:30.539]                 }
[11:01:30.539]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.539]                 "immediateCondition"))) {
[11:01:30.539]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.539]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.539]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.539]                   if (TRUE && !signal) {
[11:01:30.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.539]                     {
[11:01:30.539]                       inherits <- base::inherits
[11:01:30.539]                       invokeRestart <- base::invokeRestart
[11:01:30.539]                       is.null <- base::is.null
[11:01:30.539]                       muffled <- FALSE
[11:01:30.539]                       if (inherits(cond, "message")) {
[11:01:30.539]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.539]                         if (muffled) 
[11:01:30.539]                           invokeRestart("muffleMessage")
[11:01:30.539]                       }
[11:01:30.539]                       else if (inherits(cond, "warning")) {
[11:01:30.539]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.539]                         if (muffled) 
[11:01:30.539]                           invokeRestart("muffleWarning")
[11:01:30.539]                       }
[11:01:30.539]                       else if (inherits(cond, "condition")) {
[11:01:30.539]                         if (!is.null(pattern)) {
[11:01:30.539]                           computeRestarts <- base::computeRestarts
[11:01:30.539]                           grepl <- base::grepl
[11:01:30.539]                           restarts <- computeRestarts(cond)
[11:01:30.539]                           for (restart in restarts) {
[11:01:30.539]                             name <- restart$name
[11:01:30.539]                             if (is.null(name)) 
[11:01:30.539]                               next
[11:01:30.539]                             if (!grepl(pattern, name)) 
[11:01:30.539]                               next
[11:01:30.539]                             invokeRestart(restart)
[11:01:30.539]                             muffled <- TRUE
[11:01:30.539]                             break
[11:01:30.539]                           }
[11:01:30.539]                         }
[11:01:30.539]                       }
[11:01:30.539]                       invisible(muffled)
[11:01:30.539]                     }
[11:01:30.539]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.539]                   }
[11:01:30.539]                 }
[11:01:30.539]                 else {
[11:01:30.539]                   if (TRUE) {
[11:01:30.539]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.539]                     {
[11:01:30.539]                       inherits <- base::inherits
[11:01:30.539]                       invokeRestart <- base::invokeRestart
[11:01:30.539]                       is.null <- base::is.null
[11:01:30.539]                       muffled <- FALSE
[11:01:30.539]                       if (inherits(cond, "message")) {
[11:01:30.539]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.539]                         if (muffled) 
[11:01:30.539]                           invokeRestart("muffleMessage")
[11:01:30.539]                       }
[11:01:30.539]                       else if (inherits(cond, "warning")) {
[11:01:30.539]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.539]                         if (muffled) 
[11:01:30.539]                           invokeRestart("muffleWarning")
[11:01:30.539]                       }
[11:01:30.539]                       else if (inherits(cond, "condition")) {
[11:01:30.539]                         if (!is.null(pattern)) {
[11:01:30.539]                           computeRestarts <- base::computeRestarts
[11:01:30.539]                           grepl <- base::grepl
[11:01:30.539]                           restarts <- computeRestarts(cond)
[11:01:30.539]                           for (restart in restarts) {
[11:01:30.539]                             name <- restart$name
[11:01:30.539]                             if (is.null(name)) 
[11:01:30.539]                               next
[11:01:30.539]                             if (!grepl(pattern, name)) 
[11:01:30.539]                               next
[11:01:30.539]                             invokeRestart(restart)
[11:01:30.539]                             muffled <- TRUE
[11:01:30.539]                             break
[11:01:30.539]                           }
[11:01:30.539]                         }
[11:01:30.539]                       }
[11:01:30.539]                       invisible(muffled)
[11:01:30.539]                     }
[11:01:30.539]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.539]                   }
[11:01:30.539]                 }
[11:01:30.539]             }
[11:01:30.539]         }))
[11:01:30.539]     }, error = function(ex) {
[11:01:30.539]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.539]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.539]                 ...future.rng), started = ...future.startTime, 
[11:01:30.539]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.539]             version = "1.8"), class = "FutureResult")
[11:01:30.539]     }, finally = {
[11:01:30.539]         if (!identical(...future.workdir, getwd())) 
[11:01:30.539]             setwd(...future.workdir)
[11:01:30.539]         {
[11:01:30.539]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.539]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.539]             }
[11:01:30.539]             base::options(...future.oldOptions)
[11:01:30.539]             if (.Platform$OS.type == "windows") {
[11:01:30.539]                 old_names <- names(...future.oldEnvVars)
[11:01:30.539]                 envs <- base::Sys.getenv()
[11:01:30.539]                 names <- names(envs)
[11:01:30.539]                 common <- intersect(names, old_names)
[11:01:30.539]                 added <- setdiff(names, old_names)
[11:01:30.539]                 removed <- setdiff(old_names, names)
[11:01:30.539]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.539]                   envs[common]]
[11:01:30.539]                 NAMES <- toupper(changed)
[11:01:30.539]                 args <- list()
[11:01:30.539]                 for (kk in seq_along(NAMES)) {
[11:01:30.539]                   name <- changed[[kk]]
[11:01:30.539]                   NAME <- NAMES[[kk]]
[11:01:30.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.539]                     next
[11:01:30.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.539]                 }
[11:01:30.539]                 NAMES <- toupper(added)
[11:01:30.539]                 for (kk in seq_along(NAMES)) {
[11:01:30.539]                   name <- added[[kk]]
[11:01:30.539]                   NAME <- NAMES[[kk]]
[11:01:30.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.539]                     next
[11:01:30.539]                   args[[name]] <- ""
[11:01:30.539]                 }
[11:01:30.539]                 NAMES <- toupper(removed)
[11:01:30.539]                 for (kk in seq_along(NAMES)) {
[11:01:30.539]                   name <- removed[[kk]]
[11:01:30.539]                   NAME <- NAMES[[kk]]
[11:01:30.539]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.539]                     next
[11:01:30.539]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.539]                 }
[11:01:30.539]                 if (length(args) > 0) 
[11:01:30.539]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.539]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.539]             }
[11:01:30.539]             else {
[11:01:30.539]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.539]             }
[11:01:30.539]             {
[11:01:30.539]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.539]                   0L) {
[11:01:30.539]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.539]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.539]                   base::options(opts)
[11:01:30.539]                 }
[11:01:30.539]                 {
[11:01:30.539]                   {
[11:01:30.539]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.539]                     NULL
[11:01:30.539]                   }
[11:01:30.539]                   options(future.plan = NULL)
[11:01:30.539]                   if (is.na(NA_character_)) 
[11:01:30.539]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.539]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.539]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.539]                     .init = FALSE)
[11:01:30.539]                 }
[11:01:30.539]             }
[11:01:30.539]         }
[11:01:30.539]     })
[11:01:30.539]     if (TRUE) {
[11:01:30.539]         base::sink(type = "output", split = FALSE)
[11:01:30.539]         if (TRUE) {
[11:01:30.539]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.539]         }
[11:01:30.539]         else {
[11:01:30.539]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.539]         }
[11:01:30.539]         base::close(...future.stdout)
[11:01:30.539]         ...future.stdout <- NULL
[11:01:30.539]     }
[11:01:30.539]     ...future.result$conditions <- ...future.conditions
[11:01:30.539]     ...future.result$finished <- base::Sys.time()
[11:01:30.539]     ...future.result
[11:01:30.539] }
[11:01:30.542] MultisessionFuture started
[11:01:30.542] - Launch lazy future ... done
[11:01:30.542] run() for ‘MultisessionFuture’ ... done
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c7f870f0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c82d0218> 
 $  : NULL
 $  : NULL
 $  : num 6
List of 6
 $ a: num 1
 $ b:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c7f870f0> 
 $ c:Classes 'MultisessionFuture', 'ClusterFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a9c82d0218> 
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 logi [1:2, 1, 1:3, 1] TRUE FALSE FALSE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "" ...
[11:01:30.570] resolve() on list ...
[11:01:30.570]  recursive: 0
[11:01:30.570]  length: 6
[11:01:30.570]  elements: ‘a’, ‘b’, ‘c’, ‘’, ‘’, ‘’
[11:01:30.570] signalConditionsASAP(numeric, pos=1) ...
[11:01:30.570] - nx: 6
[11:01:30.570] - relay: TRUE
[11:01:30.571] - stdout: TRUE
[11:01:30.571] - signal: TRUE
[11:01:30.571] - resignal: FALSE
[11:01:30.571] - force: TRUE
[11:01:30.571] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.571] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.571]  - until=2
[11:01:30.571]  - relaying element #2
[11:01:30.571] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.571] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.571] signalConditionsASAP(NULL, pos=1) ... done
[11:01:30.571]  length: 5 (resolved future 1)
[11:01:30.572] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.572] - Validating connection of MultisessionFuture
[11:01:30.572] - received message: FutureResult
[11:01:30.572] - Received FutureResult
[11:01:30.572] - Erased future from FutureRegistry
[11:01:30.572] result() for ClusterFuture ...
[11:01:30.573] - result already collected: FutureResult
[11:01:30.573] result() for ClusterFuture ... done
[11:01:30.573] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.573] Future #2
[11:01:30.573] result() for ClusterFuture ...
[11:01:30.573] - result already collected: FutureResult
[11:01:30.573] result() for ClusterFuture ... done
[11:01:30.573] result() for ClusterFuture ...
[11:01:30.573] - result already collected: FutureResult
[11:01:30.573] result() for ClusterFuture ... done
[11:01:30.573] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:30.573] - nx: 6
[11:01:30.573] - relay: TRUE
[11:01:30.574] - stdout: TRUE
[11:01:30.574] - signal: TRUE
[11:01:30.574] - resignal: FALSE
[11:01:30.574] - force: TRUE
[11:01:30.574] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.574] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:30.574]  - until=2
[11:01:30.574]  - relaying element #2
[11:01:30.574] result() for ClusterFuture ...
[11:01:30.574] - result already collected: FutureResult
[11:01:30.574] result() for ClusterFuture ... done
[11:01:30.574] result() for ClusterFuture ...
[11:01:30.575] - result already collected: FutureResult
[11:01:30.575] result() for ClusterFuture ... done
[11:01:30.575] result() for ClusterFuture ...
[11:01:30.575] - result already collected: FutureResult
[11:01:30.575] result() for ClusterFuture ... done
[11:01:30.575] result() for ClusterFuture ...
[11:01:30.575] - result already collected: FutureResult
[11:01:30.575] result() for ClusterFuture ... done
[11:01:30.575] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.575] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.575] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:30.575]  length: 4 (resolved future 2)
[11:01:30.584] receiveMessageFromWorker() for ClusterFuture ...
[11:01:30.584] - Validating connection of MultisessionFuture
[11:01:30.584] - received message: FutureResult
[11:01:30.584] - Received FutureResult
[11:01:30.585] - Erased future from FutureRegistry
[11:01:30.585] result() for ClusterFuture ...
[11:01:30.585] - result already collected: FutureResult
[11:01:30.585] result() for ClusterFuture ... done
[11:01:30.585] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:30.585] Future #3
[11:01:30.585] result() for ClusterFuture ...
[11:01:30.585] - result already collected: FutureResult
[11:01:30.585] result() for ClusterFuture ... done
[11:01:30.585] result() for ClusterFuture ...
[11:01:30.585] - result already collected: FutureResult
[11:01:30.585] result() for ClusterFuture ... done
[11:01:30.586] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:30.586] - nx: 6
[11:01:30.586] - relay: TRUE
[11:01:30.586] - stdout: TRUE
[11:01:30.586] - signal: TRUE
[11:01:30.586] - resignal: FALSE
[11:01:30.586] - force: TRUE
[11:01:30.588] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.588] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:30.588]  - until=3
[11:01:30.588]  - relaying element #3
[11:01:30.588] result() for ClusterFuture ...
[11:01:30.588] - result already collected: FutureResult
[11:01:30.588] result() for ClusterFuture ... done
[11:01:30.588] result() for ClusterFuture ...
[11:01:30.588] - result already collected: FutureResult
[11:01:30.588] result() for ClusterFuture ... done
[11:01:30.589] result() for ClusterFuture ...
[11:01:30.589] - result already collected: FutureResult
[11:01:30.589] result() for ClusterFuture ... done
[11:01:30.589] result() for ClusterFuture ...
[11:01:30.589] - result already collected: FutureResult
[11:01:30.589] result() for ClusterFuture ... done
[11:01:30.589] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.589] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.589] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:30.589]  length: 3 (resolved future 3)
[11:01:30.589] signalConditionsASAP(NULL, pos=4) ...
[11:01:30.589] - nx: 6
[11:01:30.590] - relay: TRUE
[11:01:30.590] - stdout: TRUE
[11:01:30.590] - signal: TRUE
[11:01:30.590] - resignal: FALSE
[11:01:30.590] - force: TRUE
[11:01:30.590] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.590] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.590]  - until=5
[11:01:30.590]  - relaying element #5
[11:01:30.590] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.590] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.590] signalConditionsASAP(NULL, pos=4) ... done
[11:01:30.591]  length: 2 (resolved future 4)
[11:01:30.591] signalConditionsASAP(NULL, pos=5) ...
[11:01:30.591] - nx: 6
[11:01:30.591] - relay: TRUE
[11:01:30.591] - stdout: TRUE
[11:01:30.591] - signal: TRUE
[11:01:30.591] - resignal: FALSE
[11:01:30.591] - force: TRUE
[11:01:30.591] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:30.591] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.591]  - until=6
[11:01:30.591]  - relaying element #6
[11:01:30.591] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.591] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.592] signalConditionsASAP(NULL, pos=5) ... done
[11:01:30.592]  length: 1 (resolved future 5)
[11:01:30.592] signalConditionsASAP(numeric, pos=6) ...
[11:01:30.592] - nx: 6
[11:01:30.592] - relay: TRUE
[11:01:30.592] - stdout: TRUE
[11:01:30.592] - signal: TRUE
[11:01:30.592] - resignal: FALSE
[11:01:30.592] - force: TRUE
[11:01:30.592] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:30.592] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.592]  - until=6
[11:01:30.592] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.593] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.593] signalConditionsASAP(numeric, pos=6) ... done
[11:01:30.593]  length: 0 (resolved future 6)
[11:01:30.593] Relaying remaining futures
[11:01:30.593] signalConditionsASAP(NULL, pos=0) ...
[11:01:30.593] - nx: 6
[11:01:30.593] - relay: TRUE
[11:01:30.593] - stdout: TRUE
[11:01:30.593] - signal: TRUE
[11:01:30.593] - resignal: FALSE
[11:01:30.593] - force: TRUE
[11:01:30.593] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.594] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
 - flush all
[11:01:30.594] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:30.594] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:30.594] signalConditionsASAP(NULL, pos=0) ... done
[11:01:30.594] resolve() on list ... DONE
[11:01:30.594] result() for ClusterFuture ...
[11:01:30.594] - result already collected: FutureResult
[11:01:30.594] result() for ClusterFuture ... done
[11:01:30.594] result() for ClusterFuture ...
[11:01:30.594] - result already collected: FutureResult
[11:01:30.594] result() for ClusterFuture ... done
[11:01:30.594] result() for ClusterFuture ...
[11:01:30.595] - result already collected: FutureResult
[11:01:30.595] result() for ClusterFuture ... done
[11:01:30.595] result() for ClusterFuture ...
[11:01:30.595] - result already collected: FutureResult
[11:01:30.595] result() for ClusterFuture ... done
List of 6
 $ a: num 1
 $ b: num 2
 $ c: NULL
 $  : NULL
 $  : NULL
 $  : num 6
 - attr(*, "dim")= int [1:4] 2 1 3 1
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - list ... DONE
Type of object: environment
Type of future: multicore
[11:01:30.598] plan(): Setting new future strategy stack:
[11:01:30.599] List of future strategies:
[11:01:30.599] 1. multicore:
[11:01:30.599]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.599]    - tweaked: FALSE
[11:01:30.599]    - call: plan(strategy)
[11:01:30.601] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[11:01:30.601] getGlobalsAndPackages() ...
[11:01:30.601] Searching for globals...
[11:01:30.602] 
[11:01:30.602] Searching for globals ... DONE
[11:01:30.602] - globals: [0] <none>
[11:01:30.602] getGlobalsAndPackages() ... DONE
[11:01:30.603] run() for ‘Future’ ...
[11:01:30.603] - state: ‘created’
[11:01:30.603] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.605] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.605] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.605]   - Field: ‘label’
[11:01:30.605]   - Field: ‘local’
[11:01:30.606]   - Field: ‘owner’
[11:01:30.606]   - Field: ‘envir’
[11:01:30.606]   - Field: ‘workers’
[11:01:30.606]   - Field: ‘packages’
[11:01:30.606]   - Field: ‘gc’
[11:01:30.606]   - Field: ‘job’
[11:01:30.606]   - Field: ‘conditions’
[11:01:30.606]   - Field: ‘expr’
[11:01:30.607]   - Field: ‘uuid’
[11:01:30.607]   - Field: ‘seed’
[11:01:30.607]   - Field: ‘version’
[11:01:30.607]   - Field: ‘result’
[11:01:30.607]   - Field: ‘asynchronous’
[11:01:30.607]   - Field: ‘calls’
[11:01:30.607]   - Field: ‘globals’
[11:01:30.607]   - Field: ‘stdout’
[11:01:30.607]   - Field: ‘earlySignal’
[11:01:30.608]   - Field: ‘lazy’
[11:01:30.608]   - Field: ‘state’
[11:01:30.608] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.608] - Launch lazy future ...
[11:01:30.608] Packages needed by the future expression (n = 0): <none>
[11:01:30.608] Packages needed by future strategies (n = 0): <none>
[11:01:30.609] {
[11:01:30.609]     {
[11:01:30.609]         {
[11:01:30.609]             ...future.startTime <- base::Sys.time()
[11:01:30.609]             {
[11:01:30.609]                 {
[11:01:30.609]                   {
[11:01:30.609]                     {
[11:01:30.609]                       base::local({
[11:01:30.609]                         has_future <- base::requireNamespace("future", 
[11:01:30.609]                           quietly = TRUE)
[11:01:30.609]                         if (has_future) {
[11:01:30.609]                           ns <- base::getNamespace("future")
[11:01:30.609]                           version <- ns[[".package"]][["version"]]
[11:01:30.609]                           if (is.null(version)) 
[11:01:30.609]                             version <- utils::packageVersion("future")
[11:01:30.609]                         }
[11:01:30.609]                         else {
[11:01:30.609]                           version <- NULL
[11:01:30.609]                         }
[11:01:30.609]                         if (!has_future || version < "1.8.0") {
[11:01:30.609]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.609]                             "", base::R.version$version.string), 
[11:01:30.609]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.609]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.609]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.609]                               "release", "version")], collapse = " "), 
[11:01:30.609]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.609]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.609]                             info)
[11:01:30.609]                           info <- base::paste(info, collapse = "; ")
[11:01:30.609]                           if (!has_future) {
[11:01:30.609]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.609]                               info)
[11:01:30.609]                           }
[11:01:30.609]                           else {
[11:01:30.609]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.609]                               info, version)
[11:01:30.609]                           }
[11:01:30.609]                           base::stop(msg)
[11:01:30.609]                         }
[11:01:30.609]                       })
[11:01:30.609]                     }
[11:01:30.609]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.609]                     base::options(mc.cores = 1L)
[11:01:30.609]                   }
[11:01:30.609]                   ...future.strategy.old <- future::plan("list")
[11:01:30.609]                   options(future.plan = NULL)
[11:01:30.609]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.609]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.609]                 }
[11:01:30.609]                 ...future.workdir <- getwd()
[11:01:30.609]             }
[11:01:30.609]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.609]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.609]         }
[11:01:30.609]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.609]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.609]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.609]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.609]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.609]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.609]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.609]             base::names(...future.oldOptions))
[11:01:30.609]     }
[11:01:30.609]     if (FALSE) {
[11:01:30.609]     }
[11:01:30.609]     else {
[11:01:30.609]         if (TRUE) {
[11:01:30.609]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.609]                 open = "w")
[11:01:30.609]         }
[11:01:30.609]         else {
[11:01:30.609]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.609]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.609]         }
[11:01:30.609]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.609]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.609]             base::sink(type = "output", split = FALSE)
[11:01:30.609]             base::close(...future.stdout)
[11:01:30.609]         }, add = TRUE)
[11:01:30.609]     }
[11:01:30.609]     ...future.frame <- base::sys.nframe()
[11:01:30.609]     ...future.conditions <- base::list()
[11:01:30.609]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.609]     if (FALSE) {
[11:01:30.609]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.609]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.609]     }
[11:01:30.609]     ...future.result <- base::tryCatch({
[11:01:30.609]         base::withCallingHandlers({
[11:01:30.609]             ...future.value <- base::withVisible(base::local({
[11:01:30.609]                 withCallingHandlers({
[11:01:30.609]                   2
[11:01:30.609]                 }, immediateCondition = function(cond) {
[11:01:30.609]                   save_rds <- function (object, pathname, ...) 
[11:01:30.609]                   {
[11:01:30.609]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.609]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.609]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.609]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.609]                         fi_tmp[["mtime"]])
[11:01:30.609]                     }
[11:01:30.609]                     tryCatch({
[11:01:30.609]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.609]                     }, error = function(ex) {
[11:01:30.609]                       msg <- conditionMessage(ex)
[11:01:30.609]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.609]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.609]                         fi_tmp[["mtime"]], msg)
[11:01:30.609]                       ex$message <- msg
[11:01:30.609]                       stop(ex)
[11:01:30.609]                     })
[11:01:30.609]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.609]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.609]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.609]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.609]                       fi <- file.info(pathname)
[11:01:30.609]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.609]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.609]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.609]                         fi[["size"]], fi[["mtime"]])
[11:01:30.609]                       stop(msg)
[11:01:30.609]                     }
[11:01:30.609]                     invisible(pathname)
[11:01:30.609]                   }
[11:01:30.609]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.609]                     rootPath = tempdir()) 
[11:01:30.609]                   {
[11:01:30.609]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.609]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.609]                       tmpdir = path, fileext = ".rds")
[11:01:30.609]                     save_rds(obj, file)
[11:01:30.609]                   }
[11:01:30.609]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.609]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.609]                   {
[11:01:30.609]                     inherits <- base::inherits
[11:01:30.609]                     invokeRestart <- base::invokeRestart
[11:01:30.609]                     is.null <- base::is.null
[11:01:30.609]                     muffled <- FALSE
[11:01:30.609]                     if (inherits(cond, "message")) {
[11:01:30.609]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.609]                       if (muffled) 
[11:01:30.609]                         invokeRestart("muffleMessage")
[11:01:30.609]                     }
[11:01:30.609]                     else if (inherits(cond, "warning")) {
[11:01:30.609]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.609]                       if (muffled) 
[11:01:30.609]                         invokeRestart("muffleWarning")
[11:01:30.609]                     }
[11:01:30.609]                     else if (inherits(cond, "condition")) {
[11:01:30.609]                       if (!is.null(pattern)) {
[11:01:30.609]                         computeRestarts <- base::computeRestarts
[11:01:30.609]                         grepl <- base::grepl
[11:01:30.609]                         restarts <- computeRestarts(cond)
[11:01:30.609]                         for (restart in restarts) {
[11:01:30.609]                           name <- restart$name
[11:01:30.609]                           if (is.null(name)) 
[11:01:30.609]                             next
[11:01:30.609]                           if (!grepl(pattern, name)) 
[11:01:30.609]                             next
[11:01:30.609]                           invokeRestart(restart)
[11:01:30.609]                           muffled <- TRUE
[11:01:30.609]                           break
[11:01:30.609]                         }
[11:01:30.609]                       }
[11:01:30.609]                     }
[11:01:30.609]                     invisible(muffled)
[11:01:30.609]                   }
[11:01:30.609]                   muffleCondition(cond)
[11:01:30.609]                 })
[11:01:30.609]             }))
[11:01:30.609]             future::FutureResult(value = ...future.value$value, 
[11:01:30.609]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.609]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.609]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.609]                     ...future.globalenv.names))
[11:01:30.609]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.609]         }, condition = base::local({
[11:01:30.609]             c <- base::c
[11:01:30.609]             inherits <- base::inherits
[11:01:30.609]             invokeRestart <- base::invokeRestart
[11:01:30.609]             length <- base::length
[11:01:30.609]             list <- base::list
[11:01:30.609]             seq.int <- base::seq.int
[11:01:30.609]             signalCondition <- base::signalCondition
[11:01:30.609]             sys.calls <- base::sys.calls
[11:01:30.609]             `[[` <- base::`[[`
[11:01:30.609]             `+` <- base::`+`
[11:01:30.609]             `<<-` <- base::`<<-`
[11:01:30.609]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.609]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.609]                   3L)]
[11:01:30.609]             }
[11:01:30.609]             function(cond) {
[11:01:30.609]                 is_error <- inherits(cond, "error")
[11:01:30.609]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.609]                   NULL)
[11:01:30.609]                 if (is_error) {
[11:01:30.609]                   sessionInformation <- function() {
[11:01:30.609]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.609]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.609]                       search = base::search(), system = base::Sys.info())
[11:01:30.609]                   }
[11:01:30.609]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.609]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.609]                     cond$call), session = sessionInformation(), 
[11:01:30.609]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.609]                   signalCondition(cond)
[11:01:30.609]                 }
[11:01:30.609]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.609]                 "immediateCondition"))) {
[11:01:30.609]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.609]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.609]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.609]                   if (TRUE && !signal) {
[11:01:30.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.609]                     {
[11:01:30.609]                       inherits <- base::inherits
[11:01:30.609]                       invokeRestart <- base::invokeRestart
[11:01:30.609]                       is.null <- base::is.null
[11:01:30.609]                       muffled <- FALSE
[11:01:30.609]                       if (inherits(cond, "message")) {
[11:01:30.609]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.609]                         if (muffled) 
[11:01:30.609]                           invokeRestart("muffleMessage")
[11:01:30.609]                       }
[11:01:30.609]                       else if (inherits(cond, "warning")) {
[11:01:30.609]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.609]                         if (muffled) 
[11:01:30.609]                           invokeRestart("muffleWarning")
[11:01:30.609]                       }
[11:01:30.609]                       else if (inherits(cond, "condition")) {
[11:01:30.609]                         if (!is.null(pattern)) {
[11:01:30.609]                           computeRestarts <- base::computeRestarts
[11:01:30.609]                           grepl <- base::grepl
[11:01:30.609]                           restarts <- computeRestarts(cond)
[11:01:30.609]                           for (restart in restarts) {
[11:01:30.609]                             name <- restart$name
[11:01:30.609]                             if (is.null(name)) 
[11:01:30.609]                               next
[11:01:30.609]                             if (!grepl(pattern, name)) 
[11:01:30.609]                               next
[11:01:30.609]                             invokeRestart(restart)
[11:01:30.609]                             muffled <- TRUE
[11:01:30.609]                             break
[11:01:30.609]                           }
[11:01:30.609]                         }
[11:01:30.609]                       }
[11:01:30.609]                       invisible(muffled)
[11:01:30.609]                     }
[11:01:30.609]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.609]                   }
[11:01:30.609]                 }
[11:01:30.609]                 else {
[11:01:30.609]                   if (TRUE) {
[11:01:30.609]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.609]                     {
[11:01:30.609]                       inherits <- base::inherits
[11:01:30.609]                       invokeRestart <- base::invokeRestart
[11:01:30.609]                       is.null <- base::is.null
[11:01:30.609]                       muffled <- FALSE
[11:01:30.609]                       if (inherits(cond, "message")) {
[11:01:30.609]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.609]                         if (muffled) 
[11:01:30.609]                           invokeRestart("muffleMessage")
[11:01:30.609]                       }
[11:01:30.609]                       else if (inherits(cond, "warning")) {
[11:01:30.609]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.609]                         if (muffled) 
[11:01:30.609]                           invokeRestart("muffleWarning")
[11:01:30.609]                       }
[11:01:30.609]                       else if (inherits(cond, "condition")) {
[11:01:30.609]                         if (!is.null(pattern)) {
[11:01:30.609]                           computeRestarts <- base::computeRestarts
[11:01:30.609]                           grepl <- base::grepl
[11:01:30.609]                           restarts <- computeRestarts(cond)
[11:01:30.609]                           for (restart in restarts) {
[11:01:30.609]                             name <- restart$name
[11:01:30.609]                             if (is.null(name)) 
[11:01:30.609]                               next
[11:01:30.609]                             if (!grepl(pattern, name)) 
[11:01:30.609]                               next
[11:01:30.609]                             invokeRestart(restart)
[11:01:30.609]                             muffled <- TRUE
[11:01:30.609]                             break
[11:01:30.609]                           }
[11:01:30.609]                         }
[11:01:30.609]                       }
[11:01:30.609]                       invisible(muffled)
[11:01:30.609]                     }
[11:01:30.609]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.609]                   }
[11:01:30.609]                 }
[11:01:30.609]             }
[11:01:30.609]         }))
[11:01:30.609]     }, error = function(ex) {
[11:01:30.609]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.609]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.609]                 ...future.rng), started = ...future.startTime, 
[11:01:30.609]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.609]             version = "1.8"), class = "FutureResult")
[11:01:30.609]     }, finally = {
[11:01:30.609]         if (!identical(...future.workdir, getwd())) 
[11:01:30.609]             setwd(...future.workdir)
[11:01:30.609]         {
[11:01:30.609]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.609]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.609]             }
[11:01:30.609]             base::options(...future.oldOptions)
[11:01:30.609]             if (.Platform$OS.type == "windows") {
[11:01:30.609]                 old_names <- names(...future.oldEnvVars)
[11:01:30.609]                 envs <- base::Sys.getenv()
[11:01:30.609]                 names <- names(envs)
[11:01:30.609]                 common <- intersect(names, old_names)
[11:01:30.609]                 added <- setdiff(names, old_names)
[11:01:30.609]                 removed <- setdiff(old_names, names)
[11:01:30.609]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.609]                   envs[common]]
[11:01:30.609]                 NAMES <- toupper(changed)
[11:01:30.609]                 args <- list()
[11:01:30.609]                 for (kk in seq_along(NAMES)) {
[11:01:30.609]                   name <- changed[[kk]]
[11:01:30.609]                   NAME <- NAMES[[kk]]
[11:01:30.609]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.609]                     next
[11:01:30.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.609]                 }
[11:01:30.609]                 NAMES <- toupper(added)
[11:01:30.609]                 for (kk in seq_along(NAMES)) {
[11:01:30.609]                   name <- added[[kk]]
[11:01:30.609]                   NAME <- NAMES[[kk]]
[11:01:30.609]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.609]                     next
[11:01:30.609]                   args[[name]] <- ""
[11:01:30.609]                 }
[11:01:30.609]                 NAMES <- toupper(removed)
[11:01:30.609]                 for (kk in seq_along(NAMES)) {
[11:01:30.609]                   name <- removed[[kk]]
[11:01:30.609]                   NAME <- NAMES[[kk]]
[11:01:30.609]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.609]                     next
[11:01:30.609]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.609]                 }
[11:01:30.609]                 if (length(args) > 0) 
[11:01:30.609]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.609]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.609]             }
[11:01:30.609]             else {
[11:01:30.609]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.609]             }
[11:01:30.609]             {
[11:01:30.609]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.609]                   0L) {
[11:01:30.609]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.609]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.609]                   base::options(opts)
[11:01:30.609]                 }
[11:01:30.609]                 {
[11:01:30.609]                   {
[11:01:30.609]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.609]                     NULL
[11:01:30.609]                   }
[11:01:30.609]                   options(future.plan = NULL)
[11:01:30.609]                   if (is.na(NA_character_)) 
[11:01:30.609]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.609]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.609]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.609]                     .init = FALSE)
[11:01:30.609]                 }
[11:01:30.609]             }
[11:01:30.609]         }
[11:01:30.609]     })
[11:01:30.609]     if (TRUE) {
[11:01:30.609]         base::sink(type = "output", split = FALSE)
[11:01:30.609]         if (TRUE) {
[11:01:30.609]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.609]         }
[11:01:30.609]         else {
[11:01:30.609]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.609]         }
[11:01:30.609]         base::close(...future.stdout)
[11:01:30.609]         ...future.stdout <- NULL
[11:01:30.609]     }
[11:01:30.609]     ...future.result$conditions <- ...future.conditions
[11:01:30.609]     ...future.result$finished <- base::Sys.time()
[11:01:30.609]     ...future.result
[11:01:30.609] }
[11:01:30.612] requestCore(): workers = 2
[11:01:30.614] MulticoreFuture started
[11:01:30.615] - Launch lazy future ... done
[11:01:30.615] run() for ‘MulticoreFuture’ ... done
[11:01:30.615] getGlobalsAndPackages() ...
[11:01:30.615] Searching for globals...
[11:01:30.615] plan(): Setting new future strategy stack:
[11:01:30.616] 
[11:01:30.615] List of future strategies:
[11:01:30.615] 1. sequential:
[11:01:30.615]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.615]    - tweaked: FALSE
[11:01:30.615]    - call: NULL
[11:01:30.616] Searching for globals ... DONE
[11:01:30.616] plan(): nbrOfWorkers() = 1
[11:01:30.616] - globals: [0] <none>
[11:01:30.617] getGlobalsAndPackages() ... DONE
[11:01:30.617] run() for ‘Future’ ...
[11:01:30.617] - state: ‘created’
[11:01:30.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.618] plan(): Setting new future strategy stack:
[11:01:30.619] List of future strategies:
[11:01:30.619] 1. multicore:
[11:01:30.619]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.619]    - tweaked: FALSE
[11:01:30.619]    - call: plan(strategy)
[11:01:30.621] plan(): nbrOfWorkers() = 2
[11:01:30.621] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.622]   - Field: ‘label’
[11:01:30.622]   - Field: ‘local’
[11:01:30.622]   - Field: ‘owner’
[11:01:30.622]   - Field: ‘envir’
[11:01:30.622]   - Field: ‘workers’
[11:01:30.623]   - Field: ‘packages’
[11:01:30.623]   - Field: ‘gc’
[11:01:30.623]   - Field: ‘job’
[11:01:30.623]   - Field: ‘conditions’
[11:01:30.623]   - Field: ‘expr’
[11:01:30.623]   - Field: ‘uuid’
[11:01:30.623]   - Field: ‘seed’
[11:01:30.624]   - Field: ‘version’
[11:01:30.624]   - Field: ‘result’
[11:01:30.624]   - Field: ‘asynchronous’
[11:01:30.624]   - Field: ‘calls’
[11:01:30.624]   - Field: ‘globals’
[11:01:30.624]   - Field: ‘stdout’
[11:01:30.624]   - Field: ‘earlySignal’
[11:01:30.624]   - Field: ‘lazy’
[11:01:30.625]   - Field: ‘state’
[11:01:30.625] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.625] - Launch lazy future ...
[11:01:30.625] Packages needed by the future expression (n = 0): <none>
[11:01:30.626] Packages needed by future strategies (n = 0): <none>
[11:01:30.626] {
[11:01:30.626]     {
[11:01:30.626]         {
[11:01:30.626]             ...future.startTime <- base::Sys.time()
[11:01:30.626]             {
[11:01:30.626]                 {
[11:01:30.626]                   {
[11:01:30.626]                     {
[11:01:30.626]                       base::local({
[11:01:30.626]                         has_future <- base::requireNamespace("future", 
[11:01:30.626]                           quietly = TRUE)
[11:01:30.626]                         if (has_future) {
[11:01:30.626]                           ns <- base::getNamespace("future")
[11:01:30.626]                           version <- ns[[".package"]][["version"]]
[11:01:30.626]                           if (is.null(version)) 
[11:01:30.626]                             version <- utils::packageVersion("future")
[11:01:30.626]                         }
[11:01:30.626]                         else {
[11:01:30.626]                           version <- NULL
[11:01:30.626]                         }
[11:01:30.626]                         if (!has_future || version < "1.8.0") {
[11:01:30.626]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.626]                             "", base::R.version$version.string), 
[11:01:30.626]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.626]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.626]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.626]                               "release", "version")], collapse = " "), 
[11:01:30.626]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.626]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.626]                             info)
[11:01:30.626]                           info <- base::paste(info, collapse = "; ")
[11:01:30.626]                           if (!has_future) {
[11:01:30.626]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.626]                               info)
[11:01:30.626]                           }
[11:01:30.626]                           else {
[11:01:30.626]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.626]                               info, version)
[11:01:30.626]                           }
[11:01:30.626]                           base::stop(msg)
[11:01:30.626]                         }
[11:01:30.626]                       })
[11:01:30.626]                     }
[11:01:30.626]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.626]                     base::options(mc.cores = 1L)
[11:01:30.626]                   }
[11:01:30.626]                   ...future.strategy.old <- future::plan("list")
[11:01:30.626]                   options(future.plan = NULL)
[11:01:30.626]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.626]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.626]                 }
[11:01:30.626]                 ...future.workdir <- getwd()
[11:01:30.626]             }
[11:01:30.626]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.626]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.626]         }
[11:01:30.626]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.626]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.626]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.626]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.626]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.626]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.626]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.626]             base::names(...future.oldOptions))
[11:01:30.626]     }
[11:01:30.626]     if (FALSE) {
[11:01:30.626]     }
[11:01:30.626]     else {
[11:01:30.626]         if (TRUE) {
[11:01:30.626]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.626]                 open = "w")
[11:01:30.626]         }
[11:01:30.626]         else {
[11:01:30.626]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.626]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.626]         }
[11:01:30.626]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.626]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.626]             base::sink(type = "output", split = FALSE)
[11:01:30.626]             base::close(...future.stdout)
[11:01:30.626]         }, add = TRUE)
[11:01:30.626]     }
[11:01:30.626]     ...future.frame <- base::sys.nframe()
[11:01:30.626]     ...future.conditions <- base::list()
[11:01:30.626]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.626]     if (FALSE) {
[11:01:30.626]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.626]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.626]     }
[11:01:30.626]     ...future.result <- base::tryCatch({
[11:01:30.626]         base::withCallingHandlers({
[11:01:30.626]             ...future.value <- base::withVisible(base::local({
[11:01:30.626]                 withCallingHandlers({
[11:01:30.626]                   NULL
[11:01:30.626]                 }, immediateCondition = function(cond) {
[11:01:30.626]                   save_rds <- function (object, pathname, ...) 
[11:01:30.626]                   {
[11:01:30.626]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.626]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.626]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.626]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.626]                         fi_tmp[["mtime"]])
[11:01:30.626]                     }
[11:01:30.626]                     tryCatch({
[11:01:30.626]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.626]                     }, error = function(ex) {
[11:01:30.626]                       msg <- conditionMessage(ex)
[11:01:30.626]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.626]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.626]                         fi_tmp[["mtime"]], msg)
[11:01:30.626]                       ex$message <- msg
[11:01:30.626]                       stop(ex)
[11:01:30.626]                     })
[11:01:30.626]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.626]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.626]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.626]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.626]                       fi <- file.info(pathname)
[11:01:30.626]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.626]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.626]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.626]                         fi[["size"]], fi[["mtime"]])
[11:01:30.626]                       stop(msg)
[11:01:30.626]                     }
[11:01:30.626]                     invisible(pathname)
[11:01:30.626]                   }
[11:01:30.626]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.626]                     rootPath = tempdir()) 
[11:01:30.626]                   {
[11:01:30.626]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.626]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.626]                       tmpdir = path, fileext = ".rds")
[11:01:30.626]                     save_rds(obj, file)
[11:01:30.626]                   }
[11:01:30.626]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.626]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.626]                   {
[11:01:30.626]                     inherits <- base::inherits
[11:01:30.626]                     invokeRestart <- base::invokeRestart
[11:01:30.626]                     is.null <- base::is.null
[11:01:30.626]                     muffled <- FALSE
[11:01:30.626]                     if (inherits(cond, "message")) {
[11:01:30.626]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.626]                       if (muffled) 
[11:01:30.626]                         invokeRestart("muffleMessage")
[11:01:30.626]                     }
[11:01:30.626]                     else if (inherits(cond, "warning")) {
[11:01:30.626]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.626]                       if (muffled) 
[11:01:30.626]                         invokeRestart("muffleWarning")
[11:01:30.626]                     }
[11:01:30.626]                     else if (inherits(cond, "condition")) {
[11:01:30.626]                       if (!is.null(pattern)) {
[11:01:30.626]                         computeRestarts <- base::computeRestarts
[11:01:30.626]                         grepl <- base::grepl
[11:01:30.626]                         restarts <- computeRestarts(cond)
[11:01:30.626]                         for (restart in restarts) {
[11:01:30.626]                           name <- restart$name
[11:01:30.626]                           if (is.null(name)) 
[11:01:30.626]                             next
[11:01:30.626]                           if (!grepl(pattern, name)) 
[11:01:30.626]                             next
[11:01:30.626]                           invokeRestart(restart)
[11:01:30.626]                           muffled <- TRUE
[11:01:30.626]                           break
[11:01:30.626]                         }
[11:01:30.626]                       }
[11:01:30.626]                     }
[11:01:30.626]                     invisible(muffled)
[11:01:30.626]                   }
[11:01:30.626]                   muffleCondition(cond)
[11:01:30.626]                 })
[11:01:30.626]             }))
[11:01:30.626]             future::FutureResult(value = ...future.value$value, 
[11:01:30.626]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.626]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.626]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.626]                     ...future.globalenv.names))
[11:01:30.626]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.626]         }, condition = base::local({
[11:01:30.626]             c <- base::c
[11:01:30.626]             inherits <- base::inherits
[11:01:30.626]             invokeRestart <- base::invokeRestart
[11:01:30.626]             length <- base::length
[11:01:30.626]             list <- base::list
[11:01:30.626]             seq.int <- base::seq.int
[11:01:30.626]             signalCondition <- base::signalCondition
[11:01:30.626]             sys.calls <- base::sys.calls
[11:01:30.626]             `[[` <- base::`[[`
[11:01:30.626]             `+` <- base::`+`
[11:01:30.626]             `<<-` <- base::`<<-`
[11:01:30.626]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.626]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.626]                   3L)]
[11:01:30.626]             }
[11:01:30.626]             function(cond) {
[11:01:30.626]                 is_error <- inherits(cond, "error")
[11:01:30.626]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.626]                   NULL)
[11:01:30.626]                 if (is_error) {
[11:01:30.626]                   sessionInformation <- function() {
[11:01:30.626]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.626]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.626]                       search = base::search(), system = base::Sys.info())
[11:01:30.626]                   }
[11:01:30.626]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.626]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.626]                     cond$call), session = sessionInformation(), 
[11:01:30.626]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.626]                   signalCondition(cond)
[11:01:30.626]                 }
[11:01:30.626]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.626]                 "immediateCondition"))) {
[11:01:30.626]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.626]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.626]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.626]                   if (TRUE && !signal) {
[11:01:30.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.626]                     {
[11:01:30.626]                       inherits <- base::inherits
[11:01:30.626]                       invokeRestart <- base::invokeRestart
[11:01:30.626]                       is.null <- base::is.null
[11:01:30.626]                       muffled <- FALSE
[11:01:30.626]                       if (inherits(cond, "message")) {
[11:01:30.626]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.626]                         if (muffled) 
[11:01:30.626]                           invokeRestart("muffleMessage")
[11:01:30.626]                       }
[11:01:30.626]                       else if (inherits(cond, "warning")) {
[11:01:30.626]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.626]                         if (muffled) 
[11:01:30.626]                           invokeRestart("muffleWarning")
[11:01:30.626]                       }
[11:01:30.626]                       else if (inherits(cond, "condition")) {
[11:01:30.626]                         if (!is.null(pattern)) {
[11:01:30.626]                           computeRestarts <- base::computeRestarts
[11:01:30.626]                           grepl <- base::grepl
[11:01:30.626]                           restarts <- computeRestarts(cond)
[11:01:30.626]                           for (restart in restarts) {
[11:01:30.626]                             name <- restart$name
[11:01:30.626]                             if (is.null(name)) 
[11:01:30.626]                               next
[11:01:30.626]                             if (!grepl(pattern, name)) 
[11:01:30.626]                               next
[11:01:30.626]                             invokeRestart(restart)
[11:01:30.626]                             muffled <- TRUE
[11:01:30.626]                             break
[11:01:30.626]                           }
[11:01:30.626]                         }
[11:01:30.626]                       }
[11:01:30.626]                       invisible(muffled)
[11:01:30.626]                     }
[11:01:30.626]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.626]                   }
[11:01:30.626]                 }
[11:01:30.626]                 else {
[11:01:30.626]                   if (TRUE) {
[11:01:30.626]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.626]                     {
[11:01:30.626]                       inherits <- base::inherits
[11:01:30.626]                       invokeRestart <- base::invokeRestart
[11:01:30.626]                       is.null <- base::is.null
[11:01:30.626]                       muffled <- FALSE
[11:01:30.626]                       if (inherits(cond, "message")) {
[11:01:30.626]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.626]                         if (muffled) 
[11:01:30.626]                           invokeRestart("muffleMessage")
[11:01:30.626]                       }
[11:01:30.626]                       else if (inherits(cond, "warning")) {
[11:01:30.626]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.626]                         if (muffled) 
[11:01:30.626]                           invokeRestart("muffleWarning")
[11:01:30.626]                       }
[11:01:30.626]                       else if (inherits(cond, "condition")) {
[11:01:30.626]                         if (!is.null(pattern)) {
[11:01:30.626]                           computeRestarts <- base::computeRestarts
[11:01:30.626]                           grepl <- base::grepl
[11:01:30.626]                           restarts <- computeRestarts(cond)
[11:01:30.626]                           for (restart in restarts) {
[11:01:30.626]                             name <- restart$name
[11:01:30.626]                             if (is.null(name)) 
[11:01:30.626]                               next
[11:01:30.626]                             if (!grepl(pattern, name)) 
[11:01:30.626]                               next
[11:01:30.626]                             invokeRestart(restart)
[11:01:30.626]                             muffled <- TRUE
[11:01:30.626]                             break
[11:01:30.626]                           }
[11:01:30.626]                         }
[11:01:30.626]                       }
[11:01:30.626]                       invisible(muffled)
[11:01:30.626]                     }
[11:01:30.626]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.626]                   }
[11:01:30.626]                 }
[11:01:30.626]             }
[11:01:30.626]         }))
[11:01:30.626]     }, error = function(ex) {
[11:01:30.626]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.626]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.626]                 ...future.rng), started = ...future.startTime, 
[11:01:30.626]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.626]             version = "1.8"), class = "FutureResult")
[11:01:30.626]     }, finally = {
[11:01:30.626]         if (!identical(...future.workdir, getwd())) 
[11:01:30.626]             setwd(...future.workdir)
[11:01:30.626]         {
[11:01:30.626]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.626]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.626]             }
[11:01:30.626]             base::options(...future.oldOptions)
[11:01:30.626]             if (.Platform$OS.type == "windows") {
[11:01:30.626]                 old_names <- names(...future.oldEnvVars)
[11:01:30.626]                 envs <- base::Sys.getenv()
[11:01:30.626]                 names <- names(envs)
[11:01:30.626]                 common <- intersect(names, old_names)
[11:01:30.626]                 added <- setdiff(names, old_names)
[11:01:30.626]                 removed <- setdiff(old_names, names)
[11:01:30.626]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.626]                   envs[common]]
[11:01:30.626]                 NAMES <- toupper(changed)
[11:01:30.626]                 args <- list()
[11:01:30.626]                 for (kk in seq_along(NAMES)) {
[11:01:30.626]                   name <- changed[[kk]]
[11:01:30.626]                   NAME <- NAMES[[kk]]
[11:01:30.626]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.626]                     next
[11:01:30.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.626]                 }
[11:01:30.626]                 NAMES <- toupper(added)
[11:01:30.626]                 for (kk in seq_along(NAMES)) {
[11:01:30.626]                   name <- added[[kk]]
[11:01:30.626]                   NAME <- NAMES[[kk]]
[11:01:30.626]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.626]                     next
[11:01:30.626]                   args[[name]] <- ""
[11:01:30.626]                 }
[11:01:30.626]                 NAMES <- toupper(removed)
[11:01:30.626]                 for (kk in seq_along(NAMES)) {
[11:01:30.626]                   name <- removed[[kk]]
[11:01:30.626]                   NAME <- NAMES[[kk]]
[11:01:30.626]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.626]                     next
[11:01:30.626]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.626]                 }
[11:01:30.626]                 if (length(args) > 0) 
[11:01:30.626]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.626]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.626]             }
[11:01:30.626]             else {
[11:01:30.626]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.626]             }
[11:01:30.626]             {
[11:01:30.626]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.626]                   0L) {
[11:01:30.626]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.626]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.626]                   base::options(opts)
[11:01:30.626]                 }
[11:01:30.626]                 {
[11:01:30.626]                   {
[11:01:30.626]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.626]                     NULL
[11:01:30.626]                   }
[11:01:30.626]                   options(future.plan = NULL)
[11:01:30.626]                   if (is.na(NA_character_)) 
[11:01:30.626]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.626]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.626]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.626]                     .init = FALSE)
[11:01:30.626]                 }
[11:01:30.626]             }
[11:01:30.626]         }
[11:01:30.626]     })
[11:01:30.626]     if (TRUE) {
[11:01:30.626]         base::sink(type = "output", split = FALSE)
[11:01:30.626]         if (TRUE) {
[11:01:30.626]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.626]         }
[11:01:30.626]         else {
[11:01:30.626]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.626]         }
[11:01:30.626]         base::close(...future.stdout)
[11:01:30.626]         ...future.stdout <- NULL
[11:01:30.626]     }
[11:01:30.626]     ...future.result$conditions <- ...future.conditions
[11:01:30.626]     ...future.result$finished <- base::Sys.time()
[11:01:30.626]     ...future.result
[11:01:30.626] }
[11:01:30.630] requestCore(): workers = 2
[11:01:30.632] MulticoreFuture started
[11:01:30.633] - Launch lazy future ... done
[11:01:30.633] run() for ‘MulticoreFuture’ ... done
[11:01:30.633] plan(): Setting new future strategy stack:
[11:01:30.634] getGlobalsAndPackages() ...
[11:01:30.634] Searching for globals...
[11:01:30.634] List of future strategies:
[11:01:30.634] 1. sequential:
[11:01:30.634]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.634]    - tweaked: FALSE
[11:01:30.634]    - call: NULL
[11:01:30.635] plan(): nbrOfWorkers() = 1
[11:01:30.635] - globals found: [1] ‘{’
[11:01:30.635] Searching for globals ... DONE
[11:01:30.635] Resolving globals: FALSE
[11:01:30.636] 
[11:01:30.636] 
[11:01:30.636] getGlobalsAndPackages() ... DONE
[11:01:30.637] plan(): Setting new future strategy stack:
[11:01:30.637] run() for ‘Future’ ...
[11:01:30.637] - state: ‘created’
[11:01:30.637] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.637] List of future strategies:
[11:01:30.637] 1. multicore:
[11:01:30.637]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.637]    - tweaked: FALSE
[11:01:30.637]    - call: plan(strategy)
[11:01:30.640] plan(): nbrOfWorkers() = 2
[11:01:30.640] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.640] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.640]   - Field: ‘label’
[11:01:30.640]   - Field: ‘local’
[11:01:30.641]   - Field: ‘owner’
[11:01:30.641]   - Field: ‘envir’
[11:01:30.641]   - Field: ‘workers’
[11:01:30.641]   - Field: ‘packages’
[11:01:30.641]   - Field: ‘gc’
[11:01:30.641]   - Field: ‘job’
[11:01:30.641]   - Field: ‘conditions’
[11:01:30.642]   - Field: ‘expr’
[11:01:30.642]   - Field: ‘uuid’
[11:01:30.642]   - Field: ‘seed’
[11:01:30.642]   - Field: ‘version’
[11:01:30.642]   - Field: ‘result’
[11:01:30.642]   - Field: ‘asynchronous’
[11:01:30.642]   - Field: ‘calls’
[11:01:30.642]   - Field: ‘globals’
[11:01:30.642]   - Field: ‘stdout’
[11:01:30.643]   - Field: ‘earlySignal’
[11:01:30.643]   - Field: ‘lazy’
[11:01:30.643]   - Field: ‘state’
[11:01:30.643] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.643] - Launch lazy future ...
[11:01:30.644] Packages needed by the future expression (n = 0): <none>
[11:01:30.644] Packages needed by future strategies (n = 0): <none>
[11:01:30.644] {
[11:01:30.644]     {
[11:01:30.644]         {
[11:01:30.644]             ...future.startTime <- base::Sys.time()
[11:01:30.644]             {
[11:01:30.644]                 {
[11:01:30.644]                   {
[11:01:30.644]                     {
[11:01:30.644]                       base::local({
[11:01:30.644]                         has_future <- base::requireNamespace("future", 
[11:01:30.644]                           quietly = TRUE)
[11:01:30.644]                         if (has_future) {
[11:01:30.644]                           ns <- base::getNamespace("future")
[11:01:30.644]                           version <- ns[[".package"]][["version"]]
[11:01:30.644]                           if (is.null(version)) 
[11:01:30.644]                             version <- utils::packageVersion("future")
[11:01:30.644]                         }
[11:01:30.644]                         else {
[11:01:30.644]                           version <- NULL
[11:01:30.644]                         }
[11:01:30.644]                         if (!has_future || version < "1.8.0") {
[11:01:30.644]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.644]                             "", base::R.version$version.string), 
[11:01:30.644]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.644]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.644]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.644]                               "release", "version")], collapse = " "), 
[11:01:30.644]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.644]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.644]                             info)
[11:01:30.644]                           info <- base::paste(info, collapse = "; ")
[11:01:30.644]                           if (!has_future) {
[11:01:30.644]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.644]                               info)
[11:01:30.644]                           }
[11:01:30.644]                           else {
[11:01:30.644]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.644]                               info, version)
[11:01:30.644]                           }
[11:01:30.644]                           base::stop(msg)
[11:01:30.644]                         }
[11:01:30.644]                       })
[11:01:30.644]                     }
[11:01:30.644]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.644]                     base::options(mc.cores = 1L)
[11:01:30.644]                   }
[11:01:30.644]                   ...future.strategy.old <- future::plan("list")
[11:01:30.644]                   options(future.plan = NULL)
[11:01:30.644]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.644]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.644]                 }
[11:01:30.644]                 ...future.workdir <- getwd()
[11:01:30.644]             }
[11:01:30.644]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.644]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.644]         }
[11:01:30.644]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.644]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.644]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.644]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.644]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.644]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.644]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.644]             base::names(...future.oldOptions))
[11:01:30.644]     }
[11:01:30.644]     if (FALSE) {
[11:01:30.644]     }
[11:01:30.644]     else {
[11:01:30.644]         if (TRUE) {
[11:01:30.644]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.644]                 open = "w")
[11:01:30.644]         }
[11:01:30.644]         else {
[11:01:30.644]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.644]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.644]         }
[11:01:30.644]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.644]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.644]             base::sink(type = "output", split = FALSE)
[11:01:30.644]             base::close(...future.stdout)
[11:01:30.644]         }, add = TRUE)
[11:01:30.644]     }
[11:01:30.644]     ...future.frame <- base::sys.nframe()
[11:01:30.644]     ...future.conditions <- base::list()
[11:01:30.644]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.644]     if (FALSE) {
[11:01:30.644]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.644]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.644]     }
[11:01:30.644]     ...future.result <- base::tryCatch({
[11:01:30.644]         base::withCallingHandlers({
[11:01:30.644]             ...future.value <- base::withVisible(base::local({
[11:01:30.644]                 withCallingHandlers({
[11:01:30.644]                   {
[11:01:30.644]                     4
[11:01:30.644]                   }
[11:01:30.644]                 }, immediateCondition = function(cond) {
[11:01:30.644]                   save_rds <- function (object, pathname, ...) 
[11:01:30.644]                   {
[11:01:30.644]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.644]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.644]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.644]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.644]                         fi_tmp[["mtime"]])
[11:01:30.644]                     }
[11:01:30.644]                     tryCatch({
[11:01:30.644]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.644]                     }, error = function(ex) {
[11:01:30.644]                       msg <- conditionMessage(ex)
[11:01:30.644]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.644]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.644]                         fi_tmp[["mtime"]], msg)
[11:01:30.644]                       ex$message <- msg
[11:01:30.644]                       stop(ex)
[11:01:30.644]                     })
[11:01:30.644]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.644]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.644]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.644]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.644]                       fi <- file.info(pathname)
[11:01:30.644]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.644]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.644]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.644]                         fi[["size"]], fi[["mtime"]])
[11:01:30.644]                       stop(msg)
[11:01:30.644]                     }
[11:01:30.644]                     invisible(pathname)
[11:01:30.644]                   }
[11:01:30.644]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.644]                     rootPath = tempdir()) 
[11:01:30.644]                   {
[11:01:30.644]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.644]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.644]                       tmpdir = path, fileext = ".rds")
[11:01:30.644]                     save_rds(obj, file)
[11:01:30.644]                   }
[11:01:30.644]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.644]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.644]                   {
[11:01:30.644]                     inherits <- base::inherits
[11:01:30.644]                     invokeRestart <- base::invokeRestart
[11:01:30.644]                     is.null <- base::is.null
[11:01:30.644]                     muffled <- FALSE
[11:01:30.644]                     if (inherits(cond, "message")) {
[11:01:30.644]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.644]                       if (muffled) 
[11:01:30.644]                         invokeRestart("muffleMessage")
[11:01:30.644]                     }
[11:01:30.644]                     else if (inherits(cond, "warning")) {
[11:01:30.644]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.644]                       if (muffled) 
[11:01:30.644]                         invokeRestart("muffleWarning")
[11:01:30.644]                     }
[11:01:30.644]                     else if (inherits(cond, "condition")) {
[11:01:30.644]                       if (!is.null(pattern)) {
[11:01:30.644]                         computeRestarts <- base::computeRestarts
[11:01:30.644]                         grepl <- base::grepl
[11:01:30.644]                         restarts <- computeRestarts(cond)
[11:01:30.644]                         for (restart in restarts) {
[11:01:30.644]                           name <- restart$name
[11:01:30.644]                           if (is.null(name)) 
[11:01:30.644]                             next
[11:01:30.644]                           if (!grepl(pattern, name)) 
[11:01:30.644]                             next
[11:01:30.644]                           invokeRestart(restart)
[11:01:30.644]                           muffled <- TRUE
[11:01:30.644]                           break
[11:01:30.644]                         }
[11:01:30.644]                       }
[11:01:30.644]                     }
[11:01:30.644]                     invisible(muffled)
[11:01:30.644]                   }
[11:01:30.644]                   muffleCondition(cond)
[11:01:30.644]                 })
[11:01:30.644]             }))
[11:01:30.644]             future::FutureResult(value = ...future.value$value, 
[11:01:30.644]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.644]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.644]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.644]                     ...future.globalenv.names))
[11:01:30.644]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.644]         }, condition = base::local({
[11:01:30.644]             c <- base::c
[11:01:30.644]             inherits <- base::inherits
[11:01:30.644]             invokeRestart <- base::invokeRestart
[11:01:30.644]             length <- base::length
[11:01:30.644]             list <- base::list
[11:01:30.644]             seq.int <- base::seq.int
[11:01:30.644]             signalCondition <- base::signalCondition
[11:01:30.644]             sys.calls <- base::sys.calls
[11:01:30.644]             `[[` <- base::`[[`
[11:01:30.644]             `+` <- base::`+`
[11:01:30.644]             `<<-` <- base::`<<-`
[11:01:30.644]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.644]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.644]                   3L)]
[11:01:30.644]             }
[11:01:30.644]             function(cond) {
[11:01:30.644]                 is_error <- inherits(cond, "error")
[11:01:30.644]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.644]                   NULL)
[11:01:30.644]                 if (is_error) {
[11:01:30.644]                   sessionInformation <- function() {
[11:01:30.644]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.644]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.644]                       search = base::search(), system = base::Sys.info())
[11:01:30.644]                   }
[11:01:30.644]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.644]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.644]                     cond$call), session = sessionInformation(), 
[11:01:30.644]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.644]                   signalCondition(cond)
[11:01:30.644]                 }
[11:01:30.644]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.644]                 "immediateCondition"))) {
[11:01:30.644]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.644]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.644]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.644]                   if (TRUE && !signal) {
[11:01:30.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.644]                     {
[11:01:30.644]                       inherits <- base::inherits
[11:01:30.644]                       invokeRestart <- base::invokeRestart
[11:01:30.644]                       is.null <- base::is.null
[11:01:30.644]                       muffled <- FALSE
[11:01:30.644]                       if (inherits(cond, "message")) {
[11:01:30.644]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.644]                         if (muffled) 
[11:01:30.644]                           invokeRestart("muffleMessage")
[11:01:30.644]                       }
[11:01:30.644]                       else if (inherits(cond, "warning")) {
[11:01:30.644]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.644]                         if (muffled) 
[11:01:30.644]                           invokeRestart("muffleWarning")
[11:01:30.644]                       }
[11:01:30.644]                       else if (inherits(cond, "condition")) {
[11:01:30.644]                         if (!is.null(pattern)) {
[11:01:30.644]                           computeRestarts <- base::computeRestarts
[11:01:30.644]                           grepl <- base::grepl
[11:01:30.644]                           restarts <- computeRestarts(cond)
[11:01:30.644]                           for (restart in restarts) {
[11:01:30.644]                             name <- restart$name
[11:01:30.644]                             if (is.null(name)) 
[11:01:30.644]                               next
[11:01:30.644]                             if (!grepl(pattern, name)) 
[11:01:30.644]                               next
[11:01:30.644]                             invokeRestart(restart)
[11:01:30.644]                             muffled <- TRUE
[11:01:30.644]                             break
[11:01:30.644]                           }
[11:01:30.644]                         }
[11:01:30.644]                       }
[11:01:30.644]                       invisible(muffled)
[11:01:30.644]                     }
[11:01:30.644]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.644]                   }
[11:01:30.644]                 }
[11:01:30.644]                 else {
[11:01:30.644]                   if (TRUE) {
[11:01:30.644]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.644]                     {
[11:01:30.644]                       inherits <- base::inherits
[11:01:30.644]                       invokeRestart <- base::invokeRestart
[11:01:30.644]                       is.null <- base::is.null
[11:01:30.644]                       muffled <- FALSE
[11:01:30.644]                       if (inherits(cond, "message")) {
[11:01:30.644]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.644]                         if (muffled) 
[11:01:30.644]                           invokeRestart("muffleMessage")
[11:01:30.644]                       }
[11:01:30.644]                       else if (inherits(cond, "warning")) {
[11:01:30.644]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.644]                         if (muffled) 
[11:01:30.644]                           invokeRestart("muffleWarning")
[11:01:30.644]                       }
[11:01:30.644]                       else if (inherits(cond, "condition")) {
[11:01:30.644]                         if (!is.null(pattern)) {
[11:01:30.644]                           computeRestarts <- base::computeRestarts
[11:01:30.644]                           grepl <- base::grepl
[11:01:30.644]                           restarts <- computeRestarts(cond)
[11:01:30.644]                           for (restart in restarts) {
[11:01:30.644]                             name <- restart$name
[11:01:30.644]                             if (is.null(name)) 
[11:01:30.644]                               next
[11:01:30.644]                             if (!grepl(pattern, name)) 
[11:01:30.644]                               next
[11:01:30.644]                             invokeRestart(restart)
[11:01:30.644]                             muffled <- TRUE
[11:01:30.644]                             break
[11:01:30.644]                           }
[11:01:30.644]                         }
[11:01:30.644]                       }
[11:01:30.644]                       invisible(muffled)
[11:01:30.644]                     }
[11:01:30.644]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.644]                   }
[11:01:30.644]                 }
[11:01:30.644]             }
[11:01:30.644]         }))
[11:01:30.644]     }, error = function(ex) {
[11:01:30.644]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.644]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.644]                 ...future.rng), started = ...future.startTime, 
[11:01:30.644]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.644]             version = "1.8"), class = "FutureResult")
[11:01:30.644]     }, finally = {
[11:01:30.644]         if (!identical(...future.workdir, getwd())) 
[11:01:30.644]             setwd(...future.workdir)
[11:01:30.644]         {
[11:01:30.644]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.644]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.644]             }
[11:01:30.644]             base::options(...future.oldOptions)
[11:01:30.644]             if (.Platform$OS.type == "windows") {
[11:01:30.644]                 old_names <- names(...future.oldEnvVars)
[11:01:30.644]                 envs <- base::Sys.getenv()
[11:01:30.644]                 names <- names(envs)
[11:01:30.644]                 common <- intersect(names, old_names)
[11:01:30.644]                 added <- setdiff(names, old_names)
[11:01:30.644]                 removed <- setdiff(old_names, names)
[11:01:30.644]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.644]                   envs[common]]
[11:01:30.644]                 NAMES <- toupper(changed)
[11:01:30.644]                 args <- list()
[11:01:30.644]                 for (kk in seq_along(NAMES)) {
[11:01:30.644]                   name <- changed[[kk]]
[11:01:30.644]                   NAME <- NAMES[[kk]]
[11:01:30.644]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.644]                     next
[11:01:30.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.644]                 }
[11:01:30.644]                 NAMES <- toupper(added)
[11:01:30.644]                 for (kk in seq_along(NAMES)) {
[11:01:30.644]                   name <- added[[kk]]
[11:01:30.644]                   NAME <- NAMES[[kk]]
[11:01:30.644]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.644]                     next
[11:01:30.644]                   args[[name]] <- ""
[11:01:30.644]                 }
[11:01:30.644]                 NAMES <- toupper(removed)
[11:01:30.644]                 for (kk in seq_along(NAMES)) {
[11:01:30.644]                   name <- removed[[kk]]
[11:01:30.644]                   NAME <- NAMES[[kk]]
[11:01:30.644]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.644]                     next
[11:01:30.644]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.644]                 }
[11:01:30.644]                 if (length(args) > 0) 
[11:01:30.644]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.644]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.644]             }
[11:01:30.644]             else {
[11:01:30.644]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.644]             }
[11:01:30.644]             {
[11:01:30.644]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.644]                   0L) {
[11:01:30.644]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.644]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.644]                   base::options(opts)
[11:01:30.644]                 }
[11:01:30.644]                 {
[11:01:30.644]                   {
[11:01:30.644]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.644]                     NULL
[11:01:30.644]                   }
[11:01:30.644]                   options(future.plan = NULL)
[11:01:30.644]                   if (is.na(NA_character_)) 
[11:01:30.644]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.644]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.644]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.644]                     .init = FALSE)
[11:01:30.644]                 }
[11:01:30.644]             }
[11:01:30.644]         }
[11:01:30.644]     })
[11:01:30.644]     if (TRUE) {
[11:01:30.644]         base::sink(type = "output", split = FALSE)
[11:01:30.644]         if (TRUE) {
[11:01:30.644]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.644]         }
[11:01:30.644]         else {
[11:01:30.644]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.644]         }
[11:01:30.644]         base::close(...future.stdout)
[11:01:30.644]         ...future.stdout <- NULL
[11:01:30.644]     }
[11:01:30.644]     ...future.result$conditions <- ...future.conditions
[11:01:30.644]     ...future.result$finished <- base::Sys.time()
[11:01:30.644]     ...future.result
[11:01:30.644] }
[11:01:30.648] requestCore(): workers = 2
[11:01:30.648] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:30.659] result() for MulticoreFuture ...
[11:01:30.660] result() for MulticoreFuture ...
[11:01:30.660] result() for MulticoreFuture ... done
[11:01:30.660] result() for MulticoreFuture ... done
[11:01:30.660] result() for MulticoreFuture ...
[11:01:30.660] result() for MulticoreFuture ... done
[11:01:30.663] MulticoreFuture started
[11:01:30.663] - Launch lazy future ... done
[11:01:30.664] run() for ‘MulticoreFuture’ ... done
[11:01:30.664] plan(): Setting new future strategy stack:
<environment: 0x55a9c6334ff0> 
[11:01:30.664] List of future strategies:
[11:01:30.664] 1. sequential:
[11:01:30.664]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.664]    - tweaked: FALSE
[11:01:30.664]    - call: NULL
[11:01:30.666] plan(): nbrOfWorkers() = 1
<environment: 0x55a9c7e078d8> 
[11:01:30.668] plan(): Setting new future strategy stack:
[11:01:30.668] List of future strategies:
[11:01:30.668] 1. multicore:
[11:01:30.668]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.668]    - tweaked: FALSE
[11:01:30.668]    - call: plan(strategy)
[11:01:30.671] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:30.674] resolve() on environment ...
[11:01:30.674]  recursive: 0
[11:01:30.674]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:30.675] signalConditionsASAP(numeric, pos=1) ...
[11:01:30.675] - nx: 4
[11:01:30.675] - relay: TRUE
[11:01:30.675] - stdout: TRUE
[11:01:30.675] - signal: TRUE
[11:01:30.675] - resignal: FALSE
[11:01:30.675] - force: TRUE
[11:01:30.676] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.676] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.676]  - until=2
[11:01:30.676]  - relaying element #2
[11:01:30.676] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:30.676] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.676] signalConditionsASAP(NULL, pos=1) ... done
[11:01:30.676]  length: 3 (resolved future 1)
[11:01:30.677] Future #2
[11:01:30.677] result() for MulticoreFuture ...
[11:01:30.677] result() for MulticoreFuture ... done
[11:01:30.677] result() for MulticoreFuture ...
[11:01:30.677] result() for MulticoreFuture ... done
[11:01:30.677] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:30.677] - nx: 4
[11:01:30.678] - relay: TRUE
[11:01:30.678] - stdout: TRUE
[11:01:30.678] - signal: TRUE
[11:01:30.678] - resignal: FALSE
[11:01:30.678] - force: TRUE
[11:01:30.678] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:30.678] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.678]  - until=2
[11:01:30.679]  - relaying element #2
[11:01:30.679] result() for MulticoreFuture ...
[11:01:30.679] result() for MulticoreFuture ... done
[11:01:30.679] result() for MulticoreFuture ...
[11:01:30.679] result() for MulticoreFuture ... done
[11:01:30.679] result() for MulticoreFuture ...
[11:01:30.679] result() for MulticoreFuture ... done
[11:01:30.679] result() for MulticoreFuture ...
[11:01:30.679] result() for MulticoreFuture ... done
[11:01:30.680] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:30.680] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:30.680] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:30.680]  length: 2 (resolved future 2)
[11:01:30.680] Future #3
[11:01:30.680] result() for MulticoreFuture ...
[11:01:30.681] result() for MulticoreFuture ...
[11:01:30.681] result() for MulticoreFuture ... done
[11:01:30.681] result() for MulticoreFuture ... done
[11:01:30.682] result() for MulticoreFuture ...
[11:01:30.682] result() for MulticoreFuture ... done
[11:01:30.682] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:30.682] - nx: 4
[11:01:30.682] - relay: TRUE
[11:01:30.682] - stdout: TRUE
[11:01:30.682] - signal: TRUE
[11:01:30.682] - resignal: FALSE
[11:01:30.683] - force: TRUE
[11:01:30.683] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:30.683] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:30.683]  - until=3
[11:01:30.683]  - relaying element #3
[11:01:30.683] result() for MulticoreFuture ...
[11:01:30.683] result() for MulticoreFuture ... done
[11:01:30.683] result() for MulticoreFuture ...
[11:01:30.683] result() for MulticoreFuture ... done
[11:01:30.684] result() for MulticoreFuture ...
[11:01:30.684] result() for MulticoreFuture ... done
[11:01:30.684] result() for MulticoreFuture ...
[11:01:30.684] result() for MulticoreFuture ... done
[11:01:30.684] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:30.684] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:30.684] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:30.684]  length: 1 (resolved future 3)
[11:01:30.685] Future #4
[11:01:30.685] result() for MulticoreFuture ...
[11:01:30.686] result() for MulticoreFuture ...
[11:01:30.686] result() for MulticoreFuture ... done
[11:01:30.686] result() for MulticoreFuture ... done
[11:01:30.686] result() for MulticoreFuture ...
[11:01:30.686] result() for MulticoreFuture ... done
[11:01:30.686] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:30.687] - nx: 4
[11:01:30.687] - relay: TRUE
[11:01:30.687] - stdout: TRUE
[11:01:30.687] - signal: TRUE
[11:01:30.687] - resignal: FALSE
[11:01:30.687] - force: TRUE
[11:01:30.687] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:30.688] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:30.688]  - until=4
[11:01:30.688]  - relaying element #4
[11:01:30.688] result() for MulticoreFuture ...
[11:01:30.688] result() for MulticoreFuture ... done
[11:01:30.688] result() for MulticoreFuture ...
[11:01:30.689] result() for MulticoreFuture ... done
[11:01:30.689] result() for MulticoreFuture ...
[11:01:30.689] result() for MulticoreFuture ... done
[11:01:30.689] result() for MulticoreFuture ...
[11:01:30.689] result() for MulticoreFuture ... done
[11:01:30.689] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.690] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:30.690] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:30.690]  length: 0 (resolved future 4)
[11:01:30.690] Relaying remaining futures
[11:01:30.690] signalConditionsASAP(NULL, pos=0) ...
[11:01:30.690] - nx: 4
[11:01:30.690] - relay: TRUE
[11:01:30.690] - stdout: TRUE
[11:01:30.690] - signal: TRUE
[11:01:30.691] - resignal: FALSE
[11:01:30.691] - force: TRUE
[11:01:30.691] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.691] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:30.691] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.691] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:30.691] signalConditionsASAP(NULL, pos=0) ... done
[11:01:30.691] resolve() on environment ... DONE
[11:01:30.691] result() for MulticoreFuture ...
[11:01:30.691] result() for MulticoreFuture ... done
[11:01:30.692] result() for MulticoreFuture ...
[11:01:30.692] result() for MulticoreFuture ... done
[11:01:30.692] result() for MulticoreFuture ...
[11:01:30.692] result() for MulticoreFuture ... done
[11:01:30.692] result() for MulticoreFuture ...
[11:01:30.692] result() for MulticoreFuture ... done
[11:01:30.692] result() for MulticoreFuture ...
[11:01:30.692] result() for MulticoreFuture ... done
[11:01:30.692] result() for MulticoreFuture ...
[11:01:30.693] result() for MulticoreFuture ... done
<environment: 0x55a9c7ebf210> 
Dimensions: c(1, 6)
[11:01:30.693] getGlobalsAndPackages() ...
[11:01:30.693] Searching for globals...
[11:01:30.694] 
[11:01:30.694] Searching for globals ... DONE
[11:01:30.694] - globals: [0] <none>
[11:01:30.694] getGlobalsAndPackages() ... DONE
[11:01:30.694] run() for ‘Future’ ...
[11:01:30.694] - state: ‘created’
[11:01:30.695] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.697] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.697] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.697]   - Field: ‘label’
[11:01:30.697]   - Field: ‘local’
[11:01:30.697]   - Field: ‘owner’
[11:01:30.697]   - Field: ‘envir’
[11:01:30.697]   - Field: ‘workers’
[11:01:30.697]   - Field: ‘packages’
[11:01:30.698]   - Field: ‘gc’
[11:01:30.698]   - Field: ‘job’
[11:01:30.698]   - Field: ‘conditions’
[11:01:30.698]   - Field: ‘expr’
[11:01:30.698]   - Field: ‘uuid’
[11:01:30.698]   - Field: ‘seed’
[11:01:30.698]   - Field: ‘version’
[11:01:30.698]   - Field: ‘result’
[11:01:30.698]   - Field: ‘asynchronous’
[11:01:30.699]   - Field: ‘calls’
[11:01:30.699]   - Field: ‘globals’
[11:01:30.699]   - Field: ‘stdout’
[11:01:30.699]   - Field: ‘earlySignal’
[11:01:30.699]   - Field: ‘lazy’
[11:01:30.699]   - Field: ‘state’
[11:01:30.699] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.699] - Launch lazy future ...
[11:01:30.700] Packages needed by the future expression (n = 0): <none>
[11:01:30.700] Packages needed by future strategies (n = 0): <none>
[11:01:30.700] {
[11:01:30.700]     {
[11:01:30.700]         {
[11:01:30.700]             ...future.startTime <- base::Sys.time()
[11:01:30.700]             {
[11:01:30.700]                 {
[11:01:30.700]                   {
[11:01:30.700]                     {
[11:01:30.700]                       base::local({
[11:01:30.700]                         has_future <- base::requireNamespace("future", 
[11:01:30.700]                           quietly = TRUE)
[11:01:30.700]                         if (has_future) {
[11:01:30.700]                           ns <- base::getNamespace("future")
[11:01:30.700]                           version <- ns[[".package"]][["version"]]
[11:01:30.700]                           if (is.null(version)) 
[11:01:30.700]                             version <- utils::packageVersion("future")
[11:01:30.700]                         }
[11:01:30.700]                         else {
[11:01:30.700]                           version <- NULL
[11:01:30.700]                         }
[11:01:30.700]                         if (!has_future || version < "1.8.0") {
[11:01:30.700]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.700]                             "", base::R.version$version.string), 
[11:01:30.700]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.700]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.700]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.700]                               "release", "version")], collapse = " "), 
[11:01:30.700]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.700]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.700]                             info)
[11:01:30.700]                           info <- base::paste(info, collapse = "; ")
[11:01:30.700]                           if (!has_future) {
[11:01:30.700]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.700]                               info)
[11:01:30.700]                           }
[11:01:30.700]                           else {
[11:01:30.700]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.700]                               info, version)
[11:01:30.700]                           }
[11:01:30.700]                           base::stop(msg)
[11:01:30.700]                         }
[11:01:30.700]                       })
[11:01:30.700]                     }
[11:01:30.700]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.700]                     base::options(mc.cores = 1L)
[11:01:30.700]                   }
[11:01:30.700]                   ...future.strategy.old <- future::plan("list")
[11:01:30.700]                   options(future.plan = NULL)
[11:01:30.700]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.700]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.700]                 }
[11:01:30.700]                 ...future.workdir <- getwd()
[11:01:30.700]             }
[11:01:30.700]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.700]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.700]         }
[11:01:30.700]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.700]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.700]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.700]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.700]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.700]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.700]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.700]             base::names(...future.oldOptions))
[11:01:30.700]     }
[11:01:30.700]     if (FALSE) {
[11:01:30.700]     }
[11:01:30.700]     else {
[11:01:30.700]         if (TRUE) {
[11:01:30.700]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.700]                 open = "w")
[11:01:30.700]         }
[11:01:30.700]         else {
[11:01:30.700]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.700]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.700]         }
[11:01:30.700]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.700]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.700]             base::sink(type = "output", split = FALSE)
[11:01:30.700]             base::close(...future.stdout)
[11:01:30.700]         }, add = TRUE)
[11:01:30.700]     }
[11:01:30.700]     ...future.frame <- base::sys.nframe()
[11:01:30.700]     ...future.conditions <- base::list()
[11:01:30.700]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.700]     if (FALSE) {
[11:01:30.700]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.700]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.700]     }
[11:01:30.700]     ...future.result <- base::tryCatch({
[11:01:30.700]         base::withCallingHandlers({
[11:01:30.700]             ...future.value <- base::withVisible(base::local({
[11:01:30.700]                 withCallingHandlers({
[11:01:30.700]                   2
[11:01:30.700]                 }, immediateCondition = function(cond) {
[11:01:30.700]                   save_rds <- function (object, pathname, ...) 
[11:01:30.700]                   {
[11:01:30.700]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.700]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.700]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.700]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.700]                         fi_tmp[["mtime"]])
[11:01:30.700]                     }
[11:01:30.700]                     tryCatch({
[11:01:30.700]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.700]                     }, error = function(ex) {
[11:01:30.700]                       msg <- conditionMessage(ex)
[11:01:30.700]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.700]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.700]                         fi_tmp[["mtime"]], msg)
[11:01:30.700]                       ex$message <- msg
[11:01:30.700]                       stop(ex)
[11:01:30.700]                     })
[11:01:30.700]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.700]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.700]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.700]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.700]                       fi <- file.info(pathname)
[11:01:30.700]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.700]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.700]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.700]                         fi[["size"]], fi[["mtime"]])
[11:01:30.700]                       stop(msg)
[11:01:30.700]                     }
[11:01:30.700]                     invisible(pathname)
[11:01:30.700]                   }
[11:01:30.700]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.700]                     rootPath = tempdir()) 
[11:01:30.700]                   {
[11:01:30.700]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.700]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.700]                       tmpdir = path, fileext = ".rds")
[11:01:30.700]                     save_rds(obj, file)
[11:01:30.700]                   }
[11:01:30.700]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.700]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.700]                   {
[11:01:30.700]                     inherits <- base::inherits
[11:01:30.700]                     invokeRestart <- base::invokeRestart
[11:01:30.700]                     is.null <- base::is.null
[11:01:30.700]                     muffled <- FALSE
[11:01:30.700]                     if (inherits(cond, "message")) {
[11:01:30.700]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.700]                       if (muffled) 
[11:01:30.700]                         invokeRestart("muffleMessage")
[11:01:30.700]                     }
[11:01:30.700]                     else if (inherits(cond, "warning")) {
[11:01:30.700]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.700]                       if (muffled) 
[11:01:30.700]                         invokeRestart("muffleWarning")
[11:01:30.700]                     }
[11:01:30.700]                     else if (inherits(cond, "condition")) {
[11:01:30.700]                       if (!is.null(pattern)) {
[11:01:30.700]                         computeRestarts <- base::computeRestarts
[11:01:30.700]                         grepl <- base::grepl
[11:01:30.700]                         restarts <- computeRestarts(cond)
[11:01:30.700]                         for (restart in restarts) {
[11:01:30.700]                           name <- restart$name
[11:01:30.700]                           if (is.null(name)) 
[11:01:30.700]                             next
[11:01:30.700]                           if (!grepl(pattern, name)) 
[11:01:30.700]                             next
[11:01:30.700]                           invokeRestart(restart)
[11:01:30.700]                           muffled <- TRUE
[11:01:30.700]                           break
[11:01:30.700]                         }
[11:01:30.700]                       }
[11:01:30.700]                     }
[11:01:30.700]                     invisible(muffled)
[11:01:30.700]                   }
[11:01:30.700]                   muffleCondition(cond)
[11:01:30.700]                 })
[11:01:30.700]             }))
[11:01:30.700]             future::FutureResult(value = ...future.value$value, 
[11:01:30.700]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.700]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.700]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.700]                     ...future.globalenv.names))
[11:01:30.700]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.700]         }, condition = base::local({
[11:01:30.700]             c <- base::c
[11:01:30.700]             inherits <- base::inherits
[11:01:30.700]             invokeRestart <- base::invokeRestart
[11:01:30.700]             length <- base::length
[11:01:30.700]             list <- base::list
[11:01:30.700]             seq.int <- base::seq.int
[11:01:30.700]             signalCondition <- base::signalCondition
[11:01:30.700]             sys.calls <- base::sys.calls
[11:01:30.700]             `[[` <- base::`[[`
[11:01:30.700]             `+` <- base::`+`
[11:01:30.700]             `<<-` <- base::`<<-`
[11:01:30.700]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.700]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.700]                   3L)]
[11:01:30.700]             }
[11:01:30.700]             function(cond) {
[11:01:30.700]                 is_error <- inherits(cond, "error")
[11:01:30.700]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.700]                   NULL)
[11:01:30.700]                 if (is_error) {
[11:01:30.700]                   sessionInformation <- function() {
[11:01:30.700]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.700]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.700]                       search = base::search(), system = base::Sys.info())
[11:01:30.700]                   }
[11:01:30.700]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.700]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.700]                     cond$call), session = sessionInformation(), 
[11:01:30.700]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.700]                   signalCondition(cond)
[11:01:30.700]                 }
[11:01:30.700]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.700]                 "immediateCondition"))) {
[11:01:30.700]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.700]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.700]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.700]                   if (TRUE && !signal) {
[11:01:30.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.700]                     {
[11:01:30.700]                       inherits <- base::inherits
[11:01:30.700]                       invokeRestart <- base::invokeRestart
[11:01:30.700]                       is.null <- base::is.null
[11:01:30.700]                       muffled <- FALSE
[11:01:30.700]                       if (inherits(cond, "message")) {
[11:01:30.700]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.700]                         if (muffled) 
[11:01:30.700]                           invokeRestart("muffleMessage")
[11:01:30.700]                       }
[11:01:30.700]                       else if (inherits(cond, "warning")) {
[11:01:30.700]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.700]                         if (muffled) 
[11:01:30.700]                           invokeRestart("muffleWarning")
[11:01:30.700]                       }
[11:01:30.700]                       else if (inherits(cond, "condition")) {
[11:01:30.700]                         if (!is.null(pattern)) {
[11:01:30.700]                           computeRestarts <- base::computeRestarts
[11:01:30.700]                           grepl <- base::grepl
[11:01:30.700]                           restarts <- computeRestarts(cond)
[11:01:30.700]                           for (restart in restarts) {
[11:01:30.700]                             name <- restart$name
[11:01:30.700]                             if (is.null(name)) 
[11:01:30.700]                               next
[11:01:30.700]                             if (!grepl(pattern, name)) 
[11:01:30.700]                               next
[11:01:30.700]                             invokeRestart(restart)
[11:01:30.700]                             muffled <- TRUE
[11:01:30.700]                             break
[11:01:30.700]                           }
[11:01:30.700]                         }
[11:01:30.700]                       }
[11:01:30.700]                       invisible(muffled)
[11:01:30.700]                     }
[11:01:30.700]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.700]                   }
[11:01:30.700]                 }
[11:01:30.700]                 else {
[11:01:30.700]                   if (TRUE) {
[11:01:30.700]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.700]                     {
[11:01:30.700]                       inherits <- base::inherits
[11:01:30.700]                       invokeRestart <- base::invokeRestart
[11:01:30.700]                       is.null <- base::is.null
[11:01:30.700]                       muffled <- FALSE
[11:01:30.700]                       if (inherits(cond, "message")) {
[11:01:30.700]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.700]                         if (muffled) 
[11:01:30.700]                           invokeRestart("muffleMessage")
[11:01:30.700]                       }
[11:01:30.700]                       else if (inherits(cond, "warning")) {
[11:01:30.700]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.700]                         if (muffled) 
[11:01:30.700]                           invokeRestart("muffleWarning")
[11:01:30.700]                       }
[11:01:30.700]                       else if (inherits(cond, "condition")) {
[11:01:30.700]                         if (!is.null(pattern)) {
[11:01:30.700]                           computeRestarts <- base::computeRestarts
[11:01:30.700]                           grepl <- base::grepl
[11:01:30.700]                           restarts <- computeRestarts(cond)
[11:01:30.700]                           for (restart in restarts) {
[11:01:30.700]                             name <- restart$name
[11:01:30.700]                             if (is.null(name)) 
[11:01:30.700]                               next
[11:01:30.700]                             if (!grepl(pattern, name)) 
[11:01:30.700]                               next
[11:01:30.700]                             invokeRestart(restart)
[11:01:30.700]                             muffled <- TRUE
[11:01:30.700]                             break
[11:01:30.700]                           }
[11:01:30.700]                         }
[11:01:30.700]                       }
[11:01:30.700]                       invisible(muffled)
[11:01:30.700]                     }
[11:01:30.700]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.700]                   }
[11:01:30.700]                 }
[11:01:30.700]             }
[11:01:30.700]         }))
[11:01:30.700]     }, error = function(ex) {
[11:01:30.700]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.700]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.700]                 ...future.rng), started = ...future.startTime, 
[11:01:30.700]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.700]             version = "1.8"), class = "FutureResult")
[11:01:30.700]     }, finally = {
[11:01:30.700]         if (!identical(...future.workdir, getwd())) 
[11:01:30.700]             setwd(...future.workdir)
[11:01:30.700]         {
[11:01:30.700]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.700]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.700]             }
[11:01:30.700]             base::options(...future.oldOptions)
[11:01:30.700]             if (.Platform$OS.type == "windows") {
[11:01:30.700]                 old_names <- names(...future.oldEnvVars)
[11:01:30.700]                 envs <- base::Sys.getenv()
[11:01:30.700]                 names <- names(envs)
[11:01:30.700]                 common <- intersect(names, old_names)
[11:01:30.700]                 added <- setdiff(names, old_names)
[11:01:30.700]                 removed <- setdiff(old_names, names)
[11:01:30.700]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.700]                   envs[common]]
[11:01:30.700]                 NAMES <- toupper(changed)
[11:01:30.700]                 args <- list()
[11:01:30.700]                 for (kk in seq_along(NAMES)) {
[11:01:30.700]                   name <- changed[[kk]]
[11:01:30.700]                   NAME <- NAMES[[kk]]
[11:01:30.700]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.700]                     next
[11:01:30.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.700]                 }
[11:01:30.700]                 NAMES <- toupper(added)
[11:01:30.700]                 for (kk in seq_along(NAMES)) {
[11:01:30.700]                   name <- added[[kk]]
[11:01:30.700]                   NAME <- NAMES[[kk]]
[11:01:30.700]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.700]                     next
[11:01:30.700]                   args[[name]] <- ""
[11:01:30.700]                 }
[11:01:30.700]                 NAMES <- toupper(removed)
[11:01:30.700]                 for (kk in seq_along(NAMES)) {
[11:01:30.700]                   name <- removed[[kk]]
[11:01:30.700]                   NAME <- NAMES[[kk]]
[11:01:30.700]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.700]                     next
[11:01:30.700]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.700]                 }
[11:01:30.700]                 if (length(args) > 0) 
[11:01:30.700]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.700]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.700]             }
[11:01:30.700]             else {
[11:01:30.700]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.700]             }
[11:01:30.700]             {
[11:01:30.700]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.700]                   0L) {
[11:01:30.700]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.700]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.700]                   base::options(opts)
[11:01:30.700]                 }
[11:01:30.700]                 {
[11:01:30.700]                   {
[11:01:30.700]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.700]                     NULL
[11:01:30.700]                   }
[11:01:30.700]                   options(future.plan = NULL)
[11:01:30.700]                   if (is.na(NA_character_)) 
[11:01:30.700]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.700]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.700]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.700]                     .init = FALSE)
[11:01:30.700]                 }
[11:01:30.700]             }
[11:01:30.700]         }
[11:01:30.700]     })
[11:01:30.700]     if (TRUE) {
[11:01:30.700]         base::sink(type = "output", split = FALSE)
[11:01:30.700]         if (TRUE) {
[11:01:30.700]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.700]         }
[11:01:30.700]         else {
[11:01:30.700]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.700]         }
[11:01:30.700]         base::close(...future.stdout)
[11:01:30.700]         ...future.stdout <- NULL
[11:01:30.700]     }
[11:01:30.700]     ...future.result$conditions <- ...future.conditions
[11:01:30.700]     ...future.result$finished <- base::Sys.time()
[11:01:30.700]     ...future.result
[11:01:30.700] }
[11:01:30.703] requestCore(): workers = 2
[11:01:30.705] MulticoreFuture started
[11:01:30.705] - Launch lazy future ... done
[11:01:30.705] run() for ‘MulticoreFuture’ ... done
[11:01:30.706] getGlobalsAndPackages() ...
[11:01:30.706] Searching for globals...
[11:01:30.706] plan(): Setting new future strategy stack:
[11:01:30.707] 
[11:01:30.707] Searching for globals ... DONE
[11:01:30.706] List of future strategies:
[11:01:30.706] 1. sequential:
[11:01:30.706]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.706]    - tweaked: FALSE
[11:01:30.706]    - call: NULL
[11:01:30.707] - globals: [0] <none>
[11:01:30.707] getGlobalsAndPackages() ... DONE
[11:01:30.707] plan(): nbrOfWorkers() = 1
[11:01:30.708] run() for ‘Future’ ...
[11:01:30.708] - state: ‘created’
[11:01:30.708] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.709] plan(): Setting new future strategy stack:
[11:01:30.709] List of future strategies:
[11:01:30.709] 1. multicore:
[11:01:30.709]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.709]    - tweaked: FALSE
[11:01:30.709]    - call: plan(strategy)
[11:01:30.711] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.711] plan(): nbrOfWorkers() = 2
[11:01:30.711] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.711]   - Field: ‘label’
[11:01:30.712]   - Field: ‘local’
[11:01:30.712]   - Field: ‘owner’
[11:01:30.712]   - Field: ‘envir’
[11:01:30.712]   - Field: ‘workers’
[11:01:30.712]   - Field: ‘packages’
[11:01:30.712]   - Field: ‘gc’
[11:01:30.712]   - Field: ‘job’
[11:01:30.712]   - Field: ‘conditions’
[11:01:30.713]   - Field: ‘expr’
[11:01:30.713]   - Field: ‘uuid’
[11:01:30.713]   - Field: ‘seed’
[11:01:30.713]   - Field: ‘version’
[11:01:30.713]   - Field: ‘result’
[11:01:30.713]   - Field: ‘asynchronous’
[11:01:30.713]   - Field: ‘calls’
[11:01:30.714]   - Field: ‘globals’
[11:01:30.714]   - Field: ‘stdout’
[11:01:30.714]   - Field: ‘earlySignal’
[11:01:30.714]   - Field: ‘lazy’
[11:01:30.714]   - Field: ‘state’
[11:01:30.714] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.714] - Launch lazy future ...
[11:01:30.715] Packages needed by the future expression (n = 0): <none>
[11:01:30.715] Packages needed by future strategies (n = 0): <none>
[11:01:30.716] {
[11:01:30.716]     {
[11:01:30.716]         {
[11:01:30.716]             ...future.startTime <- base::Sys.time()
[11:01:30.716]             {
[11:01:30.716]                 {
[11:01:30.716]                   {
[11:01:30.716]                     {
[11:01:30.716]                       base::local({
[11:01:30.716]                         has_future <- base::requireNamespace("future", 
[11:01:30.716]                           quietly = TRUE)
[11:01:30.716]                         if (has_future) {
[11:01:30.716]                           ns <- base::getNamespace("future")
[11:01:30.716]                           version <- ns[[".package"]][["version"]]
[11:01:30.716]                           if (is.null(version)) 
[11:01:30.716]                             version <- utils::packageVersion("future")
[11:01:30.716]                         }
[11:01:30.716]                         else {
[11:01:30.716]                           version <- NULL
[11:01:30.716]                         }
[11:01:30.716]                         if (!has_future || version < "1.8.0") {
[11:01:30.716]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.716]                             "", base::R.version$version.string), 
[11:01:30.716]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.716]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.716]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.716]                               "release", "version")], collapse = " "), 
[11:01:30.716]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.716]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.716]                             info)
[11:01:30.716]                           info <- base::paste(info, collapse = "; ")
[11:01:30.716]                           if (!has_future) {
[11:01:30.716]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.716]                               info)
[11:01:30.716]                           }
[11:01:30.716]                           else {
[11:01:30.716]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.716]                               info, version)
[11:01:30.716]                           }
[11:01:30.716]                           base::stop(msg)
[11:01:30.716]                         }
[11:01:30.716]                       })
[11:01:30.716]                     }
[11:01:30.716]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.716]                     base::options(mc.cores = 1L)
[11:01:30.716]                   }
[11:01:30.716]                   ...future.strategy.old <- future::plan("list")
[11:01:30.716]                   options(future.plan = NULL)
[11:01:30.716]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.716]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.716]                 }
[11:01:30.716]                 ...future.workdir <- getwd()
[11:01:30.716]             }
[11:01:30.716]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.716]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.716]         }
[11:01:30.716]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.716]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.716]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.716]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.716]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.716]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.716]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.716]             base::names(...future.oldOptions))
[11:01:30.716]     }
[11:01:30.716]     if (FALSE) {
[11:01:30.716]     }
[11:01:30.716]     else {
[11:01:30.716]         if (TRUE) {
[11:01:30.716]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.716]                 open = "w")
[11:01:30.716]         }
[11:01:30.716]         else {
[11:01:30.716]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.716]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.716]         }
[11:01:30.716]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.716]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.716]             base::sink(type = "output", split = FALSE)
[11:01:30.716]             base::close(...future.stdout)
[11:01:30.716]         }, add = TRUE)
[11:01:30.716]     }
[11:01:30.716]     ...future.frame <- base::sys.nframe()
[11:01:30.716]     ...future.conditions <- base::list()
[11:01:30.716]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.716]     if (FALSE) {
[11:01:30.716]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.716]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.716]     }
[11:01:30.716]     ...future.result <- base::tryCatch({
[11:01:30.716]         base::withCallingHandlers({
[11:01:30.716]             ...future.value <- base::withVisible(base::local({
[11:01:30.716]                 withCallingHandlers({
[11:01:30.716]                   NULL
[11:01:30.716]                 }, immediateCondition = function(cond) {
[11:01:30.716]                   save_rds <- function (object, pathname, ...) 
[11:01:30.716]                   {
[11:01:30.716]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.716]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.716]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.716]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.716]                         fi_tmp[["mtime"]])
[11:01:30.716]                     }
[11:01:30.716]                     tryCatch({
[11:01:30.716]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.716]                     }, error = function(ex) {
[11:01:30.716]                       msg <- conditionMessage(ex)
[11:01:30.716]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.716]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.716]                         fi_tmp[["mtime"]], msg)
[11:01:30.716]                       ex$message <- msg
[11:01:30.716]                       stop(ex)
[11:01:30.716]                     })
[11:01:30.716]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.716]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.716]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.716]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.716]                       fi <- file.info(pathname)
[11:01:30.716]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.716]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.716]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.716]                         fi[["size"]], fi[["mtime"]])
[11:01:30.716]                       stop(msg)
[11:01:30.716]                     }
[11:01:30.716]                     invisible(pathname)
[11:01:30.716]                   }
[11:01:30.716]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.716]                     rootPath = tempdir()) 
[11:01:30.716]                   {
[11:01:30.716]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.716]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.716]                       tmpdir = path, fileext = ".rds")
[11:01:30.716]                     save_rds(obj, file)
[11:01:30.716]                   }
[11:01:30.716]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.716]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.716]                   {
[11:01:30.716]                     inherits <- base::inherits
[11:01:30.716]                     invokeRestart <- base::invokeRestart
[11:01:30.716]                     is.null <- base::is.null
[11:01:30.716]                     muffled <- FALSE
[11:01:30.716]                     if (inherits(cond, "message")) {
[11:01:30.716]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.716]                       if (muffled) 
[11:01:30.716]                         invokeRestart("muffleMessage")
[11:01:30.716]                     }
[11:01:30.716]                     else if (inherits(cond, "warning")) {
[11:01:30.716]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.716]                       if (muffled) 
[11:01:30.716]                         invokeRestart("muffleWarning")
[11:01:30.716]                     }
[11:01:30.716]                     else if (inherits(cond, "condition")) {
[11:01:30.716]                       if (!is.null(pattern)) {
[11:01:30.716]                         computeRestarts <- base::computeRestarts
[11:01:30.716]                         grepl <- base::grepl
[11:01:30.716]                         restarts <- computeRestarts(cond)
[11:01:30.716]                         for (restart in restarts) {
[11:01:30.716]                           name <- restart$name
[11:01:30.716]                           if (is.null(name)) 
[11:01:30.716]                             next
[11:01:30.716]                           if (!grepl(pattern, name)) 
[11:01:30.716]                             next
[11:01:30.716]                           invokeRestart(restart)
[11:01:30.716]                           muffled <- TRUE
[11:01:30.716]                           break
[11:01:30.716]                         }
[11:01:30.716]                       }
[11:01:30.716]                     }
[11:01:30.716]                     invisible(muffled)
[11:01:30.716]                   }
[11:01:30.716]                   muffleCondition(cond)
[11:01:30.716]                 })
[11:01:30.716]             }))
[11:01:30.716]             future::FutureResult(value = ...future.value$value, 
[11:01:30.716]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.716]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.716]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.716]                     ...future.globalenv.names))
[11:01:30.716]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.716]         }, condition = base::local({
[11:01:30.716]             c <- base::c
[11:01:30.716]             inherits <- base::inherits
[11:01:30.716]             invokeRestart <- base::invokeRestart
[11:01:30.716]             length <- base::length
[11:01:30.716]             list <- base::list
[11:01:30.716]             seq.int <- base::seq.int
[11:01:30.716]             signalCondition <- base::signalCondition
[11:01:30.716]             sys.calls <- base::sys.calls
[11:01:30.716]             `[[` <- base::`[[`
[11:01:30.716]             `+` <- base::`+`
[11:01:30.716]             `<<-` <- base::`<<-`
[11:01:30.716]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.716]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.716]                   3L)]
[11:01:30.716]             }
[11:01:30.716]             function(cond) {
[11:01:30.716]                 is_error <- inherits(cond, "error")
[11:01:30.716]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.716]                   NULL)
[11:01:30.716]                 if (is_error) {
[11:01:30.716]                   sessionInformation <- function() {
[11:01:30.716]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.716]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.716]                       search = base::search(), system = base::Sys.info())
[11:01:30.716]                   }
[11:01:30.716]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.716]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.716]                     cond$call), session = sessionInformation(), 
[11:01:30.716]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.716]                   signalCondition(cond)
[11:01:30.716]                 }
[11:01:30.716]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.716]                 "immediateCondition"))) {
[11:01:30.716]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.716]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.716]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.716]                   if (TRUE && !signal) {
[11:01:30.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.716]                     {
[11:01:30.716]                       inherits <- base::inherits
[11:01:30.716]                       invokeRestart <- base::invokeRestart
[11:01:30.716]                       is.null <- base::is.null
[11:01:30.716]                       muffled <- FALSE
[11:01:30.716]                       if (inherits(cond, "message")) {
[11:01:30.716]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.716]                         if (muffled) 
[11:01:30.716]                           invokeRestart("muffleMessage")
[11:01:30.716]                       }
[11:01:30.716]                       else if (inherits(cond, "warning")) {
[11:01:30.716]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.716]                         if (muffled) 
[11:01:30.716]                           invokeRestart("muffleWarning")
[11:01:30.716]                       }
[11:01:30.716]                       else if (inherits(cond, "condition")) {
[11:01:30.716]                         if (!is.null(pattern)) {
[11:01:30.716]                           computeRestarts <- base::computeRestarts
[11:01:30.716]                           grepl <- base::grepl
[11:01:30.716]                           restarts <- computeRestarts(cond)
[11:01:30.716]                           for (restart in restarts) {
[11:01:30.716]                             name <- restart$name
[11:01:30.716]                             if (is.null(name)) 
[11:01:30.716]                               next
[11:01:30.716]                             if (!grepl(pattern, name)) 
[11:01:30.716]                               next
[11:01:30.716]                             invokeRestart(restart)
[11:01:30.716]                             muffled <- TRUE
[11:01:30.716]                             break
[11:01:30.716]                           }
[11:01:30.716]                         }
[11:01:30.716]                       }
[11:01:30.716]                       invisible(muffled)
[11:01:30.716]                     }
[11:01:30.716]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.716]                   }
[11:01:30.716]                 }
[11:01:30.716]                 else {
[11:01:30.716]                   if (TRUE) {
[11:01:30.716]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.716]                     {
[11:01:30.716]                       inherits <- base::inherits
[11:01:30.716]                       invokeRestart <- base::invokeRestart
[11:01:30.716]                       is.null <- base::is.null
[11:01:30.716]                       muffled <- FALSE
[11:01:30.716]                       if (inherits(cond, "message")) {
[11:01:30.716]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.716]                         if (muffled) 
[11:01:30.716]                           invokeRestart("muffleMessage")
[11:01:30.716]                       }
[11:01:30.716]                       else if (inherits(cond, "warning")) {
[11:01:30.716]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.716]                         if (muffled) 
[11:01:30.716]                           invokeRestart("muffleWarning")
[11:01:30.716]                       }
[11:01:30.716]                       else if (inherits(cond, "condition")) {
[11:01:30.716]                         if (!is.null(pattern)) {
[11:01:30.716]                           computeRestarts <- base::computeRestarts
[11:01:30.716]                           grepl <- base::grepl
[11:01:30.716]                           restarts <- computeRestarts(cond)
[11:01:30.716]                           for (restart in restarts) {
[11:01:30.716]                             name <- restart$name
[11:01:30.716]                             if (is.null(name)) 
[11:01:30.716]                               next
[11:01:30.716]                             if (!grepl(pattern, name)) 
[11:01:30.716]                               next
[11:01:30.716]                             invokeRestart(restart)
[11:01:30.716]                             muffled <- TRUE
[11:01:30.716]                             break
[11:01:30.716]                           }
[11:01:30.716]                         }
[11:01:30.716]                       }
[11:01:30.716]                       invisible(muffled)
[11:01:30.716]                     }
[11:01:30.716]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.716]                   }
[11:01:30.716]                 }
[11:01:30.716]             }
[11:01:30.716]         }))
[11:01:30.716]     }, error = function(ex) {
[11:01:30.716]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.716]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.716]                 ...future.rng), started = ...future.startTime, 
[11:01:30.716]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.716]             version = "1.8"), class = "FutureResult")
[11:01:30.716]     }, finally = {
[11:01:30.716]         if (!identical(...future.workdir, getwd())) 
[11:01:30.716]             setwd(...future.workdir)
[11:01:30.716]         {
[11:01:30.716]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.716]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.716]             }
[11:01:30.716]             base::options(...future.oldOptions)
[11:01:30.716]             if (.Platform$OS.type == "windows") {
[11:01:30.716]                 old_names <- names(...future.oldEnvVars)
[11:01:30.716]                 envs <- base::Sys.getenv()
[11:01:30.716]                 names <- names(envs)
[11:01:30.716]                 common <- intersect(names, old_names)
[11:01:30.716]                 added <- setdiff(names, old_names)
[11:01:30.716]                 removed <- setdiff(old_names, names)
[11:01:30.716]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.716]                   envs[common]]
[11:01:30.716]                 NAMES <- toupper(changed)
[11:01:30.716]                 args <- list()
[11:01:30.716]                 for (kk in seq_along(NAMES)) {
[11:01:30.716]                   name <- changed[[kk]]
[11:01:30.716]                   NAME <- NAMES[[kk]]
[11:01:30.716]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.716]                     next
[11:01:30.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.716]                 }
[11:01:30.716]                 NAMES <- toupper(added)
[11:01:30.716]                 for (kk in seq_along(NAMES)) {
[11:01:30.716]                   name <- added[[kk]]
[11:01:30.716]                   NAME <- NAMES[[kk]]
[11:01:30.716]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.716]                     next
[11:01:30.716]                   args[[name]] <- ""
[11:01:30.716]                 }
[11:01:30.716]                 NAMES <- toupper(removed)
[11:01:30.716]                 for (kk in seq_along(NAMES)) {
[11:01:30.716]                   name <- removed[[kk]]
[11:01:30.716]                   NAME <- NAMES[[kk]]
[11:01:30.716]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.716]                     next
[11:01:30.716]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.716]                 }
[11:01:30.716]                 if (length(args) > 0) 
[11:01:30.716]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.716]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.716]             }
[11:01:30.716]             else {
[11:01:30.716]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.716]             }
[11:01:30.716]             {
[11:01:30.716]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.716]                   0L) {
[11:01:30.716]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.716]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.716]                   base::options(opts)
[11:01:30.716]                 }
[11:01:30.716]                 {
[11:01:30.716]                   {
[11:01:30.716]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.716]                     NULL
[11:01:30.716]                   }
[11:01:30.716]                   options(future.plan = NULL)
[11:01:30.716]                   if (is.na(NA_character_)) 
[11:01:30.716]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.716]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.716]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.716]                     .init = FALSE)
[11:01:30.716]                 }
[11:01:30.716]             }
[11:01:30.716]         }
[11:01:30.716]     })
[11:01:30.716]     if (TRUE) {
[11:01:30.716]         base::sink(type = "output", split = FALSE)
[11:01:30.716]         if (TRUE) {
[11:01:30.716]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.716]         }
[11:01:30.716]         else {
[11:01:30.716]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.716]         }
[11:01:30.716]         base::close(...future.stdout)
[11:01:30.716]         ...future.stdout <- NULL
[11:01:30.716]     }
[11:01:30.716]     ...future.result$conditions <- ...future.conditions
[11:01:30.716]     ...future.result$finished <- base::Sys.time()
[11:01:30.716]     ...future.result
[11:01:30.716] }
[11:01:30.719] requestCore(): workers = 2
[11:01:30.721] MulticoreFuture started
[11:01:30.721] - Launch lazy future ... done
[11:01:30.722] run() for ‘MulticoreFuture’ ... done
[11:01:30.722] plan(): Setting new future strategy stack:
[11:01:30.722] getGlobalsAndPackages() ...
[11:01:30.723] Searching for globals...
[11:01:30.722] List of future strategies:
[11:01:30.722] 1. sequential:
[11:01:30.722]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.722]    - tweaked: FALSE
[11:01:30.722]    - call: NULL
[11:01:30.723] plan(): nbrOfWorkers() = 1
[11:01:30.724] - globals found: [1] ‘{’
[11:01:30.724] Searching for globals ... DONE
[11:01:30.724] Resolving globals: FALSE
[11:01:30.725] 
[11:01:30.725] 
[11:01:30.725] getGlobalsAndPackages() ... DONE
[11:01:30.725] plan(): Setting new future strategy stack:
[11:01:30.725] run() for ‘Future’ ...
[11:01:30.725] - state: ‘created’
[11:01:30.725] List of future strategies:
[11:01:30.725] 1. multicore:
[11:01:30.725]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.725]    - tweaked: FALSE
[11:01:30.725]    - call: plan(strategy)
[11:01:30.726] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.728] plan(): nbrOfWorkers() = 2
[11:01:30.728] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.728] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.729]   - Field: ‘label’
[11:01:30.729]   - Field: ‘local’
[11:01:30.729]   - Field: ‘owner’
[11:01:30.729]   - Field: ‘envir’
[11:01:30.729]   - Field: ‘workers’
[11:01:30.729]   - Field: ‘packages’
[11:01:30.729]   - Field: ‘gc’
[11:01:30.729]   - Field: ‘job’
[11:01:30.730]   - Field: ‘conditions’
[11:01:30.730]   - Field: ‘expr’
[11:01:30.730]   - Field: ‘uuid’
[11:01:30.730]   - Field: ‘seed’
[11:01:30.730]   - Field: ‘version’
[11:01:30.730]   - Field: ‘result’
[11:01:30.730]   - Field: ‘asynchronous’
[11:01:30.730]   - Field: ‘calls’
[11:01:30.731]   - Field: ‘globals’
[11:01:30.731]   - Field: ‘stdout’
[11:01:30.731]   - Field: ‘earlySignal’
[11:01:30.731]   - Field: ‘lazy’
[11:01:30.731]   - Field: ‘state’
[11:01:30.731] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.731] - Launch lazy future ...
[11:01:30.732] Packages needed by the future expression (n = 0): <none>
[11:01:30.738] Packages needed by future strategies (n = 0): <none>
[11:01:30.738] {
[11:01:30.738]     {
[11:01:30.738]         {
[11:01:30.738]             ...future.startTime <- base::Sys.time()
[11:01:30.738]             {
[11:01:30.738]                 {
[11:01:30.738]                   {
[11:01:30.738]                     {
[11:01:30.738]                       base::local({
[11:01:30.738]                         has_future <- base::requireNamespace("future", 
[11:01:30.738]                           quietly = TRUE)
[11:01:30.738]                         if (has_future) {
[11:01:30.738]                           ns <- base::getNamespace("future")
[11:01:30.738]                           version <- ns[[".package"]][["version"]]
[11:01:30.738]                           if (is.null(version)) 
[11:01:30.738]                             version <- utils::packageVersion("future")
[11:01:30.738]                         }
[11:01:30.738]                         else {
[11:01:30.738]                           version <- NULL
[11:01:30.738]                         }
[11:01:30.738]                         if (!has_future || version < "1.8.0") {
[11:01:30.738]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.738]                             "", base::R.version$version.string), 
[11:01:30.738]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.738]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.738]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.738]                               "release", "version")], collapse = " "), 
[11:01:30.738]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.738]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.738]                             info)
[11:01:30.738]                           info <- base::paste(info, collapse = "; ")
[11:01:30.738]                           if (!has_future) {
[11:01:30.738]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.738]                               info)
[11:01:30.738]                           }
[11:01:30.738]                           else {
[11:01:30.738]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.738]                               info, version)
[11:01:30.738]                           }
[11:01:30.738]                           base::stop(msg)
[11:01:30.738]                         }
[11:01:30.738]                       })
[11:01:30.738]                     }
[11:01:30.738]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.738]                     base::options(mc.cores = 1L)
[11:01:30.738]                   }
[11:01:30.738]                   ...future.strategy.old <- future::plan("list")
[11:01:30.738]                   options(future.plan = NULL)
[11:01:30.738]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.738]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.738]                 }
[11:01:30.738]                 ...future.workdir <- getwd()
[11:01:30.738]             }
[11:01:30.738]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.738]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.738]         }
[11:01:30.738]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.738]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.738]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.738]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.738]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.738]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.738]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.738]             base::names(...future.oldOptions))
[11:01:30.738]     }
[11:01:30.738]     if (FALSE) {
[11:01:30.738]     }
[11:01:30.738]     else {
[11:01:30.738]         if (TRUE) {
[11:01:30.738]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.738]                 open = "w")
[11:01:30.738]         }
[11:01:30.738]         else {
[11:01:30.738]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.738]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.738]         }
[11:01:30.738]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.738]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.738]             base::sink(type = "output", split = FALSE)
[11:01:30.738]             base::close(...future.stdout)
[11:01:30.738]         }, add = TRUE)
[11:01:30.738]     }
[11:01:30.738]     ...future.frame <- base::sys.nframe()
[11:01:30.738]     ...future.conditions <- base::list()
[11:01:30.738]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.738]     if (FALSE) {
[11:01:30.738]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.738]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.738]     }
[11:01:30.738]     ...future.result <- base::tryCatch({
[11:01:30.738]         base::withCallingHandlers({
[11:01:30.738]             ...future.value <- base::withVisible(base::local({
[11:01:30.738]                 withCallingHandlers({
[11:01:30.738]                   {
[11:01:30.738]                     4
[11:01:30.738]                   }
[11:01:30.738]                 }, immediateCondition = function(cond) {
[11:01:30.738]                   save_rds <- function (object, pathname, ...) 
[11:01:30.738]                   {
[11:01:30.738]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.738]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.738]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.738]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.738]                         fi_tmp[["mtime"]])
[11:01:30.738]                     }
[11:01:30.738]                     tryCatch({
[11:01:30.738]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.738]                     }, error = function(ex) {
[11:01:30.738]                       msg <- conditionMessage(ex)
[11:01:30.738]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.738]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.738]                         fi_tmp[["mtime"]], msg)
[11:01:30.738]                       ex$message <- msg
[11:01:30.738]                       stop(ex)
[11:01:30.738]                     })
[11:01:30.738]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.738]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.738]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.738]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.738]                       fi <- file.info(pathname)
[11:01:30.738]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.738]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.738]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.738]                         fi[["size"]], fi[["mtime"]])
[11:01:30.738]                       stop(msg)
[11:01:30.738]                     }
[11:01:30.738]                     invisible(pathname)
[11:01:30.738]                   }
[11:01:30.738]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.738]                     rootPath = tempdir()) 
[11:01:30.738]                   {
[11:01:30.738]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.738]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.738]                       tmpdir = path, fileext = ".rds")
[11:01:30.738]                     save_rds(obj, file)
[11:01:30.738]                   }
[11:01:30.738]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.738]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.738]                   {
[11:01:30.738]                     inherits <- base::inherits
[11:01:30.738]                     invokeRestart <- base::invokeRestart
[11:01:30.738]                     is.null <- base::is.null
[11:01:30.738]                     muffled <- FALSE
[11:01:30.738]                     if (inherits(cond, "message")) {
[11:01:30.738]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.738]                       if (muffled) 
[11:01:30.738]                         invokeRestart("muffleMessage")
[11:01:30.738]                     }
[11:01:30.738]                     else if (inherits(cond, "warning")) {
[11:01:30.738]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.738]                       if (muffled) 
[11:01:30.738]                         invokeRestart("muffleWarning")
[11:01:30.738]                     }
[11:01:30.738]                     else if (inherits(cond, "condition")) {
[11:01:30.738]                       if (!is.null(pattern)) {
[11:01:30.738]                         computeRestarts <- base::computeRestarts
[11:01:30.738]                         grepl <- base::grepl
[11:01:30.738]                         restarts <- computeRestarts(cond)
[11:01:30.738]                         for (restart in restarts) {
[11:01:30.738]                           name <- restart$name
[11:01:30.738]                           if (is.null(name)) 
[11:01:30.738]                             next
[11:01:30.738]                           if (!grepl(pattern, name)) 
[11:01:30.738]                             next
[11:01:30.738]                           invokeRestart(restart)
[11:01:30.738]                           muffled <- TRUE
[11:01:30.738]                           break
[11:01:30.738]                         }
[11:01:30.738]                       }
[11:01:30.738]                     }
[11:01:30.738]                     invisible(muffled)
[11:01:30.738]                   }
[11:01:30.738]                   muffleCondition(cond)
[11:01:30.738]                 })
[11:01:30.738]             }))
[11:01:30.738]             future::FutureResult(value = ...future.value$value, 
[11:01:30.738]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.738]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.738]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.738]                     ...future.globalenv.names))
[11:01:30.738]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.738]         }, condition = base::local({
[11:01:30.738]             c <- base::c
[11:01:30.738]             inherits <- base::inherits
[11:01:30.738]             invokeRestart <- base::invokeRestart
[11:01:30.738]             length <- base::length
[11:01:30.738]             list <- base::list
[11:01:30.738]             seq.int <- base::seq.int
[11:01:30.738]             signalCondition <- base::signalCondition
[11:01:30.738]             sys.calls <- base::sys.calls
[11:01:30.738]             `[[` <- base::`[[`
[11:01:30.738]             `+` <- base::`+`
[11:01:30.738]             `<<-` <- base::`<<-`
[11:01:30.738]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.738]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.738]                   3L)]
[11:01:30.738]             }
[11:01:30.738]             function(cond) {
[11:01:30.738]                 is_error <- inherits(cond, "error")
[11:01:30.738]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.738]                   NULL)
[11:01:30.738]                 if (is_error) {
[11:01:30.738]                   sessionInformation <- function() {
[11:01:30.738]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.738]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.738]                       search = base::search(), system = base::Sys.info())
[11:01:30.738]                   }
[11:01:30.738]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.738]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.738]                     cond$call), session = sessionInformation(), 
[11:01:30.738]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.738]                   signalCondition(cond)
[11:01:30.738]                 }
[11:01:30.738]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.738]                 "immediateCondition"))) {
[11:01:30.738]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.738]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.738]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.738]                   if (TRUE && !signal) {
[11:01:30.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.738]                     {
[11:01:30.738]                       inherits <- base::inherits
[11:01:30.738]                       invokeRestart <- base::invokeRestart
[11:01:30.738]                       is.null <- base::is.null
[11:01:30.738]                       muffled <- FALSE
[11:01:30.738]                       if (inherits(cond, "message")) {
[11:01:30.738]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.738]                         if (muffled) 
[11:01:30.738]                           invokeRestart("muffleMessage")
[11:01:30.738]                       }
[11:01:30.738]                       else if (inherits(cond, "warning")) {
[11:01:30.738]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.738]                         if (muffled) 
[11:01:30.738]                           invokeRestart("muffleWarning")
[11:01:30.738]                       }
[11:01:30.738]                       else if (inherits(cond, "condition")) {
[11:01:30.738]                         if (!is.null(pattern)) {
[11:01:30.738]                           computeRestarts <- base::computeRestarts
[11:01:30.738]                           grepl <- base::grepl
[11:01:30.738]                           restarts <- computeRestarts(cond)
[11:01:30.738]                           for (restart in restarts) {
[11:01:30.738]                             name <- restart$name
[11:01:30.738]                             if (is.null(name)) 
[11:01:30.738]                               next
[11:01:30.738]                             if (!grepl(pattern, name)) 
[11:01:30.738]                               next
[11:01:30.738]                             invokeRestart(restart)
[11:01:30.738]                             muffled <- TRUE
[11:01:30.738]                             break
[11:01:30.738]                           }
[11:01:30.738]                         }
[11:01:30.738]                       }
[11:01:30.738]                       invisible(muffled)
[11:01:30.738]                     }
[11:01:30.738]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.738]                   }
[11:01:30.738]                 }
[11:01:30.738]                 else {
[11:01:30.738]                   if (TRUE) {
[11:01:30.738]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.738]                     {
[11:01:30.738]                       inherits <- base::inherits
[11:01:30.738]                       invokeRestart <- base::invokeRestart
[11:01:30.738]                       is.null <- base::is.null
[11:01:30.738]                       muffled <- FALSE
[11:01:30.738]                       if (inherits(cond, "message")) {
[11:01:30.738]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.738]                         if (muffled) 
[11:01:30.738]                           invokeRestart("muffleMessage")
[11:01:30.738]                       }
[11:01:30.738]                       else if (inherits(cond, "warning")) {
[11:01:30.738]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.738]                         if (muffled) 
[11:01:30.738]                           invokeRestart("muffleWarning")
[11:01:30.738]                       }
[11:01:30.738]                       else if (inherits(cond, "condition")) {
[11:01:30.738]                         if (!is.null(pattern)) {
[11:01:30.738]                           computeRestarts <- base::computeRestarts
[11:01:30.738]                           grepl <- base::grepl
[11:01:30.738]                           restarts <- computeRestarts(cond)
[11:01:30.738]                           for (restart in restarts) {
[11:01:30.738]                             name <- restart$name
[11:01:30.738]                             if (is.null(name)) 
[11:01:30.738]                               next
[11:01:30.738]                             if (!grepl(pattern, name)) 
[11:01:30.738]                               next
[11:01:30.738]                             invokeRestart(restart)
[11:01:30.738]                             muffled <- TRUE
[11:01:30.738]                             break
[11:01:30.738]                           }
[11:01:30.738]                         }
[11:01:30.738]                       }
[11:01:30.738]                       invisible(muffled)
[11:01:30.738]                     }
[11:01:30.738]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.738]                   }
[11:01:30.738]                 }
[11:01:30.738]             }
[11:01:30.738]         }))
[11:01:30.738]     }, error = function(ex) {
[11:01:30.738]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.738]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.738]                 ...future.rng), started = ...future.startTime, 
[11:01:30.738]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.738]             version = "1.8"), class = "FutureResult")
[11:01:30.738]     }, finally = {
[11:01:30.738]         if (!identical(...future.workdir, getwd())) 
[11:01:30.738]             setwd(...future.workdir)
[11:01:30.738]         {
[11:01:30.738]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.738]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.738]             }
[11:01:30.738]             base::options(...future.oldOptions)
[11:01:30.738]             if (.Platform$OS.type == "windows") {
[11:01:30.738]                 old_names <- names(...future.oldEnvVars)
[11:01:30.738]                 envs <- base::Sys.getenv()
[11:01:30.738]                 names <- names(envs)
[11:01:30.738]                 common <- intersect(names, old_names)
[11:01:30.738]                 added <- setdiff(names, old_names)
[11:01:30.738]                 removed <- setdiff(old_names, names)
[11:01:30.738]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.738]                   envs[common]]
[11:01:30.738]                 NAMES <- toupper(changed)
[11:01:30.738]                 args <- list()
[11:01:30.738]                 for (kk in seq_along(NAMES)) {
[11:01:30.738]                   name <- changed[[kk]]
[11:01:30.738]                   NAME <- NAMES[[kk]]
[11:01:30.738]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.738]                     next
[11:01:30.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.738]                 }
[11:01:30.738]                 NAMES <- toupper(added)
[11:01:30.738]                 for (kk in seq_along(NAMES)) {
[11:01:30.738]                   name <- added[[kk]]
[11:01:30.738]                   NAME <- NAMES[[kk]]
[11:01:30.738]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.738]                     next
[11:01:30.738]                   args[[name]] <- ""
[11:01:30.738]                 }
[11:01:30.738]                 NAMES <- toupper(removed)
[11:01:30.738]                 for (kk in seq_along(NAMES)) {
[11:01:30.738]                   name <- removed[[kk]]
[11:01:30.738]                   NAME <- NAMES[[kk]]
[11:01:30.738]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.738]                     next
[11:01:30.738]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.738]                 }
[11:01:30.738]                 if (length(args) > 0) 
[11:01:30.738]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.738]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.738]             }
[11:01:30.738]             else {
[11:01:30.738]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.738]             }
[11:01:30.738]             {
[11:01:30.738]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.738]                   0L) {
[11:01:30.738]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.738]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.738]                   base::options(opts)
[11:01:30.738]                 }
[11:01:30.738]                 {
[11:01:30.738]                   {
[11:01:30.738]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.738]                     NULL
[11:01:30.738]                   }
[11:01:30.738]                   options(future.plan = NULL)
[11:01:30.738]                   if (is.na(NA_character_)) 
[11:01:30.738]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.738]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.738]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.738]                     .init = FALSE)
[11:01:30.738]                 }
[11:01:30.738]             }
[11:01:30.738]         }
[11:01:30.738]     })
[11:01:30.738]     if (TRUE) {
[11:01:30.738]         base::sink(type = "output", split = FALSE)
[11:01:30.738]         if (TRUE) {
[11:01:30.738]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.738]         }
[11:01:30.738]         else {
[11:01:30.738]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.738]         }
[11:01:30.738]         base::close(...future.stdout)
[11:01:30.738]         ...future.stdout <- NULL
[11:01:30.738]     }
[11:01:30.738]     ...future.result$conditions <- ...future.conditions
[11:01:30.738]     ...future.result$finished <- base::Sys.time()
[11:01:30.738]     ...future.result
[11:01:30.738] }
[11:01:30.741] requestCore(): workers = 2
[11:01:30.742] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:30.765] result() for MulticoreFuture ...
[11:01:30.765] result() for MulticoreFuture ...
[11:01:30.765] result() for MulticoreFuture ... done
[11:01:30.766] result() for MulticoreFuture ... done
[11:01:30.766] result() for MulticoreFuture ...
[11:01:30.766] result() for MulticoreFuture ... done
[11:01:30.769] MulticoreFuture started
[11:01:30.769] - Launch lazy future ... done
[11:01:30.769] run() for ‘MulticoreFuture’ ... done
[11:01:30.770] plan(): Setting new future strategy stack:
<environment: 0x55a9c84eaa38> 
[11:01:30.770] List of future strategies:
[11:01:30.770] 1. sequential:
[11:01:30.770]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.770]    - tweaked: FALSE
[11:01:30.770]    - call: NULL
[11:01:30.772] plan(): nbrOfWorkers() = 1
<environment: 0x55a9c64cdac8> 
[11:01:30.774] plan(): Setting new future strategy stack:
[11:01:30.774] List of future strategies:
[11:01:30.774] 1. multicore:
[11:01:30.774]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.774]    - tweaked: FALSE
[11:01:30.774]    - call: plan(strategy)
[11:01:30.778] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:30.780] resolve() on environment ...
[11:01:30.780]  recursive: 0
[11:01:30.781]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:30.781] signalConditionsASAP(numeric, pos=1) ...
[11:01:30.781] - nx: 4
[11:01:30.781] - relay: TRUE
[11:01:30.781] - stdout: TRUE
[11:01:30.781] - signal: TRUE
[11:01:30.782] - resignal: FALSE
[11:01:30.782] - force: TRUE
[11:01:30.782] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.782] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.782]  - until=2
[11:01:30.782]  - relaying element #2
[11:01:30.782] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:30.783] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.783] signalConditionsASAP(NULL, pos=1) ... done
[11:01:30.783]  length: 3 (resolved future 1)
[11:01:30.783] Future #2
[11:01:30.783] result() for MulticoreFuture ...
[11:01:30.783] result() for MulticoreFuture ... done
[11:01:30.783] result() for MulticoreFuture ...
[11:01:30.784] result() for MulticoreFuture ... done
[11:01:30.784] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:30.784] - nx: 4
[11:01:30.784] - relay: TRUE
[11:01:30.784] - stdout: TRUE
[11:01:30.784] - signal: TRUE
[11:01:30.784] - resignal: FALSE
[11:01:30.785] - force: TRUE
[11:01:30.785] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:30.785] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.785]  - until=2
[11:01:30.785]  - relaying element #2
[11:01:30.785] result() for MulticoreFuture ...
[11:01:30.785] result() for MulticoreFuture ... done
[11:01:30.786] result() for MulticoreFuture ...
[11:01:30.786] result() for MulticoreFuture ... done
[11:01:30.786] result() for MulticoreFuture ...
[11:01:30.786] result() for MulticoreFuture ... done
[11:01:30.786] result() for MulticoreFuture ...
[11:01:30.786] result() for MulticoreFuture ... done
[11:01:30.786] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:30.787] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:30.787] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:30.787]  length: 2 (resolved future 2)
[11:01:30.787] Future #3
[11:01:30.787] result() for MulticoreFuture ...
[11:01:30.788] result() for MulticoreFuture ...
[11:01:30.788] result() for MulticoreFuture ... done
[11:01:30.788] result() for MulticoreFuture ... done
[11:01:30.789] result() for MulticoreFuture ...
[11:01:30.789] result() for MulticoreFuture ... done
[11:01:30.789] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:30.789] - nx: 4
[11:01:30.789] - relay: TRUE
[11:01:30.789] - stdout: TRUE
[11:01:30.790] - signal: TRUE
[11:01:30.790] - resignal: FALSE
[11:01:30.790] - force: TRUE
[11:01:30.790] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:30.790] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:30.790]  - until=3
[11:01:30.791]  - relaying element #3
[11:01:30.791] result() for MulticoreFuture ...
[11:01:30.791] result() for MulticoreFuture ... done
[11:01:30.791] result() for MulticoreFuture ...
[11:01:30.791] result() for MulticoreFuture ... done
[11:01:30.792] result() for MulticoreFuture ...
[11:01:30.792] result() for MulticoreFuture ... done
[11:01:30.792] result() for MulticoreFuture ...
[11:01:30.792] result() for MulticoreFuture ... done
[11:01:30.792] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:30.792] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:30.792] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:30.793]  length: 1 (resolved future 3)
[11:01:30.793] Future #4
[11:01:30.793] result() for MulticoreFuture ...
[11:01:30.794] result() for MulticoreFuture ...
[11:01:30.794] result() for MulticoreFuture ... done
[11:01:30.794] result() for MulticoreFuture ... done
[11:01:30.794] result() for MulticoreFuture ...
[11:01:30.795] result() for MulticoreFuture ... done
[11:01:30.795] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:30.795] - nx: 4
[11:01:30.795] - relay: TRUE
[11:01:30.795] - stdout: TRUE
[11:01:30.795] - signal: TRUE
[11:01:30.796] - resignal: FALSE
[11:01:30.796] - force: TRUE
[11:01:30.796] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:30.796] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:30.796]  - until=4
[11:01:30.796]  - relaying element #4
[11:01:30.797] result() for MulticoreFuture ...
[11:01:30.797] result() for MulticoreFuture ... done
[11:01:30.797] result() for MulticoreFuture ...
[11:01:30.797] result() for MulticoreFuture ... done
[11:01:30.797] result() for MulticoreFuture ...
[11:01:30.797] result() for MulticoreFuture ... done
[11:01:30.798] result() for MulticoreFuture ...
[11:01:30.798] result() for MulticoreFuture ... done
[11:01:30.798] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.798] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:30.798] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:30.798]  length: 0 (resolved future 4)
[11:01:30.798] Relaying remaining futures
[11:01:30.799] signalConditionsASAP(NULL, pos=0) ...
[11:01:30.799] - nx: 4
[11:01:30.799] - relay: TRUE
[11:01:30.799] - stdout: TRUE
[11:01:30.799] - signal: TRUE
[11:01:30.799] - resignal: FALSE
[11:01:30.799] - force: TRUE
[11:01:30.799] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.799] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:30.799] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.800] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:30.800] signalConditionsASAP(NULL, pos=0) ... done
[11:01:30.800] resolve() on environment ... DONE
[11:01:30.800] result() for MulticoreFuture ...
[11:01:30.800] result() for MulticoreFuture ... done
[11:01:30.800] result() for MulticoreFuture ...
[11:01:30.800] result() for MulticoreFuture ... done
[11:01:30.800] result() for MulticoreFuture ...
[11:01:30.800] result() for MulticoreFuture ... done
[11:01:30.801] result() for MulticoreFuture ...
[11:01:30.801] result() for MulticoreFuture ... done
[11:01:30.801] result() for MulticoreFuture ...
[11:01:30.801] result() for MulticoreFuture ... done
[11:01:30.801] result() for MulticoreFuture ...
[11:01:30.801] result() for MulticoreFuture ... done
<environment: 0x55a9c6273408> 
Dimensions: c(2, 3)
[11:01:30.802] getGlobalsAndPackages() ...
[11:01:30.802] Searching for globals...
[11:01:30.802] 
[11:01:30.802] Searching for globals ... DONE
[11:01:30.802] - globals: [0] <none>
[11:01:30.802] getGlobalsAndPackages() ... DONE
[11:01:30.803] run() for ‘Future’ ...
[11:01:30.803] - state: ‘created’
[11:01:30.803] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.805] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.805] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.805]   - Field: ‘label’
[11:01:30.805]   - Field: ‘local’
[11:01:30.806]   - Field: ‘owner’
[11:01:30.806]   - Field: ‘envir’
[11:01:30.806]   - Field: ‘workers’
[11:01:30.806]   - Field: ‘packages’
[11:01:30.806]   - Field: ‘gc’
[11:01:30.806]   - Field: ‘job’
[11:01:30.806]   - Field: ‘conditions’
[11:01:30.806]   - Field: ‘expr’
[11:01:30.806]   - Field: ‘uuid’
[11:01:30.806]   - Field: ‘seed’
[11:01:30.807]   - Field: ‘version’
[11:01:30.807]   - Field: ‘result’
[11:01:30.807]   - Field: ‘asynchronous’
[11:01:30.807]   - Field: ‘calls’
[11:01:30.807]   - Field: ‘globals’
[11:01:30.807]   - Field: ‘stdout’
[11:01:30.807]   - Field: ‘earlySignal’
[11:01:30.807]   - Field: ‘lazy’
[11:01:30.807]   - Field: ‘state’
[11:01:30.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.808] - Launch lazy future ...
[11:01:30.808] Packages needed by the future expression (n = 0): <none>
[11:01:30.808] Packages needed by future strategies (n = 0): <none>
[11:01:30.809] {
[11:01:30.809]     {
[11:01:30.809]         {
[11:01:30.809]             ...future.startTime <- base::Sys.time()
[11:01:30.809]             {
[11:01:30.809]                 {
[11:01:30.809]                   {
[11:01:30.809]                     {
[11:01:30.809]                       base::local({
[11:01:30.809]                         has_future <- base::requireNamespace("future", 
[11:01:30.809]                           quietly = TRUE)
[11:01:30.809]                         if (has_future) {
[11:01:30.809]                           ns <- base::getNamespace("future")
[11:01:30.809]                           version <- ns[[".package"]][["version"]]
[11:01:30.809]                           if (is.null(version)) 
[11:01:30.809]                             version <- utils::packageVersion("future")
[11:01:30.809]                         }
[11:01:30.809]                         else {
[11:01:30.809]                           version <- NULL
[11:01:30.809]                         }
[11:01:30.809]                         if (!has_future || version < "1.8.0") {
[11:01:30.809]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.809]                             "", base::R.version$version.string), 
[11:01:30.809]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.809]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.809]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.809]                               "release", "version")], collapse = " "), 
[11:01:30.809]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.809]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.809]                             info)
[11:01:30.809]                           info <- base::paste(info, collapse = "; ")
[11:01:30.809]                           if (!has_future) {
[11:01:30.809]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.809]                               info)
[11:01:30.809]                           }
[11:01:30.809]                           else {
[11:01:30.809]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.809]                               info, version)
[11:01:30.809]                           }
[11:01:30.809]                           base::stop(msg)
[11:01:30.809]                         }
[11:01:30.809]                       })
[11:01:30.809]                     }
[11:01:30.809]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.809]                     base::options(mc.cores = 1L)
[11:01:30.809]                   }
[11:01:30.809]                   ...future.strategy.old <- future::plan("list")
[11:01:30.809]                   options(future.plan = NULL)
[11:01:30.809]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.809]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.809]                 }
[11:01:30.809]                 ...future.workdir <- getwd()
[11:01:30.809]             }
[11:01:30.809]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.809]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.809]         }
[11:01:30.809]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.809]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.809]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.809]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.809]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.809]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.809]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.809]             base::names(...future.oldOptions))
[11:01:30.809]     }
[11:01:30.809]     if (FALSE) {
[11:01:30.809]     }
[11:01:30.809]     else {
[11:01:30.809]         if (TRUE) {
[11:01:30.809]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.809]                 open = "w")
[11:01:30.809]         }
[11:01:30.809]         else {
[11:01:30.809]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.809]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.809]         }
[11:01:30.809]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.809]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.809]             base::sink(type = "output", split = FALSE)
[11:01:30.809]             base::close(...future.stdout)
[11:01:30.809]         }, add = TRUE)
[11:01:30.809]     }
[11:01:30.809]     ...future.frame <- base::sys.nframe()
[11:01:30.809]     ...future.conditions <- base::list()
[11:01:30.809]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.809]     if (FALSE) {
[11:01:30.809]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.809]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.809]     }
[11:01:30.809]     ...future.result <- base::tryCatch({
[11:01:30.809]         base::withCallingHandlers({
[11:01:30.809]             ...future.value <- base::withVisible(base::local({
[11:01:30.809]                 withCallingHandlers({
[11:01:30.809]                   2
[11:01:30.809]                 }, immediateCondition = function(cond) {
[11:01:30.809]                   save_rds <- function (object, pathname, ...) 
[11:01:30.809]                   {
[11:01:30.809]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.809]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.809]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.809]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.809]                         fi_tmp[["mtime"]])
[11:01:30.809]                     }
[11:01:30.809]                     tryCatch({
[11:01:30.809]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.809]                     }, error = function(ex) {
[11:01:30.809]                       msg <- conditionMessage(ex)
[11:01:30.809]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.809]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.809]                         fi_tmp[["mtime"]], msg)
[11:01:30.809]                       ex$message <- msg
[11:01:30.809]                       stop(ex)
[11:01:30.809]                     })
[11:01:30.809]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.809]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.809]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.809]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.809]                       fi <- file.info(pathname)
[11:01:30.809]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.809]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.809]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.809]                         fi[["size"]], fi[["mtime"]])
[11:01:30.809]                       stop(msg)
[11:01:30.809]                     }
[11:01:30.809]                     invisible(pathname)
[11:01:30.809]                   }
[11:01:30.809]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.809]                     rootPath = tempdir()) 
[11:01:30.809]                   {
[11:01:30.809]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.809]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.809]                       tmpdir = path, fileext = ".rds")
[11:01:30.809]                     save_rds(obj, file)
[11:01:30.809]                   }
[11:01:30.809]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.809]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.809]                   {
[11:01:30.809]                     inherits <- base::inherits
[11:01:30.809]                     invokeRestart <- base::invokeRestart
[11:01:30.809]                     is.null <- base::is.null
[11:01:30.809]                     muffled <- FALSE
[11:01:30.809]                     if (inherits(cond, "message")) {
[11:01:30.809]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.809]                       if (muffled) 
[11:01:30.809]                         invokeRestart("muffleMessage")
[11:01:30.809]                     }
[11:01:30.809]                     else if (inherits(cond, "warning")) {
[11:01:30.809]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.809]                       if (muffled) 
[11:01:30.809]                         invokeRestart("muffleWarning")
[11:01:30.809]                     }
[11:01:30.809]                     else if (inherits(cond, "condition")) {
[11:01:30.809]                       if (!is.null(pattern)) {
[11:01:30.809]                         computeRestarts <- base::computeRestarts
[11:01:30.809]                         grepl <- base::grepl
[11:01:30.809]                         restarts <- computeRestarts(cond)
[11:01:30.809]                         for (restart in restarts) {
[11:01:30.809]                           name <- restart$name
[11:01:30.809]                           if (is.null(name)) 
[11:01:30.809]                             next
[11:01:30.809]                           if (!grepl(pattern, name)) 
[11:01:30.809]                             next
[11:01:30.809]                           invokeRestart(restart)
[11:01:30.809]                           muffled <- TRUE
[11:01:30.809]                           break
[11:01:30.809]                         }
[11:01:30.809]                       }
[11:01:30.809]                     }
[11:01:30.809]                     invisible(muffled)
[11:01:30.809]                   }
[11:01:30.809]                   muffleCondition(cond)
[11:01:30.809]                 })
[11:01:30.809]             }))
[11:01:30.809]             future::FutureResult(value = ...future.value$value, 
[11:01:30.809]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.809]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.809]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.809]                     ...future.globalenv.names))
[11:01:30.809]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.809]         }, condition = base::local({
[11:01:30.809]             c <- base::c
[11:01:30.809]             inherits <- base::inherits
[11:01:30.809]             invokeRestart <- base::invokeRestart
[11:01:30.809]             length <- base::length
[11:01:30.809]             list <- base::list
[11:01:30.809]             seq.int <- base::seq.int
[11:01:30.809]             signalCondition <- base::signalCondition
[11:01:30.809]             sys.calls <- base::sys.calls
[11:01:30.809]             `[[` <- base::`[[`
[11:01:30.809]             `+` <- base::`+`
[11:01:30.809]             `<<-` <- base::`<<-`
[11:01:30.809]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.809]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.809]                   3L)]
[11:01:30.809]             }
[11:01:30.809]             function(cond) {
[11:01:30.809]                 is_error <- inherits(cond, "error")
[11:01:30.809]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.809]                   NULL)
[11:01:30.809]                 if (is_error) {
[11:01:30.809]                   sessionInformation <- function() {
[11:01:30.809]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.809]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.809]                       search = base::search(), system = base::Sys.info())
[11:01:30.809]                   }
[11:01:30.809]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.809]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.809]                     cond$call), session = sessionInformation(), 
[11:01:30.809]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.809]                   signalCondition(cond)
[11:01:30.809]                 }
[11:01:30.809]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.809]                 "immediateCondition"))) {
[11:01:30.809]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.809]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.809]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.809]                   if (TRUE && !signal) {
[11:01:30.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.809]                     {
[11:01:30.809]                       inherits <- base::inherits
[11:01:30.809]                       invokeRestart <- base::invokeRestart
[11:01:30.809]                       is.null <- base::is.null
[11:01:30.809]                       muffled <- FALSE
[11:01:30.809]                       if (inherits(cond, "message")) {
[11:01:30.809]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.809]                         if (muffled) 
[11:01:30.809]                           invokeRestart("muffleMessage")
[11:01:30.809]                       }
[11:01:30.809]                       else if (inherits(cond, "warning")) {
[11:01:30.809]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.809]                         if (muffled) 
[11:01:30.809]                           invokeRestart("muffleWarning")
[11:01:30.809]                       }
[11:01:30.809]                       else if (inherits(cond, "condition")) {
[11:01:30.809]                         if (!is.null(pattern)) {
[11:01:30.809]                           computeRestarts <- base::computeRestarts
[11:01:30.809]                           grepl <- base::grepl
[11:01:30.809]                           restarts <- computeRestarts(cond)
[11:01:30.809]                           for (restart in restarts) {
[11:01:30.809]                             name <- restart$name
[11:01:30.809]                             if (is.null(name)) 
[11:01:30.809]                               next
[11:01:30.809]                             if (!grepl(pattern, name)) 
[11:01:30.809]                               next
[11:01:30.809]                             invokeRestart(restart)
[11:01:30.809]                             muffled <- TRUE
[11:01:30.809]                             break
[11:01:30.809]                           }
[11:01:30.809]                         }
[11:01:30.809]                       }
[11:01:30.809]                       invisible(muffled)
[11:01:30.809]                     }
[11:01:30.809]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.809]                   }
[11:01:30.809]                 }
[11:01:30.809]                 else {
[11:01:30.809]                   if (TRUE) {
[11:01:30.809]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.809]                     {
[11:01:30.809]                       inherits <- base::inherits
[11:01:30.809]                       invokeRestart <- base::invokeRestart
[11:01:30.809]                       is.null <- base::is.null
[11:01:30.809]                       muffled <- FALSE
[11:01:30.809]                       if (inherits(cond, "message")) {
[11:01:30.809]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.809]                         if (muffled) 
[11:01:30.809]                           invokeRestart("muffleMessage")
[11:01:30.809]                       }
[11:01:30.809]                       else if (inherits(cond, "warning")) {
[11:01:30.809]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.809]                         if (muffled) 
[11:01:30.809]                           invokeRestart("muffleWarning")
[11:01:30.809]                       }
[11:01:30.809]                       else if (inherits(cond, "condition")) {
[11:01:30.809]                         if (!is.null(pattern)) {
[11:01:30.809]                           computeRestarts <- base::computeRestarts
[11:01:30.809]                           grepl <- base::grepl
[11:01:30.809]                           restarts <- computeRestarts(cond)
[11:01:30.809]                           for (restart in restarts) {
[11:01:30.809]                             name <- restart$name
[11:01:30.809]                             if (is.null(name)) 
[11:01:30.809]                               next
[11:01:30.809]                             if (!grepl(pattern, name)) 
[11:01:30.809]                               next
[11:01:30.809]                             invokeRestart(restart)
[11:01:30.809]                             muffled <- TRUE
[11:01:30.809]                             break
[11:01:30.809]                           }
[11:01:30.809]                         }
[11:01:30.809]                       }
[11:01:30.809]                       invisible(muffled)
[11:01:30.809]                     }
[11:01:30.809]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.809]                   }
[11:01:30.809]                 }
[11:01:30.809]             }
[11:01:30.809]         }))
[11:01:30.809]     }, error = function(ex) {
[11:01:30.809]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.809]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.809]                 ...future.rng), started = ...future.startTime, 
[11:01:30.809]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.809]             version = "1.8"), class = "FutureResult")
[11:01:30.809]     }, finally = {
[11:01:30.809]         if (!identical(...future.workdir, getwd())) 
[11:01:30.809]             setwd(...future.workdir)
[11:01:30.809]         {
[11:01:30.809]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.809]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.809]             }
[11:01:30.809]             base::options(...future.oldOptions)
[11:01:30.809]             if (.Platform$OS.type == "windows") {
[11:01:30.809]                 old_names <- names(...future.oldEnvVars)
[11:01:30.809]                 envs <- base::Sys.getenv()
[11:01:30.809]                 names <- names(envs)
[11:01:30.809]                 common <- intersect(names, old_names)
[11:01:30.809]                 added <- setdiff(names, old_names)
[11:01:30.809]                 removed <- setdiff(old_names, names)
[11:01:30.809]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.809]                   envs[common]]
[11:01:30.809]                 NAMES <- toupper(changed)
[11:01:30.809]                 args <- list()
[11:01:30.809]                 for (kk in seq_along(NAMES)) {
[11:01:30.809]                   name <- changed[[kk]]
[11:01:30.809]                   NAME <- NAMES[[kk]]
[11:01:30.809]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.809]                     next
[11:01:30.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.809]                 }
[11:01:30.809]                 NAMES <- toupper(added)
[11:01:30.809]                 for (kk in seq_along(NAMES)) {
[11:01:30.809]                   name <- added[[kk]]
[11:01:30.809]                   NAME <- NAMES[[kk]]
[11:01:30.809]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.809]                     next
[11:01:30.809]                   args[[name]] <- ""
[11:01:30.809]                 }
[11:01:30.809]                 NAMES <- toupper(removed)
[11:01:30.809]                 for (kk in seq_along(NAMES)) {
[11:01:30.809]                   name <- removed[[kk]]
[11:01:30.809]                   NAME <- NAMES[[kk]]
[11:01:30.809]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.809]                     next
[11:01:30.809]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.809]                 }
[11:01:30.809]                 if (length(args) > 0) 
[11:01:30.809]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.809]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.809]             }
[11:01:30.809]             else {
[11:01:30.809]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.809]             }
[11:01:30.809]             {
[11:01:30.809]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.809]                   0L) {
[11:01:30.809]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.809]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.809]                   base::options(opts)
[11:01:30.809]                 }
[11:01:30.809]                 {
[11:01:30.809]                   {
[11:01:30.809]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.809]                     NULL
[11:01:30.809]                   }
[11:01:30.809]                   options(future.plan = NULL)
[11:01:30.809]                   if (is.na(NA_character_)) 
[11:01:30.809]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.809]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.809]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.809]                     .init = FALSE)
[11:01:30.809]                 }
[11:01:30.809]             }
[11:01:30.809]         }
[11:01:30.809]     })
[11:01:30.809]     if (TRUE) {
[11:01:30.809]         base::sink(type = "output", split = FALSE)
[11:01:30.809]         if (TRUE) {
[11:01:30.809]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.809]         }
[11:01:30.809]         else {
[11:01:30.809]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.809]         }
[11:01:30.809]         base::close(...future.stdout)
[11:01:30.809]         ...future.stdout <- NULL
[11:01:30.809]     }
[11:01:30.809]     ...future.result$conditions <- ...future.conditions
[11:01:30.809]     ...future.result$finished <- base::Sys.time()
[11:01:30.809]     ...future.result
[11:01:30.809] }
[11:01:30.811] requestCore(): workers = 2
[11:01:30.813] MulticoreFuture started
[11:01:30.814] - Launch lazy future ... done
[11:01:30.814] run() for ‘MulticoreFuture’ ... done
[11:01:30.814] getGlobalsAndPackages() ...
[11:01:30.814] Searching for globals...
[11:01:30.814] plan(): Setting new future strategy stack:
[11:01:30.815] 
[11:01:30.815] Searching for globals ... DONE
[11:01:30.815] List of future strategies:
[11:01:30.815] 1. sequential:
[11:01:30.815]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.815]    - tweaked: FALSE
[11:01:30.815]    - call: NULL
[11:01:30.815] - globals: [0] <none>
[11:01:30.816] getGlobalsAndPackages() ... DONE
[11:01:30.816] plan(): nbrOfWorkers() = 1
[11:01:30.816] run() for ‘Future’ ...
[11:01:30.816] - state: ‘created’
[11:01:30.816] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.817] plan(): Setting new future strategy stack:
[11:01:30.817] List of future strategies:
[11:01:30.817] 1. multicore:
[11:01:30.817]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.817]    - tweaked: FALSE
[11:01:30.817]    - call: plan(strategy)
[11:01:30.820] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.820] plan(): nbrOfWorkers() = 2
[11:01:30.820] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.820]   - Field: ‘label’
[11:01:30.820]   - Field: ‘local’
[11:01:30.820]   - Field: ‘owner’
[11:01:30.820]   - Field: ‘envir’
[11:01:30.820]   - Field: ‘workers’
[11:01:30.821]   - Field: ‘packages’
[11:01:30.821]   - Field: ‘gc’
[11:01:30.821]   - Field: ‘job’
[11:01:30.821]   - Field: ‘conditions’
[11:01:30.821]   - Field: ‘expr’
[11:01:30.821]   - Field: ‘uuid’
[11:01:30.821]   - Field: ‘seed’
[11:01:30.822]   - Field: ‘version’
[11:01:30.822]   - Field: ‘result’
[11:01:30.822]   - Field: ‘asynchronous’
[11:01:30.822]   - Field: ‘calls’
[11:01:30.822]   - Field: ‘globals’
[11:01:30.822]   - Field: ‘stdout’
[11:01:30.822]   - Field: ‘earlySignal’
[11:01:30.822]   - Field: ‘lazy’
[11:01:30.823]   - Field: ‘state’
[11:01:30.823] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.823] - Launch lazy future ...
[11:01:30.823] Packages needed by the future expression (n = 0): <none>
[11:01:30.823] Packages needed by future strategies (n = 0): <none>
[11:01:30.824] {
[11:01:30.824]     {
[11:01:30.824]         {
[11:01:30.824]             ...future.startTime <- base::Sys.time()
[11:01:30.824]             {
[11:01:30.824]                 {
[11:01:30.824]                   {
[11:01:30.824]                     {
[11:01:30.824]                       base::local({
[11:01:30.824]                         has_future <- base::requireNamespace("future", 
[11:01:30.824]                           quietly = TRUE)
[11:01:30.824]                         if (has_future) {
[11:01:30.824]                           ns <- base::getNamespace("future")
[11:01:30.824]                           version <- ns[[".package"]][["version"]]
[11:01:30.824]                           if (is.null(version)) 
[11:01:30.824]                             version <- utils::packageVersion("future")
[11:01:30.824]                         }
[11:01:30.824]                         else {
[11:01:30.824]                           version <- NULL
[11:01:30.824]                         }
[11:01:30.824]                         if (!has_future || version < "1.8.0") {
[11:01:30.824]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.824]                             "", base::R.version$version.string), 
[11:01:30.824]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.824]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.824]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.824]                               "release", "version")], collapse = " "), 
[11:01:30.824]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.824]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.824]                             info)
[11:01:30.824]                           info <- base::paste(info, collapse = "; ")
[11:01:30.824]                           if (!has_future) {
[11:01:30.824]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.824]                               info)
[11:01:30.824]                           }
[11:01:30.824]                           else {
[11:01:30.824]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.824]                               info, version)
[11:01:30.824]                           }
[11:01:30.824]                           base::stop(msg)
[11:01:30.824]                         }
[11:01:30.824]                       })
[11:01:30.824]                     }
[11:01:30.824]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.824]                     base::options(mc.cores = 1L)
[11:01:30.824]                   }
[11:01:30.824]                   ...future.strategy.old <- future::plan("list")
[11:01:30.824]                   options(future.plan = NULL)
[11:01:30.824]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.824]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.824]                 }
[11:01:30.824]                 ...future.workdir <- getwd()
[11:01:30.824]             }
[11:01:30.824]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.824]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.824]         }
[11:01:30.824]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.824]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.824]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.824]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.824]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.824]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.824]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.824]             base::names(...future.oldOptions))
[11:01:30.824]     }
[11:01:30.824]     if (FALSE) {
[11:01:30.824]     }
[11:01:30.824]     else {
[11:01:30.824]         if (TRUE) {
[11:01:30.824]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.824]                 open = "w")
[11:01:30.824]         }
[11:01:30.824]         else {
[11:01:30.824]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.824]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.824]         }
[11:01:30.824]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.824]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.824]             base::sink(type = "output", split = FALSE)
[11:01:30.824]             base::close(...future.stdout)
[11:01:30.824]         }, add = TRUE)
[11:01:30.824]     }
[11:01:30.824]     ...future.frame <- base::sys.nframe()
[11:01:30.824]     ...future.conditions <- base::list()
[11:01:30.824]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.824]     if (FALSE) {
[11:01:30.824]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.824]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.824]     }
[11:01:30.824]     ...future.result <- base::tryCatch({
[11:01:30.824]         base::withCallingHandlers({
[11:01:30.824]             ...future.value <- base::withVisible(base::local({
[11:01:30.824]                 withCallingHandlers({
[11:01:30.824]                   NULL
[11:01:30.824]                 }, immediateCondition = function(cond) {
[11:01:30.824]                   save_rds <- function (object, pathname, ...) 
[11:01:30.824]                   {
[11:01:30.824]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.824]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.824]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.824]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.824]                         fi_tmp[["mtime"]])
[11:01:30.824]                     }
[11:01:30.824]                     tryCatch({
[11:01:30.824]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.824]                     }, error = function(ex) {
[11:01:30.824]                       msg <- conditionMessage(ex)
[11:01:30.824]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.824]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.824]                         fi_tmp[["mtime"]], msg)
[11:01:30.824]                       ex$message <- msg
[11:01:30.824]                       stop(ex)
[11:01:30.824]                     })
[11:01:30.824]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.824]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.824]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.824]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.824]                       fi <- file.info(pathname)
[11:01:30.824]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.824]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.824]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.824]                         fi[["size"]], fi[["mtime"]])
[11:01:30.824]                       stop(msg)
[11:01:30.824]                     }
[11:01:30.824]                     invisible(pathname)
[11:01:30.824]                   }
[11:01:30.824]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.824]                     rootPath = tempdir()) 
[11:01:30.824]                   {
[11:01:30.824]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.824]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.824]                       tmpdir = path, fileext = ".rds")
[11:01:30.824]                     save_rds(obj, file)
[11:01:30.824]                   }
[11:01:30.824]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.824]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.824]                   {
[11:01:30.824]                     inherits <- base::inherits
[11:01:30.824]                     invokeRestart <- base::invokeRestart
[11:01:30.824]                     is.null <- base::is.null
[11:01:30.824]                     muffled <- FALSE
[11:01:30.824]                     if (inherits(cond, "message")) {
[11:01:30.824]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.824]                       if (muffled) 
[11:01:30.824]                         invokeRestart("muffleMessage")
[11:01:30.824]                     }
[11:01:30.824]                     else if (inherits(cond, "warning")) {
[11:01:30.824]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.824]                       if (muffled) 
[11:01:30.824]                         invokeRestart("muffleWarning")
[11:01:30.824]                     }
[11:01:30.824]                     else if (inherits(cond, "condition")) {
[11:01:30.824]                       if (!is.null(pattern)) {
[11:01:30.824]                         computeRestarts <- base::computeRestarts
[11:01:30.824]                         grepl <- base::grepl
[11:01:30.824]                         restarts <- computeRestarts(cond)
[11:01:30.824]                         for (restart in restarts) {
[11:01:30.824]                           name <- restart$name
[11:01:30.824]                           if (is.null(name)) 
[11:01:30.824]                             next
[11:01:30.824]                           if (!grepl(pattern, name)) 
[11:01:30.824]                             next
[11:01:30.824]                           invokeRestart(restart)
[11:01:30.824]                           muffled <- TRUE
[11:01:30.824]                           break
[11:01:30.824]                         }
[11:01:30.824]                       }
[11:01:30.824]                     }
[11:01:30.824]                     invisible(muffled)
[11:01:30.824]                   }
[11:01:30.824]                   muffleCondition(cond)
[11:01:30.824]                 })
[11:01:30.824]             }))
[11:01:30.824]             future::FutureResult(value = ...future.value$value, 
[11:01:30.824]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.824]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.824]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.824]                     ...future.globalenv.names))
[11:01:30.824]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.824]         }, condition = base::local({
[11:01:30.824]             c <- base::c
[11:01:30.824]             inherits <- base::inherits
[11:01:30.824]             invokeRestart <- base::invokeRestart
[11:01:30.824]             length <- base::length
[11:01:30.824]             list <- base::list
[11:01:30.824]             seq.int <- base::seq.int
[11:01:30.824]             signalCondition <- base::signalCondition
[11:01:30.824]             sys.calls <- base::sys.calls
[11:01:30.824]             `[[` <- base::`[[`
[11:01:30.824]             `+` <- base::`+`
[11:01:30.824]             `<<-` <- base::`<<-`
[11:01:30.824]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.824]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.824]                   3L)]
[11:01:30.824]             }
[11:01:30.824]             function(cond) {
[11:01:30.824]                 is_error <- inherits(cond, "error")
[11:01:30.824]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.824]                   NULL)
[11:01:30.824]                 if (is_error) {
[11:01:30.824]                   sessionInformation <- function() {
[11:01:30.824]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.824]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.824]                       search = base::search(), system = base::Sys.info())
[11:01:30.824]                   }
[11:01:30.824]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.824]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.824]                     cond$call), session = sessionInformation(), 
[11:01:30.824]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.824]                   signalCondition(cond)
[11:01:30.824]                 }
[11:01:30.824]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.824]                 "immediateCondition"))) {
[11:01:30.824]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.824]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.824]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.824]                   if (TRUE && !signal) {
[11:01:30.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.824]                     {
[11:01:30.824]                       inherits <- base::inherits
[11:01:30.824]                       invokeRestart <- base::invokeRestart
[11:01:30.824]                       is.null <- base::is.null
[11:01:30.824]                       muffled <- FALSE
[11:01:30.824]                       if (inherits(cond, "message")) {
[11:01:30.824]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.824]                         if (muffled) 
[11:01:30.824]                           invokeRestart("muffleMessage")
[11:01:30.824]                       }
[11:01:30.824]                       else if (inherits(cond, "warning")) {
[11:01:30.824]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.824]                         if (muffled) 
[11:01:30.824]                           invokeRestart("muffleWarning")
[11:01:30.824]                       }
[11:01:30.824]                       else if (inherits(cond, "condition")) {
[11:01:30.824]                         if (!is.null(pattern)) {
[11:01:30.824]                           computeRestarts <- base::computeRestarts
[11:01:30.824]                           grepl <- base::grepl
[11:01:30.824]                           restarts <- computeRestarts(cond)
[11:01:30.824]                           for (restart in restarts) {
[11:01:30.824]                             name <- restart$name
[11:01:30.824]                             if (is.null(name)) 
[11:01:30.824]                               next
[11:01:30.824]                             if (!grepl(pattern, name)) 
[11:01:30.824]                               next
[11:01:30.824]                             invokeRestart(restart)
[11:01:30.824]                             muffled <- TRUE
[11:01:30.824]                             break
[11:01:30.824]                           }
[11:01:30.824]                         }
[11:01:30.824]                       }
[11:01:30.824]                       invisible(muffled)
[11:01:30.824]                     }
[11:01:30.824]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.824]                   }
[11:01:30.824]                 }
[11:01:30.824]                 else {
[11:01:30.824]                   if (TRUE) {
[11:01:30.824]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.824]                     {
[11:01:30.824]                       inherits <- base::inherits
[11:01:30.824]                       invokeRestart <- base::invokeRestart
[11:01:30.824]                       is.null <- base::is.null
[11:01:30.824]                       muffled <- FALSE
[11:01:30.824]                       if (inherits(cond, "message")) {
[11:01:30.824]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.824]                         if (muffled) 
[11:01:30.824]                           invokeRestart("muffleMessage")
[11:01:30.824]                       }
[11:01:30.824]                       else if (inherits(cond, "warning")) {
[11:01:30.824]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.824]                         if (muffled) 
[11:01:30.824]                           invokeRestart("muffleWarning")
[11:01:30.824]                       }
[11:01:30.824]                       else if (inherits(cond, "condition")) {
[11:01:30.824]                         if (!is.null(pattern)) {
[11:01:30.824]                           computeRestarts <- base::computeRestarts
[11:01:30.824]                           grepl <- base::grepl
[11:01:30.824]                           restarts <- computeRestarts(cond)
[11:01:30.824]                           for (restart in restarts) {
[11:01:30.824]                             name <- restart$name
[11:01:30.824]                             if (is.null(name)) 
[11:01:30.824]                               next
[11:01:30.824]                             if (!grepl(pattern, name)) 
[11:01:30.824]                               next
[11:01:30.824]                             invokeRestart(restart)
[11:01:30.824]                             muffled <- TRUE
[11:01:30.824]                             break
[11:01:30.824]                           }
[11:01:30.824]                         }
[11:01:30.824]                       }
[11:01:30.824]                       invisible(muffled)
[11:01:30.824]                     }
[11:01:30.824]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.824]                   }
[11:01:30.824]                 }
[11:01:30.824]             }
[11:01:30.824]         }))
[11:01:30.824]     }, error = function(ex) {
[11:01:30.824]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.824]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.824]                 ...future.rng), started = ...future.startTime, 
[11:01:30.824]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.824]             version = "1.8"), class = "FutureResult")
[11:01:30.824]     }, finally = {
[11:01:30.824]         if (!identical(...future.workdir, getwd())) 
[11:01:30.824]             setwd(...future.workdir)
[11:01:30.824]         {
[11:01:30.824]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.824]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.824]             }
[11:01:30.824]             base::options(...future.oldOptions)
[11:01:30.824]             if (.Platform$OS.type == "windows") {
[11:01:30.824]                 old_names <- names(...future.oldEnvVars)
[11:01:30.824]                 envs <- base::Sys.getenv()
[11:01:30.824]                 names <- names(envs)
[11:01:30.824]                 common <- intersect(names, old_names)
[11:01:30.824]                 added <- setdiff(names, old_names)
[11:01:30.824]                 removed <- setdiff(old_names, names)
[11:01:30.824]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.824]                   envs[common]]
[11:01:30.824]                 NAMES <- toupper(changed)
[11:01:30.824]                 args <- list()
[11:01:30.824]                 for (kk in seq_along(NAMES)) {
[11:01:30.824]                   name <- changed[[kk]]
[11:01:30.824]                   NAME <- NAMES[[kk]]
[11:01:30.824]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.824]                     next
[11:01:30.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.824]                 }
[11:01:30.824]                 NAMES <- toupper(added)
[11:01:30.824]                 for (kk in seq_along(NAMES)) {
[11:01:30.824]                   name <- added[[kk]]
[11:01:30.824]                   NAME <- NAMES[[kk]]
[11:01:30.824]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.824]                     next
[11:01:30.824]                   args[[name]] <- ""
[11:01:30.824]                 }
[11:01:30.824]                 NAMES <- toupper(removed)
[11:01:30.824]                 for (kk in seq_along(NAMES)) {
[11:01:30.824]                   name <- removed[[kk]]
[11:01:30.824]                   NAME <- NAMES[[kk]]
[11:01:30.824]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.824]                     next
[11:01:30.824]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.824]                 }
[11:01:30.824]                 if (length(args) > 0) 
[11:01:30.824]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.824]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.824]             }
[11:01:30.824]             else {
[11:01:30.824]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.824]             }
[11:01:30.824]             {
[11:01:30.824]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.824]                   0L) {
[11:01:30.824]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.824]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.824]                   base::options(opts)
[11:01:30.824]                 }
[11:01:30.824]                 {
[11:01:30.824]                   {
[11:01:30.824]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.824]                     NULL
[11:01:30.824]                   }
[11:01:30.824]                   options(future.plan = NULL)
[11:01:30.824]                   if (is.na(NA_character_)) 
[11:01:30.824]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.824]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.824]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.824]                     .init = FALSE)
[11:01:30.824]                 }
[11:01:30.824]             }
[11:01:30.824]         }
[11:01:30.824]     })
[11:01:30.824]     if (TRUE) {
[11:01:30.824]         base::sink(type = "output", split = FALSE)
[11:01:30.824]         if (TRUE) {
[11:01:30.824]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.824]         }
[11:01:30.824]         else {
[11:01:30.824]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.824]         }
[11:01:30.824]         base::close(...future.stdout)
[11:01:30.824]         ...future.stdout <- NULL
[11:01:30.824]     }
[11:01:30.824]     ...future.result$conditions <- ...future.conditions
[11:01:30.824]     ...future.result$finished <- base::Sys.time()
[11:01:30.824]     ...future.result
[11:01:30.824] }
[11:01:30.828] requestCore(): workers = 2
[11:01:30.830] MulticoreFuture started
[11:01:30.830] - Launch lazy future ... done
[11:01:30.830] run() for ‘MulticoreFuture’ ... done
[11:01:30.831] plan(): Setting new future strategy stack:
[11:01:30.831] getGlobalsAndPackages() ...
[11:01:30.831] Searching for globals...
[11:01:30.831] List of future strategies:
[11:01:30.831] 1. sequential:
[11:01:30.831]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.831]    - tweaked: FALSE
[11:01:30.831]    - call: NULL
[11:01:30.832] plan(): nbrOfWorkers() = 1
[11:01:30.832] - globals found: [1] ‘{’
[11:01:30.833] Searching for globals ... DONE
[11:01:30.833] Resolving globals: FALSE
[11:01:30.833] 
[11:01:30.833] 
[11:01:30.834] getGlobalsAndPackages() ... DONE
[11:01:30.834] run() for ‘Future’ ...
[11:01:30.834] plan(): Setting new future strategy stack:
[11:01:30.834] - state: ‘created’
[11:01:30.834] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.834] List of future strategies:
[11:01:30.834] 1. multicore:
[11:01:30.834]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.834]    - tweaked: FALSE
[11:01:30.834]    - call: plan(strategy)
[11:01:30.837] plan(): nbrOfWorkers() = 2
[11:01:30.837] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.837] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.838]   - Field: ‘label’
[11:01:30.838]   - Field: ‘local’
[11:01:30.838]   - Field: ‘owner’
[11:01:30.838]   - Field: ‘envir’
[11:01:30.838]   - Field: ‘workers’
[11:01:30.838]   - Field: ‘packages’
[11:01:30.838]   - Field: ‘gc’
[11:01:30.838]   - Field: ‘job’
[11:01:30.839]   - Field: ‘conditions’
[11:01:30.839]   - Field: ‘expr’
[11:01:30.839]   - Field: ‘uuid’
[11:01:30.839]   - Field: ‘seed’
[11:01:30.839]   - Field: ‘version’
[11:01:30.839]   - Field: ‘result’
[11:01:30.839]   - Field: ‘asynchronous’
[11:01:30.839]   - Field: ‘calls’
[11:01:30.840]   - Field: ‘globals’
[11:01:30.840]   - Field: ‘stdout’
[11:01:30.840]   - Field: ‘earlySignal’
[11:01:30.840]   - Field: ‘lazy’
[11:01:30.840]   - Field: ‘state’
[11:01:30.840] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.840] - Launch lazy future ...
[11:01:30.841] Packages needed by the future expression (n = 0): <none>
[11:01:30.841] Packages needed by future strategies (n = 0): <none>
[11:01:30.842] {
[11:01:30.842]     {
[11:01:30.842]         {
[11:01:30.842]             ...future.startTime <- base::Sys.time()
[11:01:30.842]             {
[11:01:30.842]                 {
[11:01:30.842]                   {
[11:01:30.842]                     {
[11:01:30.842]                       base::local({
[11:01:30.842]                         has_future <- base::requireNamespace("future", 
[11:01:30.842]                           quietly = TRUE)
[11:01:30.842]                         if (has_future) {
[11:01:30.842]                           ns <- base::getNamespace("future")
[11:01:30.842]                           version <- ns[[".package"]][["version"]]
[11:01:30.842]                           if (is.null(version)) 
[11:01:30.842]                             version <- utils::packageVersion("future")
[11:01:30.842]                         }
[11:01:30.842]                         else {
[11:01:30.842]                           version <- NULL
[11:01:30.842]                         }
[11:01:30.842]                         if (!has_future || version < "1.8.0") {
[11:01:30.842]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.842]                             "", base::R.version$version.string), 
[11:01:30.842]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.842]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.842]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.842]                               "release", "version")], collapse = " "), 
[11:01:30.842]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.842]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.842]                             info)
[11:01:30.842]                           info <- base::paste(info, collapse = "; ")
[11:01:30.842]                           if (!has_future) {
[11:01:30.842]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.842]                               info)
[11:01:30.842]                           }
[11:01:30.842]                           else {
[11:01:30.842]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.842]                               info, version)
[11:01:30.842]                           }
[11:01:30.842]                           base::stop(msg)
[11:01:30.842]                         }
[11:01:30.842]                       })
[11:01:30.842]                     }
[11:01:30.842]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.842]                     base::options(mc.cores = 1L)
[11:01:30.842]                   }
[11:01:30.842]                   ...future.strategy.old <- future::plan("list")
[11:01:30.842]                   options(future.plan = NULL)
[11:01:30.842]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.842]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.842]                 }
[11:01:30.842]                 ...future.workdir <- getwd()
[11:01:30.842]             }
[11:01:30.842]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.842]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.842]         }
[11:01:30.842]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.842]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.842]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.842]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.842]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.842]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.842]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.842]             base::names(...future.oldOptions))
[11:01:30.842]     }
[11:01:30.842]     if (FALSE) {
[11:01:30.842]     }
[11:01:30.842]     else {
[11:01:30.842]         if (TRUE) {
[11:01:30.842]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.842]                 open = "w")
[11:01:30.842]         }
[11:01:30.842]         else {
[11:01:30.842]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.842]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.842]         }
[11:01:30.842]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.842]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.842]             base::sink(type = "output", split = FALSE)
[11:01:30.842]             base::close(...future.stdout)
[11:01:30.842]         }, add = TRUE)
[11:01:30.842]     }
[11:01:30.842]     ...future.frame <- base::sys.nframe()
[11:01:30.842]     ...future.conditions <- base::list()
[11:01:30.842]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.842]     if (FALSE) {
[11:01:30.842]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.842]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.842]     }
[11:01:30.842]     ...future.result <- base::tryCatch({
[11:01:30.842]         base::withCallingHandlers({
[11:01:30.842]             ...future.value <- base::withVisible(base::local({
[11:01:30.842]                 withCallingHandlers({
[11:01:30.842]                   {
[11:01:30.842]                     4
[11:01:30.842]                   }
[11:01:30.842]                 }, immediateCondition = function(cond) {
[11:01:30.842]                   save_rds <- function (object, pathname, ...) 
[11:01:30.842]                   {
[11:01:30.842]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.842]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.842]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.842]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.842]                         fi_tmp[["mtime"]])
[11:01:30.842]                     }
[11:01:30.842]                     tryCatch({
[11:01:30.842]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.842]                     }, error = function(ex) {
[11:01:30.842]                       msg <- conditionMessage(ex)
[11:01:30.842]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.842]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.842]                         fi_tmp[["mtime"]], msg)
[11:01:30.842]                       ex$message <- msg
[11:01:30.842]                       stop(ex)
[11:01:30.842]                     })
[11:01:30.842]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.842]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.842]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.842]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.842]                       fi <- file.info(pathname)
[11:01:30.842]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.842]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.842]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.842]                         fi[["size"]], fi[["mtime"]])
[11:01:30.842]                       stop(msg)
[11:01:30.842]                     }
[11:01:30.842]                     invisible(pathname)
[11:01:30.842]                   }
[11:01:30.842]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.842]                     rootPath = tempdir()) 
[11:01:30.842]                   {
[11:01:30.842]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.842]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.842]                       tmpdir = path, fileext = ".rds")
[11:01:30.842]                     save_rds(obj, file)
[11:01:30.842]                   }
[11:01:30.842]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.842]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.842]                   {
[11:01:30.842]                     inherits <- base::inherits
[11:01:30.842]                     invokeRestart <- base::invokeRestart
[11:01:30.842]                     is.null <- base::is.null
[11:01:30.842]                     muffled <- FALSE
[11:01:30.842]                     if (inherits(cond, "message")) {
[11:01:30.842]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.842]                       if (muffled) 
[11:01:30.842]                         invokeRestart("muffleMessage")
[11:01:30.842]                     }
[11:01:30.842]                     else if (inherits(cond, "warning")) {
[11:01:30.842]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.842]                       if (muffled) 
[11:01:30.842]                         invokeRestart("muffleWarning")
[11:01:30.842]                     }
[11:01:30.842]                     else if (inherits(cond, "condition")) {
[11:01:30.842]                       if (!is.null(pattern)) {
[11:01:30.842]                         computeRestarts <- base::computeRestarts
[11:01:30.842]                         grepl <- base::grepl
[11:01:30.842]                         restarts <- computeRestarts(cond)
[11:01:30.842]                         for (restart in restarts) {
[11:01:30.842]                           name <- restart$name
[11:01:30.842]                           if (is.null(name)) 
[11:01:30.842]                             next
[11:01:30.842]                           if (!grepl(pattern, name)) 
[11:01:30.842]                             next
[11:01:30.842]                           invokeRestart(restart)
[11:01:30.842]                           muffled <- TRUE
[11:01:30.842]                           break
[11:01:30.842]                         }
[11:01:30.842]                       }
[11:01:30.842]                     }
[11:01:30.842]                     invisible(muffled)
[11:01:30.842]                   }
[11:01:30.842]                   muffleCondition(cond)
[11:01:30.842]                 })
[11:01:30.842]             }))
[11:01:30.842]             future::FutureResult(value = ...future.value$value, 
[11:01:30.842]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.842]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.842]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.842]                     ...future.globalenv.names))
[11:01:30.842]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.842]         }, condition = base::local({
[11:01:30.842]             c <- base::c
[11:01:30.842]             inherits <- base::inherits
[11:01:30.842]             invokeRestart <- base::invokeRestart
[11:01:30.842]             length <- base::length
[11:01:30.842]             list <- base::list
[11:01:30.842]             seq.int <- base::seq.int
[11:01:30.842]             signalCondition <- base::signalCondition
[11:01:30.842]             sys.calls <- base::sys.calls
[11:01:30.842]             `[[` <- base::`[[`
[11:01:30.842]             `+` <- base::`+`
[11:01:30.842]             `<<-` <- base::`<<-`
[11:01:30.842]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.842]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.842]                   3L)]
[11:01:30.842]             }
[11:01:30.842]             function(cond) {
[11:01:30.842]                 is_error <- inherits(cond, "error")
[11:01:30.842]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.842]                   NULL)
[11:01:30.842]                 if (is_error) {
[11:01:30.842]                   sessionInformation <- function() {
[11:01:30.842]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.842]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.842]                       search = base::search(), system = base::Sys.info())
[11:01:30.842]                   }
[11:01:30.842]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.842]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.842]                     cond$call), session = sessionInformation(), 
[11:01:30.842]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.842]                   signalCondition(cond)
[11:01:30.842]                 }
[11:01:30.842]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.842]                 "immediateCondition"))) {
[11:01:30.842]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.842]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.842]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.842]                   if (TRUE && !signal) {
[11:01:30.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.842]                     {
[11:01:30.842]                       inherits <- base::inherits
[11:01:30.842]                       invokeRestart <- base::invokeRestart
[11:01:30.842]                       is.null <- base::is.null
[11:01:30.842]                       muffled <- FALSE
[11:01:30.842]                       if (inherits(cond, "message")) {
[11:01:30.842]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.842]                         if (muffled) 
[11:01:30.842]                           invokeRestart("muffleMessage")
[11:01:30.842]                       }
[11:01:30.842]                       else if (inherits(cond, "warning")) {
[11:01:30.842]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.842]                         if (muffled) 
[11:01:30.842]                           invokeRestart("muffleWarning")
[11:01:30.842]                       }
[11:01:30.842]                       else if (inherits(cond, "condition")) {
[11:01:30.842]                         if (!is.null(pattern)) {
[11:01:30.842]                           computeRestarts <- base::computeRestarts
[11:01:30.842]                           grepl <- base::grepl
[11:01:30.842]                           restarts <- computeRestarts(cond)
[11:01:30.842]                           for (restart in restarts) {
[11:01:30.842]                             name <- restart$name
[11:01:30.842]                             if (is.null(name)) 
[11:01:30.842]                               next
[11:01:30.842]                             if (!grepl(pattern, name)) 
[11:01:30.842]                               next
[11:01:30.842]                             invokeRestart(restart)
[11:01:30.842]                             muffled <- TRUE
[11:01:30.842]                             break
[11:01:30.842]                           }
[11:01:30.842]                         }
[11:01:30.842]                       }
[11:01:30.842]                       invisible(muffled)
[11:01:30.842]                     }
[11:01:30.842]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.842]                   }
[11:01:30.842]                 }
[11:01:30.842]                 else {
[11:01:30.842]                   if (TRUE) {
[11:01:30.842]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.842]                     {
[11:01:30.842]                       inherits <- base::inherits
[11:01:30.842]                       invokeRestart <- base::invokeRestart
[11:01:30.842]                       is.null <- base::is.null
[11:01:30.842]                       muffled <- FALSE
[11:01:30.842]                       if (inherits(cond, "message")) {
[11:01:30.842]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.842]                         if (muffled) 
[11:01:30.842]                           invokeRestart("muffleMessage")
[11:01:30.842]                       }
[11:01:30.842]                       else if (inherits(cond, "warning")) {
[11:01:30.842]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.842]                         if (muffled) 
[11:01:30.842]                           invokeRestart("muffleWarning")
[11:01:30.842]                       }
[11:01:30.842]                       else if (inherits(cond, "condition")) {
[11:01:30.842]                         if (!is.null(pattern)) {
[11:01:30.842]                           computeRestarts <- base::computeRestarts
[11:01:30.842]                           grepl <- base::grepl
[11:01:30.842]                           restarts <- computeRestarts(cond)
[11:01:30.842]                           for (restart in restarts) {
[11:01:30.842]                             name <- restart$name
[11:01:30.842]                             if (is.null(name)) 
[11:01:30.842]                               next
[11:01:30.842]                             if (!grepl(pattern, name)) 
[11:01:30.842]                               next
[11:01:30.842]                             invokeRestart(restart)
[11:01:30.842]                             muffled <- TRUE
[11:01:30.842]                             break
[11:01:30.842]                           }
[11:01:30.842]                         }
[11:01:30.842]                       }
[11:01:30.842]                       invisible(muffled)
[11:01:30.842]                     }
[11:01:30.842]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.842]                   }
[11:01:30.842]                 }
[11:01:30.842]             }
[11:01:30.842]         }))
[11:01:30.842]     }, error = function(ex) {
[11:01:30.842]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.842]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.842]                 ...future.rng), started = ...future.startTime, 
[11:01:30.842]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.842]             version = "1.8"), class = "FutureResult")
[11:01:30.842]     }, finally = {
[11:01:30.842]         if (!identical(...future.workdir, getwd())) 
[11:01:30.842]             setwd(...future.workdir)
[11:01:30.842]         {
[11:01:30.842]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.842]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.842]             }
[11:01:30.842]             base::options(...future.oldOptions)
[11:01:30.842]             if (.Platform$OS.type == "windows") {
[11:01:30.842]                 old_names <- names(...future.oldEnvVars)
[11:01:30.842]                 envs <- base::Sys.getenv()
[11:01:30.842]                 names <- names(envs)
[11:01:30.842]                 common <- intersect(names, old_names)
[11:01:30.842]                 added <- setdiff(names, old_names)
[11:01:30.842]                 removed <- setdiff(old_names, names)
[11:01:30.842]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.842]                   envs[common]]
[11:01:30.842]                 NAMES <- toupper(changed)
[11:01:30.842]                 args <- list()
[11:01:30.842]                 for (kk in seq_along(NAMES)) {
[11:01:30.842]                   name <- changed[[kk]]
[11:01:30.842]                   NAME <- NAMES[[kk]]
[11:01:30.842]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.842]                     next
[11:01:30.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.842]                 }
[11:01:30.842]                 NAMES <- toupper(added)
[11:01:30.842]                 for (kk in seq_along(NAMES)) {
[11:01:30.842]                   name <- added[[kk]]
[11:01:30.842]                   NAME <- NAMES[[kk]]
[11:01:30.842]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.842]                     next
[11:01:30.842]                   args[[name]] <- ""
[11:01:30.842]                 }
[11:01:30.842]                 NAMES <- toupper(removed)
[11:01:30.842]                 for (kk in seq_along(NAMES)) {
[11:01:30.842]                   name <- removed[[kk]]
[11:01:30.842]                   NAME <- NAMES[[kk]]
[11:01:30.842]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.842]                     next
[11:01:30.842]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.842]                 }
[11:01:30.842]                 if (length(args) > 0) 
[11:01:30.842]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.842]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.842]             }
[11:01:30.842]             else {
[11:01:30.842]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.842]             }
[11:01:30.842]             {
[11:01:30.842]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.842]                   0L) {
[11:01:30.842]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.842]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.842]                   base::options(opts)
[11:01:30.842]                 }
[11:01:30.842]                 {
[11:01:30.842]                   {
[11:01:30.842]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.842]                     NULL
[11:01:30.842]                   }
[11:01:30.842]                   options(future.plan = NULL)
[11:01:30.842]                   if (is.na(NA_character_)) 
[11:01:30.842]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.842]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.842]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.842]                     .init = FALSE)
[11:01:30.842]                 }
[11:01:30.842]             }
[11:01:30.842]         }
[11:01:30.842]     })
[11:01:30.842]     if (TRUE) {
[11:01:30.842]         base::sink(type = "output", split = FALSE)
[11:01:30.842]         if (TRUE) {
[11:01:30.842]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.842]         }
[11:01:30.842]         else {
[11:01:30.842]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.842]         }
[11:01:30.842]         base::close(...future.stdout)
[11:01:30.842]         ...future.stdout <- NULL
[11:01:30.842]     }
[11:01:30.842]     ...future.result$conditions <- ...future.conditions
[11:01:30.842]     ...future.result$finished <- base::Sys.time()
[11:01:30.842]     ...future.result
[11:01:30.842] }
[11:01:30.845] requestCore(): workers = 2
[11:01:30.845] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:30.856] result() for MulticoreFuture ...
[11:01:30.857] result() for MulticoreFuture ...
[11:01:30.857] result() for MulticoreFuture ... done
[11:01:30.857] result() for MulticoreFuture ... done
[11:01:30.857] result() for MulticoreFuture ...
[11:01:30.857] result() for MulticoreFuture ... done
[11:01:30.860] MulticoreFuture started
[11:01:30.860] - Launch lazy future ... done
[11:01:30.861] run() for ‘MulticoreFuture’ ... done
[11:01:30.861] plan(): Setting new future strategy stack:
<environment: 0x55a9c7b561e8> 
[11:01:30.861] List of future strategies:
[11:01:30.861] 1. sequential:
[11:01:30.861]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.861]    - tweaked: FALSE
[11:01:30.861]    - call: NULL
[11:01:30.863] plan(): nbrOfWorkers() = 1
<environment: 0x55a9c84881b8> 
[11:01:30.865] plan(): Setting new future strategy stack:
[11:01:30.865] List of future strategies:
[11:01:30.865] 1. multicore:
[11:01:30.865]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.865]    - tweaked: FALSE
[11:01:30.865]    - call: plan(strategy)
[11:01:30.868] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:30.871] resolve() on environment ...
[11:01:30.871]  recursive: 0
[11:01:30.871]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:30.872] signalConditionsASAP(numeric, pos=1) ...
[11:01:30.872] - nx: 4
[11:01:30.872] - relay: TRUE
[11:01:30.872] - stdout: TRUE
[11:01:30.872] - signal: TRUE
[11:01:30.872] - resignal: FALSE
[11:01:30.872] - force: TRUE
[11:01:30.872] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.873] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.873]  - until=2
[11:01:30.873]  - relaying element #2
[11:01:30.873] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:30.873] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.873] signalConditionsASAP(NULL, pos=1) ... done
[11:01:30.873]  length: 3 (resolved future 1)
[11:01:30.873] Future #2
[11:01:30.874] result() for MulticoreFuture ...
[11:01:30.874] result() for MulticoreFuture ... done
[11:01:30.874] result() for MulticoreFuture ...
[11:01:30.874] result() for MulticoreFuture ... done
[11:01:30.874] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:30.874] - nx: 4
[11:01:30.874] - relay: TRUE
[11:01:30.874] - stdout: TRUE
[11:01:30.875] - signal: TRUE
[11:01:30.875] - resignal: FALSE
[11:01:30.875] - force: TRUE
[11:01:30.875] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:30.875] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.875]  - until=2
[11:01:30.875]  - relaying element #2
[11:01:30.875] result() for MulticoreFuture ...
[11:01:30.875] result() for MulticoreFuture ... done
[11:01:30.876] result() for MulticoreFuture ...
[11:01:30.876] result() for MulticoreFuture ... done
[11:01:30.876] result() for MulticoreFuture ...
[11:01:30.876] result() for MulticoreFuture ... done
[11:01:30.876] result() for MulticoreFuture ...
[11:01:30.876] result() for MulticoreFuture ... done
[11:01:30.876] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:30.876] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:30.877] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:30.877]  length: 2 (resolved future 2)
[11:01:30.877] Future #3
[11:01:30.877] result() for MulticoreFuture ...
[11:01:30.878] result() for MulticoreFuture ...
[11:01:30.878] result() for MulticoreFuture ... done
[11:01:30.878] result() for MulticoreFuture ... done
[11:01:30.878] result() for MulticoreFuture ...
[11:01:30.878] result() for MulticoreFuture ... done
[11:01:30.879] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:30.879] - nx: 4
[11:01:30.879] - relay: TRUE
[11:01:30.879] - stdout: TRUE
[11:01:30.879] - signal: TRUE
[11:01:30.879] - resignal: FALSE
[11:01:30.879] - force: TRUE
[11:01:30.879] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:30.879] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:30.880]  - until=3
[11:01:30.880]  - relaying element #3
[11:01:30.880] result() for MulticoreFuture ...
[11:01:30.880] result() for MulticoreFuture ... done
[11:01:30.880] result() for MulticoreFuture ...
[11:01:30.880] result() for MulticoreFuture ... done
[11:01:30.880] result() for MulticoreFuture ...
[11:01:30.880] result() for MulticoreFuture ... done
[11:01:30.881] result() for MulticoreFuture ...
[11:01:30.881] result() for MulticoreFuture ... done
[11:01:30.881] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:30.881] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:30.881] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:30.881]  length: 1 (resolved future 3)
[11:01:30.881] Future #4
[11:01:30.882] result() for MulticoreFuture ...
[11:01:30.882] result() for MulticoreFuture ...
[11:01:30.882] result() for MulticoreFuture ... done
[11:01:30.883] result() for MulticoreFuture ... done
[11:01:30.883] result() for MulticoreFuture ...
[11:01:30.883] result() for MulticoreFuture ... done
[11:01:30.883] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:30.883] - nx: 4
[11:01:30.883] - relay: TRUE
[11:01:30.884] - stdout: TRUE
[11:01:30.884] - signal: TRUE
[11:01:30.884] - resignal: FALSE
[11:01:30.884] - force: TRUE
[11:01:30.884] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:30.884] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:30.885]  - until=4
[11:01:30.885]  - relaying element #4
[11:01:30.885] result() for MulticoreFuture ...
[11:01:30.885] result() for MulticoreFuture ... done
[11:01:30.885] result() for MulticoreFuture ...
[11:01:30.885] result() for MulticoreFuture ... done
[11:01:30.886] result() for MulticoreFuture ...
[11:01:30.886] result() for MulticoreFuture ... done
[11:01:30.886] result() for MulticoreFuture ...
[11:01:30.886] result() for MulticoreFuture ... done
[11:01:30.886] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.886] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:30.886] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:30.887]  length: 0 (resolved future 4)
[11:01:30.887] Relaying remaining futures
[11:01:30.887] signalConditionsASAP(NULL, pos=0) ...
[11:01:30.887] - nx: 4
[11:01:30.887] - relay: TRUE
[11:01:30.887] - stdout: TRUE
[11:01:30.887] - signal: TRUE
[11:01:30.887] - resignal: FALSE
[11:01:30.887] - force: TRUE
[11:01:30.887] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.887] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:30.888] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.888] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:30.888] signalConditionsASAP(NULL, pos=0) ... done
[11:01:30.888] resolve() on environment ... DONE
[11:01:30.888] result() for MulticoreFuture ...
[11:01:30.888] result() for MulticoreFuture ... done
[11:01:30.888] result() for MulticoreFuture ...
[11:01:30.888] result() for MulticoreFuture ... done
[11:01:30.888] result() for MulticoreFuture ...
[11:01:30.889] result() for MulticoreFuture ... done
[11:01:30.889] result() for MulticoreFuture ...
[11:01:30.889] result() for MulticoreFuture ... done
[11:01:30.889] result() for MulticoreFuture ...
[11:01:30.889] result() for MulticoreFuture ... done
[11:01:30.889] result() for MulticoreFuture ...
[11:01:30.889] result() for MulticoreFuture ... done
<environment: 0x55a9c8546450> 
Dimensions: c(2, 3, 1)
[11:01:30.890] getGlobalsAndPackages() ...
[11:01:30.890] Searching for globals...
[11:01:30.890] 
[11:01:30.890] Searching for globals ... DONE
[11:01:30.891] - globals: [0] <none>
[11:01:30.891] getGlobalsAndPackages() ... DONE
[11:01:30.891] run() for ‘Future’ ...
[11:01:30.891] - state: ‘created’
[11:01:30.891] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.893] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.893] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.893]   - Field: ‘label’
[11:01:30.894]   - Field: ‘local’
[11:01:30.894]   - Field: ‘owner’
[11:01:30.894]   - Field: ‘envir’
[11:01:30.894]   - Field: ‘workers’
[11:01:30.897]   - Field: ‘packages’
[11:01:30.897]   - Field: ‘gc’
[11:01:30.897]   - Field: ‘job’
[11:01:30.897]   - Field: ‘conditions’
[11:01:30.897]   - Field: ‘expr’
[11:01:30.897]   - Field: ‘uuid’
[11:01:30.898]   - Field: ‘seed’
[11:01:30.898]   - Field: ‘version’
[11:01:30.898]   - Field: ‘result’
[11:01:30.898]   - Field: ‘asynchronous’
[11:01:30.898]   - Field: ‘calls’
[11:01:30.898]   - Field: ‘globals’
[11:01:30.898]   - Field: ‘stdout’
[11:01:30.898]   - Field: ‘earlySignal’
[11:01:30.898]   - Field: ‘lazy’
[11:01:30.898]   - Field: ‘state’
[11:01:30.898] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.899] - Launch lazy future ...
[11:01:30.899] Packages needed by the future expression (n = 0): <none>
[11:01:30.899] Packages needed by future strategies (n = 0): <none>
[11:01:30.900] {
[11:01:30.900]     {
[11:01:30.900]         {
[11:01:30.900]             ...future.startTime <- base::Sys.time()
[11:01:30.900]             {
[11:01:30.900]                 {
[11:01:30.900]                   {
[11:01:30.900]                     {
[11:01:30.900]                       base::local({
[11:01:30.900]                         has_future <- base::requireNamespace("future", 
[11:01:30.900]                           quietly = TRUE)
[11:01:30.900]                         if (has_future) {
[11:01:30.900]                           ns <- base::getNamespace("future")
[11:01:30.900]                           version <- ns[[".package"]][["version"]]
[11:01:30.900]                           if (is.null(version)) 
[11:01:30.900]                             version <- utils::packageVersion("future")
[11:01:30.900]                         }
[11:01:30.900]                         else {
[11:01:30.900]                           version <- NULL
[11:01:30.900]                         }
[11:01:30.900]                         if (!has_future || version < "1.8.0") {
[11:01:30.900]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.900]                             "", base::R.version$version.string), 
[11:01:30.900]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.900]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.900]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.900]                               "release", "version")], collapse = " "), 
[11:01:30.900]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.900]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.900]                             info)
[11:01:30.900]                           info <- base::paste(info, collapse = "; ")
[11:01:30.900]                           if (!has_future) {
[11:01:30.900]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.900]                               info)
[11:01:30.900]                           }
[11:01:30.900]                           else {
[11:01:30.900]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.900]                               info, version)
[11:01:30.900]                           }
[11:01:30.900]                           base::stop(msg)
[11:01:30.900]                         }
[11:01:30.900]                       })
[11:01:30.900]                     }
[11:01:30.900]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.900]                     base::options(mc.cores = 1L)
[11:01:30.900]                   }
[11:01:30.900]                   ...future.strategy.old <- future::plan("list")
[11:01:30.900]                   options(future.plan = NULL)
[11:01:30.900]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.900]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.900]                 }
[11:01:30.900]                 ...future.workdir <- getwd()
[11:01:30.900]             }
[11:01:30.900]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.900]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.900]         }
[11:01:30.900]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.900]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.900]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.900]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.900]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.900]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.900]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.900]             base::names(...future.oldOptions))
[11:01:30.900]     }
[11:01:30.900]     if (FALSE) {
[11:01:30.900]     }
[11:01:30.900]     else {
[11:01:30.900]         if (TRUE) {
[11:01:30.900]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.900]                 open = "w")
[11:01:30.900]         }
[11:01:30.900]         else {
[11:01:30.900]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.900]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.900]         }
[11:01:30.900]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.900]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.900]             base::sink(type = "output", split = FALSE)
[11:01:30.900]             base::close(...future.stdout)
[11:01:30.900]         }, add = TRUE)
[11:01:30.900]     }
[11:01:30.900]     ...future.frame <- base::sys.nframe()
[11:01:30.900]     ...future.conditions <- base::list()
[11:01:30.900]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.900]     if (FALSE) {
[11:01:30.900]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.900]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.900]     }
[11:01:30.900]     ...future.result <- base::tryCatch({
[11:01:30.900]         base::withCallingHandlers({
[11:01:30.900]             ...future.value <- base::withVisible(base::local({
[11:01:30.900]                 withCallingHandlers({
[11:01:30.900]                   2
[11:01:30.900]                 }, immediateCondition = function(cond) {
[11:01:30.900]                   save_rds <- function (object, pathname, ...) 
[11:01:30.900]                   {
[11:01:30.900]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.900]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.900]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.900]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.900]                         fi_tmp[["mtime"]])
[11:01:30.900]                     }
[11:01:30.900]                     tryCatch({
[11:01:30.900]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.900]                     }, error = function(ex) {
[11:01:30.900]                       msg <- conditionMessage(ex)
[11:01:30.900]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.900]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.900]                         fi_tmp[["mtime"]], msg)
[11:01:30.900]                       ex$message <- msg
[11:01:30.900]                       stop(ex)
[11:01:30.900]                     })
[11:01:30.900]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.900]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.900]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.900]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.900]                       fi <- file.info(pathname)
[11:01:30.900]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.900]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.900]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.900]                         fi[["size"]], fi[["mtime"]])
[11:01:30.900]                       stop(msg)
[11:01:30.900]                     }
[11:01:30.900]                     invisible(pathname)
[11:01:30.900]                   }
[11:01:30.900]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.900]                     rootPath = tempdir()) 
[11:01:30.900]                   {
[11:01:30.900]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.900]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.900]                       tmpdir = path, fileext = ".rds")
[11:01:30.900]                     save_rds(obj, file)
[11:01:30.900]                   }
[11:01:30.900]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.900]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.900]                   {
[11:01:30.900]                     inherits <- base::inherits
[11:01:30.900]                     invokeRestart <- base::invokeRestart
[11:01:30.900]                     is.null <- base::is.null
[11:01:30.900]                     muffled <- FALSE
[11:01:30.900]                     if (inherits(cond, "message")) {
[11:01:30.900]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.900]                       if (muffled) 
[11:01:30.900]                         invokeRestart("muffleMessage")
[11:01:30.900]                     }
[11:01:30.900]                     else if (inherits(cond, "warning")) {
[11:01:30.900]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.900]                       if (muffled) 
[11:01:30.900]                         invokeRestart("muffleWarning")
[11:01:30.900]                     }
[11:01:30.900]                     else if (inherits(cond, "condition")) {
[11:01:30.900]                       if (!is.null(pattern)) {
[11:01:30.900]                         computeRestarts <- base::computeRestarts
[11:01:30.900]                         grepl <- base::grepl
[11:01:30.900]                         restarts <- computeRestarts(cond)
[11:01:30.900]                         for (restart in restarts) {
[11:01:30.900]                           name <- restart$name
[11:01:30.900]                           if (is.null(name)) 
[11:01:30.900]                             next
[11:01:30.900]                           if (!grepl(pattern, name)) 
[11:01:30.900]                             next
[11:01:30.900]                           invokeRestart(restart)
[11:01:30.900]                           muffled <- TRUE
[11:01:30.900]                           break
[11:01:30.900]                         }
[11:01:30.900]                       }
[11:01:30.900]                     }
[11:01:30.900]                     invisible(muffled)
[11:01:30.900]                   }
[11:01:30.900]                   muffleCondition(cond)
[11:01:30.900]                 })
[11:01:30.900]             }))
[11:01:30.900]             future::FutureResult(value = ...future.value$value, 
[11:01:30.900]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.900]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.900]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.900]                     ...future.globalenv.names))
[11:01:30.900]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.900]         }, condition = base::local({
[11:01:30.900]             c <- base::c
[11:01:30.900]             inherits <- base::inherits
[11:01:30.900]             invokeRestart <- base::invokeRestart
[11:01:30.900]             length <- base::length
[11:01:30.900]             list <- base::list
[11:01:30.900]             seq.int <- base::seq.int
[11:01:30.900]             signalCondition <- base::signalCondition
[11:01:30.900]             sys.calls <- base::sys.calls
[11:01:30.900]             `[[` <- base::`[[`
[11:01:30.900]             `+` <- base::`+`
[11:01:30.900]             `<<-` <- base::`<<-`
[11:01:30.900]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.900]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.900]                   3L)]
[11:01:30.900]             }
[11:01:30.900]             function(cond) {
[11:01:30.900]                 is_error <- inherits(cond, "error")
[11:01:30.900]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.900]                   NULL)
[11:01:30.900]                 if (is_error) {
[11:01:30.900]                   sessionInformation <- function() {
[11:01:30.900]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.900]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.900]                       search = base::search(), system = base::Sys.info())
[11:01:30.900]                   }
[11:01:30.900]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.900]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.900]                     cond$call), session = sessionInformation(), 
[11:01:30.900]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.900]                   signalCondition(cond)
[11:01:30.900]                 }
[11:01:30.900]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.900]                 "immediateCondition"))) {
[11:01:30.900]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.900]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.900]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.900]                   if (TRUE && !signal) {
[11:01:30.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.900]                     {
[11:01:30.900]                       inherits <- base::inherits
[11:01:30.900]                       invokeRestart <- base::invokeRestart
[11:01:30.900]                       is.null <- base::is.null
[11:01:30.900]                       muffled <- FALSE
[11:01:30.900]                       if (inherits(cond, "message")) {
[11:01:30.900]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.900]                         if (muffled) 
[11:01:30.900]                           invokeRestart("muffleMessage")
[11:01:30.900]                       }
[11:01:30.900]                       else if (inherits(cond, "warning")) {
[11:01:30.900]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.900]                         if (muffled) 
[11:01:30.900]                           invokeRestart("muffleWarning")
[11:01:30.900]                       }
[11:01:30.900]                       else if (inherits(cond, "condition")) {
[11:01:30.900]                         if (!is.null(pattern)) {
[11:01:30.900]                           computeRestarts <- base::computeRestarts
[11:01:30.900]                           grepl <- base::grepl
[11:01:30.900]                           restarts <- computeRestarts(cond)
[11:01:30.900]                           for (restart in restarts) {
[11:01:30.900]                             name <- restart$name
[11:01:30.900]                             if (is.null(name)) 
[11:01:30.900]                               next
[11:01:30.900]                             if (!grepl(pattern, name)) 
[11:01:30.900]                               next
[11:01:30.900]                             invokeRestart(restart)
[11:01:30.900]                             muffled <- TRUE
[11:01:30.900]                             break
[11:01:30.900]                           }
[11:01:30.900]                         }
[11:01:30.900]                       }
[11:01:30.900]                       invisible(muffled)
[11:01:30.900]                     }
[11:01:30.900]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.900]                   }
[11:01:30.900]                 }
[11:01:30.900]                 else {
[11:01:30.900]                   if (TRUE) {
[11:01:30.900]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.900]                     {
[11:01:30.900]                       inherits <- base::inherits
[11:01:30.900]                       invokeRestart <- base::invokeRestart
[11:01:30.900]                       is.null <- base::is.null
[11:01:30.900]                       muffled <- FALSE
[11:01:30.900]                       if (inherits(cond, "message")) {
[11:01:30.900]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.900]                         if (muffled) 
[11:01:30.900]                           invokeRestart("muffleMessage")
[11:01:30.900]                       }
[11:01:30.900]                       else if (inherits(cond, "warning")) {
[11:01:30.900]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.900]                         if (muffled) 
[11:01:30.900]                           invokeRestart("muffleWarning")
[11:01:30.900]                       }
[11:01:30.900]                       else if (inherits(cond, "condition")) {
[11:01:30.900]                         if (!is.null(pattern)) {
[11:01:30.900]                           computeRestarts <- base::computeRestarts
[11:01:30.900]                           grepl <- base::grepl
[11:01:30.900]                           restarts <- computeRestarts(cond)
[11:01:30.900]                           for (restart in restarts) {
[11:01:30.900]                             name <- restart$name
[11:01:30.900]                             if (is.null(name)) 
[11:01:30.900]                               next
[11:01:30.900]                             if (!grepl(pattern, name)) 
[11:01:30.900]                               next
[11:01:30.900]                             invokeRestart(restart)
[11:01:30.900]                             muffled <- TRUE
[11:01:30.900]                             break
[11:01:30.900]                           }
[11:01:30.900]                         }
[11:01:30.900]                       }
[11:01:30.900]                       invisible(muffled)
[11:01:30.900]                     }
[11:01:30.900]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.900]                   }
[11:01:30.900]                 }
[11:01:30.900]             }
[11:01:30.900]         }))
[11:01:30.900]     }, error = function(ex) {
[11:01:30.900]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.900]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.900]                 ...future.rng), started = ...future.startTime, 
[11:01:30.900]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.900]             version = "1.8"), class = "FutureResult")
[11:01:30.900]     }, finally = {
[11:01:30.900]         if (!identical(...future.workdir, getwd())) 
[11:01:30.900]             setwd(...future.workdir)
[11:01:30.900]         {
[11:01:30.900]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.900]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.900]             }
[11:01:30.900]             base::options(...future.oldOptions)
[11:01:30.900]             if (.Platform$OS.type == "windows") {
[11:01:30.900]                 old_names <- names(...future.oldEnvVars)
[11:01:30.900]                 envs <- base::Sys.getenv()
[11:01:30.900]                 names <- names(envs)
[11:01:30.900]                 common <- intersect(names, old_names)
[11:01:30.900]                 added <- setdiff(names, old_names)
[11:01:30.900]                 removed <- setdiff(old_names, names)
[11:01:30.900]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.900]                   envs[common]]
[11:01:30.900]                 NAMES <- toupper(changed)
[11:01:30.900]                 args <- list()
[11:01:30.900]                 for (kk in seq_along(NAMES)) {
[11:01:30.900]                   name <- changed[[kk]]
[11:01:30.900]                   NAME <- NAMES[[kk]]
[11:01:30.900]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.900]                     next
[11:01:30.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.900]                 }
[11:01:30.900]                 NAMES <- toupper(added)
[11:01:30.900]                 for (kk in seq_along(NAMES)) {
[11:01:30.900]                   name <- added[[kk]]
[11:01:30.900]                   NAME <- NAMES[[kk]]
[11:01:30.900]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.900]                     next
[11:01:30.900]                   args[[name]] <- ""
[11:01:30.900]                 }
[11:01:30.900]                 NAMES <- toupper(removed)
[11:01:30.900]                 for (kk in seq_along(NAMES)) {
[11:01:30.900]                   name <- removed[[kk]]
[11:01:30.900]                   NAME <- NAMES[[kk]]
[11:01:30.900]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.900]                     next
[11:01:30.900]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.900]                 }
[11:01:30.900]                 if (length(args) > 0) 
[11:01:30.900]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.900]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.900]             }
[11:01:30.900]             else {
[11:01:30.900]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.900]             }
[11:01:30.900]             {
[11:01:30.900]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.900]                   0L) {
[11:01:30.900]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.900]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.900]                   base::options(opts)
[11:01:30.900]                 }
[11:01:30.900]                 {
[11:01:30.900]                   {
[11:01:30.900]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.900]                     NULL
[11:01:30.900]                   }
[11:01:30.900]                   options(future.plan = NULL)
[11:01:30.900]                   if (is.na(NA_character_)) 
[11:01:30.900]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.900]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.900]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.900]                     .init = FALSE)
[11:01:30.900]                 }
[11:01:30.900]             }
[11:01:30.900]         }
[11:01:30.900]     })
[11:01:30.900]     if (TRUE) {
[11:01:30.900]         base::sink(type = "output", split = FALSE)
[11:01:30.900]         if (TRUE) {
[11:01:30.900]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.900]         }
[11:01:30.900]         else {
[11:01:30.900]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.900]         }
[11:01:30.900]         base::close(...future.stdout)
[11:01:30.900]         ...future.stdout <- NULL
[11:01:30.900]     }
[11:01:30.900]     ...future.result$conditions <- ...future.conditions
[11:01:30.900]     ...future.result$finished <- base::Sys.time()
[11:01:30.900]     ...future.result
[11:01:30.900] }
[11:01:30.902] requestCore(): workers = 2
[11:01:30.904] MulticoreFuture started
[11:01:30.904] - Launch lazy future ... done
[11:01:30.904] run() for ‘MulticoreFuture’ ... done
[11:01:30.905] getGlobalsAndPackages() ...
[11:01:30.905] Searching for globals...
[11:01:30.905] plan(): Setting new future strategy stack:
[11:01:30.906] 
[11:01:30.905] List of future strategies:
[11:01:30.905] 1. sequential:
[11:01:30.905]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.905]    - tweaked: FALSE
[11:01:30.905]    - call: NULL
[11:01:30.906] Searching for globals ... DONE
[11:01:30.906] - globals: [0] <none>
[11:01:30.906] plan(): nbrOfWorkers() = 1
[11:01:30.906] getGlobalsAndPackages() ... DONE
[11:01:30.907] run() for ‘Future’ ...
[11:01:30.907] - state: ‘created’
[11:01:30.907] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.908] plan(): Setting new future strategy stack:
[11:01:30.908] List of future strategies:
[11:01:30.908] 1. multicore:
[11:01:30.908]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.908]    - tweaked: FALSE
[11:01:30.908]    - call: plan(strategy)
[11:01:30.910] plan(): nbrOfWorkers() = 2
[11:01:30.910] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.911] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.911]   - Field: ‘label’
[11:01:30.911]   - Field: ‘local’
[11:01:30.911]   - Field: ‘owner’
[11:01:30.911]   - Field: ‘envir’
[11:01:30.911]   - Field: ‘workers’
[11:01:30.911]   - Field: ‘packages’
[11:01:30.912]   - Field: ‘gc’
[11:01:30.912]   - Field: ‘job’
[11:01:30.912]   - Field: ‘conditions’
[11:01:30.912]   - Field: ‘expr’
[11:01:30.912]   - Field: ‘uuid’
[11:01:30.912]   - Field: ‘seed’
[11:01:30.913]   - Field: ‘version’
[11:01:30.913]   - Field: ‘result’
[11:01:30.913]   - Field: ‘asynchronous’
[11:01:30.913]   - Field: ‘calls’
[11:01:30.913]   - Field: ‘globals’
[11:01:30.913]   - Field: ‘stdout’
[11:01:30.913]   - Field: ‘earlySignal’
[11:01:30.914]   - Field: ‘lazy’
[11:01:30.914]   - Field: ‘state’
[11:01:30.914] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.914] - Launch lazy future ...
[11:01:30.915] Packages needed by the future expression (n = 0): <none>
[11:01:30.915] Packages needed by future strategies (n = 0): <none>
[11:01:30.915] {
[11:01:30.915]     {
[11:01:30.915]         {
[11:01:30.915]             ...future.startTime <- base::Sys.time()
[11:01:30.915]             {
[11:01:30.915]                 {
[11:01:30.915]                   {
[11:01:30.915]                     {
[11:01:30.915]                       base::local({
[11:01:30.915]                         has_future <- base::requireNamespace("future", 
[11:01:30.915]                           quietly = TRUE)
[11:01:30.915]                         if (has_future) {
[11:01:30.915]                           ns <- base::getNamespace("future")
[11:01:30.915]                           version <- ns[[".package"]][["version"]]
[11:01:30.915]                           if (is.null(version)) 
[11:01:30.915]                             version <- utils::packageVersion("future")
[11:01:30.915]                         }
[11:01:30.915]                         else {
[11:01:30.915]                           version <- NULL
[11:01:30.915]                         }
[11:01:30.915]                         if (!has_future || version < "1.8.0") {
[11:01:30.915]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.915]                             "", base::R.version$version.string), 
[11:01:30.915]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.915]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.915]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.915]                               "release", "version")], collapse = " "), 
[11:01:30.915]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.915]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.915]                             info)
[11:01:30.915]                           info <- base::paste(info, collapse = "; ")
[11:01:30.915]                           if (!has_future) {
[11:01:30.915]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.915]                               info)
[11:01:30.915]                           }
[11:01:30.915]                           else {
[11:01:30.915]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.915]                               info, version)
[11:01:30.915]                           }
[11:01:30.915]                           base::stop(msg)
[11:01:30.915]                         }
[11:01:30.915]                       })
[11:01:30.915]                     }
[11:01:30.915]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.915]                     base::options(mc.cores = 1L)
[11:01:30.915]                   }
[11:01:30.915]                   ...future.strategy.old <- future::plan("list")
[11:01:30.915]                   options(future.plan = NULL)
[11:01:30.915]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.915]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.915]                 }
[11:01:30.915]                 ...future.workdir <- getwd()
[11:01:30.915]             }
[11:01:30.915]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.915]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.915]         }
[11:01:30.915]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.915]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.915]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.915]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.915]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.915]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.915]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.915]             base::names(...future.oldOptions))
[11:01:30.915]     }
[11:01:30.915]     if (FALSE) {
[11:01:30.915]     }
[11:01:30.915]     else {
[11:01:30.915]         if (TRUE) {
[11:01:30.915]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.915]                 open = "w")
[11:01:30.915]         }
[11:01:30.915]         else {
[11:01:30.915]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.915]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.915]         }
[11:01:30.915]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.915]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.915]             base::sink(type = "output", split = FALSE)
[11:01:30.915]             base::close(...future.stdout)
[11:01:30.915]         }, add = TRUE)
[11:01:30.915]     }
[11:01:30.915]     ...future.frame <- base::sys.nframe()
[11:01:30.915]     ...future.conditions <- base::list()
[11:01:30.915]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.915]     if (FALSE) {
[11:01:30.915]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.915]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.915]     }
[11:01:30.915]     ...future.result <- base::tryCatch({
[11:01:30.915]         base::withCallingHandlers({
[11:01:30.915]             ...future.value <- base::withVisible(base::local({
[11:01:30.915]                 withCallingHandlers({
[11:01:30.915]                   NULL
[11:01:30.915]                 }, immediateCondition = function(cond) {
[11:01:30.915]                   save_rds <- function (object, pathname, ...) 
[11:01:30.915]                   {
[11:01:30.915]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.915]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.915]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.915]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.915]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.915]                         fi_tmp[["mtime"]])
[11:01:30.915]                     }
[11:01:30.915]                     tryCatch({
[11:01:30.915]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.915]                     }, error = function(ex) {
[11:01:30.915]                       msg <- conditionMessage(ex)
[11:01:30.915]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.915]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.915]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.915]                         fi_tmp[["mtime"]], msg)
[11:01:30.915]                       ex$message <- msg
[11:01:30.915]                       stop(ex)
[11:01:30.915]                     })
[11:01:30.915]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.915]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.915]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.915]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.915]                       fi <- file.info(pathname)
[11:01:30.915]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.915]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.915]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.915]                         fi[["size"]], fi[["mtime"]])
[11:01:30.915]                       stop(msg)
[11:01:30.915]                     }
[11:01:30.915]                     invisible(pathname)
[11:01:30.915]                   }
[11:01:30.915]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.915]                     rootPath = tempdir()) 
[11:01:30.915]                   {
[11:01:30.915]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.915]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.915]                       tmpdir = path, fileext = ".rds")
[11:01:30.915]                     save_rds(obj, file)
[11:01:30.915]                   }
[11:01:30.915]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.915]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.915]                   {
[11:01:30.915]                     inherits <- base::inherits
[11:01:30.915]                     invokeRestart <- base::invokeRestart
[11:01:30.915]                     is.null <- base::is.null
[11:01:30.915]                     muffled <- FALSE
[11:01:30.915]                     if (inherits(cond, "message")) {
[11:01:30.915]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.915]                       if (muffled) 
[11:01:30.915]                         invokeRestart("muffleMessage")
[11:01:30.915]                     }
[11:01:30.915]                     else if (inherits(cond, "warning")) {
[11:01:30.915]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.915]                       if (muffled) 
[11:01:30.915]                         invokeRestart("muffleWarning")
[11:01:30.915]                     }
[11:01:30.915]                     else if (inherits(cond, "condition")) {
[11:01:30.915]                       if (!is.null(pattern)) {
[11:01:30.915]                         computeRestarts <- base::computeRestarts
[11:01:30.915]                         grepl <- base::grepl
[11:01:30.915]                         restarts <- computeRestarts(cond)
[11:01:30.915]                         for (restart in restarts) {
[11:01:30.915]                           name <- restart$name
[11:01:30.915]                           if (is.null(name)) 
[11:01:30.915]                             next
[11:01:30.915]                           if (!grepl(pattern, name)) 
[11:01:30.915]                             next
[11:01:30.915]                           invokeRestart(restart)
[11:01:30.915]                           muffled <- TRUE
[11:01:30.915]                           break
[11:01:30.915]                         }
[11:01:30.915]                       }
[11:01:30.915]                     }
[11:01:30.915]                     invisible(muffled)
[11:01:30.915]                   }
[11:01:30.915]                   muffleCondition(cond)
[11:01:30.915]                 })
[11:01:30.915]             }))
[11:01:30.915]             future::FutureResult(value = ...future.value$value, 
[11:01:30.915]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.915]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.915]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.915]                     ...future.globalenv.names))
[11:01:30.915]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.915]         }, condition = base::local({
[11:01:30.915]             c <- base::c
[11:01:30.915]             inherits <- base::inherits
[11:01:30.915]             invokeRestart <- base::invokeRestart
[11:01:30.915]             length <- base::length
[11:01:30.915]             list <- base::list
[11:01:30.915]             seq.int <- base::seq.int
[11:01:30.915]             signalCondition <- base::signalCondition
[11:01:30.915]             sys.calls <- base::sys.calls
[11:01:30.915]             `[[` <- base::`[[`
[11:01:30.915]             `+` <- base::`+`
[11:01:30.915]             `<<-` <- base::`<<-`
[11:01:30.915]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.915]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.915]                   3L)]
[11:01:30.915]             }
[11:01:30.915]             function(cond) {
[11:01:30.915]                 is_error <- inherits(cond, "error")
[11:01:30.915]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.915]                   NULL)
[11:01:30.915]                 if (is_error) {
[11:01:30.915]                   sessionInformation <- function() {
[11:01:30.915]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.915]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.915]                       search = base::search(), system = base::Sys.info())
[11:01:30.915]                   }
[11:01:30.915]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.915]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.915]                     cond$call), session = sessionInformation(), 
[11:01:30.915]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.915]                   signalCondition(cond)
[11:01:30.915]                 }
[11:01:30.915]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.915]                 "immediateCondition"))) {
[11:01:30.915]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.915]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.915]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.915]                   if (TRUE && !signal) {
[11:01:30.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.915]                     {
[11:01:30.915]                       inherits <- base::inherits
[11:01:30.915]                       invokeRestart <- base::invokeRestart
[11:01:30.915]                       is.null <- base::is.null
[11:01:30.915]                       muffled <- FALSE
[11:01:30.915]                       if (inherits(cond, "message")) {
[11:01:30.915]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.915]                         if (muffled) 
[11:01:30.915]                           invokeRestart("muffleMessage")
[11:01:30.915]                       }
[11:01:30.915]                       else if (inherits(cond, "warning")) {
[11:01:30.915]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.915]                         if (muffled) 
[11:01:30.915]                           invokeRestart("muffleWarning")
[11:01:30.915]                       }
[11:01:30.915]                       else if (inherits(cond, "condition")) {
[11:01:30.915]                         if (!is.null(pattern)) {
[11:01:30.915]                           computeRestarts <- base::computeRestarts
[11:01:30.915]                           grepl <- base::grepl
[11:01:30.915]                           restarts <- computeRestarts(cond)
[11:01:30.915]                           for (restart in restarts) {
[11:01:30.915]                             name <- restart$name
[11:01:30.915]                             if (is.null(name)) 
[11:01:30.915]                               next
[11:01:30.915]                             if (!grepl(pattern, name)) 
[11:01:30.915]                               next
[11:01:30.915]                             invokeRestart(restart)
[11:01:30.915]                             muffled <- TRUE
[11:01:30.915]                             break
[11:01:30.915]                           }
[11:01:30.915]                         }
[11:01:30.915]                       }
[11:01:30.915]                       invisible(muffled)
[11:01:30.915]                     }
[11:01:30.915]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.915]                   }
[11:01:30.915]                 }
[11:01:30.915]                 else {
[11:01:30.915]                   if (TRUE) {
[11:01:30.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.915]                     {
[11:01:30.915]                       inherits <- base::inherits
[11:01:30.915]                       invokeRestart <- base::invokeRestart
[11:01:30.915]                       is.null <- base::is.null
[11:01:30.915]                       muffled <- FALSE
[11:01:30.915]                       if (inherits(cond, "message")) {
[11:01:30.915]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.915]                         if (muffled) 
[11:01:30.915]                           invokeRestart("muffleMessage")
[11:01:30.915]                       }
[11:01:30.915]                       else if (inherits(cond, "warning")) {
[11:01:30.915]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.915]                         if (muffled) 
[11:01:30.915]                           invokeRestart("muffleWarning")
[11:01:30.915]                       }
[11:01:30.915]                       else if (inherits(cond, "condition")) {
[11:01:30.915]                         if (!is.null(pattern)) {
[11:01:30.915]                           computeRestarts <- base::computeRestarts
[11:01:30.915]                           grepl <- base::grepl
[11:01:30.915]                           restarts <- computeRestarts(cond)
[11:01:30.915]                           for (restart in restarts) {
[11:01:30.915]                             name <- restart$name
[11:01:30.915]                             if (is.null(name)) 
[11:01:30.915]                               next
[11:01:30.915]                             if (!grepl(pattern, name)) 
[11:01:30.915]                               next
[11:01:30.915]                             invokeRestart(restart)
[11:01:30.915]                             muffled <- TRUE
[11:01:30.915]                             break
[11:01:30.915]                           }
[11:01:30.915]                         }
[11:01:30.915]                       }
[11:01:30.915]                       invisible(muffled)
[11:01:30.915]                     }
[11:01:30.915]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.915]                   }
[11:01:30.915]                 }
[11:01:30.915]             }
[11:01:30.915]         }))
[11:01:30.915]     }, error = function(ex) {
[11:01:30.915]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.915]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.915]                 ...future.rng), started = ...future.startTime, 
[11:01:30.915]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.915]             version = "1.8"), class = "FutureResult")
[11:01:30.915]     }, finally = {
[11:01:30.915]         if (!identical(...future.workdir, getwd())) 
[11:01:30.915]             setwd(...future.workdir)
[11:01:30.915]         {
[11:01:30.915]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.915]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.915]             }
[11:01:30.915]             base::options(...future.oldOptions)
[11:01:30.915]             if (.Platform$OS.type == "windows") {
[11:01:30.915]                 old_names <- names(...future.oldEnvVars)
[11:01:30.915]                 envs <- base::Sys.getenv()
[11:01:30.915]                 names <- names(envs)
[11:01:30.915]                 common <- intersect(names, old_names)
[11:01:30.915]                 added <- setdiff(names, old_names)
[11:01:30.915]                 removed <- setdiff(old_names, names)
[11:01:30.915]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.915]                   envs[common]]
[11:01:30.915]                 NAMES <- toupper(changed)
[11:01:30.915]                 args <- list()
[11:01:30.915]                 for (kk in seq_along(NAMES)) {
[11:01:30.915]                   name <- changed[[kk]]
[11:01:30.915]                   NAME <- NAMES[[kk]]
[11:01:30.915]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.915]                     next
[11:01:30.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.915]                 }
[11:01:30.915]                 NAMES <- toupper(added)
[11:01:30.915]                 for (kk in seq_along(NAMES)) {
[11:01:30.915]                   name <- added[[kk]]
[11:01:30.915]                   NAME <- NAMES[[kk]]
[11:01:30.915]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.915]                     next
[11:01:30.915]                   args[[name]] <- ""
[11:01:30.915]                 }
[11:01:30.915]                 NAMES <- toupper(removed)
[11:01:30.915]                 for (kk in seq_along(NAMES)) {
[11:01:30.915]                   name <- removed[[kk]]
[11:01:30.915]                   NAME <- NAMES[[kk]]
[11:01:30.915]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.915]                     next
[11:01:30.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.915]                 }
[11:01:30.915]                 if (length(args) > 0) 
[11:01:30.915]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.915]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.915]             }
[11:01:30.915]             else {
[11:01:30.915]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.915]             }
[11:01:30.915]             {
[11:01:30.915]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.915]                   0L) {
[11:01:30.915]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.915]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.915]                   base::options(opts)
[11:01:30.915]                 }
[11:01:30.915]                 {
[11:01:30.915]                   {
[11:01:30.915]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.915]                     NULL
[11:01:30.915]                   }
[11:01:30.915]                   options(future.plan = NULL)
[11:01:30.915]                   if (is.na(NA_character_)) 
[11:01:30.915]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.915]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.915]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.915]                     .init = FALSE)
[11:01:30.915]                 }
[11:01:30.915]             }
[11:01:30.915]         }
[11:01:30.915]     })
[11:01:30.915]     if (TRUE) {
[11:01:30.915]         base::sink(type = "output", split = FALSE)
[11:01:30.915]         if (TRUE) {
[11:01:30.915]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.915]         }
[11:01:30.915]         else {
[11:01:30.915]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.915]         }
[11:01:30.915]         base::close(...future.stdout)
[11:01:30.915]         ...future.stdout <- NULL
[11:01:30.915]     }
[11:01:30.915]     ...future.result$conditions <- ...future.conditions
[11:01:30.915]     ...future.result$finished <- base::Sys.time()
[11:01:30.915]     ...future.result
[11:01:30.915] }
[11:01:30.919] requestCore(): workers = 2
[11:01:30.921] MulticoreFuture started
[11:01:30.921] - Launch lazy future ... done
[11:01:30.922] run() for ‘MulticoreFuture’ ... done
[11:01:30.922] plan(): Setting new future strategy stack:
[11:01:30.922] getGlobalsAndPackages() ...
[11:01:30.923] Searching for globals...
[11:01:30.922] List of future strategies:
[11:01:30.922] 1. sequential:
[11:01:30.922]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.922]    - tweaked: FALSE
[11:01:30.922]    - call: NULL
[11:01:30.923] plan(): nbrOfWorkers() = 1
[11:01:30.924] - globals found: [1] ‘{’
[11:01:30.924] Searching for globals ... DONE
[11:01:30.924] Resolving globals: FALSE
[11:01:30.925] 
[11:01:30.925] 
[11:01:30.925] getGlobalsAndPackages() ... DONE
[11:01:30.925] plan(): Setting new future strategy stack:
[11:01:30.926] run() for ‘Future’ ...
[11:01:30.926] - state: ‘created’
[11:01:30.926] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.926] List of future strategies:
[11:01:30.926] 1. multicore:
[11:01:30.926]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.926]    - tweaked: FALSE
[11:01:30.926]    - call: plan(strategy)
[11:01:30.928] plan(): nbrOfWorkers() = 2
[11:01:30.929] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.929] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.929]   - Field: ‘label’
[11:01:30.929]   - Field: ‘local’
[11:01:30.929]   - Field: ‘owner’
[11:01:30.930]   - Field: ‘envir’
[11:01:30.930]   - Field: ‘workers’
[11:01:30.930]   - Field: ‘packages’
[11:01:30.930]   - Field: ‘gc’
[11:01:30.930]   - Field: ‘job’
[11:01:30.930]   - Field: ‘conditions’
[11:01:30.930]   - Field: ‘expr’
[11:01:30.931]   - Field: ‘uuid’
[11:01:30.931]   - Field: ‘seed’
[11:01:30.931]   - Field: ‘version’
[11:01:30.931]   - Field: ‘result’
[11:01:30.931]   - Field: ‘asynchronous’
[11:01:30.931]   - Field: ‘calls’
[11:01:30.931]   - Field: ‘globals’
[11:01:30.931]   - Field: ‘stdout’
[11:01:30.932]   - Field: ‘earlySignal’
[11:01:30.932]   - Field: ‘lazy’
[11:01:30.932]   - Field: ‘state’
[11:01:30.932] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.932] - Launch lazy future ...
[11:01:30.933] Packages needed by the future expression (n = 0): <none>
[11:01:30.933] Packages needed by future strategies (n = 0): <none>
[11:01:30.934] {
[11:01:30.934]     {
[11:01:30.934]         {
[11:01:30.934]             ...future.startTime <- base::Sys.time()
[11:01:30.934]             {
[11:01:30.934]                 {
[11:01:30.934]                   {
[11:01:30.934]                     {
[11:01:30.934]                       base::local({
[11:01:30.934]                         has_future <- base::requireNamespace("future", 
[11:01:30.934]                           quietly = TRUE)
[11:01:30.934]                         if (has_future) {
[11:01:30.934]                           ns <- base::getNamespace("future")
[11:01:30.934]                           version <- ns[[".package"]][["version"]]
[11:01:30.934]                           if (is.null(version)) 
[11:01:30.934]                             version <- utils::packageVersion("future")
[11:01:30.934]                         }
[11:01:30.934]                         else {
[11:01:30.934]                           version <- NULL
[11:01:30.934]                         }
[11:01:30.934]                         if (!has_future || version < "1.8.0") {
[11:01:30.934]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.934]                             "", base::R.version$version.string), 
[11:01:30.934]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.934]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.934]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.934]                               "release", "version")], collapse = " "), 
[11:01:30.934]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.934]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.934]                             info)
[11:01:30.934]                           info <- base::paste(info, collapse = "; ")
[11:01:30.934]                           if (!has_future) {
[11:01:30.934]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.934]                               info)
[11:01:30.934]                           }
[11:01:30.934]                           else {
[11:01:30.934]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.934]                               info, version)
[11:01:30.934]                           }
[11:01:30.934]                           base::stop(msg)
[11:01:30.934]                         }
[11:01:30.934]                       })
[11:01:30.934]                     }
[11:01:30.934]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.934]                     base::options(mc.cores = 1L)
[11:01:30.934]                   }
[11:01:30.934]                   ...future.strategy.old <- future::plan("list")
[11:01:30.934]                   options(future.plan = NULL)
[11:01:30.934]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.934]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.934]                 }
[11:01:30.934]                 ...future.workdir <- getwd()
[11:01:30.934]             }
[11:01:30.934]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.934]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.934]         }
[11:01:30.934]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.934]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.934]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.934]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.934]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.934]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.934]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.934]             base::names(...future.oldOptions))
[11:01:30.934]     }
[11:01:30.934]     if (FALSE) {
[11:01:30.934]     }
[11:01:30.934]     else {
[11:01:30.934]         if (TRUE) {
[11:01:30.934]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.934]                 open = "w")
[11:01:30.934]         }
[11:01:30.934]         else {
[11:01:30.934]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.934]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.934]         }
[11:01:30.934]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.934]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.934]             base::sink(type = "output", split = FALSE)
[11:01:30.934]             base::close(...future.stdout)
[11:01:30.934]         }, add = TRUE)
[11:01:30.934]     }
[11:01:30.934]     ...future.frame <- base::sys.nframe()
[11:01:30.934]     ...future.conditions <- base::list()
[11:01:30.934]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.934]     if (FALSE) {
[11:01:30.934]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.934]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.934]     }
[11:01:30.934]     ...future.result <- base::tryCatch({
[11:01:30.934]         base::withCallingHandlers({
[11:01:30.934]             ...future.value <- base::withVisible(base::local({
[11:01:30.934]                 withCallingHandlers({
[11:01:30.934]                   {
[11:01:30.934]                     4
[11:01:30.934]                   }
[11:01:30.934]                 }, immediateCondition = function(cond) {
[11:01:30.934]                   save_rds <- function (object, pathname, ...) 
[11:01:30.934]                   {
[11:01:30.934]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.934]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.934]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.934]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.934]                         fi_tmp[["mtime"]])
[11:01:30.934]                     }
[11:01:30.934]                     tryCatch({
[11:01:30.934]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.934]                     }, error = function(ex) {
[11:01:30.934]                       msg <- conditionMessage(ex)
[11:01:30.934]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.934]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.934]                         fi_tmp[["mtime"]], msg)
[11:01:30.934]                       ex$message <- msg
[11:01:30.934]                       stop(ex)
[11:01:30.934]                     })
[11:01:30.934]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.934]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.934]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.934]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.934]                       fi <- file.info(pathname)
[11:01:30.934]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.934]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.934]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.934]                         fi[["size"]], fi[["mtime"]])
[11:01:30.934]                       stop(msg)
[11:01:30.934]                     }
[11:01:30.934]                     invisible(pathname)
[11:01:30.934]                   }
[11:01:30.934]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.934]                     rootPath = tempdir()) 
[11:01:30.934]                   {
[11:01:30.934]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.934]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.934]                       tmpdir = path, fileext = ".rds")
[11:01:30.934]                     save_rds(obj, file)
[11:01:30.934]                   }
[11:01:30.934]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.934]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.934]                   {
[11:01:30.934]                     inherits <- base::inherits
[11:01:30.934]                     invokeRestart <- base::invokeRestart
[11:01:30.934]                     is.null <- base::is.null
[11:01:30.934]                     muffled <- FALSE
[11:01:30.934]                     if (inherits(cond, "message")) {
[11:01:30.934]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.934]                       if (muffled) 
[11:01:30.934]                         invokeRestart("muffleMessage")
[11:01:30.934]                     }
[11:01:30.934]                     else if (inherits(cond, "warning")) {
[11:01:30.934]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.934]                       if (muffled) 
[11:01:30.934]                         invokeRestart("muffleWarning")
[11:01:30.934]                     }
[11:01:30.934]                     else if (inherits(cond, "condition")) {
[11:01:30.934]                       if (!is.null(pattern)) {
[11:01:30.934]                         computeRestarts <- base::computeRestarts
[11:01:30.934]                         grepl <- base::grepl
[11:01:30.934]                         restarts <- computeRestarts(cond)
[11:01:30.934]                         for (restart in restarts) {
[11:01:30.934]                           name <- restart$name
[11:01:30.934]                           if (is.null(name)) 
[11:01:30.934]                             next
[11:01:30.934]                           if (!grepl(pattern, name)) 
[11:01:30.934]                             next
[11:01:30.934]                           invokeRestart(restart)
[11:01:30.934]                           muffled <- TRUE
[11:01:30.934]                           break
[11:01:30.934]                         }
[11:01:30.934]                       }
[11:01:30.934]                     }
[11:01:30.934]                     invisible(muffled)
[11:01:30.934]                   }
[11:01:30.934]                   muffleCondition(cond)
[11:01:30.934]                 })
[11:01:30.934]             }))
[11:01:30.934]             future::FutureResult(value = ...future.value$value, 
[11:01:30.934]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.934]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.934]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.934]                     ...future.globalenv.names))
[11:01:30.934]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.934]         }, condition = base::local({
[11:01:30.934]             c <- base::c
[11:01:30.934]             inherits <- base::inherits
[11:01:30.934]             invokeRestart <- base::invokeRestart
[11:01:30.934]             length <- base::length
[11:01:30.934]             list <- base::list
[11:01:30.934]             seq.int <- base::seq.int
[11:01:30.934]             signalCondition <- base::signalCondition
[11:01:30.934]             sys.calls <- base::sys.calls
[11:01:30.934]             `[[` <- base::`[[`
[11:01:30.934]             `+` <- base::`+`
[11:01:30.934]             `<<-` <- base::`<<-`
[11:01:30.934]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.934]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.934]                   3L)]
[11:01:30.934]             }
[11:01:30.934]             function(cond) {
[11:01:30.934]                 is_error <- inherits(cond, "error")
[11:01:30.934]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.934]                   NULL)
[11:01:30.934]                 if (is_error) {
[11:01:30.934]                   sessionInformation <- function() {
[11:01:30.934]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.934]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.934]                       search = base::search(), system = base::Sys.info())
[11:01:30.934]                   }
[11:01:30.934]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.934]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.934]                     cond$call), session = sessionInformation(), 
[11:01:30.934]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.934]                   signalCondition(cond)
[11:01:30.934]                 }
[11:01:30.934]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.934]                 "immediateCondition"))) {
[11:01:30.934]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.934]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.934]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.934]                   if (TRUE && !signal) {
[11:01:30.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.934]                     {
[11:01:30.934]                       inherits <- base::inherits
[11:01:30.934]                       invokeRestart <- base::invokeRestart
[11:01:30.934]                       is.null <- base::is.null
[11:01:30.934]                       muffled <- FALSE
[11:01:30.934]                       if (inherits(cond, "message")) {
[11:01:30.934]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.934]                         if (muffled) 
[11:01:30.934]                           invokeRestart("muffleMessage")
[11:01:30.934]                       }
[11:01:30.934]                       else if (inherits(cond, "warning")) {
[11:01:30.934]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.934]                         if (muffled) 
[11:01:30.934]                           invokeRestart("muffleWarning")
[11:01:30.934]                       }
[11:01:30.934]                       else if (inherits(cond, "condition")) {
[11:01:30.934]                         if (!is.null(pattern)) {
[11:01:30.934]                           computeRestarts <- base::computeRestarts
[11:01:30.934]                           grepl <- base::grepl
[11:01:30.934]                           restarts <- computeRestarts(cond)
[11:01:30.934]                           for (restart in restarts) {
[11:01:30.934]                             name <- restart$name
[11:01:30.934]                             if (is.null(name)) 
[11:01:30.934]                               next
[11:01:30.934]                             if (!grepl(pattern, name)) 
[11:01:30.934]                               next
[11:01:30.934]                             invokeRestart(restart)
[11:01:30.934]                             muffled <- TRUE
[11:01:30.934]                             break
[11:01:30.934]                           }
[11:01:30.934]                         }
[11:01:30.934]                       }
[11:01:30.934]                       invisible(muffled)
[11:01:30.934]                     }
[11:01:30.934]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.934]                   }
[11:01:30.934]                 }
[11:01:30.934]                 else {
[11:01:30.934]                   if (TRUE) {
[11:01:30.934]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.934]                     {
[11:01:30.934]                       inherits <- base::inherits
[11:01:30.934]                       invokeRestart <- base::invokeRestart
[11:01:30.934]                       is.null <- base::is.null
[11:01:30.934]                       muffled <- FALSE
[11:01:30.934]                       if (inherits(cond, "message")) {
[11:01:30.934]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.934]                         if (muffled) 
[11:01:30.934]                           invokeRestart("muffleMessage")
[11:01:30.934]                       }
[11:01:30.934]                       else if (inherits(cond, "warning")) {
[11:01:30.934]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.934]                         if (muffled) 
[11:01:30.934]                           invokeRestart("muffleWarning")
[11:01:30.934]                       }
[11:01:30.934]                       else if (inherits(cond, "condition")) {
[11:01:30.934]                         if (!is.null(pattern)) {
[11:01:30.934]                           computeRestarts <- base::computeRestarts
[11:01:30.934]                           grepl <- base::grepl
[11:01:30.934]                           restarts <- computeRestarts(cond)
[11:01:30.934]                           for (restart in restarts) {
[11:01:30.934]                             name <- restart$name
[11:01:30.934]                             if (is.null(name)) 
[11:01:30.934]                               next
[11:01:30.934]                             if (!grepl(pattern, name)) 
[11:01:30.934]                               next
[11:01:30.934]                             invokeRestart(restart)
[11:01:30.934]                             muffled <- TRUE
[11:01:30.934]                             break
[11:01:30.934]                           }
[11:01:30.934]                         }
[11:01:30.934]                       }
[11:01:30.934]                       invisible(muffled)
[11:01:30.934]                     }
[11:01:30.934]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.934]                   }
[11:01:30.934]                 }
[11:01:30.934]             }
[11:01:30.934]         }))
[11:01:30.934]     }, error = function(ex) {
[11:01:30.934]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.934]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.934]                 ...future.rng), started = ...future.startTime, 
[11:01:30.934]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.934]             version = "1.8"), class = "FutureResult")
[11:01:30.934]     }, finally = {
[11:01:30.934]         if (!identical(...future.workdir, getwd())) 
[11:01:30.934]             setwd(...future.workdir)
[11:01:30.934]         {
[11:01:30.934]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.934]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.934]             }
[11:01:30.934]             base::options(...future.oldOptions)
[11:01:30.934]             if (.Platform$OS.type == "windows") {
[11:01:30.934]                 old_names <- names(...future.oldEnvVars)
[11:01:30.934]                 envs <- base::Sys.getenv()
[11:01:30.934]                 names <- names(envs)
[11:01:30.934]                 common <- intersect(names, old_names)
[11:01:30.934]                 added <- setdiff(names, old_names)
[11:01:30.934]                 removed <- setdiff(old_names, names)
[11:01:30.934]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.934]                   envs[common]]
[11:01:30.934]                 NAMES <- toupper(changed)
[11:01:30.934]                 args <- list()
[11:01:30.934]                 for (kk in seq_along(NAMES)) {
[11:01:30.934]                   name <- changed[[kk]]
[11:01:30.934]                   NAME <- NAMES[[kk]]
[11:01:30.934]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.934]                     next
[11:01:30.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.934]                 }
[11:01:30.934]                 NAMES <- toupper(added)
[11:01:30.934]                 for (kk in seq_along(NAMES)) {
[11:01:30.934]                   name <- added[[kk]]
[11:01:30.934]                   NAME <- NAMES[[kk]]
[11:01:30.934]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.934]                     next
[11:01:30.934]                   args[[name]] <- ""
[11:01:30.934]                 }
[11:01:30.934]                 NAMES <- toupper(removed)
[11:01:30.934]                 for (kk in seq_along(NAMES)) {
[11:01:30.934]                   name <- removed[[kk]]
[11:01:30.934]                   NAME <- NAMES[[kk]]
[11:01:30.934]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.934]                     next
[11:01:30.934]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.934]                 }
[11:01:30.934]                 if (length(args) > 0) 
[11:01:30.934]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.934]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.934]             }
[11:01:30.934]             else {
[11:01:30.934]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.934]             }
[11:01:30.934]             {
[11:01:30.934]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.934]                   0L) {
[11:01:30.934]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.934]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.934]                   base::options(opts)
[11:01:30.934]                 }
[11:01:30.934]                 {
[11:01:30.934]                   {
[11:01:30.934]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.934]                     NULL
[11:01:30.934]                   }
[11:01:30.934]                   options(future.plan = NULL)
[11:01:30.934]                   if (is.na(NA_character_)) 
[11:01:30.934]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.934]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.934]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.934]                     .init = FALSE)
[11:01:30.934]                 }
[11:01:30.934]             }
[11:01:30.934]         }
[11:01:30.934]     })
[11:01:30.934]     if (TRUE) {
[11:01:30.934]         base::sink(type = "output", split = FALSE)
[11:01:30.934]         if (TRUE) {
[11:01:30.934]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.934]         }
[11:01:30.934]         else {
[11:01:30.934]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.934]         }
[11:01:30.934]         base::close(...future.stdout)
[11:01:30.934]         ...future.stdout <- NULL
[11:01:30.934]     }
[11:01:30.934]     ...future.result$conditions <- ...future.conditions
[11:01:30.934]     ...future.result$finished <- base::Sys.time()
[11:01:30.934]     ...future.result
[11:01:30.934] }
[11:01:30.937] requestCore(): workers = 2
[11:01:30.937] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:30.948] result() for MulticoreFuture ...
[11:01:30.949] result() for MulticoreFuture ...
[11:01:30.949] result() for MulticoreFuture ... done
[11:01:30.949] result() for MulticoreFuture ... done
[11:01:30.949] result() for MulticoreFuture ...
[11:01:30.950] result() for MulticoreFuture ... done
[11:01:30.952] MulticoreFuture started
[11:01:30.953] - Launch lazy future ... done
[11:01:30.953] run() for ‘MulticoreFuture’ ... done
[11:01:30.953] plan(): Setting new future strategy stack:
<environment: 0x55a9c8dfc028> 
[11:01:30.954] List of future strategies:
[11:01:30.954] 1. sequential:
[11:01:30.954]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.954]    - tweaked: FALSE
[11:01:30.954]    - call: NULL
[11:01:30.955] plan(): nbrOfWorkers() = 1
<environment: 0x55a9c48c3340> 
[11:01:30.958] plan(): Setting new future strategy stack:
[11:01:30.958] List of future strategies:
[11:01:30.958] 1. multicore:
[11:01:30.958]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:30.958]    - tweaked: FALSE
[11:01:30.958]    - call: plan(strategy)
[11:01:30.961] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:30.964] resolve() on environment ...
[11:01:30.964]  recursive: 0
[11:01:30.965]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:30.965] signalConditionsASAP(numeric, pos=1) ...
[11:01:30.965] - nx: 4
[11:01:30.966] - relay: TRUE
[11:01:30.966] - stdout: TRUE
[11:01:30.966] - signal: TRUE
[11:01:30.966] - resignal: FALSE
[11:01:30.966] - force: TRUE
[11:01:30.966] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.966] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.967]  - until=2
[11:01:30.967]  - relaying element #2
[11:01:30.967] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:30.967] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.967] signalConditionsASAP(NULL, pos=1) ... done
[11:01:30.967]  length: 3 (resolved future 1)
[11:01:30.968] Future #2
[11:01:30.968] result() for MulticoreFuture ...
[11:01:30.968] result() for MulticoreFuture ... done
[11:01:30.968] result() for MulticoreFuture ...
[11:01:30.968] result() for MulticoreFuture ... done
[11:01:30.968] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:30.969] - nx: 4
[11:01:30.969] - relay: TRUE
[11:01:30.969] - stdout: TRUE
[11:01:30.969] - signal: TRUE
[11:01:30.969] - resignal: FALSE
[11:01:30.969] - force: TRUE
[11:01:30.969] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:30.969] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:30.970]  - until=2
[11:01:30.970]  - relaying element #2
[11:01:30.970] result() for MulticoreFuture ...
[11:01:30.970] result() for MulticoreFuture ... done
[11:01:30.970] result() for MulticoreFuture ...
[11:01:30.970] result() for MulticoreFuture ... done
[11:01:30.970] result() for MulticoreFuture ...
[11:01:30.971] result() for MulticoreFuture ... done
[11:01:30.971] result() for MulticoreFuture ...
[11:01:30.971] result() for MulticoreFuture ... done
[11:01:30.971] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:30.971] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:30.971] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:30.971]  length: 2 (resolved future 2)
[11:01:30.972] Future #3
[11:01:30.972] result() for MulticoreFuture ...
[11:01:30.973] result() for MulticoreFuture ...
[11:01:30.973] result() for MulticoreFuture ... done
[11:01:30.973] result() for MulticoreFuture ... done
[11:01:30.973] result() for MulticoreFuture ...
[11:01:30.973] result() for MulticoreFuture ... done
[11:01:30.973] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:30.973] - nx: 4
[11:01:30.974] - relay: TRUE
[11:01:30.974] - stdout: TRUE
[11:01:30.974] - signal: TRUE
[11:01:30.974] - resignal: FALSE
[11:01:30.974] - force: TRUE
[11:01:30.974] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:30.974] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:30.974]  - until=3
[11:01:30.974]  - relaying element #3
[11:01:30.975] result() for MulticoreFuture ...
[11:01:30.975] result() for MulticoreFuture ... done
[11:01:30.975] result() for MulticoreFuture ...
[11:01:30.975] result() for MulticoreFuture ... done
[11:01:30.975] result() for MulticoreFuture ...
[11:01:30.975] result() for MulticoreFuture ... done
[11:01:30.975] result() for MulticoreFuture ...
[11:01:30.976] result() for MulticoreFuture ... done
[11:01:30.976] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:30.976] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:30.976] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:30.976]  length: 1 (resolved future 3)
[11:01:30.976] Future #4
[11:01:30.977] result() for MulticoreFuture ...
[11:01:30.977] result() for MulticoreFuture ...
[11:01:30.977] result() for MulticoreFuture ... done
[11:01:30.978] result() for MulticoreFuture ... done
[11:01:30.978] result() for MulticoreFuture ...
[11:01:30.978] result() for MulticoreFuture ... done
[11:01:30.978] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:30.978] - nx: 4
[11:01:30.979] - relay: TRUE
[11:01:30.979] - stdout: TRUE
[11:01:30.979] - signal: TRUE
[11:01:30.979] - resignal: FALSE
[11:01:30.979] - force: TRUE
[11:01:30.979] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:30.979] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:30.980]  - until=4
[11:01:30.980]  - relaying element #4
[11:01:30.980] result() for MulticoreFuture ...
[11:01:30.980] result() for MulticoreFuture ... done
[11:01:30.980] result() for MulticoreFuture ...
[11:01:30.980] result() for MulticoreFuture ... done
[11:01:30.981] result() for MulticoreFuture ...
[11:01:30.981] result() for MulticoreFuture ... done
[11:01:30.981] result() for MulticoreFuture ...
[11:01:30.981] result() for MulticoreFuture ... done
[11:01:30.981] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.981] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:30.982] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:30.982]  length: 0 (resolved future 4)
[11:01:30.982] Relaying remaining futures
[11:01:30.982] signalConditionsASAP(NULL, pos=0) ...
[11:01:30.982] - nx: 4
[11:01:30.982] - relay: TRUE
[11:01:30.982] - stdout: TRUE
[11:01:30.982] - signal: TRUE
[11:01:30.982] - resignal: FALSE
[11:01:30.982] - force: TRUE
[11:01:30.983] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.983] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:30.983] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:30.983] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:30.983] signalConditionsASAP(NULL, pos=0) ... done
[11:01:30.983] resolve() on environment ... DONE
[11:01:30.983] result() for MulticoreFuture ...
[11:01:30.983] result() for MulticoreFuture ... done
[11:01:30.983] result() for MulticoreFuture ...
[11:01:30.984] result() for MulticoreFuture ... done
[11:01:30.984] result() for MulticoreFuture ...
[11:01:30.984] result() for MulticoreFuture ... done
[11:01:30.984] result() for MulticoreFuture ...
[11:01:30.984] result() for MulticoreFuture ... done
[11:01:30.984] result() for MulticoreFuture ...
[11:01:30.984] result() for MulticoreFuture ... done
[11:01:30.984] result() for MulticoreFuture ...
[11:01:30.984] result() for MulticoreFuture ... done
<environment: 0x55a9c5c73160> 
Dimensions: c(2, 1, 3, 1)
[11:01:30.985] getGlobalsAndPackages() ...
[11:01:30.985] Searching for globals...
[11:01:30.985] 
[11:01:30.986] Searching for globals ... DONE
[11:01:30.986] - globals: [0] <none>
[11:01:30.986] getGlobalsAndPackages() ... DONE
[11:01:30.986] run() for ‘Future’ ...
[11:01:30.986] - state: ‘created’
[11:01:30.986] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:30.988] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:30.989] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:30.989]   - Field: ‘label’
[11:01:30.989]   - Field: ‘local’
[11:01:30.989]   - Field: ‘owner’
[11:01:30.989]   - Field: ‘envir’
[11:01:30.989]   - Field: ‘workers’
[11:01:30.989]   - Field: ‘packages’
[11:01:30.989]   - Field: ‘gc’
[11:01:30.989]   - Field: ‘job’
[11:01:30.990]   - Field: ‘conditions’
[11:01:30.990]   - Field: ‘expr’
[11:01:30.990]   - Field: ‘uuid’
[11:01:30.990]   - Field: ‘seed’
[11:01:30.990]   - Field: ‘version’
[11:01:30.990]   - Field: ‘result’
[11:01:30.990]   - Field: ‘asynchronous’
[11:01:30.990]   - Field: ‘calls’
[11:01:30.990]   - Field: ‘globals’
[11:01:30.990]   - Field: ‘stdout’
[11:01:30.991]   - Field: ‘earlySignal’
[11:01:30.991]   - Field: ‘lazy’
[11:01:30.991]   - Field: ‘state’
[11:01:30.991] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:30.991] - Launch lazy future ...
[11:01:30.991] Packages needed by the future expression (n = 0): <none>
[11:01:30.991] Packages needed by future strategies (n = 0): <none>
[11:01:30.992] {
[11:01:30.992]     {
[11:01:30.992]         {
[11:01:30.992]             ...future.startTime <- base::Sys.time()
[11:01:30.992]             {
[11:01:30.992]                 {
[11:01:30.992]                   {
[11:01:30.992]                     {
[11:01:30.992]                       base::local({
[11:01:30.992]                         has_future <- base::requireNamespace("future", 
[11:01:30.992]                           quietly = TRUE)
[11:01:30.992]                         if (has_future) {
[11:01:30.992]                           ns <- base::getNamespace("future")
[11:01:30.992]                           version <- ns[[".package"]][["version"]]
[11:01:30.992]                           if (is.null(version)) 
[11:01:30.992]                             version <- utils::packageVersion("future")
[11:01:30.992]                         }
[11:01:30.992]                         else {
[11:01:30.992]                           version <- NULL
[11:01:30.992]                         }
[11:01:30.992]                         if (!has_future || version < "1.8.0") {
[11:01:30.992]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:30.992]                             "", base::R.version$version.string), 
[11:01:30.992]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:30.992]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:30.992]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:30.992]                               "release", "version")], collapse = " "), 
[11:01:30.992]                             hostname = base::Sys.info()[["nodename"]])
[11:01:30.992]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:30.992]                             info)
[11:01:30.992]                           info <- base::paste(info, collapse = "; ")
[11:01:30.992]                           if (!has_future) {
[11:01:30.992]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:30.992]                               info)
[11:01:30.992]                           }
[11:01:30.992]                           else {
[11:01:30.992]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:30.992]                               info, version)
[11:01:30.992]                           }
[11:01:30.992]                           base::stop(msg)
[11:01:30.992]                         }
[11:01:30.992]                       })
[11:01:30.992]                     }
[11:01:30.992]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:30.992]                     base::options(mc.cores = 1L)
[11:01:30.992]                   }
[11:01:30.992]                   ...future.strategy.old <- future::plan("list")
[11:01:30.992]                   options(future.plan = NULL)
[11:01:30.992]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.992]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:30.992]                 }
[11:01:30.992]                 ...future.workdir <- getwd()
[11:01:30.992]             }
[11:01:30.992]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:30.992]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:30.992]         }
[11:01:30.992]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:30.992]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:30.992]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:30.992]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:30.992]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:30.992]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:30.992]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:30.992]             base::names(...future.oldOptions))
[11:01:30.992]     }
[11:01:30.992]     if (FALSE) {
[11:01:30.992]     }
[11:01:30.992]     else {
[11:01:30.992]         if (TRUE) {
[11:01:30.992]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:30.992]                 open = "w")
[11:01:30.992]         }
[11:01:30.992]         else {
[11:01:30.992]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:30.992]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:30.992]         }
[11:01:30.992]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:30.992]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:30.992]             base::sink(type = "output", split = FALSE)
[11:01:30.992]             base::close(...future.stdout)
[11:01:30.992]         }, add = TRUE)
[11:01:30.992]     }
[11:01:30.992]     ...future.frame <- base::sys.nframe()
[11:01:30.992]     ...future.conditions <- base::list()
[11:01:30.992]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:30.992]     if (FALSE) {
[11:01:30.992]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:30.992]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:30.992]     }
[11:01:30.992]     ...future.result <- base::tryCatch({
[11:01:30.992]         base::withCallingHandlers({
[11:01:30.992]             ...future.value <- base::withVisible(base::local({
[11:01:30.992]                 withCallingHandlers({
[11:01:30.992]                   2
[11:01:30.992]                 }, immediateCondition = function(cond) {
[11:01:30.992]                   save_rds <- function (object, pathname, ...) 
[11:01:30.992]                   {
[11:01:30.992]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:30.992]                     if (file_test("-f", pathname_tmp)) {
[11:01:30.992]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.992]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:30.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.992]                         fi_tmp[["mtime"]])
[11:01:30.992]                     }
[11:01:30.992]                     tryCatch({
[11:01:30.992]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:30.992]                     }, error = function(ex) {
[11:01:30.992]                       msg <- conditionMessage(ex)
[11:01:30.992]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.992]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:30.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.992]                         fi_tmp[["mtime"]], msg)
[11:01:30.992]                       ex$message <- msg
[11:01:30.992]                       stop(ex)
[11:01:30.992]                     })
[11:01:30.992]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:30.992]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:30.992]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:30.992]                       fi_tmp <- file.info(pathname_tmp)
[11:01:30.992]                       fi <- file.info(pathname)
[11:01:30.992]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:30.992]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:30.992]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:30.992]                         fi[["size"]], fi[["mtime"]])
[11:01:30.992]                       stop(msg)
[11:01:30.992]                     }
[11:01:30.992]                     invisible(pathname)
[11:01:30.992]                   }
[11:01:30.992]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:30.992]                     rootPath = tempdir()) 
[11:01:30.992]                   {
[11:01:30.992]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:30.992]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:30.992]                       tmpdir = path, fileext = ".rds")
[11:01:30.992]                     save_rds(obj, file)
[11:01:30.992]                   }
[11:01:30.992]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:30.992]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.992]                   {
[11:01:30.992]                     inherits <- base::inherits
[11:01:30.992]                     invokeRestart <- base::invokeRestart
[11:01:30.992]                     is.null <- base::is.null
[11:01:30.992]                     muffled <- FALSE
[11:01:30.992]                     if (inherits(cond, "message")) {
[11:01:30.992]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:30.992]                       if (muffled) 
[11:01:30.992]                         invokeRestart("muffleMessage")
[11:01:30.992]                     }
[11:01:30.992]                     else if (inherits(cond, "warning")) {
[11:01:30.992]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:30.992]                       if (muffled) 
[11:01:30.992]                         invokeRestart("muffleWarning")
[11:01:30.992]                     }
[11:01:30.992]                     else if (inherits(cond, "condition")) {
[11:01:30.992]                       if (!is.null(pattern)) {
[11:01:30.992]                         computeRestarts <- base::computeRestarts
[11:01:30.992]                         grepl <- base::grepl
[11:01:30.992]                         restarts <- computeRestarts(cond)
[11:01:30.992]                         for (restart in restarts) {
[11:01:30.992]                           name <- restart$name
[11:01:30.992]                           if (is.null(name)) 
[11:01:30.992]                             next
[11:01:30.992]                           if (!grepl(pattern, name)) 
[11:01:30.992]                             next
[11:01:30.992]                           invokeRestart(restart)
[11:01:30.992]                           muffled <- TRUE
[11:01:30.992]                           break
[11:01:30.992]                         }
[11:01:30.992]                       }
[11:01:30.992]                     }
[11:01:30.992]                     invisible(muffled)
[11:01:30.992]                   }
[11:01:30.992]                   muffleCondition(cond)
[11:01:30.992]                 })
[11:01:30.992]             }))
[11:01:30.992]             future::FutureResult(value = ...future.value$value, 
[11:01:30.992]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.992]                   ...future.rng), globalenv = if (FALSE) 
[11:01:30.992]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:30.992]                     ...future.globalenv.names))
[11:01:30.992]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:30.992]         }, condition = base::local({
[11:01:30.992]             c <- base::c
[11:01:30.992]             inherits <- base::inherits
[11:01:30.992]             invokeRestart <- base::invokeRestart
[11:01:30.992]             length <- base::length
[11:01:30.992]             list <- base::list
[11:01:30.992]             seq.int <- base::seq.int
[11:01:30.992]             signalCondition <- base::signalCondition
[11:01:30.992]             sys.calls <- base::sys.calls
[11:01:30.992]             `[[` <- base::`[[`
[11:01:30.992]             `+` <- base::`+`
[11:01:30.992]             `<<-` <- base::`<<-`
[11:01:30.992]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:30.992]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:30.992]                   3L)]
[11:01:30.992]             }
[11:01:30.992]             function(cond) {
[11:01:30.992]                 is_error <- inherits(cond, "error")
[11:01:30.992]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:30.992]                   NULL)
[11:01:30.992]                 if (is_error) {
[11:01:30.992]                   sessionInformation <- function() {
[11:01:30.992]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:30.992]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:30.992]                       search = base::search(), system = base::Sys.info())
[11:01:30.992]                   }
[11:01:30.992]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.992]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:30.992]                     cond$call), session = sessionInformation(), 
[11:01:30.992]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:30.992]                   signalCondition(cond)
[11:01:30.992]                 }
[11:01:30.992]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:30.992]                 "immediateCondition"))) {
[11:01:30.992]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:30.992]                   ...future.conditions[[length(...future.conditions) + 
[11:01:30.992]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:30.992]                   if (TRUE && !signal) {
[11:01:30.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.992]                     {
[11:01:30.992]                       inherits <- base::inherits
[11:01:30.992]                       invokeRestart <- base::invokeRestart
[11:01:30.992]                       is.null <- base::is.null
[11:01:30.992]                       muffled <- FALSE
[11:01:30.992]                       if (inherits(cond, "message")) {
[11:01:30.992]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.992]                         if (muffled) 
[11:01:30.992]                           invokeRestart("muffleMessage")
[11:01:30.992]                       }
[11:01:30.992]                       else if (inherits(cond, "warning")) {
[11:01:30.992]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.992]                         if (muffled) 
[11:01:30.992]                           invokeRestart("muffleWarning")
[11:01:30.992]                       }
[11:01:30.992]                       else if (inherits(cond, "condition")) {
[11:01:30.992]                         if (!is.null(pattern)) {
[11:01:30.992]                           computeRestarts <- base::computeRestarts
[11:01:30.992]                           grepl <- base::grepl
[11:01:30.992]                           restarts <- computeRestarts(cond)
[11:01:30.992]                           for (restart in restarts) {
[11:01:30.992]                             name <- restart$name
[11:01:30.992]                             if (is.null(name)) 
[11:01:30.992]                               next
[11:01:30.992]                             if (!grepl(pattern, name)) 
[11:01:30.992]                               next
[11:01:30.992]                             invokeRestart(restart)
[11:01:30.992]                             muffled <- TRUE
[11:01:30.992]                             break
[11:01:30.992]                           }
[11:01:30.992]                         }
[11:01:30.992]                       }
[11:01:30.992]                       invisible(muffled)
[11:01:30.992]                     }
[11:01:30.992]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.992]                   }
[11:01:30.992]                 }
[11:01:30.992]                 else {
[11:01:30.992]                   if (TRUE) {
[11:01:30.992]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:30.992]                     {
[11:01:30.992]                       inherits <- base::inherits
[11:01:30.992]                       invokeRestart <- base::invokeRestart
[11:01:30.992]                       is.null <- base::is.null
[11:01:30.992]                       muffled <- FALSE
[11:01:30.992]                       if (inherits(cond, "message")) {
[11:01:30.992]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:30.992]                         if (muffled) 
[11:01:30.992]                           invokeRestart("muffleMessage")
[11:01:30.992]                       }
[11:01:30.992]                       else if (inherits(cond, "warning")) {
[11:01:30.992]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:30.992]                         if (muffled) 
[11:01:30.992]                           invokeRestart("muffleWarning")
[11:01:30.992]                       }
[11:01:30.992]                       else if (inherits(cond, "condition")) {
[11:01:30.992]                         if (!is.null(pattern)) {
[11:01:30.992]                           computeRestarts <- base::computeRestarts
[11:01:30.992]                           grepl <- base::grepl
[11:01:30.992]                           restarts <- computeRestarts(cond)
[11:01:30.992]                           for (restart in restarts) {
[11:01:30.992]                             name <- restart$name
[11:01:30.992]                             if (is.null(name)) 
[11:01:30.992]                               next
[11:01:30.992]                             if (!grepl(pattern, name)) 
[11:01:30.992]                               next
[11:01:30.992]                             invokeRestart(restart)
[11:01:30.992]                             muffled <- TRUE
[11:01:30.992]                             break
[11:01:30.992]                           }
[11:01:30.992]                         }
[11:01:30.992]                       }
[11:01:30.992]                       invisible(muffled)
[11:01:30.992]                     }
[11:01:30.992]                     muffleCondition(cond, pattern = "^muffle")
[11:01:30.992]                   }
[11:01:30.992]                 }
[11:01:30.992]             }
[11:01:30.992]         }))
[11:01:30.992]     }, error = function(ex) {
[11:01:30.992]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:30.992]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:30.992]                 ...future.rng), started = ...future.startTime, 
[11:01:30.992]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:30.992]             version = "1.8"), class = "FutureResult")
[11:01:30.992]     }, finally = {
[11:01:30.992]         if (!identical(...future.workdir, getwd())) 
[11:01:30.992]             setwd(...future.workdir)
[11:01:30.992]         {
[11:01:30.992]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:30.992]                 ...future.oldOptions$nwarnings <- NULL
[11:01:30.992]             }
[11:01:30.992]             base::options(...future.oldOptions)
[11:01:30.992]             if (.Platform$OS.type == "windows") {
[11:01:30.992]                 old_names <- names(...future.oldEnvVars)
[11:01:30.992]                 envs <- base::Sys.getenv()
[11:01:30.992]                 names <- names(envs)
[11:01:30.992]                 common <- intersect(names, old_names)
[11:01:30.992]                 added <- setdiff(names, old_names)
[11:01:30.992]                 removed <- setdiff(old_names, names)
[11:01:30.992]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:30.992]                   envs[common]]
[11:01:30.992]                 NAMES <- toupper(changed)
[11:01:30.992]                 args <- list()
[11:01:30.992]                 for (kk in seq_along(NAMES)) {
[11:01:30.992]                   name <- changed[[kk]]
[11:01:30.992]                   NAME <- NAMES[[kk]]
[11:01:30.992]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.992]                     next
[11:01:30.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.992]                 }
[11:01:30.992]                 NAMES <- toupper(added)
[11:01:30.992]                 for (kk in seq_along(NAMES)) {
[11:01:30.992]                   name <- added[[kk]]
[11:01:30.992]                   NAME <- NAMES[[kk]]
[11:01:30.992]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.992]                     next
[11:01:30.992]                   args[[name]] <- ""
[11:01:30.992]                 }
[11:01:30.992]                 NAMES <- toupper(removed)
[11:01:30.992]                 for (kk in seq_along(NAMES)) {
[11:01:30.992]                   name <- removed[[kk]]
[11:01:30.992]                   NAME <- NAMES[[kk]]
[11:01:30.992]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:30.992]                     next
[11:01:30.992]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:30.992]                 }
[11:01:30.992]                 if (length(args) > 0) 
[11:01:30.992]                   base::do.call(base::Sys.setenv, args = args)
[11:01:30.992]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:30.992]             }
[11:01:30.992]             else {
[11:01:30.992]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:30.992]             }
[11:01:30.992]             {
[11:01:30.992]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:30.992]                   0L) {
[11:01:30.992]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:30.992]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:30.992]                   base::options(opts)
[11:01:30.992]                 }
[11:01:30.992]                 {
[11:01:30.992]                   {
[11:01:30.992]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:30.992]                     NULL
[11:01:30.992]                   }
[11:01:30.992]                   options(future.plan = NULL)
[11:01:30.992]                   if (is.na(NA_character_)) 
[11:01:30.992]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:30.992]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:30.992]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:30.992]                     .init = FALSE)
[11:01:30.992]                 }
[11:01:30.992]             }
[11:01:30.992]         }
[11:01:30.992]     })
[11:01:30.992]     if (TRUE) {
[11:01:30.992]         base::sink(type = "output", split = FALSE)
[11:01:30.992]         if (TRUE) {
[11:01:30.992]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:30.992]         }
[11:01:30.992]         else {
[11:01:30.992]             ...future.result["stdout"] <- base::list(NULL)
[11:01:30.992]         }
[11:01:30.992]         base::close(...future.stdout)
[11:01:30.992]         ...future.stdout <- NULL
[11:01:30.992]     }
[11:01:30.992]     ...future.result$conditions <- ...future.conditions
[11:01:30.992]     ...future.result$finished <- base::Sys.time()
[11:01:30.992]     ...future.result
[11:01:30.992] }
[11:01:30.995] requestCore(): workers = 2
[11:01:30.997] MulticoreFuture started
[11:01:30.997] - Launch lazy future ... done
[11:01:30.997] run() for ‘MulticoreFuture’ ... done
[11:01:30.997] getGlobalsAndPackages() ...
[11:01:30.998] Searching for globals...
[11:01:30.998] plan(): Setting new future strategy stack:
[11:01:30.998] 
[11:01:30.998] Searching for globals ... DONE
[11:01:30.998] List of future strategies:
[11:01:30.998] 1. sequential:
[11:01:30.998]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:30.998]    - tweaked: FALSE
[11:01:30.998]    - call: NULL
[11:01:30.999] - globals: [0] <none>
[11:01:30.999] getGlobalsAndPackages() ... DONE
[11:01:30.999] plan(): nbrOfWorkers() = 1
[11:01:30.999] run() for ‘Future’ ...
[11:01:30.999] - state: ‘created’
[11:01:31.000] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.001] plan(): Setting new future strategy stack:
[11:01:31.001] List of future strategies:
[11:01:31.001] 1. multicore:
[11:01:31.001]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:31.001]    - tweaked: FALSE
[11:01:31.001]    - call: plan(strategy)
[11:01:31.003] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.003] plan(): nbrOfWorkers() = 2
[11:01:31.003] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:31.003]   - Field: ‘label’
[11:01:31.003]   - Field: ‘local’
[11:01:31.003]   - Field: ‘owner’
[11:01:31.004]   - Field: ‘envir’
[11:01:31.004]   - Field: ‘workers’
[11:01:31.004]   - Field: ‘packages’
[11:01:31.004]   - Field: ‘gc’
[11:01:31.004]   - Field: ‘job’
[11:01:31.004]   - Field: ‘conditions’
[11:01:31.004]   - Field: ‘expr’
[11:01:31.005]   - Field: ‘uuid’
[11:01:31.005]   - Field: ‘seed’
[11:01:31.005]   - Field: ‘version’
[11:01:31.005]   - Field: ‘result’
[11:01:31.005]   - Field: ‘asynchronous’
[11:01:31.005]   - Field: ‘calls’
[11:01:31.005]   - Field: ‘globals’
[11:01:31.005]   - Field: ‘stdout’
[11:01:31.006]   - Field: ‘earlySignal’
[11:01:31.006]   - Field: ‘lazy’
[11:01:31.006]   - Field: ‘state’
[11:01:31.006] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:31.006] - Launch lazy future ...
[11:01:31.006] Packages needed by the future expression (n = 0): <none>
[11:01:31.007] Packages needed by future strategies (n = 0): <none>
[11:01:31.007] {
[11:01:31.007]     {
[11:01:31.007]         {
[11:01:31.007]             ...future.startTime <- base::Sys.time()
[11:01:31.007]             {
[11:01:31.007]                 {
[11:01:31.007]                   {
[11:01:31.007]                     {
[11:01:31.007]                       base::local({
[11:01:31.007]                         has_future <- base::requireNamespace("future", 
[11:01:31.007]                           quietly = TRUE)
[11:01:31.007]                         if (has_future) {
[11:01:31.007]                           ns <- base::getNamespace("future")
[11:01:31.007]                           version <- ns[[".package"]][["version"]]
[11:01:31.007]                           if (is.null(version)) 
[11:01:31.007]                             version <- utils::packageVersion("future")
[11:01:31.007]                         }
[11:01:31.007]                         else {
[11:01:31.007]                           version <- NULL
[11:01:31.007]                         }
[11:01:31.007]                         if (!has_future || version < "1.8.0") {
[11:01:31.007]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.007]                             "", base::R.version$version.string), 
[11:01:31.007]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.007]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.007]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.007]                               "release", "version")], collapse = " "), 
[11:01:31.007]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.007]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.007]                             info)
[11:01:31.007]                           info <- base::paste(info, collapse = "; ")
[11:01:31.007]                           if (!has_future) {
[11:01:31.007]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.007]                               info)
[11:01:31.007]                           }
[11:01:31.007]                           else {
[11:01:31.007]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.007]                               info, version)
[11:01:31.007]                           }
[11:01:31.007]                           base::stop(msg)
[11:01:31.007]                         }
[11:01:31.007]                       })
[11:01:31.007]                     }
[11:01:31.007]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.007]                     base::options(mc.cores = 1L)
[11:01:31.007]                   }
[11:01:31.007]                   ...future.strategy.old <- future::plan("list")
[11:01:31.007]                   options(future.plan = NULL)
[11:01:31.007]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.007]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.007]                 }
[11:01:31.007]                 ...future.workdir <- getwd()
[11:01:31.007]             }
[11:01:31.007]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.007]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.007]         }
[11:01:31.007]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.007]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.007]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.007]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.007]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.007]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.007]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.007]             base::names(...future.oldOptions))
[11:01:31.007]     }
[11:01:31.007]     if (FALSE) {
[11:01:31.007]     }
[11:01:31.007]     else {
[11:01:31.007]         if (TRUE) {
[11:01:31.007]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.007]                 open = "w")
[11:01:31.007]         }
[11:01:31.007]         else {
[11:01:31.007]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.007]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.007]         }
[11:01:31.007]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.007]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.007]             base::sink(type = "output", split = FALSE)
[11:01:31.007]             base::close(...future.stdout)
[11:01:31.007]         }, add = TRUE)
[11:01:31.007]     }
[11:01:31.007]     ...future.frame <- base::sys.nframe()
[11:01:31.007]     ...future.conditions <- base::list()
[11:01:31.007]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.007]     if (FALSE) {
[11:01:31.007]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.007]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.007]     }
[11:01:31.007]     ...future.result <- base::tryCatch({
[11:01:31.007]         base::withCallingHandlers({
[11:01:31.007]             ...future.value <- base::withVisible(base::local({
[11:01:31.007]                 withCallingHandlers({
[11:01:31.007]                   NULL
[11:01:31.007]                 }, immediateCondition = function(cond) {
[11:01:31.007]                   save_rds <- function (object, pathname, ...) 
[11:01:31.007]                   {
[11:01:31.007]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:31.007]                     if (file_test("-f", pathname_tmp)) {
[11:01:31.007]                       fi_tmp <- file.info(pathname_tmp)
[11:01:31.007]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:31.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:31.007]                         fi_tmp[["mtime"]])
[11:01:31.007]                     }
[11:01:31.007]                     tryCatch({
[11:01:31.007]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:31.007]                     }, error = function(ex) {
[11:01:31.007]                       msg <- conditionMessage(ex)
[11:01:31.007]                       fi_tmp <- file.info(pathname_tmp)
[11:01:31.007]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:31.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:31.007]                         fi_tmp[["mtime"]], msg)
[11:01:31.007]                       ex$message <- msg
[11:01:31.007]                       stop(ex)
[11:01:31.007]                     })
[11:01:31.007]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:31.007]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:31.007]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:31.007]                       fi_tmp <- file.info(pathname_tmp)
[11:01:31.007]                       fi <- file.info(pathname)
[11:01:31.007]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:31.007]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:31.007]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:31.007]                         fi[["size"]], fi[["mtime"]])
[11:01:31.007]                       stop(msg)
[11:01:31.007]                     }
[11:01:31.007]                     invisible(pathname)
[11:01:31.007]                   }
[11:01:31.007]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:31.007]                     rootPath = tempdir()) 
[11:01:31.007]                   {
[11:01:31.007]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:31.007]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:31.007]                       tmpdir = path, fileext = ".rds")
[11:01:31.007]                     save_rds(obj, file)
[11:01:31.007]                   }
[11:01:31.007]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:31.007]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.007]                   {
[11:01:31.007]                     inherits <- base::inherits
[11:01:31.007]                     invokeRestart <- base::invokeRestart
[11:01:31.007]                     is.null <- base::is.null
[11:01:31.007]                     muffled <- FALSE
[11:01:31.007]                     if (inherits(cond, "message")) {
[11:01:31.007]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.007]                       if (muffled) 
[11:01:31.007]                         invokeRestart("muffleMessage")
[11:01:31.007]                     }
[11:01:31.007]                     else if (inherits(cond, "warning")) {
[11:01:31.007]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.007]                       if (muffled) 
[11:01:31.007]                         invokeRestart("muffleWarning")
[11:01:31.007]                     }
[11:01:31.007]                     else if (inherits(cond, "condition")) {
[11:01:31.007]                       if (!is.null(pattern)) {
[11:01:31.007]                         computeRestarts <- base::computeRestarts
[11:01:31.007]                         grepl <- base::grepl
[11:01:31.007]                         restarts <- computeRestarts(cond)
[11:01:31.007]                         for (restart in restarts) {
[11:01:31.007]                           name <- restart$name
[11:01:31.007]                           if (is.null(name)) 
[11:01:31.007]                             next
[11:01:31.007]                           if (!grepl(pattern, name)) 
[11:01:31.007]                             next
[11:01:31.007]                           invokeRestart(restart)
[11:01:31.007]                           muffled <- TRUE
[11:01:31.007]                           break
[11:01:31.007]                         }
[11:01:31.007]                       }
[11:01:31.007]                     }
[11:01:31.007]                     invisible(muffled)
[11:01:31.007]                   }
[11:01:31.007]                   muffleCondition(cond)
[11:01:31.007]                 })
[11:01:31.007]             }))
[11:01:31.007]             future::FutureResult(value = ...future.value$value, 
[11:01:31.007]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.007]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.007]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.007]                     ...future.globalenv.names))
[11:01:31.007]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.007]         }, condition = base::local({
[11:01:31.007]             c <- base::c
[11:01:31.007]             inherits <- base::inherits
[11:01:31.007]             invokeRestart <- base::invokeRestart
[11:01:31.007]             length <- base::length
[11:01:31.007]             list <- base::list
[11:01:31.007]             seq.int <- base::seq.int
[11:01:31.007]             signalCondition <- base::signalCondition
[11:01:31.007]             sys.calls <- base::sys.calls
[11:01:31.007]             `[[` <- base::`[[`
[11:01:31.007]             `+` <- base::`+`
[11:01:31.007]             `<<-` <- base::`<<-`
[11:01:31.007]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.007]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.007]                   3L)]
[11:01:31.007]             }
[11:01:31.007]             function(cond) {
[11:01:31.007]                 is_error <- inherits(cond, "error")
[11:01:31.007]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.007]                   NULL)
[11:01:31.007]                 if (is_error) {
[11:01:31.007]                   sessionInformation <- function() {
[11:01:31.007]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.007]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.007]                       search = base::search(), system = base::Sys.info())
[11:01:31.007]                   }
[11:01:31.007]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.007]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.007]                     cond$call), session = sessionInformation(), 
[11:01:31.007]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.007]                   signalCondition(cond)
[11:01:31.007]                 }
[11:01:31.007]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.007]                 "immediateCondition"))) {
[11:01:31.007]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.007]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.007]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.007]                   if (TRUE && !signal) {
[11:01:31.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.007]                     {
[11:01:31.007]                       inherits <- base::inherits
[11:01:31.007]                       invokeRestart <- base::invokeRestart
[11:01:31.007]                       is.null <- base::is.null
[11:01:31.007]                       muffled <- FALSE
[11:01:31.007]                       if (inherits(cond, "message")) {
[11:01:31.007]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.007]                         if (muffled) 
[11:01:31.007]                           invokeRestart("muffleMessage")
[11:01:31.007]                       }
[11:01:31.007]                       else if (inherits(cond, "warning")) {
[11:01:31.007]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.007]                         if (muffled) 
[11:01:31.007]                           invokeRestart("muffleWarning")
[11:01:31.007]                       }
[11:01:31.007]                       else if (inherits(cond, "condition")) {
[11:01:31.007]                         if (!is.null(pattern)) {
[11:01:31.007]                           computeRestarts <- base::computeRestarts
[11:01:31.007]                           grepl <- base::grepl
[11:01:31.007]                           restarts <- computeRestarts(cond)
[11:01:31.007]                           for (restart in restarts) {
[11:01:31.007]                             name <- restart$name
[11:01:31.007]                             if (is.null(name)) 
[11:01:31.007]                               next
[11:01:31.007]                             if (!grepl(pattern, name)) 
[11:01:31.007]                               next
[11:01:31.007]                             invokeRestart(restart)
[11:01:31.007]                             muffled <- TRUE
[11:01:31.007]                             break
[11:01:31.007]                           }
[11:01:31.007]                         }
[11:01:31.007]                       }
[11:01:31.007]                       invisible(muffled)
[11:01:31.007]                     }
[11:01:31.007]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.007]                   }
[11:01:31.007]                 }
[11:01:31.007]                 else {
[11:01:31.007]                   if (TRUE) {
[11:01:31.007]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.007]                     {
[11:01:31.007]                       inherits <- base::inherits
[11:01:31.007]                       invokeRestart <- base::invokeRestart
[11:01:31.007]                       is.null <- base::is.null
[11:01:31.007]                       muffled <- FALSE
[11:01:31.007]                       if (inherits(cond, "message")) {
[11:01:31.007]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.007]                         if (muffled) 
[11:01:31.007]                           invokeRestart("muffleMessage")
[11:01:31.007]                       }
[11:01:31.007]                       else if (inherits(cond, "warning")) {
[11:01:31.007]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.007]                         if (muffled) 
[11:01:31.007]                           invokeRestart("muffleWarning")
[11:01:31.007]                       }
[11:01:31.007]                       else if (inherits(cond, "condition")) {
[11:01:31.007]                         if (!is.null(pattern)) {
[11:01:31.007]                           computeRestarts <- base::computeRestarts
[11:01:31.007]                           grepl <- base::grepl
[11:01:31.007]                           restarts <- computeRestarts(cond)
[11:01:31.007]                           for (restart in restarts) {
[11:01:31.007]                             name <- restart$name
[11:01:31.007]                             if (is.null(name)) 
[11:01:31.007]                               next
[11:01:31.007]                             if (!grepl(pattern, name)) 
[11:01:31.007]                               next
[11:01:31.007]                             invokeRestart(restart)
[11:01:31.007]                             muffled <- TRUE
[11:01:31.007]                             break
[11:01:31.007]                           }
[11:01:31.007]                         }
[11:01:31.007]                       }
[11:01:31.007]                       invisible(muffled)
[11:01:31.007]                     }
[11:01:31.007]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.007]                   }
[11:01:31.007]                 }
[11:01:31.007]             }
[11:01:31.007]         }))
[11:01:31.007]     }, error = function(ex) {
[11:01:31.007]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.007]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.007]                 ...future.rng), started = ...future.startTime, 
[11:01:31.007]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.007]             version = "1.8"), class = "FutureResult")
[11:01:31.007]     }, finally = {
[11:01:31.007]         if (!identical(...future.workdir, getwd())) 
[11:01:31.007]             setwd(...future.workdir)
[11:01:31.007]         {
[11:01:31.007]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.007]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.007]             }
[11:01:31.007]             base::options(...future.oldOptions)
[11:01:31.007]             if (.Platform$OS.type == "windows") {
[11:01:31.007]                 old_names <- names(...future.oldEnvVars)
[11:01:31.007]                 envs <- base::Sys.getenv()
[11:01:31.007]                 names <- names(envs)
[11:01:31.007]                 common <- intersect(names, old_names)
[11:01:31.007]                 added <- setdiff(names, old_names)
[11:01:31.007]                 removed <- setdiff(old_names, names)
[11:01:31.007]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.007]                   envs[common]]
[11:01:31.007]                 NAMES <- toupper(changed)
[11:01:31.007]                 args <- list()
[11:01:31.007]                 for (kk in seq_along(NAMES)) {
[11:01:31.007]                   name <- changed[[kk]]
[11:01:31.007]                   NAME <- NAMES[[kk]]
[11:01:31.007]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.007]                     next
[11:01:31.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.007]                 }
[11:01:31.007]                 NAMES <- toupper(added)
[11:01:31.007]                 for (kk in seq_along(NAMES)) {
[11:01:31.007]                   name <- added[[kk]]
[11:01:31.007]                   NAME <- NAMES[[kk]]
[11:01:31.007]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.007]                     next
[11:01:31.007]                   args[[name]] <- ""
[11:01:31.007]                 }
[11:01:31.007]                 NAMES <- toupper(removed)
[11:01:31.007]                 for (kk in seq_along(NAMES)) {
[11:01:31.007]                   name <- removed[[kk]]
[11:01:31.007]                   NAME <- NAMES[[kk]]
[11:01:31.007]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.007]                     next
[11:01:31.007]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.007]                 }
[11:01:31.007]                 if (length(args) > 0) 
[11:01:31.007]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.007]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.007]             }
[11:01:31.007]             else {
[11:01:31.007]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.007]             }
[11:01:31.007]             {
[11:01:31.007]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.007]                   0L) {
[11:01:31.007]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.007]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.007]                   base::options(opts)
[11:01:31.007]                 }
[11:01:31.007]                 {
[11:01:31.007]                   {
[11:01:31.007]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.007]                     NULL
[11:01:31.007]                   }
[11:01:31.007]                   options(future.plan = NULL)
[11:01:31.007]                   if (is.na(NA_character_)) 
[11:01:31.007]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.007]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.007]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.007]                     .init = FALSE)
[11:01:31.007]                 }
[11:01:31.007]             }
[11:01:31.007]         }
[11:01:31.007]     })
[11:01:31.007]     if (TRUE) {
[11:01:31.007]         base::sink(type = "output", split = FALSE)
[11:01:31.007]         if (TRUE) {
[11:01:31.007]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.007]         }
[11:01:31.007]         else {
[11:01:31.007]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.007]         }
[11:01:31.007]         base::close(...future.stdout)
[11:01:31.007]         ...future.stdout <- NULL
[11:01:31.007]     }
[11:01:31.007]     ...future.result$conditions <- ...future.conditions
[11:01:31.007]     ...future.result$finished <- base::Sys.time()
[11:01:31.007]     ...future.result
[11:01:31.007] }
[11:01:31.010] requestCore(): workers = 2
[11:01:31.013] MulticoreFuture started
[11:01:31.013] - Launch lazy future ... done
[11:01:31.013] run() for ‘MulticoreFuture’ ... done
[11:01:31.014] plan(): Setting new future strategy stack:
[11:01:31.014] getGlobalsAndPackages() ...
[11:01:31.014] Searching for globals...
[11:01:31.014] List of future strategies:
[11:01:31.014] 1. sequential:
[11:01:31.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:31.014]    - tweaked: FALSE
[11:01:31.014]    - call: NULL
[11:01:31.015] plan(): nbrOfWorkers() = 1
[11:01:31.015] - globals found: [1] ‘{’
[11:01:31.016] Searching for globals ... DONE
[11:01:31.016] Resolving globals: FALSE
[11:01:31.016] 
[11:01:31.016] 
[11:01:31.016] getGlobalsAndPackages() ... DONE
[11:01:31.017] plan(): Setting new future strategy stack:
[11:01:31.017] run() for ‘Future’ ...
[11:01:31.017] - state: ‘created’
[11:01:31.017] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.017] List of future strategies:
[11:01:31.017] 1. multicore:
[11:01:31.017]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:31.017]    - tweaked: FALSE
[11:01:31.017]    - call: plan(strategy)
[11:01:31.020] plan(): nbrOfWorkers() = 2
[11:01:31.020] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.020] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:31.020]   - Field: ‘label’
[11:01:31.020]   - Field: ‘local’
[11:01:31.021]   - Field: ‘owner’
[11:01:31.021]   - Field: ‘envir’
[11:01:31.021]   - Field: ‘workers’
[11:01:31.021]   - Field: ‘packages’
[11:01:31.021]   - Field: ‘gc’
[11:01:31.021]   - Field: ‘job’
[11:01:31.021]   - Field: ‘conditions’
[11:01:31.021]   - Field: ‘expr’
[11:01:31.022]   - Field: ‘uuid’
[11:01:31.022]   - Field: ‘seed’
[11:01:31.022]   - Field: ‘version’
[11:01:31.022]   - Field: ‘result’
[11:01:31.022]   - Field: ‘asynchronous’
[11:01:31.022]   - Field: ‘calls’
[11:01:31.022]   - Field: ‘globals’
[11:01:31.022]   - Field: ‘stdout’
[11:01:31.023]   - Field: ‘earlySignal’
[11:01:31.023]   - Field: ‘lazy’
[11:01:31.023]   - Field: ‘state’
[11:01:31.023] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:31.023] - Launch lazy future ...
[11:01:31.023] Packages needed by the future expression (n = 0): <none>
[11:01:31.024] Packages needed by future strategies (n = 0): <none>
[11:01:31.024] {
[11:01:31.024]     {
[11:01:31.024]         {
[11:01:31.024]             ...future.startTime <- base::Sys.time()
[11:01:31.024]             {
[11:01:31.024]                 {
[11:01:31.024]                   {
[11:01:31.024]                     {
[11:01:31.024]                       base::local({
[11:01:31.024]                         has_future <- base::requireNamespace("future", 
[11:01:31.024]                           quietly = TRUE)
[11:01:31.024]                         if (has_future) {
[11:01:31.024]                           ns <- base::getNamespace("future")
[11:01:31.024]                           version <- ns[[".package"]][["version"]]
[11:01:31.024]                           if (is.null(version)) 
[11:01:31.024]                             version <- utils::packageVersion("future")
[11:01:31.024]                         }
[11:01:31.024]                         else {
[11:01:31.024]                           version <- NULL
[11:01:31.024]                         }
[11:01:31.024]                         if (!has_future || version < "1.8.0") {
[11:01:31.024]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.024]                             "", base::R.version$version.string), 
[11:01:31.024]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.024]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.024]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.024]                               "release", "version")], collapse = " "), 
[11:01:31.024]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.024]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.024]                             info)
[11:01:31.024]                           info <- base::paste(info, collapse = "; ")
[11:01:31.024]                           if (!has_future) {
[11:01:31.024]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.024]                               info)
[11:01:31.024]                           }
[11:01:31.024]                           else {
[11:01:31.024]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.024]                               info, version)
[11:01:31.024]                           }
[11:01:31.024]                           base::stop(msg)
[11:01:31.024]                         }
[11:01:31.024]                       })
[11:01:31.024]                     }
[11:01:31.024]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.024]                     base::options(mc.cores = 1L)
[11:01:31.024]                   }
[11:01:31.024]                   ...future.strategy.old <- future::plan("list")
[11:01:31.024]                   options(future.plan = NULL)
[11:01:31.024]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.024]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.024]                 }
[11:01:31.024]                 ...future.workdir <- getwd()
[11:01:31.024]             }
[11:01:31.024]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.024]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.024]         }
[11:01:31.024]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.024]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.024]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.024]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.024]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.024]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.024]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.024]             base::names(...future.oldOptions))
[11:01:31.024]     }
[11:01:31.024]     if (FALSE) {
[11:01:31.024]     }
[11:01:31.024]     else {
[11:01:31.024]         if (TRUE) {
[11:01:31.024]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.024]                 open = "w")
[11:01:31.024]         }
[11:01:31.024]         else {
[11:01:31.024]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.024]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.024]         }
[11:01:31.024]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.024]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.024]             base::sink(type = "output", split = FALSE)
[11:01:31.024]             base::close(...future.stdout)
[11:01:31.024]         }, add = TRUE)
[11:01:31.024]     }
[11:01:31.024]     ...future.frame <- base::sys.nframe()
[11:01:31.024]     ...future.conditions <- base::list()
[11:01:31.024]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.024]     if (FALSE) {
[11:01:31.024]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.024]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.024]     }
[11:01:31.024]     ...future.result <- base::tryCatch({
[11:01:31.024]         base::withCallingHandlers({
[11:01:31.024]             ...future.value <- base::withVisible(base::local({
[11:01:31.024]                 withCallingHandlers({
[11:01:31.024]                   {
[11:01:31.024]                     4
[11:01:31.024]                   }
[11:01:31.024]                 }, immediateCondition = function(cond) {
[11:01:31.024]                   save_rds <- function (object, pathname, ...) 
[11:01:31.024]                   {
[11:01:31.024]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:31.024]                     if (file_test("-f", pathname_tmp)) {
[11:01:31.024]                       fi_tmp <- file.info(pathname_tmp)
[11:01:31.024]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:31.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:31.024]                         fi_tmp[["mtime"]])
[11:01:31.024]                     }
[11:01:31.024]                     tryCatch({
[11:01:31.024]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:31.024]                     }, error = function(ex) {
[11:01:31.024]                       msg <- conditionMessage(ex)
[11:01:31.024]                       fi_tmp <- file.info(pathname_tmp)
[11:01:31.024]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:31.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:31.024]                         fi_tmp[["mtime"]], msg)
[11:01:31.024]                       ex$message <- msg
[11:01:31.024]                       stop(ex)
[11:01:31.024]                     })
[11:01:31.024]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:31.024]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:31.024]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:31.024]                       fi_tmp <- file.info(pathname_tmp)
[11:01:31.024]                       fi <- file.info(pathname)
[11:01:31.024]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:31.024]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:31.024]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:31.024]                         fi[["size"]], fi[["mtime"]])
[11:01:31.024]                       stop(msg)
[11:01:31.024]                     }
[11:01:31.024]                     invisible(pathname)
[11:01:31.024]                   }
[11:01:31.024]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:31.024]                     rootPath = tempdir()) 
[11:01:31.024]                   {
[11:01:31.024]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:31.024]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:31.024]                       tmpdir = path, fileext = ".rds")
[11:01:31.024]                     save_rds(obj, file)
[11:01:31.024]                   }
[11:01:31.024]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:31.024]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.024]                   {
[11:01:31.024]                     inherits <- base::inherits
[11:01:31.024]                     invokeRestart <- base::invokeRestart
[11:01:31.024]                     is.null <- base::is.null
[11:01:31.024]                     muffled <- FALSE
[11:01:31.024]                     if (inherits(cond, "message")) {
[11:01:31.024]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.024]                       if (muffled) 
[11:01:31.024]                         invokeRestart("muffleMessage")
[11:01:31.024]                     }
[11:01:31.024]                     else if (inherits(cond, "warning")) {
[11:01:31.024]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.024]                       if (muffled) 
[11:01:31.024]                         invokeRestart("muffleWarning")
[11:01:31.024]                     }
[11:01:31.024]                     else if (inherits(cond, "condition")) {
[11:01:31.024]                       if (!is.null(pattern)) {
[11:01:31.024]                         computeRestarts <- base::computeRestarts
[11:01:31.024]                         grepl <- base::grepl
[11:01:31.024]                         restarts <- computeRestarts(cond)
[11:01:31.024]                         for (restart in restarts) {
[11:01:31.024]                           name <- restart$name
[11:01:31.024]                           if (is.null(name)) 
[11:01:31.024]                             next
[11:01:31.024]                           if (!grepl(pattern, name)) 
[11:01:31.024]                             next
[11:01:31.024]                           invokeRestart(restart)
[11:01:31.024]                           muffled <- TRUE
[11:01:31.024]                           break
[11:01:31.024]                         }
[11:01:31.024]                       }
[11:01:31.024]                     }
[11:01:31.024]                     invisible(muffled)
[11:01:31.024]                   }
[11:01:31.024]                   muffleCondition(cond)
[11:01:31.024]                 })
[11:01:31.024]             }))
[11:01:31.024]             future::FutureResult(value = ...future.value$value, 
[11:01:31.024]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.024]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.024]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.024]                     ...future.globalenv.names))
[11:01:31.024]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.024]         }, condition = base::local({
[11:01:31.024]             c <- base::c
[11:01:31.024]             inherits <- base::inherits
[11:01:31.024]             invokeRestart <- base::invokeRestart
[11:01:31.024]             length <- base::length
[11:01:31.024]             list <- base::list
[11:01:31.024]             seq.int <- base::seq.int
[11:01:31.024]             signalCondition <- base::signalCondition
[11:01:31.024]             sys.calls <- base::sys.calls
[11:01:31.024]             `[[` <- base::`[[`
[11:01:31.024]             `+` <- base::`+`
[11:01:31.024]             `<<-` <- base::`<<-`
[11:01:31.024]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.024]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.024]                   3L)]
[11:01:31.024]             }
[11:01:31.024]             function(cond) {
[11:01:31.024]                 is_error <- inherits(cond, "error")
[11:01:31.024]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.024]                   NULL)
[11:01:31.024]                 if (is_error) {
[11:01:31.024]                   sessionInformation <- function() {
[11:01:31.024]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.024]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.024]                       search = base::search(), system = base::Sys.info())
[11:01:31.024]                   }
[11:01:31.024]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.024]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.024]                     cond$call), session = sessionInformation(), 
[11:01:31.024]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.024]                   signalCondition(cond)
[11:01:31.024]                 }
[11:01:31.024]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.024]                 "immediateCondition"))) {
[11:01:31.024]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.024]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.024]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.024]                   if (TRUE && !signal) {
[11:01:31.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.024]                     {
[11:01:31.024]                       inherits <- base::inherits
[11:01:31.024]                       invokeRestart <- base::invokeRestart
[11:01:31.024]                       is.null <- base::is.null
[11:01:31.024]                       muffled <- FALSE
[11:01:31.024]                       if (inherits(cond, "message")) {
[11:01:31.024]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.024]                         if (muffled) 
[11:01:31.024]                           invokeRestart("muffleMessage")
[11:01:31.024]                       }
[11:01:31.024]                       else if (inherits(cond, "warning")) {
[11:01:31.024]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.024]                         if (muffled) 
[11:01:31.024]                           invokeRestart("muffleWarning")
[11:01:31.024]                       }
[11:01:31.024]                       else if (inherits(cond, "condition")) {
[11:01:31.024]                         if (!is.null(pattern)) {
[11:01:31.024]                           computeRestarts <- base::computeRestarts
[11:01:31.024]                           grepl <- base::grepl
[11:01:31.024]                           restarts <- computeRestarts(cond)
[11:01:31.024]                           for (restart in restarts) {
[11:01:31.024]                             name <- restart$name
[11:01:31.024]                             if (is.null(name)) 
[11:01:31.024]                               next
[11:01:31.024]                             if (!grepl(pattern, name)) 
[11:01:31.024]                               next
[11:01:31.024]                             invokeRestart(restart)
[11:01:31.024]                             muffled <- TRUE
[11:01:31.024]                             break
[11:01:31.024]                           }
[11:01:31.024]                         }
[11:01:31.024]                       }
[11:01:31.024]                       invisible(muffled)
[11:01:31.024]                     }
[11:01:31.024]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.024]                   }
[11:01:31.024]                 }
[11:01:31.024]                 else {
[11:01:31.024]                   if (TRUE) {
[11:01:31.024]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.024]                     {
[11:01:31.024]                       inherits <- base::inherits
[11:01:31.024]                       invokeRestart <- base::invokeRestart
[11:01:31.024]                       is.null <- base::is.null
[11:01:31.024]                       muffled <- FALSE
[11:01:31.024]                       if (inherits(cond, "message")) {
[11:01:31.024]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.024]                         if (muffled) 
[11:01:31.024]                           invokeRestart("muffleMessage")
[11:01:31.024]                       }
[11:01:31.024]                       else if (inherits(cond, "warning")) {
[11:01:31.024]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.024]                         if (muffled) 
[11:01:31.024]                           invokeRestart("muffleWarning")
[11:01:31.024]                       }
[11:01:31.024]                       else if (inherits(cond, "condition")) {
[11:01:31.024]                         if (!is.null(pattern)) {
[11:01:31.024]                           computeRestarts <- base::computeRestarts
[11:01:31.024]                           grepl <- base::grepl
[11:01:31.024]                           restarts <- computeRestarts(cond)
[11:01:31.024]                           for (restart in restarts) {
[11:01:31.024]                             name <- restart$name
[11:01:31.024]                             if (is.null(name)) 
[11:01:31.024]                               next
[11:01:31.024]                             if (!grepl(pattern, name)) 
[11:01:31.024]                               next
[11:01:31.024]                             invokeRestart(restart)
[11:01:31.024]                             muffled <- TRUE
[11:01:31.024]                             break
[11:01:31.024]                           }
[11:01:31.024]                         }
[11:01:31.024]                       }
[11:01:31.024]                       invisible(muffled)
[11:01:31.024]                     }
[11:01:31.024]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.024]                   }
[11:01:31.024]                 }
[11:01:31.024]             }
[11:01:31.024]         }))
[11:01:31.024]     }, error = function(ex) {
[11:01:31.024]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.024]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.024]                 ...future.rng), started = ...future.startTime, 
[11:01:31.024]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.024]             version = "1.8"), class = "FutureResult")
[11:01:31.024]     }, finally = {
[11:01:31.024]         if (!identical(...future.workdir, getwd())) 
[11:01:31.024]             setwd(...future.workdir)
[11:01:31.024]         {
[11:01:31.024]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.024]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.024]             }
[11:01:31.024]             base::options(...future.oldOptions)
[11:01:31.024]             if (.Platform$OS.type == "windows") {
[11:01:31.024]                 old_names <- names(...future.oldEnvVars)
[11:01:31.024]                 envs <- base::Sys.getenv()
[11:01:31.024]                 names <- names(envs)
[11:01:31.024]                 common <- intersect(names, old_names)
[11:01:31.024]                 added <- setdiff(names, old_names)
[11:01:31.024]                 removed <- setdiff(old_names, names)
[11:01:31.024]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.024]                   envs[common]]
[11:01:31.024]                 NAMES <- toupper(changed)
[11:01:31.024]                 args <- list()
[11:01:31.024]                 for (kk in seq_along(NAMES)) {
[11:01:31.024]                   name <- changed[[kk]]
[11:01:31.024]                   NAME <- NAMES[[kk]]
[11:01:31.024]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.024]                     next
[11:01:31.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.024]                 }
[11:01:31.024]                 NAMES <- toupper(added)
[11:01:31.024]                 for (kk in seq_along(NAMES)) {
[11:01:31.024]                   name <- added[[kk]]
[11:01:31.024]                   NAME <- NAMES[[kk]]
[11:01:31.024]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.024]                     next
[11:01:31.024]                   args[[name]] <- ""
[11:01:31.024]                 }
[11:01:31.024]                 NAMES <- toupper(removed)
[11:01:31.024]                 for (kk in seq_along(NAMES)) {
[11:01:31.024]                   name <- removed[[kk]]
[11:01:31.024]                   NAME <- NAMES[[kk]]
[11:01:31.024]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.024]                     next
[11:01:31.024]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.024]                 }
[11:01:31.024]                 if (length(args) > 0) 
[11:01:31.024]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.024]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.024]             }
[11:01:31.024]             else {
[11:01:31.024]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.024]             }
[11:01:31.024]             {
[11:01:31.024]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.024]                   0L) {
[11:01:31.024]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.024]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.024]                   base::options(opts)
[11:01:31.024]                 }
[11:01:31.024]                 {
[11:01:31.024]                   {
[11:01:31.024]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.024]                     NULL
[11:01:31.024]                   }
[11:01:31.024]                   options(future.plan = NULL)
[11:01:31.024]                   if (is.na(NA_character_)) 
[11:01:31.024]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.024]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.024]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.024]                     .init = FALSE)
[11:01:31.024]                 }
[11:01:31.024]             }
[11:01:31.024]         }
[11:01:31.024]     })
[11:01:31.024]     if (TRUE) {
[11:01:31.024]         base::sink(type = "output", split = FALSE)
[11:01:31.024]         if (TRUE) {
[11:01:31.024]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.024]         }
[11:01:31.024]         else {
[11:01:31.024]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.024]         }
[11:01:31.024]         base::close(...future.stdout)
[11:01:31.024]         ...future.stdout <- NULL
[11:01:31.024]     }
[11:01:31.024]     ...future.result$conditions <- ...future.conditions
[11:01:31.024]     ...future.result$finished <- base::Sys.time()
[11:01:31.024]     ...future.result
[11:01:31.024] }
[11:01:31.027] requestCore(): workers = 2
[11:01:31.028] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:31.038] result() for MulticoreFuture ...
[11:01:31.039] result() for MulticoreFuture ...
[11:01:31.039] result() for MulticoreFuture ... done
[11:01:31.039] result() for MulticoreFuture ... done
[11:01:31.040] result() for MulticoreFuture ...
[11:01:31.040] result() for MulticoreFuture ... done
[11:01:31.042] MulticoreFuture started
[11:01:31.043] - Launch lazy future ... done
[11:01:31.043] run() for ‘MulticoreFuture’ ... done
[11:01:31.043] plan(): Setting new future strategy stack:
<environment: 0x55a9c7d997a0> 
[11:01:31.044] List of future strategies:
[11:01:31.044] 1. sequential:
[11:01:31.044]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:31.044]    - tweaked: FALSE
[11:01:31.044]    - call: NULL
[11:01:31.045] plan(): nbrOfWorkers() = 1
<environment: 0x55a9c8751c48> 
[11:01:31.048] plan(): Setting new future strategy stack:
[11:01:31.048] List of future strategies:
[11:01:31.048] 1. multicore:
[11:01:31.048]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:31.048]    - tweaked: FALSE
[11:01:31.048]    - call: plan(strategy)
[11:01:31.051] plan(): nbrOfWorkers() = 2
 Named logi [1:4] TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:31.053] resolve() on environment ...
[11:01:31.053]  recursive: 0
[11:01:31.054]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:31.054] signalConditionsASAP(numeric, pos=1) ...
[11:01:31.054] - nx: 4
[11:01:31.054] - relay: TRUE
[11:01:31.054] - stdout: TRUE
[11:01:31.054] - signal: TRUE
[11:01:31.054] - resignal: FALSE
[11:01:31.055] - force: TRUE
[11:01:31.055] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.055] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.055]  - until=2
[11:01:31.055]  - relaying element #2
[11:01:31.055] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.055] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.055] signalConditionsASAP(NULL, pos=1) ... done
[11:01:31.056]  length: 3 (resolved future 1)
[11:01:31.056] Future #2
[11:01:31.056] result() for MulticoreFuture ...
[11:01:31.056] result() for MulticoreFuture ... done
[11:01:31.056] result() for MulticoreFuture ...
[11:01:31.056] result() for MulticoreFuture ... done
[11:01:31.056] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:31.057] - nx: 4
[11:01:31.057] - relay: TRUE
[11:01:31.057] - stdout: TRUE
[11:01:31.057] - signal: TRUE
[11:01:31.057] - resignal: FALSE
[11:01:31.057] - force: TRUE
[11:01:31.057] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.057] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.057]  - until=2
[11:01:31.057]  - relaying element #2
[11:01:31.058] result() for MulticoreFuture ...
[11:01:31.058] result() for MulticoreFuture ... done
[11:01:31.058] result() for MulticoreFuture ...
[11:01:31.058] result() for MulticoreFuture ... done
[11:01:31.058] result() for MulticoreFuture ...
[11:01:31.058] result() for MulticoreFuture ... done
[11:01:31.058] result() for MulticoreFuture ...
[11:01:31.058] result() for MulticoreFuture ... done
[11:01:31.059] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.059] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.059] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:31.059]  length: 2 (resolved future 2)
[11:01:31.059] Future #3
[11:01:31.059] result() for MulticoreFuture ...
[11:01:31.060] result() for MulticoreFuture ...
[11:01:31.060] result() for MulticoreFuture ... done
[11:01:31.060] result() for MulticoreFuture ... done
[11:01:31.061] result() for MulticoreFuture ...
[11:01:31.061] result() for MulticoreFuture ... done
[11:01:31.061] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:31.061] - nx: 4
[11:01:31.061] - relay: TRUE
[11:01:31.061] - stdout: TRUE
[11:01:31.061] - signal: TRUE
[11:01:31.061] - resignal: FALSE
[11:01:31.062] - force: TRUE
[11:01:31.062] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.062] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.062]  - until=3
[11:01:31.062]  - relaying element #3
[11:01:31.062] result() for MulticoreFuture ...
[11:01:31.062] result() for MulticoreFuture ... done
[11:01:31.062] result() for MulticoreFuture ...
[11:01:31.063] result() for MulticoreFuture ... done
[11:01:31.063] result() for MulticoreFuture ...
[11:01:31.063] result() for MulticoreFuture ... done
[11:01:31.063] result() for MulticoreFuture ...
[11:01:31.063] result() for MulticoreFuture ... done
[11:01:31.063] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:31.063] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:31.063] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:31.064]  length: 1 (resolved future 3)
[11:01:31.064] Future #4
[11:01:31.064] result() for MulticoreFuture ...
[11:01:31.065] result() for MulticoreFuture ...
[11:01:31.065] result() for MulticoreFuture ... done
[11:01:31.065] result() for MulticoreFuture ... done
[11:01:31.065] result() for MulticoreFuture ...
[11:01:31.066] result() for MulticoreFuture ... done
[11:01:31.066] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:31.066] - nx: 4
[11:01:31.066] - relay: TRUE
[11:01:31.066] - stdout: TRUE
[11:01:31.066] - signal: TRUE
[11:01:31.066] - resignal: FALSE
[11:01:31.067] - force: TRUE
[11:01:31.067] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:31.067] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:31.067]  - until=4
[11:01:31.067]  - relaying element #4
[11:01:31.067] result() for MulticoreFuture ...
[11:01:31.068] result() for MulticoreFuture ... done
[11:01:31.068] result() for MulticoreFuture ...
[11:01:31.068] result() for MulticoreFuture ... done
[11:01:31.068] result() for MulticoreFuture ...
[11:01:31.068] result() for MulticoreFuture ... done
[11:01:31.068] result() for MulticoreFuture ...
[11:01:31.069] result() for MulticoreFuture ... done
[11:01:31.069] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.069] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:31.069] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:31.073]  length: 0 (resolved future 4)
[11:01:31.073] Relaying remaining futures
[11:01:31.073] signalConditionsASAP(NULL, pos=0) ...
[11:01:31.073] - nx: 4
[11:01:31.073] - relay: TRUE
[11:01:31.073] - stdout: TRUE
[11:01:31.073] - signal: TRUE
[11:01:31.074] - resignal: FALSE
[11:01:31.074] - force: TRUE
[11:01:31.074] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.074] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:31.074] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.074] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:31.074] signalConditionsASAP(NULL, pos=0) ... done
[11:01:31.074] resolve() on environment ... DONE
[11:01:31.074] result() for MulticoreFuture ...
[11:01:31.074] result() for MulticoreFuture ... done
[11:01:31.075] result() for MulticoreFuture ...
[11:01:31.075] result() for MulticoreFuture ... done
[11:01:31.075] result() for MulticoreFuture ...
[11:01:31.075] result() for MulticoreFuture ... done
[11:01:31.075] result() for MulticoreFuture ...
[11:01:31.075] result() for MulticoreFuture ... done
[11:01:31.075] result() for MulticoreFuture ...
[11:01:31.075] result() for MulticoreFuture ... done
[11:01:31.075] result() for MulticoreFuture ...
[11:01:31.076] result() for MulticoreFuture ... done
<environment: 0x55a9c88b6180> 
Type of future: multisession
[11:01:31.076] plan(): Setting new future strategy stack:
[11:01:31.076] List of future strategies:
[11:01:31.076] 1. multisession:
[11:01:31.076]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:31.076]    - tweaked: FALSE
[11:01:31.076]    - call: plan(strategy)
[11:01:31.077] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:01:31.077] multisession:
[11:01:31.077] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:31.077] - tweaked: FALSE
[11:01:31.077] - call: plan(strategy)
[11:01:31.079] getGlobalsAndPackages() ...
[11:01:31.079] Not searching for globals
[11:01:31.079] - globals: [0] <none>
[11:01:31.079] getGlobalsAndPackages() ... DONE
[11:01:31.342] Packages needed by the future expression (n = 0): <none>
[11:01:31.343] Packages needed by future strategies (n = 0): <none>
[11:01:31.343] {
[11:01:31.343]     {
[11:01:31.343]         {
[11:01:31.343]             ...future.startTime <- base::Sys.time()
[11:01:31.343]             {
[11:01:31.343]                 {
[11:01:31.343]                   {
[11:01:31.343]                     {
[11:01:31.343]                       base::local({
[11:01:31.343]                         has_future <- base::requireNamespace("future", 
[11:01:31.343]                           quietly = TRUE)
[11:01:31.343]                         if (has_future) {
[11:01:31.343]                           ns <- base::getNamespace("future")
[11:01:31.343]                           version <- ns[[".package"]][["version"]]
[11:01:31.343]                           if (is.null(version)) 
[11:01:31.343]                             version <- utils::packageVersion("future")
[11:01:31.343]                         }
[11:01:31.343]                         else {
[11:01:31.343]                           version <- NULL
[11:01:31.343]                         }
[11:01:31.343]                         if (!has_future || version < "1.8.0") {
[11:01:31.343]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.343]                             "", base::R.version$version.string), 
[11:01:31.343]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.343]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.343]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.343]                               "release", "version")], collapse = " "), 
[11:01:31.343]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.343]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.343]                             info)
[11:01:31.343]                           info <- base::paste(info, collapse = "; ")
[11:01:31.343]                           if (!has_future) {
[11:01:31.343]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.343]                               info)
[11:01:31.343]                           }
[11:01:31.343]                           else {
[11:01:31.343]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.343]                               info, version)
[11:01:31.343]                           }
[11:01:31.343]                           base::stop(msg)
[11:01:31.343]                         }
[11:01:31.343]                       })
[11:01:31.343]                     }
[11:01:31.343]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.343]                     base::options(mc.cores = 1L)
[11:01:31.343]                   }
[11:01:31.343]                   ...future.strategy.old <- future::plan("list")
[11:01:31.343]                   options(future.plan = NULL)
[11:01:31.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.343]                 }
[11:01:31.343]                 ...future.workdir <- getwd()
[11:01:31.343]             }
[11:01:31.343]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.343]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.343]         }
[11:01:31.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.343]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.343]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.343]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.343]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.343]             base::names(...future.oldOptions))
[11:01:31.343]     }
[11:01:31.343]     if (FALSE) {
[11:01:31.343]     }
[11:01:31.343]     else {
[11:01:31.343]         if (TRUE) {
[11:01:31.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.343]                 open = "w")
[11:01:31.343]         }
[11:01:31.343]         else {
[11:01:31.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.343]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.343]         }
[11:01:31.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.343]             base::sink(type = "output", split = FALSE)
[11:01:31.343]             base::close(...future.stdout)
[11:01:31.343]         }, add = TRUE)
[11:01:31.343]     }
[11:01:31.343]     ...future.frame <- base::sys.nframe()
[11:01:31.343]     ...future.conditions <- base::list()
[11:01:31.343]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.343]     if (FALSE) {
[11:01:31.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.343]     }
[11:01:31.343]     ...future.result <- base::tryCatch({
[11:01:31.343]         base::withCallingHandlers({
[11:01:31.343]             ...future.value <- base::withVisible(base::local({
[11:01:31.343]                 ...future.makeSendCondition <- base::local({
[11:01:31.343]                   sendCondition <- NULL
[11:01:31.343]                   function(frame = 1L) {
[11:01:31.343]                     if (is.function(sendCondition)) 
[11:01:31.343]                       return(sendCondition)
[11:01:31.343]                     ns <- getNamespace("parallel")
[11:01:31.343]                     if (exists("sendData", mode = "function", 
[11:01:31.343]                       envir = ns)) {
[11:01:31.343]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.343]                         envir = ns)
[11:01:31.343]                       envir <- sys.frame(frame)
[11:01:31.343]                       master <- NULL
[11:01:31.343]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.343]                         !identical(envir, emptyenv())) {
[11:01:31.343]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.343]                           inherits = FALSE)) {
[11:01:31.343]                           master <- get("master", mode = "list", 
[11:01:31.343]                             envir = envir, inherits = FALSE)
[11:01:31.343]                           if (inherits(master, c("SOCKnode", 
[11:01:31.343]                             "SOCK0node"))) {
[11:01:31.343]                             sendCondition <<- function(cond) {
[11:01:31.343]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.343]                                 success = TRUE)
[11:01:31.343]                               parallel_sendData(master, data)
[11:01:31.343]                             }
[11:01:31.343]                             return(sendCondition)
[11:01:31.343]                           }
[11:01:31.343]                         }
[11:01:31.343]                         frame <- frame + 1L
[11:01:31.343]                         envir <- sys.frame(frame)
[11:01:31.343]                       }
[11:01:31.343]                     }
[11:01:31.343]                     sendCondition <<- function(cond) NULL
[11:01:31.343]                   }
[11:01:31.343]                 })
[11:01:31.343]                 withCallingHandlers({
[11:01:31.343]                   NA
[11:01:31.343]                 }, immediateCondition = function(cond) {
[11:01:31.343]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.343]                   sendCondition(cond)
[11:01:31.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.343]                   {
[11:01:31.343]                     inherits <- base::inherits
[11:01:31.343]                     invokeRestart <- base::invokeRestart
[11:01:31.343]                     is.null <- base::is.null
[11:01:31.343]                     muffled <- FALSE
[11:01:31.343]                     if (inherits(cond, "message")) {
[11:01:31.343]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.343]                       if (muffled) 
[11:01:31.343]                         invokeRestart("muffleMessage")
[11:01:31.343]                     }
[11:01:31.343]                     else if (inherits(cond, "warning")) {
[11:01:31.343]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.343]                       if (muffled) 
[11:01:31.343]                         invokeRestart("muffleWarning")
[11:01:31.343]                     }
[11:01:31.343]                     else if (inherits(cond, "condition")) {
[11:01:31.343]                       if (!is.null(pattern)) {
[11:01:31.343]                         computeRestarts <- base::computeRestarts
[11:01:31.343]                         grepl <- base::grepl
[11:01:31.343]                         restarts <- computeRestarts(cond)
[11:01:31.343]                         for (restart in restarts) {
[11:01:31.343]                           name <- restart$name
[11:01:31.343]                           if (is.null(name)) 
[11:01:31.343]                             next
[11:01:31.343]                           if (!grepl(pattern, name)) 
[11:01:31.343]                             next
[11:01:31.343]                           invokeRestart(restart)
[11:01:31.343]                           muffled <- TRUE
[11:01:31.343]                           break
[11:01:31.343]                         }
[11:01:31.343]                       }
[11:01:31.343]                     }
[11:01:31.343]                     invisible(muffled)
[11:01:31.343]                   }
[11:01:31.343]                   muffleCondition(cond)
[11:01:31.343]                 })
[11:01:31.343]             }))
[11:01:31.343]             future::FutureResult(value = ...future.value$value, 
[11:01:31.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.343]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.343]                     ...future.globalenv.names))
[11:01:31.343]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.343]         }, condition = base::local({
[11:01:31.343]             c <- base::c
[11:01:31.343]             inherits <- base::inherits
[11:01:31.343]             invokeRestart <- base::invokeRestart
[11:01:31.343]             length <- base::length
[11:01:31.343]             list <- base::list
[11:01:31.343]             seq.int <- base::seq.int
[11:01:31.343]             signalCondition <- base::signalCondition
[11:01:31.343]             sys.calls <- base::sys.calls
[11:01:31.343]             `[[` <- base::`[[`
[11:01:31.343]             `+` <- base::`+`
[11:01:31.343]             `<<-` <- base::`<<-`
[11:01:31.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.343]                   3L)]
[11:01:31.343]             }
[11:01:31.343]             function(cond) {
[11:01:31.343]                 is_error <- inherits(cond, "error")
[11:01:31.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.343]                   NULL)
[11:01:31.343]                 if (is_error) {
[11:01:31.343]                   sessionInformation <- function() {
[11:01:31.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.343]                       search = base::search(), system = base::Sys.info())
[11:01:31.343]                   }
[11:01:31.343]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.343]                     cond$call), session = sessionInformation(), 
[11:01:31.343]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.343]                   signalCondition(cond)
[11:01:31.343]                 }
[11:01:31.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.343]                 "immediateCondition"))) {
[11:01:31.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.343]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.343]                   if (TRUE && !signal) {
[11:01:31.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.343]                     {
[11:01:31.343]                       inherits <- base::inherits
[11:01:31.343]                       invokeRestart <- base::invokeRestart
[11:01:31.343]                       is.null <- base::is.null
[11:01:31.343]                       muffled <- FALSE
[11:01:31.343]                       if (inherits(cond, "message")) {
[11:01:31.343]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.343]                         if (muffled) 
[11:01:31.343]                           invokeRestart("muffleMessage")
[11:01:31.343]                       }
[11:01:31.343]                       else if (inherits(cond, "warning")) {
[11:01:31.343]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.343]                         if (muffled) 
[11:01:31.343]                           invokeRestart("muffleWarning")
[11:01:31.343]                       }
[11:01:31.343]                       else if (inherits(cond, "condition")) {
[11:01:31.343]                         if (!is.null(pattern)) {
[11:01:31.343]                           computeRestarts <- base::computeRestarts
[11:01:31.343]                           grepl <- base::grepl
[11:01:31.343]                           restarts <- computeRestarts(cond)
[11:01:31.343]                           for (restart in restarts) {
[11:01:31.343]                             name <- restart$name
[11:01:31.343]                             if (is.null(name)) 
[11:01:31.343]                               next
[11:01:31.343]                             if (!grepl(pattern, name)) 
[11:01:31.343]                               next
[11:01:31.343]                             invokeRestart(restart)
[11:01:31.343]                             muffled <- TRUE
[11:01:31.343]                             break
[11:01:31.343]                           }
[11:01:31.343]                         }
[11:01:31.343]                       }
[11:01:31.343]                       invisible(muffled)
[11:01:31.343]                     }
[11:01:31.343]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.343]                   }
[11:01:31.343]                 }
[11:01:31.343]                 else {
[11:01:31.343]                   if (TRUE) {
[11:01:31.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.343]                     {
[11:01:31.343]                       inherits <- base::inherits
[11:01:31.343]                       invokeRestart <- base::invokeRestart
[11:01:31.343]                       is.null <- base::is.null
[11:01:31.343]                       muffled <- FALSE
[11:01:31.343]                       if (inherits(cond, "message")) {
[11:01:31.343]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.343]                         if (muffled) 
[11:01:31.343]                           invokeRestart("muffleMessage")
[11:01:31.343]                       }
[11:01:31.343]                       else if (inherits(cond, "warning")) {
[11:01:31.343]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.343]                         if (muffled) 
[11:01:31.343]                           invokeRestart("muffleWarning")
[11:01:31.343]                       }
[11:01:31.343]                       else if (inherits(cond, "condition")) {
[11:01:31.343]                         if (!is.null(pattern)) {
[11:01:31.343]                           computeRestarts <- base::computeRestarts
[11:01:31.343]                           grepl <- base::grepl
[11:01:31.343]                           restarts <- computeRestarts(cond)
[11:01:31.343]                           for (restart in restarts) {
[11:01:31.343]                             name <- restart$name
[11:01:31.343]                             if (is.null(name)) 
[11:01:31.343]                               next
[11:01:31.343]                             if (!grepl(pattern, name)) 
[11:01:31.343]                               next
[11:01:31.343]                             invokeRestart(restart)
[11:01:31.343]                             muffled <- TRUE
[11:01:31.343]                             break
[11:01:31.343]                           }
[11:01:31.343]                         }
[11:01:31.343]                       }
[11:01:31.343]                       invisible(muffled)
[11:01:31.343]                     }
[11:01:31.343]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.343]                   }
[11:01:31.343]                 }
[11:01:31.343]             }
[11:01:31.343]         }))
[11:01:31.343]     }, error = function(ex) {
[11:01:31.343]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.343]                 ...future.rng), started = ...future.startTime, 
[11:01:31.343]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.343]             version = "1.8"), class = "FutureResult")
[11:01:31.343]     }, finally = {
[11:01:31.343]         if (!identical(...future.workdir, getwd())) 
[11:01:31.343]             setwd(...future.workdir)
[11:01:31.343]         {
[11:01:31.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.343]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.343]             }
[11:01:31.343]             base::options(...future.oldOptions)
[11:01:31.343]             if (.Platform$OS.type == "windows") {
[11:01:31.343]                 old_names <- names(...future.oldEnvVars)
[11:01:31.343]                 envs <- base::Sys.getenv()
[11:01:31.343]                 names <- names(envs)
[11:01:31.343]                 common <- intersect(names, old_names)
[11:01:31.343]                 added <- setdiff(names, old_names)
[11:01:31.343]                 removed <- setdiff(old_names, names)
[11:01:31.343]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.343]                   envs[common]]
[11:01:31.343]                 NAMES <- toupper(changed)
[11:01:31.343]                 args <- list()
[11:01:31.343]                 for (kk in seq_along(NAMES)) {
[11:01:31.343]                   name <- changed[[kk]]
[11:01:31.343]                   NAME <- NAMES[[kk]]
[11:01:31.343]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.343]                     next
[11:01:31.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.343]                 }
[11:01:31.343]                 NAMES <- toupper(added)
[11:01:31.343]                 for (kk in seq_along(NAMES)) {
[11:01:31.343]                   name <- added[[kk]]
[11:01:31.343]                   NAME <- NAMES[[kk]]
[11:01:31.343]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.343]                     next
[11:01:31.343]                   args[[name]] <- ""
[11:01:31.343]                 }
[11:01:31.343]                 NAMES <- toupper(removed)
[11:01:31.343]                 for (kk in seq_along(NAMES)) {
[11:01:31.343]                   name <- removed[[kk]]
[11:01:31.343]                   NAME <- NAMES[[kk]]
[11:01:31.343]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.343]                     next
[11:01:31.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.343]                 }
[11:01:31.343]                 if (length(args) > 0) 
[11:01:31.343]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.343]             }
[11:01:31.343]             else {
[11:01:31.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.343]             }
[11:01:31.343]             {
[11:01:31.343]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.343]                   0L) {
[11:01:31.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.343]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.343]                   base::options(opts)
[11:01:31.343]                 }
[11:01:31.343]                 {
[11:01:31.343]                   {
[11:01:31.343]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.343]                     NULL
[11:01:31.343]                   }
[11:01:31.343]                   options(future.plan = NULL)
[11:01:31.343]                   if (is.na(NA_character_)) 
[11:01:31.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.343]                     .init = FALSE)
[11:01:31.343]                 }
[11:01:31.343]             }
[11:01:31.343]         }
[11:01:31.343]     })
[11:01:31.343]     if (TRUE) {
[11:01:31.343]         base::sink(type = "output", split = FALSE)
[11:01:31.343]         if (TRUE) {
[11:01:31.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.343]         }
[11:01:31.343]         else {
[11:01:31.343]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.343]         }
[11:01:31.343]         base::close(...future.stdout)
[11:01:31.343]         ...future.stdout <- NULL
[11:01:31.343]     }
[11:01:31.343]     ...future.result$conditions <- ...future.conditions
[11:01:31.343]     ...future.result$finished <- base::Sys.time()
[11:01:31.343]     ...future.result
[11:01:31.343] }
[11:01:31.395] MultisessionFuture started
[11:01:31.395] result() for ClusterFuture ...
[11:01:31.396] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.396] - Validating connection of MultisessionFuture
[11:01:31.427] - received message: FutureResult
[11:01:31.427] - Received FutureResult
[11:01:31.428] - Erased future from FutureRegistry
[11:01:31.428] result() for ClusterFuture ...
[11:01:31.428] - result already collected: FutureResult
[11:01:31.428] result() for ClusterFuture ... done
[11:01:31.428] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:31.428] result() for ClusterFuture ... done
[11:01:31.428] result() for ClusterFuture ...
[11:01:31.428] - result already collected: FutureResult
[11:01:31.428] result() for ClusterFuture ... done
[11:01:31.429] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:01:31.430] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[11:01:31.430] getGlobalsAndPackages() ...
[11:01:31.431] Searching for globals...
[11:01:31.431] 
[11:01:31.431] Searching for globals ... DONE
[11:01:31.431] - globals: [0] <none>
[11:01:31.431] getGlobalsAndPackages() ... DONE
[11:01:31.432] run() for ‘Future’ ...
[11:01:31.432] - state: ‘created’
[11:01:31.432] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.448] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.449]   - Field: ‘node’
[11:01:31.449]   - Field: ‘label’
[11:01:31.449]   - Field: ‘local’
[11:01:31.449]   - Field: ‘owner’
[11:01:31.449]   - Field: ‘envir’
[11:01:31.450]   - Field: ‘workers’
[11:01:31.450]   - Field: ‘packages’
[11:01:31.450]   - Field: ‘gc’
[11:01:31.450]   - Field: ‘conditions’
[11:01:31.450]   - Field: ‘persistent’
[11:01:31.450]   - Field: ‘expr’
[11:01:31.451]   - Field: ‘uuid’
[11:01:31.451]   - Field: ‘seed’
[11:01:31.451]   - Field: ‘version’
[11:01:31.451]   - Field: ‘result’
[11:01:31.451]   - Field: ‘asynchronous’
[11:01:31.451]   - Field: ‘calls’
[11:01:31.452]   - Field: ‘globals’
[11:01:31.452]   - Field: ‘stdout’
[11:01:31.452]   - Field: ‘earlySignal’
[11:01:31.452]   - Field: ‘lazy’
[11:01:31.452]   - Field: ‘state’
[11:01:31.453] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.453] - Launch lazy future ...
[11:01:31.453] Packages needed by the future expression (n = 0): <none>
[11:01:31.453] Packages needed by future strategies (n = 0): <none>
[11:01:31.454] {
[11:01:31.454]     {
[11:01:31.454]         {
[11:01:31.454]             ...future.startTime <- base::Sys.time()
[11:01:31.454]             {
[11:01:31.454]                 {
[11:01:31.454]                   {
[11:01:31.454]                     {
[11:01:31.454]                       base::local({
[11:01:31.454]                         has_future <- base::requireNamespace("future", 
[11:01:31.454]                           quietly = TRUE)
[11:01:31.454]                         if (has_future) {
[11:01:31.454]                           ns <- base::getNamespace("future")
[11:01:31.454]                           version <- ns[[".package"]][["version"]]
[11:01:31.454]                           if (is.null(version)) 
[11:01:31.454]                             version <- utils::packageVersion("future")
[11:01:31.454]                         }
[11:01:31.454]                         else {
[11:01:31.454]                           version <- NULL
[11:01:31.454]                         }
[11:01:31.454]                         if (!has_future || version < "1.8.0") {
[11:01:31.454]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.454]                             "", base::R.version$version.string), 
[11:01:31.454]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.454]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.454]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.454]                               "release", "version")], collapse = " "), 
[11:01:31.454]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.454]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.454]                             info)
[11:01:31.454]                           info <- base::paste(info, collapse = "; ")
[11:01:31.454]                           if (!has_future) {
[11:01:31.454]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.454]                               info)
[11:01:31.454]                           }
[11:01:31.454]                           else {
[11:01:31.454]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.454]                               info, version)
[11:01:31.454]                           }
[11:01:31.454]                           base::stop(msg)
[11:01:31.454]                         }
[11:01:31.454]                       })
[11:01:31.454]                     }
[11:01:31.454]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.454]                     base::options(mc.cores = 1L)
[11:01:31.454]                   }
[11:01:31.454]                   ...future.strategy.old <- future::plan("list")
[11:01:31.454]                   options(future.plan = NULL)
[11:01:31.454]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.454]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.454]                 }
[11:01:31.454]                 ...future.workdir <- getwd()
[11:01:31.454]             }
[11:01:31.454]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.454]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.454]         }
[11:01:31.454]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.454]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.454]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.454]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.454]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.454]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.454]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.454]             base::names(...future.oldOptions))
[11:01:31.454]     }
[11:01:31.454]     if (FALSE) {
[11:01:31.454]     }
[11:01:31.454]     else {
[11:01:31.454]         if (TRUE) {
[11:01:31.454]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.454]                 open = "w")
[11:01:31.454]         }
[11:01:31.454]         else {
[11:01:31.454]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.454]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.454]         }
[11:01:31.454]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.454]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.454]             base::sink(type = "output", split = FALSE)
[11:01:31.454]             base::close(...future.stdout)
[11:01:31.454]         }, add = TRUE)
[11:01:31.454]     }
[11:01:31.454]     ...future.frame <- base::sys.nframe()
[11:01:31.454]     ...future.conditions <- base::list()
[11:01:31.454]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.454]     if (FALSE) {
[11:01:31.454]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.454]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.454]     }
[11:01:31.454]     ...future.result <- base::tryCatch({
[11:01:31.454]         base::withCallingHandlers({
[11:01:31.454]             ...future.value <- base::withVisible(base::local({
[11:01:31.454]                 ...future.makeSendCondition <- base::local({
[11:01:31.454]                   sendCondition <- NULL
[11:01:31.454]                   function(frame = 1L) {
[11:01:31.454]                     if (is.function(sendCondition)) 
[11:01:31.454]                       return(sendCondition)
[11:01:31.454]                     ns <- getNamespace("parallel")
[11:01:31.454]                     if (exists("sendData", mode = "function", 
[11:01:31.454]                       envir = ns)) {
[11:01:31.454]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.454]                         envir = ns)
[11:01:31.454]                       envir <- sys.frame(frame)
[11:01:31.454]                       master <- NULL
[11:01:31.454]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.454]                         !identical(envir, emptyenv())) {
[11:01:31.454]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.454]                           inherits = FALSE)) {
[11:01:31.454]                           master <- get("master", mode = "list", 
[11:01:31.454]                             envir = envir, inherits = FALSE)
[11:01:31.454]                           if (inherits(master, c("SOCKnode", 
[11:01:31.454]                             "SOCK0node"))) {
[11:01:31.454]                             sendCondition <<- function(cond) {
[11:01:31.454]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.454]                                 success = TRUE)
[11:01:31.454]                               parallel_sendData(master, data)
[11:01:31.454]                             }
[11:01:31.454]                             return(sendCondition)
[11:01:31.454]                           }
[11:01:31.454]                         }
[11:01:31.454]                         frame <- frame + 1L
[11:01:31.454]                         envir <- sys.frame(frame)
[11:01:31.454]                       }
[11:01:31.454]                     }
[11:01:31.454]                     sendCondition <<- function(cond) NULL
[11:01:31.454]                   }
[11:01:31.454]                 })
[11:01:31.454]                 withCallingHandlers({
[11:01:31.454]                   2
[11:01:31.454]                 }, immediateCondition = function(cond) {
[11:01:31.454]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.454]                   sendCondition(cond)
[11:01:31.454]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.454]                   {
[11:01:31.454]                     inherits <- base::inherits
[11:01:31.454]                     invokeRestart <- base::invokeRestart
[11:01:31.454]                     is.null <- base::is.null
[11:01:31.454]                     muffled <- FALSE
[11:01:31.454]                     if (inherits(cond, "message")) {
[11:01:31.454]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.454]                       if (muffled) 
[11:01:31.454]                         invokeRestart("muffleMessage")
[11:01:31.454]                     }
[11:01:31.454]                     else if (inherits(cond, "warning")) {
[11:01:31.454]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.454]                       if (muffled) 
[11:01:31.454]                         invokeRestart("muffleWarning")
[11:01:31.454]                     }
[11:01:31.454]                     else if (inherits(cond, "condition")) {
[11:01:31.454]                       if (!is.null(pattern)) {
[11:01:31.454]                         computeRestarts <- base::computeRestarts
[11:01:31.454]                         grepl <- base::grepl
[11:01:31.454]                         restarts <- computeRestarts(cond)
[11:01:31.454]                         for (restart in restarts) {
[11:01:31.454]                           name <- restart$name
[11:01:31.454]                           if (is.null(name)) 
[11:01:31.454]                             next
[11:01:31.454]                           if (!grepl(pattern, name)) 
[11:01:31.454]                             next
[11:01:31.454]                           invokeRestart(restart)
[11:01:31.454]                           muffled <- TRUE
[11:01:31.454]                           break
[11:01:31.454]                         }
[11:01:31.454]                       }
[11:01:31.454]                     }
[11:01:31.454]                     invisible(muffled)
[11:01:31.454]                   }
[11:01:31.454]                   muffleCondition(cond)
[11:01:31.454]                 })
[11:01:31.454]             }))
[11:01:31.454]             future::FutureResult(value = ...future.value$value, 
[11:01:31.454]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.454]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.454]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.454]                     ...future.globalenv.names))
[11:01:31.454]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.454]         }, condition = base::local({
[11:01:31.454]             c <- base::c
[11:01:31.454]             inherits <- base::inherits
[11:01:31.454]             invokeRestart <- base::invokeRestart
[11:01:31.454]             length <- base::length
[11:01:31.454]             list <- base::list
[11:01:31.454]             seq.int <- base::seq.int
[11:01:31.454]             signalCondition <- base::signalCondition
[11:01:31.454]             sys.calls <- base::sys.calls
[11:01:31.454]             `[[` <- base::`[[`
[11:01:31.454]             `+` <- base::`+`
[11:01:31.454]             `<<-` <- base::`<<-`
[11:01:31.454]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.454]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.454]                   3L)]
[11:01:31.454]             }
[11:01:31.454]             function(cond) {
[11:01:31.454]                 is_error <- inherits(cond, "error")
[11:01:31.454]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.454]                   NULL)
[11:01:31.454]                 if (is_error) {
[11:01:31.454]                   sessionInformation <- function() {
[11:01:31.454]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.454]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.454]                       search = base::search(), system = base::Sys.info())
[11:01:31.454]                   }
[11:01:31.454]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.454]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.454]                     cond$call), session = sessionInformation(), 
[11:01:31.454]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.454]                   signalCondition(cond)
[11:01:31.454]                 }
[11:01:31.454]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.454]                 "immediateCondition"))) {
[11:01:31.454]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.454]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.454]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.454]                   if (TRUE && !signal) {
[11:01:31.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.454]                     {
[11:01:31.454]                       inherits <- base::inherits
[11:01:31.454]                       invokeRestart <- base::invokeRestart
[11:01:31.454]                       is.null <- base::is.null
[11:01:31.454]                       muffled <- FALSE
[11:01:31.454]                       if (inherits(cond, "message")) {
[11:01:31.454]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.454]                         if (muffled) 
[11:01:31.454]                           invokeRestart("muffleMessage")
[11:01:31.454]                       }
[11:01:31.454]                       else if (inherits(cond, "warning")) {
[11:01:31.454]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.454]                         if (muffled) 
[11:01:31.454]                           invokeRestart("muffleWarning")
[11:01:31.454]                       }
[11:01:31.454]                       else if (inherits(cond, "condition")) {
[11:01:31.454]                         if (!is.null(pattern)) {
[11:01:31.454]                           computeRestarts <- base::computeRestarts
[11:01:31.454]                           grepl <- base::grepl
[11:01:31.454]                           restarts <- computeRestarts(cond)
[11:01:31.454]                           for (restart in restarts) {
[11:01:31.454]                             name <- restart$name
[11:01:31.454]                             if (is.null(name)) 
[11:01:31.454]                               next
[11:01:31.454]                             if (!grepl(pattern, name)) 
[11:01:31.454]                               next
[11:01:31.454]                             invokeRestart(restart)
[11:01:31.454]                             muffled <- TRUE
[11:01:31.454]                             break
[11:01:31.454]                           }
[11:01:31.454]                         }
[11:01:31.454]                       }
[11:01:31.454]                       invisible(muffled)
[11:01:31.454]                     }
[11:01:31.454]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.454]                   }
[11:01:31.454]                 }
[11:01:31.454]                 else {
[11:01:31.454]                   if (TRUE) {
[11:01:31.454]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.454]                     {
[11:01:31.454]                       inherits <- base::inherits
[11:01:31.454]                       invokeRestart <- base::invokeRestart
[11:01:31.454]                       is.null <- base::is.null
[11:01:31.454]                       muffled <- FALSE
[11:01:31.454]                       if (inherits(cond, "message")) {
[11:01:31.454]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.454]                         if (muffled) 
[11:01:31.454]                           invokeRestart("muffleMessage")
[11:01:31.454]                       }
[11:01:31.454]                       else if (inherits(cond, "warning")) {
[11:01:31.454]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.454]                         if (muffled) 
[11:01:31.454]                           invokeRestart("muffleWarning")
[11:01:31.454]                       }
[11:01:31.454]                       else if (inherits(cond, "condition")) {
[11:01:31.454]                         if (!is.null(pattern)) {
[11:01:31.454]                           computeRestarts <- base::computeRestarts
[11:01:31.454]                           grepl <- base::grepl
[11:01:31.454]                           restarts <- computeRestarts(cond)
[11:01:31.454]                           for (restart in restarts) {
[11:01:31.454]                             name <- restart$name
[11:01:31.454]                             if (is.null(name)) 
[11:01:31.454]                               next
[11:01:31.454]                             if (!grepl(pattern, name)) 
[11:01:31.454]                               next
[11:01:31.454]                             invokeRestart(restart)
[11:01:31.454]                             muffled <- TRUE
[11:01:31.454]                             break
[11:01:31.454]                           }
[11:01:31.454]                         }
[11:01:31.454]                       }
[11:01:31.454]                       invisible(muffled)
[11:01:31.454]                     }
[11:01:31.454]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.454]                   }
[11:01:31.454]                 }
[11:01:31.454]             }
[11:01:31.454]         }))
[11:01:31.454]     }, error = function(ex) {
[11:01:31.454]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.454]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.454]                 ...future.rng), started = ...future.startTime, 
[11:01:31.454]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.454]             version = "1.8"), class = "FutureResult")
[11:01:31.454]     }, finally = {
[11:01:31.454]         if (!identical(...future.workdir, getwd())) 
[11:01:31.454]             setwd(...future.workdir)
[11:01:31.454]         {
[11:01:31.454]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.454]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.454]             }
[11:01:31.454]             base::options(...future.oldOptions)
[11:01:31.454]             if (.Platform$OS.type == "windows") {
[11:01:31.454]                 old_names <- names(...future.oldEnvVars)
[11:01:31.454]                 envs <- base::Sys.getenv()
[11:01:31.454]                 names <- names(envs)
[11:01:31.454]                 common <- intersect(names, old_names)
[11:01:31.454]                 added <- setdiff(names, old_names)
[11:01:31.454]                 removed <- setdiff(old_names, names)
[11:01:31.454]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.454]                   envs[common]]
[11:01:31.454]                 NAMES <- toupper(changed)
[11:01:31.454]                 args <- list()
[11:01:31.454]                 for (kk in seq_along(NAMES)) {
[11:01:31.454]                   name <- changed[[kk]]
[11:01:31.454]                   NAME <- NAMES[[kk]]
[11:01:31.454]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.454]                     next
[11:01:31.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.454]                 }
[11:01:31.454]                 NAMES <- toupper(added)
[11:01:31.454]                 for (kk in seq_along(NAMES)) {
[11:01:31.454]                   name <- added[[kk]]
[11:01:31.454]                   NAME <- NAMES[[kk]]
[11:01:31.454]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.454]                     next
[11:01:31.454]                   args[[name]] <- ""
[11:01:31.454]                 }
[11:01:31.454]                 NAMES <- toupper(removed)
[11:01:31.454]                 for (kk in seq_along(NAMES)) {
[11:01:31.454]                   name <- removed[[kk]]
[11:01:31.454]                   NAME <- NAMES[[kk]]
[11:01:31.454]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.454]                     next
[11:01:31.454]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.454]                 }
[11:01:31.454]                 if (length(args) > 0) 
[11:01:31.454]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.454]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.454]             }
[11:01:31.454]             else {
[11:01:31.454]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.454]             }
[11:01:31.454]             {
[11:01:31.454]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.454]                   0L) {
[11:01:31.454]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.454]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.454]                   base::options(opts)
[11:01:31.454]                 }
[11:01:31.454]                 {
[11:01:31.454]                   {
[11:01:31.454]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.454]                     NULL
[11:01:31.454]                   }
[11:01:31.454]                   options(future.plan = NULL)
[11:01:31.454]                   if (is.na(NA_character_)) 
[11:01:31.454]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.454]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.454]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.454]                     .init = FALSE)
[11:01:31.454]                 }
[11:01:31.454]             }
[11:01:31.454]         }
[11:01:31.454]     })
[11:01:31.454]     if (TRUE) {
[11:01:31.454]         base::sink(type = "output", split = FALSE)
[11:01:31.454]         if (TRUE) {
[11:01:31.454]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.454]         }
[11:01:31.454]         else {
[11:01:31.454]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.454]         }
[11:01:31.454]         base::close(...future.stdout)
[11:01:31.454]         ...future.stdout <- NULL
[11:01:31.454]     }
[11:01:31.454]     ...future.result$conditions <- ...future.conditions
[11:01:31.454]     ...future.result$finished <- base::Sys.time()
[11:01:31.454]     ...future.result
[11:01:31.454] }
[11:01:31.458] MultisessionFuture started
[11:01:31.458] - Launch lazy future ... done
[11:01:31.459] run() for ‘MultisessionFuture’ ... done
[11:01:31.459] getGlobalsAndPackages() ...
[11:01:31.459] Searching for globals...
[11:01:31.459] 
[11:01:31.459] Searching for globals ... DONE
[11:01:31.460] - globals: [0] <none>
[11:01:31.460] getGlobalsAndPackages() ... DONE
[11:01:31.460] run() for ‘Future’ ...
[11:01:31.460] - state: ‘created’
[11:01:31.460] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.477] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.477] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.477]   - Field: ‘node’
[11:01:31.477]   - Field: ‘label’
[11:01:31.477]   - Field: ‘local’
[11:01:31.477]   - Field: ‘owner’
[11:01:31.478]   - Field: ‘envir’
[11:01:31.478]   - Field: ‘workers’
[11:01:31.478]   - Field: ‘packages’
[11:01:31.478]   - Field: ‘gc’
[11:01:31.478]   - Field: ‘conditions’
[11:01:31.478]   - Field: ‘persistent’
[11:01:31.478]   - Field: ‘expr’
[11:01:31.478]   - Field: ‘uuid’
[11:01:31.478]   - Field: ‘seed’
[11:01:31.478]   - Field: ‘version’
[11:01:31.479]   - Field: ‘result’
[11:01:31.479]   - Field: ‘asynchronous’
[11:01:31.479]   - Field: ‘calls’
[11:01:31.479]   - Field: ‘globals’
[11:01:31.479]   - Field: ‘stdout’
[11:01:31.479]   - Field: ‘earlySignal’
[11:01:31.479]   - Field: ‘lazy’
[11:01:31.479]   - Field: ‘state’
[11:01:31.479] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.479] - Launch lazy future ...
[11:01:31.480] Packages needed by the future expression (n = 0): <none>
[11:01:31.480] Packages needed by future strategies (n = 0): <none>
[11:01:31.480] {
[11:01:31.480]     {
[11:01:31.480]         {
[11:01:31.480]             ...future.startTime <- base::Sys.time()
[11:01:31.480]             {
[11:01:31.480]                 {
[11:01:31.480]                   {
[11:01:31.480]                     {
[11:01:31.480]                       base::local({
[11:01:31.480]                         has_future <- base::requireNamespace("future", 
[11:01:31.480]                           quietly = TRUE)
[11:01:31.480]                         if (has_future) {
[11:01:31.480]                           ns <- base::getNamespace("future")
[11:01:31.480]                           version <- ns[[".package"]][["version"]]
[11:01:31.480]                           if (is.null(version)) 
[11:01:31.480]                             version <- utils::packageVersion("future")
[11:01:31.480]                         }
[11:01:31.480]                         else {
[11:01:31.480]                           version <- NULL
[11:01:31.480]                         }
[11:01:31.480]                         if (!has_future || version < "1.8.0") {
[11:01:31.480]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.480]                             "", base::R.version$version.string), 
[11:01:31.480]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.480]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.480]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.480]                               "release", "version")], collapse = " "), 
[11:01:31.480]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.480]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.480]                             info)
[11:01:31.480]                           info <- base::paste(info, collapse = "; ")
[11:01:31.480]                           if (!has_future) {
[11:01:31.480]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.480]                               info)
[11:01:31.480]                           }
[11:01:31.480]                           else {
[11:01:31.480]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.480]                               info, version)
[11:01:31.480]                           }
[11:01:31.480]                           base::stop(msg)
[11:01:31.480]                         }
[11:01:31.480]                       })
[11:01:31.480]                     }
[11:01:31.480]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.480]                     base::options(mc.cores = 1L)
[11:01:31.480]                   }
[11:01:31.480]                   ...future.strategy.old <- future::plan("list")
[11:01:31.480]                   options(future.plan = NULL)
[11:01:31.480]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.480]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.480]                 }
[11:01:31.480]                 ...future.workdir <- getwd()
[11:01:31.480]             }
[11:01:31.480]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.480]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.480]         }
[11:01:31.480]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.480]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.480]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.480]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.480]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.480]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.480]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.480]             base::names(...future.oldOptions))
[11:01:31.480]     }
[11:01:31.480]     if (FALSE) {
[11:01:31.480]     }
[11:01:31.480]     else {
[11:01:31.480]         if (TRUE) {
[11:01:31.480]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.480]                 open = "w")
[11:01:31.480]         }
[11:01:31.480]         else {
[11:01:31.480]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.480]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.480]         }
[11:01:31.480]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.480]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.480]             base::sink(type = "output", split = FALSE)
[11:01:31.480]             base::close(...future.stdout)
[11:01:31.480]         }, add = TRUE)
[11:01:31.480]     }
[11:01:31.480]     ...future.frame <- base::sys.nframe()
[11:01:31.480]     ...future.conditions <- base::list()
[11:01:31.480]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.480]     if (FALSE) {
[11:01:31.480]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.480]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.480]     }
[11:01:31.480]     ...future.result <- base::tryCatch({
[11:01:31.480]         base::withCallingHandlers({
[11:01:31.480]             ...future.value <- base::withVisible(base::local({
[11:01:31.480]                 ...future.makeSendCondition <- base::local({
[11:01:31.480]                   sendCondition <- NULL
[11:01:31.480]                   function(frame = 1L) {
[11:01:31.480]                     if (is.function(sendCondition)) 
[11:01:31.480]                       return(sendCondition)
[11:01:31.480]                     ns <- getNamespace("parallel")
[11:01:31.480]                     if (exists("sendData", mode = "function", 
[11:01:31.480]                       envir = ns)) {
[11:01:31.480]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.480]                         envir = ns)
[11:01:31.480]                       envir <- sys.frame(frame)
[11:01:31.480]                       master <- NULL
[11:01:31.480]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.480]                         !identical(envir, emptyenv())) {
[11:01:31.480]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.480]                           inherits = FALSE)) {
[11:01:31.480]                           master <- get("master", mode = "list", 
[11:01:31.480]                             envir = envir, inherits = FALSE)
[11:01:31.480]                           if (inherits(master, c("SOCKnode", 
[11:01:31.480]                             "SOCK0node"))) {
[11:01:31.480]                             sendCondition <<- function(cond) {
[11:01:31.480]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.480]                                 success = TRUE)
[11:01:31.480]                               parallel_sendData(master, data)
[11:01:31.480]                             }
[11:01:31.480]                             return(sendCondition)
[11:01:31.480]                           }
[11:01:31.480]                         }
[11:01:31.480]                         frame <- frame + 1L
[11:01:31.480]                         envir <- sys.frame(frame)
[11:01:31.480]                       }
[11:01:31.480]                     }
[11:01:31.480]                     sendCondition <<- function(cond) NULL
[11:01:31.480]                   }
[11:01:31.480]                 })
[11:01:31.480]                 withCallingHandlers({
[11:01:31.480]                   NULL
[11:01:31.480]                 }, immediateCondition = function(cond) {
[11:01:31.480]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.480]                   sendCondition(cond)
[11:01:31.480]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.480]                   {
[11:01:31.480]                     inherits <- base::inherits
[11:01:31.480]                     invokeRestart <- base::invokeRestart
[11:01:31.480]                     is.null <- base::is.null
[11:01:31.480]                     muffled <- FALSE
[11:01:31.480]                     if (inherits(cond, "message")) {
[11:01:31.480]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.480]                       if (muffled) 
[11:01:31.480]                         invokeRestart("muffleMessage")
[11:01:31.480]                     }
[11:01:31.480]                     else if (inherits(cond, "warning")) {
[11:01:31.480]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.480]                       if (muffled) 
[11:01:31.480]                         invokeRestart("muffleWarning")
[11:01:31.480]                     }
[11:01:31.480]                     else if (inherits(cond, "condition")) {
[11:01:31.480]                       if (!is.null(pattern)) {
[11:01:31.480]                         computeRestarts <- base::computeRestarts
[11:01:31.480]                         grepl <- base::grepl
[11:01:31.480]                         restarts <- computeRestarts(cond)
[11:01:31.480]                         for (restart in restarts) {
[11:01:31.480]                           name <- restart$name
[11:01:31.480]                           if (is.null(name)) 
[11:01:31.480]                             next
[11:01:31.480]                           if (!grepl(pattern, name)) 
[11:01:31.480]                             next
[11:01:31.480]                           invokeRestart(restart)
[11:01:31.480]                           muffled <- TRUE
[11:01:31.480]                           break
[11:01:31.480]                         }
[11:01:31.480]                       }
[11:01:31.480]                     }
[11:01:31.480]                     invisible(muffled)
[11:01:31.480]                   }
[11:01:31.480]                   muffleCondition(cond)
[11:01:31.480]                 })
[11:01:31.480]             }))
[11:01:31.480]             future::FutureResult(value = ...future.value$value, 
[11:01:31.480]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.480]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.480]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.480]                     ...future.globalenv.names))
[11:01:31.480]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.480]         }, condition = base::local({
[11:01:31.480]             c <- base::c
[11:01:31.480]             inherits <- base::inherits
[11:01:31.480]             invokeRestart <- base::invokeRestart
[11:01:31.480]             length <- base::length
[11:01:31.480]             list <- base::list
[11:01:31.480]             seq.int <- base::seq.int
[11:01:31.480]             signalCondition <- base::signalCondition
[11:01:31.480]             sys.calls <- base::sys.calls
[11:01:31.480]             `[[` <- base::`[[`
[11:01:31.480]             `+` <- base::`+`
[11:01:31.480]             `<<-` <- base::`<<-`
[11:01:31.480]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.480]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.480]                   3L)]
[11:01:31.480]             }
[11:01:31.480]             function(cond) {
[11:01:31.480]                 is_error <- inherits(cond, "error")
[11:01:31.480]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.480]                   NULL)
[11:01:31.480]                 if (is_error) {
[11:01:31.480]                   sessionInformation <- function() {
[11:01:31.480]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.480]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.480]                       search = base::search(), system = base::Sys.info())
[11:01:31.480]                   }
[11:01:31.480]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.480]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.480]                     cond$call), session = sessionInformation(), 
[11:01:31.480]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.480]                   signalCondition(cond)
[11:01:31.480]                 }
[11:01:31.480]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.480]                 "immediateCondition"))) {
[11:01:31.480]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.480]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.480]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.480]                   if (TRUE && !signal) {
[11:01:31.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.480]                     {
[11:01:31.480]                       inherits <- base::inherits
[11:01:31.480]                       invokeRestart <- base::invokeRestart
[11:01:31.480]                       is.null <- base::is.null
[11:01:31.480]                       muffled <- FALSE
[11:01:31.480]                       if (inherits(cond, "message")) {
[11:01:31.480]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.480]                         if (muffled) 
[11:01:31.480]                           invokeRestart("muffleMessage")
[11:01:31.480]                       }
[11:01:31.480]                       else if (inherits(cond, "warning")) {
[11:01:31.480]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.480]                         if (muffled) 
[11:01:31.480]                           invokeRestart("muffleWarning")
[11:01:31.480]                       }
[11:01:31.480]                       else if (inherits(cond, "condition")) {
[11:01:31.480]                         if (!is.null(pattern)) {
[11:01:31.480]                           computeRestarts <- base::computeRestarts
[11:01:31.480]                           grepl <- base::grepl
[11:01:31.480]                           restarts <- computeRestarts(cond)
[11:01:31.480]                           for (restart in restarts) {
[11:01:31.480]                             name <- restart$name
[11:01:31.480]                             if (is.null(name)) 
[11:01:31.480]                               next
[11:01:31.480]                             if (!grepl(pattern, name)) 
[11:01:31.480]                               next
[11:01:31.480]                             invokeRestart(restart)
[11:01:31.480]                             muffled <- TRUE
[11:01:31.480]                             break
[11:01:31.480]                           }
[11:01:31.480]                         }
[11:01:31.480]                       }
[11:01:31.480]                       invisible(muffled)
[11:01:31.480]                     }
[11:01:31.480]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.480]                   }
[11:01:31.480]                 }
[11:01:31.480]                 else {
[11:01:31.480]                   if (TRUE) {
[11:01:31.480]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.480]                     {
[11:01:31.480]                       inherits <- base::inherits
[11:01:31.480]                       invokeRestart <- base::invokeRestart
[11:01:31.480]                       is.null <- base::is.null
[11:01:31.480]                       muffled <- FALSE
[11:01:31.480]                       if (inherits(cond, "message")) {
[11:01:31.480]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.480]                         if (muffled) 
[11:01:31.480]                           invokeRestart("muffleMessage")
[11:01:31.480]                       }
[11:01:31.480]                       else if (inherits(cond, "warning")) {
[11:01:31.480]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.480]                         if (muffled) 
[11:01:31.480]                           invokeRestart("muffleWarning")
[11:01:31.480]                       }
[11:01:31.480]                       else if (inherits(cond, "condition")) {
[11:01:31.480]                         if (!is.null(pattern)) {
[11:01:31.480]                           computeRestarts <- base::computeRestarts
[11:01:31.480]                           grepl <- base::grepl
[11:01:31.480]                           restarts <- computeRestarts(cond)
[11:01:31.480]                           for (restart in restarts) {
[11:01:31.480]                             name <- restart$name
[11:01:31.480]                             if (is.null(name)) 
[11:01:31.480]                               next
[11:01:31.480]                             if (!grepl(pattern, name)) 
[11:01:31.480]                               next
[11:01:31.480]                             invokeRestart(restart)
[11:01:31.480]                             muffled <- TRUE
[11:01:31.480]                             break
[11:01:31.480]                           }
[11:01:31.480]                         }
[11:01:31.480]                       }
[11:01:31.480]                       invisible(muffled)
[11:01:31.480]                     }
[11:01:31.480]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.480]                   }
[11:01:31.480]                 }
[11:01:31.480]             }
[11:01:31.480]         }))
[11:01:31.480]     }, error = function(ex) {
[11:01:31.480]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.480]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.480]                 ...future.rng), started = ...future.startTime, 
[11:01:31.480]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.480]             version = "1.8"), class = "FutureResult")
[11:01:31.480]     }, finally = {
[11:01:31.480]         if (!identical(...future.workdir, getwd())) 
[11:01:31.480]             setwd(...future.workdir)
[11:01:31.480]         {
[11:01:31.480]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.480]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.480]             }
[11:01:31.480]             base::options(...future.oldOptions)
[11:01:31.480]             if (.Platform$OS.type == "windows") {
[11:01:31.480]                 old_names <- names(...future.oldEnvVars)
[11:01:31.480]                 envs <- base::Sys.getenv()
[11:01:31.480]                 names <- names(envs)
[11:01:31.480]                 common <- intersect(names, old_names)
[11:01:31.480]                 added <- setdiff(names, old_names)
[11:01:31.480]                 removed <- setdiff(old_names, names)
[11:01:31.480]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.480]                   envs[common]]
[11:01:31.480]                 NAMES <- toupper(changed)
[11:01:31.480]                 args <- list()
[11:01:31.480]                 for (kk in seq_along(NAMES)) {
[11:01:31.480]                   name <- changed[[kk]]
[11:01:31.480]                   NAME <- NAMES[[kk]]
[11:01:31.480]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.480]                     next
[11:01:31.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.480]                 }
[11:01:31.480]                 NAMES <- toupper(added)
[11:01:31.480]                 for (kk in seq_along(NAMES)) {
[11:01:31.480]                   name <- added[[kk]]
[11:01:31.480]                   NAME <- NAMES[[kk]]
[11:01:31.480]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.480]                     next
[11:01:31.480]                   args[[name]] <- ""
[11:01:31.480]                 }
[11:01:31.480]                 NAMES <- toupper(removed)
[11:01:31.480]                 for (kk in seq_along(NAMES)) {
[11:01:31.480]                   name <- removed[[kk]]
[11:01:31.480]                   NAME <- NAMES[[kk]]
[11:01:31.480]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.480]                     next
[11:01:31.480]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.480]                 }
[11:01:31.480]                 if (length(args) > 0) 
[11:01:31.480]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.480]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.480]             }
[11:01:31.480]             else {
[11:01:31.480]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.480]             }
[11:01:31.480]             {
[11:01:31.480]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.480]                   0L) {
[11:01:31.480]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.480]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.480]                   base::options(opts)
[11:01:31.480]                 }
[11:01:31.480]                 {
[11:01:31.480]                   {
[11:01:31.480]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.480]                     NULL
[11:01:31.480]                   }
[11:01:31.480]                   options(future.plan = NULL)
[11:01:31.480]                   if (is.na(NA_character_)) 
[11:01:31.480]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.480]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.480]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.480]                     .init = FALSE)
[11:01:31.480]                 }
[11:01:31.480]             }
[11:01:31.480]         }
[11:01:31.480]     })
[11:01:31.480]     if (TRUE) {
[11:01:31.480]         base::sink(type = "output", split = FALSE)
[11:01:31.480]         if (TRUE) {
[11:01:31.480]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.480]         }
[11:01:31.480]         else {
[11:01:31.480]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.480]         }
[11:01:31.480]         base::close(...future.stdout)
[11:01:31.480]         ...future.stdout <- NULL
[11:01:31.480]     }
[11:01:31.480]     ...future.result$conditions <- ...future.conditions
[11:01:31.480]     ...future.result$finished <- base::Sys.time()
[11:01:31.480]     ...future.result
[11:01:31.480] }
[11:01:31.532] MultisessionFuture started
[11:01:31.532] - Launch lazy future ... done
[11:01:31.532] run() for ‘MultisessionFuture’ ... done
[11:01:31.533] getGlobalsAndPackages() ...
[11:01:31.533] Searching for globals...
[11:01:31.534] - globals found: [1] ‘{’
[11:01:31.534] Searching for globals ... DONE
[11:01:31.534] Resolving globals: FALSE
[11:01:31.534] 
[11:01:31.534] 
[11:01:31.535] getGlobalsAndPackages() ... DONE
[11:01:31.535] run() for ‘Future’ ...
[11:01:31.535] - state: ‘created’
[11:01:31.535] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.549] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.550] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.550]   - Field: ‘node’
[11:01:31.550]   - Field: ‘label’
[11:01:31.550]   - Field: ‘local’
[11:01:31.550]   - Field: ‘owner’
[11:01:31.550]   - Field: ‘envir’
[11:01:31.550]   - Field: ‘workers’
[11:01:31.550]   - Field: ‘packages’
[11:01:31.550]   - Field: ‘gc’
[11:01:31.551]   - Field: ‘conditions’
[11:01:31.551]   - Field: ‘persistent’
[11:01:31.551]   - Field: ‘expr’
[11:01:31.551]   - Field: ‘uuid’
[11:01:31.551]   - Field: ‘seed’
[11:01:31.551]   - Field: ‘version’
[11:01:31.551]   - Field: ‘result’
[11:01:31.551]   - Field: ‘asynchronous’
[11:01:31.551]   - Field: ‘calls’
[11:01:31.551]   - Field: ‘globals’
[11:01:31.552]   - Field: ‘stdout’
[11:01:31.552]   - Field: ‘earlySignal’
[11:01:31.552]   - Field: ‘lazy’
[11:01:31.552]   - Field: ‘state’
[11:01:31.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.552] - Launch lazy future ...
[11:01:31.552] Packages needed by the future expression (n = 0): <none>
[11:01:31.553] Packages needed by future strategies (n = 0): <none>
[11:01:31.553] {
[11:01:31.553]     {
[11:01:31.553]         {
[11:01:31.553]             ...future.startTime <- base::Sys.time()
[11:01:31.553]             {
[11:01:31.553]                 {
[11:01:31.553]                   {
[11:01:31.553]                     {
[11:01:31.553]                       base::local({
[11:01:31.553]                         has_future <- base::requireNamespace("future", 
[11:01:31.553]                           quietly = TRUE)
[11:01:31.553]                         if (has_future) {
[11:01:31.553]                           ns <- base::getNamespace("future")
[11:01:31.553]                           version <- ns[[".package"]][["version"]]
[11:01:31.553]                           if (is.null(version)) 
[11:01:31.553]                             version <- utils::packageVersion("future")
[11:01:31.553]                         }
[11:01:31.553]                         else {
[11:01:31.553]                           version <- NULL
[11:01:31.553]                         }
[11:01:31.553]                         if (!has_future || version < "1.8.0") {
[11:01:31.553]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.553]                             "", base::R.version$version.string), 
[11:01:31.553]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.553]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.553]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.553]                               "release", "version")], collapse = " "), 
[11:01:31.553]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.553]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.553]                             info)
[11:01:31.553]                           info <- base::paste(info, collapse = "; ")
[11:01:31.553]                           if (!has_future) {
[11:01:31.553]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.553]                               info)
[11:01:31.553]                           }
[11:01:31.553]                           else {
[11:01:31.553]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.553]                               info, version)
[11:01:31.553]                           }
[11:01:31.553]                           base::stop(msg)
[11:01:31.553]                         }
[11:01:31.553]                       })
[11:01:31.553]                     }
[11:01:31.553]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.553]                     base::options(mc.cores = 1L)
[11:01:31.553]                   }
[11:01:31.553]                   ...future.strategy.old <- future::plan("list")
[11:01:31.553]                   options(future.plan = NULL)
[11:01:31.553]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.553]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.553]                 }
[11:01:31.553]                 ...future.workdir <- getwd()
[11:01:31.553]             }
[11:01:31.553]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.553]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.553]         }
[11:01:31.553]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.553]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.553]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.553]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.553]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.553]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.553]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.553]             base::names(...future.oldOptions))
[11:01:31.553]     }
[11:01:31.553]     if (FALSE) {
[11:01:31.553]     }
[11:01:31.553]     else {
[11:01:31.553]         if (TRUE) {
[11:01:31.553]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.553]                 open = "w")
[11:01:31.553]         }
[11:01:31.553]         else {
[11:01:31.553]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.553]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.553]         }
[11:01:31.553]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.553]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.553]             base::sink(type = "output", split = FALSE)
[11:01:31.553]             base::close(...future.stdout)
[11:01:31.553]         }, add = TRUE)
[11:01:31.553]     }
[11:01:31.553]     ...future.frame <- base::sys.nframe()
[11:01:31.553]     ...future.conditions <- base::list()
[11:01:31.553]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.553]     if (FALSE) {
[11:01:31.553]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.553]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.553]     }
[11:01:31.553]     ...future.result <- base::tryCatch({
[11:01:31.553]         base::withCallingHandlers({
[11:01:31.553]             ...future.value <- base::withVisible(base::local({
[11:01:31.553]                 ...future.makeSendCondition <- base::local({
[11:01:31.553]                   sendCondition <- NULL
[11:01:31.553]                   function(frame = 1L) {
[11:01:31.553]                     if (is.function(sendCondition)) 
[11:01:31.553]                       return(sendCondition)
[11:01:31.553]                     ns <- getNamespace("parallel")
[11:01:31.553]                     if (exists("sendData", mode = "function", 
[11:01:31.553]                       envir = ns)) {
[11:01:31.553]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.553]                         envir = ns)
[11:01:31.553]                       envir <- sys.frame(frame)
[11:01:31.553]                       master <- NULL
[11:01:31.553]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.553]                         !identical(envir, emptyenv())) {
[11:01:31.553]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.553]                           inherits = FALSE)) {
[11:01:31.553]                           master <- get("master", mode = "list", 
[11:01:31.553]                             envir = envir, inherits = FALSE)
[11:01:31.553]                           if (inherits(master, c("SOCKnode", 
[11:01:31.553]                             "SOCK0node"))) {
[11:01:31.553]                             sendCondition <<- function(cond) {
[11:01:31.553]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.553]                                 success = TRUE)
[11:01:31.553]                               parallel_sendData(master, data)
[11:01:31.553]                             }
[11:01:31.553]                             return(sendCondition)
[11:01:31.553]                           }
[11:01:31.553]                         }
[11:01:31.553]                         frame <- frame + 1L
[11:01:31.553]                         envir <- sys.frame(frame)
[11:01:31.553]                       }
[11:01:31.553]                     }
[11:01:31.553]                     sendCondition <<- function(cond) NULL
[11:01:31.553]                   }
[11:01:31.553]                 })
[11:01:31.553]                 withCallingHandlers({
[11:01:31.553]                   {
[11:01:31.553]                     4
[11:01:31.553]                   }
[11:01:31.553]                 }, immediateCondition = function(cond) {
[11:01:31.553]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.553]                   sendCondition(cond)
[11:01:31.553]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.553]                   {
[11:01:31.553]                     inherits <- base::inherits
[11:01:31.553]                     invokeRestart <- base::invokeRestart
[11:01:31.553]                     is.null <- base::is.null
[11:01:31.553]                     muffled <- FALSE
[11:01:31.553]                     if (inherits(cond, "message")) {
[11:01:31.553]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.553]                       if (muffled) 
[11:01:31.553]                         invokeRestart("muffleMessage")
[11:01:31.553]                     }
[11:01:31.553]                     else if (inherits(cond, "warning")) {
[11:01:31.553]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.553]                       if (muffled) 
[11:01:31.553]                         invokeRestart("muffleWarning")
[11:01:31.553]                     }
[11:01:31.553]                     else if (inherits(cond, "condition")) {
[11:01:31.553]                       if (!is.null(pattern)) {
[11:01:31.553]                         computeRestarts <- base::computeRestarts
[11:01:31.553]                         grepl <- base::grepl
[11:01:31.553]                         restarts <- computeRestarts(cond)
[11:01:31.553]                         for (restart in restarts) {
[11:01:31.553]                           name <- restart$name
[11:01:31.553]                           if (is.null(name)) 
[11:01:31.553]                             next
[11:01:31.553]                           if (!grepl(pattern, name)) 
[11:01:31.553]                             next
[11:01:31.553]                           invokeRestart(restart)
[11:01:31.553]                           muffled <- TRUE
[11:01:31.553]                           break
[11:01:31.553]                         }
[11:01:31.553]                       }
[11:01:31.553]                     }
[11:01:31.553]                     invisible(muffled)
[11:01:31.553]                   }
[11:01:31.553]                   muffleCondition(cond)
[11:01:31.553]                 })
[11:01:31.553]             }))
[11:01:31.553]             future::FutureResult(value = ...future.value$value, 
[11:01:31.553]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.553]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.553]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.553]                     ...future.globalenv.names))
[11:01:31.553]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.553]         }, condition = base::local({
[11:01:31.553]             c <- base::c
[11:01:31.553]             inherits <- base::inherits
[11:01:31.553]             invokeRestart <- base::invokeRestart
[11:01:31.553]             length <- base::length
[11:01:31.553]             list <- base::list
[11:01:31.553]             seq.int <- base::seq.int
[11:01:31.553]             signalCondition <- base::signalCondition
[11:01:31.553]             sys.calls <- base::sys.calls
[11:01:31.553]             `[[` <- base::`[[`
[11:01:31.553]             `+` <- base::`+`
[11:01:31.553]             `<<-` <- base::`<<-`
[11:01:31.553]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.553]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.553]                   3L)]
[11:01:31.553]             }
[11:01:31.553]             function(cond) {
[11:01:31.553]                 is_error <- inherits(cond, "error")
[11:01:31.553]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.553]                   NULL)
[11:01:31.553]                 if (is_error) {
[11:01:31.553]                   sessionInformation <- function() {
[11:01:31.553]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.553]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.553]                       search = base::search(), system = base::Sys.info())
[11:01:31.553]                   }
[11:01:31.553]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.553]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.553]                     cond$call), session = sessionInformation(), 
[11:01:31.553]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.553]                   signalCondition(cond)
[11:01:31.553]                 }
[11:01:31.553]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.553]                 "immediateCondition"))) {
[11:01:31.553]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.553]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.553]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.553]                   if (TRUE && !signal) {
[11:01:31.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.553]                     {
[11:01:31.553]                       inherits <- base::inherits
[11:01:31.553]                       invokeRestart <- base::invokeRestart
[11:01:31.553]                       is.null <- base::is.null
[11:01:31.553]                       muffled <- FALSE
[11:01:31.553]                       if (inherits(cond, "message")) {
[11:01:31.553]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.553]                         if (muffled) 
[11:01:31.553]                           invokeRestart("muffleMessage")
[11:01:31.553]                       }
[11:01:31.553]                       else if (inherits(cond, "warning")) {
[11:01:31.553]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.553]                         if (muffled) 
[11:01:31.553]                           invokeRestart("muffleWarning")
[11:01:31.553]                       }
[11:01:31.553]                       else if (inherits(cond, "condition")) {
[11:01:31.553]                         if (!is.null(pattern)) {
[11:01:31.553]                           computeRestarts <- base::computeRestarts
[11:01:31.553]                           grepl <- base::grepl
[11:01:31.553]                           restarts <- computeRestarts(cond)
[11:01:31.553]                           for (restart in restarts) {
[11:01:31.553]                             name <- restart$name
[11:01:31.553]                             if (is.null(name)) 
[11:01:31.553]                               next
[11:01:31.553]                             if (!grepl(pattern, name)) 
[11:01:31.553]                               next
[11:01:31.553]                             invokeRestart(restart)
[11:01:31.553]                             muffled <- TRUE
[11:01:31.553]                             break
[11:01:31.553]                           }
[11:01:31.553]                         }
[11:01:31.553]                       }
[11:01:31.553]                       invisible(muffled)
[11:01:31.553]                     }
[11:01:31.553]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.553]                   }
[11:01:31.553]                 }
[11:01:31.553]                 else {
[11:01:31.553]                   if (TRUE) {
[11:01:31.553]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.553]                     {
[11:01:31.553]                       inherits <- base::inherits
[11:01:31.553]                       invokeRestart <- base::invokeRestart
[11:01:31.553]                       is.null <- base::is.null
[11:01:31.553]                       muffled <- FALSE
[11:01:31.553]                       if (inherits(cond, "message")) {
[11:01:31.553]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.553]                         if (muffled) 
[11:01:31.553]                           invokeRestart("muffleMessage")
[11:01:31.553]                       }
[11:01:31.553]                       else if (inherits(cond, "warning")) {
[11:01:31.553]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.553]                         if (muffled) 
[11:01:31.553]                           invokeRestart("muffleWarning")
[11:01:31.553]                       }
[11:01:31.553]                       else if (inherits(cond, "condition")) {
[11:01:31.553]                         if (!is.null(pattern)) {
[11:01:31.553]                           computeRestarts <- base::computeRestarts
[11:01:31.553]                           grepl <- base::grepl
[11:01:31.553]                           restarts <- computeRestarts(cond)
[11:01:31.553]                           for (restart in restarts) {
[11:01:31.553]                             name <- restart$name
[11:01:31.553]                             if (is.null(name)) 
[11:01:31.553]                               next
[11:01:31.553]                             if (!grepl(pattern, name)) 
[11:01:31.553]                               next
[11:01:31.553]                             invokeRestart(restart)
[11:01:31.553]                             muffled <- TRUE
[11:01:31.553]                             break
[11:01:31.553]                           }
[11:01:31.553]                         }
[11:01:31.553]                       }
[11:01:31.553]                       invisible(muffled)
[11:01:31.553]                     }
[11:01:31.553]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.553]                   }
[11:01:31.553]                 }
[11:01:31.553]             }
[11:01:31.553]         }))
[11:01:31.553]     }, error = function(ex) {
[11:01:31.553]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.553]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.553]                 ...future.rng), started = ...future.startTime, 
[11:01:31.553]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.553]             version = "1.8"), class = "FutureResult")
[11:01:31.553]     }, finally = {
[11:01:31.553]         if (!identical(...future.workdir, getwd())) 
[11:01:31.553]             setwd(...future.workdir)
[11:01:31.553]         {
[11:01:31.553]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.553]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.553]             }
[11:01:31.553]             base::options(...future.oldOptions)
[11:01:31.553]             if (.Platform$OS.type == "windows") {
[11:01:31.553]                 old_names <- names(...future.oldEnvVars)
[11:01:31.553]                 envs <- base::Sys.getenv()
[11:01:31.553]                 names <- names(envs)
[11:01:31.553]                 common <- intersect(names, old_names)
[11:01:31.553]                 added <- setdiff(names, old_names)
[11:01:31.553]                 removed <- setdiff(old_names, names)
[11:01:31.553]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.553]                   envs[common]]
[11:01:31.553]                 NAMES <- toupper(changed)
[11:01:31.553]                 args <- list()
[11:01:31.553]                 for (kk in seq_along(NAMES)) {
[11:01:31.553]                   name <- changed[[kk]]
[11:01:31.553]                   NAME <- NAMES[[kk]]
[11:01:31.553]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.553]                     next
[11:01:31.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.553]                 }
[11:01:31.553]                 NAMES <- toupper(added)
[11:01:31.553]                 for (kk in seq_along(NAMES)) {
[11:01:31.553]                   name <- added[[kk]]
[11:01:31.553]                   NAME <- NAMES[[kk]]
[11:01:31.553]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.553]                     next
[11:01:31.553]                   args[[name]] <- ""
[11:01:31.553]                 }
[11:01:31.553]                 NAMES <- toupper(removed)
[11:01:31.553]                 for (kk in seq_along(NAMES)) {
[11:01:31.553]                   name <- removed[[kk]]
[11:01:31.553]                   NAME <- NAMES[[kk]]
[11:01:31.553]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.553]                     next
[11:01:31.553]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.553]                 }
[11:01:31.553]                 if (length(args) > 0) 
[11:01:31.553]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.553]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.553]             }
[11:01:31.553]             else {
[11:01:31.553]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.553]             }
[11:01:31.553]             {
[11:01:31.553]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.553]                   0L) {
[11:01:31.553]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.553]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.553]                   base::options(opts)
[11:01:31.553]                 }
[11:01:31.553]                 {
[11:01:31.553]                   {
[11:01:31.553]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.553]                     NULL
[11:01:31.553]                   }
[11:01:31.553]                   options(future.plan = NULL)
[11:01:31.553]                   if (is.na(NA_character_)) 
[11:01:31.553]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.553]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.553]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.553]                     .init = FALSE)
[11:01:31.553]                 }
[11:01:31.553]             }
[11:01:31.553]         }
[11:01:31.553]     })
[11:01:31.553]     if (TRUE) {
[11:01:31.553]         base::sink(type = "output", split = FALSE)
[11:01:31.553]         if (TRUE) {
[11:01:31.553]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.553]         }
[11:01:31.553]         else {
[11:01:31.553]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.553]         }
[11:01:31.553]         base::close(...future.stdout)
[11:01:31.553]         ...future.stdout <- NULL
[11:01:31.553]     }
[11:01:31.553]     ...future.result$conditions <- ...future.conditions
[11:01:31.553]     ...future.result$finished <- base::Sys.time()
[11:01:31.553]     ...future.result
[11:01:31.553] }
[11:01:31.555] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:31.566] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.566] - Validating connection of MultisessionFuture
[11:01:31.566] - received message: FutureResult
[11:01:31.567] - Received FutureResult
[11:01:31.567] - Erased future from FutureRegistry
[11:01:31.567] result() for ClusterFuture ...
[11:01:31.567] - result already collected: FutureResult
[11:01:31.567] result() for ClusterFuture ... done
[11:01:31.567] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:31.567] result() for ClusterFuture ...
[11:01:31.567] - result already collected: FutureResult
[11:01:31.567] result() for ClusterFuture ... done
[11:01:31.568] result() for ClusterFuture ...
[11:01:31.568] - result already collected: FutureResult
[11:01:31.568] result() for ClusterFuture ... done
[11:01:31.569] MultisessionFuture started
[11:01:31.569] - Launch lazy future ... done
[11:01:31.569] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a9c64883c0> 
<environment: 0x55a9c8004258> 
[11:01:31.572] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.572] - Validating connection of MultisessionFuture
[11:01:31.572] - received message: FutureResult
[11:01:31.573] - Received FutureResult
[11:01:31.573] - Erased future from FutureRegistry
[11:01:31.573] result() for ClusterFuture ...
[11:01:31.573] - result already collected: FutureResult
[11:01:31.573] result() for ClusterFuture ... done
[11:01:31.573] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:31.585] resolve() on environment ...
[11:01:31.585]  recursive: 0
[11:01:31.586]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:31.586] signalConditionsASAP(numeric, pos=1) ...
[11:01:31.586] - nx: 4
[11:01:31.586] - relay: TRUE
[11:01:31.586] - stdout: TRUE
[11:01:31.586] - signal: TRUE
[11:01:31.586] - resignal: FALSE
[11:01:31.586] - force: TRUE
[11:01:31.587] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.587] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.587]  - until=2
[11:01:31.587]  - relaying element #2
[11:01:31.587] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.587] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.587] signalConditionsASAP(NULL, pos=1) ... done
[11:01:31.587]  length: 3 (resolved future 1)
[11:01:31.587] Future #2
[11:01:31.587] result() for ClusterFuture ...
[11:01:31.588] - result already collected: FutureResult
[11:01:31.588] result() for ClusterFuture ... done
[11:01:31.588] result() for ClusterFuture ...
[11:01:31.588] - result already collected: FutureResult
[11:01:31.588] result() for ClusterFuture ... done
[11:01:31.588] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:31.588] - nx: 4
[11:01:31.588] - relay: TRUE
[11:01:31.588] - stdout: TRUE
[11:01:31.588] - signal: TRUE
[11:01:31.589] - resignal: FALSE
[11:01:31.589] - force: TRUE
[11:01:31.589] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.589] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.589]  - until=2
[11:01:31.589]  - relaying element #2
[11:01:31.589] result() for ClusterFuture ...
[11:01:31.589] - result already collected: FutureResult
[11:01:31.589] result() for ClusterFuture ... done
[11:01:31.589] result() for ClusterFuture ...
[11:01:31.589] - result already collected: FutureResult
[11:01:31.590] result() for ClusterFuture ... done
[11:01:31.590] result() for ClusterFuture ...
[11:01:31.590] - result already collected: FutureResult
[11:01:31.590] result() for ClusterFuture ... done
[11:01:31.590] result() for ClusterFuture ...
[11:01:31.590] - result already collected: FutureResult
[11:01:31.590] result() for ClusterFuture ... done
[11:01:31.590] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.590] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.590] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:31.591]  length: 2 (resolved future 2)
[11:01:31.591] Future #3
[11:01:31.591] result() for ClusterFuture ...
[11:01:31.591] - result already collected: FutureResult
[11:01:31.591] result() for ClusterFuture ... done
[11:01:31.591] result() for ClusterFuture ...
[11:01:31.591] - result already collected: FutureResult
[11:01:31.591] result() for ClusterFuture ... done
[11:01:31.591] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:31.591] - nx: 4
[11:01:31.591] - relay: TRUE
[11:01:31.592] - stdout: TRUE
[11:01:31.592] - signal: TRUE
[11:01:31.592] - resignal: FALSE
[11:01:31.592] - force: TRUE
[11:01:31.592] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.592] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.592]  - until=3
[11:01:31.592]  - relaying element #3
[11:01:31.592] result() for ClusterFuture ...
[11:01:31.592] - result already collected: FutureResult
[11:01:31.592] result() for ClusterFuture ... done
[11:01:31.593] result() for ClusterFuture ...
[11:01:31.593] - result already collected: FutureResult
[11:01:31.593] result() for ClusterFuture ... done
[11:01:31.593] result() for ClusterFuture ...
[11:01:31.593] - result already collected: FutureResult
[11:01:31.593] result() for ClusterFuture ... done
[11:01:31.593] result() for ClusterFuture ...
[11:01:31.593] - result already collected: FutureResult
[11:01:31.593] result() for ClusterFuture ... done
[11:01:31.593] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:31.594] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:31.594] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:31.594]  length: 1 (resolved future 3)
[11:01:31.615] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.615] - Validating connection of MultisessionFuture
[11:01:31.615] - received message: FutureResult
[11:01:31.616] - Received FutureResult
[11:01:31.616] - Erased future from FutureRegistry
[11:01:31.616] result() for ClusterFuture ...
[11:01:31.616] - result already collected: FutureResult
[11:01:31.616] result() for ClusterFuture ... done
[11:01:31.616] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:31.616] Future #4
[11:01:31.616] result() for ClusterFuture ...
[11:01:31.616] - result already collected: FutureResult
[11:01:31.616] result() for ClusterFuture ... done
[11:01:31.617] result() for ClusterFuture ...
[11:01:31.617] - result already collected: FutureResult
[11:01:31.617] result() for ClusterFuture ... done
[11:01:31.617] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:31.617] - nx: 4
[11:01:31.617] - relay: TRUE
[11:01:31.617] - stdout: TRUE
[11:01:31.617] - signal: TRUE
[11:01:31.617] - resignal: FALSE
[11:01:31.617] - force: TRUE
[11:01:31.617] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:31.618] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:31.618]  - until=4
[11:01:31.618]  - relaying element #4
[11:01:31.618] result() for ClusterFuture ...
[11:01:31.618] - result already collected: FutureResult
[11:01:31.618] result() for ClusterFuture ... done
[11:01:31.618] result() for ClusterFuture ...
[11:01:31.618] - result already collected: FutureResult
[11:01:31.618] result() for ClusterFuture ... done
[11:01:31.618] result() for ClusterFuture ...
[11:01:31.618] - result already collected: FutureResult
[11:01:31.618] result() for ClusterFuture ... done
[11:01:31.619] result() for ClusterFuture ...
[11:01:31.619] - result already collected: FutureResult
[11:01:31.619] result() for ClusterFuture ... done
[11:01:31.619] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.619] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:31.619] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:31.619]  length: 0 (resolved future 4)
[11:01:31.619] Relaying remaining futures
[11:01:31.619] signalConditionsASAP(NULL, pos=0) ...
[11:01:31.619] - nx: 4
[11:01:31.619] - relay: TRUE
[11:01:31.619] - stdout: TRUE
[11:01:31.620] - signal: TRUE
[11:01:31.620] - resignal: FALSE
[11:01:31.620] - force: TRUE
[11:01:31.620] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.620] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:31.620] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.620] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:31.620] signalConditionsASAP(NULL, pos=0) ... done
[11:01:31.620] resolve() on environment ... DONE
[11:01:31.620] result() for ClusterFuture ...
[11:01:31.620] - result already collected: FutureResult
[11:01:31.620] result() for ClusterFuture ... done
[11:01:31.621] result() for ClusterFuture ...
[11:01:31.621] - result already collected: FutureResult
[11:01:31.621] result() for ClusterFuture ... done
[11:01:31.621] result() for ClusterFuture ...
[11:01:31.621] - result already collected: FutureResult
[11:01:31.621] result() for ClusterFuture ... done
[11:01:31.621] result() for ClusterFuture ...
[11:01:31.621] - result already collected: FutureResult
[11:01:31.621] result() for ClusterFuture ... done
[11:01:31.621] result() for ClusterFuture ...
[11:01:31.621] - result already collected: FutureResult
[11:01:31.621] result() for ClusterFuture ... done
[11:01:31.622] result() for ClusterFuture ...
[11:01:31.622] - result already collected: FutureResult
[11:01:31.622] result() for ClusterFuture ... done
<environment: 0x55a9c814d1c0> 
Dimensions: c(1, 6)
[11:01:31.622] getGlobalsAndPackages() ...
[11:01:31.622] Searching for globals...
[11:01:31.623] 
[11:01:31.623] Searching for globals ... DONE
[11:01:31.623] - globals: [0] <none>
[11:01:31.623] getGlobalsAndPackages() ... DONE
[11:01:31.623] run() for ‘Future’ ...
[11:01:31.623] - state: ‘created’
[11:01:31.623] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.637] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.637] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.638]   - Field: ‘node’
[11:01:31.638]   - Field: ‘label’
[11:01:31.638]   - Field: ‘local’
[11:01:31.638]   - Field: ‘owner’
[11:01:31.638]   - Field: ‘envir’
[11:01:31.638]   - Field: ‘workers’
[11:01:31.638]   - Field: ‘packages’
[11:01:31.638]   - Field: ‘gc’
[11:01:31.638]   - Field: ‘conditions’
[11:01:31.638]   - Field: ‘persistent’
[11:01:31.638]   - Field: ‘expr’
[11:01:31.639]   - Field: ‘uuid’
[11:01:31.639]   - Field: ‘seed’
[11:01:31.639]   - Field: ‘version’
[11:01:31.639]   - Field: ‘result’
[11:01:31.639]   - Field: ‘asynchronous’
[11:01:31.639]   - Field: ‘calls’
[11:01:31.639]   - Field: ‘globals’
[11:01:31.639]   - Field: ‘stdout’
[11:01:31.639]   - Field: ‘earlySignal’
[11:01:31.639]   - Field: ‘lazy’
[11:01:31.639]   - Field: ‘state’
[11:01:31.640] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.640] - Launch lazy future ...
[11:01:31.640] Packages needed by the future expression (n = 0): <none>
[11:01:31.640] Packages needed by future strategies (n = 0): <none>
[11:01:31.640] {
[11:01:31.640]     {
[11:01:31.640]         {
[11:01:31.640]             ...future.startTime <- base::Sys.time()
[11:01:31.640]             {
[11:01:31.640]                 {
[11:01:31.640]                   {
[11:01:31.640]                     {
[11:01:31.640]                       base::local({
[11:01:31.640]                         has_future <- base::requireNamespace("future", 
[11:01:31.640]                           quietly = TRUE)
[11:01:31.640]                         if (has_future) {
[11:01:31.640]                           ns <- base::getNamespace("future")
[11:01:31.640]                           version <- ns[[".package"]][["version"]]
[11:01:31.640]                           if (is.null(version)) 
[11:01:31.640]                             version <- utils::packageVersion("future")
[11:01:31.640]                         }
[11:01:31.640]                         else {
[11:01:31.640]                           version <- NULL
[11:01:31.640]                         }
[11:01:31.640]                         if (!has_future || version < "1.8.0") {
[11:01:31.640]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.640]                             "", base::R.version$version.string), 
[11:01:31.640]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.640]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.640]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.640]                               "release", "version")], collapse = " "), 
[11:01:31.640]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.640]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.640]                             info)
[11:01:31.640]                           info <- base::paste(info, collapse = "; ")
[11:01:31.640]                           if (!has_future) {
[11:01:31.640]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.640]                               info)
[11:01:31.640]                           }
[11:01:31.640]                           else {
[11:01:31.640]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.640]                               info, version)
[11:01:31.640]                           }
[11:01:31.640]                           base::stop(msg)
[11:01:31.640]                         }
[11:01:31.640]                       })
[11:01:31.640]                     }
[11:01:31.640]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.640]                     base::options(mc.cores = 1L)
[11:01:31.640]                   }
[11:01:31.640]                   ...future.strategy.old <- future::plan("list")
[11:01:31.640]                   options(future.plan = NULL)
[11:01:31.640]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.640]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.640]                 }
[11:01:31.640]                 ...future.workdir <- getwd()
[11:01:31.640]             }
[11:01:31.640]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.640]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.640]         }
[11:01:31.640]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.640]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.640]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.640]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.640]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.640]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.640]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.640]             base::names(...future.oldOptions))
[11:01:31.640]     }
[11:01:31.640]     if (FALSE) {
[11:01:31.640]     }
[11:01:31.640]     else {
[11:01:31.640]         if (TRUE) {
[11:01:31.640]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.640]                 open = "w")
[11:01:31.640]         }
[11:01:31.640]         else {
[11:01:31.640]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.640]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.640]         }
[11:01:31.640]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.640]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.640]             base::sink(type = "output", split = FALSE)
[11:01:31.640]             base::close(...future.stdout)
[11:01:31.640]         }, add = TRUE)
[11:01:31.640]     }
[11:01:31.640]     ...future.frame <- base::sys.nframe()
[11:01:31.640]     ...future.conditions <- base::list()
[11:01:31.640]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.640]     if (FALSE) {
[11:01:31.640]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.640]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.640]     }
[11:01:31.640]     ...future.result <- base::tryCatch({
[11:01:31.640]         base::withCallingHandlers({
[11:01:31.640]             ...future.value <- base::withVisible(base::local({
[11:01:31.640]                 ...future.makeSendCondition <- base::local({
[11:01:31.640]                   sendCondition <- NULL
[11:01:31.640]                   function(frame = 1L) {
[11:01:31.640]                     if (is.function(sendCondition)) 
[11:01:31.640]                       return(sendCondition)
[11:01:31.640]                     ns <- getNamespace("parallel")
[11:01:31.640]                     if (exists("sendData", mode = "function", 
[11:01:31.640]                       envir = ns)) {
[11:01:31.640]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.640]                         envir = ns)
[11:01:31.640]                       envir <- sys.frame(frame)
[11:01:31.640]                       master <- NULL
[11:01:31.640]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.640]                         !identical(envir, emptyenv())) {
[11:01:31.640]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.640]                           inherits = FALSE)) {
[11:01:31.640]                           master <- get("master", mode = "list", 
[11:01:31.640]                             envir = envir, inherits = FALSE)
[11:01:31.640]                           if (inherits(master, c("SOCKnode", 
[11:01:31.640]                             "SOCK0node"))) {
[11:01:31.640]                             sendCondition <<- function(cond) {
[11:01:31.640]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.640]                                 success = TRUE)
[11:01:31.640]                               parallel_sendData(master, data)
[11:01:31.640]                             }
[11:01:31.640]                             return(sendCondition)
[11:01:31.640]                           }
[11:01:31.640]                         }
[11:01:31.640]                         frame <- frame + 1L
[11:01:31.640]                         envir <- sys.frame(frame)
[11:01:31.640]                       }
[11:01:31.640]                     }
[11:01:31.640]                     sendCondition <<- function(cond) NULL
[11:01:31.640]                   }
[11:01:31.640]                 })
[11:01:31.640]                 withCallingHandlers({
[11:01:31.640]                   2
[11:01:31.640]                 }, immediateCondition = function(cond) {
[11:01:31.640]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.640]                   sendCondition(cond)
[11:01:31.640]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.640]                   {
[11:01:31.640]                     inherits <- base::inherits
[11:01:31.640]                     invokeRestart <- base::invokeRestart
[11:01:31.640]                     is.null <- base::is.null
[11:01:31.640]                     muffled <- FALSE
[11:01:31.640]                     if (inherits(cond, "message")) {
[11:01:31.640]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.640]                       if (muffled) 
[11:01:31.640]                         invokeRestart("muffleMessage")
[11:01:31.640]                     }
[11:01:31.640]                     else if (inherits(cond, "warning")) {
[11:01:31.640]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.640]                       if (muffled) 
[11:01:31.640]                         invokeRestart("muffleWarning")
[11:01:31.640]                     }
[11:01:31.640]                     else if (inherits(cond, "condition")) {
[11:01:31.640]                       if (!is.null(pattern)) {
[11:01:31.640]                         computeRestarts <- base::computeRestarts
[11:01:31.640]                         grepl <- base::grepl
[11:01:31.640]                         restarts <- computeRestarts(cond)
[11:01:31.640]                         for (restart in restarts) {
[11:01:31.640]                           name <- restart$name
[11:01:31.640]                           if (is.null(name)) 
[11:01:31.640]                             next
[11:01:31.640]                           if (!grepl(pattern, name)) 
[11:01:31.640]                             next
[11:01:31.640]                           invokeRestart(restart)
[11:01:31.640]                           muffled <- TRUE
[11:01:31.640]                           break
[11:01:31.640]                         }
[11:01:31.640]                       }
[11:01:31.640]                     }
[11:01:31.640]                     invisible(muffled)
[11:01:31.640]                   }
[11:01:31.640]                   muffleCondition(cond)
[11:01:31.640]                 })
[11:01:31.640]             }))
[11:01:31.640]             future::FutureResult(value = ...future.value$value, 
[11:01:31.640]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.640]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.640]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.640]                     ...future.globalenv.names))
[11:01:31.640]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.640]         }, condition = base::local({
[11:01:31.640]             c <- base::c
[11:01:31.640]             inherits <- base::inherits
[11:01:31.640]             invokeRestart <- base::invokeRestart
[11:01:31.640]             length <- base::length
[11:01:31.640]             list <- base::list
[11:01:31.640]             seq.int <- base::seq.int
[11:01:31.640]             signalCondition <- base::signalCondition
[11:01:31.640]             sys.calls <- base::sys.calls
[11:01:31.640]             `[[` <- base::`[[`
[11:01:31.640]             `+` <- base::`+`
[11:01:31.640]             `<<-` <- base::`<<-`
[11:01:31.640]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.640]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.640]                   3L)]
[11:01:31.640]             }
[11:01:31.640]             function(cond) {
[11:01:31.640]                 is_error <- inherits(cond, "error")
[11:01:31.640]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.640]                   NULL)
[11:01:31.640]                 if (is_error) {
[11:01:31.640]                   sessionInformation <- function() {
[11:01:31.640]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.640]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.640]                       search = base::search(), system = base::Sys.info())
[11:01:31.640]                   }
[11:01:31.640]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.640]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.640]                     cond$call), session = sessionInformation(), 
[11:01:31.640]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.640]                   signalCondition(cond)
[11:01:31.640]                 }
[11:01:31.640]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.640]                 "immediateCondition"))) {
[11:01:31.640]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.640]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.640]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.640]                   if (TRUE && !signal) {
[11:01:31.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.640]                     {
[11:01:31.640]                       inherits <- base::inherits
[11:01:31.640]                       invokeRestart <- base::invokeRestart
[11:01:31.640]                       is.null <- base::is.null
[11:01:31.640]                       muffled <- FALSE
[11:01:31.640]                       if (inherits(cond, "message")) {
[11:01:31.640]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.640]                         if (muffled) 
[11:01:31.640]                           invokeRestart("muffleMessage")
[11:01:31.640]                       }
[11:01:31.640]                       else if (inherits(cond, "warning")) {
[11:01:31.640]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.640]                         if (muffled) 
[11:01:31.640]                           invokeRestart("muffleWarning")
[11:01:31.640]                       }
[11:01:31.640]                       else if (inherits(cond, "condition")) {
[11:01:31.640]                         if (!is.null(pattern)) {
[11:01:31.640]                           computeRestarts <- base::computeRestarts
[11:01:31.640]                           grepl <- base::grepl
[11:01:31.640]                           restarts <- computeRestarts(cond)
[11:01:31.640]                           for (restart in restarts) {
[11:01:31.640]                             name <- restart$name
[11:01:31.640]                             if (is.null(name)) 
[11:01:31.640]                               next
[11:01:31.640]                             if (!grepl(pattern, name)) 
[11:01:31.640]                               next
[11:01:31.640]                             invokeRestart(restart)
[11:01:31.640]                             muffled <- TRUE
[11:01:31.640]                             break
[11:01:31.640]                           }
[11:01:31.640]                         }
[11:01:31.640]                       }
[11:01:31.640]                       invisible(muffled)
[11:01:31.640]                     }
[11:01:31.640]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.640]                   }
[11:01:31.640]                 }
[11:01:31.640]                 else {
[11:01:31.640]                   if (TRUE) {
[11:01:31.640]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.640]                     {
[11:01:31.640]                       inherits <- base::inherits
[11:01:31.640]                       invokeRestart <- base::invokeRestart
[11:01:31.640]                       is.null <- base::is.null
[11:01:31.640]                       muffled <- FALSE
[11:01:31.640]                       if (inherits(cond, "message")) {
[11:01:31.640]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.640]                         if (muffled) 
[11:01:31.640]                           invokeRestart("muffleMessage")
[11:01:31.640]                       }
[11:01:31.640]                       else if (inherits(cond, "warning")) {
[11:01:31.640]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.640]                         if (muffled) 
[11:01:31.640]                           invokeRestart("muffleWarning")
[11:01:31.640]                       }
[11:01:31.640]                       else if (inherits(cond, "condition")) {
[11:01:31.640]                         if (!is.null(pattern)) {
[11:01:31.640]                           computeRestarts <- base::computeRestarts
[11:01:31.640]                           grepl <- base::grepl
[11:01:31.640]                           restarts <- computeRestarts(cond)
[11:01:31.640]                           for (restart in restarts) {
[11:01:31.640]                             name <- restart$name
[11:01:31.640]                             if (is.null(name)) 
[11:01:31.640]                               next
[11:01:31.640]                             if (!grepl(pattern, name)) 
[11:01:31.640]                               next
[11:01:31.640]                             invokeRestart(restart)
[11:01:31.640]                             muffled <- TRUE
[11:01:31.640]                             break
[11:01:31.640]                           }
[11:01:31.640]                         }
[11:01:31.640]                       }
[11:01:31.640]                       invisible(muffled)
[11:01:31.640]                     }
[11:01:31.640]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.640]                   }
[11:01:31.640]                 }
[11:01:31.640]             }
[11:01:31.640]         }))
[11:01:31.640]     }, error = function(ex) {
[11:01:31.640]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.640]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.640]                 ...future.rng), started = ...future.startTime, 
[11:01:31.640]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.640]             version = "1.8"), class = "FutureResult")
[11:01:31.640]     }, finally = {
[11:01:31.640]         if (!identical(...future.workdir, getwd())) 
[11:01:31.640]             setwd(...future.workdir)
[11:01:31.640]         {
[11:01:31.640]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.640]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.640]             }
[11:01:31.640]             base::options(...future.oldOptions)
[11:01:31.640]             if (.Platform$OS.type == "windows") {
[11:01:31.640]                 old_names <- names(...future.oldEnvVars)
[11:01:31.640]                 envs <- base::Sys.getenv()
[11:01:31.640]                 names <- names(envs)
[11:01:31.640]                 common <- intersect(names, old_names)
[11:01:31.640]                 added <- setdiff(names, old_names)
[11:01:31.640]                 removed <- setdiff(old_names, names)
[11:01:31.640]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.640]                   envs[common]]
[11:01:31.640]                 NAMES <- toupper(changed)
[11:01:31.640]                 args <- list()
[11:01:31.640]                 for (kk in seq_along(NAMES)) {
[11:01:31.640]                   name <- changed[[kk]]
[11:01:31.640]                   NAME <- NAMES[[kk]]
[11:01:31.640]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.640]                     next
[11:01:31.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.640]                 }
[11:01:31.640]                 NAMES <- toupper(added)
[11:01:31.640]                 for (kk in seq_along(NAMES)) {
[11:01:31.640]                   name <- added[[kk]]
[11:01:31.640]                   NAME <- NAMES[[kk]]
[11:01:31.640]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.640]                     next
[11:01:31.640]                   args[[name]] <- ""
[11:01:31.640]                 }
[11:01:31.640]                 NAMES <- toupper(removed)
[11:01:31.640]                 for (kk in seq_along(NAMES)) {
[11:01:31.640]                   name <- removed[[kk]]
[11:01:31.640]                   NAME <- NAMES[[kk]]
[11:01:31.640]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.640]                     next
[11:01:31.640]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.640]                 }
[11:01:31.640]                 if (length(args) > 0) 
[11:01:31.640]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.640]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.640]             }
[11:01:31.640]             else {
[11:01:31.640]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.640]             }
[11:01:31.640]             {
[11:01:31.640]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.640]                   0L) {
[11:01:31.640]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.640]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.640]                   base::options(opts)
[11:01:31.640]                 }
[11:01:31.640]                 {
[11:01:31.640]                   {
[11:01:31.640]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.640]                     NULL
[11:01:31.640]                   }
[11:01:31.640]                   options(future.plan = NULL)
[11:01:31.640]                   if (is.na(NA_character_)) 
[11:01:31.640]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.640]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.640]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.640]                     .init = FALSE)
[11:01:31.640]                 }
[11:01:31.640]             }
[11:01:31.640]         }
[11:01:31.640]     })
[11:01:31.640]     if (TRUE) {
[11:01:31.640]         base::sink(type = "output", split = FALSE)
[11:01:31.640]         if (TRUE) {
[11:01:31.640]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.640]         }
[11:01:31.640]         else {
[11:01:31.640]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.640]         }
[11:01:31.640]         base::close(...future.stdout)
[11:01:31.640]         ...future.stdout <- NULL
[11:01:31.640]     }
[11:01:31.640]     ...future.result$conditions <- ...future.conditions
[11:01:31.640]     ...future.result$finished <- base::Sys.time()
[11:01:31.640]     ...future.result
[11:01:31.640] }
[11:01:31.643] MultisessionFuture started
[11:01:31.644] - Launch lazy future ... done
[11:01:31.644] run() for ‘MultisessionFuture’ ... done
[11:01:31.644] getGlobalsAndPackages() ...
[11:01:31.644] Searching for globals...
[11:01:31.649] 
[11:01:31.649] Searching for globals ... DONE
[11:01:31.649] - globals: [0] <none>
[11:01:31.649] getGlobalsAndPackages() ... DONE
[11:01:31.649] run() for ‘Future’ ...
[11:01:31.649] - state: ‘created’
[11:01:31.649] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.663] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.663]   - Field: ‘node’
[11:01:31.663]   - Field: ‘label’
[11:01:31.663]   - Field: ‘local’
[11:01:31.663]   - Field: ‘owner’
[11:01:31.664]   - Field: ‘envir’
[11:01:31.664]   - Field: ‘workers’
[11:01:31.664]   - Field: ‘packages’
[11:01:31.664]   - Field: ‘gc’
[11:01:31.664]   - Field: ‘conditions’
[11:01:31.664]   - Field: ‘persistent’
[11:01:31.664]   - Field: ‘expr’
[11:01:31.664]   - Field: ‘uuid’
[11:01:31.664]   - Field: ‘seed’
[11:01:31.664]   - Field: ‘version’
[11:01:31.664]   - Field: ‘result’
[11:01:31.664]   - Field: ‘asynchronous’
[11:01:31.664]   - Field: ‘calls’
[11:01:31.665]   - Field: ‘globals’
[11:01:31.665]   - Field: ‘stdout’
[11:01:31.665]   - Field: ‘earlySignal’
[11:01:31.665]   - Field: ‘lazy’
[11:01:31.665]   - Field: ‘state’
[11:01:31.665] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.665] - Launch lazy future ...
[11:01:31.665] Packages needed by the future expression (n = 0): <none>
[11:01:31.665] Packages needed by future strategies (n = 0): <none>
[11:01:31.666] {
[11:01:31.666]     {
[11:01:31.666]         {
[11:01:31.666]             ...future.startTime <- base::Sys.time()
[11:01:31.666]             {
[11:01:31.666]                 {
[11:01:31.666]                   {
[11:01:31.666]                     {
[11:01:31.666]                       base::local({
[11:01:31.666]                         has_future <- base::requireNamespace("future", 
[11:01:31.666]                           quietly = TRUE)
[11:01:31.666]                         if (has_future) {
[11:01:31.666]                           ns <- base::getNamespace("future")
[11:01:31.666]                           version <- ns[[".package"]][["version"]]
[11:01:31.666]                           if (is.null(version)) 
[11:01:31.666]                             version <- utils::packageVersion("future")
[11:01:31.666]                         }
[11:01:31.666]                         else {
[11:01:31.666]                           version <- NULL
[11:01:31.666]                         }
[11:01:31.666]                         if (!has_future || version < "1.8.0") {
[11:01:31.666]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.666]                             "", base::R.version$version.string), 
[11:01:31.666]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.666]                               "release", "version")], collapse = " "), 
[11:01:31.666]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.666]                             info)
[11:01:31.666]                           info <- base::paste(info, collapse = "; ")
[11:01:31.666]                           if (!has_future) {
[11:01:31.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.666]                               info)
[11:01:31.666]                           }
[11:01:31.666]                           else {
[11:01:31.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.666]                               info, version)
[11:01:31.666]                           }
[11:01:31.666]                           base::stop(msg)
[11:01:31.666]                         }
[11:01:31.666]                       })
[11:01:31.666]                     }
[11:01:31.666]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.666]                     base::options(mc.cores = 1L)
[11:01:31.666]                   }
[11:01:31.666]                   ...future.strategy.old <- future::plan("list")
[11:01:31.666]                   options(future.plan = NULL)
[11:01:31.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.666]                 }
[11:01:31.666]                 ...future.workdir <- getwd()
[11:01:31.666]             }
[11:01:31.666]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.666]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.666]         }
[11:01:31.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.666]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.666]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.666]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.666]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.666]             base::names(...future.oldOptions))
[11:01:31.666]     }
[11:01:31.666]     if (FALSE) {
[11:01:31.666]     }
[11:01:31.666]     else {
[11:01:31.666]         if (TRUE) {
[11:01:31.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.666]                 open = "w")
[11:01:31.666]         }
[11:01:31.666]         else {
[11:01:31.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.666]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.666]         }
[11:01:31.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.666]             base::sink(type = "output", split = FALSE)
[11:01:31.666]             base::close(...future.stdout)
[11:01:31.666]         }, add = TRUE)
[11:01:31.666]     }
[11:01:31.666]     ...future.frame <- base::sys.nframe()
[11:01:31.666]     ...future.conditions <- base::list()
[11:01:31.666]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.666]     if (FALSE) {
[11:01:31.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.666]     }
[11:01:31.666]     ...future.result <- base::tryCatch({
[11:01:31.666]         base::withCallingHandlers({
[11:01:31.666]             ...future.value <- base::withVisible(base::local({
[11:01:31.666]                 ...future.makeSendCondition <- base::local({
[11:01:31.666]                   sendCondition <- NULL
[11:01:31.666]                   function(frame = 1L) {
[11:01:31.666]                     if (is.function(sendCondition)) 
[11:01:31.666]                       return(sendCondition)
[11:01:31.666]                     ns <- getNamespace("parallel")
[11:01:31.666]                     if (exists("sendData", mode = "function", 
[11:01:31.666]                       envir = ns)) {
[11:01:31.666]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.666]                         envir = ns)
[11:01:31.666]                       envir <- sys.frame(frame)
[11:01:31.666]                       master <- NULL
[11:01:31.666]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.666]                         !identical(envir, emptyenv())) {
[11:01:31.666]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.666]                           inherits = FALSE)) {
[11:01:31.666]                           master <- get("master", mode = "list", 
[11:01:31.666]                             envir = envir, inherits = FALSE)
[11:01:31.666]                           if (inherits(master, c("SOCKnode", 
[11:01:31.666]                             "SOCK0node"))) {
[11:01:31.666]                             sendCondition <<- function(cond) {
[11:01:31.666]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.666]                                 success = TRUE)
[11:01:31.666]                               parallel_sendData(master, data)
[11:01:31.666]                             }
[11:01:31.666]                             return(sendCondition)
[11:01:31.666]                           }
[11:01:31.666]                         }
[11:01:31.666]                         frame <- frame + 1L
[11:01:31.666]                         envir <- sys.frame(frame)
[11:01:31.666]                       }
[11:01:31.666]                     }
[11:01:31.666]                     sendCondition <<- function(cond) NULL
[11:01:31.666]                   }
[11:01:31.666]                 })
[11:01:31.666]                 withCallingHandlers({
[11:01:31.666]                   NULL
[11:01:31.666]                 }, immediateCondition = function(cond) {
[11:01:31.666]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.666]                   sendCondition(cond)
[11:01:31.666]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.666]                   {
[11:01:31.666]                     inherits <- base::inherits
[11:01:31.666]                     invokeRestart <- base::invokeRestart
[11:01:31.666]                     is.null <- base::is.null
[11:01:31.666]                     muffled <- FALSE
[11:01:31.666]                     if (inherits(cond, "message")) {
[11:01:31.666]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.666]                       if (muffled) 
[11:01:31.666]                         invokeRestart("muffleMessage")
[11:01:31.666]                     }
[11:01:31.666]                     else if (inherits(cond, "warning")) {
[11:01:31.666]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.666]                       if (muffled) 
[11:01:31.666]                         invokeRestart("muffleWarning")
[11:01:31.666]                     }
[11:01:31.666]                     else if (inherits(cond, "condition")) {
[11:01:31.666]                       if (!is.null(pattern)) {
[11:01:31.666]                         computeRestarts <- base::computeRestarts
[11:01:31.666]                         grepl <- base::grepl
[11:01:31.666]                         restarts <- computeRestarts(cond)
[11:01:31.666]                         for (restart in restarts) {
[11:01:31.666]                           name <- restart$name
[11:01:31.666]                           if (is.null(name)) 
[11:01:31.666]                             next
[11:01:31.666]                           if (!grepl(pattern, name)) 
[11:01:31.666]                             next
[11:01:31.666]                           invokeRestart(restart)
[11:01:31.666]                           muffled <- TRUE
[11:01:31.666]                           break
[11:01:31.666]                         }
[11:01:31.666]                       }
[11:01:31.666]                     }
[11:01:31.666]                     invisible(muffled)
[11:01:31.666]                   }
[11:01:31.666]                   muffleCondition(cond)
[11:01:31.666]                 })
[11:01:31.666]             }))
[11:01:31.666]             future::FutureResult(value = ...future.value$value, 
[11:01:31.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.666]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.666]                     ...future.globalenv.names))
[11:01:31.666]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.666]         }, condition = base::local({
[11:01:31.666]             c <- base::c
[11:01:31.666]             inherits <- base::inherits
[11:01:31.666]             invokeRestart <- base::invokeRestart
[11:01:31.666]             length <- base::length
[11:01:31.666]             list <- base::list
[11:01:31.666]             seq.int <- base::seq.int
[11:01:31.666]             signalCondition <- base::signalCondition
[11:01:31.666]             sys.calls <- base::sys.calls
[11:01:31.666]             `[[` <- base::`[[`
[11:01:31.666]             `+` <- base::`+`
[11:01:31.666]             `<<-` <- base::`<<-`
[11:01:31.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.666]                   3L)]
[11:01:31.666]             }
[11:01:31.666]             function(cond) {
[11:01:31.666]                 is_error <- inherits(cond, "error")
[11:01:31.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.666]                   NULL)
[11:01:31.666]                 if (is_error) {
[11:01:31.666]                   sessionInformation <- function() {
[11:01:31.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.666]                       search = base::search(), system = base::Sys.info())
[11:01:31.666]                   }
[11:01:31.666]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.666]                     cond$call), session = sessionInformation(), 
[11:01:31.666]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.666]                   signalCondition(cond)
[11:01:31.666]                 }
[11:01:31.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.666]                 "immediateCondition"))) {
[11:01:31.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.666]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.666]                   if (TRUE && !signal) {
[11:01:31.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.666]                     {
[11:01:31.666]                       inherits <- base::inherits
[11:01:31.666]                       invokeRestart <- base::invokeRestart
[11:01:31.666]                       is.null <- base::is.null
[11:01:31.666]                       muffled <- FALSE
[11:01:31.666]                       if (inherits(cond, "message")) {
[11:01:31.666]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.666]                         if (muffled) 
[11:01:31.666]                           invokeRestart("muffleMessage")
[11:01:31.666]                       }
[11:01:31.666]                       else if (inherits(cond, "warning")) {
[11:01:31.666]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.666]                         if (muffled) 
[11:01:31.666]                           invokeRestart("muffleWarning")
[11:01:31.666]                       }
[11:01:31.666]                       else if (inherits(cond, "condition")) {
[11:01:31.666]                         if (!is.null(pattern)) {
[11:01:31.666]                           computeRestarts <- base::computeRestarts
[11:01:31.666]                           grepl <- base::grepl
[11:01:31.666]                           restarts <- computeRestarts(cond)
[11:01:31.666]                           for (restart in restarts) {
[11:01:31.666]                             name <- restart$name
[11:01:31.666]                             if (is.null(name)) 
[11:01:31.666]                               next
[11:01:31.666]                             if (!grepl(pattern, name)) 
[11:01:31.666]                               next
[11:01:31.666]                             invokeRestart(restart)
[11:01:31.666]                             muffled <- TRUE
[11:01:31.666]                             break
[11:01:31.666]                           }
[11:01:31.666]                         }
[11:01:31.666]                       }
[11:01:31.666]                       invisible(muffled)
[11:01:31.666]                     }
[11:01:31.666]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.666]                   }
[11:01:31.666]                 }
[11:01:31.666]                 else {
[11:01:31.666]                   if (TRUE) {
[11:01:31.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.666]                     {
[11:01:31.666]                       inherits <- base::inherits
[11:01:31.666]                       invokeRestart <- base::invokeRestart
[11:01:31.666]                       is.null <- base::is.null
[11:01:31.666]                       muffled <- FALSE
[11:01:31.666]                       if (inherits(cond, "message")) {
[11:01:31.666]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.666]                         if (muffled) 
[11:01:31.666]                           invokeRestart("muffleMessage")
[11:01:31.666]                       }
[11:01:31.666]                       else if (inherits(cond, "warning")) {
[11:01:31.666]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.666]                         if (muffled) 
[11:01:31.666]                           invokeRestart("muffleWarning")
[11:01:31.666]                       }
[11:01:31.666]                       else if (inherits(cond, "condition")) {
[11:01:31.666]                         if (!is.null(pattern)) {
[11:01:31.666]                           computeRestarts <- base::computeRestarts
[11:01:31.666]                           grepl <- base::grepl
[11:01:31.666]                           restarts <- computeRestarts(cond)
[11:01:31.666]                           for (restart in restarts) {
[11:01:31.666]                             name <- restart$name
[11:01:31.666]                             if (is.null(name)) 
[11:01:31.666]                               next
[11:01:31.666]                             if (!grepl(pattern, name)) 
[11:01:31.666]                               next
[11:01:31.666]                             invokeRestart(restart)
[11:01:31.666]                             muffled <- TRUE
[11:01:31.666]                             break
[11:01:31.666]                           }
[11:01:31.666]                         }
[11:01:31.666]                       }
[11:01:31.666]                       invisible(muffled)
[11:01:31.666]                     }
[11:01:31.666]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.666]                   }
[11:01:31.666]                 }
[11:01:31.666]             }
[11:01:31.666]         }))
[11:01:31.666]     }, error = function(ex) {
[11:01:31.666]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.666]                 ...future.rng), started = ...future.startTime, 
[11:01:31.666]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.666]             version = "1.8"), class = "FutureResult")
[11:01:31.666]     }, finally = {
[11:01:31.666]         if (!identical(...future.workdir, getwd())) 
[11:01:31.666]             setwd(...future.workdir)
[11:01:31.666]         {
[11:01:31.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.666]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.666]             }
[11:01:31.666]             base::options(...future.oldOptions)
[11:01:31.666]             if (.Platform$OS.type == "windows") {
[11:01:31.666]                 old_names <- names(...future.oldEnvVars)
[11:01:31.666]                 envs <- base::Sys.getenv()
[11:01:31.666]                 names <- names(envs)
[11:01:31.666]                 common <- intersect(names, old_names)
[11:01:31.666]                 added <- setdiff(names, old_names)
[11:01:31.666]                 removed <- setdiff(old_names, names)
[11:01:31.666]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.666]                   envs[common]]
[11:01:31.666]                 NAMES <- toupper(changed)
[11:01:31.666]                 args <- list()
[11:01:31.666]                 for (kk in seq_along(NAMES)) {
[11:01:31.666]                   name <- changed[[kk]]
[11:01:31.666]                   NAME <- NAMES[[kk]]
[11:01:31.666]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.666]                     next
[11:01:31.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.666]                 }
[11:01:31.666]                 NAMES <- toupper(added)
[11:01:31.666]                 for (kk in seq_along(NAMES)) {
[11:01:31.666]                   name <- added[[kk]]
[11:01:31.666]                   NAME <- NAMES[[kk]]
[11:01:31.666]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.666]                     next
[11:01:31.666]                   args[[name]] <- ""
[11:01:31.666]                 }
[11:01:31.666]                 NAMES <- toupper(removed)
[11:01:31.666]                 for (kk in seq_along(NAMES)) {
[11:01:31.666]                   name <- removed[[kk]]
[11:01:31.666]                   NAME <- NAMES[[kk]]
[11:01:31.666]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.666]                     next
[11:01:31.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.666]                 }
[11:01:31.666]                 if (length(args) > 0) 
[11:01:31.666]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.666]             }
[11:01:31.666]             else {
[11:01:31.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.666]             }
[11:01:31.666]             {
[11:01:31.666]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.666]                   0L) {
[11:01:31.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.666]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.666]                   base::options(opts)
[11:01:31.666]                 }
[11:01:31.666]                 {
[11:01:31.666]                   {
[11:01:31.666]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.666]                     NULL
[11:01:31.666]                   }
[11:01:31.666]                   options(future.plan = NULL)
[11:01:31.666]                   if (is.na(NA_character_)) 
[11:01:31.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.666]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.666]                     .init = FALSE)
[11:01:31.666]                 }
[11:01:31.666]             }
[11:01:31.666]         }
[11:01:31.666]     })
[11:01:31.666]     if (TRUE) {
[11:01:31.666]         base::sink(type = "output", split = FALSE)
[11:01:31.666]         if (TRUE) {
[11:01:31.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.666]         }
[11:01:31.666]         else {
[11:01:31.666]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.666]         }
[11:01:31.666]         base::close(...future.stdout)
[11:01:31.666]         ...future.stdout <- NULL
[11:01:31.666]     }
[11:01:31.666]     ...future.result$conditions <- ...future.conditions
[11:01:31.666]     ...future.result$finished <- base::Sys.time()
[11:01:31.666]     ...future.result
[11:01:31.666] }
[11:01:31.669] MultisessionFuture started
[11:01:31.669] - Launch lazy future ... done
[11:01:31.669] run() for ‘MultisessionFuture’ ... done
[11:01:31.669] getGlobalsAndPackages() ...
[11:01:31.669] Searching for globals...
[11:01:31.670] - globals found: [1] ‘{’
[11:01:31.670] Searching for globals ... DONE
[11:01:31.670] Resolving globals: FALSE
[11:01:31.670] 
[11:01:31.670] 
[11:01:31.670] getGlobalsAndPackages() ... DONE
[11:01:31.671] run() for ‘Future’ ...
[11:01:31.671] - state: ‘created’
[11:01:31.671] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.685] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.685] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.685]   - Field: ‘node’
[11:01:31.685]   - Field: ‘label’
[11:01:31.685]   - Field: ‘local’
[11:01:31.686]   - Field: ‘owner’
[11:01:31.686]   - Field: ‘envir’
[11:01:31.686]   - Field: ‘workers’
[11:01:31.686]   - Field: ‘packages’
[11:01:31.686]   - Field: ‘gc’
[11:01:31.686]   - Field: ‘conditions’
[11:01:31.686]   - Field: ‘persistent’
[11:01:31.686]   - Field: ‘expr’
[11:01:31.686]   - Field: ‘uuid’
[11:01:31.686]   - Field: ‘seed’
[11:01:31.686]   - Field: ‘version’
[11:01:31.687]   - Field: ‘result’
[11:01:31.687]   - Field: ‘asynchronous’
[11:01:31.687]   - Field: ‘calls’
[11:01:31.687]   - Field: ‘globals’
[11:01:31.687]   - Field: ‘stdout’
[11:01:31.687]   - Field: ‘earlySignal’
[11:01:31.687]   - Field: ‘lazy’
[11:01:31.687]   - Field: ‘state’
[11:01:31.687] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.687] - Launch lazy future ...
[11:01:31.688] Packages needed by the future expression (n = 0): <none>
[11:01:31.688] Packages needed by future strategies (n = 0): <none>
[11:01:31.688] {
[11:01:31.688]     {
[11:01:31.688]         {
[11:01:31.688]             ...future.startTime <- base::Sys.time()
[11:01:31.688]             {
[11:01:31.688]                 {
[11:01:31.688]                   {
[11:01:31.688]                     {
[11:01:31.688]                       base::local({
[11:01:31.688]                         has_future <- base::requireNamespace("future", 
[11:01:31.688]                           quietly = TRUE)
[11:01:31.688]                         if (has_future) {
[11:01:31.688]                           ns <- base::getNamespace("future")
[11:01:31.688]                           version <- ns[[".package"]][["version"]]
[11:01:31.688]                           if (is.null(version)) 
[11:01:31.688]                             version <- utils::packageVersion("future")
[11:01:31.688]                         }
[11:01:31.688]                         else {
[11:01:31.688]                           version <- NULL
[11:01:31.688]                         }
[11:01:31.688]                         if (!has_future || version < "1.8.0") {
[11:01:31.688]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.688]                             "", base::R.version$version.string), 
[11:01:31.688]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.688]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.688]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.688]                               "release", "version")], collapse = " "), 
[11:01:31.688]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.688]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.688]                             info)
[11:01:31.688]                           info <- base::paste(info, collapse = "; ")
[11:01:31.688]                           if (!has_future) {
[11:01:31.688]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.688]                               info)
[11:01:31.688]                           }
[11:01:31.688]                           else {
[11:01:31.688]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.688]                               info, version)
[11:01:31.688]                           }
[11:01:31.688]                           base::stop(msg)
[11:01:31.688]                         }
[11:01:31.688]                       })
[11:01:31.688]                     }
[11:01:31.688]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.688]                     base::options(mc.cores = 1L)
[11:01:31.688]                   }
[11:01:31.688]                   ...future.strategy.old <- future::plan("list")
[11:01:31.688]                   options(future.plan = NULL)
[11:01:31.688]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.688]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.688]                 }
[11:01:31.688]                 ...future.workdir <- getwd()
[11:01:31.688]             }
[11:01:31.688]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.688]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.688]         }
[11:01:31.688]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.688]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.688]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.688]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.688]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.688]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.688]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.688]             base::names(...future.oldOptions))
[11:01:31.688]     }
[11:01:31.688]     if (FALSE) {
[11:01:31.688]     }
[11:01:31.688]     else {
[11:01:31.688]         if (TRUE) {
[11:01:31.688]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.688]                 open = "w")
[11:01:31.688]         }
[11:01:31.688]         else {
[11:01:31.688]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.688]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.688]         }
[11:01:31.688]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.688]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.688]             base::sink(type = "output", split = FALSE)
[11:01:31.688]             base::close(...future.stdout)
[11:01:31.688]         }, add = TRUE)
[11:01:31.688]     }
[11:01:31.688]     ...future.frame <- base::sys.nframe()
[11:01:31.688]     ...future.conditions <- base::list()
[11:01:31.688]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.688]     if (FALSE) {
[11:01:31.688]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.688]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.688]     }
[11:01:31.688]     ...future.result <- base::tryCatch({
[11:01:31.688]         base::withCallingHandlers({
[11:01:31.688]             ...future.value <- base::withVisible(base::local({
[11:01:31.688]                 ...future.makeSendCondition <- base::local({
[11:01:31.688]                   sendCondition <- NULL
[11:01:31.688]                   function(frame = 1L) {
[11:01:31.688]                     if (is.function(sendCondition)) 
[11:01:31.688]                       return(sendCondition)
[11:01:31.688]                     ns <- getNamespace("parallel")
[11:01:31.688]                     if (exists("sendData", mode = "function", 
[11:01:31.688]                       envir = ns)) {
[11:01:31.688]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.688]                         envir = ns)
[11:01:31.688]                       envir <- sys.frame(frame)
[11:01:31.688]                       master <- NULL
[11:01:31.688]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.688]                         !identical(envir, emptyenv())) {
[11:01:31.688]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.688]                           inherits = FALSE)) {
[11:01:31.688]                           master <- get("master", mode = "list", 
[11:01:31.688]                             envir = envir, inherits = FALSE)
[11:01:31.688]                           if (inherits(master, c("SOCKnode", 
[11:01:31.688]                             "SOCK0node"))) {
[11:01:31.688]                             sendCondition <<- function(cond) {
[11:01:31.688]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.688]                                 success = TRUE)
[11:01:31.688]                               parallel_sendData(master, data)
[11:01:31.688]                             }
[11:01:31.688]                             return(sendCondition)
[11:01:31.688]                           }
[11:01:31.688]                         }
[11:01:31.688]                         frame <- frame + 1L
[11:01:31.688]                         envir <- sys.frame(frame)
[11:01:31.688]                       }
[11:01:31.688]                     }
[11:01:31.688]                     sendCondition <<- function(cond) NULL
[11:01:31.688]                   }
[11:01:31.688]                 })
[11:01:31.688]                 withCallingHandlers({
[11:01:31.688]                   {
[11:01:31.688]                     4
[11:01:31.688]                   }
[11:01:31.688]                 }, immediateCondition = function(cond) {
[11:01:31.688]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.688]                   sendCondition(cond)
[11:01:31.688]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.688]                   {
[11:01:31.688]                     inherits <- base::inherits
[11:01:31.688]                     invokeRestart <- base::invokeRestart
[11:01:31.688]                     is.null <- base::is.null
[11:01:31.688]                     muffled <- FALSE
[11:01:31.688]                     if (inherits(cond, "message")) {
[11:01:31.688]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.688]                       if (muffled) 
[11:01:31.688]                         invokeRestart("muffleMessage")
[11:01:31.688]                     }
[11:01:31.688]                     else if (inherits(cond, "warning")) {
[11:01:31.688]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.688]                       if (muffled) 
[11:01:31.688]                         invokeRestart("muffleWarning")
[11:01:31.688]                     }
[11:01:31.688]                     else if (inherits(cond, "condition")) {
[11:01:31.688]                       if (!is.null(pattern)) {
[11:01:31.688]                         computeRestarts <- base::computeRestarts
[11:01:31.688]                         grepl <- base::grepl
[11:01:31.688]                         restarts <- computeRestarts(cond)
[11:01:31.688]                         for (restart in restarts) {
[11:01:31.688]                           name <- restart$name
[11:01:31.688]                           if (is.null(name)) 
[11:01:31.688]                             next
[11:01:31.688]                           if (!grepl(pattern, name)) 
[11:01:31.688]                             next
[11:01:31.688]                           invokeRestart(restart)
[11:01:31.688]                           muffled <- TRUE
[11:01:31.688]                           break
[11:01:31.688]                         }
[11:01:31.688]                       }
[11:01:31.688]                     }
[11:01:31.688]                     invisible(muffled)
[11:01:31.688]                   }
[11:01:31.688]                   muffleCondition(cond)
[11:01:31.688]                 })
[11:01:31.688]             }))
[11:01:31.688]             future::FutureResult(value = ...future.value$value, 
[11:01:31.688]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.688]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.688]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.688]                     ...future.globalenv.names))
[11:01:31.688]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.688]         }, condition = base::local({
[11:01:31.688]             c <- base::c
[11:01:31.688]             inherits <- base::inherits
[11:01:31.688]             invokeRestart <- base::invokeRestart
[11:01:31.688]             length <- base::length
[11:01:31.688]             list <- base::list
[11:01:31.688]             seq.int <- base::seq.int
[11:01:31.688]             signalCondition <- base::signalCondition
[11:01:31.688]             sys.calls <- base::sys.calls
[11:01:31.688]             `[[` <- base::`[[`
[11:01:31.688]             `+` <- base::`+`
[11:01:31.688]             `<<-` <- base::`<<-`
[11:01:31.688]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.688]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.688]                   3L)]
[11:01:31.688]             }
[11:01:31.688]             function(cond) {
[11:01:31.688]                 is_error <- inherits(cond, "error")
[11:01:31.688]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.688]                   NULL)
[11:01:31.688]                 if (is_error) {
[11:01:31.688]                   sessionInformation <- function() {
[11:01:31.688]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.688]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.688]                       search = base::search(), system = base::Sys.info())
[11:01:31.688]                   }
[11:01:31.688]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.688]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.688]                     cond$call), session = sessionInformation(), 
[11:01:31.688]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.688]                   signalCondition(cond)
[11:01:31.688]                 }
[11:01:31.688]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.688]                 "immediateCondition"))) {
[11:01:31.688]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.688]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.688]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.688]                   if (TRUE && !signal) {
[11:01:31.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.688]                     {
[11:01:31.688]                       inherits <- base::inherits
[11:01:31.688]                       invokeRestart <- base::invokeRestart
[11:01:31.688]                       is.null <- base::is.null
[11:01:31.688]                       muffled <- FALSE
[11:01:31.688]                       if (inherits(cond, "message")) {
[11:01:31.688]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.688]                         if (muffled) 
[11:01:31.688]                           invokeRestart("muffleMessage")
[11:01:31.688]                       }
[11:01:31.688]                       else if (inherits(cond, "warning")) {
[11:01:31.688]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.688]                         if (muffled) 
[11:01:31.688]                           invokeRestart("muffleWarning")
[11:01:31.688]                       }
[11:01:31.688]                       else if (inherits(cond, "condition")) {
[11:01:31.688]                         if (!is.null(pattern)) {
[11:01:31.688]                           computeRestarts <- base::computeRestarts
[11:01:31.688]                           grepl <- base::grepl
[11:01:31.688]                           restarts <- computeRestarts(cond)
[11:01:31.688]                           for (restart in restarts) {
[11:01:31.688]                             name <- restart$name
[11:01:31.688]                             if (is.null(name)) 
[11:01:31.688]                               next
[11:01:31.688]                             if (!grepl(pattern, name)) 
[11:01:31.688]                               next
[11:01:31.688]                             invokeRestart(restart)
[11:01:31.688]                             muffled <- TRUE
[11:01:31.688]                             break
[11:01:31.688]                           }
[11:01:31.688]                         }
[11:01:31.688]                       }
[11:01:31.688]                       invisible(muffled)
[11:01:31.688]                     }
[11:01:31.688]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.688]                   }
[11:01:31.688]                 }
[11:01:31.688]                 else {
[11:01:31.688]                   if (TRUE) {
[11:01:31.688]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.688]                     {
[11:01:31.688]                       inherits <- base::inherits
[11:01:31.688]                       invokeRestart <- base::invokeRestart
[11:01:31.688]                       is.null <- base::is.null
[11:01:31.688]                       muffled <- FALSE
[11:01:31.688]                       if (inherits(cond, "message")) {
[11:01:31.688]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.688]                         if (muffled) 
[11:01:31.688]                           invokeRestart("muffleMessage")
[11:01:31.688]                       }
[11:01:31.688]                       else if (inherits(cond, "warning")) {
[11:01:31.688]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.688]                         if (muffled) 
[11:01:31.688]                           invokeRestart("muffleWarning")
[11:01:31.688]                       }
[11:01:31.688]                       else if (inherits(cond, "condition")) {
[11:01:31.688]                         if (!is.null(pattern)) {
[11:01:31.688]                           computeRestarts <- base::computeRestarts
[11:01:31.688]                           grepl <- base::grepl
[11:01:31.688]                           restarts <- computeRestarts(cond)
[11:01:31.688]                           for (restart in restarts) {
[11:01:31.688]                             name <- restart$name
[11:01:31.688]                             if (is.null(name)) 
[11:01:31.688]                               next
[11:01:31.688]                             if (!grepl(pattern, name)) 
[11:01:31.688]                               next
[11:01:31.688]                             invokeRestart(restart)
[11:01:31.688]                             muffled <- TRUE
[11:01:31.688]                             break
[11:01:31.688]                           }
[11:01:31.688]                         }
[11:01:31.688]                       }
[11:01:31.688]                       invisible(muffled)
[11:01:31.688]                     }
[11:01:31.688]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.688]                   }
[11:01:31.688]                 }
[11:01:31.688]             }
[11:01:31.688]         }))
[11:01:31.688]     }, error = function(ex) {
[11:01:31.688]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.688]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.688]                 ...future.rng), started = ...future.startTime, 
[11:01:31.688]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.688]             version = "1.8"), class = "FutureResult")
[11:01:31.688]     }, finally = {
[11:01:31.688]         if (!identical(...future.workdir, getwd())) 
[11:01:31.688]             setwd(...future.workdir)
[11:01:31.688]         {
[11:01:31.688]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.688]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.688]             }
[11:01:31.688]             base::options(...future.oldOptions)
[11:01:31.688]             if (.Platform$OS.type == "windows") {
[11:01:31.688]                 old_names <- names(...future.oldEnvVars)
[11:01:31.688]                 envs <- base::Sys.getenv()
[11:01:31.688]                 names <- names(envs)
[11:01:31.688]                 common <- intersect(names, old_names)
[11:01:31.688]                 added <- setdiff(names, old_names)
[11:01:31.688]                 removed <- setdiff(old_names, names)
[11:01:31.688]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.688]                   envs[common]]
[11:01:31.688]                 NAMES <- toupper(changed)
[11:01:31.688]                 args <- list()
[11:01:31.688]                 for (kk in seq_along(NAMES)) {
[11:01:31.688]                   name <- changed[[kk]]
[11:01:31.688]                   NAME <- NAMES[[kk]]
[11:01:31.688]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.688]                     next
[11:01:31.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.688]                 }
[11:01:31.688]                 NAMES <- toupper(added)
[11:01:31.688]                 for (kk in seq_along(NAMES)) {
[11:01:31.688]                   name <- added[[kk]]
[11:01:31.688]                   NAME <- NAMES[[kk]]
[11:01:31.688]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.688]                     next
[11:01:31.688]                   args[[name]] <- ""
[11:01:31.688]                 }
[11:01:31.688]                 NAMES <- toupper(removed)
[11:01:31.688]                 for (kk in seq_along(NAMES)) {
[11:01:31.688]                   name <- removed[[kk]]
[11:01:31.688]                   NAME <- NAMES[[kk]]
[11:01:31.688]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.688]                     next
[11:01:31.688]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.688]                 }
[11:01:31.688]                 if (length(args) > 0) 
[11:01:31.688]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.688]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.688]             }
[11:01:31.688]             else {
[11:01:31.688]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.688]             }
[11:01:31.688]             {
[11:01:31.688]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.688]                   0L) {
[11:01:31.688]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.688]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.688]                   base::options(opts)
[11:01:31.688]                 }
[11:01:31.688]                 {
[11:01:31.688]                   {
[11:01:31.688]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.688]                     NULL
[11:01:31.688]                   }
[11:01:31.688]                   options(future.plan = NULL)
[11:01:31.688]                   if (is.na(NA_character_)) 
[11:01:31.688]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.688]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.688]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.688]                     .init = FALSE)
[11:01:31.688]                 }
[11:01:31.688]             }
[11:01:31.688]         }
[11:01:31.688]     })
[11:01:31.688]     if (TRUE) {
[11:01:31.688]         base::sink(type = "output", split = FALSE)
[11:01:31.688]         if (TRUE) {
[11:01:31.688]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.688]         }
[11:01:31.688]         else {
[11:01:31.688]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.688]         }
[11:01:31.688]         base::close(...future.stdout)
[11:01:31.688]         ...future.stdout <- NULL
[11:01:31.688]     }
[11:01:31.688]     ...future.result$conditions <- ...future.conditions
[11:01:31.688]     ...future.result$finished <- base::Sys.time()
[11:01:31.688]     ...future.result
[11:01:31.688] }
[11:01:31.690] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:31.701] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.701] - Validating connection of MultisessionFuture
[11:01:31.701] - received message: FutureResult
[11:01:31.701] - Received FutureResult
[11:01:31.701] - Erased future from FutureRegistry
[11:01:31.701] result() for ClusterFuture ...
[11:01:31.701] - result already collected: FutureResult
[11:01:31.702] result() for ClusterFuture ... done
[11:01:31.702] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:31.702] result() for ClusterFuture ...
[11:01:31.702] - result already collected: FutureResult
[11:01:31.702] result() for ClusterFuture ... done
[11:01:31.702] result() for ClusterFuture ...
[11:01:31.702] - result already collected: FutureResult
[11:01:31.702] result() for ClusterFuture ... done
[11:01:31.703] MultisessionFuture started
[11:01:31.703] - Launch lazy future ... done
[11:01:31.703] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a9c89d0178> 
<environment: 0x55a9c501a090> 
[11:01:31.711] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.711] - Validating connection of MultisessionFuture
[11:01:31.711] - received message: FutureResult
[11:01:31.712] - Received FutureResult
[11:01:31.712] - Erased future from FutureRegistry
[11:01:31.712] result() for ClusterFuture ...
[11:01:31.712] - result already collected: FutureResult
[11:01:31.712] result() for ClusterFuture ... done
[11:01:31.712] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:31.724] resolve() on environment ...
[11:01:31.724]  recursive: 0
[11:01:31.724]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:31.724] signalConditionsASAP(numeric, pos=1) ...
[11:01:31.724] - nx: 4
[11:01:31.724] - relay: TRUE
[11:01:31.725] - stdout: TRUE
[11:01:31.725] - signal: TRUE
[11:01:31.725] - resignal: FALSE
[11:01:31.725] - force: TRUE
[11:01:31.725] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.725] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.725]  - until=2
[11:01:31.725]  - relaying element #2
[11:01:31.725] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.725] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.725] signalConditionsASAP(NULL, pos=1) ... done
[11:01:31.725]  length: 3 (resolved future 1)
[11:01:31.726] Future #2
[11:01:31.726] result() for ClusterFuture ...
[11:01:31.726] - result already collected: FutureResult
[11:01:31.726] result() for ClusterFuture ... done
[11:01:31.726] result() for ClusterFuture ...
[11:01:31.726] - result already collected: FutureResult
[11:01:31.726] result() for ClusterFuture ... done
[11:01:31.726] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:31.726] - nx: 4
[11:01:31.726] - relay: TRUE
[11:01:31.726] - stdout: TRUE
[11:01:31.726] - signal: TRUE
[11:01:31.727] - resignal: FALSE
[11:01:31.727] - force: TRUE
[11:01:31.727] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.727] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.727]  - until=2
[11:01:31.727]  - relaying element #2
[11:01:31.727] result() for ClusterFuture ...
[11:01:31.727] - result already collected: FutureResult
[11:01:31.727] result() for ClusterFuture ... done
[11:01:31.727] result() for ClusterFuture ...
[11:01:31.727] - result already collected: FutureResult
[11:01:31.727] result() for ClusterFuture ... done
[11:01:31.728] result() for ClusterFuture ...
[11:01:31.728] - result already collected: FutureResult
[11:01:31.728] result() for ClusterFuture ... done
[11:01:31.728] result() for ClusterFuture ...
[11:01:31.728] - result already collected: FutureResult
[11:01:31.728] result() for ClusterFuture ... done
[11:01:31.728] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.728] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.728] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:31.728]  length: 2 (resolved future 2)
[11:01:31.728] Future #3
[11:01:31.729] result() for ClusterFuture ...
[11:01:31.729] - result already collected: FutureResult
[11:01:31.729] result() for ClusterFuture ... done
[11:01:31.729] result() for ClusterFuture ...
[11:01:31.729] - result already collected: FutureResult
[11:01:31.729] result() for ClusterFuture ... done
[11:01:31.729] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:31.729] - nx: 4
[11:01:31.729] - relay: TRUE
[11:01:31.729] - stdout: TRUE
[11:01:31.729] - signal: TRUE
[11:01:31.729] - resignal: FALSE
[11:01:31.729] - force: TRUE
[11:01:31.730] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.730] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.730]  - until=3
[11:01:31.730]  - relaying element #3
[11:01:31.730] result() for ClusterFuture ...
[11:01:31.730] - result already collected: FutureResult
[11:01:31.730] result() for ClusterFuture ... done
[11:01:31.730] result() for ClusterFuture ...
[11:01:31.730] - result already collected: FutureResult
[11:01:31.730] result() for ClusterFuture ... done
[11:01:31.730] result() for ClusterFuture ...
[11:01:31.730] - result already collected: FutureResult
[11:01:31.731] result() for ClusterFuture ... done
[11:01:31.731] result() for ClusterFuture ...
[11:01:31.731] - result already collected: FutureResult
[11:01:31.731] result() for ClusterFuture ... done
[11:01:31.731] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:31.731] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:31.731] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:31.731]  length: 1 (resolved future 3)
[11:01:31.752] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.752] - Validating connection of MultisessionFuture
[11:01:31.752] - received message: FutureResult
[11:01:31.753] - Received FutureResult
[11:01:31.753] - Erased future from FutureRegistry
[11:01:31.753] result() for ClusterFuture ...
[11:01:31.753] - result already collected: FutureResult
[11:01:31.753] result() for ClusterFuture ... done
[11:01:31.753] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:31.753] Future #4
[11:01:31.753] result() for ClusterFuture ...
[11:01:31.753] - result already collected: FutureResult
[11:01:31.753] result() for ClusterFuture ... done
[11:01:31.753] result() for ClusterFuture ...
[11:01:31.754] - result already collected: FutureResult
[11:01:31.754] result() for ClusterFuture ... done
[11:01:31.754] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:31.754] - nx: 4
[11:01:31.754] - relay: TRUE
[11:01:31.754] - stdout: TRUE
[11:01:31.754] - signal: TRUE
[11:01:31.754] - resignal: FALSE
[11:01:31.754] - force: TRUE
[11:01:31.754] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:31.754] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:31.754]  - until=4
[11:01:31.754]  - relaying element #4
[11:01:31.755] result() for ClusterFuture ...
[11:01:31.755] - result already collected: FutureResult
[11:01:31.755] result() for ClusterFuture ... done
[11:01:31.755] result() for ClusterFuture ...
[11:01:31.755] - result already collected: FutureResult
[11:01:31.755] result() for ClusterFuture ... done
[11:01:31.755] result() for ClusterFuture ...
[11:01:31.755] - result already collected: FutureResult
[11:01:31.755] result() for ClusterFuture ... done
[11:01:31.755] result() for ClusterFuture ...
[11:01:31.755] - result already collected: FutureResult
[11:01:31.755] result() for ClusterFuture ... done
[11:01:31.756] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.756] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:31.756] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:31.756]  length: 0 (resolved future 4)
[11:01:31.756] Relaying remaining futures
[11:01:31.756] signalConditionsASAP(NULL, pos=0) ...
[11:01:31.756] - nx: 4
[11:01:31.756] - relay: TRUE
[11:01:31.756] - stdout: TRUE
[11:01:31.756] - signal: TRUE
[11:01:31.756] - resignal: FALSE
[11:01:31.756] - force: TRUE
[11:01:31.757] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.757] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:31.757] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.757] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:31.757] signalConditionsASAP(NULL, pos=0) ... done
[11:01:31.757] resolve() on environment ... DONE
[11:01:31.757] result() for ClusterFuture ...
[11:01:31.757] - result already collected: FutureResult
[11:01:31.757] result() for ClusterFuture ... done
[11:01:31.757] result() for ClusterFuture ...
[11:01:31.757] - result already collected: FutureResult
[11:01:31.757] result() for ClusterFuture ... done
[11:01:31.758] result() for ClusterFuture ...
[11:01:31.758] - result already collected: FutureResult
[11:01:31.758] result() for ClusterFuture ... done
[11:01:31.758] result() for ClusterFuture ...
[11:01:31.758] - result already collected: FutureResult
[11:01:31.758] result() for ClusterFuture ... done
[11:01:31.758] result() for ClusterFuture ...
[11:01:31.758] - result already collected: FutureResult
[11:01:31.758] result() for ClusterFuture ... done
[11:01:31.758] result() for ClusterFuture ...
[11:01:31.758] - result already collected: FutureResult
[11:01:31.758] result() for ClusterFuture ... done
<environment: 0x55a9c5ba47f8> 
Dimensions: c(2, 3)
[11:01:31.759] getGlobalsAndPackages() ...
[11:01:31.759] Searching for globals...
[11:01:31.759] 
[11:01:31.759] Searching for globals ... DONE
[11:01:31.759] - globals: [0] <none>
[11:01:31.759] getGlobalsAndPackages() ... DONE
[11:01:31.760] run() for ‘Future’ ...
[11:01:31.760] - state: ‘created’
[11:01:31.760] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.773] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.773]   - Field: ‘node’
[11:01:31.774]   - Field: ‘label’
[11:01:31.774]   - Field: ‘local’
[11:01:31.774]   - Field: ‘owner’
[11:01:31.774]   - Field: ‘envir’
[11:01:31.774]   - Field: ‘workers’
[11:01:31.774]   - Field: ‘packages’
[11:01:31.774]   - Field: ‘gc’
[11:01:31.774]   - Field: ‘conditions’
[11:01:31.774]   - Field: ‘persistent’
[11:01:31.774]   - Field: ‘expr’
[11:01:31.774]   - Field: ‘uuid’
[11:01:31.775]   - Field: ‘seed’
[11:01:31.775]   - Field: ‘version’
[11:01:31.775]   - Field: ‘result’
[11:01:31.775]   - Field: ‘asynchronous’
[11:01:31.775]   - Field: ‘calls’
[11:01:31.775]   - Field: ‘globals’
[11:01:31.775]   - Field: ‘stdout’
[11:01:31.775]   - Field: ‘earlySignal’
[11:01:31.775]   - Field: ‘lazy’
[11:01:31.775]   - Field: ‘state’
[11:01:31.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.776] - Launch lazy future ...
[11:01:31.776] Packages needed by the future expression (n = 0): <none>
[11:01:31.776] Packages needed by future strategies (n = 0): <none>
[11:01:31.776] {
[11:01:31.776]     {
[11:01:31.776]         {
[11:01:31.776]             ...future.startTime <- base::Sys.time()
[11:01:31.776]             {
[11:01:31.776]                 {
[11:01:31.776]                   {
[11:01:31.776]                     {
[11:01:31.776]                       base::local({
[11:01:31.776]                         has_future <- base::requireNamespace("future", 
[11:01:31.776]                           quietly = TRUE)
[11:01:31.776]                         if (has_future) {
[11:01:31.776]                           ns <- base::getNamespace("future")
[11:01:31.776]                           version <- ns[[".package"]][["version"]]
[11:01:31.776]                           if (is.null(version)) 
[11:01:31.776]                             version <- utils::packageVersion("future")
[11:01:31.776]                         }
[11:01:31.776]                         else {
[11:01:31.776]                           version <- NULL
[11:01:31.776]                         }
[11:01:31.776]                         if (!has_future || version < "1.8.0") {
[11:01:31.776]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.776]                             "", base::R.version$version.string), 
[11:01:31.776]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.776]                               "release", "version")], collapse = " "), 
[11:01:31.776]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.776]                             info)
[11:01:31.776]                           info <- base::paste(info, collapse = "; ")
[11:01:31.776]                           if (!has_future) {
[11:01:31.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.776]                               info)
[11:01:31.776]                           }
[11:01:31.776]                           else {
[11:01:31.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.776]                               info, version)
[11:01:31.776]                           }
[11:01:31.776]                           base::stop(msg)
[11:01:31.776]                         }
[11:01:31.776]                       })
[11:01:31.776]                     }
[11:01:31.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.776]                     base::options(mc.cores = 1L)
[11:01:31.776]                   }
[11:01:31.776]                   ...future.strategy.old <- future::plan("list")
[11:01:31.776]                   options(future.plan = NULL)
[11:01:31.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.776]                 }
[11:01:31.776]                 ...future.workdir <- getwd()
[11:01:31.776]             }
[11:01:31.776]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.776]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.776]         }
[11:01:31.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.776]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.776]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.776]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.776]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.776]             base::names(...future.oldOptions))
[11:01:31.776]     }
[11:01:31.776]     if (FALSE) {
[11:01:31.776]     }
[11:01:31.776]     else {
[11:01:31.776]         if (TRUE) {
[11:01:31.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.776]                 open = "w")
[11:01:31.776]         }
[11:01:31.776]         else {
[11:01:31.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.776]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.776]         }
[11:01:31.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.776]             base::sink(type = "output", split = FALSE)
[11:01:31.776]             base::close(...future.stdout)
[11:01:31.776]         }, add = TRUE)
[11:01:31.776]     }
[11:01:31.776]     ...future.frame <- base::sys.nframe()
[11:01:31.776]     ...future.conditions <- base::list()
[11:01:31.776]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.776]     if (FALSE) {
[11:01:31.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.776]     }
[11:01:31.776]     ...future.result <- base::tryCatch({
[11:01:31.776]         base::withCallingHandlers({
[11:01:31.776]             ...future.value <- base::withVisible(base::local({
[11:01:31.776]                 ...future.makeSendCondition <- base::local({
[11:01:31.776]                   sendCondition <- NULL
[11:01:31.776]                   function(frame = 1L) {
[11:01:31.776]                     if (is.function(sendCondition)) 
[11:01:31.776]                       return(sendCondition)
[11:01:31.776]                     ns <- getNamespace("parallel")
[11:01:31.776]                     if (exists("sendData", mode = "function", 
[11:01:31.776]                       envir = ns)) {
[11:01:31.776]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.776]                         envir = ns)
[11:01:31.776]                       envir <- sys.frame(frame)
[11:01:31.776]                       master <- NULL
[11:01:31.776]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.776]                         !identical(envir, emptyenv())) {
[11:01:31.776]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.776]                           inherits = FALSE)) {
[11:01:31.776]                           master <- get("master", mode = "list", 
[11:01:31.776]                             envir = envir, inherits = FALSE)
[11:01:31.776]                           if (inherits(master, c("SOCKnode", 
[11:01:31.776]                             "SOCK0node"))) {
[11:01:31.776]                             sendCondition <<- function(cond) {
[11:01:31.776]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.776]                                 success = TRUE)
[11:01:31.776]                               parallel_sendData(master, data)
[11:01:31.776]                             }
[11:01:31.776]                             return(sendCondition)
[11:01:31.776]                           }
[11:01:31.776]                         }
[11:01:31.776]                         frame <- frame + 1L
[11:01:31.776]                         envir <- sys.frame(frame)
[11:01:31.776]                       }
[11:01:31.776]                     }
[11:01:31.776]                     sendCondition <<- function(cond) NULL
[11:01:31.776]                   }
[11:01:31.776]                 })
[11:01:31.776]                 withCallingHandlers({
[11:01:31.776]                   2
[11:01:31.776]                 }, immediateCondition = function(cond) {
[11:01:31.776]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.776]                   sendCondition(cond)
[11:01:31.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.776]                   {
[11:01:31.776]                     inherits <- base::inherits
[11:01:31.776]                     invokeRestart <- base::invokeRestart
[11:01:31.776]                     is.null <- base::is.null
[11:01:31.776]                     muffled <- FALSE
[11:01:31.776]                     if (inherits(cond, "message")) {
[11:01:31.776]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.776]                       if (muffled) 
[11:01:31.776]                         invokeRestart("muffleMessage")
[11:01:31.776]                     }
[11:01:31.776]                     else if (inherits(cond, "warning")) {
[11:01:31.776]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.776]                       if (muffled) 
[11:01:31.776]                         invokeRestart("muffleWarning")
[11:01:31.776]                     }
[11:01:31.776]                     else if (inherits(cond, "condition")) {
[11:01:31.776]                       if (!is.null(pattern)) {
[11:01:31.776]                         computeRestarts <- base::computeRestarts
[11:01:31.776]                         grepl <- base::grepl
[11:01:31.776]                         restarts <- computeRestarts(cond)
[11:01:31.776]                         for (restart in restarts) {
[11:01:31.776]                           name <- restart$name
[11:01:31.776]                           if (is.null(name)) 
[11:01:31.776]                             next
[11:01:31.776]                           if (!grepl(pattern, name)) 
[11:01:31.776]                             next
[11:01:31.776]                           invokeRestart(restart)
[11:01:31.776]                           muffled <- TRUE
[11:01:31.776]                           break
[11:01:31.776]                         }
[11:01:31.776]                       }
[11:01:31.776]                     }
[11:01:31.776]                     invisible(muffled)
[11:01:31.776]                   }
[11:01:31.776]                   muffleCondition(cond)
[11:01:31.776]                 })
[11:01:31.776]             }))
[11:01:31.776]             future::FutureResult(value = ...future.value$value, 
[11:01:31.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.776]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.776]                     ...future.globalenv.names))
[11:01:31.776]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.776]         }, condition = base::local({
[11:01:31.776]             c <- base::c
[11:01:31.776]             inherits <- base::inherits
[11:01:31.776]             invokeRestart <- base::invokeRestart
[11:01:31.776]             length <- base::length
[11:01:31.776]             list <- base::list
[11:01:31.776]             seq.int <- base::seq.int
[11:01:31.776]             signalCondition <- base::signalCondition
[11:01:31.776]             sys.calls <- base::sys.calls
[11:01:31.776]             `[[` <- base::`[[`
[11:01:31.776]             `+` <- base::`+`
[11:01:31.776]             `<<-` <- base::`<<-`
[11:01:31.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.776]                   3L)]
[11:01:31.776]             }
[11:01:31.776]             function(cond) {
[11:01:31.776]                 is_error <- inherits(cond, "error")
[11:01:31.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.776]                   NULL)
[11:01:31.776]                 if (is_error) {
[11:01:31.776]                   sessionInformation <- function() {
[11:01:31.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.776]                       search = base::search(), system = base::Sys.info())
[11:01:31.776]                   }
[11:01:31.776]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.776]                     cond$call), session = sessionInformation(), 
[11:01:31.776]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.776]                   signalCondition(cond)
[11:01:31.776]                 }
[11:01:31.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.776]                 "immediateCondition"))) {
[11:01:31.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.776]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.776]                   if (TRUE && !signal) {
[11:01:31.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.776]                     {
[11:01:31.776]                       inherits <- base::inherits
[11:01:31.776]                       invokeRestart <- base::invokeRestart
[11:01:31.776]                       is.null <- base::is.null
[11:01:31.776]                       muffled <- FALSE
[11:01:31.776]                       if (inherits(cond, "message")) {
[11:01:31.776]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.776]                         if (muffled) 
[11:01:31.776]                           invokeRestart("muffleMessage")
[11:01:31.776]                       }
[11:01:31.776]                       else if (inherits(cond, "warning")) {
[11:01:31.776]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.776]                         if (muffled) 
[11:01:31.776]                           invokeRestart("muffleWarning")
[11:01:31.776]                       }
[11:01:31.776]                       else if (inherits(cond, "condition")) {
[11:01:31.776]                         if (!is.null(pattern)) {
[11:01:31.776]                           computeRestarts <- base::computeRestarts
[11:01:31.776]                           grepl <- base::grepl
[11:01:31.776]                           restarts <- computeRestarts(cond)
[11:01:31.776]                           for (restart in restarts) {
[11:01:31.776]                             name <- restart$name
[11:01:31.776]                             if (is.null(name)) 
[11:01:31.776]                               next
[11:01:31.776]                             if (!grepl(pattern, name)) 
[11:01:31.776]                               next
[11:01:31.776]                             invokeRestart(restart)
[11:01:31.776]                             muffled <- TRUE
[11:01:31.776]                             break
[11:01:31.776]                           }
[11:01:31.776]                         }
[11:01:31.776]                       }
[11:01:31.776]                       invisible(muffled)
[11:01:31.776]                     }
[11:01:31.776]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.776]                   }
[11:01:31.776]                 }
[11:01:31.776]                 else {
[11:01:31.776]                   if (TRUE) {
[11:01:31.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.776]                     {
[11:01:31.776]                       inherits <- base::inherits
[11:01:31.776]                       invokeRestart <- base::invokeRestart
[11:01:31.776]                       is.null <- base::is.null
[11:01:31.776]                       muffled <- FALSE
[11:01:31.776]                       if (inherits(cond, "message")) {
[11:01:31.776]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.776]                         if (muffled) 
[11:01:31.776]                           invokeRestart("muffleMessage")
[11:01:31.776]                       }
[11:01:31.776]                       else if (inherits(cond, "warning")) {
[11:01:31.776]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.776]                         if (muffled) 
[11:01:31.776]                           invokeRestart("muffleWarning")
[11:01:31.776]                       }
[11:01:31.776]                       else if (inherits(cond, "condition")) {
[11:01:31.776]                         if (!is.null(pattern)) {
[11:01:31.776]                           computeRestarts <- base::computeRestarts
[11:01:31.776]                           grepl <- base::grepl
[11:01:31.776]                           restarts <- computeRestarts(cond)
[11:01:31.776]                           for (restart in restarts) {
[11:01:31.776]                             name <- restart$name
[11:01:31.776]                             if (is.null(name)) 
[11:01:31.776]                               next
[11:01:31.776]                             if (!grepl(pattern, name)) 
[11:01:31.776]                               next
[11:01:31.776]                             invokeRestart(restart)
[11:01:31.776]                             muffled <- TRUE
[11:01:31.776]                             break
[11:01:31.776]                           }
[11:01:31.776]                         }
[11:01:31.776]                       }
[11:01:31.776]                       invisible(muffled)
[11:01:31.776]                     }
[11:01:31.776]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.776]                   }
[11:01:31.776]                 }
[11:01:31.776]             }
[11:01:31.776]         }))
[11:01:31.776]     }, error = function(ex) {
[11:01:31.776]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.776]                 ...future.rng), started = ...future.startTime, 
[11:01:31.776]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.776]             version = "1.8"), class = "FutureResult")
[11:01:31.776]     }, finally = {
[11:01:31.776]         if (!identical(...future.workdir, getwd())) 
[11:01:31.776]             setwd(...future.workdir)
[11:01:31.776]         {
[11:01:31.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.776]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.776]             }
[11:01:31.776]             base::options(...future.oldOptions)
[11:01:31.776]             if (.Platform$OS.type == "windows") {
[11:01:31.776]                 old_names <- names(...future.oldEnvVars)
[11:01:31.776]                 envs <- base::Sys.getenv()
[11:01:31.776]                 names <- names(envs)
[11:01:31.776]                 common <- intersect(names, old_names)
[11:01:31.776]                 added <- setdiff(names, old_names)
[11:01:31.776]                 removed <- setdiff(old_names, names)
[11:01:31.776]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.776]                   envs[common]]
[11:01:31.776]                 NAMES <- toupper(changed)
[11:01:31.776]                 args <- list()
[11:01:31.776]                 for (kk in seq_along(NAMES)) {
[11:01:31.776]                   name <- changed[[kk]]
[11:01:31.776]                   NAME <- NAMES[[kk]]
[11:01:31.776]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.776]                     next
[11:01:31.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.776]                 }
[11:01:31.776]                 NAMES <- toupper(added)
[11:01:31.776]                 for (kk in seq_along(NAMES)) {
[11:01:31.776]                   name <- added[[kk]]
[11:01:31.776]                   NAME <- NAMES[[kk]]
[11:01:31.776]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.776]                     next
[11:01:31.776]                   args[[name]] <- ""
[11:01:31.776]                 }
[11:01:31.776]                 NAMES <- toupper(removed)
[11:01:31.776]                 for (kk in seq_along(NAMES)) {
[11:01:31.776]                   name <- removed[[kk]]
[11:01:31.776]                   NAME <- NAMES[[kk]]
[11:01:31.776]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.776]                     next
[11:01:31.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.776]                 }
[11:01:31.776]                 if (length(args) > 0) 
[11:01:31.776]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.776]             }
[11:01:31.776]             else {
[11:01:31.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.776]             }
[11:01:31.776]             {
[11:01:31.776]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.776]                   0L) {
[11:01:31.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.776]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.776]                   base::options(opts)
[11:01:31.776]                 }
[11:01:31.776]                 {
[11:01:31.776]                   {
[11:01:31.776]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.776]                     NULL
[11:01:31.776]                   }
[11:01:31.776]                   options(future.plan = NULL)
[11:01:31.776]                   if (is.na(NA_character_)) 
[11:01:31.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.776]                     .init = FALSE)
[11:01:31.776]                 }
[11:01:31.776]             }
[11:01:31.776]         }
[11:01:31.776]     })
[11:01:31.776]     if (TRUE) {
[11:01:31.776]         base::sink(type = "output", split = FALSE)
[11:01:31.776]         if (TRUE) {
[11:01:31.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.776]         }
[11:01:31.776]         else {
[11:01:31.776]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.776]         }
[11:01:31.776]         base::close(...future.stdout)
[11:01:31.776]         ...future.stdout <- NULL
[11:01:31.776]     }
[11:01:31.776]     ...future.result$conditions <- ...future.conditions
[11:01:31.776]     ...future.result$finished <- base::Sys.time()
[11:01:31.776]     ...future.result
[11:01:31.776] }
[11:01:31.779] MultisessionFuture started
[11:01:31.779] - Launch lazy future ... done
[11:01:31.779] run() for ‘MultisessionFuture’ ... done
[11:01:31.779] getGlobalsAndPackages() ...
[11:01:31.780] Searching for globals...
[11:01:31.780] 
[11:01:31.780] Searching for globals ... DONE
[11:01:31.780] - globals: [0] <none>
[11:01:31.780] getGlobalsAndPackages() ... DONE
[11:01:31.780] run() for ‘Future’ ...
[11:01:31.780] - state: ‘created’
[11:01:31.781] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.794] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.794] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.794]   - Field: ‘node’
[11:01:31.794]   - Field: ‘label’
[11:01:31.795]   - Field: ‘local’
[11:01:31.795]   - Field: ‘owner’
[11:01:31.795]   - Field: ‘envir’
[11:01:31.795]   - Field: ‘workers’
[11:01:31.795]   - Field: ‘packages’
[11:01:31.795]   - Field: ‘gc’
[11:01:31.795]   - Field: ‘conditions’
[11:01:31.795]   - Field: ‘persistent’
[11:01:31.795]   - Field: ‘expr’
[11:01:31.795]   - Field: ‘uuid’
[11:01:31.795]   - Field: ‘seed’
[11:01:31.795]   - Field: ‘version’
[11:01:31.796]   - Field: ‘result’
[11:01:31.796]   - Field: ‘asynchronous’
[11:01:31.796]   - Field: ‘calls’
[11:01:31.796]   - Field: ‘globals’
[11:01:31.796]   - Field: ‘stdout’
[11:01:31.796]   - Field: ‘earlySignal’
[11:01:31.796]   - Field: ‘lazy’
[11:01:31.796]   - Field: ‘state’
[11:01:31.796] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.796] - Launch lazy future ...
[11:01:31.797] Packages needed by the future expression (n = 0): <none>
[11:01:31.797] Packages needed by future strategies (n = 0): <none>
[11:01:31.797] {
[11:01:31.797]     {
[11:01:31.797]         {
[11:01:31.797]             ...future.startTime <- base::Sys.time()
[11:01:31.797]             {
[11:01:31.797]                 {
[11:01:31.797]                   {
[11:01:31.797]                     {
[11:01:31.797]                       base::local({
[11:01:31.797]                         has_future <- base::requireNamespace("future", 
[11:01:31.797]                           quietly = TRUE)
[11:01:31.797]                         if (has_future) {
[11:01:31.797]                           ns <- base::getNamespace("future")
[11:01:31.797]                           version <- ns[[".package"]][["version"]]
[11:01:31.797]                           if (is.null(version)) 
[11:01:31.797]                             version <- utils::packageVersion("future")
[11:01:31.797]                         }
[11:01:31.797]                         else {
[11:01:31.797]                           version <- NULL
[11:01:31.797]                         }
[11:01:31.797]                         if (!has_future || version < "1.8.0") {
[11:01:31.797]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.797]                             "", base::R.version$version.string), 
[11:01:31.797]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.797]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.797]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.797]                               "release", "version")], collapse = " "), 
[11:01:31.797]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.797]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.797]                             info)
[11:01:31.797]                           info <- base::paste(info, collapse = "; ")
[11:01:31.797]                           if (!has_future) {
[11:01:31.797]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.797]                               info)
[11:01:31.797]                           }
[11:01:31.797]                           else {
[11:01:31.797]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.797]                               info, version)
[11:01:31.797]                           }
[11:01:31.797]                           base::stop(msg)
[11:01:31.797]                         }
[11:01:31.797]                       })
[11:01:31.797]                     }
[11:01:31.797]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.797]                     base::options(mc.cores = 1L)
[11:01:31.797]                   }
[11:01:31.797]                   ...future.strategy.old <- future::plan("list")
[11:01:31.797]                   options(future.plan = NULL)
[11:01:31.797]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.797]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.797]                 }
[11:01:31.797]                 ...future.workdir <- getwd()
[11:01:31.797]             }
[11:01:31.797]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.797]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.797]         }
[11:01:31.797]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.797]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.797]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.797]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.797]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.797]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.797]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.797]             base::names(...future.oldOptions))
[11:01:31.797]     }
[11:01:31.797]     if (FALSE) {
[11:01:31.797]     }
[11:01:31.797]     else {
[11:01:31.797]         if (TRUE) {
[11:01:31.797]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.797]                 open = "w")
[11:01:31.797]         }
[11:01:31.797]         else {
[11:01:31.797]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.797]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.797]         }
[11:01:31.797]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.797]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.797]             base::sink(type = "output", split = FALSE)
[11:01:31.797]             base::close(...future.stdout)
[11:01:31.797]         }, add = TRUE)
[11:01:31.797]     }
[11:01:31.797]     ...future.frame <- base::sys.nframe()
[11:01:31.797]     ...future.conditions <- base::list()
[11:01:31.797]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.797]     if (FALSE) {
[11:01:31.797]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.797]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.797]     }
[11:01:31.797]     ...future.result <- base::tryCatch({
[11:01:31.797]         base::withCallingHandlers({
[11:01:31.797]             ...future.value <- base::withVisible(base::local({
[11:01:31.797]                 ...future.makeSendCondition <- base::local({
[11:01:31.797]                   sendCondition <- NULL
[11:01:31.797]                   function(frame = 1L) {
[11:01:31.797]                     if (is.function(sendCondition)) 
[11:01:31.797]                       return(sendCondition)
[11:01:31.797]                     ns <- getNamespace("parallel")
[11:01:31.797]                     if (exists("sendData", mode = "function", 
[11:01:31.797]                       envir = ns)) {
[11:01:31.797]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.797]                         envir = ns)
[11:01:31.797]                       envir <- sys.frame(frame)
[11:01:31.797]                       master <- NULL
[11:01:31.797]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.797]                         !identical(envir, emptyenv())) {
[11:01:31.797]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.797]                           inherits = FALSE)) {
[11:01:31.797]                           master <- get("master", mode = "list", 
[11:01:31.797]                             envir = envir, inherits = FALSE)
[11:01:31.797]                           if (inherits(master, c("SOCKnode", 
[11:01:31.797]                             "SOCK0node"))) {
[11:01:31.797]                             sendCondition <<- function(cond) {
[11:01:31.797]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.797]                                 success = TRUE)
[11:01:31.797]                               parallel_sendData(master, data)
[11:01:31.797]                             }
[11:01:31.797]                             return(sendCondition)
[11:01:31.797]                           }
[11:01:31.797]                         }
[11:01:31.797]                         frame <- frame + 1L
[11:01:31.797]                         envir <- sys.frame(frame)
[11:01:31.797]                       }
[11:01:31.797]                     }
[11:01:31.797]                     sendCondition <<- function(cond) NULL
[11:01:31.797]                   }
[11:01:31.797]                 })
[11:01:31.797]                 withCallingHandlers({
[11:01:31.797]                   NULL
[11:01:31.797]                 }, immediateCondition = function(cond) {
[11:01:31.797]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.797]                   sendCondition(cond)
[11:01:31.797]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.797]                   {
[11:01:31.797]                     inherits <- base::inherits
[11:01:31.797]                     invokeRestart <- base::invokeRestart
[11:01:31.797]                     is.null <- base::is.null
[11:01:31.797]                     muffled <- FALSE
[11:01:31.797]                     if (inherits(cond, "message")) {
[11:01:31.797]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.797]                       if (muffled) 
[11:01:31.797]                         invokeRestart("muffleMessage")
[11:01:31.797]                     }
[11:01:31.797]                     else if (inherits(cond, "warning")) {
[11:01:31.797]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.797]                       if (muffled) 
[11:01:31.797]                         invokeRestart("muffleWarning")
[11:01:31.797]                     }
[11:01:31.797]                     else if (inherits(cond, "condition")) {
[11:01:31.797]                       if (!is.null(pattern)) {
[11:01:31.797]                         computeRestarts <- base::computeRestarts
[11:01:31.797]                         grepl <- base::grepl
[11:01:31.797]                         restarts <- computeRestarts(cond)
[11:01:31.797]                         for (restart in restarts) {
[11:01:31.797]                           name <- restart$name
[11:01:31.797]                           if (is.null(name)) 
[11:01:31.797]                             next
[11:01:31.797]                           if (!grepl(pattern, name)) 
[11:01:31.797]                             next
[11:01:31.797]                           invokeRestart(restart)
[11:01:31.797]                           muffled <- TRUE
[11:01:31.797]                           break
[11:01:31.797]                         }
[11:01:31.797]                       }
[11:01:31.797]                     }
[11:01:31.797]                     invisible(muffled)
[11:01:31.797]                   }
[11:01:31.797]                   muffleCondition(cond)
[11:01:31.797]                 })
[11:01:31.797]             }))
[11:01:31.797]             future::FutureResult(value = ...future.value$value, 
[11:01:31.797]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.797]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.797]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.797]                     ...future.globalenv.names))
[11:01:31.797]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.797]         }, condition = base::local({
[11:01:31.797]             c <- base::c
[11:01:31.797]             inherits <- base::inherits
[11:01:31.797]             invokeRestart <- base::invokeRestart
[11:01:31.797]             length <- base::length
[11:01:31.797]             list <- base::list
[11:01:31.797]             seq.int <- base::seq.int
[11:01:31.797]             signalCondition <- base::signalCondition
[11:01:31.797]             sys.calls <- base::sys.calls
[11:01:31.797]             `[[` <- base::`[[`
[11:01:31.797]             `+` <- base::`+`
[11:01:31.797]             `<<-` <- base::`<<-`
[11:01:31.797]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.797]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.797]                   3L)]
[11:01:31.797]             }
[11:01:31.797]             function(cond) {
[11:01:31.797]                 is_error <- inherits(cond, "error")
[11:01:31.797]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.797]                   NULL)
[11:01:31.797]                 if (is_error) {
[11:01:31.797]                   sessionInformation <- function() {
[11:01:31.797]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.797]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.797]                       search = base::search(), system = base::Sys.info())
[11:01:31.797]                   }
[11:01:31.797]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.797]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.797]                     cond$call), session = sessionInformation(), 
[11:01:31.797]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.797]                   signalCondition(cond)
[11:01:31.797]                 }
[11:01:31.797]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.797]                 "immediateCondition"))) {
[11:01:31.797]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.797]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.797]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.797]                   if (TRUE && !signal) {
[11:01:31.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.797]                     {
[11:01:31.797]                       inherits <- base::inherits
[11:01:31.797]                       invokeRestart <- base::invokeRestart
[11:01:31.797]                       is.null <- base::is.null
[11:01:31.797]                       muffled <- FALSE
[11:01:31.797]                       if (inherits(cond, "message")) {
[11:01:31.797]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.797]                         if (muffled) 
[11:01:31.797]                           invokeRestart("muffleMessage")
[11:01:31.797]                       }
[11:01:31.797]                       else if (inherits(cond, "warning")) {
[11:01:31.797]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.797]                         if (muffled) 
[11:01:31.797]                           invokeRestart("muffleWarning")
[11:01:31.797]                       }
[11:01:31.797]                       else if (inherits(cond, "condition")) {
[11:01:31.797]                         if (!is.null(pattern)) {
[11:01:31.797]                           computeRestarts <- base::computeRestarts
[11:01:31.797]                           grepl <- base::grepl
[11:01:31.797]                           restarts <- computeRestarts(cond)
[11:01:31.797]                           for (restart in restarts) {
[11:01:31.797]                             name <- restart$name
[11:01:31.797]                             if (is.null(name)) 
[11:01:31.797]                               next
[11:01:31.797]                             if (!grepl(pattern, name)) 
[11:01:31.797]                               next
[11:01:31.797]                             invokeRestart(restart)
[11:01:31.797]                             muffled <- TRUE
[11:01:31.797]                             break
[11:01:31.797]                           }
[11:01:31.797]                         }
[11:01:31.797]                       }
[11:01:31.797]                       invisible(muffled)
[11:01:31.797]                     }
[11:01:31.797]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.797]                   }
[11:01:31.797]                 }
[11:01:31.797]                 else {
[11:01:31.797]                   if (TRUE) {
[11:01:31.797]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.797]                     {
[11:01:31.797]                       inherits <- base::inherits
[11:01:31.797]                       invokeRestart <- base::invokeRestart
[11:01:31.797]                       is.null <- base::is.null
[11:01:31.797]                       muffled <- FALSE
[11:01:31.797]                       if (inherits(cond, "message")) {
[11:01:31.797]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.797]                         if (muffled) 
[11:01:31.797]                           invokeRestart("muffleMessage")
[11:01:31.797]                       }
[11:01:31.797]                       else if (inherits(cond, "warning")) {
[11:01:31.797]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.797]                         if (muffled) 
[11:01:31.797]                           invokeRestart("muffleWarning")
[11:01:31.797]                       }
[11:01:31.797]                       else if (inherits(cond, "condition")) {
[11:01:31.797]                         if (!is.null(pattern)) {
[11:01:31.797]                           computeRestarts <- base::computeRestarts
[11:01:31.797]                           grepl <- base::grepl
[11:01:31.797]                           restarts <- computeRestarts(cond)
[11:01:31.797]                           for (restart in restarts) {
[11:01:31.797]                             name <- restart$name
[11:01:31.797]                             if (is.null(name)) 
[11:01:31.797]                               next
[11:01:31.797]                             if (!grepl(pattern, name)) 
[11:01:31.797]                               next
[11:01:31.797]                             invokeRestart(restart)
[11:01:31.797]                             muffled <- TRUE
[11:01:31.797]                             break
[11:01:31.797]                           }
[11:01:31.797]                         }
[11:01:31.797]                       }
[11:01:31.797]                       invisible(muffled)
[11:01:31.797]                     }
[11:01:31.797]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.797]                   }
[11:01:31.797]                 }
[11:01:31.797]             }
[11:01:31.797]         }))
[11:01:31.797]     }, error = function(ex) {
[11:01:31.797]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.797]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.797]                 ...future.rng), started = ...future.startTime, 
[11:01:31.797]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.797]             version = "1.8"), class = "FutureResult")
[11:01:31.797]     }, finally = {
[11:01:31.797]         if (!identical(...future.workdir, getwd())) 
[11:01:31.797]             setwd(...future.workdir)
[11:01:31.797]         {
[11:01:31.797]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.797]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.797]             }
[11:01:31.797]             base::options(...future.oldOptions)
[11:01:31.797]             if (.Platform$OS.type == "windows") {
[11:01:31.797]                 old_names <- names(...future.oldEnvVars)
[11:01:31.797]                 envs <- base::Sys.getenv()
[11:01:31.797]                 names <- names(envs)
[11:01:31.797]                 common <- intersect(names, old_names)
[11:01:31.797]                 added <- setdiff(names, old_names)
[11:01:31.797]                 removed <- setdiff(old_names, names)
[11:01:31.797]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.797]                   envs[common]]
[11:01:31.797]                 NAMES <- toupper(changed)
[11:01:31.797]                 args <- list()
[11:01:31.797]                 for (kk in seq_along(NAMES)) {
[11:01:31.797]                   name <- changed[[kk]]
[11:01:31.797]                   NAME <- NAMES[[kk]]
[11:01:31.797]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.797]                     next
[11:01:31.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.797]                 }
[11:01:31.797]                 NAMES <- toupper(added)
[11:01:31.797]                 for (kk in seq_along(NAMES)) {
[11:01:31.797]                   name <- added[[kk]]
[11:01:31.797]                   NAME <- NAMES[[kk]]
[11:01:31.797]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.797]                     next
[11:01:31.797]                   args[[name]] <- ""
[11:01:31.797]                 }
[11:01:31.797]                 NAMES <- toupper(removed)
[11:01:31.797]                 for (kk in seq_along(NAMES)) {
[11:01:31.797]                   name <- removed[[kk]]
[11:01:31.797]                   NAME <- NAMES[[kk]]
[11:01:31.797]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.797]                     next
[11:01:31.797]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.797]                 }
[11:01:31.797]                 if (length(args) > 0) 
[11:01:31.797]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.797]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.797]             }
[11:01:31.797]             else {
[11:01:31.797]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.797]             }
[11:01:31.797]             {
[11:01:31.797]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.797]                   0L) {
[11:01:31.797]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.797]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.797]                   base::options(opts)
[11:01:31.797]                 }
[11:01:31.797]                 {
[11:01:31.797]                   {
[11:01:31.797]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.797]                     NULL
[11:01:31.797]                   }
[11:01:31.797]                   options(future.plan = NULL)
[11:01:31.797]                   if (is.na(NA_character_)) 
[11:01:31.797]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.797]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.797]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.797]                     .init = FALSE)
[11:01:31.797]                 }
[11:01:31.797]             }
[11:01:31.797]         }
[11:01:31.797]     })
[11:01:31.797]     if (TRUE) {
[11:01:31.797]         base::sink(type = "output", split = FALSE)
[11:01:31.797]         if (TRUE) {
[11:01:31.797]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.797]         }
[11:01:31.797]         else {
[11:01:31.797]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.797]         }
[11:01:31.797]         base::close(...future.stdout)
[11:01:31.797]         ...future.stdout <- NULL
[11:01:31.797]     }
[11:01:31.797]     ...future.result$conditions <- ...future.conditions
[11:01:31.797]     ...future.result$finished <- base::Sys.time()
[11:01:31.797]     ...future.result
[11:01:31.797] }
[11:01:31.800] MultisessionFuture started
[11:01:31.800] - Launch lazy future ... done
[11:01:31.800] run() for ‘MultisessionFuture’ ... done
[11:01:31.800] getGlobalsAndPackages() ...
[11:01:31.800] Searching for globals...
[11:01:31.801] - globals found: [1] ‘{’
[11:01:31.801] Searching for globals ... DONE
[11:01:31.801] Resolving globals: FALSE
[11:01:31.801] 
[11:01:31.802] 
[11:01:31.802] getGlobalsAndPackages() ... DONE
[11:01:31.802] run() for ‘Future’ ...
[11:01:31.802] - state: ‘created’
[11:01:31.802] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.816] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.816] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.816]   - Field: ‘node’
[11:01:31.816]   - Field: ‘label’
[11:01:31.817]   - Field: ‘local’
[11:01:31.817]   - Field: ‘owner’
[11:01:31.817]   - Field: ‘envir’
[11:01:31.817]   - Field: ‘workers’
[11:01:31.817]   - Field: ‘packages’
[11:01:31.817]   - Field: ‘gc’
[11:01:31.817]   - Field: ‘conditions’
[11:01:31.817]   - Field: ‘persistent’
[11:01:31.817]   - Field: ‘expr’
[11:01:31.817]   - Field: ‘uuid’
[11:01:31.817]   - Field: ‘seed’
[11:01:31.817]   - Field: ‘version’
[11:01:31.818]   - Field: ‘result’
[11:01:31.818]   - Field: ‘asynchronous’
[11:01:31.818]   - Field: ‘calls’
[11:01:31.818]   - Field: ‘globals’
[11:01:31.818]   - Field: ‘stdout’
[11:01:31.818]   - Field: ‘earlySignal’
[11:01:31.818]   - Field: ‘lazy’
[11:01:31.818]   - Field: ‘state’
[11:01:31.818] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.818] - Launch lazy future ...
[11:01:31.819] Packages needed by the future expression (n = 0): <none>
[11:01:31.819] Packages needed by future strategies (n = 0): <none>
[11:01:31.819] {
[11:01:31.819]     {
[11:01:31.819]         {
[11:01:31.819]             ...future.startTime <- base::Sys.time()
[11:01:31.819]             {
[11:01:31.819]                 {
[11:01:31.819]                   {
[11:01:31.819]                     {
[11:01:31.819]                       base::local({
[11:01:31.819]                         has_future <- base::requireNamespace("future", 
[11:01:31.819]                           quietly = TRUE)
[11:01:31.819]                         if (has_future) {
[11:01:31.819]                           ns <- base::getNamespace("future")
[11:01:31.819]                           version <- ns[[".package"]][["version"]]
[11:01:31.819]                           if (is.null(version)) 
[11:01:31.819]                             version <- utils::packageVersion("future")
[11:01:31.819]                         }
[11:01:31.819]                         else {
[11:01:31.819]                           version <- NULL
[11:01:31.819]                         }
[11:01:31.819]                         if (!has_future || version < "1.8.0") {
[11:01:31.819]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.819]                             "", base::R.version$version.string), 
[11:01:31.819]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.819]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.819]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.819]                               "release", "version")], collapse = " "), 
[11:01:31.819]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.819]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.819]                             info)
[11:01:31.819]                           info <- base::paste(info, collapse = "; ")
[11:01:31.819]                           if (!has_future) {
[11:01:31.819]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.819]                               info)
[11:01:31.819]                           }
[11:01:31.819]                           else {
[11:01:31.819]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.819]                               info, version)
[11:01:31.819]                           }
[11:01:31.819]                           base::stop(msg)
[11:01:31.819]                         }
[11:01:31.819]                       })
[11:01:31.819]                     }
[11:01:31.819]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.819]                     base::options(mc.cores = 1L)
[11:01:31.819]                   }
[11:01:31.819]                   ...future.strategy.old <- future::plan("list")
[11:01:31.819]                   options(future.plan = NULL)
[11:01:31.819]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.819]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.819]                 }
[11:01:31.819]                 ...future.workdir <- getwd()
[11:01:31.819]             }
[11:01:31.819]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.819]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.819]         }
[11:01:31.819]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.819]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.819]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.819]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.819]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.819]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.819]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.819]             base::names(...future.oldOptions))
[11:01:31.819]     }
[11:01:31.819]     if (FALSE) {
[11:01:31.819]     }
[11:01:31.819]     else {
[11:01:31.819]         if (TRUE) {
[11:01:31.819]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.819]                 open = "w")
[11:01:31.819]         }
[11:01:31.819]         else {
[11:01:31.819]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.819]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.819]         }
[11:01:31.819]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.819]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.819]             base::sink(type = "output", split = FALSE)
[11:01:31.819]             base::close(...future.stdout)
[11:01:31.819]         }, add = TRUE)
[11:01:31.819]     }
[11:01:31.819]     ...future.frame <- base::sys.nframe()
[11:01:31.819]     ...future.conditions <- base::list()
[11:01:31.819]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.819]     if (FALSE) {
[11:01:31.819]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.819]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.819]     }
[11:01:31.819]     ...future.result <- base::tryCatch({
[11:01:31.819]         base::withCallingHandlers({
[11:01:31.819]             ...future.value <- base::withVisible(base::local({
[11:01:31.819]                 ...future.makeSendCondition <- base::local({
[11:01:31.819]                   sendCondition <- NULL
[11:01:31.819]                   function(frame = 1L) {
[11:01:31.819]                     if (is.function(sendCondition)) 
[11:01:31.819]                       return(sendCondition)
[11:01:31.819]                     ns <- getNamespace("parallel")
[11:01:31.819]                     if (exists("sendData", mode = "function", 
[11:01:31.819]                       envir = ns)) {
[11:01:31.819]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.819]                         envir = ns)
[11:01:31.819]                       envir <- sys.frame(frame)
[11:01:31.819]                       master <- NULL
[11:01:31.819]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.819]                         !identical(envir, emptyenv())) {
[11:01:31.819]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.819]                           inherits = FALSE)) {
[11:01:31.819]                           master <- get("master", mode = "list", 
[11:01:31.819]                             envir = envir, inherits = FALSE)
[11:01:31.819]                           if (inherits(master, c("SOCKnode", 
[11:01:31.819]                             "SOCK0node"))) {
[11:01:31.819]                             sendCondition <<- function(cond) {
[11:01:31.819]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.819]                                 success = TRUE)
[11:01:31.819]                               parallel_sendData(master, data)
[11:01:31.819]                             }
[11:01:31.819]                             return(sendCondition)
[11:01:31.819]                           }
[11:01:31.819]                         }
[11:01:31.819]                         frame <- frame + 1L
[11:01:31.819]                         envir <- sys.frame(frame)
[11:01:31.819]                       }
[11:01:31.819]                     }
[11:01:31.819]                     sendCondition <<- function(cond) NULL
[11:01:31.819]                   }
[11:01:31.819]                 })
[11:01:31.819]                 withCallingHandlers({
[11:01:31.819]                   {
[11:01:31.819]                     4
[11:01:31.819]                   }
[11:01:31.819]                 }, immediateCondition = function(cond) {
[11:01:31.819]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.819]                   sendCondition(cond)
[11:01:31.819]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.819]                   {
[11:01:31.819]                     inherits <- base::inherits
[11:01:31.819]                     invokeRestart <- base::invokeRestart
[11:01:31.819]                     is.null <- base::is.null
[11:01:31.819]                     muffled <- FALSE
[11:01:31.819]                     if (inherits(cond, "message")) {
[11:01:31.819]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.819]                       if (muffled) 
[11:01:31.819]                         invokeRestart("muffleMessage")
[11:01:31.819]                     }
[11:01:31.819]                     else if (inherits(cond, "warning")) {
[11:01:31.819]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.819]                       if (muffled) 
[11:01:31.819]                         invokeRestart("muffleWarning")
[11:01:31.819]                     }
[11:01:31.819]                     else if (inherits(cond, "condition")) {
[11:01:31.819]                       if (!is.null(pattern)) {
[11:01:31.819]                         computeRestarts <- base::computeRestarts
[11:01:31.819]                         grepl <- base::grepl
[11:01:31.819]                         restarts <- computeRestarts(cond)
[11:01:31.819]                         for (restart in restarts) {
[11:01:31.819]                           name <- restart$name
[11:01:31.819]                           if (is.null(name)) 
[11:01:31.819]                             next
[11:01:31.819]                           if (!grepl(pattern, name)) 
[11:01:31.819]                             next
[11:01:31.819]                           invokeRestart(restart)
[11:01:31.819]                           muffled <- TRUE
[11:01:31.819]                           break
[11:01:31.819]                         }
[11:01:31.819]                       }
[11:01:31.819]                     }
[11:01:31.819]                     invisible(muffled)
[11:01:31.819]                   }
[11:01:31.819]                   muffleCondition(cond)
[11:01:31.819]                 })
[11:01:31.819]             }))
[11:01:31.819]             future::FutureResult(value = ...future.value$value, 
[11:01:31.819]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.819]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.819]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.819]                     ...future.globalenv.names))
[11:01:31.819]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.819]         }, condition = base::local({
[11:01:31.819]             c <- base::c
[11:01:31.819]             inherits <- base::inherits
[11:01:31.819]             invokeRestart <- base::invokeRestart
[11:01:31.819]             length <- base::length
[11:01:31.819]             list <- base::list
[11:01:31.819]             seq.int <- base::seq.int
[11:01:31.819]             signalCondition <- base::signalCondition
[11:01:31.819]             sys.calls <- base::sys.calls
[11:01:31.819]             `[[` <- base::`[[`
[11:01:31.819]             `+` <- base::`+`
[11:01:31.819]             `<<-` <- base::`<<-`
[11:01:31.819]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.819]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.819]                   3L)]
[11:01:31.819]             }
[11:01:31.819]             function(cond) {
[11:01:31.819]                 is_error <- inherits(cond, "error")
[11:01:31.819]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.819]                   NULL)
[11:01:31.819]                 if (is_error) {
[11:01:31.819]                   sessionInformation <- function() {
[11:01:31.819]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.819]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.819]                       search = base::search(), system = base::Sys.info())
[11:01:31.819]                   }
[11:01:31.819]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.819]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.819]                     cond$call), session = sessionInformation(), 
[11:01:31.819]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.819]                   signalCondition(cond)
[11:01:31.819]                 }
[11:01:31.819]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.819]                 "immediateCondition"))) {
[11:01:31.819]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.819]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.819]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.819]                   if (TRUE && !signal) {
[11:01:31.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.819]                     {
[11:01:31.819]                       inherits <- base::inherits
[11:01:31.819]                       invokeRestart <- base::invokeRestart
[11:01:31.819]                       is.null <- base::is.null
[11:01:31.819]                       muffled <- FALSE
[11:01:31.819]                       if (inherits(cond, "message")) {
[11:01:31.819]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.819]                         if (muffled) 
[11:01:31.819]                           invokeRestart("muffleMessage")
[11:01:31.819]                       }
[11:01:31.819]                       else if (inherits(cond, "warning")) {
[11:01:31.819]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.819]                         if (muffled) 
[11:01:31.819]                           invokeRestart("muffleWarning")
[11:01:31.819]                       }
[11:01:31.819]                       else if (inherits(cond, "condition")) {
[11:01:31.819]                         if (!is.null(pattern)) {
[11:01:31.819]                           computeRestarts <- base::computeRestarts
[11:01:31.819]                           grepl <- base::grepl
[11:01:31.819]                           restarts <- computeRestarts(cond)
[11:01:31.819]                           for (restart in restarts) {
[11:01:31.819]                             name <- restart$name
[11:01:31.819]                             if (is.null(name)) 
[11:01:31.819]                               next
[11:01:31.819]                             if (!grepl(pattern, name)) 
[11:01:31.819]                               next
[11:01:31.819]                             invokeRestart(restart)
[11:01:31.819]                             muffled <- TRUE
[11:01:31.819]                             break
[11:01:31.819]                           }
[11:01:31.819]                         }
[11:01:31.819]                       }
[11:01:31.819]                       invisible(muffled)
[11:01:31.819]                     }
[11:01:31.819]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.819]                   }
[11:01:31.819]                 }
[11:01:31.819]                 else {
[11:01:31.819]                   if (TRUE) {
[11:01:31.819]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.819]                     {
[11:01:31.819]                       inherits <- base::inherits
[11:01:31.819]                       invokeRestart <- base::invokeRestart
[11:01:31.819]                       is.null <- base::is.null
[11:01:31.819]                       muffled <- FALSE
[11:01:31.819]                       if (inherits(cond, "message")) {
[11:01:31.819]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.819]                         if (muffled) 
[11:01:31.819]                           invokeRestart("muffleMessage")
[11:01:31.819]                       }
[11:01:31.819]                       else if (inherits(cond, "warning")) {
[11:01:31.819]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.819]                         if (muffled) 
[11:01:31.819]                           invokeRestart("muffleWarning")
[11:01:31.819]                       }
[11:01:31.819]                       else if (inherits(cond, "condition")) {
[11:01:31.819]                         if (!is.null(pattern)) {
[11:01:31.819]                           computeRestarts <- base::computeRestarts
[11:01:31.819]                           grepl <- base::grepl
[11:01:31.819]                           restarts <- computeRestarts(cond)
[11:01:31.819]                           for (restart in restarts) {
[11:01:31.819]                             name <- restart$name
[11:01:31.819]                             if (is.null(name)) 
[11:01:31.819]                               next
[11:01:31.819]                             if (!grepl(pattern, name)) 
[11:01:31.819]                               next
[11:01:31.819]                             invokeRestart(restart)
[11:01:31.819]                             muffled <- TRUE
[11:01:31.819]                             break
[11:01:31.819]                           }
[11:01:31.819]                         }
[11:01:31.819]                       }
[11:01:31.819]                       invisible(muffled)
[11:01:31.819]                     }
[11:01:31.819]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.819]                   }
[11:01:31.819]                 }
[11:01:31.819]             }
[11:01:31.819]         }))
[11:01:31.819]     }, error = function(ex) {
[11:01:31.819]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.819]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.819]                 ...future.rng), started = ...future.startTime, 
[11:01:31.819]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.819]             version = "1.8"), class = "FutureResult")
[11:01:31.819]     }, finally = {
[11:01:31.819]         if (!identical(...future.workdir, getwd())) 
[11:01:31.819]             setwd(...future.workdir)
[11:01:31.819]         {
[11:01:31.819]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.819]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.819]             }
[11:01:31.819]             base::options(...future.oldOptions)
[11:01:31.819]             if (.Platform$OS.type == "windows") {
[11:01:31.819]                 old_names <- names(...future.oldEnvVars)
[11:01:31.819]                 envs <- base::Sys.getenv()
[11:01:31.819]                 names <- names(envs)
[11:01:31.819]                 common <- intersect(names, old_names)
[11:01:31.819]                 added <- setdiff(names, old_names)
[11:01:31.819]                 removed <- setdiff(old_names, names)
[11:01:31.819]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.819]                   envs[common]]
[11:01:31.819]                 NAMES <- toupper(changed)
[11:01:31.819]                 args <- list()
[11:01:31.819]                 for (kk in seq_along(NAMES)) {
[11:01:31.819]                   name <- changed[[kk]]
[11:01:31.819]                   NAME <- NAMES[[kk]]
[11:01:31.819]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.819]                     next
[11:01:31.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.819]                 }
[11:01:31.819]                 NAMES <- toupper(added)
[11:01:31.819]                 for (kk in seq_along(NAMES)) {
[11:01:31.819]                   name <- added[[kk]]
[11:01:31.819]                   NAME <- NAMES[[kk]]
[11:01:31.819]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.819]                     next
[11:01:31.819]                   args[[name]] <- ""
[11:01:31.819]                 }
[11:01:31.819]                 NAMES <- toupper(removed)
[11:01:31.819]                 for (kk in seq_along(NAMES)) {
[11:01:31.819]                   name <- removed[[kk]]
[11:01:31.819]                   NAME <- NAMES[[kk]]
[11:01:31.819]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.819]                     next
[11:01:31.819]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.819]                 }
[11:01:31.819]                 if (length(args) > 0) 
[11:01:31.819]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.819]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.819]             }
[11:01:31.819]             else {
[11:01:31.819]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.819]             }
[11:01:31.819]             {
[11:01:31.819]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.819]                   0L) {
[11:01:31.819]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.819]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.819]                   base::options(opts)
[11:01:31.819]                 }
[11:01:31.819]                 {
[11:01:31.819]                   {
[11:01:31.819]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.819]                     NULL
[11:01:31.819]                   }
[11:01:31.819]                   options(future.plan = NULL)
[11:01:31.819]                   if (is.na(NA_character_)) 
[11:01:31.819]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.819]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.819]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.819]                     .init = FALSE)
[11:01:31.819]                 }
[11:01:31.819]             }
[11:01:31.819]         }
[11:01:31.819]     })
[11:01:31.819]     if (TRUE) {
[11:01:31.819]         base::sink(type = "output", split = FALSE)
[11:01:31.819]         if (TRUE) {
[11:01:31.819]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.819]         }
[11:01:31.819]         else {
[11:01:31.819]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.819]         }
[11:01:31.819]         base::close(...future.stdout)
[11:01:31.819]         ...future.stdout <- NULL
[11:01:31.819]     }
[11:01:31.819]     ...future.result$conditions <- ...future.conditions
[11:01:31.819]     ...future.result$finished <- base::Sys.time()
[11:01:31.819]     ...future.result
[11:01:31.819] }
[11:01:31.822] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:31.833] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.833] - Validating connection of MultisessionFuture
[11:01:31.833] - received message: FutureResult
[11:01:31.833] - Received FutureResult
[11:01:31.833] - Erased future from FutureRegistry
[11:01:31.834] result() for ClusterFuture ...
[11:01:31.834] - result already collected: FutureResult
[11:01:31.834] result() for ClusterFuture ... done
[11:01:31.834] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:31.834] result() for ClusterFuture ...
[11:01:31.834] - result already collected: FutureResult
[11:01:31.834] result() for ClusterFuture ... done
[11:01:31.834] result() for ClusterFuture ...
[11:01:31.834] - result already collected: FutureResult
[11:01:31.834] result() for ClusterFuture ... done
[11:01:31.835] MultisessionFuture started
[11:01:31.835] - Launch lazy future ... done
[11:01:31.836] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a9c7eeb878> 
<environment: 0x55a9c8c2a710> 
[11:01:31.842] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.842] - Validating connection of MultisessionFuture
[11:01:31.842] - received message: FutureResult
[11:01:31.842] - Received FutureResult
[11:01:31.843] - Erased future from FutureRegistry
[11:01:31.843] result() for ClusterFuture ...
[11:01:31.843] - result already collected: FutureResult
[11:01:31.843] result() for ClusterFuture ... done
[11:01:31.843] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:31.855] resolve() on environment ...
[11:01:31.855]  recursive: 0
[11:01:31.855]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:31.855] signalConditionsASAP(numeric, pos=1) ...
[11:01:31.855] - nx: 4
[11:01:31.857] - relay: TRUE
[11:01:31.858] - stdout: TRUE
[11:01:31.858] - signal: TRUE
[11:01:31.858] - resignal: FALSE
[11:01:31.858] - force: TRUE
[11:01:31.858] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.858] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.858]  - until=2
[11:01:31.858]  - relaying element #2
[11:01:31.858] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.858] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.859] signalConditionsASAP(NULL, pos=1) ... done
[11:01:31.859]  length: 3 (resolved future 1)
[11:01:31.859] Future #2
[11:01:31.859] result() for ClusterFuture ...
[11:01:31.859] - result already collected: FutureResult
[11:01:31.859] result() for ClusterFuture ... done
[11:01:31.859] result() for ClusterFuture ...
[11:01:31.859] - result already collected: FutureResult
[11:01:31.859] result() for ClusterFuture ... done
[11:01:31.859] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:31.859] - nx: 4
[11:01:31.859] - relay: TRUE
[11:01:31.860] - stdout: TRUE
[11:01:31.860] - signal: TRUE
[11:01:31.860] - resignal: FALSE
[11:01:31.860] - force: TRUE
[11:01:31.860] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.860] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.860]  - until=2
[11:01:31.860]  - relaying element #2
[11:01:31.860] result() for ClusterFuture ...
[11:01:31.860] - result already collected: FutureResult
[11:01:31.860] result() for ClusterFuture ... done
[11:01:31.860] result() for ClusterFuture ...
[11:01:31.860] - result already collected: FutureResult
[11:01:31.861] result() for ClusterFuture ... done
[11:01:31.861] result() for ClusterFuture ...
[11:01:31.861] - result already collected: FutureResult
[11:01:31.861] result() for ClusterFuture ... done
[11:01:31.861] result() for ClusterFuture ...
[11:01:31.861] - result already collected: FutureResult
[11:01:31.861] result() for ClusterFuture ... done
[11:01:31.861] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.861] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.861] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:31.861]  length: 2 (resolved future 2)
[11:01:31.861] Future #3
[11:01:31.862] result() for ClusterFuture ...
[11:01:31.862] - result already collected: FutureResult
[11:01:31.862] result() for ClusterFuture ... done
[11:01:31.862] result() for ClusterFuture ...
[11:01:31.862] - result already collected: FutureResult
[11:01:31.862] result() for ClusterFuture ... done
[11:01:31.862] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:31.862] - nx: 4
[11:01:31.862] - relay: TRUE
[11:01:31.862] - stdout: TRUE
[11:01:31.862] - signal: TRUE
[11:01:31.862] - resignal: FALSE
[11:01:31.863] - force: TRUE
[11:01:31.863] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.863] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.863]  - until=3
[11:01:31.863]  - relaying element #3
[11:01:31.863] result() for ClusterFuture ...
[11:01:31.863] - result already collected: FutureResult
[11:01:31.863] result() for ClusterFuture ... done
[11:01:31.863] result() for ClusterFuture ...
[11:01:31.863] - result already collected: FutureResult
[11:01:31.863] result() for ClusterFuture ... done
[11:01:31.863] result() for ClusterFuture ...
[11:01:31.863] - result already collected: FutureResult
[11:01:31.864] result() for ClusterFuture ... done
[11:01:31.864] result() for ClusterFuture ...
[11:01:31.864] - result already collected: FutureResult
[11:01:31.864] result() for ClusterFuture ... done
[11:01:31.864] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:31.864] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:31.864] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:31.864]  length: 1 (resolved future 3)
[11:01:31.885] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.885] - Validating connection of MultisessionFuture
[11:01:31.886] - received message: FutureResult
[11:01:31.886] - Received FutureResult
[11:01:31.886] - Erased future from FutureRegistry
[11:01:31.886] result() for ClusterFuture ...
[11:01:31.886] - result already collected: FutureResult
[11:01:31.886] result() for ClusterFuture ... done
[11:01:31.886] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:31.886] Future #4
[11:01:31.886] result() for ClusterFuture ...
[11:01:31.886] - result already collected: FutureResult
[11:01:31.886] result() for ClusterFuture ... done
[11:01:31.886] result() for ClusterFuture ...
[11:01:31.887] - result already collected: FutureResult
[11:01:31.887] result() for ClusterFuture ... done
[11:01:31.887] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:31.887] - nx: 4
[11:01:31.887] - relay: TRUE
[11:01:31.887] - stdout: TRUE
[11:01:31.887] - signal: TRUE
[11:01:31.887] - resignal: FALSE
[11:01:31.887] - force: TRUE
[11:01:31.887] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:31.887] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:31.887]  - until=4
[11:01:31.888]  - relaying element #4
[11:01:31.888] result() for ClusterFuture ...
[11:01:31.888] - result already collected: FutureResult
[11:01:31.888] result() for ClusterFuture ... done
[11:01:31.888] result() for ClusterFuture ...
[11:01:31.888] - result already collected: FutureResult
[11:01:31.888] result() for ClusterFuture ... done
[11:01:31.888] result() for ClusterFuture ...
[11:01:31.888] - result already collected: FutureResult
[11:01:31.888] result() for ClusterFuture ... done
[11:01:31.888] result() for ClusterFuture ...
[11:01:31.888] - result already collected: FutureResult
[11:01:31.889] result() for ClusterFuture ... done
[11:01:31.889] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.889] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:31.889] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:31.889]  length: 0 (resolved future 4)
[11:01:31.889] Relaying remaining futures
[11:01:31.889] signalConditionsASAP(NULL, pos=0) ...
[11:01:31.889] - nx: 4
[11:01:31.889] - relay: TRUE
[11:01:31.889] - stdout: TRUE
[11:01:31.889] - signal: TRUE
[11:01:31.889] - resignal: FALSE
[11:01:31.889] - force: TRUE
[11:01:31.890] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.890] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:31.890] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:31.890] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:31.890] signalConditionsASAP(NULL, pos=0) ... done
[11:01:31.890] resolve() on environment ... DONE
[11:01:31.890] result() for ClusterFuture ...
[11:01:31.890] - result already collected: FutureResult
[11:01:31.890] result() for ClusterFuture ... done
[11:01:31.890] result() for ClusterFuture ...
[11:01:31.890] - result already collected: FutureResult
[11:01:31.890] result() for ClusterFuture ... done
[11:01:31.891] result() for ClusterFuture ...
[11:01:31.891] - result already collected: FutureResult
[11:01:31.891] result() for ClusterFuture ... done
[11:01:31.891] result() for ClusterFuture ...
[11:01:31.891] - result already collected: FutureResult
[11:01:31.891] result() for ClusterFuture ... done
[11:01:31.891] result() for ClusterFuture ...
[11:01:31.891] - result already collected: FutureResult
[11:01:31.891] result() for ClusterFuture ... done
[11:01:31.891] result() for ClusterFuture ...
[11:01:31.891] - result already collected: FutureResult
[11:01:31.891] result() for ClusterFuture ... done
<environment: 0x55a9c8e28008> 
Dimensions: c(2, 3, 1)
[11:01:31.892] getGlobalsAndPackages() ...
[11:01:31.892] Searching for globals...
[11:01:31.892] 
[11:01:31.892] Searching for globals ... DONE
[11:01:31.892] - globals: [0] <none>
[11:01:31.892] getGlobalsAndPackages() ... DONE
[11:01:31.893] run() for ‘Future’ ...
[11:01:31.893] - state: ‘created’
[11:01:31.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.906] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.906] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.907]   - Field: ‘node’
[11:01:31.907]   - Field: ‘label’
[11:01:31.907]   - Field: ‘local’
[11:01:31.907]   - Field: ‘owner’
[11:01:31.907]   - Field: ‘envir’
[11:01:31.907]   - Field: ‘workers’
[11:01:31.907]   - Field: ‘packages’
[11:01:31.907]   - Field: ‘gc’
[11:01:31.907]   - Field: ‘conditions’
[11:01:31.907]   - Field: ‘persistent’
[11:01:31.907]   - Field: ‘expr’
[11:01:31.908]   - Field: ‘uuid’
[11:01:31.908]   - Field: ‘seed’
[11:01:31.908]   - Field: ‘version’
[11:01:31.908]   - Field: ‘result’
[11:01:31.908]   - Field: ‘asynchronous’
[11:01:31.908]   - Field: ‘calls’
[11:01:31.908]   - Field: ‘globals’
[11:01:31.908]   - Field: ‘stdout’
[11:01:31.908]   - Field: ‘earlySignal’
[11:01:31.908]   - Field: ‘lazy’
[11:01:31.908]   - Field: ‘state’
[11:01:31.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.909] - Launch lazy future ...
[11:01:31.909] Packages needed by the future expression (n = 0): <none>
[11:01:31.909] Packages needed by future strategies (n = 0): <none>
[11:01:31.909] {
[11:01:31.909]     {
[11:01:31.909]         {
[11:01:31.909]             ...future.startTime <- base::Sys.time()
[11:01:31.909]             {
[11:01:31.909]                 {
[11:01:31.909]                   {
[11:01:31.909]                     {
[11:01:31.909]                       base::local({
[11:01:31.909]                         has_future <- base::requireNamespace("future", 
[11:01:31.909]                           quietly = TRUE)
[11:01:31.909]                         if (has_future) {
[11:01:31.909]                           ns <- base::getNamespace("future")
[11:01:31.909]                           version <- ns[[".package"]][["version"]]
[11:01:31.909]                           if (is.null(version)) 
[11:01:31.909]                             version <- utils::packageVersion("future")
[11:01:31.909]                         }
[11:01:31.909]                         else {
[11:01:31.909]                           version <- NULL
[11:01:31.909]                         }
[11:01:31.909]                         if (!has_future || version < "1.8.0") {
[11:01:31.909]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.909]                             "", base::R.version$version.string), 
[11:01:31.909]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.909]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.909]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.909]                               "release", "version")], collapse = " "), 
[11:01:31.909]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.909]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.909]                             info)
[11:01:31.909]                           info <- base::paste(info, collapse = "; ")
[11:01:31.909]                           if (!has_future) {
[11:01:31.909]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.909]                               info)
[11:01:31.909]                           }
[11:01:31.909]                           else {
[11:01:31.909]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.909]                               info, version)
[11:01:31.909]                           }
[11:01:31.909]                           base::stop(msg)
[11:01:31.909]                         }
[11:01:31.909]                       })
[11:01:31.909]                     }
[11:01:31.909]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.909]                     base::options(mc.cores = 1L)
[11:01:31.909]                   }
[11:01:31.909]                   ...future.strategy.old <- future::plan("list")
[11:01:31.909]                   options(future.plan = NULL)
[11:01:31.909]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.909]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.909]                 }
[11:01:31.909]                 ...future.workdir <- getwd()
[11:01:31.909]             }
[11:01:31.909]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.909]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.909]         }
[11:01:31.909]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.909]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.909]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.909]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.909]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.909]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.909]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.909]             base::names(...future.oldOptions))
[11:01:31.909]     }
[11:01:31.909]     if (FALSE) {
[11:01:31.909]     }
[11:01:31.909]     else {
[11:01:31.909]         if (TRUE) {
[11:01:31.909]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.909]                 open = "w")
[11:01:31.909]         }
[11:01:31.909]         else {
[11:01:31.909]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.909]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.909]         }
[11:01:31.909]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.909]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.909]             base::sink(type = "output", split = FALSE)
[11:01:31.909]             base::close(...future.stdout)
[11:01:31.909]         }, add = TRUE)
[11:01:31.909]     }
[11:01:31.909]     ...future.frame <- base::sys.nframe()
[11:01:31.909]     ...future.conditions <- base::list()
[11:01:31.909]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.909]     if (FALSE) {
[11:01:31.909]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.909]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.909]     }
[11:01:31.909]     ...future.result <- base::tryCatch({
[11:01:31.909]         base::withCallingHandlers({
[11:01:31.909]             ...future.value <- base::withVisible(base::local({
[11:01:31.909]                 ...future.makeSendCondition <- base::local({
[11:01:31.909]                   sendCondition <- NULL
[11:01:31.909]                   function(frame = 1L) {
[11:01:31.909]                     if (is.function(sendCondition)) 
[11:01:31.909]                       return(sendCondition)
[11:01:31.909]                     ns <- getNamespace("parallel")
[11:01:31.909]                     if (exists("sendData", mode = "function", 
[11:01:31.909]                       envir = ns)) {
[11:01:31.909]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.909]                         envir = ns)
[11:01:31.909]                       envir <- sys.frame(frame)
[11:01:31.909]                       master <- NULL
[11:01:31.909]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.909]                         !identical(envir, emptyenv())) {
[11:01:31.909]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.909]                           inherits = FALSE)) {
[11:01:31.909]                           master <- get("master", mode = "list", 
[11:01:31.909]                             envir = envir, inherits = FALSE)
[11:01:31.909]                           if (inherits(master, c("SOCKnode", 
[11:01:31.909]                             "SOCK0node"))) {
[11:01:31.909]                             sendCondition <<- function(cond) {
[11:01:31.909]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.909]                                 success = TRUE)
[11:01:31.909]                               parallel_sendData(master, data)
[11:01:31.909]                             }
[11:01:31.909]                             return(sendCondition)
[11:01:31.909]                           }
[11:01:31.909]                         }
[11:01:31.909]                         frame <- frame + 1L
[11:01:31.909]                         envir <- sys.frame(frame)
[11:01:31.909]                       }
[11:01:31.909]                     }
[11:01:31.909]                     sendCondition <<- function(cond) NULL
[11:01:31.909]                   }
[11:01:31.909]                 })
[11:01:31.909]                 withCallingHandlers({
[11:01:31.909]                   2
[11:01:31.909]                 }, immediateCondition = function(cond) {
[11:01:31.909]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.909]                   sendCondition(cond)
[11:01:31.909]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.909]                   {
[11:01:31.909]                     inherits <- base::inherits
[11:01:31.909]                     invokeRestart <- base::invokeRestart
[11:01:31.909]                     is.null <- base::is.null
[11:01:31.909]                     muffled <- FALSE
[11:01:31.909]                     if (inherits(cond, "message")) {
[11:01:31.909]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.909]                       if (muffled) 
[11:01:31.909]                         invokeRestart("muffleMessage")
[11:01:31.909]                     }
[11:01:31.909]                     else if (inherits(cond, "warning")) {
[11:01:31.909]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.909]                       if (muffled) 
[11:01:31.909]                         invokeRestart("muffleWarning")
[11:01:31.909]                     }
[11:01:31.909]                     else if (inherits(cond, "condition")) {
[11:01:31.909]                       if (!is.null(pattern)) {
[11:01:31.909]                         computeRestarts <- base::computeRestarts
[11:01:31.909]                         grepl <- base::grepl
[11:01:31.909]                         restarts <- computeRestarts(cond)
[11:01:31.909]                         for (restart in restarts) {
[11:01:31.909]                           name <- restart$name
[11:01:31.909]                           if (is.null(name)) 
[11:01:31.909]                             next
[11:01:31.909]                           if (!grepl(pattern, name)) 
[11:01:31.909]                             next
[11:01:31.909]                           invokeRestart(restart)
[11:01:31.909]                           muffled <- TRUE
[11:01:31.909]                           break
[11:01:31.909]                         }
[11:01:31.909]                       }
[11:01:31.909]                     }
[11:01:31.909]                     invisible(muffled)
[11:01:31.909]                   }
[11:01:31.909]                   muffleCondition(cond)
[11:01:31.909]                 })
[11:01:31.909]             }))
[11:01:31.909]             future::FutureResult(value = ...future.value$value, 
[11:01:31.909]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.909]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.909]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.909]                     ...future.globalenv.names))
[11:01:31.909]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.909]         }, condition = base::local({
[11:01:31.909]             c <- base::c
[11:01:31.909]             inherits <- base::inherits
[11:01:31.909]             invokeRestart <- base::invokeRestart
[11:01:31.909]             length <- base::length
[11:01:31.909]             list <- base::list
[11:01:31.909]             seq.int <- base::seq.int
[11:01:31.909]             signalCondition <- base::signalCondition
[11:01:31.909]             sys.calls <- base::sys.calls
[11:01:31.909]             `[[` <- base::`[[`
[11:01:31.909]             `+` <- base::`+`
[11:01:31.909]             `<<-` <- base::`<<-`
[11:01:31.909]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.909]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.909]                   3L)]
[11:01:31.909]             }
[11:01:31.909]             function(cond) {
[11:01:31.909]                 is_error <- inherits(cond, "error")
[11:01:31.909]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.909]                   NULL)
[11:01:31.909]                 if (is_error) {
[11:01:31.909]                   sessionInformation <- function() {
[11:01:31.909]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.909]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.909]                       search = base::search(), system = base::Sys.info())
[11:01:31.909]                   }
[11:01:31.909]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.909]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.909]                     cond$call), session = sessionInformation(), 
[11:01:31.909]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.909]                   signalCondition(cond)
[11:01:31.909]                 }
[11:01:31.909]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.909]                 "immediateCondition"))) {
[11:01:31.909]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.909]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.909]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.909]                   if (TRUE && !signal) {
[11:01:31.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.909]                     {
[11:01:31.909]                       inherits <- base::inherits
[11:01:31.909]                       invokeRestart <- base::invokeRestart
[11:01:31.909]                       is.null <- base::is.null
[11:01:31.909]                       muffled <- FALSE
[11:01:31.909]                       if (inherits(cond, "message")) {
[11:01:31.909]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.909]                         if (muffled) 
[11:01:31.909]                           invokeRestart("muffleMessage")
[11:01:31.909]                       }
[11:01:31.909]                       else if (inherits(cond, "warning")) {
[11:01:31.909]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.909]                         if (muffled) 
[11:01:31.909]                           invokeRestart("muffleWarning")
[11:01:31.909]                       }
[11:01:31.909]                       else if (inherits(cond, "condition")) {
[11:01:31.909]                         if (!is.null(pattern)) {
[11:01:31.909]                           computeRestarts <- base::computeRestarts
[11:01:31.909]                           grepl <- base::grepl
[11:01:31.909]                           restarts <- computeRestarts(cond)
[11:01:31.909]                           for (restart in restarts) {
[11:01:31.909]                             name <- restart$name
[11:01:31.909]                             if (is.null(name)) 
[11:01:31.909]                               next
[11:01:31.909]                             if (!grepl(pattern, name)) 
[11:01:31.909]                               next
[11:01:31.909]                             invokeRestart(restart)
[11:01:31.909]                             muffled <- TRUE
[11:01:31.909]                             break
[11:01:31.909]                           }
[11:01:31.909]                         }
[11:01:31.909]                       }
[11:01:31.909]                       invisible(muffled)
[11:01:31.909]                     }
[11:01:31.909]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.909]                   }
[11:01:31.909]                 }
[11:01:31.909]                 else {
[11:01:31.909]                   if (TRUE) {
[11:01:31.909]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.909]                     {
[11:01:31.909]                       inherits <- base::inherits
[11:01:31.909]                       invokeRestart <- base::invokeRestart
[11:01:31.909]                       is.null <- base::is.null
[11:01:31.909]                       muffled <- FALSE
[11:01:31.909]                       if (inherits(cond, "message")) {
[11:01:31.909]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.909]                         if (muffled) 
[11:01:31.909]                           invokeRestart("muffleMessage")
[11:01:31.909]                       }
[11:01:31.909]                       else if (inherits(cond, "warning")) {
[11:01:31.909]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.909]                         if (muffled) 
[11:01:31.909]                           invokeRestart("muffleWarning")
[11:01:31.909]                       }
[11:01:31.909]                       else if (inherits(cond, "condition")) {
[11:01:31.909]                         if (!is.null(pattern)) {
[11:01:31.909]                           computeRestarts <- base::computeRestarts
[11:01:31.909]                           grepl <- base::grepl
[11:01:31.909]                           restarts <- computeRestarts(cond)
[11:01:31.909]                           for (restart in restarts) {
[11:01:31.909]                             name <- restart$name
[11:01:31.909]                             if (is.null(name)) 
[11:01:31.909]                               next
[11:01:31.909]                             if (!grepl(pattern, name)) 
[11:01:31.909]                               next
[11:01:31.909]                             invokeRestart(restart)
[11:01:31.909]                             muffled <- TRUE
[11:01:31.909]                             break
[11:01:31.909]                           }
[11:01:31.909]                         }
[11:01:31.909]                       }
[11:01:31.909]                       invisible(muffled)
[11:01:31.909]                     }
[11:01:31.909]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.909]                   }
[11:01:31.909]                 }
[11:01:31.909]             }
[11:01:31.909]         }))
[11:01:31.909]     }, error = function(ex) {
[11:01:31.909]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.909]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.909]                 ...future.rng), started = ...future.startTime, 
[11:01:31.909]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.909]             version = "1.8"), class = "FutureResult")
[11:01:31.909]     }, finally = {
[11:01:31.909]         if (!identical(...future.workdir, getwd())) 
[11:01:31.909]             setwd(...future.workdir)
[11:01:31.909]         {
[11:01:31.909]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.909]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.909]             }
[11:01:31.909]             base::options(...future.oldOptions)
[11:01:31.909]             if (.Platform$OS.type == "windows") {
[11:01:31.909]                 old_names <- names(...future.oldEnvVars)
[11:01:31.909]                 envs <- base::Sys.getenv()
[11:01:31.909]                 names <- names(envs)
[11:01:31.909]                 common <- intersect(names, old_names)
[11:01:31.909]                 added <- setdiff(names, old_names)
[11:01:31.909]                 removed <- setdiff(old_names, names)
[11:01:31.909]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.909]                   envs[common]]
[11:01:31.909]                 NAMES <- toupper(changed)
[11:01:31.909]                 args <- list()
[11:01:31.909]                 for (kk in seq_along(NAMES)) {
[11:01:31.909]                   name <- changed[[kk]]
[11:01:31.909]                   NAME <- NAMES[[kk]]
[11:01:31.909]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.909]                     next
[11:01:31.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.909]                 }
[11:01:31.909]                 NAMES <- toupper(added)
[11:01:31.909]                 for (kk in seq_along(NAMES)) {
[11:01:31.909]                   name <- added[[kk]]
[11:01:31.909]                   NAME <- NAMES[[kk]]
[11:01:31.909]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.909]                     next
[11:01:31.909]                   args[[name]] <- ""
[11:01:31.909]                 }
[11:01:31.909]                 NAMES <- toupper(removed)
[11:01:31.909]                 for (kk in seq_along(NAMES)) {
[11:01:31.909]                   name <- removed[[kk]]
[11:01:31.909]                   NAME <- NAMES[[kk]]
[11:01:31.909]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.909]                     next
[11:01:31.909]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.909]                 }
[11:01:31.909]                 if (length(args) > 0) 
[11:01:31.909]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.909]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.909]             }
[11:01:31.909]             else {
[11:01:31.909]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.909]             }
[11:01:31.909]             {
[11:01:31.909]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.909]                   0L) {
[11:01:31.909]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.909]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.909]                   base::options(opts)
[11:01:31.909]                 }
[11:01:31.909]                 {
[11:01:31.909]                   {
[11:01:31.909]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.909]                     NULL
[11:01:31.909]                   }
[11:01:31.909]                   options(future.plan = NULL)
[11:01:31.909]                   if (is.na(NA_character_)) 
[11:01:31.909]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.909]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.909]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.909]                     .init = FALSE)
[11:01:31.909]                 }
[11:01:31.909]             }
[11:01:31.909]         }
[11:01:31.909]     })
[11:01:31.909]     if (TRUE) {
[11:01:31.909]         base::sink(type = "output", split = FALSE)
[11:01:31.909]         if (TRUE) {
[11:01:31.909]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.909]         }
[11:01:31.909]         else {
[11:01:31.909]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.909]         }
[11:01:31.909]         base::close(...future.stdout)
[11:01:31.909]         ...future.stdout <- NULL
[11:01:31.909]     }
[11:01:31.909]     ...future.result$conditions <- ...future.conditions
[11:01:31.909]     ...future.result$finished <- base::Sys.time()
[11:01:31.909]     ...future.result
[11:01:31.909] }
[11:01:31.912] MultisessionFuture started
[11:01:31.912] - Launch lazy future ... done
[11:01:31.912] run() for ‘MultisessionFuture’ ... done
[11:01:31.913] getGlobalsAndPackages() ...
[11:01:31.913] Searching for globals...
[11:01:31.913] 
[11:01:31.913] Searching for globals ... DONE
[11:01:31.913] - globals: [0] <none>
[11:01:31.913] getGlobalsAndPackages() ... DONE
[11:01:31.913] run() for ‘Future’ ...
[11:01:31.913] - state: ‘created’
[11:01:31.914] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.927] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.927] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.927]   - Field: ‘node’
[11:01:31.927]   - Field: ‘label’
[11:01:31.927]   - Field: ‘local’
[11:01:31.928]   - Field: ‘owner’
[11:01:31.928]   - Field: ‘envir’
[11:01:31.928]   - Field: ‘workers’
[11:01:31.928]   - Field: ‘packages’
[11:01:31.928]   - Field: ‘gc’
[11:01:31.928]   - Field: ‘conditions’
[11:01:31.928]   - Field: ‘persistent’
[11:01:31.928]   - Field: ‘expr’
[11:01:31.928]   - Field: ‘uuid’
[11:01:31.928]   - Field: ‘seed’
[11:01:31.928]   - Field: ‘version’
[11:01:31.928]   - Field: ‘result’
[11:01:31.929]   - Field: ‘asynchronous’
[11:01:31.929]   - Field: ‘calls’
[11:01:31.929]   - Field: ‘globals’
[11:01:31.929]   - Field: ‘stdout’
[11:01:31.929]   - Field: ‘earlySignal’
[11:01:31.929]   - Field: ‘lazy’
[11:01:31.929]   - Field: ‘state’
[11:01:31.929] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.929] - Launch lazy future ...
[11:01:31.929] Packages needed by the future expression (n = 0): <none>
[11:01:31.930] Packages needed by future strategies (n = 0): <none>
[11:01:31.930] {
[11:01:31.930]     {
[11:01:31.930]         {
[11:01:31.930]             ...future.startTime <- base::Sys.time()
[11:01:31.930]             {
[11:01:31.930]                 {
[11:01:31.930]                   {
[11:01:31.930]                     {
[11:01:31.930]                       base::local({
[11:01:31.930]                         has_future <- base::requireNamespace("future", 
[11:01:31.930]                           quietly = TRUE)
[11:01:31.930]                         if (has_future) {
[11:01:31.930]                           ns <- base::getNamespace("future")
[11:01:31.930]                           version <- ns[[".package"]][["version"]]
[11:01:31.930]                           if (is.null(version)) 
[11:01:31.930]                             version <- utils::packageVersion("future")
[11:01:31.930]                         }
[11:01:31.930]                         else {
[11:01:31.930]                           version <- NULL
[11:01:31.930]                         }
[11:01:31.930]                         if (!has_future || version < "1.8.0") {
[11:01:31.930]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.930]                             "", base::R.version$version.string), 
[11:01:31.930]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.930]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.930]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.930]                               "release", "version")], collapse = " "), 
[11:01:31.930]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.930]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.930]                             info)
[11:01:31.930]                           info <- base::paste(info, collapse = "; ")
[11:01:31.930]                           if (!has_future) {
[11:01:31.930]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.930]                               info)
[11:01:31.930]                           }
[11:01:31.930]                           else {
[11:01:31.930]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.930]                               info, version)
[11:01:31.930]                           }
[11:01:31.930]                           base::stop(msg)
[11:01:31.930]                         }
[11:01:31.930]                       })
[11:01:31.930]                     }
[11:01:31.930]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.930]                     base::options(mc.cores = 1L)
[11:01:31.930]                   }
[11:01:31.930]                   ...future.strategy.old <- future::plan("list")
[11:01:31.930]                   options(future.plan = NULL)
[11:01:31.930]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.930]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.930]                 }
[11:01:31.930]                 ...future.workdir <- getwd()
[11:01:31.930]             }
[11:01:31.930]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.930]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.930]         }
[11:01:31.930]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.930]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.930]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.930]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.930]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.930]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.930]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.930]             base::names(...future.oldOptions))
[11:01:31.930]     }
[11:01:31.930]     if (FALSE) {
[11:01:31.930]     }
[11:01:31.930]     else {
[11:01:31.930]         if (TRUE) {
[11:01:31.930]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.930]                 open = "w")
[11:01:31.930]         }
[11:01:31.930]         else {
[11:01:31.930]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.930]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.930]         }
[11:01:31.930]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.930]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.930]             base::sink(type = "output", split = FALSE)
[11:01:31.930]             base::close(...future.stdout)
[11:01:31.930]         }, add = TRUE)
[11:01:31.930]     }
[11:01:31.930]     ...future.frame <- base::sys.nframe()
[11:01:31.930]     ...future.conditions <- base::list()
[11:01:31.930]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.930]     if (FALSE) {
[11:01:31.930]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.930]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.930]     }
[11:01:31.930]     ...future.result <- base::tryCatch({
[11:01:31.930]         base::withCallingHandlers({
[11:01:31.930]             ...future.value <- base::withVisible(base::local({
[11:01:31.930]                 ...future.makeSendCondition <- base::local({
[11:01:31.930]                   sendCondition <- NULL
[11:01:31.930]                   function(frame = 1L) {
[11:01:31.930]                     if (is.function(sendCondition)) 
[11:01:31.930]                       return(sendCondition)
[11:01:31.930]                     ns <- getNamespace("parallel")
[11:01:31.930]                     if (exists("sendData", mode = "function", 
[11:01:31.930]                       envir = ns)) {
[11:01:31.930]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.930]                         envir = ns)
[11:01:31.930]                       envir <- sys.frame(frame)
[11:01:31.930]                       master <- NULL
[11:01:31.930]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.930]                         !identical(envir, emptyenv())) {
[11:01:31.930]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.930]                           inherits = FALSE)) {
[11:01:31.930]                           master <- get("master", mode = "list", 
[11:01:31.930]                             envir = envir, inherits = FALSE)
[11:01:31.930]                           if (inherits(master, c("SOCKnode", 
[11:01:31.930]                             "SOCK0node"))) {
[11:01:31.930]                             sendCondition <<- function(cond) {
[11:01:31.930]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.930]                                 success = TRUE)
[11:01:31.930]                               parallel_sendData(master, data)
[11:01:31.930]                             }
[11:01:31.930]                             return(sendCondition)
[11:01:31.930]                           }
[11:01:31.930]                         }
[11:01:31.930]                         frame <- frame + 1L
[11:01:31.930]                         envir <- sys.frame(frame)
[11:01:31.930]                       }
[11:01:31.930]                     }
[11:01:31.930]                     sendCondition <<- function(cond) NULL
[11:01:31.930]                   }
[11:01:31.930]                 })
[11:01:31.930]                 withCallingHandlers({
[11:01:31.930]                   NULL
[11:01:31.930]                 }, immediateCondition = function(cond) {
[11:01:31.930]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.930]                   sendCondition(cond)
[11:01:31.930]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.930]                   {
[11:01:31.930]                     inherits <- base::inherits
[11:01:31.930]                     invokeRestart <- base::invokeRestart
[11:01:31.930]                     is.null <- base::is.null
[11:01:31.930]                     muffled <- FALSE
[11:01:31.930]                     if (inherits(cond, "message")) {
[11:01:31.930]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.930]                       if (muffled) 
[11:01:31.930]                         invokeRestart("muffleMessage")
[11:01:31.930]                     }
[11:01:31.930]                     else if (inherits(cond, "warning")) {
[11:01:31.930]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.930]                       if (muffled) 
[11:01:31.930]                         invokeRestart("muffleWarning")
[11:01:31.930]                     }
[11:01:31.930]                     else if (inherits(cond, "condition")) {
[11:01:31.930]                       if (!is.null(pattern)) {
[11:01:31.930]                         computeRestarts <- base::computeRestarts
[11:01:31.930]                         grepl <- base::grepl
[11:01:31.930]                         restarts <- computeRestarts(cond)
[11:01:31.930]                         for (restart in restarts) {
[11:01:31.930]                           name <- restart$name
[11:01:31.930]                           if (is.null(name)) 
[11:01:31.930]                             next
[11:01:31.930]                           if (!grepl(pattern, name)) 
[11:01:31.930]                             next
[11:01:31.930]                           invokeRestart(restart)
[11:01:31.930]                           muffled <- TRUE
[11:01:31.930]                           break
[11:01:31.930]                         }
[11:01:31.930]                       }
[11:01:31.930]                     }
[11:01:31.930]                     invisible(muffled)
[11:01:31.930]                   }
[11:01:31.930]                   muffleCondition(cond)
[11:01:31.930]                 })
[11:01:31.930]             }))
[11:01:31.930]             future::FutureResult(value = ...future.value$value, 
[11:01:31.930]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.930]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.930]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.930]                     ...future.globalenv.names))
[11:01:31.930]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.930]         }, condition = base::local({
[11:01:31.930]             c <- base::c
[11:01:31.930]             inherits <- base::inherits
[11:01:31.930]             invokeRestart <- base::invokeRestart
[11:01:31.930]             length <- base::length
[11:01:31.930]             list <- base::list
[11:01:31.930]             seq.int <- base::seq.int
[11:01:31.930]             signalCondition <- base::signalCondition
[11:01:31.930]             sys.calls <- base::sys.calls
[11:01:31.930]             `[[` <- base::`[[`
[11:01:31.930]             `+` <- base::`+`
[11:01:31.930]             `<<-` <- base::`<<-`
[11:01:31.930]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.930]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.930]                   3L)]
[11:01:31.930]             }
[11:01:31.930]             function(cond) {
[11:01:31.930]                 is_error <- inherits(cond, "error")
[11:01:31.930]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.930]                   NULL)
[11:01:31.930]                 if (is_error) {
[11:01:31.930]                   sessionInformation <- function() {
[11:01:31.930]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.930]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.930]                       search = base::search(), system = base::Sys.info())
[11:01:31.930]                   }
[11:01:31.930]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.930]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.930]                     cond$call), session = sessionInformation(), 
[11:01:31.930]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.930]                   signalCondition(cond)
[11:01:31.930]                 }
[11:01:31.930]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.930]                 "immediateCondition"))) {
[11:01:31.930]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.930]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.930]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.930]                   if (TRUE && !signal) {
[11:01:31.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.930]                     {
[11:01:31.930]                       inherits <- base::inherits
[11:01:31.930]                       invokeRestart <- base::invokeRestart
[11:01:31.930]                       is.null <- base::is.null
[11:01:31.930]                       muffled <- FALSE
[11:01:31.930]                       if (inherits(cond, "message")) {
[11:01:31.930]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.930]                         if (muffled) 
[11:01:31.930]                           invokeRestart("muffleMessage")
[11:01:31.930]                       }
[11:01:31.930]                       else if (inherits(cond, "warning")) {
[11:01:31.930]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.930]                         if (muffled) 
[11:01:31.930]                           invokeRestart("muffleWarning")
[11:01:31.930]                       }
[11:01:31.930]                       else if (inherits(cond, "condition")) {
[11:01:31.930]                         if (!is.null(pattern)) {
[11:01:31.930]                           computeRestarts <- base::computeRestarts
[11:01:31.930]                           grepl <- base::grepl
[11:01:31.930]                           restarts <- computeRestarts(cond)
[11:01:31.930]                           for (restart in restarts) {
[11:01:31.930]                             name <- restart$name
[11:01:31.930]                             if (is.null(name)) 
[11:01:31.930]                               next
[11:01:31.930]                             if (!grepl(pattern, name)) 
[11:01:31.930]                               next
[11:01:31.930]                             invokeRestart(restart)
[11:01:31.930]                             muffled <- TRUE
[11:01:31.930]                             break
[11:01:31.930]                           }
[11:01:31.930]                         }
[11:01:31.930]                       }
[11:01:31.930]                       invisible(muffled)
[11:01:31.930]                     }
[11:01:31.930]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.930]                   }
[11:01:31.930]                 }
[11:01:31.930]                 else {
[11:01:31.930]                   if (TRUE) {
[11:01:31.930]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.930]                     {
[11:01:31.930]                       inherits <- base::inherits
[11:01:31.930]                       invokeRestart <- base::invokeRestart
[11:01:31.930]                       is.null <- base::is.null
[11:01:31.930]                       muffled <- FALSE
[11:01:31.930]                       if (inherits(cond, "message")) {
[11:01:31.930]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.930]                         if (muffled) 
[11:01:31.930]                           invokeRestart("muffleMessage")
[11:01:31.930]                       }
[11:01:31.930]                       else if (inherits(cond, "warning")) {
[11:01:31.930]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.930]                         if (muffled) 
[11:01:31.930]                           invokeRestart("muffleWarning")
[11:01:31.930]                       }
[11:01:31.930]                       else if (inherits(cond, "condition")) {
[11:01:31.930]                         if (!is.null(pattern)) {
[11:01:31.930]                           computeRestarts <- base::computeRestarts
[11:01:31.930]                           grepl <- base::grepl
[11:01:31.930]                           restarts <- computeRestarts(cond)
[11:01:31.930]                           for (restart in restarts) {
[11:01:31.930]                             name <- restart$name
[11:01:31.930]                             if (is.null(name)) 
[11:01:31.930]                               next
[11:01:31.930]                             if (!grepl(pattern, name)) 
[11:01:31.930]                               next
[11:01:31.930]                             invokeRestart(restart)
[11:01:31.930]                             muffled <- TRUE
[11:01:31.930]                             break
[11:01:31.930]                           }
[11:01:31.930]                         }
[11:01:31.930]                       }
[11:01:31.930]                       invisible(muffled)
[11:01:31.930]                     }
[11:01:31.930]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.930]                   }
[11:01:31.930]                 }
[11:01:31.930]             }
[11:01:31.930]         }))
[11:01:31.930]     }, error = function(ex) {
[11:01:31.930]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.930]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.930]                 ...future.rng), started = ...future.startTime, 
[11:01:31.930]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.930]             version = "1.8"), class = "FutureResult")
[11:01:31.930]     }, finally = {
[11:01:31.930]         if (!identical(...future.workdir, getwd())) 
[11:01:31.930]             setwd(...future.workdir)
[11:01:31.930]         {
[11:01:31.930]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.930]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.930]             }
[11:01:31.930]             base::options(...future.oldOptions)
[11:01:31.930]             if (.Platform$OS.type == "windows") {
[11:01:31.930]                 old_names <- names(...future.oldEnvVars)
[11:01:31.930]                 envs <- base::Sys.getenv()
[11:01:31.930]                 names <- names(envs)
[11:01:31.930]                 common <- intersect(names, old_names)
[11:01:31.930]                 added <- setdiff(names, old_names)
[11:01:31.930]                 removed <- setdiff(old_names, names)
[11:01:31.930]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.930]                   envs[common]]
[11:01:31.930]                 NAMES <- toupper(changed)
[11:01:31.930]                 args <- list()
[11:01:31.930]                 for (kk in seq_along(NAMES)) {
[11:01:31.930]                   name <- changed[[kk]]
[11:01:31.930]                   NAME <- NAMES[[kk]]
[11:01:31.930]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.930]                     next
[11:01:31.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.930]                 }
[11:01:31.930]                 NAMES <- toupper(added)
[11:01:31.930]                 for (kk in seq_along(NAMES)) {
[11:01:31.930]                   name <- added[[kk]]
[11:01:31.930]                   NAME <- NAMES[[kk]]
[11:01:31.930]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.930]                     next
[11:01:31.930]                   args[[name]] <- ""
[11:01:31.930]                 }
[11:01:31.930]                 NAMES <- toupper(removed)
[11:01:31.930]                 for (kk in seq_along(NAMES)) {
[11:01:31.930]                   name <- removed[[kk]]
[11:01:31.930]                   NAME <- NAMES[[kk]]
[11:01:31.930]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.930]                     next
[11:01:31.930]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.930]                 }
[11:01:31.930]                 if (length(args) > 0) 
[11:01:31.930]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.930]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.930]             }
[11:01:31.930]             else {
[11:01:31.930]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.930]             }
[11:01:31.930]             {
[11:01:31.930]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.930]                   0L) {
[11:01:31.930]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.930]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.930]                   base::options(opts)
[11:01:31.930]                 }
[11:01:31.930]                 {
[11:01:31.930]                   {
[11:01:31.930]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.930]                     NULL
[11:01:31.930]                   }
[11:01:31.930]                   options(future.plan = NULL)
[11:01:31.930]                   if (is.na(NA_character_)) 
[11:01:31.930]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.930]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.930]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.930]                     .init = FALSE)
[11:01:31.930]                 }
[11:01:31.930]             }
[11:01:31.930]         }
[11:01:31.930]     })
[11:01:31.930]     if (TRUE) {
[11:01:31.930]         base::sink(type = "output", split = FALSE)
[11:01:31.930]         if (TRUE) {
[11:01:31.930]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.930]         }
[11:01:31.930]         else {
[11:01:31.930]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.930]         }
[11:01:31.930]         base::close(...future.stdout)
[11:01:31.930]         ...future.stdout <- NULL
[11:01:31.930]     }
[11:01:31.930]     ...future.result$conditions <- ...future.conditions
[11:01:31.930]     ...future.result$finished <- base::Sys.time()
[11:01:31.930]     ...future.result
[11:01:31.930] }
[11:01:31.933] MultisessionFuture started
[11:01:31.933] - Launch lazy future ... done
[11:01:31.933] run() for ‘MultisessionFuture’ ... done
[11:01:31.933] getGlobalsAndPackages() ...
[11:01:31.933] Searching for globals...
[11:01:31.934] - globals found: [1] ‘{’
[11:01:31.934] Searching for globals ... DONE
[11:01:31.934] Resolving globals: FALSE
[11:01:31.934] 
[11:01:31.935] 
[11:01:31.935] getGlobalsAndPackages() ... DONE
[11:01:31.935] run() for ‘Future’ ...
[11:01:31.935] - state: ‘created’
[11:01:31.935] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:31.948] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:31.949] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:31.949]   - Field: ‘node’
[11:01:31.949]   - Field: ‘label’
[11:01:31.949]   - Field: ‘local’
[11:01:31.949]   - Field: ‘owner’
[11:01:31.949]   - Field: ‘envir’
[11:01:31.949]   - Field: ‘workers’
[11:01:31.949]   - Field: ‘packages’
[11:01:31.949]   - Field: ‘gc’
[11:01:31.949]   - Field: ‘conditions’
[11:01:31.949]   - Field: ‘persistent’
[11:01:31.949]   - Field: ‘expr’
[11:01:31.950]   - Field: ‘uuid’
[11:01:31.950]   - Field: ‘seed’
[11:01:31.950]   - Field: ‘version’
[11:01:31.950]   - Field: ‘result’
[11:01:31.950]   - Field: ‘asynchronous’
[11:01:31.950]   - Field: ‘calls’
[11:01:31.950]   - Field: ‘globals’
[11:01:31.950]   - Field: ‘stdout’
[11:01:31.950]   - Field: ‘earlySignal’
[11:01:31.950]   - Field: ‘lazy’
[11:01:31.950]   - Field: ‘state’
[11:01:31.951] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:31.951] - Launch lazy future ...
[11:01:31.951] Packages needed by the future expression (n = 0): <none>
[11:01:31.951] Packages needed by future strategies (n = 0): <none>
[11:01:31.951] {
[11:01:31.951]     {
[11:01:31.951]         {
[11:01:31.951]             ...future.startTime <- base::Sys.time()
[11:01:31.951]             {
[11:01:31.951]                 {
[11:01:31.951]                   {
[11:01:31.951]                     {
[11:01:31.951]                       base::local({
[11:01:31.951]                         has_future <- base::requireNamespace("future", 
[11:01:31.951]                           quietly = TRUE)
[11:01:31.951]                         if (has_future) {
[11:01:31.951]                           ns <- base::getNamespace("future")
[11:01:31.951]                           version <- ns[[".package"]][["version"]]
[11:01:31.951]                           if (is.null(version)) 
[11:01:31.951]                             version <- utils::packageVersion("future")
[11:01:31.951]                         }
[11:01:31.951]                         else {
[11:01:31.951]                           version <- NULL
[11:01:31.951]                         }
[11:01:31.951]                         if (!has_future || version < "1.8.0") {
[11:01:31.951]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:31.951]                             "", base::R.version$version.string), 
[11:01:31.951]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:31.951]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:31.951]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:31.951]                               "release", "version")], collapse = " "), 
[11:01:31.951]                             hostname = base::Sys.info()[["nodename"]])
[11:01:31.951]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:31.951]                             info)
[11:01:31.951]                           info <- base::paste(info, collapse = "; ")
[11:01:31.951]                           if (!has_future) {
[11:01:31.951]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:31.951]                               info)
[11:01:31.951]                           }
[11:01:31.951]                           else {
[11:01:31.951]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:31.951]                               info, version)
[11:01:31.951]                           }
[11:01:31.951]                           base::stop(msg)
[11:01:31.951]                         }
[11:01:31.951]                       })
[11:01:31.951]                     }
[11:01:31.951]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:31.951]                     base::options(mc.cores = 1L)
[11:01:31.951]                   }
[11:01:31.951]                   ...future.strategy.old <- future::plan("list")
[11:01:31.951]                   options(future.plan = NULL)
[11:01:31.951]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.951]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:31.951]                 }
[11:01:31.951]                 ...future.workdir <- getwd()
[11:01:31.951]             }
[11:01:31.951]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:31.951]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:31.951]         }
[11:01:31.951]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:31.951]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:31.951]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:31.951]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:31.951]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:31.951]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:31.951]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:31.951]             base::names(...future.oldOptions))
[11:01:31.951]     }
[11:01:31.951]     if (FALSE) {
[11:01:31.951]     }
[11:01:31.951]     else {
[11:01:31.951]         if (TRUE) {
[11:01:31.951]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:31.951]                 open = "w")
[11:01:31.951]         }
[11:01:31.951]         else {
[11:01:31.951]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:31.951]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:31.951]         }
[11:01:31.951]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:31.951]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:31.951]             base::sink(type = "output", split = FALSE)
[11:01:31.951]             base::close(...future.stdout)
[11:01:31.951]         }, add = TRUE)
[11:01:31.951]     }
[11:01:31.951]     ...future.frame <- base::sys.nframe()
[11:01:31.951]     ...future.conditions <- base::list()
[11:01:31.951]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:31.951]     if (FALSE) {
[11:01:31.951]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:31.951]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:31.951]     }
[11:01:31.951]     ...future.result <- base::tryCatch({
[11:01:31.951]         base::withCallingHandlers({
[11:01:31.951]             ...future.value <- base::withVisible(base::local({
[11:01:31.951]                 ...future.makeSendCondition <- base::local({
[11:01:31.951]                   sendCondition <- NULL
[11:01:31.951]                   function(frame = 1L) {
[11:01:31.951]                     if (is.function(sendCondition)) 
[11:01:31.951]                       return(sendCondition)
[11:01:31.951]                     ns <- getNamespace("parallel")
[11:01:31.951]                     if (exists("sendData", mode = "function", 
[11:01:31.951]                       envir = ns)) {
[11:01:31.951]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:31.951]                         envir = ns)
[11:01:31.951]                       envir <- sys.frame(frame)
[11:01:31.951]                       master <- NULL
[11:01:31.951]                       while (!identical(envir, .GlobalEnv) && 
[11:01:31.951]                         !identical(envir, emptyenv())) {
[11:01:31.951]                         if (exists("master", mode = "list", envir = envir, 
[11:01:31.951]                           inherits = FALSE)) {
[11:01:31.951]                           master <- get("master", mode = "list", 
[11:01:31.951]                             envir = envir, inherits = FALSE)
[11:01:31.951]                           if (inherits(master, c("SOCKnode", 
[11:01:31.951]                             "SOCK0node"))) {
[11:01:31.951]                             sendCondition <<- function(cond) {
[11:01:31.951]                               data <- list(type = "VALUE", value = cond, 
[11:01:31.951]                                 success = TRUE)
[11:01:31.951]                               parallel_sendData(master, data)
[11:01:31.951]                             }
[11:01:31.951]                             return(sendCondition)
[11:01:31.951]                           }
[11:01:31.951]                         }
[11:01:31.951]                         frame <- frame + 1L
[11:01:31.951]                         envir <- sys.frame(frame)
[11:01:31.951]                       }
[11:01:31.951]                     }
[11:01:31.951]                     sendCondition <<- function(cond) NULL
[11:01:31.951]                   }
[11:01:31.951]                 })
[11:01:31.951]                 withCallingHandlers({
[11:01:31.951]                   {
[11:01:31.951]                     4
[11:01:31.951]                   }
[11:01:31.951]                 }, immediateCondition = function(cond) {
[11:01:31.951]                   sendCondition <- ...future.makeSendCondition()
[11:01:31.951]                   sendCondition(cond)
[11:01:31.951]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.951]                   {
[11:01:31.951]                     inherits <- base::inherits
[11:01:31.951]                     invokeRestart <- base::invokeRestart
[11:01:31.951]                     is.null <- base::is.null
[11:01:31.951]                     muffled <- FALSE
[11:01:31.951]                     if (inherits(cond, "message")) {
[11:01:31.951]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:31.951]                       if (muffled) 
[11:01:31.951]                         invokeRestart("muffleMessage")
[11:01:31.951]                     }
[11:01:31.951]                     else if (inherits(cond, "warning")) {
[11:01:31.951]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:31.951]                       if (muffled) 
[11:01:31.951]                         invokeRestart("muffleWarning")
[11:01:31.951]                     }
[11:01:31.951]                     else if (inherits(cond, "condition")) {
[11:01:31.951]                       if (!is.null(pattern)) {
[11:01:31.951]                         computeRestarts <- base::computeRestarts
[11:01:31.951]                         grepl <- base::grepl
[11:01:31.951]                         restarts <- computeRestarts(cond)
[11:01:31.951]                         for (restart in restarts) {
[11:01:31.951]                           name <- restart$name
[11:01:31.951]                           if (is.null(name)) 
[11:01:31.951]                             next
[11:01:31.951]                           if (!grepl(pattern, name)) 
[11:01:31.951]                             next
[11:01:31.951]                           invokeRestart(restart)
[11:01:31.951]                           muffled <- TRUE
[11:01:31.951]                           break
[11:01:31.951]                         }
[11:01:31.951]                       }
[11:01:31.951]                     }
[11:01:31.951]                     invisible(muffled)
[11:01:31.951]                   }
[11:01:31.951]                   muffleCondition(cond)
[11:01:31.951]                 })
[11:01:31.951]             }))
[11:01:31.951]             future::FutureResult(value = ...future.value$value, 
[11:01:31.951]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.951]                   ...future.rng), globalenv = if (FALSE) 
[11:01:31.951]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:31.951]                     ...future.globalenv.names))
[11:01:31.951]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:31.951]         }, condition = base::local({
[11:01:31.951]             c <- base::c
[11:01:31.951]             inherits <- base::inherits
[11:01:31.951]             invokeRestart <- base::invokeRestart
[11:01:31.951]             length <- base::length
[11:01:31.951]             list <- base::list
[11:01:31.951]             seq.int <- base::seq.int
[11:01:31.951]             signalCondition <- base::signalCondition
[11:01:31.951]             sys.calls <- base::sys.calls
[11:01:31.951]             `[[` <- base::`[[`
[11:01:31.951]             `+` <- base::`+`
[11:01:31.951]             `<<-` <- base::`<<-`
[11:01:31.951]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:31.951]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:31.951]                   3L)]
[11:01:31.951]             }
[11:01:31.951]             function(cond) {
[11:01:31.951]                 is_error <- inherits(cond, "error")
[11:01:31.951]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:31.951]                   NULL)
[11:01:31.951]                 if (is_error) {
[11:01:31.951]                   sessionInformation <- function() {
[11:01:31.951]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:31.951]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:31.951]                       search = base::search(), system = base::Sys.info())
[11:01:31.951]                   }
[11:01:31.951]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.951]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:31.951]                     cond$call), session = sessionInformation(), 
[11:01:31.951]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:31.951]                   signalCondition(cond)
[11:01:31.951]                 }
[11:01:31.951]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:31.951]                 "immediateCondition"))) {
[11:01:31.951]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:31.951]                   ...future.conditions[[length(...future.conditions) + 
[11:01:31.951]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:31.951]                   if (TRUE && !signal) {
[11:01:31.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.951]                     {
[11:01:31.951]                       inherits <- base::inherits
[11:01:31.951]                       invokeRestart <- base::invokeRestart
[11:01:31.951]                       is.null <- base::is.null
[11:01:31.951]                       muffled <- FALSE
[11:01:31.951]                       if (inherits(cond, "message")) {
[11:01:31.951]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.951]                         if (muffled) 
[11:01:31.951]                           invokeRestart("muffleMessage")
[11:01:31.951]                       }
[11:01:31.951]                       else if (inherits(cond, "warning")) {
[11:01:31.951]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.951]                         if (muffled) 
[11:01:31.951]                           invokeRestart("muffleWarning")
[11:01:31.951]                       }
[11:01:31.951]                       else if (inherits(cond, "condition")) {
[11:01:31.951]                         if (!is.null(pattern)) {
[11:01:31.951]                           computeRestarts <- base::computeRestarts
[11:01:31.951]                           grepl <- base::grepl
[11:01:31.951]                           restarts <- computeRestarts(cond)
[11:01:31.951]                           for (restart in restarts) {
[11:01:31.951]                             name <- restart$name
[11:01:31.951]                             if (is.null(name)) 
[11:01:31.951]                               next
[11:01:31.951]                             if (!grepl(pattern, name)) 
[11:01:31.951]                               next
[11:01:31.951]                             invokeRestart(restart)
[11:01:31.951]                             muffled <- TRUE
[11:01:31.951]                             break
[11:01:31.951]                           }
[11:01:31.951]                         }
[11:01:31.951]                       }
[11:01:31.951]                       invisible(muffled)
[11:01:31.951]                     }
[11:01:31.951]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.951]                   }
[11:01:31.951]                 }
[11:01:31.951]                 else {
[11:01:31.951]                   if (TRUE) {
[11:01:31.951]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:31.951]                     {
[11:01:31.951]                       inherits <- base::inherits
[11:01:31.951]                       invokeRestart <- base::invokeRestart
[11:01:31.951]                       is.null <- base::is.null
[11:01:31.951]                       muffled <- FALSE
[11:01:31.951]                       if (inherits(cond, "message")) {
[11:01:31.951]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:31.951]                         if (muffled) 
[11:01:31.951]                           invokeRestart("muffleMessage")
[11:01:31.951]                       }
[11:01:31.951]                       else if (inherits(cond, "warning")) {
[11:01:31.951]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:31.951]                         if (muffled) 
[11:01:31.951]                           invokeRestart("muffleWarning")
[11:01:31.951]                       }
[11:01:31.951]                       else if (inherits(cond, "condition")) {
[11:01:31.951]                         if (!is.null(pattern)) {
[11:01:31.951]                           computeRestarts <- base::computeRestarts
[11:01:31.951]                           grepl <- base::grepl
[11:01:31.951]                           restarts <- computeRestarts(cond)
[11:01:31.951]                           for (restart in restarts) {
[11:01:31.951]                             name <- restart$name
[11:01:31.951]                             if (is.null(name)) 
[11:01:31.951]                               next
[11:01:31.951]                             if (!grepl(pattern, name)) 
[11:01:31.951]                               next
[11:01:31.951]                             invokeRestart(restart)
[11:01:31.951]                             muffled <- TRUE
[11:01:31.951]                             break
[11:01:31.951]                           }
[11:01:31.951]                         }
[11:01:31.951]                       }
[11:01:31.951]                       invisible(muffled)
[11:01:31.951]                     }
[11:01:31.951]                     muffleCondition(cond, pattern = "^muffle")
[11:01:31.951]                   }
[11:01:31.951]                 }
[11:01:31.951]             }
[11:01:31.951]         }))
[11:01:31.951]     }, error = function(ex) {
[11:01:31.951]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:31.951]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:31.951]                 ...future.rng), started = ...future.startTime, 
[11:01:31.951]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:31.951]             version = "1.8"), class = "FutureResult")
[11:01:31.951]     }, finally = {
[11:01:31.951]         if (!identical(...future.workdir, getwd())) 
[11:01:31.951]             setwd(...future.workdir)
[11:01:31.951]         {
[11:01:31.951]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:31.951]                 ...future.oldOptions$nwarnings <- NULL
[11:01:31.951]             }
[11:01:31.951]             base::options(...future.oldOptions)
[11:01:31.951]             if (.Platform$OS.type == "windows") {
[11:01:31.951]                 old_names <- names(...future.oldEnvVars)
[11:01:31.951]                 envs <- base::Sys.getenv()
[11:01:31.951]                 names <- names(envs)
[11:01:31.951]                 common <- intersect(names, old_names)
[11:01:31.951]                 added <- setdiff(names, old_names)
[11:01:31.951]                 removed <- setdiff(old_names, names)
[11:01:31.951]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:31.951]                   envs[common]]
[11:01:31.951]                 NAMES <- toupper(changed)
[11:01:31.951]                 args <- list()
[11:01:31.951]                 for (kk in seq_along(NAMES)) {
[11:01:31.951]                   name <- changed[[kk]]
[11:01:31.951]                   NAME <- NAMES[[kk]]
[11:01:31.951]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.951]                     next
[11:01:31.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.951]                 }
[11:01:31.951]                 NAMES <- toupper(added)
[11:01:31.951]                 for (kk in seq_along(NAMES)) {
[11:01:31.951]                   name <- added[[kk]]
[11:01:31.951]                   NAME <- NAMES[[kk]]
[11:01:31.951]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.951]                     next
[11:01:31.951]                   args[[name]] <- ""
[11:01:31.951]                 }
[11:01:31.951]                 NAMES <- toupper(removed)
[11:01:31.951]                 for (kk in seq_along(NAMES)) {
[11:01:31.951]                   name <- removed[[kk]]
[11:01:31.951]                   NAME <- NAMES[[kk]]
[11:01:31.951]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:31.951]                     next
[11:01:31.951]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:31.951]                 }
[11:01:31.951]                 if (length(args) > 0) 
[11:01:31.951]                   base::do.call(base::Sys.setenv, args = args)
[11:01:31.951]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:31.951]             }
[11:01:31.951]             else {
[11:01:31.951]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:31.951]             }
[11:01:31.951]             {
[11:01:31.951]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:31.951]                   0L) {
[11:01:31.951]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:31.951]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:31.951]                   base::options(opts)
[11:01:31.951]                 }
[11:01:31.951]                 {
[11:01:31.951]                   {
[11:01:31.951]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:31.951]                     NULL
[11:01:31.951]                   }
[11:01:31.951]                   options(future.plan = NULL)
[11:01:31.951]                   if (is.na(NA_character_)) 
[11:01:31.951]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:31.951]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:31.951]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:31.951]                     .init = FALSE)
[11:01:31.951]                 }
[11:01:31.951]             }
[11:01:31.951]         }
[11:01:31.951]     })
[11:01:31.951]     if (TRUE) {
[11:01:31.951]         base::sink(type = "output", split = FALSE)
[11:01:31.951]         if (TRUE) {
[11:01:31.951]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:31.951]         }
[11:01:31.951]         else {
[11:01:31.951]             ...future.result["stdout"] <- base::list(NULL)
[11:01:31.951]         }
[11:01:31.951]         base::close(...future.stdout)
[11:01:31.951]         ...future.stdout <- NULL
[11:01:31.951]     }
[11:01:31.951]     ...future.result$conditions <- ...future.conditions
[11:01:31.951]     ...future.result$finished <- base::Sys.time()
[11:01:31.951]     ...future.result
[11:01:31.951] }
[11:01:31.954] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:31.965] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.965] - Validating connection of MultisessionFuture
[11:01:31.965] - received message: FutureResult
[11:01:31.965] - Received FutureResult
[11:01:31.966] - Erased future from FutureRegistry
[11:01:31.966] result() for ClusterFuture ...
[11:01:31.966] - result already collected: FutureResult
[11:01:31.966] result() for ClusterFuture ... done
[11:01:31.966] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:31.966] result() for ClusterFuture ...
[11:01:31.966] - result already collected: FutureResult
[11:01:31.966] result() for ClusterFuture ... done
[11:01:31.966] result() for ClusterFuture ...
[11:01:31.966] - result already collected: FutureResult
[11:01:31.966] result() for ClusterFuture ... done
[11:01:31.967] MultisessionFuture started
[11:01:31.967] - Launch lazy future ... done
[11:01:31.968] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a9c6256490> 
<environment: 0x55a9c80ba800> 
[11:01:31.975] receiveMessageFromWorker() for ClusterFuture ...
[11:01:31.975] - Validating connection of MultisessionFuture
[11:01:31.975] - received message: FutureResult
[11:01:31.976] - Received FutureResult
[11:01:31.976] - Erased future from FutureRegistry
[11:01:31.976] result() for ClusterFuture ...
[11:01:31.976] - result already collected: FutureResult
[11:01:31.976] result() for ClusterFuture ... done
[11:01:31.976] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:31.988] resolve() on environment ...
[11:01:31.988]  recursive: 0
[11:01:31.988]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:31.988] signalConditionsASAP(numeric, pos=1) ...
[11:01:31.989] - nx: 4
[11:01:31.989] - relay: TRUE
[11:01:31.989] - stdout: TRUE
[11:01:31.989] - signal: TRUE
[11:01:31.989] - resignal: FALSE
[11:01:31.989] - force: TRUE
[11:01:31.989] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.989] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.989]  - until=2
[11:01:31.989]  - relaying element #2
[11:01:31.989] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.989] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.989] signalConditionsASAP(NULL, pos=1) ... done
[11:01:31.990]  length: 3 (resolved future 1)
[11:01:31.990] Future #2
[11:01:31.990] result() for ClusterFuture ...
[11:01:31.990] - result already collected: FutureResult
[11:01:31.990] result() for ClusterFuture ... done
[11:01:31.990] result() for ClusterFuture ...
[11:01:31.990] - result already collected: FutureResult
[11:01:31.990] result() for ClusterFuture ... done
[11:01:31.990] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:31.990] - nx: 4
[11:01:31.990] - relay: TRUE
[11:01:31.990] - stdout: TRUE
[11:01:31.991] - signal: TRUE
[11:01:31.991] - resignal: FALSE
[11:01:31.991] - force: TRUE
[11:01:31.991] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:31.991] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:31.991]  - until=2
[11:01:31.991]  - relaying element #2
[11:01:31.991] result() for ClusterFuture ...
[11:01:31.991] - result already collected: FutureResult
[11:01:31.991] result() for ClusterFuture ... done
[11:01:31.991] result() for ClusterFuture ...
[11:01:31.991] - result already collected: FutureResult
[11:01:31.991] result() for ClusterFuture ... done
[11:01:31.992] result() for ClusterFuture ...
[11:01:31.992] - result already collected: FutureResult
[11:01:31.992] result() for ClusterFuture ... done
[11:01:31.992] result() for ClusterFuture ...
[11:01:31.992] - result already collected: FutureResult
[11:01:31.992] result() for ClusterFuture ... done
[11:01:31.992] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.992] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.992] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:31.992]  length: 2 (resolved future 2)
[11:01:31.992] Future #3
[11:01:31.993] result() for ClusterFuture ...
[11:01:31.993] - result already collected: FutureResult
[11:01:31.993] result() for ClusterFuture ... done
[11:01:31.993] result() for ClusterFuture ...
[11:01:31.993] - result already collected: FutureResult
[11:01:31.993] result() for ClusterFuture ... done
[11:01:31.993] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:31.993] - nx: 4
[11:01:31.993] - relay: TRUE
[11:01:31.993] - stdout: TRUE
[11:01:31.993] - signal: TRUE
[11:01:31.993] - resignal: FALSE
[11:01:31.993] - force: TRUE
[11:01:31.994] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:31.994] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:31.994]  - until=3
[11:01:31.994]  - relaying element #3
[11:01:31.994] result() for ClusterFuture ...
[11:01:31.994] - result already collected: FutureResult
[11:01:31.994] result() for ClusterFuture ... done
[11:01:31.994] result() for ClusterFuture ...
[11:01:31.994] - result already collected: FutureResult
[11:01:31.994] result() for ClusterFuture ... done
[11:01:31.994] result() for ClusterFuture ...
[11:01:31.994] - result already collected: FutureResult
[11:01:31.995] result() for ClusterFuture ... done
[11:01:31.995] result() for ClusterFuture ...
[11:01:31.995] - result already collected: FutureResult
[11:01:31.995] result() for ClusterFuture ... done
[11:01:31.995] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:31.995] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:31.995] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:31.995]  length: 1 (resolved future 3)
[11:01:32.016] receiveMessageFromWorker() for ClusterFuture ...
[11:01:32.016] - Validating connection of MultisessionFuture
[11:01:32.016] - received message: FutureResult
[11:01:32.017] - Received FutureResult
[11:01:32.017] - Erased future from FutureRegistry
[11:01:32.017] result() for ClusterFuture ...
[11:01:32.017] - result already collected: FutureResult
[11:01:32.017] result() for ClusterFuture ... done
[11:01:32.017] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:32.017] Future #4
[11:01:32.017] result() for ClusterFuture ...
[11:01:32.017] - result already collected: FutureResult
[11:01:32.017] result() for ClusterFuture ... done
[11:01:32.017] result() for ClusterFuture ...
[11:01:32.018] - result already collected: FutureResult
[11:01:32.018] result() for ClusterFuture ... done
[11:01:32.018] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:32.018] - nx: 4
[11:01:32.018] - relay: TRUE
[11:01:32.018] - stdout: TRUE
[11:01:32.018] - signal: TRUE
[11:01:32.018] - resignal: FALSE
[11:01:32.018] - force: TRUE
[11:01:32.018] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:32.018] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:32.018]  - until=4
[11:01:32.019]  - relaying element #4
[11:01:32.019] result() for ClusterFuture ...
[11:01:32.019] - result already collected: FutureResult
[11:01:32.019] result() for ClusterFuture ... done
[11:01:32.019] result() for ClusterFuture ...
[11:01:32.019] - result already collected: FutureResult
[11:01:32.019] result() for ClusterFuture ... done
[11:01:32.019] result() for ClusterFuture ...
[11:01:32.019] - result already collected: FutureResult
[11:01:32.019] result() for ClusterFuture ... done
[11:01:32.019] result() for ClusterFuture ...
[11:01:32.019] - result already collected: FutureResult
[11:01:32.020] result() for ClusterFuture ... done
[11:01:32.020] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:32.020] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:32.020] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:32.020]  length: 0 (resolved future 4)
[11:01:32.020] Relaying remaining futures
[11:01:32.020] signalConditionsASAP(NULL, pos=0) ...
[11:01:32.020] - nx: 4
[11:01:32.020] - relay: TRUE
[11:01:32.020] - stdout: TRUE
[11:01:32.020] - signal: TRUE
[11:01:32.021] - resignal: FALSE
[11:01:32.021] - force: TRUE
[11:01:32.021] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:32.021] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:32.021] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:32.021] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:32.021] signalConditionsASAP(NULL, pos=0) ... done
[11:01:32.021] resolve() on environment ... DONE
[11:01:32.021] result() for ClusterFuture ...
[11:01:32.021] - result already collected: FutureResult
[11:01:32.021] result() for ClusterFuture ... done
[11:01:32.021] result() for ClusterFuture ...
[11:01:32.022] - result already collected: FutureResult
[11:01:32.022] result() for ClusterFuture ... done
[11:01:32.022] result() for ClusterFuture ...
[11:01:32.022] - result already collected: FutureResult
[11:01:32.022] result() for ClusterFuture ... done
[11:01:32.022] result() for ClusterFuture ...
[11:01:32.022] - result already collected: FutureResult
[11:01:32.022] result() for ClusterFuture ... done
[11:01:32.022] result() for ClusterFuture ...
[11:01:32.022] - result already collected: FutureResult
[11:01:32.022] result() for ClusterFuture ... done
[11:01:32.022] result() for ClusterFuture ...
[11:01:32.023] - result already collected: FutureResult
[11:01:32.023] result() for ClusterFuture ... done
<environment: 0x55a9c82046b8> 
Dimensions: c(2, 1, 3, 1)
[11:01:32.023] getGlobalsAndPackages() ...
[11:01:32.023] Searching for globals...
[11:01:32.023] 
[11:01:32.023] Searching for globals ... DONE
[11:01:32.024] - globals: [0] <none>
[11:01:32.024] getGlobalsAndPackages() ... DONE
[11:01:32.024] run() for ‘Future’ ...
[11:01:32.024] - state: ‘created’
[11:01:32.024] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.038] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.038] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:32.038]   - Field: ‘node’
[11:01:32.038]   - Field: ‘label’
[11:01:32.038]   - Field: ‘local’
[11:01:32.038]   - Field: ‘owner’
[11:01:32.038]   - Field: ‘envir’
[11:01:32.038]   - Field: ‘workers’
[11:01:32.038]   - Field: ‘packages’
[11:01:32.038]   - Field: ‘gc’
[11:01:32.038]   - Field: ‘conditions’
[11:01:32.039]   - Field: ‘persistent’
[11:01:32.039]   - Field: ‘expr’
[11:01:32.039]   - Field: ‘uuid’
[11:01:32.039]   - Field: ‘seed’
[11:01:32.039]   - Field: ‘version’
[11:01:32.039]   - Field: ‘result’
[11:01:32.039]   - Field: ‘asynchronous’
[11:01:32.039]   - Field: ‘calls’
[11:01:32.039]   - Field: ‘globals’
[11:01:32.039]   - Field: ‘stdout’
[11:01:32.039]   - Field: ‘earlySignal’
[11:01:32.039]   - Field: ‘lazy’
[11:01:32.040]   - Field: ‘state’
[11:01:32.040] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:32.040] - Launch lazy future ...
[11:01:32.040] Packages needed by the future expression (n = 0): <none>
[11:01:32.042] Packages needed by future strategies (n = 0): <none>
[11:01:32.043] {
[11:01:32.043]     {
[11:01:32.043]         {
[11:01:32.043]             ...future.startTime <- base::Sys.time()
[11:01:32.043]             {
[11:01:32.043]                 {
[11:01:32.043]                   {
[11:01:32.043]                     {
[11:01:32.043]                       base::local({
[11:01:32.043]                         has_future <- base::requireNamespace("future", 
[11:01:32.043]                           quietly = TRUE)
[11:01:32.043]                         if (has_future) {
[11:01:32.043]                           ns <- base::getNamespace("future")
[11:01:32.043]                           version <- ns[[".package"]][["version"]]
[11:01:32.043]                           if (is.null(version)) 
[11:01:32.043]                             version <- utils::packageVersion("future")
[11:01:32.043]                         }
[11:01:32.043]                         else {
[11:01:32.043]                           version <- NULL
[11:01:32.043]                         }
[11:01:32.043]                         if (!has_future || version < "1.8.0") {
[11:01:32.043]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.043]                             "", base::R.version$version.string), 
[11:01:32.043]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.043]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.043]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.043]                               "release", "version")], collapse = " "), 
[11:01:32.043]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.043]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.043]                             info)
[11:01:32.043]                           info <- base::paste(info, collapse = "; ")
[11:01:32.043]                           if (!has_future) {
[11:01:32.043]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.043]                               info)
[11:01:32.043]                           }
[11:01:32.043]                           else {
[11:01:32.043]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.043]                               info, version)
[11:01:32.043]                           }
[11:01:32.043]                           base::stop(msg)
[11:01:32.043]                         }
[11:01:32.043]                       })
[11:01:32.043]                     }
[11:01:32.043]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.043]                     base::options(mc.cores = 1L)
[11:01:32.043]                   }
[11:01:32.043]                   ...future.strategy.old <- future::plan("list")
[11:01:32.043]                   options(future.plan = NULL)
[11:01:32.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.043]                 }
[11:01:32.043]                 ...future.workdir <- getwd()
[11:01:32.043]             }
[11:01:32.043]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.043]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.043]         }
[11:01:32.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.043]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.043]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.043]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.043]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.043]             base::names(...future.oldOptions))
[11:01:32.043]     }
[11:01:32.043]     if (FALSE) {
[11:01:32.043]     }
[11:01:32.043]     else {
[11:01:32.043]         if (TRUE) {
[11:01:32.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.043]                 open = "w")
[11:01:32.043]         }
[11:01:32.043]         else {
[11:01:32.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.043]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.043]         }
[11:01:32.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.043]             base::sink(type = "output", split = FALSE)
[11:01:32.043]             base::close(...future.stdout)
[11:01:32.043]         }, add = TRUE)
[11:01:32.043]     }
[11:01:32.043]     ...future.frame <- base::sys.nframe()
[11:01:32.043]     ...future.conditions <- base::list()
[11:01:32.043]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.043]     if (FALSE) {
[11:01:32.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.043]     }
[11:01:32.043]     ...future.result <- base::tryCatch({
[11:01:32.043]         base::withCallingHandlers({
[11:01:32.043]             ...future.value <- base::withVisible(base::local({
[11:01:32.043]                 ...future.makeSendCondition <- base::local({
[11:01:32.043]                   sendCondition <- NULL
[11:01:32.043]                   function(frame = 1L) {
[11:01:32.043]                     if (is.function(sendCondition)) 
[11:01:32.043]                       return(sendCondition)
[11:01:32.043]                     ns <- getNamespace("parallel")
[11:01:32.043]                     if (exists("sendData", mode = "function", 
[11:01:32.043]                       envir = ns)) {
[11:01:32.043]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:32.043]                         envir = ns)
[11:01:32.043]                       envir <- sys.frame(frame)
[11:01:32.043]                       master <- NULL
[11:01:32.043]                       while (!identical(envir, .GlobalEnv) && 
[11:01:32.043]                         !identical(envir, emptyenv())) {
[11:01:32.043]                         if (exists("master", mode = "list", envir = envir, 
[11:01:32.043]                           inherits = FALSE)) {
[11:01:32.043]                           master <- get("master", mode = "list", 
[11:01:32.043]                             envir = envir, inherits = FALSE)
[11:01:32.043]                           if (inherits(master, c("SOCKnode", 
[11:01:32.043]                             "SOCK0node"))) {
[11:01:32.043]                             sendCondition <<- function(cond) {
[11:01:32.043]                               data <- list(type = "VALUE", value = cond, 
[11:01:32.043]                                 success = TRUE)
[11:01:32.043]                               parallel_sendData(master, data)
[11:01:32.043]                             }
[11:01:32.043]                             return(sendCondition)
[11:01:32.043]                           }
[11:01:32.043]                         }
[11:01:32.043]                         frame <- frame + 1L
[11:01:32.043]                         envir <- sys.frame(frame)
[11:01:32.043]                       }
[11:01:32.043]                     }
[11:01:32.043]                     sendCondition <<- function(cond) NULL
[11:01:32.043]                   }
[11:01:32.043]                 })
[11:01:32.043]                 withCallingHandlers({
[11:01:32.043]                   2
[11:01:32.043]                 }, immediateCondition = function(cond) {
[11:01:32.043]                   sendCondition <- ...future.makeSendCondition()
[11:01:32.043]                   sendCondition(cond)
[11:01:32.043]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.043]                   {
[11:01:32.043]                     inherits <- base::inherits
[11:01:32.043]                     invokeRestart <- base::invokeRestart
[11:01:32.043]                     is.null <- base::is.null
[11:01:32.043]                     muffled <- FALSE
[11:01:32.043]                     if (inherits(cond, "message")) {
[11:01:32.043]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.043]                       if (muffled) 
[11:01:32.043]                         invokeRestart("muffleMessage")
[11:01:32.043]                     }
[11:01:32.043]                     else if (inherits(cond, "warning")) {
[11:01:32.043]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.043]                       if (muffled) 
[11:01:32.043]                         invokeRestart("muffleWarning")
[11:01:32.043]                     }
[11:01:32.043]                     else if (inherits(cond, "condition")) {
[11:01:32.043]                       if (!is.null(pattern)) {
[11:01:32.043]                         computeRestarts <- base::computeRestarts
[11:01:32.043]                         grepl <- base::grepl
[11:01:32.043]                         restarts <- computeRestarts(cond)
[11:01:32.043]                         for (restart in restarts) {
[11:01:32.043]                           name <- restart$name
[11:01:32.043]                           if (is.null(name)) 
[11:01:32.043]                             next
[11:01:32.043]                           if (!grepl(pattern, name)) 
[11:01:32.043]                             next
[11:01:32.043]                           invokeRestart(restart)
[11:01:32.043]                           muffled <- TRUE
[11:01:32.043]                           break
[11:01:32.043]                         }
[11:01:32.043]                       }
[11:01:32.043]                     }
[11:01:32.043]                     invisible(muffled)
[11:01:32.043]                   }
[11:01:32.043]                   muffleCondition(cond)
[11:01:32.043]                 })
[11:01:32.043]             }))
[11:01:32.043]             future::FutureResult(value = ...future.value$value, 
[11:01:32.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.043]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.043]                     ...future.globalenv.names))
[11:01:32.043]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.043]         }, condition = base::local({
[11:01:32.043]             c <- base::c
[11:01:32.043]             inherits <- base::inherits
[11:01:32.043]             invokeRestart <- base::invokeRestart
[11:01:32.043]             length <- base::length
[11:01:32.043]             list <- base::list
[11:01:32.043]             seq.int <- base::seq.int
[11:01:32.043]             signalCondition <- base::signalCondition
[11:01:32.043]             sys.calls <- base::sys.calls
[11:01:32.043]             `[[` <- base::`[[`
[11:01:32.043]             `+` <- base::`+`
[11:01:32.043]             `<<-` <- base::`<<-`
[11:01:32.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.043]                   3L)]
[11:01:32.043]             }
[11:01:32.043]             function(cond) {
[11:01:32.043]                 is_error <- inherits(cond, "error")
[11:01:32.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.043]                   NULL)
[11:01:32.043]                 if (is_error) {
[11:01:32.043]                   sessionInformation <- function() {
[11:01:32.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.043]                       search = base::search(), system = base::Sys.info())
[11:01:32.043]                   }
[11:01:32.043]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.043]                     cond$call), session = sessionInformation(), 
[11:01:32.043]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.043]                   signalCondition(cond)
[11:01:32.043]                 }
[11:01:32.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.043]                 "immediateCondition"))) {
[11:01:32.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.043]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.043]                   if (TRUE && !signal) {
[11:01:32.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.043]                     {
[11:01:32.043]                       inherits <- base::inherits
[11:01:32.043]                       invokeRestart <- base::invokeRestart
[11:01:32.043]                       is.null <- base::is.null
[11:01:32.043]                       muffled <- FALSE
[11:01:32.043]                       if (inherits(cond, "message")) {
[11:01:32.043]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.043]                         if (muffled) 
[11:01:32.043]                           invokeRestart("muffleMessage")
[11:01:32.043]                       }
[11:01:32.043]                       else if (inherits(cond, "warning")) {
[11:01:32.043]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.043]                         if (muffled) 
[11:01:32.043]                           invokeRestart("muffleWarning")
[11:01:32.043]                       }
[11:01:32.043]                       else if (inherits(cond, "condition")) {
[11:01:32.043]                         if (!is.null(pattern)) {
[11:01:32.043]                           computeRestarts <- base::computeRestarts
[11:01:32.043]                           grepl <- base::grepl
[11:01:32.043]                           restarts <- computeRestarts(cond)
[11:01:32.043]                           for (restart in restarts) {
[11:01:32.043]                             name <- restart$name
[11:01:32.043]                             if (is.null(name)) 
[11:01:32.043]                               next
[11:01:32.043]                             if (!grepl(pattern, name)) 
[11:01:32.043]                               next
[11:01:32.043]                             invokeRestart(restart)
[11:01:32.043]                             muffled <- TRUE
[11:01:32.043]                             break
[11:01:32.043]                           }
[11:01:32.043]                         }
[11:01:32.043]                       }
[11:01:32.043]                       invisible(muffled)
[11:01:32.043]                     }
[11:01:32.043]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.043]                   }
[11:01:32.043]                 }
[11:01:32.043]                 else {
[11:01:32.043]                   if (TRUE) {
[11:01:32.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.043]                     {
[11:01:32.043]                       inherits <- base::inherits
[11:01:32.043]                       invokeRestart <- base::invokeRestart
[11:01:32.043]                       is.null <- base::is.null
[11:01:32.043]                       muffled <- FALSE
[11:01:32.043]                       if (inherits(cond, "message")) {
[11:01:32.043]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.043]                         if (muffled) 
[11:01:32.043]                           invokeRestart("muffleMessage")
[11:01:32.043]                       }
[11:01:32.043]                       else if (inherits(cond, "warning")) {
[11:01:32.043]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.043]                         if (muffled) 
[11:01:32.043]                           invokeRestart("muffleWarning")
[11:01:32.043]                       }
[11:01:32.043]                       else if (inherits(cond, "condition")) {
[11:01:32.043]                         if (!is.null(pattern)) {
[11:01:32.043]                           computeRestarts <- base::computeRestarts
[11:01:32.043]                           grepl <- base::grepl
[11:01:32.043]                           restarts <- computeRestarts(cond)
[11:01:32.043]                           for (restart in restarts) {
[11:01:32.043]                             name <- restart$name
[11:01:32.043]                             if (is.null(name)) 
[11:01:32.043]                               next
[11:01:32.043]                             if (!grepl(pattern, name)) 
[11:01:32.043]                               next
[11:01:32.043]                             invokeRestart(restart)
[11:01:32.043]                             muffled <- TRUE
[11:01:32.043]                             break
[11:01:32.043]                           }
[11:01:32.043]                         }
[11:01:32.043]                       }
[11:01:32.043]                       invisible(muffled)
[11:01:32.043]                     }
[11:01:32.043]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.043]                   }
[11:01:32.043]                 }
[11:01:32.043]             }
[11:01:32.043]         }))
[11:01:32.043]     }, error = function(ex) {
[11:01:32.043]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.043]                 ...future.rng), started = ...future.startTime, 
[11:01:32.043]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.043]             version = "1.8"), class = "FutureResult")
[11:01:32.043]     }, finally = {
[11:01:32.043]         if (!identical(...future.workdir, getwd())) 
[11:01:32.043]             setwd(...future.workdir)
[11:01:32.043]         {
[11:01:32.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.043]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.043]             }
[11:01:32.043]             base::options(...future.oldOptions)
[11:01:32.043]             if (.Platform$OS.type == "windows") {
[11:01:32.043]                 old_names <- names(...future.oldEnvVars)
[11:01:32.043]                 envs <- base::Sys.getenv()
[11:01:32.043]                 names <- names(envs)
[11:01:32.043]                 common <- intersect(names, old_names)
[11:01:32.043]                 added <- setdiff(names, old_names)
[11:01:32.043]                 removed <- setdiff(old_names, names)
[11:01:32.043]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.043]                   envs[common]]
[11:01:32.043]                 NAMES <- toupper(changed)
[11:01:32.043]                 args <- list()
[11:01:32.043]                 for (kk in seq_along(NAMES)) {
[11:01:32.043]                   name <- changed[[kk]]
[11:01:32.043]                   NAME <- NAMES[[kk]]
[11:01:32.043]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.043]                     next
[11:01:32.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.043]                 }
[11:01:32.043]                 NAMES <- toupper(added)
[11:01:32.043]                 for (kk in seq_along(NAMES)) {
[11:01:32.043]                   name <- added[[kk]]
[11:01:32.043]                   NAME <- NAMES[[kk]]
[11:01:32.043]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.043]                     next
[11:01:32.043]                   args[[name]] <- ""
[11:01:32.043]                 }
[11:01:32.043]                 NAMES <- toupper(removed)
[11:01:32.043]                 for (kk in seq_along(NAMES)) {
[11:01:32.043]                   name <- removed[[kk]]
[11:01:32.043]                   NAME <- NAMES[[kk]]
[11:01:32.043]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.043]                     next
[11:01:32.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.043]                 }
[11:01:32.043]                 if (length(args) > 0) 
[11:01:32.043]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.043]             }
[11:01:32.043]             else {
[11:01:32.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.043]             }
[11:01:32.043]             {
[11:01:32.043]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.043]                   0L) {
[11:01:32.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.043]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.043]                   base::options(opts)
[11:01:32.043]                 }
[11:01:32.043]                 {
[11:01:32.043]                   {
[11:01:32.043]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.043]                     NULL
[11:01:32.043]                   }
[11:01:32.043]                   options(future.plan = NULL)
[11:01:32.043]                   if (is.na(NA_character_)) 
[11:01:32.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.043]                     .init = FALSE)
[11:01:32.043]                 }
[11:01:32.043]             }
[11:01:32.043]         }
[11:01:32.043]     })
[11:01:32.043]     if (TRUE) {
[11:01:32.043]         base::sink(type = "output", split = FALSE)
[11:01:32.043]         if (TRUE) {
[11:01:32.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.043]         }
[11:01:32.043]         else {
[11:01:32.043]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.043]         }
[11:01:32.043]         base::close(...future.stdout)
[11:01:32.043]         ...future.stdout <- NULL
[11:01:32.043]     }
[11:01:32.043]     ...future.result$conditions <- ...future.conditions
[11:01:32.043]     ...future.result$finished <- base::Sys.time()
[11:01:32.043]     ...future.result
[11:01:32.043] }
[11:01:32.046] MultisessionFuture started
[11:01:32.046] - Launch lazy future ... done
[11:01:32.046] run() for ‘MultisessionFuture’ ... done
[11:01:32.046] getGlobalsAndPackages() ...
[11:01:32.046] Searching for globals...
[11:01:32.046] 
[11:01:32.046] Searching for globals ... DONE
[11:01:32.046] - globals: [0] <none>
[11:01:32.047] getGlobalsAndPackages() ... DONE
[11:01:32.047] run() for ‘Future’ ...
[11:01:32.047] - state: ‘created’
[11:01:32.047] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.061] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.061] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:32.061]   - Field: ‘node’
[11:01:32.061]   - Field: ‘label’
[11:01:32.061]   - Field: ‘local’
[11:01:32.061]   - Field: ‘owner’
[11:01:32.061]   - Field: ‘envir’
[11:01:32.061]   - Field: ‘workers’
[11:01:32.061]   - Field: ‘packages’
[11:01:32.062]   - Field: ‘gc’
[11:01:32.062]   - Field: ‘conditions’
[11:01:32.062]   - Field: ‘persistent’
[11:01:32.062]   - Field: ‘expr’
[11:01:32.062]   - Field: ‘uuid’
[11:01:32.062]   - Field: ‘seed’
[11:01:32.062]   - Field: ‘version’
[11:01:32.062]   - Field: ‘result’
[11:01:32.062]   - Field: ‘asynchronous’
[11:01:32.062]   - Field: ‘calls’
[11:01:32.062]   - Field: ‘globals’
[11:01:32.062]   - Field: ‘stdout’
[11:01:32.063]   - Field: ‘earlySignal’
[11:01:32.063]   - Field: ‘lazy’
[11:01:32.063]   - Field: ‘state’
[11:01:32.063] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:32.063] - Launch lazy future ...
[11:01:32.063] Packages needed by the future expression (n = 0): <none>
[11:01:32.063] Packages needed by future strategies (n = 0): <none>
[11:01:32.064] {
[11:01:32.064]     {
[11:01:32.064]         {
[11:01:32.064]             ...future.startTime <- base::Sys.time()
[11:01:32.064]             {
[11:01:32.064]                 {
[11:01:32.064]                   {
[11:01:32.064]                     {
[11:01:32.064]                       base::local({
[11:01:32.064]                         has_future <- base::requireNamespace("future", 
[11:01:32.064]                           quietly = TRUE)
[11:01:32.064]                         if (has_future) {
[11:01:32.064]                           ns <- base::getNamespace("future")
[11:01:32.064]                           version <- ns[[".package"]][["version"]]
[11:01:32.064]                           if (is.null(version)) 
[11:01:32.064]                             version <- utils::packageVersion("future")
[11:01:32.064]                         }
[11:01:32.064]                         else {
[11:01:32.064]                           version <- NULL
[11:01:32.064]                         }
[11:01:32.064]                         if (!has_future || version < "1.8.0") {
[11:01:32.064]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.064]                             "", base::R.version$version.string), 
[11:01:32.064]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.064]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.064]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.064]                               "release", "version")], collapse = " "), 
[11:01:32.064]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.064]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.064]                             info)
[11:01:32.064]                           info <- base::paste(info, collapse = "; ")
[11:01:32.064]                           if (!has_future) {
[11:01:32.064]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.064]                               info)
[11:01:32.064]                           }
[11:01:32.064]                           else {
[11:01:32.064]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.064]                               info, version)
[11:01:32.064]                           }
[11:01:32.064]                           base::stop(msg)
[11:01:32.064]                         }
[11:01:32.064]                       })
[11:01:32.064]                     }
[11:01:32.064]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.064]                     base::options(mc.cores = 1L)
[11:01:32.064]                   }
[11:01:32.064]                   ...future.strategy.old <- future::plan("list")
[11:01:32.064]                   options(future.plan = NULL)
[11:01:32.064]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.064]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.064]                 }
[11:01:32.064]                 ...future.workdir <- getwd()
[11:01:32.064]             }
[11:01:32.064]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.064]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.064]         }
[11:01:32.064]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.064]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.064]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.064]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.064]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.064]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.064]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.064]             base::names(...future.oldOptions))
[11:01:32.064]     }
[11:01:32.064]     if (FALSE) {
[11:01:32.064]     }
[11:01:32.064]     else {
[11:01:32.064]         if (TRUE) {
[11:01:32.064]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.064]                 open = "w")
[11:01:32.064]         }
[11:01:32.064]         else {
[11:01:32.064]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.064]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.064]         }
[11:01:32.064]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.064]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.064]             base::sink(type = "output", split = FALSE)
[11:01:32.064]             base::close(...future.stdout)
[11:01:32.064]         }, add = TRUE)
[11:01:32.064]     }
[11:01:32.064]     ...future.frame <- base::sys.nframe()
[11:01:32.064]     ...future.conditions <- base::list()
[11:01:32.064]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.064]     if (FALSE) {
[11:01:32.064]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.064]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.064]     }
[11:01:32.064]     ...future.result <- base::tryCatch({
[11:01:32.064]         base::withCallingHandlers({
[11:01:32.064]             ...future.value <- base::withVisible(base::local({
[11:01:32.064]                 ...future.makeSendCondition <- base::local({
[11:01:32.064]                   sendCondition <- NULL
[11:01:32.064]                   function(frame = 1L) {
[11:01:32.064]                     if (is.function(sendCondition)) 
[11:01:32.064]                       return(sendCondition)
[11:01:32.064]                     ns <- getNamespace("parallel")
[11:01:32.064]                     if (exists("sendData", mode = "function", 
[11:01:32.064]                       envir = ns)) {
[11:01:32.064]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:32.064]                         envir = ns)
[11:01:32.064]                       envir <- sys.frame(frame)
[11:01:32.064]                       master <- NULL
[11:01:32.064]                       while (!identical(envir, .GlobalEnv) && 
[11:01:32.064]                         !identical(envir, emptyenv())) {
[11:01:32.064]                         if (exists("master", mode = "list", envir = envir, 
[11:01:32.064]                           inherits = FALSE)) {
[11:01:32.064]                           master <- get("master", mode = "list", 
[11:01:32.064]                             envir = envir, inherits = FALSE)
[11:01:32.064]                           if (inherits(master, c("SOCKnode", 
[11:01:32.064]                             "SOCK0node"))) {
[11:01:32.064]                             sendCondition <<- function(cond) {
[11:01:32.064]                               data <- list(type = "VALUE", value = cond, 
[11:01:32.064]                                 success = TRUE)
[11:01:32.064]                               parallel_sendData(master, data)
[11:01:32.064]                             }
[11:01:32.064]                             return(sendCondition)
[11:01:32.064]                           }
[11:01:32.064]                         }
[11:01:32.064]                         frame <- frame + 1L
[11:01:32.064]                         envir <- sys.frame(frame)
[11:01:32.064]                       }
[11:01:32.064]                     }
[11:01:32.064]                     sendCondition <<- function(cond) NULL
[11:01:32.064]                   }
[11:01:32.064]                 })
[11:01:32.064]                 withCallingHandlers({
[11:01:32.064]                   NULL
[11:01:32.064]                 }, immediateCondition = function(cond) {
[11:01:32.064]                   sendCondition <- ...future.makeSendCondition()
[11:01:32.064]                   sendCondition(cond)
[11:01:32.064]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.064]                   {
[11:01:32.064]                     inherits <- base::inherits
[11:01:32.064]                     invokeRestart <- base::invokeRestart
[11:01:32.064]                     is.null <- base::is.null
[11:01:32.064]                     muffled <- FALSE
[11:01:32.064]                     if (inherits(cond, "message")) {
[11:01:32.064]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.064]                       if (muffled) 
[11:01:32.064]                         invokeRestart("muffleMessage")
[11:01:32.064]                     }
[11:01:32.064]                     else if (inherits(cond, "warning")) {
[11:01:32.064]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.064]                       if (muffled) 
[11:01:32.064]                         invokeRestart("muffleWarning")
[11:01:32.064]                     }
[11:01:32.064]                     else if (inherits(cond, "condition")) {
[11:01:32.064]                       if (!is.null(pattern)) {
[11:01:32.064]                         computeRestarts <- base::computeRestarts
[11:01:32.064]                         grepl <- base::grepl
[11:01:32.064]                         restarts <- computeRestarts(cond)
[11:01:32.064]                         for (restart in restarts) {
[11:01:32.064]                           name <- restart$name
[11:01:32.064]                           if (is.null(name)) 
[11:01:32.064]                             next
[11:01:32.064]                           if (!grepl(pattern, name)) 
[11:01:32.064]                             next
[11:01:32.064]                           invokeRestart(restart)
[11:01:32.064]                           muffled <- TRUE
[11:01:32.064]                           break
[11:01:32.064]                         }
[11:01:32.064]                       }
[11:01:32.064]                     }
[11:01:32.064]                     invisible(muffled)
[11:01:32.064]                   }
[11:01:32.064]                   muffleCondition(cond)
[11:01:32.064]                 })
[11:01:32.064]             }))
[11:01:32.064]             future::FutureResult(value = ...future.value$value, 
[11:01:32.064]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.064]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.064]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.064]                     ...future.globalenv.names))
[11:01:32.064]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.064]         }, condition = base::local({
[11:01:32.064]             c <- base::c
[11:01:32.064]             inherits <- base::inherits
[11:01:32.064]             invokeRestart <- base::invokeRestart
[11:01:32.064]             length <- base::length
[11:01:32.064]             list <- base::list
[11:01:32.064]             seq.int <- base::seq.int
[11:01:32.064]             signalCondition <- base::signalCondition
[11:01:32.064]             sys.calls <- base::sys.calls
[11:01:32.064]             `[[` <- base::`[[`
[11:01:32.064]             `+` <- base::`+`
[11:01:32.064]             `<<-` <- base::`<<-`
[11:01:32.064]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.064]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.064]                   3L)]
[11:01:32.064]             }
[11:01:32.064]             function(cond) {
[11:01:32.064]                 is_error <- inherits(cond, "error")
[11:01:32.064]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.064]                   NULL)
[11:01:32.064]                 if (is_error) {
[11:01:32.064]                   sessionInformation <- function() {
[11:01:32.064]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.064]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.064]                       search = base::search(), system = base::Sys.info())
[11:01:32.064]                   }
[11:01:32.064]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.064]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.064]                     cond$call), session = sessionInformation(), 
[11:01:32.064]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.064]                   signalCondition(cond)
[11:01:32.064]                 }
[11:01:32.064]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.064]                 "immediateCondition"))) {
[11:01:32.064]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.064]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.064]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.064]                   if (TRUE && !signal) {
[11:01:32.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.064]                     {
[11:01:32.064]                       inherits <- base::inherits
[11:01:32.064]                       invokeRestart <- base::invokeRestart
[11:01:32.064]                       is.null <- base::is.null
[11:01:32.064]                       muffled <- FALSE
[11:01:32.064]                       if (inherits(cond, "message")) {
[11:01:32.064]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.064]                         if (muffled) 
[11:01:32.064]                           invokeRestart("muffleMessage")
[11:01:32.064]                       }
[11:01:32.064]                       else if (inherits(cond, "warning")) {
[11:01:32.064]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.064]                         if (muffled) 
[11:01:32.064]                           invokeRestart("muffleWarning")
[11:01:32.064]                       }
[11:01:32.064]                       else if (inherits(cond, "condition")) {
[11:01:32.064]                         if (!is.null(pattern)) {
[11:01:32.064]                           computeRestarts <- base::computeRestarts
[11:01:32.064]                           grepl <- base::grepl
[11:01:32.064]                           restarts <- computeRestarts(cond)
[11:01:32.064]                           for (restart in restarts) {
[11:01:32.064]                             name <- restart$name
[11:01:32.064]                             if (is.null(name)) 
[11:01:32.064]                               next
[11:01:32.064]                             if (!grepl(pattern, name)) 
[11:01:32.064]                               next
[11:01:32.064]                             invokeRestart(restart)
[11:01:32.064]                             muffled <- TRUE
[11:01:32.064]                             break
[11:01:32.064]                           }
[11:01:32.064]                         }
[11:01:32.064]                       }
[11:01:32.064]                       invisible(muffled)
[11:01:32.064]                     }
[11:01:32.064]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.064]                   }
[11:01:32.064]                 }
[11:01:32.064]                 else {
[11:01:32.064]                   if (TRUE) {
[11:01:32.064]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.064]                     {
[11:01:32.064]                       inherits <- base::inherits
[11:01:32.064]                       invokeRestart <- base::invokeRestart
[11:01:32.064]                       is.null <- base::is.null
[11:01:32.064]                       muffled <- FALSE
[11:01:32.064]                       if (inherits(cond, "message")) {
[11:01:32.064]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.064]                         if (muffled) 
[11:01:32.064]                           invokeRestart("muffleMessage")
[11:01:32.064]                       }
[11:01:32.064]                       else if (inherits(cond, "warning")) {
[11:01:32.064]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.064]                         if (muffled) 
[11:01:32.064]                           invokeRestart("muffleWarning")
[11:01:32.064]                       }
[11:01:32.064]                       else if (inherits(cond, "condition")) {
[11:01:32.064]                         if (!is.null(pattern)) {
[11:01:32.064]                           computeRestarts <- base::computeRestarts
[11:01:32.064]                           grepl <- base::grepl
[11:01:32.064]                           restarts <- computeRestarts(cond)
[11:01:32.064]                           for (restart in restarts) {
[11:01:32.064]                             name <- restart$name
[11:01:32.064]                             if (is.null(name)) 
[11:01:32.064]                               next
[11:01:32.064]                             if (!grepl(pattern, name)) 
[11:01:32.064]                               next
[11:01:32.064]                             invokeRestart(restart)
[11:01:32.064]                             muffled <- TRUE
[11:01:32.064]                             break
[11:01:32.064]                           }
[11:01:32.064]                         }
[11:01:32.064]                       }
[11:01:32.064]                       invisible(muffled)
[11:01:32.064]                     }
[11:01:32.064]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.064]                   }
[11:01:32.064]                 }
[11:01:32.064]             }
[11:01:32.064]         }))
[11:01:32.064]     }, error = function(ex) {
[11:01:32.064]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.064]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.064]                 ...future.rng), started = ...future.startTime, 
[11:01:32.064]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.064]             version = "1.8"), class = "FutureResult")
[11:01:32.064]     }, finally = {
[11:01:32.064]         if (!identical(...future.workdir, getwd())) 
[11:01:32.064]             setwd(...future.workdir)
[11:01:32.064]         {
[11:01:32.064]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.064]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.064]             }
[11:01:32.064]             base::options(...future.oldOptions)
[11:01:32.064]             if (.Platform$OS.type == "windows") {
[11:01:32.064]                 old_names <- names(...future.oldEnvVars)
[11:01:32.064]                 envs <- base::Sys.getenv()
[11:01:32.064]                 names <- names(envs)
[11:01:32.064]                 common <- intersect(names, old_names)
[11:01:32.064]                 added <- setdiff(names, old_names)
[11:01:32.064]                 removed <- setdiff(old_names, names)
[11:01:32.064]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.064]                   envs[common]]
[11:01:32.064]                 NAMES <- toupper(changed)
[11:01:32.064]                 args <- list()
[11:01:32.064]                 for (kk in seq_along(NAMES)) {
[11:01:32.064]                   name <- changed[[kk]]
[11:01:32.064]                   NAME <- NAMES[[kk]]
[11:01:32.064]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.064]                     next
[11:01:32.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.064]                 }
[11:01:32.064]                 NAMES <- toupper(added)
[11:01:32.064]                 for (kk in seq_along(NAMES)) {
[11:01:32.064]                   name <- added[[kk]]
[11:01:32.064]                   NAME <- NAMES[[kk]]
[11:01:32.064]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.064]                     next
[11:01:32.064]                   args[[name]] <- ""
[11:01:32.064]                 }
[11:01:32.064]                 NAMES <- toupper(removed)
[11:01:32.064]                 for (kk in seq_along(NAMES)) {
[11:01:32.064]                   name <- removed[[kk]]
[11:01:32.064]                   NAME <- NAMES[[kk]]
[11:01:32.064]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.064]                     next
[11:01:32.064]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.064]                 }
[11:01:32.064]                 if (length(args) > 0) 
[11:01:32.064]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.064]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.064]             }
[11:01:32.064]             else {
[11:01:32.064]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.064]             }
[11:01:32.064]             {
[11:01:32.064]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.064]                   0L) {
[11:01:32.064]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.064]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.064]                   base::options(opts)
[11:01:32.064]                 }
[11:01:32.064]                 {
[11:01:32.064]                   {
[11:01:32.064]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.064]                     NULL
[11:01:32.064]                   }
[11:01:32.064]                   options(future.plan = NULL)
[11:01:32.064]                   if (is.na(NA_character_)) 
[11:01:32.064]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.064]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.064]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.064]                     .init = FALSE)
[11:01:32.064]                 }
[11:01:32.064]             }
[11:01:32.064]         }
[11:01:32.064]     })
[11:01:32.064]     if (TRUE) {
[11:01:32.064]         base::sink(type = "output", split = FALSE)
[11:01:32.064]         if (TRUE) {
[11:01:32.064]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.064]         }
[11:01:32.064]         else {
[11:01:32.064]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.064]         }
[11:01:32.064]         base::close(...future.stdout)
[11:01:32.064]         ...future.stdout <- NULL
[11:01:32.064]     }
[11:01:32.064]     ...future.result$conditions <- ...future.conditions
[11:01:32.064]     ...future.result$finished <- base::Sys.time()
[11:01:32.064]     ...future.result
[11:01:32.064] }
[11:01:32.067] MultisessionFuture started
[11:01:32.067] - Launch lazy future ... done
[11:01:32.067] run() for ‘MultisessionFuture’ ... done
[11:01:32.067] getGlobalsAndPackages() ...
[11:01:32.067] Searching for globals...
[11:01:32.068] - globals found: [1] ‘{’
[11:01:32.068] Searching for globals ... DONE
[11:01:32.068] Resolving globals: FALSE
[11:01:32.068] 
[11:01:32.068] 
[11:01:32.068] getGlobalsAndPackages() ... DONE
[11:01:32.069] run() for ‘Future’ ...
[11:01:32.069] - state: ‘created’
[11:01:32.069] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.083] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.083] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:32.083]   - Field: ‘node’
[11:01:32.083]   - Field: ‘label’
[11:01:32.083]   - Field: ‘local’
[11:01:32.083]   - Field: ‘owner’
[11:01:32.084]   - Field: ‘envir’
[11:01:32.084]   - Field: ‘workers’
[11:01:32.084]   - Field: ‘packages’
[11:01:32.084]   - Field: ‘gc’
[11:01:32.084]   - Field: ‘conditions’
[11:01:32.084]   - Field: ‘persistent’
[11:01:32.084]   - Field: ‘expr’
[11:01:32.084]   - Field: ‘uuid’
[11:01:32.084]   - Field: ‘seed’
[11:01:32.084]   - Field: ‘version’
[11:01:32.084]   - Field: ‘result’
[11:01:32.084]   - Field: ‘asynchronous’
[11:01:32.085]   - Field: ‘calls’
[11:01:32.085]   - Field: ‘globals’
[11:01:32.085]   - Field: ‘stdout’
[11:01:32.085]   - Field: ‘earlySignal’
[11:01:32.085]   - Field: ‘lazy’
[11:01:32.085]   - Field: ‘state’
[11:01:32.085] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:32.085] - Launch lazy future ...
[11:01:32.085] Packages needed by the future expression (n = 0): <none>
[11:01:32.086] Packages needed by future strategies (n = 0): <none>
[11:01:32.086] {
[11:01:32.086]     {
[11:01:32.086]         {
[11:01:32.086]             ...future.startTime <- base::Sys.time()
[11:01:32.086]             {
[11:01:32.086]                 {
[11:01:32.086]                   {
[11:01:32.086]                     {
[11:01:32.086]                       base::local({
[11:01:32.086]                         has_future <- base::requireNamespace("future", 
[11:01:32.086]                           quietly = TRUE)
[11:01:32.086]                         if (has_future) {
[11:01:32.086]                           ns <- base::getNamespace("future")
[11:01:32.086]                           version <- ns[[".package"]][["version"]]
[11:01:32.086]                           if (is.null(version)) 
[11:01:32.086]                             version <- utils::packageVersion("future")
[11:01:32.086]                         }
[11:01:32.086]                         else {
[11:01:32.086]                           version <- NULL
[11:01:32.086]                         }
[11:01:32.086]                         if (!has_future || version < "1.8.0") {
[11:01:32.086]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.086]                             "", base::R.version$version.string), 
[11:01:32.086]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.086]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.086]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.086]                               "release", "version")], collapse = " "), 
[11:01:32.086]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.086]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.086]                             info)
[11:01:32.086]                           info <- base::paste(info, collapse = "; ")
[11:01:32.086]                           if (!has_future) {
[11:01:32.086]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.086]                               info)
[11:01:32.086]                           }
[11:01:32.086]                           else {
[11:01:32.086]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.086]                               info, version)
[11:01:32.086]                           }
[11:01:32.086]                           base::stop(msg)
[11:01:32.086]                         }
[11:01:32.086]                       })
[11:01:32.086]                     }
[11:01:32.086]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.086]                     base::options(mc.cores = 1L)
[11:01:32.086]                   }
[11:01:32.086]                   ...future.strategy.old <- future::plan("list")
[11:01:32.086]                   options(future.plan = NULL)
[11:01:32.086]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.086]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.086]                 }
[11:01:32.086]                 ...future.workdir <- getwd()
[11:01:32.086]             }
[11:01:32.086]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.086]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.086]         }
[11:01:32.086]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.086]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.086]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.086]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.086]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.086]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.086]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.086]             base::names(...future.oldOptions))
[11:01:32.086]     }
[11:01:32.086]     if (FALSE) {
[11:01:32.086]     }
[11:01:32.086]     else {
[11:01:32.086]         if (TRUE) {
[11:01:32.086]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.086]                 open = "w")
[11:01:32.086]         }
[11:01:32.086]         else {
[11:01:32.086]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.086]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.086]         }
[11:01:32.086]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.086]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.086]             base::sink(type = "output", split = FALSE)
[11:01:32.086]             base::close(...future.stdout)
[11:01:32.086]         }, add = TRUE)
[11:01:32.086]     }
[11:01:32.086]     ...future.frame <- base::sys.nframe()
[11:01:32.086]     ...future.conditions <- base::list()
[11:01:32.086]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.086]     if (FALSE) {
[11:01:32.086]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.086]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.086]     }
[11:01:32.086]     ...future.result <- base::tryCatch({
[11:01:32.086]         base::withCallingHandlers({
[11:01:32.086]             ...future.value <- base::withVisible(base::local({
[11:01:32.086]                 ...future.makeSendCondition <- base::local({
[11:01:32.086]                   sendCondition <- NULL
[11:01:32.086]                   function(frame = 1L) {
[11:01:32.086]                     if (is.function(sendCondition)) 
[11:01:32.086]                       return(sendCondition)
[11:01:32.086]                     ns <- getNamespace("parallel")
[11:01:32.086]                     if (exists("sendData", mode = "function", 
[11:01:32.086]                       envir = ns)) {
[11:01:32.086]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:32.086]                         envir = ns)
[11:01:32.086]                       envir <- sys.frame(frame)
[11:01:32.086]                       master <- NULL
[11:01:32.086]                       while (!identical(envir, .GlobalEnv) && 
[11:01:32.086]                         !identical(envir, emptyenv())) {
[11:01:32.086]                         if (exists("master", mode = "list", envir = envir, 
[11:01:32.086]                           inherits = FALSE)) {
[11:01:32.086]                           master <- get("master", mode = "list", 
[11:01:32.086]                             envir = envir, inherits = FALSE)
[11:01:32.086]                           if (inherits(master, c("SOCKnode", 
[11:01:32.086]                             "SOCK0node"))) {
[11:01:32.086]                             sendCondition <<- function(cond) {
[11:01:32.086]                               data <- list(type = "VALUE", value = cond, 
[11:01:32.086]                                 success = TRUE)
[11:01:32.086]                               parallel_sendData(master, data)
[11:01:32.086]                             }
[11:01:32.086]                             return(sendCondition)
[11:01:32.086]                           }
[11:01:32.086]                         }
[11:01:32.086]                         frame <- frame + 1L
[11:01:32.086]                         envir <- sys.frame(frame)
[11:01:32.086]                       }
[11:01:32.086]                     }
[11:01:32.086]                     sendCondition <<- function(cond) NULL
[11:01:32.086]                   }
[11:01:32.086]                 })
[11:01:32.086]                 withCallingHandlers({
[11:01:32.086]                   {
[11:01:32.086]                     4
[11:01:32.086]                   }
[11:01:32.086]                 }, immediateCondition = function(cond) {
[11:01:32.086]                   sendCondition <- ...future.makeSendCondition()
[11:01:32.086]                   sendCondition(cond)
[11:01:32.086]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.086]                   {
[11:01:32.086]                     inherits <- base::inherits
[11:01:32.086]                     invokeRestart <- base::invokeRestart
[11:01:32.086]                     is.null <- base::is.null
[11:01:32.086]                     muffled <- FALSE
[11:01:32.086]                     if (inherits(cond, "message")) {
[11:01:32.086]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.086]                       if (muffled) 
[11:01:32.086]                         invokeRestart("muffleMessage")
[11:01:32.086]                     }
[11:01:32.086]                     else if (inherits(cond, "warning")) {
[11:01:32.086]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.086]                       if (muffled) 
[11:01:32.086]                         invokeRestart("muffleWarning")
[11:01:32.086]                     }
[11:01:32.086]                     else if (inherits(cond, "condition")) {
[11:01:32.086]                       if (!is.null(pattern)) {
[11:01:32.086]                         computeRestarts <- base::computeRestarts
[11:01:32.086]                         grepl <- base::grepl
[11:01:32.086]                         restarts <- computeRestarts(cond)
[11:01:32.086]                         for (restart in restarts) {
[11:01:32.086]                           name <- restart$name
[11:01:32.086]                           if (is.null(name)) 
[11:01:32.086]                             next
[11:01:32.086]                           if (!grepl(pattern, name)) 
[11:01:32.086]                             next
[11:01:32.086]                           invokeRestart(restart)
[11:01:32.086]                           muffled <- TRUE
[11:01:32.086]                           break
[11:01:32.086]                         }
[11:01:32.086]                       }
[11:01:32.086]                     }
[11:01:32.086]                     invisible(muffled)
[11:01:32.086]                   }
[11:01:32.086]                   muffleCondition(cond)
[11:01:32.086]                 })
[11:01:32.086]             }))
[11:01:32.086]             future::FutureResult(value = ...future.value$value, 
[11:01:32.086]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.086]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.086]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.086]                     ...future.globalenv.names))
[11:01:32.086]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.086]         }, condition = base::local({
[11:01:32.086]             c <- base::c
[11:01:32.086]             inherits <- base::inherits
[11:01:32.086]             invokeRestart <- base::invokeRestart
[11:01:32.086]             length <- base::length
[11:01:32.086]             list <- base::list
[11:01:32.086]             seq.int <- base::seq.int
[11:01:32.086]             signalCondition <- base::signalCondition
[11:01:32.086]             sys.calls <- base::sys.calls
[11:01:32.086]             `[[` <- base::`[[`
[11:01:32.086]             `+` <- base::`+`
[11:01:32.086]             `<<-` <- base::`<<-`
[11:01:32.086]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.086]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.086]                   3L)]
[11:01:32.086]             }
[11:01:32.086]             function(cond) {
[11:01:32.086]                 is_error <- inherits(cond, "error")
[11:01:32.086]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.086]                   NULL)
[11:01:32.086]                 if (is_error) {
[11:01:32.086]                   sessionInformation <- function() {
[11:01:32.086]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.086]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.086]                       search = base::search(), system = base::Sys.info())
[11:01:32.086]                   }
[11:01:32.086]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.086]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.086]                     cond$call), session = sessionInformation(), 
[11:01:32.086]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.086]                   signalCondition(cond)
[11:01:32.086]                 }
[11:01:32.086]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.086]                 "immediateCondition"))) {
[11:01:32.086]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.086]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.086]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.086]                   if (TRUE && !signal) {
[11:01:32.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.086]                     {
[11:01:32.086]                       inherits <- base::inherits
[11:01:32.086]                       invokeRestart <- base::invokeRestart
[11:01:32.086]                       is.null <- base::is.null
[11:01:32.086]                       muffled <- FALSE
[11:01:32.086]                       if (inherits(cond, "message")) {
[11:01:32.086]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.086]                         if (muffled) 
[11:01:32.086]                           invokeRestart("muffleMessage")
[11:01:32.086]                       }
[11:01:32.086]                       else if (inherits(cond, "warning")) {
[11:01:32.086]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.086]                         if (muffled) 
[11:01:32.086]                           invokeRestart("muffleWarning")
[11:01:32.086]                       }
[11:01:32.086]                       else if (inherits(cond, "condition")) {
[11:01:32.086]                         if (!is.null(pattern)) {
[11:01:32.086]                           computeRestarts <- base::computeRestarts
[11:01:32.086]                           grepl <- base::grepl
[11:01:32.086]                           restarts <- computeRestarts(cond)
[11:01:32.086]                           for (restart in restarts) {
[11:01:32.086]                             name <- restart$name
[11:01:32.086]                             if (is.null(name)) 
[11:01:32.086]                               next
[11:01:32.086]                             if (!grepl(pattern, name)) 
[11:01:32.086]                               next
[11:01:32.086]                             invokeRestart(restart)
[11:01:32.086]                             muffled <- TRUE
[11:01:32.086]                             break
[11:01:32.086]                           }
[11:01:32.086]                         }
[11:01:32.086]                       }
[11:01:32.086]                       invisible(muffled)
[11:01:32.086]                     }
[11:01:32.086]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.086]                   }
[11:01:32.086]                 }
[11:01:32.086]                 else {
[11:01:32.086]                   if (TRUE) {
[11:01:32.086]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.086]                     {
[11:01:32.086]                       inherits <- base::inherits
[11:01:32.086]                       invokeRestart <- base::invokeRestart
[11:01:32.086]                       is.null <- base::is.null
[11:01:32.086]                       muffled <- FALSE
[11:01:32.086]                       if (inherits(cond, "message")) {
[11:01:32.086]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.086]                         if (muffled) 
[11:01:32.086]                           invokeRestart("muffleMessage")
[11:01:32.086]                       }
[11:01:32.086]                       else if (inherits(cond, "warning")) {
[11:01:32.086]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.086]                         if (muffled) 
[11:01:32.086]                           invokeRestart("muffleWarning")
[11:01:32.086]                       }
[11:01:32.086]                       else if (inherits(cond, "condition")) {
[11:01:32.086]                         if (!is.null(pattern)) {
[11:01:32.086]                           computeRestarts <- base::computeRestarts
[11:01:32.086]                           grepl <- base::grepl
[11:01:32.086]                           restarts <- computeRestarts(cond)
[11:01:32.086]                           for (restart in restarts) {
[11:01:32.086]                             name <- restart$name
[11:01:32.086]                             if (is.null(name)) 
[11:01:32.086]                               next
[11:01:32.086]                             if (!grepl(pattern, name)) 
[11:01:32.086]                               next
[11:01:32.086]                             invokeRestart(restart)
[11:01:32.086]                             muffled <- TRUE
[11:01:32.086]                             break
[11:01:32.086]                           }
[11:01:32.086]                         }
[11:01:32.086]                       }
[11:01:32.086]                       invisible(muffled)
[11:01:32.086]                     }
[11:01:32.086]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.086]                   }
[11:01:32.086]                 }
[11:01:32.086]             }
[11:01:32.086]         }))
[11:01:32.086]     }, error = function(ex) {
[11:01:32.086]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.086]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.086]                 ...future.rng), started = ...future.startTime, 
[11:01:32.086]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.086]             version = "1.8"), class = "FutureResult")
[11:01:32.086]     }, finally = {
[11:01:32.086]         if (!identical(...future.workdir, getwd())) 
[11:01:32.086]             setwd(...future.workdir)
[11:01:32.086]         {
[11:01:32.086]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.086]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.086]             }
[11:01:32.086]             base::options(...future.oldOptions)
[11:01:32.086]             if (.Platform$OS.type == "windows") {
[11:01:32.086]                 old_names <- names(...future.oldEnvVars)
[11:01:32.086]                 envs <- base::Sys.getenv()
[11:01:32.086]                 names <- names(envs)
[11:01:32.086]                 common <- intersect(names, old_names)
[11:01:32.086]                 added <- setdiff(names, old_names)
[11:01:32.086]                 removed <- setdiff(old_names, names)
[11:01:32.086]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.086]                   envs[common]]
[11:01:32.086]                 NAMES <- toupper(changed)
[11:01:32.086]                 args <- list()
[11:01:32.086]                 for (kk in seq_along(NAMES)) {
[11:01:32.086]                   name <- changed[[kk]]
[11:01:32.086]                   NAME <- NAMES[[kk]]
[11:01:32.086]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.086]                     next
[11:01:32.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.086]                 }
[11:01:32.086]                 NAMES <- toupper(added)
[11:01:32.086]                 for (kk in seq_along(NAMES)) {
[11:01:32.086]                   name <- added[[kk]]
[11:01:32.086]                   NAME <- NAMES[[kk]]
[11:01:32.086]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.086]                     next
[11:01:32.086]                   args[[name]] <- ""
[11:01:32.086]                 }
[11:01:32.086]                 NAMES <- toupper(removed)
[11:01:32.086]                 for (kk in seq_along(NAMES)) {
[11:01:32.086]                   name <- removed[[kk]]
[11:01:32.086]                   NAME <- NAMES[[kk]]
[11:01:32.086]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.086]                     next
[11:01:32.086]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.086]                 }
[11:01:32.086]                 if (length(args) > 0) 
[11:01:32.086]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.086]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.086]             }
[11:01:32.086]             else {
[11:01:32.086]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.086]             }
[11:01:32.086]             {
[11:01:32.086]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.086]                   0L) {
[11:01:32.086]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.086]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.086]                   base::options(opts)
[11:01:32.086]                 }
[11:01:32.086]                 {
[11:01:32.086]                   {
[11:01:32.086]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.086]                     NULL
[11:01:32.086]                   }
[11:01:32.086]                   options(future.plan = NULL)
[11:01:32.086]                   if (is.na(NA_character_)) 
[11:01:32.086]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.086]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.086]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.086]                     .init = FALSE)
[11:01:32.086]                 }
[11:01:32.086]             }
[11:01:32.086]         }
[11:01:32.086]     })
[11:01:32.086]     if (TRUE) {
[11:01:32.086]         base::sink(type = "output", split = FALSE)
[11:01:32.086]         if (TRUE) {
[11:01:32.086]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.086]         }
[11:01:32.086]         else {
[11:01:32.086]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.086]         }
[11:01:32.086]         base::close(...future.stdout)
[11:01:32.086]         ...future.stdout <- NULL
[11:01:32.086]     }
[11:01:32.086]     ...future.result$conditions <- ...future.conditions
[11:01:32.086]     ...future.result$finished <- base::Sys.time()
[11:01:32.086]     ...future.result
[11:01:32.086] }
[11:01:32.089] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:32.100] receiveMessageFromWorker() for ClusterFuture ...
[11:01:32.100] - Validating connection of MultisessionFuture
[11:01:32.100] - received message: FutureResult
[11:01:32.100] - Received FutureResult
[11:01:32.100] - Erased future from FutureRegistry
[11:01:32.101] result() for ClusterFuture ...
[11:01:32.101] - result already collected: FutureResult
[11:01:32.101] result() for ClusterFuture ... done
[11:01:32.101] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:32.101] result() for ClusterFuture ...
[11:01:32.101] - result already collected: FutureResult
[11:01:32.101] result() for ClusterFuture ... done
[11:01:32.101] result() for ClusterFuture ...
[11:01:32.101] - result already collected: FutureResult
[11:01:32.101] result() for ClusterFuture ... done
[11:01:32.102] MultisessionFuture started
[11:01:32.102] - Launch lazy future ... done
[11:01:32.102] run() for ‘MultisessionFuture’ ... done
<environment: 0x55a9c8ac52c8> 
<environment: 0x55a9c53b6680> 
[11:01:32.109] receiveMessageFromWorker() for ClusterFuture ...
[11:01:32.109] - Validating connection of MultisessionFuture
[11:01:32.110] - received message: FutureResult
[11:01:32.110] - Received FutureResult
[11:01:32.110] - Erased future from FutureRegistry
[11:01:32.110] result() for ClusterFuture ...
[11:01:32.110] - result already collected: FutureResult
[11:01:32.110] result() for ClusterFuture ... done
[11:01:32.110] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:4] TRUE TRUE TRUE FALSE
 - attr(*, "names")= chr [1:4] "a" "b" "c" "d"
[11:01:32.122] resolve() on environment ...
[11:01:32.122]  recursive: 0
[11:01:32.122]  elements: [4] ‘a’, ‘b’, ‘c’, ‘d’
[11:01:32.123] signalConditionsASAP(numeric, pos=1) ...
[11:01:32.123] - nx: 4
[11:01:32.123] - relay: TRUE
[11:01:32.123] - stdout: TRUE
[11:01:32.123] - signal: TRUE
[11:01:32.123] - resignal: FALSE
[11:01:32.123] - force: TRUE
[11:01:32.123] - relayed: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:32.123] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:32.123]  - until=2
[11:01:32.123]  - relaying element #2
[11:01:32.124] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:32.124] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:32.124] signalConditionsASAP(NULL, pos=1) ... done
[11:01:32.124]  length: 3 (resolved future 1)
[11:01:32.124] Future #2
[11:01:32.124] result() for ClusterFuture ...
[11:01:32.124] - result already collected: FutureResult
[11:01:32.124] result() for ClusterFuture ... done
[11:01:32.124] result() for ClusterFuture ...
[11:01:32.124] - result already collected: FutureResult
[11:01:32.125] result() for ClusterFuture ... done
[11:01:32.125] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:32.125] - nx: 4
[11:01:32.125] - relay: TRUE
[11:01:32.125] - stdout: TRUE
[11:01:32.125] - signal: TRUE
[11:01:32.125] - resignal: FALSE
[11:01:32.125] - force: TRUE
[11:01:32.125] - relayed: [n=4] TRUE, FALSE, FALSE, FALSE
[11:01:32.125] - queued futures: [n=4] FALSE, FALSE, FALSE, FALSE
[11:01:32.125]  - until=2
[11:01:32.125]  - relaying element #2
[11:01:32.125] result() for ClusterFuture ...
[11:01:32.126] - result already collected: FutureResult
[11:01:32.126] result() for ClusterFuture ... done
[11:01:32.126] result() for ClusterFuture ...
[11:01:32.126] - result already collected: FutureResult
[11:01:32.126] result() for ClusterFuture ... done
[11:01:32.126] result() for ClusterFuture ...
[11:01:32.126] - result already collected: FutureResult
[11:01:32.126] result() for ClusterFuture ... done
[11:01:32.126] result() for ClusterFuture ...
[11:01:32.126] - result already collected: FutureResult
[11:01:32.126] result() for ClusterFuture ... done
[11:01:32.126] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:32.127] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:32.127] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:32.127]  length: 2 (resolved future 2)
[11:01:32.127] Future #3
[11:01:32.127] result() for ClusterFuture ...
[11:01:32.127] - result already collected: FutureResult
[11:01:32.127] result() for ClusterFuture ... done
[11:01:32.127] result() for ClusterFuture ...
[11:01:32.127] - result already collected: FutureResult
[11:01:32.127] result() for ClusterFuture ... done
[11:01:32.127] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:32.128] - nx: 4
[11:01:32.128] - relay: TRUE
[11:01:32.128] - stdout: TRUE
[11:01:32.128] - signal: TRUE
[11:01:32.128] - resignal: FALSE
[11:01:32.128] - force: TRUE
[11:01:32.128] - relayed: [n=4] TRUE, TRUE, FALSE, FALSE
[11:01:32.128] - queued futures: [n=4] FALSE, TRUE, FALSE, FALSE
[11:01:32.128]  - until=3
[11:01:32.128]  - relaying element #3
[11:01:32.128] result() for ClusterFuture ...
[11:01:32.128] - result already collected: FutureResult
[11:01:32.128] result() for ClusterFuture ... done
[11:01:32.129] result() for ClusterFuture ...
[11:01:32.129] - result already collected: FutureResult
[11:01:32.129] result() for ClusterFuture ... done
[11:01:32.129] result() for ClusterFuture ...
[11:01:32.129] - result already collected: FutureResult
[11:01:32.129] result() for ClusterFuture ... done
[11:01:32.129] result() for ClusterFuture ...
[11:01:32.129] - result already collected: FutureResult
[11:01:32.129] result() for ClusterFuture ... done
[11:01:32.129] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:32.129] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:32.129] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:32.130]  length: 1 (resolved future 3)
[11:01:32.150] receiveMessageFromWorker() for ClusterFuture ...
[11:01:32.151] - Validating connection of MultisessionFuture
[11:01:32.151] - received message: FutureResult
[11:01:32.151] - Received FutureResult
[11:01:32.151] - Erased future from FutureRegistry
[11:01:32.151] result() for ClusterFuture ...
[11:01:32.151] - result already collected: FutureResult
[11:01:32.151] result() for ClusterFuture ... done
[11:01:32.151] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:32.151] Future #4
[11:01:32.151] result() for ClusterFuture ...
[11:01:32.152] - result already collected: FutureResult
[11:01:32.152] result() for ClusterFuture ... done
[11:01:32.152] result() for ClusterFuture ...
[11:01:32.152] - result already collected: FutureResult
[11:01:32.152] result() for ClusterFuture ... done
[11:01:32.152] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:32.152] - nx: 4
[11:01:32.152] - relay: TRUE
[11:01:32.152] - stdout: TRUE
[11:01:32.152] - signal: TRUE
[11:01:32.152] - resignal: FALSE
[11:01:32.152] - force: TRUE
[11:01:32.153] - relayed: [n=4] TRUE, TRUE, TRUE, FALSE
[11:01:32.153] - queued futures: [n=4] FALSE, TRUE, TRUE, FALSE
[11:01:32.153]  - until=4
[11:01:32.153]  - relaying element #4
[11:01:32.153] result() for ClusterFuture ...
[11:01:32.153] - result already collected: FutureResult
[11:01:32.153] result() for ClusterFuture ... done
[11:01:32.153] result() for ClusterFuture ...
[11:01:32.153] - result already collected: FutureResult
[11:01:32.153] result() for ClusterFuture ... done
[11:01:32.153] result() for ClusterFuture ...
[11:01:32.153] - result already collected: FutureResult
[11:01:32.154] result() for ClusterFuture ... done
[11:01:32.154] result() for ClusterFuture ...
[11:01:32.154] - result already collected: FutureResult
[11:01:32.154] result() for ClusterFuture ... done
[11:01:32.154] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:32.154] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:32.154] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:32.154]  length: 0 (resolved future 4)
[11:01:32.154] Relaying remaining futures
[11:01:32.154] signalConditionsASAP(NULL, pos=0) ...
[11:01:32.154] - nx: 4
[11:01:32.154] - relay: TRUE
[11:01:32.155] - stdout: TRUE
[11:01:32.155] - signal: TRUE
[11:01:32.155] - resignal: FALSE
[11:01:32.155] - force: TRUE
[11:01:32.155] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:32.155] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
 - flush all
[11:01:32.155] - relayed: [n=4] TRUE, TRUE, TRUE, TRUE
[11:01:32.155] - queued futures: [n=4] FALSE, TRUE, TRUE, TRUE
[11:01:32.155] signalConditionsASAP(NULL, pos=0) ... done
[11:01:32.155] resolve() on environment ... DONE
[11:01:32.155] result() for ClusterFuture ...
[11:01:32.155] - result already collected: FutureResult
[11:01:32.156] result() for ClusterFuture ... done
[11:01:32.156] result() for ClusterFuture ...
[11:01:32.156] - result already collected: FutureResult
[11:01:32.156] result() for ClusterFuture ... done
[11:01:32.156] result() for ClusterFuture ...
[11:01:32.156] - result already collected: FutureResult
[11:01:32.156] result() for ClusterFuture ... done
[11:01:32.156] result() for ClusterFuture ...
[11:01:32.156] - result already collected: FutureResult
[11:01:32.156] result() for ClusterFuture ... done
[11:01:32.156] result() for ClusterFuture ...
[11:01:32.157] - result already collected: FutureResult
[11:01:32.157] result() for ClusterFuture ... done
[11:01:32.157] result() for ClusterFuture ...
[11:01:32.157] - result already collected: FutureResult
[11:01:32.157] result() for ClusterFuture ... done
<environment: 0x55a9c4dfb758> 
*** futures() - environment ... DONE
Type of object: listenv
Type of future: multicore
[11:01:32.157] plan(): Setting new future strategy stack:
[11:01:32.158] List of future strategies:
[11:01:32.158] 1. multicore:
[11:01:32.158]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.158]    - tweaked: FALSE
[11:01:32.158]    - call: plan(strategy)
[11:01:32.160] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[11:01:32.161] getGlobalsAndPackages() ...
[11:01:32.161] Searching for globals...
[11:01:32.161] 
[11:01:32.161] Searching for globals ... DONE
[11:01:32.161] - globals: [0] <none>
[11:01:32.161] getGlobalsAndPackages() ... DONE
[11:01:32.162] run() for ‘Future’ ...
[11:01:32.162] - state: ‘created’
[11:01:32.162] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.163] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.163] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.164]   - Field: ‘label’
[11:01:32.164]   - Field: ‘local’
[11:01:32.164]   - Field: ‘owner’
[11:01:32.164]   - Field: ‘envir’
[11:01:32.164]   - Field: ‘workers’
[11:01:32.164]   - Field: ‘packages’
[11:01:32.164]   - Field: ‘gc’
[11:01:32.164]   - Field: ‘job’
[11:01:32.164]   - Field: ‘conditions’
[11:01:32.164]   - Field: ‘expr’
[11:01:32.164]   - Field: ‘uuid’
[11:01:32.165]   - Field: ‘seed’
[11:01:32.165]   - Field: ‘version’
[11:01:32.165]   - Field: ‘result’
[11:01:32.165]   - Field: ‘asynchronous’
[11:01:32.165]   - Field: ‘calls’
[11:01:32.165]   - Field: ‘globals’
[11:01:32.165]   - Field: ‘stdout’
[11:01:32.165]   - Field: ‘earlySignal’
[11:01:32.165]   - Field: ‘lazy’
[11:01:32.165]   - Field: ‘state’
[11:01:32.165] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.165] - Launch lazy future ...
[11:01:32.166] Packages needed by the future expression (n = 0): <none>
[11:01:32.166] Packages needed by future strategies (n = 0): <none>
[11:01:32.166] {
[11:01:32.166]     {
[11:01:32.166]         {
[11:01:32.166]             ...future.startTime <- base::Sys.time()
[11:01:32.166]             {
[11:01:32.166]                 {
[11:01:32.166]                   {
[11:01:32.166]                     {
[11:01:32.166]                       base::local({
[11:01:32.166]                         has_future <- base::requireNamespace("future", 
[11:01:32.166]                           quietly = TRUE)
[11:01:32.166]                         if (has_future) {
[11:01:32.166]                           ns <- base::getNamespace("future")
[11:01:32.166]                           version <- ns[[".package"]][["version"]]
[11:01:32.166]                           if (is.null(version)) 
[11:01:32.166]                             version <- utils::packageVersion("future")
[11:01:32.166]                         }
[11:01:32.166]                         else {
[11:01:32.166]                           version <- NULL
[11:01:32.166]                         }
[11:01:32.166]                         if (!has_future || version < "1.8.0") {
[11:01:32.166]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.166]                             "", base::R.version$version.string), 
[11:01:32.166]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.166]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.166]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.166]                               "release", "version")], collapse = " "), 
[11:01:32.166]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.166]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.166]                             info)
[11:01:32.166]                           info <- base::paste(info, collapse = "; ")
[11:01:32.166]                           if (!has_future) {
[11:01:32.166]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.166]                               info)
[11:01:32.166]                           }
[11:01:32.166]                           else {
[11:01:32.166]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.166]                               info, version)
[11:01:32.166]                           }
[11:01:32.166]                           base::stop(msg)
[11:01:32.166]                         }
[11:01:32.166]                       })
[11:01:32.166]                     }
[11:01:32.166]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.166]                     base::options(mc.cores = 1L)
[11:01:32.166]                   }
[11:01:32.166]                   ...future.strategy.old <- future::plan("list")
[11:01:32.166]                   options(future.plan = NULL)
[11:01:32.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.166]                 }
[11:01:32.166]                 ...future.workdir <- getwd()
[11:01:32.166]             }
[11:01:32.166]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.166]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.166]         }
[11:01:32.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.166]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.166]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.166]             base::names(...future.oldOptions))
[11:01:32.166]     }
[11:01:32.166]     if (FALSE) {
[11:01:32.166]     }
[11:01:32.166]     else {
[11:01:32.166]         if (TRUE) {
[11:01:32.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.166]                 open = "w")
[11:01:32.166]         }
[11:01:32.166]         else {
[11:01:32.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.166]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.166]         }
[11:01:32.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.166]             base::sink(type = "output", split = FALSE)
[11:01:32.166]             base::close(...future.stdout)
[11:01:32.166]         }, add = TRUE)
[11:01:32.166]     }
[11:01:32.166]     ...future.frame <- base::sys.nframe()
[11:01:32.166]     ...future.conditions <- base::list()
[11:01:32.166]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.166]     if (FALSE) {
[11:01:32.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.166]     }
[11:01:32.166]     ...future.result <- base::tryCatch({
[11:01:32.166]         base::withCallingHandlers({
[11:01:32.166]             ...future.value <- base::withVisible(base::local({
[11:01:32.166]                 withCallingHandlers({
[11:01:32.166]                   2
[11:01:32.166]                 }, immediateCondition = function(cond) {
[11:01:32.166]                   save_rds <- function (object, pathname, ...) 
[11:01:32.166]                   {
[11:01:32.166]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.166]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.166]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.166]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.166]                         fi_tmp[["mtime"]])
[11:01:32.166]                     }
[11:01:32.166]                     tryCatch({
[11:01:32.166]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.166]                     }, error = function(ex) {
[11:01:32.166]                       msg <- conditionMessage(ex)
[11:01:32.166]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.166]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.166]                         fi_tmp[["mtime"]], msg)
[11:01:32.166]                       ex$message <- msg
[11:01:32.166]                       stop(ex)
[11:01:32.166]                     })
[11:01:32.166]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.166]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.166]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.166]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.166]                       fi <- file.info(pathname)
[11:01:32.166]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.166]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.166]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.166]                         fi[["size"]], fi[["mtime"]])
[11:01:32.166]                       stop(msg)
[11:01:32.166]                     }
[11:01:32.166]                     invisible(pathname)
[11:01:32.166]                   }
[11:01:32.166]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.166]                     rootPath = tempdir()) 
[11:01:32.166]                   {
[11:01:32.166]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.166]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.166]                       tmpdir = path, fileext = ".rds")
[11:01:32.166]                     save_rds(obj, file)
[11:01:32.166]                   }
[11:01:32.166]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.166]                   {
[11:01:32.166]                     inherits <- base::inherits
[11:01:32.166]                     invokeRestart <- base::invokeRestart
[11:01:32.166]                     is.null <- base::is.null
[11:01:32.166]                     muffled <- FALSE
[11:01:32.166]                     if (inherits(cond, "message")) {
[11:01:32.166]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.166]                       if (muffled) 
[11:01:32.166]                         invokeRestart("muffleMessage")
[11:01:32.166]                     }
[11:01:32.166]                     else if (inherits(cond, "warning")) {
[11:01:32.166]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.166]                       if (muffled) 
[11:01:32.166]                         invokeRestart("muffleWarning")
[11:01:32.166]                     }
[11:01:32.166]                     else if (inherits(cond, "condition")) {
[11:01:32.166]                       if (!is.null(pattern)) {
[11:01:32.166]                         computeRestarts <- base::computeRestarts
[11:01:32.166]                         grepl <- base::grepl
[11:01:32.166]                         restarts <- computeRestarts(cond)
[11:01:32.166]                         for (restart in restarts) {
[11:01:32.166]                           name <- restart$name
[11:01:32.166]                           if (is.null(name)) 
[11:01:32.166]                             next
[11:01:32.166]                           if (!grepl(pattern, name)) 
[11:01:32.166]                             next
[11:01:32.166]                           invokeRestart(restart)
[11:01:32.166]                           muffled <- TRUE
[11:01:32.166]                           break
[11:01:32.166]                         }
[11:01:32.166]                       }
[11:01:32.166]                     }
[11:01:32.166]                     invisible(muffled)
[11:01:32.166]                   }
[11:01:32.166]                   muffleCondition(cond)
[11:01:32.166]                 })
[11:01:32.166]             }))
[11:01:32.166]             future::FutureResult(value = ...future.value$value, 
[11:01:32.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.166]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.166]                     ...future.globalenv.names))
[11:01:32.166]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.166]         }, condition = base::local({
[11:01:32.166]             c <- base::c
[11:01:32.166]             inherits <- base::inherits
[11:01:32.166]             invokeRestart <- base::invokeRestart
[11:01:32.166]             length <- base::length
[11:01:32.166]             list <- base::list
[11:01:32.166]             seq.int <- base::seq.int
[11:01:32.166]             signalCondition <- base::signalCondition
[11:01:32.166]             sys.calls <- base::sys.calls
[11:01:32.166]             `[[` <- base::`[[`
[11:01:32.166]             `+` <- base::`+`
[11:01:32.166]             `<<-` <- base::`<<-`
[11:01:32.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.166]                   3L)]
[11:01:32.166]             }
[11:01:32.166]             function(cond) {
[11:01:32.166]                 is_error <- inherits(cond, "error")
[11:01:32.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.166]                   NULL)
[11:01:32.166]                 if (is_error) {
[11:01:32.166]                   sessionInformation <- function() {
[11:01:32.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.166]                       search = base::search(), system = base::Sys.info())
[11:01:32.166]                   }
[11:01:32.166]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.166]                     cond$call), session = sessionInformation(), 
[11:01:32.166]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.166]                   signalCondition(cond)
[11:01:32.166]                 }
[11:01:32.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.166]                 "immediateCondition"))) {
[11:01:32.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.166]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.166]                   if (TRUE && !signal) {
[11:01:32.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.166]                     {
[11:01:32.166]                       inherits <- base::inherits
[11:01:32.166]                       invokeRestart <- base::invokeRestart
[11:01:32.166]                       is.null <- base::is.null
[11:01:32.166]                       muffled <- FALSE
[11:01:32.166]                       if (inherits(cond, "message")) {
[11:01:32.166]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.166]                         if (muffled) 
[11:01:32.166]                           invokeRestart("muffleMessage")
[11:01:32.166]                       }
[11:01:32.166]                       else if (inherits(cond, "warning")) {
[11:01:32.166]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.166]                         if (muffled) 
[11:01:32.166]                           invokeRestart("muffleWarning")
[11:01:32.166]                       }
[11:01:32.166]                       else if (inherits(cond, "condition")) {
[11:01:32.166]                         if (!is.null(pattern)) {
[11:01:32.166]                           computeRestarts <- base::computeRestarts
[11:01:32.166]                           grepl <- base::grepl
[11:01:32.166]                           restarts <- computeRestarts(cond)
[11:01:32.166]                           for (restart in restarts) {
[11:01:32.166]                             name <- restart$name
[11:01:32.166]                             if (is.null(name)) 
[11:01:32.166]                               next
[11:01:32.166]                             if (!grepl(pattern, name)) 
[11:01:32.166]                               next
[11:01:32.166]                             invokeRestart(restart)
[11:01:32.166]                             muffled <- TRUE
[11:01:32.166]                             break
[11:01:32.166]                           }
[11:01:32.166]                         }
[11:01:32.166]                       }
[11:01:32.166]                       invisible(muffled)
[11:01:32.166]                     }
[11:01:32.166]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.166]                   }
[11:01:32.166]                 }
[11:01:32.166]                 else {
[11:01:32.166]                   if (TRUE) {
[11:01:32.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.166]                     {
[11:01:32.166]                       inherits <- base::inherits
[11:01:32.166]                       invokeRestart <- base::invokeRestart
[11:01:32.166]                       is.null <- base::is.null
[11:01:32.166]                       muffled <- FALSE
[11:01:32.166]                       if (inherits(cond, "message")) {
[11:01:32.166]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.166]                         if (muffled) 
[11:01:32.166]                           invokeRestart("muffleMessage")
[11:01:32.166]                       }
[11:01:32.166]                       else if (inherits(cond, "warning")) {
[11:01:32.166]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.166]                         if (muffled) 
[11:01:32.166]                           invokeRestart("muffleWarning")
[11:01:32.166]                       }
[11:01:32.166]                       else if (inherits(cond, "condition")) {
[11:01:32.166]                         if (!is.null(pattern)) {
[11:01:32.166]                           computeRestarts <- base::computeRestarts
[11:01:32.166]                           grepl <- base::grepl
[11:01:32.166]                           restarts <- computeRestarts(cond)
[11:01:32.166]                           for (restart in restarts) {
[11:01:32.166]                             name <- restart$name
[11:01:32.166]                             if (is.null(name)) 
[11:01:32.166]                               next
[11:01:32.166]                             if (!grepl(pattern, name)) 
[11:01:32.166]                               next
[11:01:32.166]                             invokeRestart(restart)
[11:01:32.166]                             muffled <- TRUE
[11:01:32.166]                             break
[11:01:32.166]                           }
[11:01:32.166]                         }
[11:01:32.166]                       }
[11:01:32.166]                       invisible(muffled)
[11:01:32.166]                     }
[11:01:32.166]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.166]                   }
[11:01:32.166]                 }
[11:01:32.166]             }
[11:01:32.166]         }))
[11:01:32.166]     }, error = function(ex) {
[11:01:32.166]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.166]                 ...future.rng), started = ...future.startTime, 
[11:01:32.166]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.166]             version = "1.8"), class = "FutureResult")
[11:01:32.166]     }, finally = {
[11:01:32.166]         if (!identical(...future.workdir, getwd())) 
[11:01:32.166]             setwd(...future.workdir)
[11:01:32.166]         {
[11:01:32.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.166]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.166]             }
[11:01:32.166]             base::options(...future.oldOptions)
[11:01:32.166]             if (.Platform$OS.type == "windows") {
[11:01:32.166]                 old_names <- names(...future.oldEnvVars)
[11:01:32.166]                 envs <- base::Sys.getenv()
[11:01:32.166]                 names <- names(envs)
[11:01:32.166]                 common <- intersect(names, old_names)
[11:01:32.166]                 added <- setdiff(names, old_names)
[11:01:32.166]                 removed <- setdiff(old_names, names)
[11:01:32.166]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.166]                   envs[common]]
[11:01:32.166]                 NAMES <- toupper(changed)
[11:01:32.166]                 args <- list()
[11:01:32.166]                 for (kk in seq_along(NAMES)) {
[11:01:32.166]                   name <- changed[[kk]]
[11:01:32.166]                   NAME <- NAMES[[kk]]
[11:01:32.166]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.166]                     next
[11:01:32.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.166]                 }
[11:01:32.166]                 NAMES <- toupper(added)
[11:01:32.166]                 for (kk in seq_along(NAMES)) {
[11:01:32.166]                   name <- added[[kk]]
[11:01:32.166]                   NAME <- NAMES[[kk]]
[11:01:32.166]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.166]                     next
[11:01:32.166]                   args[[name]] <- ""
[11:01:32.166]                 }
[11:01:32.166]                 NAMES <- toupper(removed)
[11:01:32.166]                 for (kk in seq_along(NAMES)) {
[11:01:32.166]                   name <- removed[[kk]]
[11:01:32.166]                   NAME <- NAMES[[kk]]
[11:01:32.166]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.166]                     next
[11:01:32.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.166]                 }
[11:01:32.166]                 if (length(args) > 0) 
[11:01:32.166]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.166]             }
[11:01:32.166]             else {
[11:01:32.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.166]             }
[11:01:32.166]             {
[11:01:32.166]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.166]                   0L) {
[11:01:32.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.166]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.166]                   base::options(opts)
[11:01:32.166]                 }
[11:01:32.166]                 {
[11:01:32.166]                   {
[11:01:32.166]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.166]                     NULL
[11:01:32.166]                   }
[11:01:32.166]                   options(future.plan = NULL)
[11:01:32.166]                   if (is.na(NA_character_)) 
[11:01:32.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.166]                     .init = FALSE)
[11:01:32.166]                 }
[11:01:32.166]             }
[11:01:32.166]         }
[11:01:32.166]     })
[11:01:32.166]     if (TRUE) {
[11:01:32.166]         base::sink(type = "output", split = FALSE)
[11:01:32.166]         if (TRUE) {
[11:01:32.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.166]         }
[11:01:32.166]         else {
[11:01:32.166]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.166]         }
[11:01:32.166]         base::close(...future.stdout)
[11:01:32.166]         ...future.stdout <- NULL
[11:01:32.166]     }
[11:01:32.166]     ...future.result$conditions <- ...future.conditions
[11:01:32.166]     ...future.result$finished <- base::Sys.time()
[11:01:32.166]     ...future.result
[11:01:32.166] }
[11:01:32.168] requestCore(): workers = 2
[11:01:32.171] MulticoreFuture started
[11:01:32.171] - Launch lazy future ... done
[11:01:32.172] run() for ‘MulticoreFuture’ ... done
[11:01:32.172] getGlobalsAndPackages() ...
[11:01:32.172] plan(): Setting new future strategy stack:
[11:01:32.172] Searching for globals...
[11:01:32.173] 
[11:01:32.172] List of future strategies:
[11:01:32.172] 1. sequential:
[11:01:32.172]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.172]    - tweaked: FALSE
[11:01:32.172]    - call: NULL
[11:01:32.173] Searching for globals ... DONE
[11:01:32.173] plan(): nbrOfWorkers() = 1
[11:01:32.173] - globals: [0] <none>
[11:01:32.173] getGlobalsAndPackages() ... DONE
[11:01:32.174] run() for ‘Future’ ...
[11:01:32.174] - state: ‘created’
[11:01:32.174] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.176] plan(): Setting new future strategy stack:
[11:01:32.176] List of future strategies:
[11:01:32.176] 1. multicore:
[11:01:32.176]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.176]    - tweaked: FALSE
[11:01:32.176]    - call: plan(strategy)
[11:01:32.178] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.178] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.178]   - Field: ‘label’
[11:01:32.178]   - Field: ‘local’
[11:01:32.178] plan(): nbrOfWorkers() = 2
[11:01:32.178]   - Field: ‘owner’
[11:01:32.178]   - Field: ‘envir’
[11:01:32.178]   - Field: ‘workers’
[11:01:32.179]   - Field: ‘packages’
[11:01:32.179]   - Field: ‘gc’
[11:01:32.179]   - Field: ‘job’
[11:01:32.179]   - Field: ‘conditions’
[11:01:32.179]   - Field: ‘expr’
[11:01:32.179]   - Field: ‘uuid’
[11:01:32.179]   - Field: ‘seed’
[11:01:32.179]   - Field: ‘version’
[11:01:32.180]   - Field: ‘result’
[11:01:32.180]   - Field: ‘asynchronous’
[11:01:32.180]   - Field: ‘calls’
[11:01:32.180]   - Field: ‘globals’
[11:01:32.180]   - Field: ‘stdout’
[11:01:32.180]   - Field: ‘earlySignal’
[11:01:32.180]   - Field: ‘lazy’
[11:01:32.180]   - Field: ‘state’
[11:01:32.181] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.181] - Launch lazy future ...
[11:01:32.181] Packages needed by the future expression (n = 0): <none>
[11:01:32.181] Packages needed by future strategies (n = 0): <none>
[11:01:32.182] {
[11:01:32.182]     {
[11:01:32.182]         {
[11:01:32.182]             ...future.startTime <- base::Sys.time()
[11:01:32.182]             {
[11:01:32.182]                 {
[11:01:32.182]                   {
[11:01:32.182]                     {
[11:01:32.182]                       base::local({
[11:01:32.182]                         has_future <- base::requireNamespace("future", 
[11:01:32.182]                           quietly = TRUE)
[11:01:32.182]                         if (has_future) {
[11:01:32.182]                           ns <- base::getNamespace("future")
[11:01:32.182]                           version <- ns[[".package"]][["version"]]
[11:01:32.182]                           if (is.null(version)) 
[11:01:32.182]                             version <- utils::packageVersion("future")
[11:01:32.182]                         }
[11:01:32.182]                         else {
[11:01:32.182]                           version <- NULL
[11:01:32.182]                         }
[11:01:32.182]                         if (!has_future || version < "1.8.0") {
[11:01:32.182]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.182]                             "", base::R.version$version.string), 
[11:01:32.182]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.182]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.182]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.182]                               "release", "version")], collapse = " "), 
[11:01:32.182]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.182]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.182]                             info)
[11:01:32.182]                           info <- base::paste(info, collapse = "; ")
[11:01:32.182]                           if (!has_future) {
[11:01:32.182]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.182]                               info)
[11:01:32.182]                           }
[11:01:32.182]                           else {
[11:01:32.182]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.182]                               info, version)
[11:01:32.182]                           }
[11:01:32.182]                           base::stop(msg)
[11:01:32.182]                         }
[11:01:32.182]                       })
[11:01:32.182]                     }
[11:01:32.182]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.182]                     base::options(mc.cores = 1L)
[11:01:32.182]                   }
[11:01:32.182]                   ...future.strategy.old <- future::plan("list")
[11:01:32.182]                   options(future.plan = NULL)
[11:01:32.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.182]                 }
[11:01:32.182]                 ...future.workdir <- getwd()
[11:01:32.182]             }
[11:01:32.182]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.182]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.182]         }
[11:01:32.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.182]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.182]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.182]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.182]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.182]             base::names(...future.oldOptions))
[11:01:32.182]     }
[11:01:32.182]     if (FALSE) {
[11:01:32.182]     }
[11:01:32.182]     else {
[11:01:32.182]         if (TRUE) {
[11:01:32.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.182]                 open = "w")
[11:01:32.182]         }
[11:01:32.182]         else {
[11:01:32.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.182]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.182]         }
[11:01:32.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.182]             base::sink(type = "output", split = FALSE)
[11:01:32.182]             base::close(...future.stdout)
[11:01:32.182]         }, add = TRUE)
[11:01:32.182]     }
[11:01:32.182]     ...future.frame <- base::sys.nframe()
[11:01:32.182]     ...future.conditions <- base::list()
[11:01:32.182]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.182]     if (FALSE) {
[11:01:32.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.182]     }
[11:01:32.182]     ...future.result <- base::tryCatch({
[11:01:32.182]         base::withCallingHandlers({
[11:01:32.182]             ...future.value <- base::withVisible(base::local({
[11:01:32.182]                 withCallingHandlers({
[11:01:32.182]                   NULL
[11:01:32.182]                 }, immediateCondition = function(cond) {
[11:01:32.182]                   save_rds <- function (object, pathname, ...) 
[11:01:32.182]                   {
[11:01:32.182]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.182]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.182]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.182]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.182]                         fi_tmp[["mtime"]])
[11:01:32.182]                     }
[11:01:32.182]                     tryCatch({
[11:01:32.182]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.182]                     }, error = function(ex) {
[11:01:32.182]                       msg <- conditionMessage(ex)
[11:01:32.182]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.182]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.182]                         fi_tmp[["mtime"]], msg)
[11:01:32.182]                       ex$message <- msg
[11:01:32.182]                       stop(ex)
[11:01:32.182]                     })
[11:01:32.182]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.182]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.182]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.182]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.182]                       fi <- file.info(pathname)
[11:01:32.182]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.182]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.182]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.182]                         fi[["size"]], fi[["mtime"]])
[11:01:32.182]                       stop(msg)
[11:01:32.182]                     }
[11:01:32.182]                     invisible(pathname)
[11:01:32.182]                   }
[11:01:32.182]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.182]                     rootPath = tempdir()) 
[11:01:32.182]                   {
[11:01:32.182]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.182]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.182]                       tmpdir = path, fileext = ".rds")
[11:01:32.182]                     save_rds(obj, file)
[11:01:32.182]                   }
[11:01:32.182]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.182]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.182]                   {
[11:01:32.182]                     inherits <- base::inherits
[11:01:32.182]                     invokeRestart <- base::invokeRestart
[11:01:32.182]                     is.null <- base::is.null
[11:01:32.182]                     muffled <- FALSE
[11:01:32.182]                     if (inherits(cond, "message")) {
[11:01:32.182]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.182]                       if (muffled) 
[11:01:32.182]                         invokeRestart("muffleMessage")
[11:01:32.182]                     }
[11:01:32.182]                     else if (inherits(cond, "warning")) {
[11:01:32.182]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.182]                       if (muffled) 
[11:01:32.182]                         invokeRestart("muffleWarning")
[11:01:32.182]                     }
[11:01:32.182]                     else if (inherits(cond, "condition")) {
[11:01:32.182]                       if (!is.null(pattern)) {
[11:01:32.182]                         computeRestarts <- base::computeRestarts
[11:01:32.182]                         grepl <- base::grepl
[11:01:32.182]                         restarts <- computeRestarts(cond)
[11:01:32.182]                         for (restart in restarts) {
[11:01:32.182]                           name <- restart$name
[11:01:32.182]                           if (is.null(name)) 
[11:01:32.182]                             next
[11:01:32.182]                           if (!grepl(pattern, name)) 
[11:01:32.182]                             next
[11:01:32.182]                           invokeRestart(restart)
[11:01:32.182]                           muffled <- TRUE
[11:01:32.182]                           break
[11:01:32.182]                         }
[11:01:32.182]                       }
[11:01:32.182]                     }
[11:01:32.182]                     invisible(muffled)
[11:01:32.182]                   }
[11:01:32.182]                   muffleCondition(cond)
[11:01:32.182]                 })
[11:01:32.182]             }))
[11:01:32.182]             future::FutureResult(value = ...future.value$value, 
[11:01:32.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.182]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.182]                     ...future.globalenv.names))
[11:01:32.182]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.182]         }, condition = base::local({
[11:01:32.182]             c <- base::c
[11:01:32.182]             inherits <- base::inherits
[11:01:32.182]             invokeRestart <- base::invokeRestart
[11:01:32.182]             length <- base::length
[11:01:32.182]             list <- base::list
[11:01:32.182]             seq.int <- base::seq.int
[11:01:32.182]             signalCondition <- base::signalCondition
[11:01:32.182]             sys.calls <- base::sys.calls
[11:01:32.182]             `[[` <- base::`[[`
[11:01:32.182]             `+` <- base::`+`
[11:01:32.182]             `<<-` <- base::`<<-`
[11:01:32.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.182]                   3L)]
[11:01:32.182]             }
[11:01:32.182]             function(cond) {
[11:01:32.182]                 is_error <- inherits(cond, "error")
[11:01:32.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.182]                   NULL)
[11:01:32.182]                 if (is_error) {
[11:01:32.182]                   sessionInformation <- function() {
[11:01:32.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.182]                       search = base::search(), system = base::Sys.info())
[11:01:32.182]                   }
[11:01:32.182]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.182]                     cond$call), session = sessionInformation(), 
[11:01:32.182]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.182]                   signalCondition(cond)
[11:01:32.182]                 }
[11:01:32.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.182]                 "immediateCondition"))) {
[11:01:32.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.182]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.182]                   if (TRUE && !signal) {
[11:01:32.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.182]                     {
[11:01:32.182]                       inherits <- base::inherits
[11:01:32.182]                       invokeRestart <- base::invokeRestart
[11:01:32.182]                       is.null <- base::is.null
[11:01:32.182]                       muffled <- FALSE
[11:01:32.182]                       if (inherits(cond, "message")) {
[11:01:32.182]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.182]                         if (muffled) 
[11:01:32.182]                           invokeRestart("muffleMessage")
[11:01:32.182]                       }
[11:01:32.182]                       else if (inherits(cond, "warning")) {
[11:01:32.182]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.182]                         if (muffled) 
[11:01:32.182]                           invokeRestart("muffleWarning")
[11:01:32.182]                       }
[11:01:32.182]                       else if (inherits(cond, "condition")) {
[11:01:32.182]                         if (!is.null(pattern)) {
[11:01:32.182]                           computeRestarts <- base::computeRestarts
[11:01:32.182]                           grepl <- base::grepl
[11:01:32.182]                           restarts <- computeRestarts(cond)
[11:01:32.182]                           for (restart in restarts) {
[11:01:32.182]                             name <- restart$name
[11:01:32.182]                             if (is.null(name)) 
[11:01:32.182]                               next
[11:01:32.182]                             if (!grepl(pattern, name)) 
[11:01:32.182]                               next
[11:01:32.182]                             invokeRestart(restart)
[11:01:32.182]                             muffled <- TRUE
[11:01:32.182]                             break
[11:01:32.182]                           }
[11:01:32.182]                         }
[11:01:32.182]                       }
[11:01:32.182]                       invisible(muffled)
[11:01:32.182]                     }
[11:01:32.182]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.182]                   }
[11:01:32.182]                 }
[11:01:32.182]                 else {
[11:01:32.182]                   if (TRUE) {
[11:01:32.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.182]                     {
[11:01:32.182]                       inherits <- base::inherits
[11:01:32.182]                       invokeRestart <- base::invokeRestart
[11:01:32.182]                       is.null <- base::is.null
[11:01:32.182]                       muffled <- FALSE
[11:01:32.182]                       if (inherits(cond, "message")) {
[11:01:32.182]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.182]                         if (muffled) 
[11:01:32.182]                           invokeRestart("muffleMessage")
[11:01:32.182]                       }
[11:01:32.182]                       else if (inherits(cond, "warning")) {
[11:01:32.182]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.182]                         if (muffled) 
[11:01:32.182]                           invokeRestart("muffleWarning")
[11:01:32.182]                       }
[11:01:32.182]                       else if (inherits(cond, "condition")) {
[11:01:32.182]                         if (!is.null(pattern)) {
[11:01:32.182]                           computeRestarts <- base::computeRestarts
[11:01:32.182]                           grepl <- base::grepl
[11:01:32.182]                           restarts <- computeRestarts(cond)
[11:01:32.182]                           for (restart in restarts) {
[11:01:32.182]                             name <- restart$name
[11:01:32.182]                             if (is.null(name)) 
[11:01:32.182]                               next
[11:01:32.182]                             if (!grepl(pattern, name)) 
[11:01:32.182]                               next
[11:01:32.182]                             invokeRestart(restart)
[11:01:32.182]                             muffled <- TRUE
[11:01:32.182]                             break
[11:01:32.182]                           }
[11:01:32.182]                         }
[11:01:32.182]                       }
[11:01:32.182]                       invisible(muffled)
[11:01:32.182]                     }
[11:01:32.182]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.182]                   }
[11:01:32.182]                 }
[11:01:32.182]             }
[11:01:32.182]         }))
[11:01:32.182]     }, error = function(ex) {
[11:01:32.182]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.182]                 ...future.rng), started = ...future.startTime, 
[11:01:32.182]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.182]             version = "1.8"), class = "FutureResult")
[11:01:32.182]     }, finally = {
[11:01:32.182]         if (!identical(...future.workdir, getwd())) 
[11:01:32.182]             setwd(...future.workdir)
[11:01:32.182]         {
[11:01:32.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.182]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.182]             }
[11:01:32.182]             base::options(...future.oldOptions)
[11:01:32.182]             if (.Platform$OS.type == "windows") {
[11:01:32.182]                 old_names <- names(...future.oldEnvVars)
[11:01:32.182]                 envs <- base::Sys.getenv()
[11:01:32.182]                 names <- names(envs)
[11:01:32.182]                 common <- intersect(names, old_names)
[11:01:32.182]                 added <- setdiff(names, old_names)
[11:01:32.182]                 removed <- setdiff(old_names, names)
[11:01:32.182]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.182]                   envs[common]]
[11:01:32.182]                 NAMES <- toupper(changed)
[11:01:32.182]                 args <- list()
[11:01:32.182]                 for (kk in seq_along(NAMES)) {
[11:01:32.182]                   name <- changed[[kk]]
[11:01:32.182]                   NAME <- NAMES[[kk]]
[11:01:32.182]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.182]                     next
[11:01:32.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.182]                 }
[11:01:32.182]                 NAMES <- toupper(added)
[11:01:32.182]                 for (kk in seq_along(NAMES)) {
[11:01:32.182]                   name <- added[[kk]]
[11:01:32.182]                   NAME <- NAMES[[kk]]
[11:01:32.182]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.182]                     next
[11:01:32.182]                   args[[name]] <- ""
[11:01:32.182]                 }
[11:01:32.182]                 NAMES <- toupper(removed)
[11:01:32.182]                 for (kk in seq_along(NAMES)) {
[11:01:32.182]                   name <- removed[[kk]]
[11:01:32.182]                   NAME <- NAMES[[kk]]
[11:01:32.182]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.182]                     next
[11:01:32.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.182]                 }
[11:01:32.182]                 if (length(args) > 0) 
[11:01:32.182]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.182]             }
[11:01:32.182]             else {
[11:01:32.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.182]             }
[11:01:32.182]             {
[11:01:32.182]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.182]                   0L) {
[11:01:32.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.182]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.182]                   base::options(opts)
[11:01:32.182]                 }
[11:01:32.182]                 {
[11:01:32.182]                   {
[11:01:32.182]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.182]                     NULL
[11:01:32.182]                   }
[11:01:32.182]                   options(future.plan = NULL)
[11:01:32.182]                   if (is.na(NA_character_)) 
[11:01:32.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.182]                     .init = FALSE)
[11:01:32.182]                 }
[11:01:32.182]             }
[11:01:32.182]         }
[11:01:32.182]     })
[11:01:32.182]     if (TRUE) {
[11:01:32.182]         base::sink(type = "output", split = FALSE)
[11:01:32.182]         if (TRUE) {
[11:01:32.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.182]         }
[11:01:32.182]         else {
[11:01:32.182]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.182]         }
[11:01:32.182]         base::close(...future.stdout)
[11:01:32.182]         ...future.stdout <- NULL
[11:01:32.182]     }
[11:01:32.182]     ...future.result$conditions <- ...future.conditions
[11:01:32.182]     ...future.result$finished <- base::Sys.time()
[11:01:32.182]     ...future.result
[11:01:32.182] }
[11:01:32.185] requestCore(): workers = 2
[11:01:32.188] MulticoreFuture started
[11:01:32.188] - Launch lazy future ... done
[11:01:32.188] run() for ‘MulticoreFuture’ ... done
[11:01:32.189] plan(): Setting new future strategy stack:
[11:01:32.189] getGlobalsAndPackages() ...
[11:01:32.189] Searching for globals...
[11:01:32.189] List of future strategies:
[11:01:32.189] 1. sequential:
[11:01:32.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.189]    - tweaked: FALSE
[11:01:32.189]    - call: NULL
[11:01:32.190] plan(): nbrOfWorkers() = 1
[11:01:32.191] - globals found: [1] ‘{’
[11:01:32.191] Searching for globals ... DONE
[11:01:32.191] Resolving globals: FALSE
[11:01:32.192] 
[11:01:32.192] 
[11:01:32.192] plan(): Setting new future strategy stack:
[11:01:32.192] getGlobalsAndPackages() ... DONE
[11:01:32.192] List of future strategies:
[11:01:32.192] 1. multicore:
[11:01:32.192]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.192]    - tweaked: FALSE
[11:01:32.192]    - call: plan(strategy)
[11:01:32.192] run() for ‘Future’ ...
[11:01:32.192] - state: ‘created’
[11:01:32.193] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.195] plan(): nbrOfWorkers() = 2
[11:01:32.195] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.195] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.196]   - Field: ‘label’
[11:01:32.196]   - Field: ‘local’
[11:01:32.196]   - Field: ‘owner’
[11:01:32.196]   - Field: ‘envir’
[11:01:32.196]   - Field: ‘workers’
[11:01:32.196]   - Field: ‘packages’
[11:01:32.196]   - Field: ‘gc’
[11:01:32.196]   - Field: ‘job’
[11:01:32.197]   - Field: ‘conditions’
[11:01:32.197]   - Field: ‘expr’
[11:01:32.197]   - Field: ‘uuid’
[11:01:32.197]   - Field: ‘seed’
[11:01:32.197]   - Field: ‘version’
[11:01:32.197]   - Field: ‘result’
[11:01:32.197]   - Field: ‘asynchronous’
[11:01:32.197]   - Field: ‘calls’
[11:01:32.198]   - Field: ‘globals’
[11:01:32.198]   - Field: ‘stdout’
[11:01:32.198]   - Field: ‘earlySignal’
[11:01:32.198]   - Field: ‘lazy’
[11:01:32.198]   - Field: ‘state’
[11:01:32.198] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.198] - Launch lazy future ...
[11:01:32.199] Packages needed by the future expression (n = 0): <none>
[11:01:32.199] Packages needed by future strategies (n = 0): <none>
[11:01:32.200] {
[11:01:32.200]     {
[11:01:32.200]         {
[11:01:32.200]             ...future.startTime <- base::Sys.time()
[11:01:32.200]             {
[11:01:32.200]                 {
[11:01:32.200]                   {
[11:01:32.200]                     {
[11:01:32.200]                       base::local({
[11:01:32.200]                         has_future <- base::requireNamespace("future", 
[11:01:32.200]                           quietly = TRUE)
[11:01:32.200]                         if (has_future) {
[11:01:32.200]                           ns <- base::getNamespace("future")
[11:01:32.200]                           version <- ns[[".package"]][["version"]]
[11:01:32.200]                           if (is.null(version)) 
[11:01:32.200]                             version <- utils::packageVersion("future")
[11:01:32.200]                         }
[11:01:32.200]                         else {
[11:01:32.200]                           version <- NULL
[11:01:32.200]                         }
[11:01:32.200]                         if (!has_future || version < "1.8.0") {
[11:01:32.200]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.200]                             "", base::R.version$version.string), 
[11:01:32.200]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.200]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.200]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.200]                               "release", "version")], collapse = " "), 
[11:01:32.200]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.200]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.200]                             info)
[11:01:32.200]                           info <- base::paste(info, collapse = "; ")
[11:01:32.200]                           if (!has_future) {
[11:01:32.200]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.200]                               info)
[11:01:32.200]                           }
[11:01:32.200]                           else {
[11:01:32.200]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.200]                               info, version)
[11:01:32.200]                           }
[11:01:32.200]                           base::stop(msg)
[11:01:32.200]                         }
[11:01:32.200]                       })
[11:01:32.200]                     }
[11:01:32.200]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.200]                     base::options(mc.cores = 1L)
[11:01:32.200]                   }
[11:01:32.200]                   ...future.strategy.old <- future::plan("list")
[11:01:32.200]                   options(future.plan = NULL)
[11:01:32.200]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.200]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.200]                 }
[11:01:32.200]                 ...future.workdir <- getwd()
[11:01:32.200]             }
[11:01:32.200]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.200]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.200]         }
[11:01:32.200]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.200]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.200]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.200]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.200]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.200]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.200]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.200]             base::names(...future.oldOptions))
[11:01:32.200]     }
[11:01:32.200]     if (FALSE) {
[11:01:32.200]     }
[11:01:32.200]     else {
[11:01:32.200]         if (TRUE) {
[11:01:32.200]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.200]                 open = "w")
[11:01:32.200]         }
[11:01:32.200]         else {
[11:01:32.200]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.200]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.200]         }
[11:01:32.200]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.200]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.200]             base::sink(type = "output", split = FALSE)
[11:01:32.200]             base::close(...future.stdout)
[11:01:32.200]         }, add = TRUE)
[11:01:32.200]     }
[11:01:32.200]     ...future.frame <- base::sys.nframe()
[11:01:32.200]     ...future.conditions <- base::list()
[11:01:32.200]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.200]     if (FALSE) {
[11:01:32.200]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.200]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.200]     }
[11:01:32.200]     ...future.result <- base::tryCatch({
[11:01:32.200]         base::withCallingHandlers({
[11:01:32.200]             ...future.value <- base::withVisible(base::local({
[11:01:32.200]                 withCallingHandlers({
[11:01:32.200]                   {
[11:01:32.200]                     4
[11:01:32.200]                   }
[11:01:32.200]                 }, immediateCondition = function(cond) {
[11:01:32.200]                   save_rds <- function (object, pathname, ...) 
[11:01:32.200]                   {
[11:01:32.200]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.200]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.200]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.200]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.200]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.200]                         fi_tmp[["mtime"]])
[11:01:32.200]                     }
[11:01:32.200]                     tryCatch({
[11:01:32.200]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.200]                     }, error = function(ex) {
[11:01:32.200]                       msg <- conditionMessage(ex)
[11:01:32.200]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.200]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.200]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.200]                         fi_tmp[["mtime"]], msg)
[11:01:32.200]                       ex$message <- msg
[11:01:32.200]                       stop(ex)
[11:01:32.200]                     })
[11:01:32.200]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.200]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.200]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.200]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.200]                       fi <- file.info(pathname)
[11:01:32.200]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.200]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.200]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.200]                         fi[["size"]], fi[["mtime"]])
[11:01:32.200]                       stop(msg)
[11:01:32.200]                     }
[11:01:32.200]                     invisible(pathname)
[11:01:32.200]                   }
[11:01:32.200]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.200]                     rootPath = tempdir()) 
[11:01:32.200]                   {
[11:01:32.200]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.200]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.200]                       tmpdir = path, fileext = ".rds")
[11:01:32.200]                     save_rds(obj, file)
[11:01:32.200]                   }
[11:01:32.200]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.200]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.200]                   {
[11:01:32.200]                     inherits <- base::inherits
[11:01:32.200]                     invokeRestart <- base::invokeRestart
[11:01:32.200]                     is.null <- base::is.null
[11:01:32.200]                     muffled <- FALSE
[11:01:32.200]                     if (inherits(cond, "message")) {
[11:01:32.200]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.200]                       if (muffled) 
[11:01:32.200]                         invokeRestart("muffleMessage")
[11:01:32.200]                     }
[11:01:32.200]                     else if (inherits(cond, "warning")) {
[11:01:32.200]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.200]                       if (muffled) 
[11:01:32.200]                         invokeRestart("muffleWarning")
[11:01:32.200]                     }
[11:01:32.200]                     else if (inherits(cond, "condition")) {
[11:01:32.200]                       if (!is.null(pattern)) {
[11:01:32.200]                         computeRestarts <- base::computeRestarts
[11:01:32.200]                         grepl <- base::grepl
[11:01:32.200]                         restarts <- computeRestarts(cond)
[11:01:32.200]                         for (restart in restarts) {
[11:01:32.200]                           name <- restart$name
[11:01:32.200]                           if (is.null(name)) 
[11:01:32.200]                             next
[11:01:32.200]                           if (!grepl(pattern, name)) 
[11:01:32.200]                             next
[11:01:32.200]                           invokeRestart(restart)
[11:01:32.200]                           muffled <- TRUE
[11:01:32.200]                           break
[11:01:32.200]                         }
[11:01:32.200]                       }
[11:01:32.200]                     }
[11:01:32.200]                     invisible(muffled)
[11:01:32.200]                   }
[11:01:32.200]                   muffleCondition(cond)
[11:01:32.200]                 })
[11:01:32.200]             }))
[11:01:32.200]             future::FutureResult(value = ...future.value$value, 
[11:01:32.200]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.200]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.200]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.200]                     ...future.globalenv.names))
[11:01:32.200]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.200]         }, condition = base::local({
[11:01:32.200]             c <- base::c
[11:01:32.200]             inherits <- base::inherits
[11:01:32.200]             invokeRestart <- base::invokeRestart
[11:01:32.200]             length <- base::length
[11:01:32.200]             list <- base::list
[11:01:32.200]             seq.int <- base::seq.int
[11:01:32.200]             signalCondition <- base::signalCondition
[11:01:32.200]             sys.calls <- base::sys.calls
[11:01:32.200]             `[[` <- base::`[[`
[11:01:32.200]             `+` <- base::`+`
[11:01:32.200]             `<<-` <- base::`<<-`
[11:01:32.200]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.200]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.200]                   3L)]
[11:01:32.200]             }
[11:01:32.200]             function(cond) {
[11:01:32.200]                 is_error <- inherits(cond, "error")
[11:01:32.200]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.200]                   NULL)
[11:01:32.200]                 if (is_error) {
[11:01:32.200]                   sessionInformation <- function() {
[11:01:32.200]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.200]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.200]                       search = base::search(), system = base::Sys.info())
[11:01:32.200]                   }
[11:01:32.200]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.200]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.200]                     cond$call), session = sessionInformation(), 
[11:01:32.200]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.200]                   signalCondition(cond)
[11:01:32.200]                 }
[11:01:32.200]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.200]                 "immediateCondition"))) {
[11:01:32.200]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.200]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.200]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.200]                   if (TRUE && !signal) {
[11:01:32.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.200]                     {
[11:01:32.200]                       inherits <- base::inherits
[11:01:32.200]                       invokeRestart <- base::invokeRestart
[11:01:32.200]                       is.null <- base::is.null
[11:01:32.200]                       muffled <- FALSE
[11:01:32.200]                       if (inherits(cond, "message")) {
[11:01:32.200]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.200]                         if (muffled) 
[11:01:32.200]                           invokeRestart("muffleMessage")
[11:01:32.200]                       }
[11:01:32.200]                       else if (inherits(cond, "warning")) {
[11:01:32.200]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.200]                         if (muffled) 
[11:01:32.200]                           invokeRestart("muffleWarning")
[11:01:32.200]                       }
[11:01:32.200]                       else if (inherits(cond, "condition")) {
[11:01:32.200]                         if (!is.null(pattern)) {
[11:01:32.200]                           computeRestarts <- base::computeRestarts
[11:01:32.200]                           grepl <- base::grepl
[11:01:32.200]                           restarts <- computeRestarts(cond)
[11:01:32.200]                           for (restart in restarts) {
[11:01:32.200]                             name <- restart$name
[11:01:32.200]                             if (is.null(name)) 
[11:01:32.200]                               next
[11:01:32.200]                             if (!grepl(pattern, name)) 
[11:01:32.200]                               next
[11:01:32.200]                             invokeRestart(restart)
[11:01:32.200]                             muffled <- TRUE
[11:01:32.200]                             break
[11:01:32.200]                           }
[11:01:32.200]                         }
[11:01:32.200]                       }
[11:01:32.200]                       invisible(muffled)
[11:01:32.200]                     }
[11:01:32.200]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.200]                   }
[11:01:32.200]                 }
[11:01:32.200]                 else {
[11:01:32.200]                   if (TRUE) {
[11:01:32.200]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.200]                     {
[11:01:32.200]                       inherits <- base::inherits
[11:01:32.200]                       invokeRestart <- base::invokeRestart
[11:01:32.200]                       is.null <- base::is.null
[11:01:32.200]                       muffled <- FALSE
[11:01:32.200]                       if (inherits(cond, "message")) {
[11:01:32.200]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.200]                         if (muffled) 
[11:01:32.200]                           invokeRestart("muffleMessage")
[11:01:32.200]                       }
[11:01:32.200]                       else if (inherits(cond, "warning")) {
[11:01:32.200]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.200]                         if (muffled) 
[11:01:32.200]                           invokeRestart("muffleWarning")
[11:01:32.200]                       }
[11:01:32.200]                       else if (inherits(cond, "condition")) {
[11:01:32.200]                         if (!is.null(pattern)) {
[11:01:32.200]                           computeRestarts <- base::computeRestarts
[11:01:32.200]                           grepl <- base::grepl
[11:01:32.200]                           restarts <- computeRestarts(cond)
[11:01:32.200]                           for (restart in restarts) {
[11:01:32.200]                             name <- restart$name
[11:01:32.200]                             if (is.null(name)) 
[11:01:32.200]                               next
[11:01:32.200]                             if (!grepl(pattern, name)) 
[11:01:32.200]                               next
[11:01:32.200]                             invokeRestart(restart)
[11:01:32.200]                             muffled <- TRUE
[11:01:32.200]                             break
[11:01:32.200]                           }
[11:01:32.200]                         }
[11:01:32.200]                       }
[11:01:32.200]                       invisible(muffled)
[11:01:32.200]                     }
[11:01:32.200]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.200]                   }
[11:01:32.200]                 }
[11:01:32.200]             }
[11:01:32.200]         }))
[11:01:32.200]     }, error = function(ex) {
[11:01:32.200]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.200]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.200]                 ...future.rng), started = ...future.startTime, 
[11:01:32.200]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.200]             version = "1.8"), class = "FutureResult")
[11:01:32.200]     }, finally = {
[11:01:32.200]         if (!identical(...future.workdir, getwd())) 
[11:01:32.200]             setwd(...future.workdir)
[11:01:32.200]         {
[11:01:32.200]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.200]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.200]             }
[11:01:32.200]             base::options(...future.oldOptions)
[11:01:32.200]             if (.Platform$OS.type == "windows") {
[11:01:32.200]                 old_names <- names(...future.oldEnvVars)
[11:01:32.200]                 envs <- base::Sys.getenv()
[11:01:32.200]                 names <- names(envs)
[11:01:32.200]                 common <- intersect(names, old_names)
[11:01:32.200]                 added <- setdiff(names, old_names)
[11:01:32.200]                 removed <- setdiff(old_names, names)
[11:01:32.200]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.200]                   envs[common]]
[11:01:32.200]                 NAMES <- toupper(changed)
[11:01:32.200]                 args <- list()
[11:01:32.200]                 for (kk in seq_along(NAMES)) {
[11:01:32.200]                   name <- changed[[kk]]
[11:01:32.200]                   NAME <- NAMES[[kk]]
[11:01:32.200]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.200]                     next
[11:01:32.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.200]                 }
[11:01:32.200]                 NAMES <- toupper(added)
[11:01:32.200]                 for (kk in seq_along(NAMES)) {
[11:01:32.200]                   name <- added[[kk]]
[11:01:32.200]                   NAME <- NAMES[[kk]]
[11:01:32.200]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.200]                     next
[11:01:32.200]                   args[[name]] <- ""
[11:01:32.200]                 }
[11:01:32.200]                 NAMES <- toupper(removed)
[11:01:32.200]                 for (kk in seq_along(NAMES)) {
[11:01:32.200]                   name <- removed[[kk]]
[11:01:32.200]                   NAME <- NAMES[[kk]]
[11:01:32.200]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.200]                     next
[11:01:32.200]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.200]                 }
[11:01:32.200]                 if (length(args) > 0) 
[11:01:32.200]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.200]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.200]             }
[11:01:32.200]             else {
[11:01:32.200]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.200]             }
[11:01:32.200]             {
[11:01:32.200]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.200]                   0L) {
[11:01:32.200]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.200]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.200]                   base::options(opts)
[11:01:32.200]                 }
[11:01:32.200]                 {
[11:01:32.200]                   {
[11:01:32.200]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.200]                     NULL
[11:01:32.200]                   }
[11:01:32.200]                   options(future.plan = NULL)
[11:01:32.200]                   if (is.na(NA_character_)) 
[11:01:32.200]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.200]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.200]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.200]                     .init = FALSE)
[11:01:32.200]                 }
[11:01:32.200]             }
[11:01:32.200]         }
[11:01:32.200]     })
[11:01:32.200]     if (TRUE) {
[11:01:32.200]         base::sink(type = "output", split = FALSE)
[11:01:32.200]         if (TRUE) {
[11:01:32.200]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.200]         }
[11:01:32.200]         else {
[11:01:32.200]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.200]         }
[11:01:32.200]         base::close(...future.stdout)
[11:01:32.200]         ...future.stdout <- NULL
[11:01:32.200]     }
[11:01:32.200]     ...future.result$conditions <- ...future.conditions
[11:01:32.200]     ...future.result$finished <- base::Sys.time()
[11:01:32.200]     ...future.result
[11:01:32.200] }
[11:01:32.203] requestCore(): workers = 2
[11:01:32.203] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:32.214] result() for MulticoreFuture ...
[11:01:32.215] result() for MulticoreFuture ...
[11:01:32.215] result() for MulticoreFuture ... done
[11:01:32.215] result() for MulticoreFuture ... done
[11:01:32.215] result() for MulticoreFuture ...
[11:01:32.215] result() for MulticoreFuture ... done
[11:01:32.218] MulticoreFuture started
[11:01:32.218] - Launch lazy future ... done
[11:01:32.218] run() for ‘MulticoreFuture’ ... done
[11:01:32.219] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a9c8070b38> 
[11:01:32.219] List of future strategies:
[11:01:32.219] 1. sequential:
[11:01:32.219]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.219]    - tweaked: FALSE
[11:01:32.219]    - call: NULL
[11:01:32.221] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55a9c8bb0c68> 
[11:01:32.223] plan(): Setting new future strategy stack:
[11:01:32.224] List of future strategies:
[11:01:32.224] 1. multicore:
[11:01:32.224]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.224]    - tweaked: FALSE
[11:01:32.224]    - call: plan(strategy)
[11:01:32.227] plan(): nbrOfWorkers() = 2
 Named logi [1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:32.230] resolve() on list environment ...
[11:01:32.230]  recursive: 0
[11:01:32.239]  length: 6
[11:01:32.239]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:32.240] signalConditionsASAP(numeric, pos=1) ...
[11:01:32.240] - nx: 6
[11:01:32.241] - relay: TRUE
[11:01:32.241] - stdout: TRUE
[11:01:32.241] - signal: TRUE
[11:01:32.242] - resignal: FALSE
[11:01:32.242] - force: TRUE
[11:01:32.242] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.242] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.243]  - until=2
[11:01:32.243]  - relaying element #2
[11:01:32.243] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.243] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.243] signalConditionsASAP(NULL, pos=1) ... done
[11:01:32.243]  length: 5 (resolved future 1)
[11:01:32.243] Future #2
[11:01:32.244] result() for MulticoreFuture ...
[11:01:32.244] result() for MulticoreFuture ... done
[11:01:32.244] result() for MulticoreFuture ...
[11:01:32.244] result() for MulticoreFuture ... done
[11:01:32.244] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:32.244] - nx: 6
[11:01:32.244] - relay: TRUE
[11:01:32.245] - stdout: TRUE
[11:01:32.245] - signal: TRUE
[11:01:32.245] - resignal: FALSE
[11:01:32.245] - force: TRUE
[11:01:32.245] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.245] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.245]  - until=2
[11:01:32.245]  - relaying element #2
[11:01:32.246] result() for MulticoreFuture ...
[11:01:32.246] result() for MulticoreFuture ... done
[11:01:32.246] result() for MulticoreFuture ...
[11:01:32.246] result() for MulticoreFuture ... done
[11:01:32.246] result() for MulticoreFuture ...
[11:01:32.246] result() for MulticoreFuture ... done
[11:01:32.246] result() for MulticoreFuture ...
[11:01:32.246] result() for MulticoreFuture ... done
[11:01:32.247] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.247] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.247] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:32.247]  length: 4 (resolved future 2)
[11:01:32.247] Future #3
[11:01:32.248] result() for MulticoreFuture ...
[11:01:32.248] result() for MulticoreFuture ...
[11:01:32.249] result() for MulticoreFuture ... done
[11:01:32.249] result() for MulticoreFuture ... done
[11:01:32.249] result() for MulticoreFuture ...
[11:01:32.249] result() for MulticoreFuture ... done
[11:01:32.249] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:32.249] - nx: 6
[11:01:32.249] - relay: TRUE
[11:01:32.249] - stdout: TRUE
[11:01:32.250] - signal: TRUE
[11:01:32.250] - resignal: FALSE
[11:01:32.250] - force: TRUE
[11:01:32.250] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.250] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.250]  - until=3
[11:01:32.250]  - relaying element #3
[11:01:32.250] result() for MulticoreFuture ...
[11:01:32.250] result() for MulticoreFuture ... done
[11:01:32.251] result() for MulticoreFuture ...
[11:01:32.251] result() for MulticoreFuture ... done
[11:01:32.251] result() for MulticoreFuture ...
[11:01:32.251] result() for MulticoreFuture ... done
[11:01:32.251] result() for MulticoreFuture ...
[11:01:32.251] result() for MulticoreFuture ... done
[11:01:32.251] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.251] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.252] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:32.252]  length: 3 (resolved future 3)
[11:01:32.252] Future #4
[11:01:32.252] result() for MulticoreFuture ...
[11:01:32.253] result() for MulticoreFuture ...
[11:01:32.253] result() for MulticoreFuture ... done
[11:01:32.253] result() for MulticoreFuture ... done
[11:01:32.253] result() for MulticoreFuture ...
[11:01:32.253] result() for MulticoreFuture ... done
[11:01:32.254] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:32.254] - nx: 6
[11:01:32.254] - relay: TRUE
[11:01:32.254] - stdout: TRUE
[11:01:32.254] - signal: TRUE
[11:01:32.254] - resignal: FALSE
[11:01:32.255] - force: TRUE
[11:01:32.255] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.255] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.255]  - until=4
[11:01:32.255]  - relaying element #4
[11:01:32.255] result() for MulticoreFuture ...
[11:01:32.255] result() for MulticoreFuture ... done
[11:01:32.256] result() for MulticoreFuture ...
[11:01:32.256] result() for MulticoreFuture ... done
[11:01:32.256] result() for MulticoreFuture ...
[11:01:32.256] result() for MulticoreFuture ... done
[11:01:32.256] result() for MulticoreFuture ...
[11:01:32.256] result() for MulticoreFuture ... done
[11:01:32.257] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.257] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.257] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:32.257]  length: 2 (resolved future 4)
[11:01:32.257] signalConditionsASAP(NULL, pos=5) ...
[11:01:32.257] - nx: 6
[11:01:32.257] - relay: TRUE
[11:01:32.258] - stdout: TRUE
[11:01:32.258] - signal: TRUE
[11:01:32.258] - resignal: FALSE
[11:01:32.258] - force: TRUE
[11:01:32.258] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.258] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.258]  - until=6
[11:01:32.258]  - relaying element #6
[11:01:32.258] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.259] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.259] signalConditionsASAP(NULL, pos=5) ... done
[11:01:32.259]  length: 1 (resolved future 5)
[11:01:32.259] signalConditionsASAP(numeric, pos=6) ...
[11:01:32.259] - nx: 6
[11:01:32.259] - relay: TRUE
[11:01:32.259] - stdout: TRUE
[11:01:32.259] - signal: TRUE
[11:01:32.259] - resignal: FALSE
[11:01:32.259] - force: TRUE
[11:01:32.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.260] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.260]  - until=6
[11:01:32.260] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.260] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.260] signalConditionsASAP(numeric, pos=6) ... done
[11:01:32.260]  length: 0 (resolved future 6)
[11:01:32.260] Relaying remaining futures
[11:01:32.260] signalConditionsASAP(NULL, pos=0) ...
[11:01:32.260] - nx: 6
[11:01:32.260] - relay: TRUE
[11:01:32.261] - stdout: TRUE
[11:01:32.261] - signal: TRUE
[11:01:32.261] - resignal: FALSE
[11:01:32.261] - force: TRUE
[11:01:32.261] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.261] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:32.261] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.261] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.261] signalConditionsASAP(NULL, pos=0) ... done
[11:01:32.261] resolve() on list environment ... DONE
[11:01:32.262] result() for MulticoreFuture ...
[11:01:32.262] result() for MulticoreFuture ... done
[11:01:32.262] result() for MulticoreFuture ...
[11:01:32.262] result() for MulticoreFuture ... done
[11:01:32.262] result() for MulticoreFuture ...
[11:01:32.262] result() for MulticoreFuture ... done
[11:01:32.262] result() for MulticoreFuture ...
[11:01:32.262] result() for MulticoreFuture ... done
[11:01:32.263] result() for MulticoreFuture ...
[11:01:32.263] result() for MulticoreFuture ... done
[11:01:32.263] result() for MulticoreFuture ...
[11:01:32.263] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c8dbc908> 
Dimensions: c(1, 6)
[11:01:32.264] getGlobalsAndPackages() ...
[11:01:32.264] Searching for globals...
[11:01:32.264] 
[11:01:32.264] Searching for globals ... DONE
[11:01:32.265] - globals: [0] <none>
[11:01:32.265] getGlobalsAndPackages() ... DONE
[11:01:32.265] run() for ‘Future’ ...
[11:01:32.265] - state: ‘created’
[11:01:32.265] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.267] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.267] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.268]   - Field: ‘label’
[11:01:32.268]   - Field: ‘local’
[11:01:32.268]   - Field: ‘owner’
[11:01:32.268]   - Field: ‘envir’
[11:01:32.268]   - Field: ‘workers’
[11:01:32.268]   - Field: ‘packages’
[11:01:32.268]   - Field: ‘gc’
[11:01:32.268]   - Field: ‘job’
[11:01:32.268]   - Field: ‘conditions’
[11:01:32.269]   - Field: ‘expr’
[11:01:32.269]   - Field: ‘uuid’
[11:01:32.269]   - Field: ‘seed’
[11:01:32.269]   - Field: ‘version’
[11:01:32.269]   - Field: ‘result’
[11:01:32.269]   - Field: ‘asynchronous’
[11:01:32.269]   - Field: ‘calls’
[11:01:32.269]   - Field: ‘globals’
[11:01:32.269]   - Field: ‘stdout’
[11:01:32.270]   - Field: ‘earlySignal’
[11:01:32.270]   - Field: ‘lazy’
[11:01:32.270]   - Field: ‘state’
[11:01:32.270] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.270] - Launch lazy future ...
[11:01:32.270] Packages needed by the future expression (n = 0): <none>
[11:01:32.271] Packages needed by future strategies (n = 0): <none>
[11:01:32.271] {
[11:01:32.271]     {
[11:01:32.271]         {
[11:01:32.271]             ...future.startTime <- base::Sys.time()
[11:01:32.271]             {
[11:01:32.271]                 {
[11:01:32.271]                   {
[11:01:32.271]                     {
[11:01:32.271]                       base::local({
[11:01:32.271]                         has_future <- base::requireNamespace("future", 
[11:01:32.271]                           quietly = TRUE)
[11:01:32.271]                         if (has_future) {
[11:01:32.271]                           ns <- base::getNamespace("future")
[11:01:32.271]                           version <- ns[[".package"]][["version"]]
[11:01:32.271]                           if (is.null(version)) 
[11:01:32.271]                             version <- utils::packageVersion("future")
[11:01:32.271]                         }
[11:01:32.271]                         else {
[11:01:32.271]                           version <- NULL
[11:01:32.271]                         }
[11:01:32.271]                         if (!has_future || version < "1.8.0") {
[11:01:32.271]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.271]                             "", base::R.version$version.string), 
[11:01:32.271]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.271]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.271]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.271]                               "release", "version")], collapse = " "), 
[11:01:32.271]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.271]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.271]                             info)
[11:01:32.271]                           info <- base::paste(info, collapse = "; ")
[11:01:32.271]                           if (!has_future) {
[11:01:32.271]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.271]                               info)
[11:01:32.271]                           }
[11:01:32.271]                           else {
[11:01:32.271]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.271]                               info, version)
[11:01:32.271]                           }
[11:01:32.271]                           base::stop(msg)
[11:01:32.271]                         }
[11:01:32.271]                       })
[11:01:32.271]                     }
[11:01:32.271]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.271]                     base::options(mc.cores = 1L)
[11:01:32.271]                   }
[11:01:32.271]                   ...future.strategy.old <- future::plan("list")
[11:01:32.271]                   options(future.plan = NULL)
[11:01:32.271]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.271]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.271]                 }
[11:01:32.271]                 ...future.workdir <- getwd()
[11:01:32.271]             }
[11:01:32.271]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.271]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.271]         }
[11:01:32.271]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.271]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.271]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.271]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.271]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.271]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.271]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.271]             base::names(...future.oldOptions))
[11:01:32.271]     }
[11:01:32.271]     if (FALSE) {
[11:01:32.271]     }
[11:01:32.271]     else {
[11:01:32.271]         if (TRUE) {
[11:01:32.271]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.271]                 open = "w")
[11:01:32.271]         }
[11:01:32.271]         else {
[11:01:32.271]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.271]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.271]         }
[11:01:32.271]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.271]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.271]             base::sink(type = "output", split = FALSE)
[11:01:32.271]             base::close(...future.stdout)
[11:01:32.271]         }, add = TRUE)
[11:01:32.271]     }
[11:01:32.271]     ...future.frame <- base::sys.nframe()
[11:01:32.271]     ...future.conditions <- base::list()
[11:01:32.271]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.271]     if (FALSE) {
[11:01:32.271]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.271]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.271]     }
[11:01:32.271]     ...future.result <- base::tryCatch({
[11:01:32.271]         base::withCallingHandlers({
[11:01:32.271]             ...future.value <- base::withVisible(base::local({
[11:01:32.271]                 withCallingHandlers({
[11:01:32.271]                   2
[11:01:32.271]                 }, immediateCondition = function(cond) {
[11:01:32.271]                   save_rds <- function (object, pathname, ...) 
[11:01:32.271]                   {
[11:01:32.271]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.271]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.271]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.271]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.271]                         fi_tmp[["mtime"]])
[11:01:32.271]                     }
[11:01:32.271]                     tryCatch({
[11:01:32.271]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.271]                     }, error = function(ex) {
[11:01:32.271]                       msg <- conditionMessage(ex)
[11:01:32.271]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.271]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.271]                         fi_tmp[["mtime"]], msg)
[11:01:32.271]                       ex$message <- msg
[11:01:32.271]                       stop(ex)
[11:01:32.271]                     })
[11:01:32.271]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.271]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.271]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.271]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.271]                       fi <- file.info(pathname)
[11:01:32.271]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.271]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.271]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.271]                         fi[["size"]], fi[["mtime"]])
[11:01:32.271]                       stop(msg)
[11:01:32.271]                     }
[11:01:32.271]                     invisible(pathname)
[11:01:32.271]                   }
[11:01:32.271]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.271]                     rootPath = tempdir()) 
[11:01:32.271]                   {
[11:01:32.271]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.271]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.271]                       tmpdir = path, fileext = ".rds")
[11:01:32.271]                     save_rds(obj, file)
[11:01:32.271]                   }
[11:01:32.271]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.271]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.271]                   {
[11:01:32.271]                     inherits <- base::inherits
[11:01:32.271]                     invokeRestart <- base::invokeRestart
[11:01:32.271]                     is.null <- base::is.null
[11:01:32.271]                     muffled <- FALSE
[11:01:32.271]                     if (inherits(cond, "message")) {
[11:01:32.271]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.271]                       if (muffled) 
[11:01:32.271]                         invokeRestart("muffleMessage")
[11:01:32.271]                     }
[11:01:32.271]                     else if (inherits(cond, "warning")) {
[11:01:32.271]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.271]                       if (muffled) 
[11:01:32.271]                         invokeRestart("muffleWarning")
[11:01:32.271]                     }
[11:01:32.271]                     else if (inherits(cond, "condition")) {
[11:01:32.271]                       if (!is.null(pattern)) {
[11:01:32.271]                         computeRestarts <- base::computeRestarts
[11:01:32.271]                         grepl <- base::grepl
[11:01:32.271]                         restarts <- computeRestarts(cond)
[11:01:32.271]                         for (restart in restarts) {
[11:01:32.271]                           name <- restart$name
[11:01:32.271]                           if (is.null(name)) 
[11:01:32.271]                             next
[11:01:32.271]                           if (!grepl(pattern, name)) 
[11:01:32.271]                             next
[11:01:32.271]                           invokeRestart(restart)
[11:01:32.271]                           muffled <- TRUE
[11:01:32.271]                           break
[11:01:32.271]                         }
[11:01:32.271]                       }
[11:01:32.271]                     }
[11:01:32.271]                     invisible(muffled)
[11:01:32.271]                   }
[11:01:32.271]                   muffleCondition(cond)
[11:01:32.271]                 })
[11:01:32.271]             }))
[11:01:32.271]             future::FutureResult(value = ...future.value$value, 
[11:01:32.271]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.271]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.271]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.271]                     ...future.globalenv.names))
[11:01:32.271]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.271]         }, condition = base::local({
[11:01:32.271]             c <- base::c
[11:01:32.271]             inherits <- base::inherits
[11:01:32.271]             invokeRestart <- base::invokeRestart
[11:01:32.271]             length <- base::length
[11:01:32.271]             list <- base::list
[11:01:32.271]             seq.int <- base::seq.int
[11:01:32.271]             signalCondition <- base::signalCondition
[11:01:32.271]             sys.calls <- base::sys.calls
[11:01:32.271]             `[[` <- base::`[[`
[11:01:32.271]             `+` <- base::`+`
[11:01:32.271]             `<<-` <- base::`<<-`
[11:01:32.271]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.271]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.271]                   3L)]
[11:01:32.271]             }
[11:01:32.271]             function(cond) {
[11:01:32.271]                 is_error <- inherits(cond, "error")
[11:01:32.271]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.271]                   NULL)
[11:01:32.271]                 if (is_error) {
[11:01:32.271]                   sessionInformation <- function() {
[11:01:32.271]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.271]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.271]                       search = base::search(), system = base::Sys.info())
[11:01:32.271]                   }
[11:01:32.271]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.271]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.271]                     cond$call), session = sessionInformation(), 
[11:01:32.271]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.271]                   signalCondition(cond)
[11:01:32.271]                 }
[11:01:32.271]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.271]                 "immediateCondition"))) {
[11:01:32.271]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.271]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.271]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.271]                   if (TRUE && !signal) {
[11:01:32.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.271]                     {
[11:01:32.271]                       inherits <- base::inherits
[11:01:32.271]                       invokeRestart <- base::invokeRestart
[11:01:32.271]                       is.null <- base::is.null
[11:01:32.271]                       muffled <- FALSE
[11:01:32.271]                       if (inherits(cond, "message")) {
[11:01:32.271]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.271]                         if (muffled) 
[11:01:32.271]                           invokeRestart("muffleMessage")
[11:01:32.271]                       }
[11:01:32.271]                       else if (inherits(cond, "warning")) {
[11:01:32.271]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.271]                         if (muffled) 
[11:01:32.271]                           invokeRestart("muffleWarning")
[11:01:32.271]                       }
[11:01:32.271]                       else if (inherits(cond, "condition")) {
[11:01:32.271]                         if (!is.null(pattern)) {
[11:01:32.271]                           computeRestarts <- base::computeRestarts
[11:01:32.271]                           grepl <- base::grepl
[11:01:32.271]                           restarts <- computeRestarts(cond)
[11:01:32.271]                           for (restart in restarts) {
[11:01:32.271]                             name <- restart$name
[11:01:32.271]                             if (is.null(name)) 
[11:01:32.271]                               next
[11:01:32.271]                             if (!grepl(pattern, name)) 
[11:01:32.271]                               next
[11:01:32.271]                             invokeRestart(restart)
[11:01:32.271]                             muffled <- TRUE
[11:01:32.271]                             break
[11:01:32.271]                           }
[11:01:32.271]                         }
[11:01:32.271]                       }
[11:01:32.271]                       invisible(muffled)
[11:01:32.271]                     }
[11:01:32.271]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.271]                   }
[11:01:32.271]                 }
[11:01:32.271]                 else {
[11:01:32.271]                   if (TRUE) {
[11:01:32.271]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.271]                     {
[11:01:32.271]                       inherits <- base::inherits
[11:01:32.271]                       invokeRestart <- base::invokeRestart
[11:01:32.271]                       is.null <- base::is.null
[11:01:32.271]                       muffled <- FALSE
[11:01:32.271]                       if (inherits(cond, "message")) {
[11:01:32.271]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.271]                         if (muffled) 
[11:01:32.271]                           invokeRestart("muffleMessage")
[11:01:32.271]                       }
[11:01:32.271]                       else if (inherits(cond, "warning")) {
[11:01:32.271]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.271]                         if (muffled) 
[11:01:32.271]                           invokeRestart("muffleWarning")
[11:01:32.271]                       }
[11:01:32.271]                       else if (inherits(cond, "condition")) {
[11:01:32.271]                         if (!is.null(pattern)) {
[11:01:32.271]                           computeRestarts <- base::computeRestarts
[11:01:32.271]                           grepl <- base::grepl
[11:01:32.271]                           restarts <- computeRestarts(cond)
[11:01:32.271]                           for (restart in restarts) {
[11:01:32.271]                             name <- restart$name
[11:01:32.271]                             if (is.null(name)) 
[11:01:32.271]                               next
[11:01:32.271]                             if (!grepl(pattern, name)) 
[11:01:32.271]                               next
[11:01:32.271]                             invokeRestart(restart)
[11:01:32.271]                             muffled <- TRUE
[11:01:32.271]                             break
[11:01:32.271]                           }
[11:01:32.271]                         }
[11:01:32.271]                       }
[11:01:32.271]                       invisible(muffled)
[11:01:32.271]                     }
[11:01:32.271]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.271]                   }
[11:01:32.271]                 }
[11:01:32.271]             }
[11:01:32.271]         }))
[11:01:32.271]     }, error = function(ex) {
[11:01:32.271]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.271]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.271]                 ...future.rng), started = ...future.startTime, 
[11:01:32.271]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.271]             version = "1.8"), class = "FutureResult")
[11:01:32.271]     }, finally = {
[11:01:32.271]         if (!identical(...future.workdir, getwd())) 
[11:01:32.271]             setwd(...future.workdir)
[11:01:32.271]         {
[11:01:32.271]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.271]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.271]             }
[11:01:32.271]             base::options(...future.oldOptions)
[11:01:32.271]             if (.Platform$OS.type == "windows") {
[11:01:32.271]                 old_names <- names(...future.oldEnvVars)
[11:01:32.271]                 envs <- base::Sys.getenv()
[11:01:32.271]                 names <- names(envs)
[11:01:32.271]                 common <- intersect(names, old_names)
[11:01:32.271]                 added <- setdiff(names, old_names)
[11:01:32.271]                 removed <- setdiff(old_names, names)
[11:01:32.271]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.271]                   envs[common]]
[11:01:32.271]                 NAMES <- toupper(changed)
[11:01:32.271]                 args <- list()
[11:01:32.271]                 for (kk in seq_along(NAMES)) {
[11:01:32.271]                   name <- changed[[kk]]
[11:01:32.271]                   NAME <- NAMES[[kk]]
[11:01:32.271]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.271]                     next
[11:01:32.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.271]                 }
[11:01:32.271]                 NAMES <- toupper(added)
[11:01:32.271]                 for (kk in seq_along(NAMES)) {
[11:01:32.271]                   name <- added[[kk]]
[11:01:32.271]                   NAME <- NAMES[[kk]]
[11:01:32.271]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.271]                     next
[11:01:32.271]                   args[[name]] <- ""
[11:01:32.271]                 }
[11:01:32.271]                 NAMES <- toupper(removed)
[11:01:32.271]                 for (kk in seq_along(NAMES)) {
[11:01:32.271]                   name <- removed[[kk]]
[11:01:32.271]                   NAME <- NAMES[[kk]]
[11:01:32.271]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.271]                     next
[11:01:32.271]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.271]                 }
[11:01:32.271]                 if (length(args) > 0) 
[11:01:32.271]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.271]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.271]             }
[11:01:32.271]             else {
[11:01:32.271]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.271]             }
[11:01:32.271]             {
[11:01:32.271]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.271]                   0L) {
[11:01:32.271]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.271]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.271]                   base::options(opts)
[11:01:32.271]                 }
[11:01:32.271]                 {
[11:01:32.271]                   {
[11:01:32.271]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.271]                     NULL
[11:01:32.271]                   }
[11:01:32.271]                   options(future.plan = NULL)
[11:01:32.271]                   if (is.na(NA_character_)) 
[11:01:32.271]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.271]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.271]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.271]                     .init = FALSE)
[11:01:32.271]                 }
[11:01:32.271]             }
[11:01:32.271]         }
[11:01:32.271]     })
[11:01:32.271]     if (TRUE) {
[11:01:32.271]         base::sink(type = "output", split = FALSE)
[11:01:32.271]         if (TRUE) {
[11:01:32.271]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.271]         }
[11:01:32.271]         else {
[11:01:32.271]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.271]         }
[11:01:32.271]         base::close(...future.stdout)
[11:01:32.271]         ...future.stdout <- NULL
[11:01:32.271]     }
[11:01:32.271]     ...future.result$conditions <- ...future.conditions
[11:01:32.271]     ...future.result$finished <- base::Sys.time()
[11:01:32.271]     ...future.result
[11:01:32.271] }
[11:01:32.273] requestCore(): workers = 2
[11:01:32.276] MulticoreFuture started
[11:01:32.276] - Launch lazy future ... done
[11:01:32.276] run() for ‘MulticoreFuture’ ... done
[11:01:32.277] plan(): Setting new future strategy stack:
[11:01:32.277] getGlobalsAndPackages() ...
[11:01:32.277] Searching for globals...
[11:01:32.277] List of future strategies:
[11:01:32.277] 1. sequential:
[11:01:32.277]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.277]    - tweaked: FALSE
[11:01:32.277]    - call: NULL
[11:01:32.278] 
[11:01:32.278] plan(): nbrOfWorkers() = 1
[11:01:32.278] Searching for globals ... DONE
[11:01:32.278] - globals: [0] <none>
[11:01:32.278] getGlobalsAndPackages() ... DONE
[11:01:32.279] run() for ‘Future’ ...
[11:01:32.279] - state: ‘created’
[11:01:32.279] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.280] plan(): Setting new future strategy stack:
[11:01:32.280] List of future strategies:
[11:01:32.280] 1. multicore:
[11:01:32.280]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.280]    - tweaked: FALSE
[11:01:32.280]    - call: plan(strategy)
[11:01:32.282] plan(): nbrOfWorkers() = 2
[11:01:32.283] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.283] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.283]   - Field: ‘label’
[11:01:32.283]   - Field: ‘local’
[11:01:32.283]   - Field: ‘owner’
[11:01:32.283]   - Field: ‘envir’
[11:01:32.284]   - Field: ‘workers’
[11:01:32.284]   - Field: ‘packages’
[11:01:32.284]   - Field: ‘gc’
[11:01:32.284]   - Field: ‘job’
[11:01:32.284]   - Field: ‘conditions’
[11:01:32.284]   - Field: ‘expr’
[11:01:32.285]   - Field: ‘uuid’
[11:01:32.285]   - Field: ‘seed’
[11:01:32.285]   - Field: ‘version’
[11:01:32.285]   - Field: ‘result’
[11:01:32.285]   - Field: ‘asynchronous’
[11:01:32.285]   - Field: ‘calls’
[11:01:32.285]   - Field: ‘globals’
[11:01:32.286]   - Field: ‘stdout’
[11:01:32.286]   - Field: ‘earlySignal’
[11:01:32.286]   - Field: ‘lazy’
[11:01:32.286]   - Field: ‘state’
[11:01:32.286] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.286] - Launch lazy future ...
[11:01:32.287] Packages needed by the future expression (n = 0): <none>
[11:01:32.287] Packages needed by future strategies (n = 0): <none>
[11:01:32.288] {
[11:01:32.288]     {
[11:01:32.288]         {
[11:01:32.288]             ...future.startTime <- base::Sys.time()
[11:01:32.288]             {
[11:01:32.288]                 {
[11:01:32.288]                   {
[11:01:32.288]                     {
[11:01:32.288]                       base::local({
[11:01:32.288]                         has_future <- base::requireNamespace("future", 
[11:01:32.288]                           quietly = TRUE)
[11:01:32.288]                         if (has_future) {
[11:01:32.288]                           ns <- base::getNamespace("future")
[11:01:32.288]                           version <- ns[[".package"]][["version"]]
[11:01:32.288]                           if (is.null(version)) 
[11:01:32.288]                             version <- utils::packageVersion("future")
[11:01:32.288]                         }
[11:01:32.288]                         else {
[11:01:32.288]                           version <- NULL
[11:01:32.288]                         }
[11:01:32.288]                         if (!has_future || version < "1.8.0") {
[11:01:32.288]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.288]                             "", base::R.version$version.string), 
[11:01:32.288]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.288]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.288]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.288]                               "release", "version")], collapse = " "), 
[11:01:32.288]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.288]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.288]                             info)
[11:01:32.288]                           info <- base::paste(info, collapse = "; ")
[11:01:32.288]                           if (!has_future) {
[11:01:32.288]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.288]                               info)
[11:01:32.288]                           }
[11:01:32.288]                           else {
[11:01:32.288]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.288]                               info, version)
[11:01:32.288]                           }
[11:01:32.288]                           base::stop(msg)
[11:01:32.288]                         }
[11:01:32.288]                       })
[11:01:32.288]                     }
[11:01:32.288]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.288]                     base::options(mc.cores = 1L)
[11:01:32.288]                   }
[11:01:32.288]                   ...future.strategy.old <- future::plan("list")
[11:01:32.288]                   options(future.plan = NULL)
[11:01:32.288]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.288]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.288]                 }
[11:01:32.288]                 ...future.workdir <- getwd()
[11:01:32.288]             }
[11:01:32.288]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.288]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.288]         }
[11:01:32.288]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.288]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.288]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.288]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.288]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.288]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.288]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.288]             base::names(...future.oldOptions))
[11:01:32.288]     }
[11:01:32.288]     if (FALSE) {
[11:01:32.288]     }
[11:01:32.288]     else {
[11:01:32.288]         if (TRUE) {
[11:01:32.288]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.288]                 open = "w")
[11:01:32.288]         }
[11:01:32.288]         else {
[11:01:32.288]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.288]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.288]         }
[11:01:32.288]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.288]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.288]             base::sink(type = "output", split = FALSE)
[11:01:32.288]             base::close(...future.stdout)
[11:01:32.288]         }, add = TRUE)
[11:01:32.288]     }
[11:01:32.288]     ...future.frame <- base::sys.nframe()
[11:01:32.288]     ...future.conditions <- base::list()
[11:01:32.288]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.288]     if (FALSE) {
[11:01:32.288]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.288]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.288]     }
[11:01:32.288]     ...future.result <- base::tryCatch({
[11:01:32.288]         base::withCallingHandlers({
[11:01:32.288]             ...future.value <- base::withVisible(base::local({
[11:01:32.288]                 withCallingHandlers({
[11:01:32.288]                   NULL
[11:01:32.288]                 }, immediateCondition = function(cond) {
[11:01:32.288]                   save_rds <- function (object, pathname, ...) 
[11:01:32.288]                   {
[11:01:32.288]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.288]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.288]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.288]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.288]                         fi_tmp[["mtime"]])
[11:01:32.288]                     }
[11:01:32.288]                     tryCatch({
[11:01:32.288]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.288]                     }, error = function(ex) {
[11:01:32.288]                       msg <- conditionMessage(ex)
[11:01:32.288]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.288]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.288]                         fi_tmp[["mtime"]], msg)
[11:01:32.288]                       ex$message <- msg
[11:01:32.288]                       stop(ex)
[11:01:32.288]                     })
[11:01:32.288]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.288]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.288]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.288]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.288]                       fi <- file.info(pathname)
[11:01:32.288]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.288]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.288]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.288]                         fi[["size"]], fi[["mtime"]])
[11:01:32.288]                       stop(msg)
[11:01:32.288]                     }
[11:01:32.288]                     invisible(pathname)
[11:01:32.288]                   }
[11:01:32.288]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.288]                     rootPath = tempdir()) 
[11:01:32.288]                   {
[11:01:32.288]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.288]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.288]                       tmpdir = path, fileext = ".rds")
[11:01:32.288]                     save_rds(obj, file)
[11:01:32.288]                   }
[11:01:32.288]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.288]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.288]                   {
[11:01:32.288]                     inherits <- base::inherits
[11:01:32.288]                     invokeRestart <- base::invokeRestart
[11:01:32.288]                     is.null <- base::is.null
[11:01:32.288]                     muffled <- FALSE
[11:01:32.288]                     if (inherits(cond, "message")) {
[11:01:32.288]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.288]                       if (muffled) 
[11:01:32.288]                         invokeRestart("muffleMessage")
[11:01:32.288]                     }
[11:01:32.288]                     else if (inherits(cond, "warning")) {
[11:01:32.288]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.288]                       if (muffled) 
[11:01:32.288]                         invokeRestart("muffleWarning")
[11:01:32.288]                     }
[11:01:32.288]                     else if (inherits(cond, "condition")) {
[11:01:32.288]                       if (!is.null(pattern)) {
[11:01:32.288]                         computeRestarts <- base::computeRestarts
[11:01:32.288]                         grepl <- base::grepl
[11:01:32.288]                         restarts <- computeRestarts(cond)
[11:01:32.288]                         for (restart in restarts) {
[11:01:32.288]                           name <- restart$name
[11:01:32.288]                           if (is.null(name)) 
[11:01:32.288]                             next
[11:01:32.288]                           if (!grepl(pattern, name)) 
[11:01:32.288]                             next
[11:01:32.288]                           invokeRestart(restart)
[11:01:32.288]                           muffled <- TRUE
[11:01:32.288]                           break
[11:01:32.288]                         }
[11:01:32.288]                       }
[11:01:32.288]                     }
[11:01:32.288]                     invisible(muffled)
[11:01:32.288]                   }
[11:01:32.288]                   muffleCondition(cond)
[11:01:32.288]                 })
[11:01:32.288]             }))
[11:01:32.288]             future::FutureResult(value = ...future.value$value, 
[11:01:32.288]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.288]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.288]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.288]                     ...future.globalenv.names))
[11:01:32.288]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.288]         }, condition = base::local({
[11:01:32.288]             c <- base::c
[11:01:32.288]             inherits <- base::inherits
[11:01:32.288]             invokeRestart <- base::invokeRestart
[11:01:32.288]             length <- base::length
[11:01:32.288]             list <- base::list
[11:01:32.288]             seq.int <- base::seq.int
[11:01:32.288]             signalCondition <- base::signalCondition
[11:01:32.288]             sys.calls <- base::sys.calls
[11:01:32.288]             `[[` <- base::`[[`
[11:01:32.288]             `+` <- base::`+`
[11:01:32.288]             `<<-` <- base::`<<-`
[11:01:32.288]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.288]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.288]                   3L)]
[11:01:32.288]             }
[11:01:32.288]             function(cond) {
[11:01:32.288]                 is_error <- inherits(cond, "error")
[11:01:32.288]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.288]                   NULL)
[11:01:32.288]                 if (is_error) {
[11:01:32.288]                   sessionInformation <- function() {
[11:01:32.288]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.288]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.288]                       search = base::search(), system = base::Sys.info())
[11:01:32.288]                   }
[11:01:32.288]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.288]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.288]                     cond$call), session = sessionInformation(), 
[11:01:32.288]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.288]                   signalCondition(cond)
[11:01:32.288]                 }
[11:01:32.288]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.288]                 "immediateCondition"))) {
[11:01:32.288]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.288]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.288]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.288]                   if (TRUE && !signal) {
[11:01:32.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.288]                     {
[11:01:32.288]                       inherits <- base::inherits
[11:01:32.288]                       invokeRestart <- base::invokeRestart
[11:01:32.288]                       is.null <- base::is.null
[11:01:32.288]                       muffled <- FALSE
[11:01:32.288]                       if (inherits(cond, "message")) {
[11:01:32.288]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.288]                         if (muffled) 
[11:01:32.288]                           invokeRestart("muffleMessage")
[11:01:32.288]                       }
[11:01:32.288]                       else if (inherits(cond, "warning")) {
[11:01:32.288]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.288]                         if (muffled) 
[11:01:32.288]                           invokeRestart("muffleWarning")
[11:01:32.288]                       }
[11:01:32.288]                       else if (inherits(cond, "condition")) {
[11:01:32.288]                         if (!is.null(pattern)) {
[11:01:32.288]                           computeRestarts <- base::computeRestarts
[11:01:32.288]                           grepl <- base::grepl
[11:01:32.288]                           restarts <- computeRestarts(cond)
[11:01:32.288]                           for (restart in restarts) {
[11:01:32.288]                             name <- restart$name
[11:01:32.288]                             if (is.null(name)) 
[11:01:32.288]                               next
[11:01:32.288]                             if (!grepl(pattern, name)) 
[11:01:32.288]                               next
[11:01:32.288]                             invokeRestart(restart)
[11:01:32.288]                             muffled <- TRUE
[11:01:32.288]                             break
[11:01:32.288]                           }
[11:01:32.288]                         }
[11:01:32.288]                       }
[11:01:32.288]                       invisible(muffled)
[11:01:32.288]                     }
[11:01:32.288]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.288]                   }
[11:01:32.288]                 }
[11:01:32.288]                 else {
[11:01:32.288]                   if (TRUE) {
[11:01:32.288]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.288]                     {
[11:01:32.288]                       inherits <- base::inherits
[11:01:32.288]                       invokeRestart <- base::invokeRestart
[11:01:32.288]                       is.null <- base::is.null
[11:01:32.288]                       muffled <- FALSE
[11:01:32.288]                       if (inherits(cond, "message")) {
[11:01:32.288]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.288]                         if (muffled) 
[11:01:32.288]                           invokeRestart("muffleMessage")
[11:01:32.288]                       }
[11:01:32.288]                       else if (inherits(cond, "warning")) {
[11:01:32.288]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.288]                         if (muffled) 
[11:01:32.288]                           invokeRestart("muffleWarning")
[11:01:32.288]                       }
[11:01:32.288]                       else if (inherits(cond, "condition")) {
[11:01:32.288]                         if (!is.null(pattern)) {
[11:01:32.288]                           computeRestarts <- base::computeRestarts
[11:01:32.288]                           grepl <- base::grepl
[11:01:32.288]                           restarts <- computeRestarts(cond)
[11:01:32.288]                           for (restart in restarts) {
[11:01:32.288]                             name <- restart$name
[11:01:32.288]                             if (is.null(name)) 
[11:01:32.288]                               next
[11:01:32.288]                             if (!grepl(pattern, name)) 
[11:01:32.288]                               next
[11:01:32.288]                             invokeRestart(restart)
[11:01:32.288]                             muffled <- TRUE
[11:01:32.288]                             break
[11:01:32.288]                           }
[11:01:32.288]                         }
[11:01:32.288]                       }
[11:01:32.288]                       invisible(muffled)
[11:01:32.288]                     }
[11:01:32.288]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.288]                   }
[11:01:32.288]                 }
[11:01:32.288]             }
[11:01:32.288]         }))
[11:01:32.288]     }, error = function(ex) {
[11:01:32.288]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.288]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.288]                 ...future.rng), started = ...future.startTime, 
[11:01:32.288]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.288]             version = "1.8"), class = "FutureResult")
[11:01:32.288]     }, finally = {
[11:01:32.288]         if (!identical(...future.workdir, getwd())) 
[11:01:32.288]             setwd(...future.workdir)
[11:01:32.288]         {
[11:01:32.288]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.288]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.288]             }
[11:01:32.288]             base::options(...future.oldOptions)
[11:01:32.288]             if (.Platform$OS.type == "windows") {
[11:01:32.288]                 old_names <- names(...future.oldEnvVars)
[11:01:32.288]                 envs <- base::Sys.getenv()
[11:01:32.288]                 names <- names(envs)
[11:01:32.288]                 common <- intersect(names, old_names)
[11:01:32.288]                 added <- setdiff(names, old_names)
[11:01:32.288]                 removed <- setdiff(old_names, names)
[11:01:32.288]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.288]                   envs[common]]
[11:01:32.288]                 NAMES <- toupper(changed)
[11:01:32.288]                 args <- list()
[11:01:32.288]                 for (kk in seq_along(NAMES)) {
[11:01:32.288]                   name <- changed[[kk]]
[11:01:32.288]                   NAME <- NAMES[[kk]]
[11:01:32.288]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.288]                     next
[11:01:32.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.288]                 }
[11:01:32.288]                 NAMES <- toupper(added)
[11:01:32.288]                 for (kk in seq_along(NAMES)) {
[11:01:32.288]                   name <- added[[kk]]
[11:01:32.288]                   NAME <- NAMES[[kk]]
[11:01:32.288]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.288]                     next
[11:01:32.288]                   args[[name]] <- ""
[11:01:32.288]                 }
[11:01:32.288]                 NAMES <- toupper(removed)
[11:01:32.288]                 for (kk in seq_along(NAMES)) {
[11:01:32.288]                   name <- removed[[kk]]
[11:01:32.288]                   NAME <- NAMES[[kk]]
[11:01:32.288]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.288]                     next
[11:01:32.288]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.288]                 }
[11:01:32.288]                 if (length(args) > 0) 
[11:01:32.288]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.288]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.288]             }
[11:01:32.288]             else {
[11:01:32.288]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.288]             }
[11:01:32.288]             {
[11:01:32.288]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.288]                   0L) {
[11:01:32.288]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.288]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.288]                   base::options(opts)
[11:01:32.288]                 }
[11:01:32.288]                 {
[11:01:32.288]                   {
[11:01:32.288]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.288]                     NULL
[11:01:32.288]                   }
[11:01:32.288]                   options(future.plan = NULL)
[11:01:32.288]                   if (is.na(NA_character_)) 
[11:01:32.288]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.288]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.288]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.288]                     .init = FALSE)
[11:01:32.288]                 }
[11:01:32.288]             }
[11:01:32.288]         }
[11:01:32.288]     })
[11:01:32.288]     if (TRUE) {
[11:01:32.288]         base::sink(type = "output", split = FALSE)
[11:01:32.288]         if (TRUE) {
[11:01:32.288]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.288]         }
[11:01:32.288]         else {
[11:01:32.288]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.288]         }
[11:01:32.288]         base::close(...future.stdout)
[11:01:32.288]         ...future.stdout <- NULL
[11:01:32.288]     }
[11:01:32.288]     ...future.result$conditions <- ...future.conditions
[11:01:32.288]     ...future.result$finished <- base::Sys.time()
[11:01:32.288]     ...future.result
[11:01:32.288] }
[11:01:32.291] requestCore(): workers = 2
[11:01:32.294] MulticoreFuture started
[11:01:32.294] - Launch lazy future ... done
[11:01:32.294] run() for ‘MulticoreFuture’ ... done
[11:01:32.295] plan(): Setting new future strategy stack:
[11:01:32.295] getGlobalsAndPackages() ...
[11:01:32.295] Searching for globals...
[11:01:32.295] List of future strategies:
[11:01:32.295] 1. sequential:
[11:01:32.295]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.295]    - tweaked: FALSE
[11:01:32.295]    - call: NULL
[11:01:32.296] plan(): nbrOfWorkers() = 1
[11:01:32.296] - globals found: [1] ‘{’
[11:01:32.297] Searching for globals ... DONE
[11:01:32.297] Resolving globals: FALSE
[11:01:32.297] 
[11:01:32.297] 
[11:01:32.298] getGlobalsAndPackages() ... DONE
[11:01:32.298] plan(): Setting new future strategy stack:
[11:01:32.298] run() for ‘Future’ ...
[11:01:32.298] - state: ‘created’
[11:01:32.298] List of future strategies:
[11:01:32.298] 1. multicore:
[11:01:32.298]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.298]    - tweaked: FALSE
[11:01:32.298]    - call: plan(strategy)
[11:01:32.298] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.301] plan(): nbrOfWorkers() = 2
[11:01:32.301] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.301] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.302]   - Field: ‘label’
[11:01:32.302]   - Field: ‘local’
[11:01:32.302]   - Field: ‘owner’
[11:01:32.302]   - Field: ‘envir’
[11:01:32.302]   - Field: ‘workers’
[11:01:32.302]   - Field: ‘packages’
[11:01:32.302]   - Field: ‘gc’
[11:01:32.302]   - Field: ‘job’
[11:01:32.303]   - Field: ‘conditions’
[11:01:32.303]   - Field: ‘expr’
[11:01:32.303]   - Field: ‘uuid’
[11:01:32.303]   - Field: ‘seed’
[11:01:32.303]   - Field: ‘version’
[11:01:32.303]   - Field: ‘result’
[11:01:32.303]   - Field: ‘asynchronous’
[11:01:32.303]   - Field: ‘calls’
[11:01:32.304]   - Field: ‘globals’
[11:01:32.304]   - Field: ‘stdout’
[11:01:32.304]   - Field: ‘earlySignal’
[11:01:32.304]   - Field: ‘lazy’
[11:01:32.304]   - Field: ‘state’
[11:01:32.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.304] - Launch lazy future ...
[11:01:32.305] Packages needed by the future expression (n = 0): <none>
[11:01:32.305] Packages needed by future strategies (n = 0): <none>
[11:01:32.305] {
[11:01:32.305]     {
[11:01:32.305]         {
[11:01:32.305]             ...future.startTime <- base::Sys.time()
[11:01:32.305]             {
[11:01:32.305]                 {
[11:01:32.305]                   {
[11:01:32.305]                     {
[11:01:32.305]                       base::local({
[11:01:32.305]                         has_future <- base::requireNamespace("future", 
[11:01:32.305]                           quietly = TRUE)
[11:01:32.305]                         if (has_future) {
[11:01:32.305]                           ns <- base::getNamespace("future")
[11:01:32.305]                           version <- ns[[".package"]][["version"]]
[11:01:32.305]                           if (is.null(version)) 
[11:01:32.305]                             version <- utils::packageVersion("future")
[11:01:32.305]                         }
[11:01:32.305]                         else {
[11:01:32.305]                           version <- NULL
[11:01:32.305]                         }
[11:01:32.305]                         if (!has_future || version < "1.8.0") {
[11:01:32.305]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.305]                             "", base::R.version$version.string), 
[11:01:32.305]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.305]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.305]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.305]                               "release", "version")], collapse = " "), 
[11:01:32.305]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.305]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.305]                             info)
[11:01:32.305]                           info <- base::paste(info, collapse = "; ")
[11:01:32.305]                           if (!has_future) {
[11:01:32.305]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.305]                               info)
[11:01:32.305]                           }
[11:01:32.305]                           else {
[11:01:32.305]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.305]                               info, version)
[11:01:32.305]                           }
[11:01:32.305]                           base::stop(msg)
[11:01:32.305]                         }
[11:01:32.305]                       })
[11:01:32.305]                     }
[11:01:32.305]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.305]                     base::options(mc.cores = 1L)
[11:01:32.305]                   }
[11:01:32.305]                   ...future.strategy.old <- future::plan("list")
[11:01:32.305]                   options(future.plan = NULL)
[11:01:32.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.305]                 }
[11:01:32.305]                 ...future.workdir <- getwd()
[11:01:32.305]             }
[11:01:32.305]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.305]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.305]         }
[11:01:32.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.305]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.305]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.305]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.305]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.305]             base::names(...future.oldOptions))
[11:01:32.305]     }
[11:01:32.305]     if (FALSE) {
[11:01:32.305]     }
[11:01:32.305]     else {
[11:01:32.305]         if (TRUE) {
[11:01:32.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.305]                 open = "w")
[11:01:32.305]         }
[11:01:32.305]         else {
[11:01:32.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.305]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.305]         }
[11:01:32.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.305]             base::sink(type = "output", split = FALSE)
[11:01:32.305]             base::close(...future.stdout)
[11:01:32.305]         }, add = TRUE)
[11:01:32.305]     }
[11:01:32.305]     ...future.frame <- base::sys.nframe()
[11:01:32.305]     ...future.conditions <- base::list()
[11:01:32.305]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.305]     if (FALSE) {
[11:01:32.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.305]     }
[11:01:32.305]     ...future.result <- base::tryCatch({
[11:01:32.305]         base::withCallingHandlers({
[11:01:32.305]             ...future.value <- base::withVisible(base::local({
[11:01:32.305]                 withCallingHandlers({
[11:01:32.305]                   {
[11:01:32.305]                     4
[11:01:32.305]                   }
[11:01:32.305]                 }, immediateCondition = function(cond) {
[11:01:32.305]                   save_rds <- function (object, pathname, ...) 
[11:01:32.305]                   {
[11:01:32.305]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.305]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.305]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.305]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.305]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.305]                         fi_tmp[["mtime"]])
[11:01:32.305]                     }
[11:01:32.305]                     tryCatch({
[11:01:32.305]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.305]                     }, error = function(ex) {
[11:01:32.305]                       msg <- conditionMessage(ex)
[11:01:32.305]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.305]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.305]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.305]                         fi_tmp[["mtime"]], msg)
[11:01:32.305]                       ex$message <- msg
[11:01:32.305]                       stop(ex)
[11:01:32.305]                     })
[11:01:32.305]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.305]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.305]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.305]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.305]                       fi <- file.info(pathname)
[11:01:32.305]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.305]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.305]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.305]                         fi[["size"]], fi[["mtime"]])
[11:01:32.305]                       stop(msg)
[11:01:32.305]                     }
[11:01:32.305]                     invisible(pathname)
[11:01:32.305]                   }
[11:01:32.305]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.305]                     rootPath = tempdir()) 
[11:01:32.305]                   {
[11:01:32.305]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.305]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.305]                       tmpdir = path, fileext = ".rds")
[11:01:32.305]                     save_rds(obj, file)
[11:01:32.305]                   }
[11:01:32.305]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.305]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.305]                   {
[11:01:32.305]                     inherits <- base::inherits
[11:01:32.305]                     invokeRestart <- base::invokeRestart
[11:01:32.305]                     is.null <- base::is.null
[11:01:32.305]                     muffled <- FALSE
[11:01:32.305]                     if (inherits(cond, "message")) {
[11:01:32.305]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.305]                       if (muffled) 
[11:01:32.305]                         invokeRestart("muffleMessage")
[11:01:32.305]                     }
[11:01:32.305]                     else if (inherits(cond, "warning")) {
[11:01:32.305]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.305]                       if (muffled) 
[11:01:32.305]                         invokeRestart("muffleWarning")
[11:01:32.305]                     }
[11:01:32.305]                     else if (inherits(cond, "condition")) {
[11:01:32.305]                       if (!is.null(pattern)) {
[11:01:32.305]                         computeRestarts <- base::computeRestarts
[11:01:32.305]                         grepl <- base::grepl
[11:01:32.305]                         restarts <- computeRestarts(cond)
[11:01:32.305]                         for (restart in restarts) {
[11:01:32.305]                           name <- restart$name
[11:01:32.305]                           if (is.null(name)) 
[11:01:32.305]                             next
[11:01:32.305]                           if (!grepl(pattern, name)) 
[11:01:32.305]                             next
[11:01:32.305]                           invokeRestart(restart)
[11:01:32.305]                           muffled <- TRUE
[11:01:32.305]                           break
[11:01:32.305]                         }
[11:01:32.305]                       }
[11:01:32.305]                     }
[11:01:32.305]                     invisible(muffled)
[11:01:32.305]                   }
[11:01:32.305]                   muffleCondition(cond)
[11:01:32.305]                 })
[11:01:32.305]             }))
[11:01:32.305]             future::FutureResult(value = ...future.value$value, 
[11:01:32.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.305]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.305]                     ...future.globalenv.names))
[11:01:32.305]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.305]         }, condition = base::local({
[11:01:32.305]             c <- base::c
[11:01:32.305]             inherits <- base::inherits
[11:01:32.305]             invokeRestart <- base::invokeRestart
[11:01:32.305]             length <- base::length
[11:01:32.305]             list <- base::list
[11:01:32.305]             seq.int <- base::seq.int
[11:01:32.305]             signalCondition <- base::signalCondition
[11:01:32.305]             sys.calls <- base::sys.calls
[11:01:32.305]             `[[` <- base::`[[`
[11:01:32.305]             `+` <- base::`+`
[11:01:32.305]             `<<-` <- base::`<<-`
[11:01:32.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.305]                   3L)]
[11:01:32.305]             }
[11:01:32.305]             function(cond) {
[11:01:32.305]                 is_error <- inherits(cond, "error")
[11:01:32.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.305]                   NULL)
[11:01:32.305]                 if (is_error) {
[11:01:32.305]                   sessionInformation <- function() {
[11:01:32.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.305]                       search = base::search(), system = base::Sys.info())
[11:01:32.305]                   }
[11:01:32.305]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.305]                     cond$call), session = sessionInformation(), 
[11:01:32.305]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.305]                   signalCondition(cond)
[11:01:32.305]                 }
[11:01:32.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.305]                 "immediateCondition"))) {
[11:01:32.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.305]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.305]                   if (TRUE && !signal) {
[11:01:32.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.305]                     {
[11:01:32.305]                       inherits <- base::inherits
[11:01:32.305]                       invokeRestart <- base::invokeRestart
[11:01:32.305]                       is.null <- base::is.null
[11:01:32.305]                       muffled <- FALSE
[11:01:32.305]                       if (inherits(cond, "message")) {
[11:01:32.305]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.305]                         if (muffled) 
[11:01:32.305]                           invokeRestart("muffleMessage")
[11:01:32.305]                       }
[11:01:32.305]                       else if (inherits(cond, "warning")) {
[11:01:32.305]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.305]                         if (muffled) 
[11:01:32.305]                           invokeRestart("muffleWarning")
[11:01:32.305]                       }
[11:01:32.305]                       else if (inherits(cond, "condition")) {
[11:01:32.305]                         if (!is.null(pattern)) {
[11:01:32.305]                           computeRestarts <- base::computeRestarts
[11:01:32.305]                           grepl <- base::grepl
[11:01:32.305]                           restarts <- computeRestarts(cond)
[11:01:32.305]                           for (restart in restarts) {
[11:01:32.305]                             name <- restart$name
[11:01:32.305]                             if (is.null(name)) 
[11:01:32.305]                               next
[11:01:32.305]                             if (!grepl(pattern, name)) 
[11:01:32.305]                               next
[11:01:32.305]                             invokeRestart(restart)
[11:01:32.305]                             muffled <- TRUE
[11:01:32.305]                             break
[11:01:32.305]                           }
[11:01:32.305]                         }
[11:01:32.305]                       }
[11:01:32.305]                       invisible(muffled)
[11:01:32.305]                     }
[11:01:32.305]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.305]                   }
[11:01:32.305]                 }
[11:01:32.305]                 else {
[11:01:32.305]                   if (TRUE) {
[11:01:32.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.305]                     {
[11:01:32.305]                       inherits <- base::inherits
[11:01:32.305]                       invokeRestart <- base::invokeRestart
[11:01:32.305]                       is.null <- base::is.null
[11:01:32.305]                       muffled <- FALSE
[11:01:32.305]                       if (inherits(cond, "message")) {
[11:01:32.305]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.305]                         if (muffled) 
[11:01:32.305]                           invokeRestart("muffleMessage")
[11:01:32.305]                       }
[11:01:32.305]                       else if (inherits(cond, "warning")) {
[11:01:32.305]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.305]                         if (muffled) 
[11:01:32.305]                           invokeRestart("muffleWarning")
[11:01:32.305]                       }
[11:01:32.305]                       else if (inherits(cond, "condition")) {
[11:01:32.305]                         if (!is.null(pattern)) {
[11:01:32.305]                           computeRestarts <- base::computeRestarts
[11:01:32.305]                           grepl <- base::grepl
[11:01:32.305]                           restarts <- computeRestarts(cond)
[11:01:32.305]                           for (restart in restarts) {
[11:01:32.305]                             name <- restart$name
[11:01:32.305]                             if (is.null(name)) 
[11:01:32.305]                               next
[11:01:32.305]                             if (!grepl(pattern, name)) 
[11:01:32.305]                               next
[11:01:32.305]                             invokeRestart(restart)
[11:01:32.305]                             muffled <- TRUE
[11:01:32.305]                             break
[11:01:32.305]                           }
[11:01:32.305]                         }
[11:01:32.305]                       }
[11:01:32.305]                       invisible(muffled)
[11:01:32.305]                     }
[11:01:32.305]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.305]                   }
[11:01:32.305]                 }
[11:01:32.305]             }
[11:01:32.305]         }))
[11:01:32.305]     }, error = function(ex) {
[11:01:32.305]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.305]                 ...future.rng), started = ...future.startTime, 
[11:01:32.305]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.305]             version = "1.8"), class = "FutureResult")
[11:01:32.305]     }, finally = {
[11:01:32.305]         if (!identical(...future.workdir, getwd())) 
[11:01:32.305]             setwd(...future.workdir)
[11:01:32.305]         {
[11:01:32.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.305]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.305]             }
[11:01:32.305]             base::options(...future.oldOptions)
[11:01:32.305]             if (.Platform$OS.type == "windows") {
[11:01:32.305]                 old_names <- names(...future.oldEnvVars)
[11:01:32.305]                 envs <- base::Sys.getenv()
[11:01:32.305]                 names <- names(envs)
[11:01:32.305]                 common <- intersect(names, old_names)
[11:01:32.305]                 added <- setdiff(names, old_names)
[11:01:32.305]                 removed <- setdiff(old_names, names)
[11:01:32.305]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.305]                   envs[common]]
[11:01:32.305]                 NAMES <- toupper(changed)
[11:01:32.305]                 args <- list()
[11:01:32.305]                 for (kk in seq_along(NAMES)) {
[11:01:32.305]                   name <- changed[[kk]]
[11:01:32.305]                   NAME <- NAMES[[kk]]
[11:01:32.305]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.305]                     next
[11:01:32.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.305]                 }
[11:01:32.305]                 NAMES <- toupper(added)
[11:01:32.305]                 for (kk in seq_along(NAMES)) {
[11:01:32.305]                   name <- added[[kk]]
[11:01:32.305]                   NAME <- NAMES[[kk]]
[11:01:32.305]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.305]                     next
[11:01:32.305]                   args[[name]] <- ""
[11:01:32.305]                 }
[11:01:32.305]                 NAMES <- toupper(removed)
[11:01:32.305]                 for (kk in seq_along(NAMES)) {
[11:01:32.305]                   name <- removed[[kk]]
[11:01:32.305]                   NAME <- NAMES[[kk]]
[11:01:32.305]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.305]                     next
[11:01:32.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.305]                 }
[11:01:32.305]                 if (length(args) > 0) 
[11:01:32.305]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.305]             }
[11:01:32.305]             else {
[11:01:32.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.305]             }
[11:01:32.305]             {
[11:01:32.305]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.305]                   0L) {
[11:01:32.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.305]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.305]                   base::options(opts)
[11:01:32.305]                 }
[11:01:32.305]                 {
[11:01:32.305]                   {
[11:01:32.305]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.305]                     NULL
[11:01:32.305]                   }
[11:01:32.305]                   options(future.plan = NULL)
[11:01:32.305]                   if (is.na(NA_character_)) 
[11:01:32.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.305]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.305]                     .init = FALSE)
[11:01:32.305]                 }
[11:01:32.305]             }
[11:01:32.305]         }
[11:01:32.305]     })
[11:01:32.305]     if (TRUE) {
[11:01:32.305]         base::sink(type = "output", split = FALSE)
[11:01:32.305]         if (TRUE) {
[11:01:32.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.305]         }
[11:01:32.305]         else {
[11:01:32.305]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.305]         }
[11:01:32.305]         base::close(...future.stdout)
[11:01:32.305]         ...future.stdout <- NULL
[11:01:32.305]     }
[11:01:32.305]     ...future.result$conditions <- ...future.conditions
[11:01:32.305]     ...future.result$finished <- base::Sys.time()
[11:01:32.305]     ...future.result
[11:01:32.305] }
[11:01:32.309] requestCore(): workers = 2
[11:01:32.309] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:32.320] result() for MulticoreFuture ...
[11:01:32.321] result() for MulticoreFuture ...
[11:01:32.321] result() for MulticoreFuture ... done
[11:01:32.321] result() for MulticoreFuture ... done
[11:01:32.322] result() for MulticoreFuture ...
[11:01:32.322] result() for MulticoreFuture ... done
[11:01:32.324] MulticoreFuture started
[11:01:32.325] - Launch lazy future ... done
[11:01:32.325] run() for ‘MulticoreFuture’ ... done
[11:01:32.326] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a9c5f16918> 
[11:01:32.326] List of future strategies:
[11:01:32.326] 1. sequential:
[11:01:32.326]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.326]    - tweaked: FALSE
[11:01:32.326]    - call: NULL
[11:01:32.327] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55a9c7f44d28> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=[11:01:32.330] plan(): Setting new future strategy stack:
List of 2
  ..$ :[11:01:32.330] List of future strategies:
[11:01:32.330] 1. multicore:
[11:01:32.330]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.330]    - tweaked: FALSE
[11:01:32.330]    - call: plan(strategy)
 chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[11:01:32.335] plan(): nbrOfWorkers() = 2
 logi [1, 1:6] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:32.338] resolve() on list environment ...
[11:01:32.338]  recursive: 0
[11:01:32.340]  length: 6
[11:01:32.340]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:32.340] signalConditionsASAP(numeric, pos=1) ...
[11:01:32.340] - nx: 6
[11:01:32.340] - relay: TRUE
[11:01:32.340] - stdout: TRUE
[11:01:32.340] - signal: TRUE
[11:01:32.341] - resignal: FALSE
[11:01:32.341] - force: TRUE
[11:01:32.341] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.341] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.341]  - until=2
[11:01:32.341]  - relaying element #2
[11:01:32.341] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.341] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.342] signalConditionsASAP(NULL, pos=1) ... done
[11:01:32.342]  length: 5 (resolved future 1)
[11:01:32.342] Future #2
[11:01:32.342] result() for MulticoreFuture ...
[11:01:32.342] result() for MulticoreFuture ... done
[11:01:32.342] result() for MulticoreFuture ...
[11:01:32.342] result() for MulticoreFuture ... done
[11:01:32.343] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:32.343] - nx: 6
[11:01:32.343] - relay: TRUE
[11:01:32.343] - stdout: TRUE
[11:01:32.343] - signal: TRUE
[11:01:32.343] - resignal: FALSE
[11:01:32.343] - force: TRUE
[11:01:32.343] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.343] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.344]  - until=2
[11:01:32.344]  - relaying element #2
[11:01:32.344] result() for MulticoreFuture ...
[11:01:32.344] result() for MulticoreFuture ... done
[11:01:32.344] result() for MulticoreFuture ...
[11:01:32.344] result() for MulticoreFuture ... done
[11:01:32.344] result() for MulticoreFuture ...
[11:01:32.345] result() for MulticoreFuture ... done
[11:01:32.345] result() for MulticoreFuture ...
[11:01:32.345] result() for MulticoreFuture ... done
[11:01:32.345] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.345] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.345] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:32.345]  length: 4 (resolved future 2)
[11:01:32.346] Future #3
[11:01:32.346] result() for MulticoreFuture ...
[11:01:32.347] result() for MulticoreFuture ...
[11:01:32.347] result() for MulticoreFuture ... done
[11:01:32.347] result() for MulticoreFuture ... done
[11:01:32.347] result() for MulticoreFuture ...
[11:01:32.347] result() for MulticoreFuture ... done
[11:01:32.347] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:32.347] - nx: 6
[11:01:32.347] - relay: TRUE
[11:01:32.348] - stdout: TRUE
[11:01:32.348] - signal: TRUE
[11:01:32.348] - resignal: FALSE
[11:01:32.348] - force: TRUE
[11:01:32.348] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.348] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.348]  - until=3
[11:01:32.348]  - relaying element #3
[11:01:32.348] result() for MulticoreFuture ...
[11:01:32.349] result() for MulticoreFuture ... done
[11:01:32.349] result() for MulticoreFuture ...
[11:01:32.349] result() for MulticoreFuture ... done
[11:01:32.349] result() for MulticoreFuture ...
[11:01:32.349] result() for MulticoreFuture ... done
[11:01:32.349] result() for MulticoreFuture ...
[11:01:32.349] result() for MulticoreFuture ... done
[11:01:32.349] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.350] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.350] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:32.350]  length: 3 (resolved future 3)
[11:01:32.350] Future #4
[11:01:32.350] result() for MulticoreFuture ...
[11:01:32.351] result() for MulticoreFuture ...
[11:01:32.351] result() for MulticoreFuture ... done
[11:01:32.351] result() for MulticoreFuture ... done
[11:01:32.352] result() for MulticoreFuture ...
[11:01:32.352] result() for MulticoreFuture ... done
[11:01:32.352] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:32.352] - nx: 6
[11:01:32.352] - relay: TRUE
[11:01:32.352] - stdout: TRUE
[11:01:32.353] - signal: TRUE
[11:01:32.353] - resignal: FALSE
[11:01:32.353] - force: TRUE
[11:01:32.353] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.353] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.353]  - until=4
[11:01:32.353]  - relaying element #4
[11:01:32.354] result() for MulticoreFuture ...
[11:01:32.354] result() for MulticoreFuture ... done
[11:01:32.354] result() for MulticoreFuture ...
[11:01:32.354] result() for MulticoreFuture ... done
[11:01:32.354] result() for MulticoreFuture ...
[11:01:32.354] result() for MulticoreFuture ... done
[11:01:32.355] result() for MulticoreFuture ...
[11:01:32.355] result() for MulticoreFuture ... done
[11:01:32.355] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.355] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.355] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:32.355]  length: 2 (resolved future 4)
[11:01:32.355] signalConditionsASAP(NULL, pos=5) ...
[11:01:32.356] - nx: 6
[11:01:32.356] - relay: TRUE
[11:01:32.356] - stdout: TRUE
[11:01:32.356] - signal: TRUE
[11:01:32.356] - resignal: FALSE
[11:01:32.356] - force: TRUE
[11:01:32.356] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.356] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.356]  - until=6
[11:01:32.356]  - relaying element #6
[11:01:32.356] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.357] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.357] signalConditionsASAP(NULL, pos=5) ... done
[11:01:32.357]  length: 1 (resolved future 5)
[11:01:32.357] signalConditionsASAP(numeric, pos=6) ...
[11:01:32.357] - nx: 6
[11:01:32.357] - relay: TRUE
[11:01:32.357] - stdout: TRUE
[11:01:32.357] - signal: TRUE
[11:01:32.357] - resignal: FALSE
[11:01:32.357] - force: TRUE
[11:01:32.358] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.358] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.358]  - until=6
[11:01:32.358] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.358] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.358] signalConditionsASAP(numeric, pos=6) ... done
[11:01:32.358]  length: 0 (resolved future 6)
[11:01:32.358] Relaying remaining futures
[11:01:32.358] signalConditionsASAP(NULL, pos=0) ...
[11:01:32.358] - nx: 6
[11:01:32.359] - relay: TRUE
[11:01:32.359] - stdout: TRUE
[11:01:32.359] - signal: TRUE
[11:01:32.359] - resignal: FALSE
[11:01:32.359] - force: TRUE
[11:01:32.359] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.359] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:32.359] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.359] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.359] signalConditionsASAP(NULL, pos=0) ... done
[11:01:32.360] resolve() on list environment ... DONE
[11:01:32.360] result() for MulticoreFuture ...
[11:01:32.360] result() for MulticoreFuture ... done
[11:01:32.360] result() for MulticoreFuture ...
[11:01:32.360] result() for MulticoreFuture ... done
[11:01:32.360] result() for MulticoreFuture ...
[11:01:32.360] result() for MulticoreFuture ... done
[11:01:32.360] result() for MulticoreFuture ...
[11:01:32.361] result() for MulticoreFuture ... done
[11:01:32.361] result() for MulticoreFuture ...
[11:01:32.361] result() for MulticoreFuture ... done
[11:01:32.361] result() for MulticoreFuture ...
[11:01:32.361] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c8188168> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[11:01:32.363] getGlobalsAndPackages() ...
[11:01:32.363] Searching for globals...
[11:01:32.364] 
[11:01:32.364] Searching for globals ... DONE
[11:01:32.364] - globals: [0] <none>
[11:01:32.364] getGlobalsAndPackages() ... DONE
[11:01:32.364] run() for ‘Future’ ...
[11:01:32.364] - state: ‘created’
[11:01:32.364] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.367] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.367] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.367]   - Field: ‘label’
[11:01:32.367]   - Field: ‘local’
[11:01:32.367]   - Field: ‘owner’
[11:01:32.367]   - Field: ‘envir’
[11:01:32.367]   - Field: ‘workers’
[11:01:32.367]   - Field: ‘packages’
[11:01:32.368]   - Field: ‘gc’
[11:01:32.368]   - Field: ‘job’
[11:01:32.368]   - Field: ‘conditions’
[11:01:32.368]   - Field: ‘expr’
[11:01:32.368]   - Field: ‘uuid’
[11:01:32.368]   - Field: ‘seed’
[11:01:32.368]   - Field: ‘version’
[11:01:32.368]   - Field: ‘result’
[11:01:32.368]   - Field: ‘asynchronous’
[11:01:32.368]   - Field: ‘calls’
[11:01:32.369]   - Field: ‘globals’
[11:01:32.369]   - Field: ‘stdout’
[11:01:32.369]   - Field: ‘earlySignal’
[11:01:32.369]   - Field: ‘lazy’
[11:01:32.369]   - Field: ‘state’
[11:01:32.372] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.372] - Launch lazy future ...
[11:01:32.373] Packages needed by the future expression (n = 0): <none>
[11:01:32.373] Packages needed by future strategies (n = 0): <none>
[11:01:32.374] {
[11:01:32.374]     {
[11:01:32.374]         {
[11:01:32.374]             ...future.startTime <- base::Sys.time()
[11:01:32.374]             {
[11:01:32.374]                 {
[11:01:32.374]                   {
[11:01:32.374]                     {
[11:01:32.374]                       base::local({
[11:01:32.374]                         has_future <- base::requireNamespace("future", 
[11:01:32.374]                           quietly = TRUE)
[11:01:32.374]                         if (has_future) {
[11:01:32.374]                           ns <- base::getNamespace("future")
[11:01:32.374]                           version <- ns[[".package"]][["version"]]
[11:01:32.374]                           if (is.null(version)) 
[11:01:32.374]                             version <- utils::packageVersion("future")
[11:01:32.374]                         }
[11:01:32.374]                         else {
[11:01:32.374]                           version <- NULL
[11:01:32.374]                         }
[11:01:32.374]                         if (!has_future || version < "1.8.0") {
[11:01:32.374]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.374]                             "", base::R.version$version.string), 
[11:01:32.374]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.374]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.374]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.374]                               "release", "version")], collapse = " "), 
[11:01:32.374]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.374]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.374]                             info)
[11:01:32.374]                           info <- base::paste(info, collapse = "; ")
[11:01:32.374]                           if (!has_future) {
[11:01:32.374]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.374]                               info)
[11:01:32.374]                           }
[11:01:32.374]                           else {
[11:01:32.374]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.374]                               info, version)
[11:01:32.374]                           }
[11:01:32.374]                           base::stop(msg)
[11:01:32.374]                         }
[11:01:32.374]                       })
[11:01:32.374]                     }
[11:01:32.374]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.374]                     base::options(mc.cores = 1L)
[11:01:32.374]                   }
[11:01:32.374]                   ...future.strategy.old <- future::plan("list")
[11:01:32.374]                   options(future.plan = NULL)
[11:01:32.374]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.374]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.374]                 }
[11:01:32.374]                 ...future.workdir <- getwd()
[11:01:32.374]             }
[11:01:32.374]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.374]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.374]         }
[11:01:32.374]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.374]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.374]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.374]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.374]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.374]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.374]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.374]             base::names(...future.oldOptions))
[11:01:32.374]     }
[11:01:32.374]     if (FALSE) {
[11:01:32.374]     }
[11:01:32.374]     else {
[11:01:32.374]         if (TRUE) {
[11:01:32.374]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.374]                 open = "w")
[11:01:32.374]         }
[11:01:32.374]         else {
[11:01:32.374]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.374]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.374]         }
[11:01:32.374]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.374]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.374]             base::sink(type = "output", split = FALSE)
[11:01:32.374]             base::close(...future.stdout)
[11:01:32.374]         }, add = TRUE)
[11:01:32.374]     }
[11:01:32.374]     ...future.frame <- base::sys.nframe()
[11:01:32.374]     ...future.conditions <- base::list()
[11:01:32.374]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.374]     if (FALSE) {
[11:01:32.374]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.374]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.374]     }
[11:01:32.374]     ...future.result <- base::tryCatch({
[11:01:32.374]         base::withCallingHandlers({
[11:01:32.374]             ...future.value <- base::withVisible(base::local({
[11:01:32.374]                 withCallingHandlers({
[11:01:32.374]                   2
[11:01:32.374]                 }, immediateCondition = function(cond) {
[11:01:32.374]                   save_rds <- function (object, pathname, ...) 
[11:01:32.374]                   {
[11:01:32.374]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.374]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.374]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.374]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.374]                         fi_tmp[["mtime"]])
[11:01:32.374]                     }
[11:01:32.374]                     tryCatch({
[11:01:32.374]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.374]                     }, error = function(ex) {
[11:01:32.374]                       msg <- conditionMessage(ex)
[11:01:32.374]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.374]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.374]                         fi_tmp[["mtime"]], msg)
[11:01:32.374]                       ex$message <- msg
[11:01:32.374]                       stop(ex)
[11:01:32.374]                     })
[11:01:32.374]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.374]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.374]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.374]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.374]                       fi <- file.info(pathname)
[11:01:32.374]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.374]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.374]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.374]                         fi[["size"]], fi[["mtime"]])
[11:01:32.374]                       stop(msg)
[11:01:32.374]                     }
[11:01:32.374]                     invisible(pathname)
[11:01:32.374]                   }
[11:01:32.374]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.374]                     rootPath = tempdir()) 
[11:01:32.374]                   {
[11:01:32.374]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.374]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.374]                       tmpdir = path, fileext = ".rds")
[11:01:32.374]                     save_rds(obj, file)
[11:01:32.374]                   }
[11:01:32.374]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.374]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.374]                   {
[11:01:32.374]                     inherits <- base::inherits
[11:01:32.374]                     invokeRestart <- base::invokeRestart
[11:01:32.374]                     is.null <- base::is.null
[11:01:32.374]                     muffled <- FALSE
[11:01:32.374]                     if (inherits(cond, "message")) {
[11:01:32.374]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.374]                       if (muffled) 
[11:01:32.374]                         invokeRestart("muffleMessage")
[11:01:32.374]                     }
[11:01:32.374]                     else if (inherits(cond, "warning")) {
[11:01:32.374]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.374]                       if (muffled) 
[11:01:32.374]                         invokeRestart("muffleWarning")
[11:01:32.374]                     }
[11:01:32.374]                     else if (inherits(cond, "condition")) {
[11:01:32.374]                       if (!is.null(pattern)) {
[11:01:32.374]                         computeRestarts <- base::computeRestarts
[11:01:32.374]                         grepl <- base::grepl
[11:01:32.374]                         restarts <- computeRestarts(cond)
[11:01:32.374]                         for (restart in restarts) {
[11:01:32.374]                           name <- restart$name
[11:01:32.374]                           if (is.null(name)) 
[11:01:32.374]                             next
[11:01:32.374]                           if (!grepl(pattern, name)) 
[11:01:32.374]                             next
[11:01:32.374]                           invokeRestart(restart)
[11:01:32.374]                           muffled <- TRUE
[11:01:32.374]                           break
[11:01:32.374]                         }
[11:01:32.374]                       }
[11:01:32.374]                     }
[11:01:32.374]                     invisible(muffled)
[11:01:32.374]                   }
[11:01:32.374]                   muffleCondition(cond)
[11:01:32.374]                 })
[11:01:32.374]             }))
[11:01:32.374]             future::FutureResult(value = ...future.value$value, 
[11:01:32.374]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.374]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.374]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.374]                     ...future.globalenv.names))
[11:01:32.374]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.374]         }, condition = base::local({
[11:01:32.374]             c <- base::c
[11:01:32.374]             inherits <- base::inherits
[11:01:32.374]             invokeRestart <- base::invokeRestart
[11:01:32.374]             length <- base::length
[11:01:32.374]             list <- base::list
[11:01:32.374]             seq.int <- base::seq.int
[11:01:32.374]             signalCondition <- base::signalCondition
[11:01:32.374]             sys.calls <- base::sys.calls
[11:01:32.374]             `[[` <- base::`[[`
[11:01:32.374]             `+` <- base::`+`
[11:01:32.374]             `<<-` <- base::`<<-`
[11:01:32.374]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.374]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.374]                   3L)]
[11:01:32.374]             }
[11:01:32.374]             function(cond) {
[11:01:32.374]                 is_error <- inherits(cond, "error")
[11:01:32.374]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.374]                   NULL)
[11:01:32.374]                 if (is_error) {
[11:01:32.374]                   sessionInformation <- function() {
[11:01:32.374]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.374]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.374]                       search = base::search(), system = base::Sys.info())
[11:01:32.374]                   }
[11:01:32.374]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.374]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.374]                     cond$call), session = sessionInformation(), 
[11:01:32.374]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.374]                   signalCondition(cond)
[11:01:32.374]                 }
[11:01:32.374]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.374]                 "immediateCondition"))) {
[11:01:32.374]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.374]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.374]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.374]                   if (TRUE && !signal) {
[11:01:32.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.374]                     {
[11:01:32.374]                       inherits <- base::inherits
[11:01:32.374]                       invokeRestart <- base::invokeRestart
[11:01:32.374]                       is.null <- base::is.null
[11:01:32.374]                       muffled <- FALSE
[11:01:32.374]                       if (inherits(cond, "message")) {
[11:01:32.374]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.374]                         if (muffled) 
[11:01:32.374]                           invokeRestart("muffleMessage")
[11:01:32.374]                       }
[11:01:32.374]                       else if (inherits(cond, "warning")) {
[11:01:32.374]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.374]                         if (muffled) 
[11:01:32.374]                           invokeRestart("muffleWarning")
[11:01:32.374]                       }
[11:01:32.374]                       else if (inherits(cond, "condition")) {
[11:01:32.374]                         if (!is.null(pattern)) {
[11:01:32.374]                           computeRestarts <- base::computeRestarts
[11:01:32.374]                           grepl <- base::grepl
[11:01:32.374]                           restarts <- computeRestarts(cond)
[11:01:32.374]                           for (restart in restarts) {
[11:01:32.374]                             name <- restart$name
[11:01:32.374]                             if (is.null(name)) 
[11:01:32.374]                               next
[11:01:32.374]                             if (!grepl(pattern, name)) 
[11:01:32.374]                               next
[11:01:32.374]                             invokeRestart(restart)
[11:01:32.374]                             muffled <- TRUE
[11:01:32.374]                             break
[11:01:32.374]                           }
[11:01:32.374]                         }
[11:01:32.374]                       }
[11:01:32.374]                       invisible(muffled)
[11:01:32.374]                     }
[11:01:32.374]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.374]                   }
[11:01:32.374]                 }
[11:01:32.374]                 else {
[11:01:32.374]                   if (TRUE) {
[11:01:32.374]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.374]                     {
[11:01:32.374]                       inherits <- base::inherits
[11:01:32.374]                       invokeRestart <- base::invokeRestart
[11:01:32.374]                       is.null <- base::is.null
[11:01:32.374]                       muffled <- FALSE
[11:01:32.374]                       if (inherits(cond, "message")) {
[11:01:32.374]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.374]                         if (muffled) 
[11:01:32.374]                           invokeRestart("muffleMessage")
[11:01:32.374]                       }
[11:01:32.374]                       else if (inherits(cond, "warning")) {
[11:01:32.374]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.374]                         if (muffled) 
[11:01:32.374]                           invokeRestart("muffleWarning")
[11:01:32.374]                       }
[11:01:32.374]                       else if (inherits(cond, "condition")) {
[11:01:32.374]                         if (!is.null(pattern)) {
[11:01:32.374]                           computeRestarts <- base::computeRestarts
[11:01:32.374]                           grepl <- base::grepl
[11:01:32.374]                           restarts <- computeRestarts(cond)
[11:01:32.374]                           for (restart in restarts) {
[11:01:32.374]                             name <- restart$name
[11:01:32.374]                             if (is.null(name)) 
[11:01:32.374]                               next
[11:01:32.374]                             if (!grepl(pattern, name)) 
[11:01:32.374]                               next
[11:01:32.374]                             invokeRestart(restart)
[11:01:32.374]                             muffled <- TRUE
[11:01:32.374]                             break
[11:01:32.374]                           }
[11:01:32.374]                         }
[11:01:32.374]                       }
[11:01:32.374]                       invisible(muffled)
[11:01:32.374]                     }
[11:01:32.374]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.374]                   }
[11:01:32.374]                 }
[11:01:32.374]             }
[11:01:32.374]         }))
[11:01:32.374]     }, error = function(ex) {
[11:01:32.374]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.374]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.374]                 ...future.rng), started = ...future.startTime, 
[11:01:32.374]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.374]             version = "1.8"), class = "FutureResult")
[11:01:32.374]     }, finally = {
[11:01:32.374]         if (!identical(...future.workdir, getwd())) 
[11:01:32.374]             setwd(...future.workdir)
[11:01:32.374]         {
[11:01:32.374]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.374]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.374]             }
[11:01:32.374]             base::options(...future.oldOptions)
[11:01:32.374]             if (.Platform$OS.type == "windows") {
[11:01:32.374]                 old_names <- names(...future.oldEnvVars)
[11:01:32.374]                 envs <- base::Sys.getenv()
[11:01:32.374]                 names <- names(envs)
[11:01:32.374]                 common <- intersect(names, old_names)
[11:01:32.374]                 added <- setdiff(names, old_names)
[11:01:32.374]                 removed <- setdiff(old_names, names)
[11:01:32.374]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.374]                   envs[common]]
[11:01:32.374]                 NAMES <- toupper(changed)
[11:01:32.374]                 args <- list()
[11:01:32.374]                 for (kk in seq_along(NAMES)) {
[11:01:32.374]                   name <- changed[[kk]]
[11:01:32.374]                   NAME <- NAMES[[kk]]
[11:01:32.374]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.374]                     next
[11:01:32.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.374]                 }
[11:01:32.374]                 NAMES <- toupper(added)
[11:01:32.374]                 for (kk in seq_along(NAMES)) {
[11:01:32.374]                   name <- added[[kk]]
[11:01:32.374]                   NAME <- NAMES[[kk]]
[11:01:32.374]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.374]                     next
[11:01:32.374]                   args[[name]] <- ""
[11:01:32.374]                 }
[11:01:32.374]                 NAMES <- toupper(removed)
[11:01:32.374]                 for (kk in seq_along(NAMES)) {
[11:01:32.374]                   name <- removed[[kk]]
[11:01:32.374]                   NAME <- NAMES[[kk]]
[11:01:32.374]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.374]                     next
[11:01:32.374]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.374]                 }
[11:01:32.374]                 if (length(args) > 0) 
[11:01:32.374]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.374]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.374]             }
[11:01:32.374]             else {
[11:01:32.374]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.374]             }
[11:01:32.374]             {
[11:01:32.374]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.374]                   0L) {
[11:01:32.374]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.374]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.374]                   base::options(opts)
[11:01:32.374]                 }
[11:01:32.374]                 {
[11:01:32.374]                   {
[11:01:32.374]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.374]                     NULL
[11:01:32.374]                   }
[11:01:32.374]                   options(future.plan = NULL)
[11:01:32.374]                   if (is.na(NA_character_)) 
[11:01:32.374]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.374]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.374]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.374]                     .init = FALSE)
[11:01:32.374]                 }
[11:01:32.374]             }
[11:01:32.374]         }
[11:01:32.374]     })
[11:01:32.374]     if (TRUE) {
[11:01:32.374]         base::sink(type = "output", split = FALSE)
[11:01:32.374]         if (TRUE) {
[11:01:32.374]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.374]         }
[11:01:32.374]         else {
[11:01:32.374]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.374]         }
[11:01:32.374]         base::close(...future.stdout)
[11:01:32.374]         ...future.stdout <- NULL
[11:01:32.374]     }
[11:01:32.374]     ...future.result$conditions <- ...future.conditions
[11:01:32.374]     ...future.result$finished <- base::Sys.time()
[11:01:32.374]     ...future.result
[11:01:32.374] }
[11:01:32.376] requestCore(): workers = 2
[11:01:32.378] MulticoreFuture started
[11:01:32.379] - Launch lazy future ... done
[11:01:32.379] run() for ‘MulticoreFuture’ ... done
[11:01:32.379] getGlobalsAndPackages() ...
[11:01:32.380] plan(): Setting new future strategy stack:
[11:01:32.380] Searching for globals...
[11:01:32.381] 
[11:01:32.380] List of future strategies:
[11:01:32.380] 1. sequential:
[11:01:32.380]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.380]    - tweaked: FALSE
[11:01:32.380]    - call: NULL
[11:01:32.381] Searching for globals ... DONE
[11:01:32.381] plan(): nbrOfWorkers() = 1
[11:01:32.381] - globals: [0] <none>
[11:01:32.381] getGlobalsAndPackages() ... DONE
[11:01:32.382] run() for ‘Future’ ...
[11:01:32.382] - state: ‘created’
[11:01:32.382] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.383] plan(): Setting new future strategy stack:
[11:01:32.383] List of future strategies:
[11:01:32.383] 1. multicore:
[11:01:32.383]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.383]    - tweaked: FALSE
[11:01:32.383]    - call: plan(strategy)
[11:01:32.385] plan(): nbrOfWorkers() = 2
[11:01:32.385] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.385] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.386]   - Field: ‘label’
[11:01:32.386]   - Field: ‘local’
[11:01:32.386]   - Field: ‘owner’
[11:01:32.386]   - Field: ‘envir’
[11:01:32.386]   - Field: ‘workers’
[11:01:32.386]   - Field: ‘packages’
[11:01:32.386]   - Field: ‘gc’
[11:01:32.387]   - Field: ‘job’
[11:01:32.387]   - Field: ‘conditions’
[11:01:32.387]   - Field: ‘expr’
[11:01:32.387]   - Field: ‘uuid’
[11:01:32.387]   - Field: ‘seed’
[11:01:32.387]   - Field: ‘version’
[11:01:32.388]   - Field: ‘result’
[11:01:32.388]   - Field: ‘asynchronous’
[11:01:32.388]   - Field: ‘calls’
[11:01:32.388]   - Field: ‘globals’
[11:01:32.388]   - Field: ‘stdout’
[11:01:32.388]   - Field: ‘earlySignal’
[11:01:32.388]   - Field: ‘lazy’
[11:01:32.389]   - Field: ‘state’
[11:01:32.389] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.389] - Launch lazy future ...
[11:01:32.389] Packages needed by the future expression (n = 0): <none>
[11:01:32.389] Packages needed by future strategies (n = 0): <none>
[11:01:32.390] {
[11:01:32.390]     {
[11:01:32.390]         {
[11:01:32.390]             ...future.startTime <- base::Sys.time()
[11:01:32.390]             {
[11:01:32.390]                 {
[11:01:32.390]                   {
[11:01:32.390]                     {
[11:01:32.390]                       base::local({
[11:01:32.390]                         has_future <- base::requireNamespace("future", 
[11:01:32.390]                           quietly = TRUE)
[11:01:32.390]                         if (has_future) {
[11:01:32.390]                           ns <- base::getNamespace("future")
[11:01:32.390]                           version <- ns[[".package"]][["version"]]
[11:01:32.390]                           if (is.null(version)) 
[11:01:32.390]                             version <- utils::packageVersion("future")
[11:01:32.390]                         }
[11:01:32.390]                         else {
[11:01:32.390]                           version <- NULL
[11:01:32.390]                         }
[11:01:32.390]                         if (!has_future || version < "1.8.0") {
[11:01:32.390]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.390]                             "", base::R.version$version.string), 
[11:01:32.390]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.390]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.390]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.390]                               "release", "version")], collapse = " "), 
[11:01:32.390]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.390]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.390]                             info)
[11:01:32.390]                           info <- base::paste(info, collapse = "; ")
[11:01:32.390]                           if (!has_future) {
[11:01:32.390]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.390]                               info)
[11:01:32.390]                           }
[11:01:32.390]                           else {
[11:01:32.390]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.390]                               info, version)
[11:01:32.390]                           }
[11:01:32.390]                           base::stop(msg)
[11:01:32.390]                         }
[11:01:32.390]                       })
[11:01:32.390]                     }
[11:01:32.390]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.390]                     base::options(mc.cores = 1L)
[11:01:32.390]                   }
[11:01:32.390]                   ...future.strategy.old <- future::plan("list")
[11:01:32.390]                   options(future.plan = NULL)
[11:01:32.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.390]                 }
[11:01:32.390]                 ...future.workdir <- getwd()
[11:01:32.390]             }
[11:01:32.390]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.390]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.390]         }
[11:01:32.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.390]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.390]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.390]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.390]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.390]             base::names(...future.oldOptions))
[11:01:32.390]     }
[11:01:32.390]     if (FALSE) {
[11:01:32.390]     }
[11:01:32.390]     else {
[11:01:32.390]         if (TRUE) {
[11:01:32.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.390]                 open = "w")
[11:01:32.390]         }
[11:01:32.390]         else {
[11:01:32.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.390]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.390]         }
[11:01:32.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.390]             base::sink(type = "output", split = FALSE)
[11:01:32.390]             base::close(...future.stdout)
[11:01:32.390]         }, add = TRUE)
[11:01:32.390]     }
[11:01:32.390]     ...future.frame <- base::sys.nframe()
[11:01:32.390]     ...future.conditions <- base::list()
[11:01:32.390]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.390]     if (FALSE) {
[11:01:32.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.390]     }
[11:01:32.390]     ...future.result <- base::tryCatch({
[11:01:32.390]         base::withCallingHandlers({
[11:01:32.390]             ...future.value <- base::withVisible(base::local({
[11:01:32.390]                 withCallingHandlers({
[11:01:32.390]                   NULL
[11:01:32.390]                 }, immediateCondition = function(cond) {
[11:01:32.390]                   save_rds <- function (object, pathname, ...) 
[11:01:32.390]                   {
[11:01:32.390]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.390]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.390]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.390]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.390]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.390]                         fi_tmp[["mtime"]])
[11:01:32.390]                     }
[11:01:32.390]                     tryCatch({
[11:01:32.390]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.390]                     }, error = function(ex) {
[11:01:32.390]                       msg <- conditionMessage(ex)
[11:01:32.390]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.390]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.390]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.390]                         fi_tmp[["mtime"]], msg)
[11:01:32.390]                       ex$message <- msg
[11:01:32.390]                       stop(ex)
[11:01:32.390]                     })
[11:01:32.390]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.390]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.390]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.390]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.390]                       fi <- file.info(pathname)
[11:01:32.390]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.390]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.390]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.390]                         fi[["size"]], fi[["mtime"]])
[11:01:32.390]                       stop(msg)
[11:01:32.390]                     }
[11:01:32.390]                     invisible(pathname)
[11:01:32.390]                   }
[11:01:32.390]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.390]                     rootPath = tempdir()) 
[11:01:32.390]                   {
[11:01:32.390]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.390]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.390]                       tmpdir = path, fileext = ".rds")
[11:01:32.390]                     save_rds(obj, file)
[11:01:32.390]                   }
[11:01:32.390]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.390]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.390]                   {
[11:01:32.390]                     inherits <- base::inherits
[11:01:32.390]                     invokeRestart <- base::invokeRestart
[11:01:32.390]                     is.null <- base::is.null
[11:01:32.390]                     muffled <- FALSE
[11:01:32.390]                     if (inherits(cond, "message")) {
[11:01:32.390]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.390]                       if (muffled) 
[11:01:32.390]                         invokeRestart("muffleMessage")
[11:01:32.390]                     }
[11:01:32.390]                     else if (inherits(cond, "warning")) {
[11:01:32.390]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.390]                       if (muffled) 
[11:01:32.390]                         invokeRestart("muffleWarning")
[11:01:32.390]                     }
[11:01:32.390]                     else if (inherits(cond, "condition")) {
[11:01:32.390]                       if (!is.null(pattern)) {
[11:01:32.390]                         computeRestarts <- base::computeRestarts
[11:01:32.390]                         grepl <- base::grepl
[11:01:32.390]                         restarts <- computeRestarts(cond)
[11:01:32.390]                         for (restart in restarts) {
[11:01:32.390]                           name <- restart$name
[11:01:32.390]                           if (is.null(name)) 
[11:01:32.390]                             next
[11:01:32.390]                           if (!grepl(pattern, name)) 
[11:01:32.390]                             next
[11:01:32.390]                           invokeRestart(restart)
[11:01:32.390]                           muffled <- TRUE
[11:01:32.390]                           break
[11:01:32.390]                         }
[11:01:32.390]                       }
[11:01:32.390]                     }
[11:01:32.390]                     invisible(muffled)
[11:01:32.390]                   }
[11:01:32.390]                   muffleCondition(cond)
[11:01:32.390]                 })
[11:01:32.390]             }))
[11:01:32.390]             future::FutureResult(value = ...future.value$value, 
[11:01:32.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.390]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.390]                     ...future.globalenv.names))
[11:01:32.390]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.390]         }, condition = base::local({
[11:01:32.390]             c <- base::c
[11:01:32.390]             inherits <- base::inherits
[11:01:32.390]             invokeRestart <- base::invokeRestart
[11:01:32.390]             length <- base::length
[11:01:32.390]             list <- base::list
[11:01:32.390]             seq.int <- base::seq.int
[11:01:32.390]             signalCondition <- base::signalCondition
[11:01:32.390]             sys.calls <- base::sys.calls
[11:01:32.390]             `[[` <- base::`[[`
[11:01:32.390]             `+` <- base::`+`
[11:01:32.390]             `<<-` <- base::`<<-`
[11:01:32.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.390]                   3L)]
[11:01:32.390]             }
[11:01:32.390]             function(cond) {
[11:01:32.390]                 is_error <- inherits(cond, "error")
[11:01:32.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.390]                   NULL)
[11:01:32.390]                 if (is_error) {
[11:01:32.390]                   sessionInformation <- function() {
[11:01:32.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.390]                       search = base::search(), system = base::Sys.info())
[11:01:32.390]                   }
[11:01:32.390]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.390]                     cond$call), session = sessionInformation(), 
[11:01:32.390]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.390]                   signalCondition(cond)
[11:01:32.390]                 }
[11:01:32.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.390]                 "immediateCondition"))) {
[11:01:32.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.390]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.390]                   if (TRUE && !signal) {
[11:01:32.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.390]                     {
[11:01:32.390]                       inherits <- base::inherits
[11:01:32.390]                       invokeRestart <- base::invokeRestart
[11:01:32.390]                       is.null <- base::is.null
[11:01:32.390]                       muffled <- FALSE
[11:01:32.390]                       if (inherits(cond, "message")) {
[11:01:32.390]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.390]                         if (muffled) 
[11:01:32.390]                           invokeRestart("muffleMessage")
[11:01:32.390]                       }
[11:01:32.390]                       else if (inherits(cond, "warning")) {
[11:01:32.390]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.390]                         if (muffled) 
[11:01:32.390]                           invokeRestart("muffleWarning")
[11:01:32.390]                       }
[11:01:32.390]                       else if (inherits(cond, "condition")) {
[11:01:32.390]                         if (!is.null(pattern)) {
[11:01:32.390]                           computeRestarts <- base::computeRestarts
[11:01:32.390]                           grepl <- base::grepl
[11:01:32.390]                           restarts <- computeRestarts(cond)
[11:01:32.390]                           for (restart in restarts) {
[11:01:32.390]                             name <- restart$name
[11:01:32.390]                             if (is.null(name)) 
[11:01:32.390]                               next
[11:01:32.390]                             if (!grepl(pattern, name)) 
[11:01:32.390]                               next
[11:01:32.390]                             invokeRestart(restart)
[11:01:32.390]                             muffled <- TRUE
[11:01:32.390]                             break
[11:01:32.390]                           }
[11:01:32.390]                         }
[11:01:32.390]                       }
[11:01:32.390]                       invisible(muffled)
[11:01:32.390]                     }
[11:01:32.390]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.390]                   }
[11:01:32.390]                 }
[11:01:32.390]                 else {
[11:01:32.390]                   if (TRUE) {
[11:01:32.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.390]                     {
[11:01:32.390]                       inherits <- base::inherits
[11:01:32.390]                       invokeRestart <- base::invokeRestart
[11:01:32.390]                       is.null <- base::is.null
[11:01:32.390]                       muffled <- FALSE
[11:01:32.390]                       if (inherits(cond, "message")) {
[11:01:32.390]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.390]                         if (muffled) 
[11:01:32.390]                           invokeRestart("muffleMessage")
[11:01:32.390]                       }
[11:01:32.390]                       else if (inherits(cond, "warning")) {
[11:01:32.390]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.390]                         if (muffled) 
[11:01:32.390]                           invokeRestart("muffleWarning")
[11:01:32.390]                       }
[11:01:32.390]                       else if (inherits(cond, "condition")) {
[11:01:32.390]                         if (!is.null(pattern)) {
[11:01:32.390]                           computeRestarts <- base::computeRestarts
[11:01:32.390]                           grepl <- base::grepl
[11:01:32.390]                           restarts <- computeRestarts(cond)
[11:01:32.390]                           for (restart in restarts) {
[11:01:32.390]                             name <- restart$name
[11:01:32.390]                             if (is.null(name)) 
[11:01:32.390]                               next
[11:01:32.390]                             if (!grepl(pattern, name)) 
[11:01:32.390]                               next
[11:01:32.390]                             invokeRestart(restart)
[11:01:32.390]                             muffled <- TRUE
[11:01:32.390]                             break
[11:01:32.390]                           }
[11:01:32.390]                         }
[11:01:32.390]                       }
[11:01:32.390]                       invisible(muffled)
[11:01:32.390]                     }
[11:01:32.390]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.390]                   }
[11:01:32.390]                 }
[11:01:32.390]             }
[11:01:32.390]         }))
[11:01:32.390]     }, error = function(ex) {
[11:01:32.390]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.390]                 ...future.rng), started = ...future.startTime, 
[11:01:32.390]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.390]             version = "1.8"), class = "FutureResult")
[11:01:32.390]     }, finally = {
[11:01:32.390]         if (!identical(...future.workdir, getwd())) 
[11:01:32.390]             setwd(...future.workdir)
[11:01:32.390]         {
[11:01:32.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.390]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.390]             }
[11:01:32.390]             base::options(...future.oldOptions)
[11:01:32.390]             if (.Platform$OS.type == "windows") {
[11:01:32.390]                 old_names <- names(...future.oldEnvVars)
[11:01:32.390]                 envs <- base::Sys.getenv()
[11:01:32.390]                 names <- names(envs)
[11:01:32.390]                 common <- intersect(names, old_names)
[11:01:32.390]                 added <- setdiff(names, old_names)
[11:01:32.390]                 removed <- setdiff(old_names, names)
[11:01:32.390]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.390]                   envs[common]]
[11:01:32.390]                 NAMES <- toupper(changed)
[11:01:32.390]                 args <- list()
[11:01:32.390]                 for (kk in seq_along(NAMES)) {
[11:01:32.390]                   name <- changed[[kk]]
[11:01:32.390]                   NAME <- NAMES[[kk]]
[11:01:32.390]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.390]                     next
[11:01:32.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.390]                 }
[11:01:32.390]                 NAMES <- toupper(added)
[11:01:32.390]                 for (kk in seq_along(NAMES)) {
[11:01:32.390]                   name <- added[[kk]]
[11:01:32.390]                   NAME <- NAMES[[kk]]
[11:01:32.390]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.390]                     next
[11:01:32.390]                   args[[name]] <- ""
[11:01:32.390]                 }
[11:01:32.390]                 NAMES <- toupper(removed)
[11:01:32.390]                 for (kk in seq_along(NAMES)) {
[11:01:32.390]                   name <- removed[[kk]]
[11:01:32.390]                   NAME <- NAMES[[kk]]
[11:01:32.390]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.390]                     next
[11:01:32.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.390]                 }
[11:01:32.390]                 if (length(args) > 0) 
[11:01:32.390]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.390]             }
[11:01:32.390]             else {
[11:01:32.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.390]             }
[11:01:32.390]             {
[11:01:32.390]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.390]                   0L) {
[11:01:32.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.390]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.390]                   base::options(opts)
[11:01:32.390]                 }
[11:01:32.390]                 {
[11:01:32.390]                   {
[11:01:32.390]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.390]                     NULL
[11:01:32.390]                   }
[11:01:32.390]                   options(future.plan = NULL)
[11:01:32.390]                   if (is.na(NA_character_)) 
[11:01:32.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.390]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.390]                     .init = FALSE)
[11:01:32.390]                 }
[11:01:32.390]             }
[11:01:32.390]         }
[11:01:32.390]     })
[11:01:32.390]     if (TRUE) {
[11:01:32.390]         base::sink(type = "output", split = FALSE)
[11:01:32.390]         if (TRUE) {
[11:01:32.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.390]         }
[11:01:32.390]         else {
[11:01:32.390]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.390]         }
[11:01:32.390]         base::close(...future.stdout)
[11:01:32.390]         ...future.stdout <- NULL
[11:01:32.390]     }
[11:01:32.390]     ...future.result$conditions <- ...future.conditions
[11:01:32.390]     ...future.result$finished <- base::Sys.time()
[11:01:32.390]     ...future.result
[11:01:32.390] }
[11:01:32.394] requestCore(): workers = 2
[11:01:32.397] MulticoreFuture started
[11:01:32.397] - Launch lazy future ... done
[11:01:32.398] run() for ‘MulticoreFuture’ ... done
[11:01:32.398] plan(): Setting new future strategy stack:
[11:01:32.399] getGlobalsAndPackages() ...
[11:01:32.399] Searching for globals...
[11:01:32.398] List of future strategies:
[11:01:32.398] 1. sequential:
[11:01:32.398]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.398]    - tweaked: FALSE
[11:01:32.398]    - call: NULL
[11:01:32.400] plan(): nbrOfWorkers() = 1
[11:01:32.401] - globals found: [1] ‘{’
[11:01:32.401] Searching for globals ... DONE
[11:01:32.402] Resolving globals: FALSE
[11:01:32.402] 
[11:01:32.403] 
[11:01:32.403] getGlobalsAndPackages() ... DONE
[11:01:32.403] plan(): Setting new future strategy stack:
[11:01:32.403] run() for ‘Future’ ...
[11:01:32.403] List of future strategies:
[11:01:32.403] 1. multicore:
[11:01:32.403]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.403]    - tweaked: FALSE
[11:01:32.403]    - call: plan(strategy)
[11:01:32.404] - state: ‘created’
[11:01:32.404] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.407] plan(): nbrOfWorkers() = 2
[11:01:32.408] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.408] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.408]   - Field: ‘label’
[11:01:32.408]   - Field: ‘local’
[11:01:32.409]   - Field: ‘owner’
[11:01:32.409]   - Field: ‘envir’
[11:01:32.409]   - Field: ‘workers’
[11:01:32.409]   - Field: ‘packages’
[11:01:32.409]   - Field: ‘gc’
[11:01:32.409]   - Field: ‘job’
[11:01:32.410]   - Field: ‘conditions’
[11:01:32.410]   - Field: ‘expr’
[11:01:32.410]   - Field: ‘uuid’
[11:01:32.410]   - Field: ‘seed’
[11:01:32.410]   - Field: ‘version’
[11:01:32.410]   - Field: ‘result’
[11:01:32.410]   - Field: ‘asynchronous’
[11:01:32.410]   - Field: ‘calls’
[11:01:32.411]   - Field: ‘globals’
[11:01:32.411]   - Field: ‘stdout’
[11:01:32.411]   - Field: ‘earlySignal’
[11:01:32.411]   - Field: ‘lazy’
[11:01:32.411]   - Field: ‘state’
[11:01:32.411] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.411] - Launch lazy future ...
[11:01:32.412] Packages needed by the future expression (n = 0): <none>
[11:01:32.412] Packages needed by future strategies (n = 0): <none>
[11:01:32.413] {
[11:01:32.413]     {
[11:01:32.413]         {
[11:01:32.413]             ...future.startTime <- base::Sys.time()
[11:01:32.413]             {
[11:01:32.413]                 {
[11:01:32.413]                   {
[11:01:32.413]                     {
[11:01:32.413]                       base::local({
[11:01:32.413]                         has_future <- base::requireNamespace("future", 
[11:01:32.413]                           quietly = TRUE)
[11:01:32.413]                         if (has_future) {
[11:01:32.413]                           ns <- base::getNamespace("future")
[11:01:32.413]                           version <- ns[[".package"]][["version"]]
[11:01:32.413]                           if (is.null(version)) 
[11:01:32.413]                             version <- utils::packageVersion("future")
[11:01:32.413]                         }
[11:01:32.413]                         else {
[11:01:32.413]                           version <- NULL
[11:01:32.413]                         }
[11:01:32.413]                         if (!has_future || version < "1.8.0") {
[11:01:32.413]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.413]                             "", base::R.version$version.string), 
[11:01:32.413]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.413]                               "release", "version")], collapse = " "), 
[11:01:32.413]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.413]                             info)
[11:01:32.413]                           info <- base::paste(info, collapse = "; ")
[11:01:32.413]                           if (!has_future) {
[11:01:32.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.413]                               info)
[11:01:32.413]                           }
[11:01:32.413]                           else {
[11:01:32.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.413]                               info, version)
[11:01:32.413]                           }
[11:01:32.413]                           base::stop(msg)
[11:01:32.413]                         }
[11:01:32.413]                       })
[11:01:32.413]                     }
[11:01:32.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.413]                     base::options(mc.cores = 1L)
[11:01:32.413]                   }
[11:01:32.413]                   ...future.strategy.old <- future::plan("list")
[11:01:32.413]                   options(future.plan = NULL)
[11:01:32.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.413]                 }
[11:01:32.413]                 ...future.workdir <- getwd()
[11:01:32.413]             }
[11:01:32.413]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.413]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.413]         }
[11:01:32.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.413]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.413]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.413]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.413]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.413]             base::names(...future.oldOptions))
[11:01:32.413]     }
[11:01:32.413]     if (FALSE) {
[11:01:32.413]     }
[11:01:32.413]     else {
[11:01:32.413]         if (TRUE) {
[11:01:32.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.413]                 open = "w")
[11:01:32.413]         }
[11:01:32.413]         else {
[11:01:32.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.413]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.413]         }
[11:01:32.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.413]             base::sink(type = "output", split = FALSE)
[11:01:32.413]             base::close(...future.stdout)
[11:01:32.413]         }, add = TRUE)
[11:01:32.413]     }
[11:01:32.413]     ...future.frame <- base::sys.nframe()
[11:01:32.413]     ...future.conditions <- base::list()
[11:01:32.413]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.413]     if (FALSE) {
[11:01:32.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.413]     }
[11:01:32.413]     ...future.result <- base::tryCatch({
[11:01:32.413]         base::withCallingHandlers({
[11:01:32.413]             ...future.value <- base::withVisible(base::local({
[11:01:32.413]                 withCallingHandlers({
[11:01:32.413]                   {
[11:01:32.413]                     4
[11:01:32.413]                   }
[11:01:32.413]                 }, immediateCondition = function(cond) {
[11:01:32.413]                   save_rds <- function (object, pathname, ...) 
[11:01:32.413]                   {
[11:01:32.413]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.413]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.413]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.413]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.413]                         fi_tmp[["mtime"]])
[11:01:32.413]                     }
[11:01:32.413]                     tryCatch({
[11:01:32.413]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.413]                     }, error = function(ex) {
[11:01:32.413]                       msg <- conditionMessage(ex)
[11:01:32.413]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.413]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.413]                         fi_tmp[["mtime"]], msg)
[11:01:32.413]                       ex$message <- msg
[11:01:32.413]                       stop(ex)
[11:01:32.413]                     })
[11:01:32.413]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.413]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.413]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.413]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.413]                       fi <- file.info(pathname)
[11:01:32.413]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.413]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.413]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.413]                         fi[["size"]], fi[["mtime"]])
[11:01:32.413]                       stop(msg)
[11:01:32.413]                     }
[11:01:32.413]                     invisible(pathname)
[11:01:32.413]                   }
[11:01:32.413]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.413]                     rootPath = tempdir()) 
[11:01:32.413]                   {
[11:01:32.413]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.413]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.413]                       tmpdir = path, fileext = ".rds")
[11:01:32.413]                     save_rds(obj, file)
[11:01:32.413]                   }
[11:01:32.413]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.413]                   {
[11:01:32.413]                     inherits <- base::inherits
[11:01:32.413]                     invokeRestart <- base::invokeRestart
[11:01:32.413]                     is.null <- base::is.null
[11:01:32.413]                     muffled <- FALSE
[11:01:32.413]                     if (inherits(cond, "message")) {
[11:01:32.413]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.413]                       if (muffled) 
[11:01:32.413]                         invokeRestart("muffleMessage")
[11:01:32.413]                     }
[11:01:32.413]                     else if (inherits(cond, "warning")) {
[11:01:32.413]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.413]                       if (muffled) 
[11:01:32.413]                         invokeRestart("muffleWarning")
[11:01:32.413]                     }
[11:01:32.413]                     else if (inherits(cond, "condition")) {
[11:01:32.413]                       if (!is.null(pattern)) {
[11:01:32.413]                         computeRestarts <- base::computeRestarts
[11:01:32.413]                         grepl <- base::grepl
[11:01:32.413]                         restarts <- computeRestarts(cond)
[11:01:32.413]                         for (restart in restarts) {
[11:01:32.413]                           name <- restart$name
[11:01:32.413]                           if (is.null(name)) 
[11:01:32.413]                             next
[11:01:32.413]                           if (!grepl(pattern, name)) 
[11:01:32.413]                             next
[11:01:32.413]                           invokeRestart(restart)
[11:01:32.413]                           muffled <- TRUE
[11:01:32.413]                           break
[11:01:32.413]                         }
[11:01:32.413]                       }
[11:01:32.413]                     }
[11:01:32.413]                     invisible(muffled)
[11:01:32.413]                   }
[11:01:32.413]                   muffleCondition(cond)
[11:01:32.413]                 })
[11:01:32.413]             }))
[11:01:32.413]             future::FutureResult(value = ...future.value$value, 
[11:01:32.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.413]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.413]                     ...future.globalenv.names))
[11:01:32.413]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.413]         }, condition = base::local({
[11:01:32.413]             c <- base::c
[11:01:32.413]             inherits <- base::inherits
[11:01:32.413]             invokeRestart <- base::invokeRestart
[11:01:32.413]             length <- base::length
[11:01:32.413]             list <- base::list
[11:01:32.413]             seq.int <- base::seq.int
[11:01:32.413]             signalCondition <- base::signalCondition
[11:01:32.413]             sys.calls <- base::sys.calls
[11:01:32.413]             `[[` <- base::`[[`
[11:01:32.413]             `+` <- base::`+`
[11:01:32.413]             `<<-` <- base::`<<-`
[11:01:32.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.413]                   3L)]
[11:01:32.413]             }
[11:01:32.413]             function(cond) {
[11:01:32.413]                 is_error <- inherits(cond, "error")
[11:01:32.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.413]                   NULL)
[11:01:32.413]                 if (is_error) {
[11:01:32.413]                   sessionInformation <- function() {
[11:01:32.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.413]                       search = base::search(), system = base::Sys.info())
[11:01:32.413]                   }
[11:01:32.413]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.413]                     cond$call), session = sessionInformation(), 
[11:01:32.413]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.413]                   signalCondition(cond)
[11:01:32.413]                 }
[11:01:32.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.413]                 "immediateCondition"))) {
[11:01:32.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.413]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.413]                   if (TRUE && !signal) {
[11:01:32.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.413]                     {
[11:01:32.413]                       inherits <- base::inherits
[11:01:32.413]                       invokeRestart <- base::invokeRestart
[11:01:32.413]                       is.null <- base::is.null
[11:01:32.413]                       muffled <- FALSE
[11:01:32.413]                       if (inherits(cond, "message")) {
[11:01:32.413]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.413]                         if (muffled) 
[11:01:32.413]                           invokeRestart("muffleMessage")
[11:01:32.413]                       }
[11:01:32.413]                       else if (inherits(cond, "warning")) {
[11:01:32.413]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.413]                         if (muffled) 
[11:01:32.413]                           invokeRestart("muffleWarning")
[11:01:32.413]                       }
[11:01:32.413]                       else if (inherits(cond, "condition")) {
[11:01:32.413]                         if (!is.null(pattern)) {
[11:01:32.413]                           computeRestarts <- base::computeRestarts
[11:01:32.413]                           grepl <- base::grepl
[11:01:32.413]                           restarts <- computeRestarts(cond)
[11:01:32.413]                           for (restart in restarts) {
[11:01:32.413]                             name <- restart$name
[11:01:32.413]                             if (is.null(name)) 
[11:01:32.413]                               next
[11:01:32.413]                             if (!grepl(pattern, name)) 
[11:01:32.413]                               next
[11:01:32.413]                             invokeRestart(restart)
[11:01:32.413]                             muffled <- TRUE
[11:01:32.413]                             break
[11:01:32.413]                           }
[11:01:32.413]                         }
[11:01:32.413]                       }
[11:01:32.413]                       invisible(muffled)
[11:01:32.413]                     }
[11:01:32.413]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.413]                   }
[11:01:32.413]                 }
[11:01:32.413]                 else {
[11:01:32.413]                   if (TRUE) {
[11:01:32.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.413]                     {
[11:01:32.413]                       inherits <- base::inherits
[11:01:32.413]                       invokeRestart <- base::invokeRestart
[11:01:32.413]                       is.null <- base::is.null
[11:01:32.413]                       muffled <- FALSE
[11:01:32.413]                       if (inherits(cond, "message")) {
[11:01:32.413]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.413]                         if (muffled) 
[11:01:32.413]                           invokeRestart("muffleMessage")
[11:01:32.413]                       }
[11:01:32.413]                       else if (inherits(cond, "warning")) {
[11:01:32.413]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.413]                         if (muffled) 
[11:01:32.413]                           invokeRestart("muffleWarning")
[11:01:32.413]                       }
[11:01:32.413]                       else if (inherits(cond, "condition")) {
[11:01:32.413]                         if (!is.null(pattern)) {
[11:01:32.413]                           computeRestarts <- base::computeRestarts
[11:01:32.413]                           grepl <- base::grepl
[11:01:32.413]                           restarts <- computeRestarts(cond)
[11:01:32.413]                           for (restart in restarts) {
[11:01:32.413]                             name <- restart$name
[11:01:32.413]                             if (is.null(name)) 
[11:01:32.413]                               next
[11:01:32.413]                             if (!grepl(pattern, name)) 
[11:01:32.413]                               next
[11:01:32.413]                             invokeRestart(restart)
[11:01:32.413]                             muffled <- TRUE
[11:01:32.413]                             break
[11:01:32.413]                           }
[11:01:32.413]                         }
[11:01:32.413]                       }
[11:01:32.413]                       invisible(muffled)
[11:01:32.413]                     }
[11:01:32.413]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.413]                   }
[11:01:32.413]                 }
[11:01:32.413]             }
[11:01:32.413]         }))
[11:01:32.413]     }, error = function(ex) {
[11:01:32.413]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.413]                 ...future.rng), started = ...future.startTime, 
[11:01:32.413]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.413]             version = "1.8"), class = "FutureResult")
[11:01:32.413]     }, finally = {
[11:01:32.413]         if (!identical(...future.workdir, getwd())) 
[11:01:32.413]             setwd(...future.workdir)
[11:01:32.413]         {
[11:01:32.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.413]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.413]             }
[11:01:32.413]             base::options(...future.oldOptions)
[11:01:32.413]             if (.Platform$OS.type == "windows") {
[11:01:32.413]                 old_names <- names(...future.oldEnvVars)
[11:01:32.413]                 envs <- base::Sys.getenv()
[11:01:32.413]                 names <- names(envs)
[11:01:32.413]                 common <- intersect(names, old_names)
[11:01:32.413]                 added <- setdiff(names, old_names)
[11:01:32.413]                 removed <- setdiff(old_names, names)
[11:01:32.413]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.413]                   envs[common]]
[11:01:32.413]                 NAMES <- toupper(changed)
[11:01:32.413]                 args <- list()
[11:01:32.413]                 for (kk in seq_along(NAMES)) {
[11:01:32.413]                   name <- changed[[kk]]
[11:01:32.413]                   NAME <- NAMES[[kk]]
[11:01:32.413]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.413]                     next
[11:01:32.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.413]                 }
[11:01:32.413]                 NAMES <- toupper(added)
[11:01:32.413]                 for (kk in seq_along(NAMES)) {
[11:01:32.413]                   name <- added[[kk]]
[11:01:32.413]                   NAME <- NAMES[[kk]]
[11:01:32.413]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.413]                     next
[11:01:32.413]                   args[[name]] <- ""
[11:01:32.413]                 }
[11:01:32.413]                 NAMES <- toupper(removed)
[11:01:32.413]                 for (kk in seq_along(NAMES)) {
[11:01:32.413]                   name <- removed[[kk]]
[11:01:32.413]                   NAME <- NAMES[[kk]]
[11:01:32.413]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.413]                     next
[11:01:32.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.413]                 }
[11:01:32.413]                 if (length(args) > 0) 
[11:01:32.413]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.413]             }
[11:01:32.413]             else {
[11:01:32.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.413]             }
[11:01:32.413]             {
[11:01:32.413]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.413]                   0L) {
[11:01:32.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.413]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.413]                   base::options(opts)
[11:01:32.413]                 }
[11:01:32.413]                 {
[11:01:32.413]                   {
[11:01:32.413]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.413]                     NULL
[11:01:32.413]                   }
[11:01:32.413]                   options(future.plan = NULL)
[11:01:32.413]                   if (is.na(NA_character_)) 
[11:01:32.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.413]                     .init = FALSE)
[11:01:32.413]                 }
[11:01:32.413]             }
[11:01:32.413]         }
[11:01:32.413]     })
[11:01:32.413]     if (TRUE) {
[11:01:32.413]         base::sink(type = "output", split = FALSE)
[11:01:32.413]         if (TRUE) {
[11:01:32.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.413]         }
[11:01:32.413]         else {
[11:01:32.413]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.413]         }
[11:01:32.413]         base::close(...future.stdout)
[11:01:32.413]         ...future.stdout <- NULL
[11:01:32.413]     }
[11:01:32.413]     ...future.result$conditions <- ...future.conditions
[11:01:32.413]     ...future.result$finished <- base::Sys.time()
[11:01:32.413]     ...future.result
[11:01:32.413] }
[11:01:32.416] requestCore(): workers = 2
[11:01:32.417] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:32.427] result() for MulticoreFuture ...
[11:01:32.428] result() for MulticoreFuture ...
[11:01:32.429] result() for MulticoreFuture ... done
[11:01:32.429] result() for MulticoreFuture ... done
[11:01:32.429] result() for MulticoreFuture ...
[11:01:32.429] result() for MulticoreFuture ... done
[11:01:32.432] MulticoreFuture started
[11:01:32.432] - Launch lazy future ... done
[11:01:32.432] run() for ‘MulticoreFuture’ ... done
[11:01:32.433] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a9c8bedc70> 
[11:01:32.433] List of future strategies:
[11:01:32.433] 1. sequential:
[11:01:32.433]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.433]    - tweaked: FALSE
[11:01:32.433]    - call: NULL
[11:01:32.435] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55a9c4c153f0> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=[11:01:32.438] plan(): Setting new future strategy stack:
List of 2
  ..$ :[11:01:32.438] List of future strategies:
[11:01:32.438] 1. multicore:
[11:01:32.438]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.438]    - tweaked: FALSE
[11:01:32.438]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[11:01:32.443] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:32.448] resolve() on list environment ...
[11:01:32.448]  recursive: 0
[11:01:32.449]  length: 6
[11:01:32.450]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:32.450] signalConditionsASAP(numeric, pos=1) ...
[11:01:32.450] - nx: 6
[11:01:32.450] - relay: TRUE
[11:01:32.450] - stdout: TRUE
[11:01:32.450] - signal: TRUE
[11:01:32.450] - resignal: FALSE
[11:01:32.451] - force: TRUE
[11:01:32.451] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.451] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.451]  - until=2
[11:01:32.451]  - relaying element #2
[11:01:32.451] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.451] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.452] signalConditionsASAP(NULL, pos=1) ... done
[11:01:32.452]  length: 5 (resolved future 1)
[11:01:32.452] Future #2
[11:01:32.452] result() for MulticoreFuture ...
[11:01:32.452] result() for MulticoreFuture ... done
[11:01:32.452] result() for MulticoreFuture ...
[11:01:32.452] result() for MulticoreFuture ... done
[11:01:32.453] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:32.453] - nx: 6
[11:01:32.453] - relay: TRUE
[11:01:32.453] - stdout: TRUE
[11:01:32.453] - signal: TRUE
[11:01:32.453] - resignal: FALSE
[11:01:32.453] - force: TRUE
[11:01:32.453] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.454] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.454]  - until=2
[11:01:32.454]  - relaying element #2
[11:01:32.454] result() for MulticoreFuture ...
[11:01:32.454] result() for MulticoreFuture ... done
[11:01:32.454] result() for MulticoreFuture ...
[11:01:32.454] result() for MulticoreFuture ... done
[11:01:32.454] result() for MulticoreFuture ...
[11:01:32.455] result() for MulticoreFuture ... done
[11:01:32.455] result() for MulticoreFuture ...
[11:01:32.455] result() for MulticoreFuture ... done
[11:01:32.455] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.455] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.455] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:32.455]  length: 4 (resolved future 2)
[11:01:32.456] Future #3
[11:01:32.456] result() for MulticoreFuture ...
[11:01:32.457] result() for MulticoreFuture ...
[11:01:32.457] result() for MulticoreFuture ... done
[11:01:32.457] result() for MulticoreFuture ... done
[11:01:32.457] result() for MulticoreFuture ...
[11:01:32.457] result() for MulticoreFuture ... done
[11:01:32.458] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:32.458] - nx: 6
[11:01:32.458] - relay: TRUE
[11:01:32.458] - stdout: TRUE
[11:01:32.458] - signal: TRUE
[11:01:32.458] - resignal: FALSE
[11:01:32.459] - force: TRUE
[11:01:32.459] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.459] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.459]  - until=3
[11:01:32.459]  - relaying element #3
[11:01:32.459] result() for MulticoreFuture ...
[11:01:32.460] result() for MulticoreFuture ... done
[11:01:32.460] result() for MulticoreFuture ...
[11:01:32.460] result() for MulticoreFuture ... done
[11:01:32.460] result() for MulticoreFuture ...
[11:01:32.460] result() for MulticoreFuture ... done
[11:01:32.461] result() for MulticoreFuture ...
[11:01:32.461] result() for MulticoreFuture ... done
[11:01:32.461] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.461] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.461] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:32.461]  length: 3 (resolved future 3)
[11:01:32.462] Future #4
[11:01:32.462] result() for MulticoreFuture ...
[11:01:32.463] result() for MulticoreFuture ...
[11:01:32.463] result() for MulticoreFuture ... done
[11:01:32.463] result() for MulticoreFuture ... done
[11:01:32.463] result() for MulticoreFuture ...
[11:01:32.463] result() for MulticoreFuture ... done
[11:01:32.464] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:32.464] - nx: 6
[11:01:32.464] - relay: TRUE
[11:01:32.464] - stdout: TRUE
[11:01:32.464] - signal: TRUE
[11:01:32.464] - resignal: FALSE
[11:01:32.465] - force: TRUE
[11:01:32.465] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.465] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.465]  - until=4
[11:01:32.465]  - relaying element #4
[11:01:32.465] result() for MulticoreFuture ...
[11:01:32.466] result() for MulticoreFuture ... done
[11:01:32.466] result() for MulticoreFuture ...
[11:01:32.466] result() for MulticoreFuture ... done
[11:01:32.466] result() for MulticoreFuture ...
[11:01:32.466] result() for MulticoreFuture ... done
[11:01:32.467] result() for MulticoreFuture ...
[11:01:32.467] result() for MulticoreFuture ... done
[11:01:32.467] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.467] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.467] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:32.467]  length: 2 (resolved future 4)
[11:01:32.467] signalConditionsASAP(NULL, pos=5) ...
[11:01:32.468] - nx: 6
[11:01:32.468] - relay: TRUE
[11:01:32.468] - stdout: TRUE
[11:01:32.468] - signal: TRUE
[11:01:32.468] - resignal: FALSE
[11:01:32.468] - force: TRUE
[11:01:32.468] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.468] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.468]  - until=6
[11:01:32.469]  - relaying element #6
[11:01:32.469] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.469] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.469] signalConditionsASAP(NULL, pos=5) ... done
[11:01:32.469]  length: 1 (resolved future 5)
[11:01:32.469] signalConditionsASAP(numeric, pos=6) ...
[11:01:32.469] - nx: 6
[11:01:32.469] - relay: TRUE
[11:01:32.469] - stdout: TRUE
[11:01:32.469] - signal: TRUE
[11:01:32.470] - resignal: FALSE
[11:01:32.470] - force: TRUE
[11:01:32.470] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.470] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.470]  - until=6
[11:01:32.470] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.470] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.470] signalConditionsASAP(numeric, pos=6) ... done
[11:01:32.470]  length: 0 (resolved future 6)
[11:01:32.470] Relaying remaining futures
[11:01:32.471] signalConditionsASAP(NULL, pos=0) ...
[11:01:32.471] - nx: 6
[11:01:32.471] - relay: TRUE
[11:01:32.471] - stdout: TRUE
[11:01:32.471] - signal: TRUE
[11:01:32.471] - resignal: FALSE
[11:01:32.471] - force: TRUE
[11:01:32.471] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.471] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:32.471] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.472] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.472] signalConditionsASAP(NULL, pos=0) ... done
[11:01:32.472] resolve() on list environment ... DONE
[11:01:32.472] result() for MulticoreFuture ...
[11:01:32.472] result() for MulticoreFuture ... done
[11:01:32.472] result() for MulticoreFuture ...
[11:01:32.472] result() for MulticoreFuture ... done
[11:01:32.472] result() for MulticoreFuture ...
[11:01:32.472] result() for MulticoreFuture ... done
[11:01:32.473] result() for MulticoreFuture ...
[11:01:32.473] result() for MulticoreFuture ... done
[11:01:32.473] result() for MulticoreFuture ...
[11:01:32.473] result() for MulticoreFuture ... done
[11:01:32.473] result() for MulticoreFuture ...
[11:01:32.473] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c4eda9a8> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[11:01:32.475] getGlobalsAndPackages() ...
[11:01:32.475] Searching for globals...
[11:01:32.476] 
[11:01:32.476] Searching for globals ... DONE
[11:01:32.476] - globals: [0] <none>
[11:01:32.476] getGlobalsAndPackages() ... DONE
[11:01:32.476] run() for ‘Future’ ...
[11:01:32.476] - state: ‘created’
[11:01:32.477] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.479] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.479] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.479]   - Field: ‘label’
[11:01:32.479]   - Field: ‘local’
[11:01:32.479]   - Field: ‘owner’
[11:01:32.479]   - Field: ‘envir’
[11:01:32.479]   - Field: ‘workers’
[11:01:32.480]   - Field: ‘packages’
[11:01:32.480]   - Field: ‘gc’
[11:01:32.480]   - Field: ‘job’
[11:01:32.480]   - Field: ‘conditions’
[11:01:32.480]   - Field: ‘expr’
[11:01:32.480]   - Field: ‘uuid’
[11:01:32.480]   - Field: ‘seed’
[11:01:32.480]   - Field: ‘version’
[11:01:32.480]   - Field: ‘result’
[11:01:32.480]   - Field: ‘asynchronous’
[11:01:32.481]   - Field: ‘calls’
[11:01:32.481]   - Field: ‘globals’
[11:01:32.481]   - Field: ‘stdout’
[11:01:32.481]   - Field: ‘earlySignal’
[11:01:32.481]   - Field: ‘lazy’
[11:01:32.481]   - Field: ‘state’
[11:01:32.481] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.481] - Launch lazy future ...
[11:01:32.482] Packages needed by the future expression (n = 0): <none>
[11:01:32.482] Packages needed by future strategies (n = 0): <none>
[11:01:32.482] {
[11:01:32.482]     {
[11:01:32.482]         {
[11:01:32.482]             ...future.startTime <- base::Sys.time()
[11:01:32.482]             {
[11:01:32.482]                 {
[11:01:32.482]                   {
[11:01:32.482]                     {
[11:01:32.482]                       base::local({
[11:01:32.482]                         has_future <- base::requireNamespace("future", 
[11:01:32.482]                           quietly = TRUE)
[11:01:32.482]                         if (has_future) {
[11:01:32.482]                           ns <- base::getNamespace("future")
[11:01:32.482]                           version <- ns[[".package"]][["version"]]
[11:01:32.482]                           if (is.null(version)) 
[11:01:32.482]                             version <- utils::packageVersion("future")
[11:01:32.482]                         }
[11:01:32.482]                         else {
[11:01:32.482]                           version <- NULL
[11:01:32.482]                         }
[11:01:32.482]                         if (!has_future || version < "1.8.0") {
[11:01:32.482]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.482]                             "", base::R.version$version.string), 
[11:01:32.482]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.482]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.482]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.482]                               "release", "version")], collapse = " "), 
[11:01:32.482]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.482]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.482]                             info)
[11:01:32.482]                           info <- base::paste(info, collapse = "; ")
[11:01:32.482]                           if (!has_future) {
[11:01:32.482]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.482]                               info)
[11:01:32.482]                           }
[11:01:32.482]                           else {
[11:01:32.482]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.482]                               info, version)
[11:01:32.482]                           }
[11:01:32.482]                           base::stop(msg)
[11:01:32.482]                         }
[11:01:32.482]                       })
[11:01:32.482]                     }
[11:01:32.482]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.482]                     base::options(mc.cores = 1L)
[11:01:32.482]                   }
[11:01:32.482]                   ...future.strategy.old <- future::plan("list")
[11:01:32.482]                   options(future.plan = NULL)
[11:01:32.482]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.482]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.482]                 }
[11:01:32.482]                 ...future.workdir <- getwd()
[11:01:32.482]             }
[11:01:32.482]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.482]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.482]         }
[11:01:32.482]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.482]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.482]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.482]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.482]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.482]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.482]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.482]             base::names(...future.oldOptions))
[11:01:32.482]     }
[11:01:32.482]     if (FALSE) {
[11:01:32.482]     }
[11:01:32.482]     else {
[11:01:32.482]         if (TRUE) {
[11:01:32.482]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.482]                 open = "w")
[11:01:32.482]         }
[11:01:32.482]         else {
[11:01:32.482]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.482]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.482]         }
[11:01:32.482]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.482]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.482]             base::sink(type = "output", split = FALSE)
[11:01:32.482]             base::close(...future.stdout)
[11:01:32.482]         }, add = TRUE)
[11:01:32.482]     }
[11:01:32.482]     ...future.frame <- base::sys.nframe()
[11:01:32.482]     ...future.conditions <- base::list()
[11:01:32.482]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.482]     if (FALSE) {
[11:01:32.482]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.482]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.482]     }
[11:01:32.482]     ...future.result <- base::tryCatch({
[11:01:32.482]         base::withCallingHandlers({
[11:01:32.482]             ...future.value <- base::withVisible(base::local({
[11:01:32.482]                 withCallingHandlers({
[11:01:32.482]                   2
[11:01:32.482]                 }, immediateCondition = function(cond) {
[11:01:32.482]                   save_rds <- function (object, pathname, ...) 
[11:01:32.482]                   {
[11:01:32.482]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.482]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.482]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.482]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.482]                         fi_tmp[["mtime"]])
[11:01:32.482]                     }
[11:01:32.482]                     tryCatch({
[11:01:32.482]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.482]                     }, error = function(ex) {
[11:01:32.482]                       msg <- conditionMessage(ex)
[11:01:32.482]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.482]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.482]                         fi_tmp[["mtime"]], msg)
[11:01:32.482]                       ex$message <- msg
[11:01:32.482]                       stop(ex)
[11:01:32.482]                     })
[11:01:32.482]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.482]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.482]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.482]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.482]                       fi <- file.info(pathname)
[11:01:32.482]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.482]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.482]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.482]                         fi[["size"]], fi[["mtime"]])
[11:01:32.482]                       stop(msg)
[11:01:32.482]                     }
[11:01:32.482]                     invisible(pathname)
[11:01:32.482]                   }
[11:01:32.482]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.482]                     rootPath = tempdir()) 
[11:01:32.482]                   {
[11:01:32.482]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.482]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.482]                       tmpdir = path, fileext = ".rds")
[11:01:32.482]                     save_rds(obj, file)
[11:01:32.482]                   }
[11:01:32.482]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.482]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.482]                   {
[11:01:32.482]                     inherits <- base::inherits
[11:01:32.482]                     invokeRestart <- base::invokeRestart
[11:01:32.482]                     is.null <- base::is.null
[11:01:32.482]                     muffled <- FALSE
[11:01:32.482]                     if (inherits(cond, "message")) {
[11:01:32.482]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.482]                       if (muffled) 
[11:01:32.482]                         invokeRestart("muffleMessage")
[11:01:32.482]                     }
[11:01:32.482]                     else if (inherits(cond, "warning")) {
[11:01:32.482]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.482]                       if (muffled) 
[11:01:32.482]                         invokeRestart("muffleWarning")
[11:01:32.482]                     }
[11:01:32.482]                     else if (inherits(cond, "condition")) {
[11:01:32.482]                       if (!is.null(pattern)) {
[11:01:32.482]                         computeRestarts <- base::computeRestarts
[11:01:32.482]                         grepl <- base::grepl
[11:01:32.482]                         restarts <- computeRestarts(cond)
[11:01:32.482]                         for (restart in restarts) {
[11:01:32.482]                           name <- restart$name
[11:01:32.482]                           if (is.null(name)) 
[11:01:32.482]                             next
[11:01:32.482]                           if (!grepl(pattern, name)) 
[11:01:32.482]                             next
[11:01:32.482]                           invokeRestart(restart)
[11:01:32.482]                           muffled <- TRUE
[11:01:32.482]                           break
[11:01:32.482]                         }
[11:01:32.482]                       }
[11:01:32.482]                     }
[11:01:32.482]                     invisible(muffled)
[11:01:32.482]                   }
[11:01:32.482]                   muffleCondition(cond)
[11:01:32.482]                 })
[11:01:32.482]             }))
[11:01:32.482]             future::FutureResult(value = ...future.value$value, 
[11:01:32.482]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.482]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.482]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.482]                     ...future.globalenv.names))
[11:01:32.482]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.482]         }, condition = base::local({
[11:01:32.482]             c <- base::c
[11:01:32.482]             inherits <- base::inherits
[11:01:32.482]             invokeRestart <- base::invokeRestart
[11:01:32.482]             length <- base::length
[11:01:32.482]             list <- base::list
[11:01:32.482]             seq.int <- base::seq.int
[11:01:32.482]             signalCondition <- base::signalCondition
[11:01:32.482]             sys.calls <- base::sys.calls
[11:01:32.482]             `[[` <- base::`[[`
[11:01:32.482]             `+` <- base::`+`
[11:01:32.482]             `<<-` <- base::`<<-`
[11:01:32.482]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.482]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.482]                   3L)]
[11:01:32.482]             }
[11:01:32.482]             function(cond) {
[11:01:32.482]                 is_error <- inherits(cond, "error")
[11:01:32.482]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.482]                   NULL)
[11:01:32.482]                 if (is_error) {
[11:01:32.482]                   sessionInformation <- function() {
[11:01:32.482]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.482]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.482]                       search = base::search(), system = base::Sys.info())
[11:01:32.482]                   }
[11:01:32.482]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.482]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.482]                     cond$call), session = sessionInformation(), 
[11:01:32.482]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.482]                   signalCondition(cond)
[11:01:32.482]                 }
[11:01:32.482]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.482]                 "immediateCondition"))) {
[11:01:32.482]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.482]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.482]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.482]                   if (TRUE && !signal) {
[11:01:32.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.482]                     {
[11:01:32.482]                       inherits <- base::inherits
[11:01:32.482]                       invokeRestart <- base::invokeRestart
[11:01:32.482]                       is.null <- base::is.null
[11:01:32.482]                       muffled <- FALSE
[11:01:32.482]                       if (inherits(cond, "message")) {
[11:01:32.482]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.482]                         if (muffled) 
[11:01:32.482]                           invokeRestart("muffleMessage")
[11:01:32.482]                       }
[11:01:32.482]                       else if (inherits(cond, "warning")) {
[11:01:32.482]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.482]                         if (muffled) 
[11:01:32.482]                           invokeRestart("muffleWarning")
[11:01:32.482]                       }
[11:01:32.482]                       else if (inherits(cond, "condition")) {
[11:01:32.482]                         if (!is.null(pattern)) {
[11:01:32.482]                           computeRestarts <- base::computeRestarts
[11:01:32.482]                           grepl <- base::grepl
[11:01:32.482]                           restarts <- computeRestarts(cond)
[11:01:32.482]                           for (restart in restarts) {
[11:01:32.482]                             name <- restart$name
[11:01:32.482]                             if (is.null(name)) 
[11:01:32.482]                               next
[11:01:32.482]                             if (!grepl(pattern, name)) 
[11:01:32.482]                               next
[11:01:32.482]                             invokeRestart(restart)
[11:01:32.482]                             muffled <- TRUE
[11:01:32.482]                             break
[11:01:32.482]                           }
[11:01:32.482]                         }
[11:01:32.482]                       }
[11:01:32.482]                       invisible(muffled)
[11:01:32.482]                     }
[11:01:32.482]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.482]                   }
[11:01:32.482]                 }
[11:01:32.482]                 else {
[11:01:32.482]                   if (TRUE) {
[11:01:32.482]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.482]                     {
[11:01:32.482]                       inherits <- base::inherits
[11:01:32.482]                       invokeRestart <- base::invokeRestart
[11:01:32.482]                       is.null <- base::is.null
[11:01:32.482]                       muffled <- FALSE
[11:01:32.482]                       if (inherits(cond, "message")) {
[11:01:32.482]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.482]                         if (muffled) 
[11:01:32.482]                           invokeRestart("muffleMessage")
[11:01:32.482]                       }
[11:01:32.482]                       else if (inherits(cond, "warning")) {
[11:01:32.482]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.482]                         if (muffled) 
[11:01:32.482]                           invokeRestart("muffleWarning")
[11:01:32.482]                       }
[11:01:32.482]                       else if (inherits(cond, "condition")) {
[11:01:32.482]                         if (!is.null(pattern)) {
[11:01:32.482]                           computeRestarts <- base::computeRestarts
[11:01:32.482]                           grepl <- base::grepl
[11:01:32.482]                           restarts <- computeRestarts(cond)
[11:01:32.482]                           for (restart in restarts) {
[11:01:32.482]                             name <- restart$name
[11:01:32.482]                             if (is.null(name)) 
[11:01:32.482]                               next
[11:01:32.482]                             if (!grepl(pattern, name)) 
[11:01:32.482]                               next
[11:01:32.482]                             invokeRestart(restart)
[11:01:32.482]                             muffled <- TRUE
[11:01:32.482]                             break
[11:01:32.482]                           }
[11:01:32.482]                         }
[11:01:32.482]                       }
[11:01:32.482]                       invisible(muffled)
[11:01:32.482]                     }
[11:01:32.482]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.482]                   }
[11:01:32.482]                 }
[11:01:32.482]             }
[11:01:32.482]         }))
[11:01:32.482]     }, error = function(ex) {
[11:01:32.482]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.482]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.482]                 ...future.rng), started = ...future.startTime, 
[11:01:32.482]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.482]             version = "1.8"), class = "FutureResult")
[11:01:32.482]     }, finally = {
[11:01:32.482]         if (!identical(...future.workdir, getwd())) 
[11:01:32.482]             setwd(...future.workdir)
[11:01:32.482]         {
[11:01:32.482]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.482]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.482]             }
[11:01:32.482]             base::options(...future.oldOptions)
[11:01:32.482]             if (.Platform$OS.type == "windows") {
[11:01:32.482]                 old_names <- names(...future.oldEnvVars)
[11:01:32.482]                 envs <- base::Sys.getenv()
[11:01:32.482]                 names <- names(envs)
[11:01:32.482]                 common <- intersect(names, old_names)
[11:01:32.482]                 added <- setdiff(names, old_names)
[11:01:32.482]                 removed <- setdiff(old_names, names)
[11:01:32.482]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.482]                   envs[common]]
[11:01:32.482]                 NAMES <- toupper(changed)
[11:01:32.482]                 args <- list()
[11:01:32.482]                 for (kk in seq_along(NAMES)) {
[11:01:32.482]                   name <- changed[[kk]]
[11:01:32.482]                   NAME <- NAMES[[kk]]
[11:01:32.482]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.482]                     next
[11:01:32.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.482]                 }
[11:01:32.482]                 NAMES <- toupper(added)
[11:01:32.482]                 for (kk in seq_along(NAMES)) {
[11:01:32.482]                   name <- added[[kk]]
[11:01:32.482]                   NAME <- NAMES[[kk]]
[11:01:32.482]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.482]                     next
[11:01:32.482]                   args[[name]] <- ""
[11:01:32.482]                 }
[11:01:32.482]                 NAMES <- toupper(removed)
[11:01:32.482]                 for (kk in seq_along(NAMES)) {
[11:01:32.482]                   name <- removed[[kk]]
[11:01:32.482]                   NAME <- NAMES[[kk]]
[11:01:32.482]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.482]                     next
[11:01:32.482]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.482]                 }
[11:01:32.482]                 if (length(args) > 0) 
[11:01:32.482]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.482]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.482]             }
[11:01:32.482]             else {
[11:01:32.482]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.482]             }
[11:01:32.482]             {
[11:01:32.482]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.482]                   0L) {
[11:01:32.482]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.482]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.482]                   base::options(opts)
[11:01:32.482]                 }
[11:01:32.482]                 {
[11:01:32.482]                   {
[11:01:32.482]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.482]                     NULL
[11:01:32.482]                   }
[11:01:32.482]                   options(future.plan = NULL)
[11:01:32.482]                   if (is.na(NA_character_)) 
[11:01:32.482]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.482]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.482]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.482]                     .init = FALSE)
[11:01:32.482]                 }
[11:01:32.482]             }
[11:01:32.482]         }
[11:01:32.482]     })
[11:01:32.482]     if (TRUE) {
[11:01:32.482]         base::sink(type = "output", split = FALSE)
[11:01:32.482]         if (TRUE) {
[11:01:32.482]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.482]         }
[11:01:32.482]         else {
[11:01:32.482]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.482]         }
[11:01:32.482]         base::close(...future.stdout)
[11:01:32.482]         ...future.stdout <- NULL
[11:01:32.482]     }
[11:01:32.482]     ...future.result$conditions <- ...future.conditions
[11:01:32.482]     ...future.result$finished <- base::Sys.time()
[11:01:32.482]     ...future.result
[11:01:32.482] }
[11:01:32.485] requestCore(): workers = 2
[11:01:32.487] MulticoreFuture started
[11:01:32.487] - Launch lazy future ... done
[11:01:32.488] run() for ‘MulticoreFuture’ ... done
[11:01:32.488] getGlobalsAndPackages() ...
[11:01:32.488] Searching for globals...
[11:01:32.488] plan(): Setting new future strategy stack:
[11:01:32.489] 
[11:01:32.489] Searching for globals ... DONE
[11:01:32.488] List of future strategies:
[11:01:32.488] 1. sequential:
[11:01:32.488]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.488]    - tweaked: FALSE
[11:01:32.488]    - call: NULL
[11:01:32.489] - globals: [0] <none>
[11:01:32.489] plan(): nbrOfWorkers() = 1
[11:01:32.489] getGlobalsAndPackages() ... DONE
[11:01:32.490] run() for ‘Future’ ...
[11:01:32.490] - state: ‘created’
[11:01:32.490] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.491] plan(): Setting new future strategy stack:
[11:01:32.491] List of future strategies:
[11:01:32.491] 1. multicore:
[11:01:32.491]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.491]    - tweaked: FALSE
[11:01:32.491]    - call: plan(strategy)
[11:01:32.493] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.494] plan(): nbrOfWorkers() = 2
[11:01:32.494] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.494]   - Field: ‘label’
[11:01:32.494]   - Field: ‘local’
[11:01:32.494]   - Field: ‘owner’
[11:01:32.494]   - Field: ‘envir’
[11:01:32.494]   - Field: ‘workers’
[11:01:32.494]   - Field: ‘packages’
[11:01:32.494]   - Field: ‘gc’
[11:01:32.495]   - Field: ‘job’
[11:01:32.495]   - Field: ‘conditions’
[11:01:32.495]   - Field: ‘expr’
[11:01:32.495]   - Field: ‘uuid’
[11:01:32.495]   - Field: ‘seed’
[11:01:32.495]   - Field: ‘version’
[11:01:32.495]   - Field: ‘result’
[11:01:32.495]   - Field: ‘asynchronous’
[11:01:32.496]   - Field: ‘calls’
[11:01:32.496]   - Field: ‘globals’
[11:01:32.496]   - Field: ‘stdout’
[11:01:32.496]   - Field: ‘earlySignal’
[11:01:32.496]   - Field: ‘lazy’
[11:01:32.496]   - Field: ‘state’
[11:01:32.496] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.496] - Launch lazy future ...
[11:01:32.497] Packages needed by the future expression (n = 0): <none>
[11:01:32.497] Packages needed by future strategies (n = 0): <none>
[11:01:32.498] {
[11:01:32.498]     {
[11:01:32.498]         {
[11:01:32.498]             ...future.startTime <- base::Sys.time()
[11:01:32.498]             {
[11:01:32.498]                 {
[11:01:32.498]                   {
[11:01:32.498]                     {
[11:01:32.498]                       base::local({
[11:01:32.498]                         has_future <- base::requireNamespace("future", 
[11:01:32.498]                           quietly = TRUE)
[11:01:32.498]                         if (has_future) {
[11:01:32.498]                           ns <- base::getNamespace("future")
[11:01:32.498]                           version <- ns[[".package"]][["version"]]
[11:01:32.498]                           if (is.null(version)) 
[11:01:32.498]                             version <- utils::packageVersion("future")
[11:01:32.498]                         }
[11:01:32.498]                         else {
[11:01:32.498]                           version <- NULL
[11:01:32.498]                         }
[11:01:32.498]                         if (!has_future || version < "1.8.0") {
[11:01:32.498]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.498]                             "", base::R.version$version.string), 
[11:01:32.498]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.498]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.498]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.498]                               "release", "version")], collapse = " "), 
[11:01:32.498]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.498]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.498]                             info)
[11:01:32.498]                           info <- base::paste(info, collapse = "; ")
[11:01:32.498]                           if (!has_future) {
[11:01:32.498]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.498]                               info)
[11:01:32.498]                           }
[11:01:32.498]                           else {
[11:01:32.498]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.498]                               info, version)
[11:01:32.498]                           }
[11:01:32.498]                           base::stop(msg)
[11:01:32.498]                         }
[11:01:32.498]                       })
[11:01:32.498]                     }
[11:01:32.498]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.498]                     base::options(mc.cores = 1L)
[11:01:32.498]                   }
[11:01:32.498]                   ...future.strategy.old <- future::plan("list")
[11:01:32.498]                   options(future.plan = NULL)
[11:01:32.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.498]                 }
[11:01:32.498]                 ...future.workdir <- getwd()
[11:01:32.498]             }
[11:01:32.498]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.498]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.498]         }
[11:01:32.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.498]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.498]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.498]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.498]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.498]             base::names(...future.oldOptions))
[11:01:32.498]     }
[11:01:32.498]     if (FALSE) {
[11:01:32.498]     }
[11:01:32.498]     else {
[11:01:32.498]         if (TRUE) {
[11:01:32.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.498]                 open = "w")
[11:01:32.498]         }
[11:01:32.498]         else {
[11:01:32.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.498]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.498]         }
[11:01:32.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.498]             base::sink(type = "output", split = FALSE)
[11:01:32.498]             base::close(...future.stdout)
[11:01:32.498]         }, add = TRUE)
[11:01:32.498]     }
[11:01:32.498]     ...future.frame <- base::sys.nframe()
[11:01:32.498]     ...future.conditions <- base::list()
[11:01:32.498]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.498]     if (FALSE) {
[11:01:32.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.498]     }
[11:01:32.498]     ...future.result <- base::tryCatch({
[11:01:32.498]         base::withCallingHandlers({
[11:01:32.498]             ...future.value <- base::withVisible(base::local({
[11:01:32.498]                 withCallingHandlers({
[11:01:32.498]                   NULL
[11:01:32.498]                 }, immediateCondition = function(cond) {
[11:01:32.498]                   save_rds <- function (object, pathname, ...) 
[11:01:32.498]                   {
[11:01:32.498]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.498]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.498]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.498]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.498]                         fi_tmp[["mtime"]])
[11:01:32.498]                     }
[11:01:32.498]                     tryCatch({
[11:01:32.498]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.498]                     }, error = function(ex) {
[11:01:32.498]                       msg <- conditionMessage(ex)
[11:01:32.498]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.498]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.498]                         fi_tmp[["mtime"]], msg)
[11:01:32.498]                       ex$message <- msg
[11:01:32.498]                       stop(ex)
[11:01:32.498]                     })
[11:01:32.498]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.498]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.498]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.498]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.498]                       fi <- file.info(pathname)
[11:01:32.498]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.498]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.498]                         fi[["size"]], fi[["mtime"]])
[11:01:32.498]                       stop(msg)
[11:01:32.498]                     }
[11:01:32.498]                     invisible(pathname)
[11:01:32.498]                   }
[11:01:32.498]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.498]                     rootPath = tempdir()) 
[11:01:32.498]                   {
[11:01:32.498]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.498]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.498]                       tmpdir = path, fileext = ".rds")
[11:01:32.498]                     save_rds(obj, file)
[11:01:32.498]                   }
[11:01:32.498]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.498]                   {
[11:01:32.498]                     inherits <- base::inherits
[11:01:32.498]                     invokeRestart <- base::invokeRestart
[11:01:32.498]                     is.null <- base::is.null
[11:01:32.498]                     muffled <- FALSE
[11:01:32.498]                     if (inherits(cond, "message")) {
[11:01:32.498]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.498]                       if (muffled) 
[11:01:32.498]                         invokeRestart("muffleMessage")
[11:01:32.498]                     }
[11:01:32.498]                     else if (inherits(cond, "warning")) {
[11:01:32.498]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.498]                       if (muffled) 
[11:01:32.498]                         invokeRestart("muffleWarning")
[11:01:32.498]                     }
[11:01:32.498]                     else if (inherits(cond, "condition")) {
[11:01:32.498]                       if (!is.null(pattern)) {
[11:01:32.498]                         computeRestarts <- base::computeRestarts
[11:01:32.498]                         grepl <- base::grepl
[11:01:32.498]                         restarts <- computeRestarts(cond)
[11:01:32.498]                         for (restart in restarts) {
[11:01:32.498]                           name <- restart$name
[11:01:32.498]                           if (is.null(name)) 
[11:01:32.498]                             next
[11:01:32.498]                           if (!grepl(pattern, name)) 
[11:01:32.498]                             next
[11:01:32.498]                           invokeRestart(restart)
[11:01:32.498]                           muffled <- TRUE
[11:01:32.498]                           break
[11:01:32.498]                         }
[11:01:32.498]                       }
[11:01:32.498]                     }
[11:01:32.498]                     invisible(muffled)
[11:01:32.498]                   }
[11:01:32.498]                   muffleCondition(cond)
[11:01:32.498]                 })
[11:01:32.498]             }))
[11:01:32.498]             future::FutureResult(value = ...future.value$value, 
[11:01:32.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.498]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.498]                     ...future.globalenv.names))
[11:01:32.498]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.498]         }, condition = base::local({
[11:01:32.498]             c <- base::c
[11:01:32.498]             inherits <- base::inherits
[11:01:32.498]             invokeRestart <- base::invokeRestart
[11:01:32.498]             length <- base::length
[11:01:32.498]             list <- base::list
[11:01:32.498]             seq.int <- base::seq.int
[11:01:32.498]             signalCondition <- base::signalCondition
[11:01:32.498]             sys.calls <- base::sys.calls
[11:01:32.498]             `[[` <- base::`[[`
[11:01:32.498]             `+` <- base::`+`
[11:01:32.498]             `<<-` <- base::`<<-`
[11:01:32.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.498]                   3L)]
[11:01:32.498]             }
[11:01:32.498]             function(cond) {
[11:01:32.498]                 is_error <- inherits(cond, "error")
[11:01:32.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.498]                   NULL)
[11:01:32.498]                 if (is_error) {
[11:01:32.498]                   sessionInformation <- function() {
[11:01:32.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.498]                       search = base::search(), system = base::Sys.info())
[11:01:32.498]                   }
[11:01:32.498]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.498]                     cond$call), session = sessionInformation(), 
[11:01:32.498]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.498]                   signalCondition(cond)
[11:01:32.498]                 }
[11:01:32.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.498]                 "immediateCondition"))) {
[11:01:32.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.498]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.498]                   if (TRUE && !signal) {
[11:01:32.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.498]                     {
[11:01:32.498]                       inherits <- base::inherits
[11:01:32.498]                       invokeRestart <- base::invokeRestart
[11:01:32.498]                       is.null <- base::is.null
[11:01:32.498]                       muffled <- FALSE
[11:01:32.498]                       if (inherits(cond, "message")) {
[11:01:32.498]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.498]                         if (muffled) 
[11:01:32.498]                           invokeRestart("muffleMessage")
[11:01:32.498]                       }
[11:01:32.498]                       else if (inherits(cond, "warning")) {
[11:01:32.498]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.498]                         if (muffled) 
[11:01:32.498]                           invokeRestart("muffleWarning")
[11:01:32.498]                       }
[11:01:32.498]                       else if (inherits(cond, "condition")) {
[11:01:32.498]                         if (!is.null(pattern)) {
[11:01:32.498]                           computeRestarts <- base::computeRestarts
[11:01:32.498]                           grepl <- base::grepl
[11:01:32.498]                           restarts <- computeRestarts(cond)
[11:01:32.498]                           for (restart in restarts) {
[11:01:32.498]                             name <- restart$name
[11:01:32.498]                             if (is.null(name)) 
[11:01:32.498]                               next
[11:01:32.498]                             if (!grepl(pattern, name)) 
[11:01:32.498]                               next
[11:01:32.498]                             invokeRestart(restart)
[11:01:32.498]                             muffled <- TRUE
[11:01:32.498]                             break
[11:01:32.498]                           }
[11:01:32.498]                         }
[11:01:32.498]                       }
[11:01:32.498]                       invisible(muffled)
[11:01:32.498]                     }
[11:01:32.498]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.498]                   }
[11:01:32.498]                 }
[11:01:32.498]                 else {
[11:01:32.498]                   if (TRUE) {
[11:01:32.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.498]                     {
[11:01:32.498]                       inherits <- base::inherits
[11:01:32.498]                       invokeRestart <- base::invokeRestart
[11:01:32.498]                       is.null <- base::is.null
[11:01:32.498]                       muffled <- FALSE
[11:01:32.498]                       if (inherits(cond, "message")) {
[11:01:32.498]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.498]                         if (muffled) 
[11:01:32.498]                           invokeRestart("muffleMessage")
[11:01:32.498]                       }
[11:01:32.498]                       else if (inherits(cond, "warning")) {
[11:01:32.498]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.498]                         if (muffled) 
[11:01:32.498]                           invokeRestart("muffleWarning")
[11:01:32.498]                       }
[11:01:32.498]                       else if (inherits(cond, "condition")) {
[11:01:32.498]                         if (!is.null(pattern)) {
[11:01:32.498]                           computeRestarts <- base::computeRestarts
[11:01:32.498]                           grepl <- base::grepl
[11:01:32.498]                           restarts <- computeRestarts(cond)
[11:01:32.498]                           for (restart in restarts) {
[11:01:32.498]                             name <- restart$name
[11:01:32.498]                             if (is.null(name)) 
[11:01:32.498]                               next
[11:01:32.498]                             if (!grepl(pattern, name)) 
[11:01:32.498]                               next
[11:01:32.498]                             invokeRestart(restart)
[11:01:32.498]                             muffled <- TRUE
[11:01:32.498]                             break
[11:01:32.498]                           }
[11:01:32.498]                         }
[11:01:32.498]                       }
[11:01:32.498]                       invisible(muffled)
[11:01:32.498]                     }
[11:01:32.498]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.498]                   }
[11:01:32.498]                 }
[11:01:32.498]             }
[11:01:32.498]         }))
[11:01:32.498]     }, error = function(ex) {
[11:01:32.498]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.498]                 ...future.rng), started = ...future.startTime, 
[11:01:32.498]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.498]             version = "1.8"), class = "FutureResult")
[11:01:32.498]     }, finally = {
[11:01:32.498]         if (!identical(...future.workdir, getwd())) 
[11:01:32.498]             setwd(...future.workdir)
[11:01:32.498]         {
[11:01:32.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.498]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.498]             }
[11:01:32.498]             base::options(...future.oldOptions)
[11:01:32.498]             if (.Platform$OS.type == "windows") {
[11:01:32.498]                 old_names <- names(...future.oldEnvVars)
[11:01:32.498]                 envs <- base::Sys.getenv()
[11:01:32.498]                 names <- names(envs)
[11:01:32.498]                 common <- intersect(names, old_names)
[11:01:32.498]                 added <- setdiff(names, old_names)
[11:01:32.498]                 removed <- setdiff(old_names, names)
[11:01:32.498]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.498]                   envs[common]]
[11:01:32.498]                 NAMES <- toupper(changed)
[11:01:32.498]                 args <- list()
[11:01:32.498]                 for (kk in seq_along(NAMES)) {
[11:01:32.498]                   name <- changed[[kk]]
[11:01:32.498]                   NAME <- NAMES[[kk]]
[11:01:32.498]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.498]                     next
[11:01:32.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.498]                 }
[11:01:32.498]                 NAMES <- toupper(added)
[11:01:32.498]                 for (kk in seq_along(NAMES)) {
[11:01:32.498]                   name <- added[[kk]]
[11:01:32.498]                   NAME <- NAMES[[kk]]
[11:01:32.498]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.498]                     next
[11:01:32.498]                   args[[name]] <- ""
[11:01:32.498]                 }
[11:01:32.498]                 NAMES <- toupper(removed)
[11:01:32.498]                 for (kk in seq_along(NAMES)) {
[11:01:32.498]                   name <- removed[[kk]]
[11:01:32.498]                   NAME <- NAMES[[kk]]
[11:01:32.498]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.498]                     next
[11:01:32.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.498]                 }
[11:01:32.498]                 if (length(args) > 0) 
[11:01:32.498]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.498]             }
[11:01:32.498]             else {
[11:01:32.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.498]             }
[11:01:32.498]             {
[11:01:32.498]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.498]                   0L) {
[11:01:32.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.498]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.498]                   base::options(opts)
[11:01:32.498]                 }
[11:01:32.498]                 {
[11:01:32.498]                   {
[11:01:32.498]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.498]                     NULL
[11:01:32.498]                   }
[11:01:32.498]                   options(future.plan = NULL)
[11:01:32.498]                   if (is.na(NA_character_)) 
[11:01:32.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.498]                     .init = FALSE)
[11:01:32.498]                 }
[11:01:32.498]             }
[11:01:32.498]         }
[11:01:32.498]     })
[11:01:32.498]     if (TRUE) {
[11:01:32.498]         base::sink(type = "output", split = FALSE)
[11:01:32.498]         if (TRUE) {
[11:01:32.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.498]         }
[11:01:32.498]         else {
[11:01:32.498]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.498]         }
[11:01:32.498]         base::close(...future.stdout)
[11:01:32.498]         ...future.stdout <- NULL
[11:01:32.498]     }
[11:01:32.498]     ...future.result$conditions <- ...future.conditions
[11:01:32.498]     ...future.result$finished <- base::Sys.time()
[11:01:32.498]     ...future.result
[11:01:32.498] }
[11:01:32.501] requestCore(): workers = 2
[11:01:32.504] MulticoreFuture started
[11:01:32.504] - Launch lazy future ... done
[11:01:32.504] run() for ‘MulticoreFuture’ ... done
[11:01:32.505] plan(): Setting new future strategy stack:
[11:01:32.505] getGlobalsAndPackages() ...
[11:01:32.505] Searching for globals...
[11:01:32.505] List of future strategies:
[11:01:32.505] 1. sequential:
[11:01:32.505]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.505]    - tweaked: FALSE
[11:01:32.505]    - call: NULL
[11:01:32.506] plan(): nbrOfWorkers() = 1
[11:01:32.506] - globals found: [1] ‘{’
[11:01:32.506] Searching for globals ... DONE
[11:01:32.507] Resolving globals: FALSE
[11:01:32.507] 
[11:01:32.507] 
[11:01:32.507] getGlobalsAndPackages() ... DONE
[11:01:32.508] run() for ‘Future’ ...
[11:01:32.508] plan(): Setting new future strategy stack:
[11:01:32.508] - state: ‘created’
[11:01:32.508] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.508] List of future strategies:
[11:01:32.508] 1. multicore:
[11:01:32.508]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.508]    - tweaked: FALSE
[11:01:32.508]    - call: plan(strategy)
[11:01:32.511] plan(): nbrOfWorkers() = 2
[11:01:32.511] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.511] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.511]   - Field: ‘label’
[11:01:32.512]   - Field: ‘local’
[11:01:32.512]   - Field: ‘owner’
[11:01:32.512]   - Field: ‘envir’
[11:01:32.512]   - Field: ‘workers’
[11:01:32.512]   - Field: ‘packages’
[11:01:32.512]   - Field: ‘gc’
[11:01:32.512]   - Field: ‘job’
[11:01:32.513]   - Field: ‘conditions’
[11:01:32.513]   - Field: ‘expr’
[11:01:32.513]   - Field: ‘uuid’
[11:01:32.513]   - Field: ‘seed’
[11:01:32.513]   - Field: ‘version’
[11:01:32.513]   - Field: ‘result’
[11:01:32.513]   - Field: ‘asynchronous’
[11:01:32.513]   - Field: ‘calls’
[11:01:32.513]   - Field: ‘globals’
[11:01:32.514]   - Field: ‘stdout’
[11:01:32.514]   - Field: ‘earlySignal’
[11:01:32.514]   - Field: ‘lazy’
[11:01:32.514]   - Field: ‘state’
[11:01:32.514] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.514] - Launch lazy future ...
[11:01:32.515] Packages needed by the future expression (n = 0): <none>
[11:01:32.515] Packages needed by future strategies (n = 0): <none>
[11:01:32.515] {
[11:01:32.515]     {
[11:01:32.515]         {
[11:01:32.515]             ...future.startTime <- base::Sys.time()
[11:01:32.515]             {
[11:01:32.515]                 {
[11:01:32.515]                   {
[11:01:32.515]                     {
[11:01:32.515]                       base::local({
[11:01:32.515]                         has_future <- base::requireNamespace("future", 
[11:01:32.515]                           quietly = TRUE)
[11:01:32.515]                         if (has_future) {
[11:01:32.515]                           ns <- base::getNamespace("future")
[11:01:32.515]                           version <- ns[[".package"]][["version"]]
[11:01:32.515]                           if (is.null(version)) 
[11:01:32.515]                             version <- utils::packageVersion("future")
[11:01:32.515]                         }
[11:01:32.515]                         else {
[11:01:32.515]                           version <- NULL
[11:01:32.515]                         }
[11:01:32.515]                         if (!has_future || version < "1.8.0") {
[11:01:32.515]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.515]                             "", base::R.version$version.string), 
[11:01:32.515]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.515]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.515]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.515]                               "release", "version")], collapse = " "), 
[11:01:32.515]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.515]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.515]                             info)
[11:01:32.515]                           info <- base::paste(info, collapse = "; ")
[11:01:32.515]                           if (!has_future) {
[11:01:32.515]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.515]                               info)
[11:01:32.515]                           }
[11:01:32.515]                           else {
[11:01:32.515]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.515]                               info, version)
[11:01:32.515]                           }
[11:01:32.515]                           base::stop(msg)
[11:01:32.515]                         }
[11:01:32.515]                       })
[11:01:32.515]                     }
[11:01:32.515]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.515]                     base::options(mc.cores = 1L)
[11:01:32.515]                   }
[11:01:32.515]                   ...future.strategy.old <- future::plan("list")
[11:01:32.515]                   options(future.plan = NULL)
[11:01:32.515]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.515]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.515]                 }
[11:01:32.515]                 ...future.workdir <- getwd()
[11:01:32.515]             }
[11:01:32.515]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.515]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.515]         }
[11:01:32.515]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.515]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.515]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.515]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.515]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.515]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.515]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.515]             base::names(...future.oldOptions))
[11:01:32.515]     }
[11:01:32.515]     if (FALSE) {
[11:01:32.515]     }
[11:01:32.515]     else {
[11:01:32.515]         if (TRUE) {
[11:01:32.515]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.515]                 open = "w")
[11:01:32.515]         }
[11:01:32.515]         else {
[11:01:32.515]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.515]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.515]         }
[11:01:32.515]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.515]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.515]             base::sink(type = "output", split = FALSE)
[11:01:32.515]             base::close(...future.stdout)
[11:01:32.515]         }, add = TRUE)
[11:01:32.515]     }
[11:01:32.515]     ...future.frame <- base::sys.nframe()
[11:01:32.515]     ...future.conditions <- base::list()
[11:01:32.515]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.515]     if (FALSE) {
[11:01:32.515]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.515]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.515]     }
[11:01:32.515]     ...future.result <- base::tryCatch({
[11:01:32.515]         base::withCallingHandlers({
[11:01:32.515]             ...future.value <- base::withVisible(base::local({
[11:01:32.515]                 withCallingHandlers({
[11:01:32.515]                   {
[11:01:32.515]                     4
[11:01:32.515]                   }
[11:01:32.515]                 }, immediateCondition = function(cond) {
[11:01:32.515]                   save_rds <- function (object, pathname, ...) 
[11:01:32.515]                   {
[11:01:32.515]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.515]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.515]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.515]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.515]                         fi_tmp[["mtime"]])
[11:01:32.515]                     }
[11:01:32.515]                     tryCatch({
[11:01:32.515]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.515]                     }, error = function(ex) {
[11:01:32.515]                       msg <- conditionMessage(ex)
[11:01:32.515]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.515]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.515]                         fi_tmp[["mtime"]], msg)
[11:01:32.515]                       ex$message <- msg
[11:01:32.515]                       stop(ex)
[11:01:32.515]                     })
[11:01:32.515]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.515]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.515]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.515]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.515]                       fi <- file.info(pathname)
[11:01:32.515]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.515]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.515]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.515]                         fi[["size"]], fi[["mtime"]])
[11:01:32.515]                       stop(msg)
[11:01:32.515]                     }
[11:01:32.515]                     invisible(pathname)
[11:01:32.515]                   }
[11:01:32.515]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.515]                     rootPath = tempdir()) 
[11:01:32.515]                   {
[11:01:32.515]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.515]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.515]                       tmpdir = path, fileext = ".rds")
[11:01:32.515]                     save_rds(obj, file)
[11:01:32.515]                   }
[11:01:32.515]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.515]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.515]                   {
[11:01:32.515]                     inherits <- base::inherits
[11:01:32.515]                     invokeRestart <- base::invokeRestart
[11:01:32.515]                     is.null <- base::is.null
[11:01:32.515]                     muffled <- FALSE
[11:01:32.515]                     if (inherits(cond, "message")) {
[11:01:32.515]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.515]                       if (muffled) 
[11:01:32.515]                         invokeRestart("muffleMessage")
[11:01:32.515]                     }
[11:01:32.515]                     else if (inherits(cond, "warning")) {
[11:01:32.515]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.515]                       if (muffled) 
[11:01:32.515]                         invokeRestart("muffleWarning")
[11:01:32.515]                     }
[11:01:32.515]                     else if (inherits(cond, "condition")) {
[11:01:32.515]                       if (!is.null(pattern)) {
[11:01:32.515]                         computeRestarts <- base::computeRestarts
[11:01:32.515]                         grepl <- base::grepl
[11:01:32.515]                         restarts <- computeRestarts(cond)
[11:01:32.515]                         for (restart in restarts) {
[11:01:32.515]                           name <- restart$name
[11:01:32.515]                           if (is.null(name)) 
[11:01:32.515]                             next
[11:01:32.515]                           if (!grepl(pattern, name)) 
[11:01:32.515]                             next
[11:01:32.515]                           invokeRestart(restart)
[11:01:32.515]                           muffled <- TRUE
[11:01:32.515]                           break
[11:01:32.515]                         }
[11:01:32.515]                       }
[11:01:32.515]                     }
[11:01:32.515]                     invisible(muffled)
[11:01:32.515]                   }
[11:01:32.515]                   muffleCondition(cond)
[11:01:32.515]                 })
[11:01:32.515]             }))
[11:01:32.515]             future::FutureResult(value = ...future.value$value, 
[11:01:32.515]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.515]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.515]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.515]                     ...future.globalenv.names))
[11:01:32.515]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.515]         }, condition = base::local({
[11:01:32.515]             c <- base::c
[11:01:32.515]             inherits <- base::inherits
[11:01:32.515]             invokeRestart <- base::invokeRestart
[11:01:32.515]             length <- base::length
[11:01:32.515]             list <- base::list
[11:01:32.515]             seq.int <- base::seq.int
[11:01:32.515]             signalCondition <- base::signalCondition
[11:01:32.515]             sys.calls <- base::sys.calls
[11:01:32.515]             `[[` <- base::`[[`
[11:01:32.515]             `+` <- base::`+`
[11:01:32.515]             `<<-` <- base::`<<-`
[11:01:32.515]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.515]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.515]                   3L)]
[11:01:32.515]             }
[11:01:32.515]             function(cond) {
[11:01:32.515]                 is_error <- inherits(cond, "error")
[11:01:32.515]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.515]                   NULL)
[11:01:32.515]                 if (is_error) {
[11:01:32.515]                   sessionInformation <- function() {
[11:01:32.515]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.515]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.515]                       search = base::search(), system = base::Sys.info())
[11:01:32.515]                   }
[11:01:32.515]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.515]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.515]                     cond$call), session = sessionInformation(), 
[11:01:32.515]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.515]                   signalCondition(cond)
[11:01:32.515]                 }
[11:01:32.515]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.515]                 "immediateCondition"))) {
[11:01:32.515]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.515]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.515]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.515]                   if (TRUE && !signal) {
[11:01:32.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.515]                     {
[11:01:32.515]                       inherits <- base::inherits
[11:01:32.515]                       invokeRestart <- base::invokeRestart
[11:01:32.515]                       is.null <- base::is.null
[11:01:32.515]                       muffled <- FALSE
[11:01:32.515]                       if (inherits(cond, "message")) {
[11:01:32.515]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.515]                         if (muffled) 
[11:01:32.515]                           invokeRestart("muffleMessage")
[11:01:32.515]                       }
[11:01:32.515]                       else if (inherits(cond, "warning")) {
[11:01:32.515]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.515]                         if (muffled) 
[11:01:32.515]                           invokeRestart("muffleWarning")
[11:01:32.515]                       }
[11:01:32.515]                       else if (inherits(cond, "condition")) {
[11:01:32.515]                         if (!is.null(pattern)) {
[11:01:32.515]                           computeRestarts <- base::computeRestarts
[11:01:32.515]                           grepl <- base::grepl
[11:01:32.515]                           restarts <- computeRestarts(cond)
[11:01:32.515]                           for (restart in restarts) {
[11:01:32.515]                             name <- restart$name
[11:01:32.515]                             if (is.null(name)) 
[11:01:32.515]                               next
[11:01:32.515]                             if (!grepl(pattern, name)) 
[11:01:32.515]                               next
[11:01:32.515]                             invokeRestart(restart)
[11:01:32.515]                             muffled <- TRUE
[11:01:32.515]                             break
[11:01:32.515]                           }
[11:01:32.515]                         }
[11:01:32.515]                       }
[11:01:32.515]                       invisible(muffled)
[11:01:32.515]                     }
[11:01:32.515]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.515]                   }
[11:01:32.515]                 }
[11:01:32.515]                 else {
[11:01:32.515]                   if (TRUE) {
[11:01:32.515]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.515]                     {
[11:01:32.515]                       inherits <- base::inherits
[11:01:32.515]                       invokeRestart <- base::invokeRestart
[11:01:32.515]                       is.null <- base::is.null
[11:01:32.515]                       muffled <- FALSE
[11:01:32.515]                       if (inherits(cond, "message")) {
[11:01:32.515]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.515]                         if (muffled) 
[11:01:32.515]                           invokeRestart("muffleMessage")
[11:01:32.515]                       }
[11:01:32.515]                       else if (inherits(cond, "warning")) {
[11:01:32.515]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.515]                         if (muffled) 
[11:01:32.515]                           invokeRestart("muffleWarning")
[11:01:32.515]                       }
[11:01:32.515]                       else if (inherits(cond, "condition")) {
[11:01:32.515]                         if (!is.null(pattern)) {
[11:01:32.515]                           computeRestarts <- base::computeRestarts
[11:01:32.515]                           grepl <- base::grepl
[11:01:32.515]                           restarts <- computeRestarts(cond)
[11:01:32.515]                           for (restart in restarts) {
[11:01:32.515]                             name <- restart$name
[11:01:32.515]                             if (is.null(name)) 
[11:01:32.515]                               next
[11:01:32.515]                             if (!grepl(pattern, name)) 
[11:01:32.515]                               next
[11:01:32.515]                             invokeRestart(restart)
[11:01:32.515]                             muffled <- TRUE
[11:01:32.515]                             break
[11:01:32.515]                           }
[11:01:32.515]                         }
[11:01:32.515]                       }
[11:01:32.515]                       invisible(muffled)
[11:01:32.515]                     }
[11:01:32.515]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.515]                   }
[11:01:32.515]                 }
[11:01:32.515]             }
[11:01:32.515]         }))
[11:01:32.515]     }, error = function(ex) {
[11:01:32.515]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.515]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.515]                 ...future.rng), started = ...future.startTime, 
[11:01:32.515]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.515]             version = "1.8"), class = "FutureResult")
[11:01:32.515]     }, finally = {
[11:01:32.515]         if (!identical(...future.workdir, getwd())) 
[11:01:32.515]             setwd(...future.workdir)
[11:01:32.515]         {
[11:01:32.515]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.515]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.515]             }
[11:01:32.515]             base::options(...future.oldOptions)
[11:01:32.515]             if (.Platform$OS.type == "windows") {
[11:01:32.515]                 old_names <- names(...future.oldEnvVars)
[11:01:32.515]                 envs <- base::Sys.getenv()
[11:01:32.515]                 names <- names(envs)
[11:01:32.515]                 common <- intersect(names, old_names)
[11:01:32.515]                 added <- setdiff(names, old_names)
[11:01:32.515]                 removed <- setdiff(old_names, names)
[11:01:32.515]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.515]                   envs[common]]
[11:01:32.515]                 NAMES <- toupper(changed)
[11:01:32.515]                 args <- list()
[11:01:32.515]                 for (kk in seq_along(NAMES)) {
[11:01:32.515]                   name <- changed[[kk]]
[11:01:32.515]                   NAME <- NAMES[[kk]]
[11:01:32.515]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.515]                     next
[11:01:32.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.515]                 }
[11:01:32.515]                 NAMES <- toupper(added)
[11:01:32.515]                 for (kk in seq_along(NAMES)) {
[11:01:32.515]                   name <- added[[kk]]
[11:01:32.515]                   NAME <- NAMES[[kk]]
[11:01:32.515]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.515]                     next
[11:01:32.515]                   args[[name]] <- ""
[11:01:32.515]                 }
[11:01:32.515]                 NAMES <- toupper(removed)
[11:01:32.515]                 for (kk in seq_along(NAMES)) {
[11:01:32.515]                   name <- removed[[kk]]
[11:01:32.515]                   NAME <- NAMES[[kk]]
[11:01:32.515]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.515]                     next
[11:01:32.515]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.515]                 }
[11:01:32.515]                 if (length(args) > 0) 
[11:01:32.515]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.515]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.515]             }
[11:01:32.515]             else {
[11:01:32.515]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.515]             }
[11:01:32.515]             {
[11:01:32.515]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.515]                   0L) {
[11:01:32.515]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.515]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.515]                   base::options(opts)
[11:01:32.515]                 }
[11:01:32.515]                 {
[11:01:32.515]                   {
[11:01:32.515]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.515]                     NULL
[11:01:32.515]                   }
[11:01:32.515]                   options(future.plan = NULL)
[11:01:32.515]                   if (is.na(NA_character_)) 
[11:01:32.515]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.515]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.515]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.515]                     .init = FALSE)
[11:01:32.515]                 }
[11:01:32.515]             }
[11:01:32.515]         }
[11:01:32.515]     })
[11:01:32.515]     if (TRUE) {
[11:01:32.515]         base::sink(type = "output", split = FALSE)
[11:01:32.515]         if (TRUE) {
[11:01:32.515]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.515]         }
[11:01:32.515]         else {
[11:01:32.515]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.515]         }
[11:01:32.515]         base::close(...future.stdout)
[11:01:32.515]         ...future.stdout <- NULL
[11:01:32.515]     }
[11:01:32.515]     ...future.result$conditions <- ...future.conditions
[11:01:32.515]     ...future.result$finished <- base::Sys.time()
[11:01:32.515]     ...future.result
[11:01:32.515] }
[11:01:32.519] requestCore(): workers = 2
[11:01:32.519] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:32.530] result() for MulticoreFuture ...
[11:01:32.531] result() for MulticoreFuture ...
[11:01:32.531] result() for MulticoreFuture ... done
[11:01:32.531] result() for MulticoreFuture ... done
[11:01:32.531] result() for MulticoreFuture ...
[11:01:32.531] result() for MulticoreFuture ... done
[11:01:32.534] MulticoreFuture started
[11:01:32.534] - Launch lazy future ... done
[11:01:32.535] run() for ‘MulticoreFuture’ ... done
[11:01:32.535] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a9c80dcb80> 
[11:01:32.535] List of future strategies:
[11:01:32.535] 1. sequential:
[11:01:32.535]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.535]    - tweaked: FALSE
[11:01:32.535]    - call: NULL
[11:01:32.537] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55a9c8c2fe40> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=[11:01:32.540] plan(): Setting new future strategy stack:
List of 3
  ..$ :[11:01:32.540] List of future strategies:
[11:01:32.540] 1. multicore:
[11:01:32.540]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.540]    - tweaked: FALSE
[11:01:32.540]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[11:01:32.545] plan(): nbrOfWorkers() = 2
 logi [1:2, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:32.559] resolve() on list environment ...
[11:01:32.559]  recursive: 0
[11:01:32.560]  length: 6
[11:01:32.560]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:32.560] signalConditionsASAP(numeric, pos=1) ...
[11:01:32.561] - nx: 6
[11:01:32.561] - relay: TRUE
[11:01:32.561] - stdout: TRUE
[11:01:32.561] - signal: TRUE
[11:01:32.561] - resignal: FALSE
[11:01:32.561] - force: TRUE
[11:01:32.561] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.561] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.561]  - until=2
[11:01:32.562]  - relaying element #2
[11:01:32.562] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.562] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.562] signalConditionsASAP(NULL, pos=1) ... done
[11:01:32.562]  length: 5 (resolved future 1)
[11:01:32.562] Future #2
[11:01:32.562] result() for MulticoreFuture ...
[11:01:32.563] result() for MulticoreFuture ... done
[11:01:32.563] result() for MulticoreFuture ...
[11:01:32.563] result() for MulticoreFuture ... done
[11:01:32.563] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:32.563] - nx: 6
[11:01:32.563] - relay: TRUE
[11:01:32.563] - stdout: TRUE
[11:01:32.563] - signal: TRUE
[11:01:32.563] - resignal: FALSE
[11:01:32.564] - force: TRUE
[11:01:32.564] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.564] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.564]  - until=2
[11:01:32.564]  - relaying element #2
[11:01:32.564] result() for MulticoreFuture ...
[11:01:32.564] result() for MulticoreFuture ... done
[11:01:32.564] result() for MulticoreFuture ...
[11:01:32.565] result() for MulticoreFuture ... done
[11:01:32.565] result() for MulticoreFuture ...
[11:01:32.565] result() for MulticoreFuture ... done
[11:01:32.565] result() for MulticoreFuture ...
[11:01:32.565] result() for MulticoreFuture ... done
[11:01:32.565] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.565] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.565] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:32.566]  length: 4 (resolved future 2)
[11:01:32.566] Future #3
[11:01:32.566] result() for MulticoreFuture ...
[11:01:32.567] result() for MulticoreFuture ...
[11:01:32.567] result() for MulticoreFuture ... done
[11:01:32.567] result() for MulticoreFuture ... done
[11:01:32.567] result() for MulticoreFuture ...
[11:01:32.567] result() for MulticoreFuture ... done
[11:01:32.567] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:32.568] - nx: 6
[11:01:32.568] - relay: TRUE
[11:01:32.568] - stdout: TRUE
[11:01:32.568] - signal: TRUE
[11:01:32.568] - resignal: FALSE
[11:01:32.568] - force: TRUE
[11:01:32.568] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.568] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.568]  - until=3
[11:01:32.569]  - relaying element #3
[11:01:32.569] result() for MulticoreFuture ...
[11:01:32.569] result() for MulticoreFuture ... done
[11:01:32.569] result() for MulticoreFuture ...
[11:01:32.569] result() for MulticoreFuture ... done
[11:01:32.569] result() for MulticoreFuture ...
[11:01:32.569] result() for MulticoreFuture ... done
[11:01:32.569] result() for MulticoreFuture ...
[11:01:32.570] result() for MulticoreFuture ... done
[11:01:32.570] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.570] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.570] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:32.570]  length: 3 (resolved future 3)
[11:01:32.571] Future #4
[11:01:32.571] result() for MulticoreFuture ...
[11:01:32.571] result() for MulticoreFuture ...
[11:01:32.572] result() for MulticoreFuture ... done
[11:01:32.572] result() for MulticoreFuture ... done
[11:01:32.572] result() for MulticoreFuture ...
[11:01:32.572] result() for MulticoreFuture ... done
[11:01:32.572] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:32.572] - nx: 6
[11:01:32.573] - relay: TRUE
[11:01:32.573] - stdout: TRUE
[11:01:32.573] - signal: TRUE
[11:01:32.573] - resignal: FALSE
[11:01:32.573] - force: TRUE
[11:01:32.573] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.573] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.574]  - until=4
[11:01:32.574]  - relaying element #4
[11:01:32.574] result() for MulticoreFuture ...
[11:01:32.574] result() for MulticoreFuture ... done
[11:01:32.574] result() for MulticoreFuture ...
[11:01:32.574] result() for MulticoreFuture ... done
[11:01:32.574] result() for MulticoreFuture ...
[11:01:32.575] result() for MulticoreFuture ... done
[11:01:32.575] result() for MulticoreFuture ...
[11:01:32.575] result() for MulticoreFuture ... done
[11:01:32.575] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.575] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.575] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:32.576]  length: 2 (resolved future 4)
[11:01:32.576] signalConditionsASAP(NULL, pos=5) ...
[11:01:32.576] - nx: 6
[11:01:32.576] - relay: TRUE
[11:01:32.576] - stdout: TRUE
[11:01:32.576] - signal: TRUE
[11:01:32.576] - resignal: FALSE
[11:01:32.577] - force: TRUE
[11:01:32.577] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.577] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.577]  - until=6
[11:01:32.577]  - relaying element #6
[11:01:32.577] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.577] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.577] signalConditionsASAP(NULL, pos=5) ... done
[11:01:32.578]  length: 1 (resolved future 5)
[11:01:32.578] signalConditionsASAP(numeric, pos=6) ...
[11:01:32.578] - nx: 6
[11:01:32.578] - relay: TRUE
[11:01:32.578] - stdout: TRUE
[11:01:32.578] - signal: TRUE
[11:01:32.578] - resignal: FALSE
[11:01:32.578] - force: TRUE
[11:01:32.578] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.579] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.579]  - until=6
[11:01:32.579] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.579] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.579] signalConditionsASAP(numeric, pos=6) ... done
[11:01:32.579]  length: 0 (resolved future 6)
[11:01:32.579] Relaying remaining futures
[11:01:32.579] signalConditionsASAP(NULL, pos=0) ...
[11:01:32.579] - nx: 6
[11:01:32.579] - relay: TRUE
[11:01:32.579] - stdout: TRUE
[11:01:32.580] - signal: TRUE
[11:01:32.580] - resignal: FALSE
[11:01:32.580] - force: TRUE
[11:01:32.580] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.580] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:32.580] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.580] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.580] signalConditionsASAP(NULL, pos=0) ... done
[11:01:32.580] resolve() on list environment ... DONE
[11:01:32.581] result() for MulticoreFuture ...
[11:01:32.581] result() for MulticoreFuture ... done
[11:01:32.581] result() for MulticoreFuture ...
[11:01:32.581] result() for MulticoreFuture ... done
[11:01:32.581] result() for MulticoreFuture ...
[11:01:32.581] result() for MulticoreFuture ... done
[11:01:32.581] result() for MulticoreFuture ...
[11:01:32.581] result() for MulticoreFuture ... done
[11:01:32.582] result() for MulticoreFuture ...
[11:01:32.582] result() for MulticoreFuture ... done
[11:01:32.582] result() for MulticoreFuture ...
[11:01:32.582] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c71465d0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[11:01:32.584] getGlobalsAndPackages() ...
[11:01:32.585] Searching for globals...
[11:01:32.585] 
[11:01:32.585] Searching for globals ... DONE
[11:01:32.585] - globals: [0] <none>
[11:01:32.585] getGlobalsAndPackages() ... DONE
[11:01:32.586] run() for ‘Future’ ...
[11:01:32.586] - state: ‘created’
[11:01:32.586] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.588] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.588] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.588]   - Field: ‘label’
[11:01:32.588]   - Field: ‘local’
[11:01:32.589]   - Field: ‘owner’
[11:01:32.589]   - Field: ‘envir’
[11:01:32.589]   - Field: ‘workers’
[11:01:32.589]   - Field: ‘packages’
[11:01:32.589]   - Field: ‘gc’
[11:01:32.589]   - Field: ‘job’
[11:01:32.589]   - Field: ‘conditions’
[11:01:32.589]   - Field: ‘expr’
[11:01:32.589]   - Field: ‘uuid’
[11:01:32.589]   - Field: ‘seed’
[11:01:32.590]   - Field: ‘version’
[11:01:32.590]   - Field: ‘result’
[11:01:32.590]   - Field: ‘asynchronous’
[11:01:32.590]   - Field: ‘calls’
[11:01:32.590]   - Field: ‘globals’
[11:01:32.590]   - Field: ‘stdout’
[11:01:32.590]   - Field: ‘earlySignal’
[11:01:32.590]   - Field: ‘lazy’
[11:01:32.590]   - Field: ‘state’
[11:01:32.591] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.591] - Launch lazy future ...
[11:01:32.591] Packages needed by the future expression (n = 0): <none>
[11:01:32.591] Packages needed by future strategies (n = 0): <none>
[11:01:32.592] {
[11:01:32.592]     {
[11:01:32.592]         {
[11:01:32.592]             ...future.startTime <- base::Sys.time()
[11:01:32.592]             {
[11:01:32.592]                 {
[11:01:32.592]                   {
[11:01:32.592]                     {
[11:01:32.592]                       base::local({
[11:01:32.592]                         has_future <- base::requireNamespace("future", 
[11:01:32.592]                           quietly = TRUE)
[11:01:32.592]                         if (has_future) {
[11:01:32.592]                           ns <- base::getNamespace("future")
[11:01:32.592]                           version <- ns[[".package"]][["version"]]
[11:01:32.592]                           if (is.null(version)) 
[11:01:32.592]                             version <- utils::packageVersion("future")
[11:01:32.592]                         }
[11:01:32.592]                         else {
[11:01:32.592]                           version <- NULL
[11:01:32.592]                         }
[11:01:32.592]                         if (!has_future || version < "1.8.0") {
[11:01:32.592]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.592]                             "", base::R.version$version.string), 
[11:01:32.592]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.592]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.592]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.592]                               "release", "version")], collapse = " "), 
[11:01:32.592]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.592]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.592]                             info)
[11:01:32.592]                           info <- base::paste(info, collapse = "; ")
[11:01:32.592]                           if (!has_future) {
[11:01:32.592]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.592]                               info)
[11:01:32.592]                           }
[11:01:32.592]                           else {
[11:01:32.592]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.592]                               info, version)
[11:01:32.592]                           }
[11:01:32.592]                           base::stop(msg)
[11:01:32.592]                         }
[11:01:32.592]                       })
[11:01:32.592]                     }
[11:01:32.592]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.592]                     base::options(mc.cores = 1L)
[11:01:32.592]                   }
[11:01:32.592]                   ...future.strategy.old <- future::plan("list")
[11:01:32.592]                   options(future.plan = NULL)
[11:01:32.592]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.592]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.592]                 }
[11:01:32.592]                 ...future.workdir <- getwd()
[11:01:32.592]             }
[11:01:32.592]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.592]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.592]         }
[11:01:32.592]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.592]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.592]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.592]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.592]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.592]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.592]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.592]             base::names(...future.oldOptions))
[11:01:32.592]     }
[11:01:32.592]     if (FALSE) {
[11:01:32.592]     }
[11:01:32.592]     else {
[11:01:32.592]         if (TRUE) {
[11:01:32.592]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.592]                 open = "w")
[11:01:32.592]         }
[11:01:32.592]         else {
[11:01:32.592]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.592]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.592]         }
[11:01:32.592]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.592]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.592]             base::sink(type = "output", split = FALSE)
[11:01:32.592]             base::close(...future.stdout)
[11:01:32.592]         }, add = TRUE)
[11:01:32.592]     }
[11:01:32.592]     ...future.frame <- base::sys.nframe()
[11:01:32.592]     ...future.conditions <- base::list()
[11:01:32.592]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.592]     if (FALSE) {
[11:01:32.592]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.592]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.592]     }
[11:01:32.592]     ...future.result <- base::tryCatch({
[11:01:32.592]         base::withCallingHandlers({
[11:01:32.592]             ...future.value <- base::withVisible(base::local({
[11:01:32.592]                 withCallingHandlers({
[11:01:32.592]                   2
[11:01:32.592]                 }, immediateCondition = function(cond) {
[11:01:32.592]                   save_rds <- function (object, pathname, ...) 
[11:01:32.592]                   {
[11:01:32.592]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.592]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.592]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.592]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.592]                         fi_tmp[["mtime"]])
[11:01:32.592]                     }
[11:01:32.592]                     tryCatch({
[11:01:32.592]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.592]                     }, error = function(ex) {
[11:01:32.592]                       msg <- conditionMessage(ex)
[11:01:32.592]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.592]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.592]                         fi_tmp[["mtime"]], msg)
[11:01:32.592]                       ex$message <- msg
[11:01:32.592]                       stop(ex)
[11:01:32.592]                     })
[11:01:32.592]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.592]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.592]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.592]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.592]                       fi <- file.info(pathname)
[11:01:32.592]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.592]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.592]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.592]                         fi[["size"]], fi[["mtime"]])
[11:01:32.592]                       stop(msg)
[11:01:32.592]                     }
[11:01:32.592]                     invisible(pathname)
[11:01:32.592]                   }
[11:01:32.592]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.592]                     rootPath = tempdir()) 
[11:01:32.592]                   {
[11:01:32.592]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.592]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.592]                       tmpdir = path, fileext = ".rds")
[11:01:32.592]                     save_rds(obj, file)
[11:01:32.592]                   }
[11:01:32.592]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.592]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.592]                   {
[11:01:32.592]                     inherits <- base::inherits
[11:01:32.592]                     invokeRestart <- base::invokeRestart
[11:01:32.592]                     is.null <- base::is.null
[11:01:32.592]                     muffled <- FALSE
[11:01:32.592]                     if (inherits(cond, "message")) {
[11:01:32.592]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.592]                       if (muffled) 
[11:01:32.592]                         invokeRestart("muffleMessage")
[11:01:32.592]                     }
[11:01:32.592]                     else if (inherits(cond, "warning")) {
[11:01:32.592]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.592]                       if (muffled) 
[11:01:32.592]                         invokeRestart("muffleWarning")
[11:01:32.592]                     }
[11:01:32.592]                     else if (inherits(cond, "condition")) {
[11:01:32.592]                       if (!is.null(pattern)) {
[11:01:32.592]                         computeRestarts <- base::computeRestarts
[11:01:32.592]                         grepl <- base::grepl
[11:01:32.592]                         restarts <- computeRestarts(cond)
[11:01:32.592]                         for (restart in restarts) {
[11:01:32.592]                           name <- restart$name
[11:01:32.592]                           if (is.null(name)) 
[11:01:32.592]                             next
[11:01:32.592]                           if (!grepl(pattern, name)) 
[11:01:32.592]                             next
[11:01:32.592]                           invokeRestart(restart)
[11:01:32.592]                           muffled <- TRUE
[11:01:32.592]                           break
[11:01:32.592]                         }
[11:01:32.592]                       }
[11:01:32.592]                     }
[11:01:32.592]                     invisible(muffled)
[11:01:32.592]                   }
[11:01:32.592]                   muffleCondition(cond)
[11:01:32.592]                 })
[11:01:32.592]             }))
[11:01:32.592]             future::FutureResult(value = ...future.value$value, 
[11:01:32.592]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.592]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.592]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.592]                     ...future.globalenv.names))
[11:01:32.592]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.592]         }, condition = base::local({
[11:01:32.592]             c <- base::c
[11:01:32.592]             inherits <- base::inherits
[11:01:32.592]             invokeRestart <- base::invokeRestart
[11:01:32.592]             length <- base::length
[11:01:32.592]             list <- base::list
[11:01:32.592]             seq.int <- base::seq.int
[11:01:32.592]             signalCondition <- base::signalCondition
[11:01:32.592]             sys.calls <- base::sys.calls
[11:01:32.592]             `[[` <- base::`[[`
[11:01:32.592]             `+` <- base::`+`
[11:01:32.592]             `<<-` <- base::`<<-`
[11:01:32.592]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.592]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.592]                   3L)]
[11:01:32.592]             }
[11:01:32.592]             function(cond) {
[11:01:32.592]                 is_error <- inherits(cond, "error")
[11:01:32.592]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.592]                   NULL)
[11:01:32.592]                 if (is_error) {
[11:01:32.592]                   sessionInformation <- function() {
[11:01:32.592]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.592]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.592]                       search = base::search(), system = base::Sys.info())
[11:01:32.592]                   }
[11:01:32.592]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.592]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.592]                     cond$call), session = sessionInformation(), 
[11:01:32.592]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.592]                   signalCondition(cond)
[11:01:32.592]                 }
[11:01:32.592]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.592]                 "immediateCondition"))) {
[11:01:32.592]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.592]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.592]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.592]                   if (TRUE && !signal) {
[11:01:32.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.592]                     {
[11:01:32.592]                       inherits <- base::inherits
[11:01:32.592]                       invokeRestart <- base::invokeRestart
[11:01:32.592]                       is.null <- base::is.null
[11:01:32.592]                       muffled <- FALSE
[11:01:32.592]                       if (inherits(cond, "message")) {
[11:01:32.592]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.592]                         if (muffled) 
[11:01:32.592]                           invokeRestart("muffleMessage")
[11:01:32.592]                       }
[11:01:32.592]                       else if (inherits(cond, "warning")) {
[11:01:32.592]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.592]                         if (muffled) 
[11:01:32.592]                           invokeRestart("muffleWarning")
[11:01:32.592]                       }
[11:01:32.592]                       else if (inherits(cond, "condition")) {
[11:01:32.592]                         if (!is.null(pattern)) {
[11:01:32.592]                           computeRestarts <- base::computeRestarts
[11:01:32.592]                           grepl <- base::grepl
[11:01:32.592]                           restarts <- computeRestarts(cond)
[11:01:32.592]                           for (restart in restarts) {
[11:01:32.592]                             name <- restart$name
[11:01:32.592]                             if (is.null(name)) 
[11:01:32.592]                               next
[11:01:32.592]                             if (!grepl(pattern, name)) 
[11:01:32.592]                               next
[11:01:32.592]                             invokeRestart(restart)
[11:01:32.592]                             muffled <- TRUE
[11:01:32.592]                             break
[11:01:32.592]                           }
[11:01:32.592]                         }
[11:01:32.592]                       }
[11:01:32.592]                       invisible(muffled)
[11:01:32.592]                     }
[11:01:32.592]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.592]                   }
[11:01:32.592]                 }
[11:01:32.592]                 else {
[11:01:32.592]                   if (TRUE) {
[11:01:32.592]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.592]                     {
[11:01:32.592]                       inherits <- base::inherits
[11:01:32.592]                       invokeRestart <- base::invokeRestart
[11:01:32.592]                       is.null <- base::is.null
[11:01:32.592]                       muffled <- FALSE
[11:01:32.592]                       if (inherits(cond, "message")) {
[11:01:32.592]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.592]                         if (muffled) 
[11:01:32.592]                           invokeRestart("muffleMessage")
[11:01:32.592]                       }
[11:01:32.592]                       else if (inherits(cond, "warning")) {
[11:01:32.592]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.592]                         if (muffled) 
[11:01:32.592]                           invokeRestart("muffleWarning")
[11:01:32.592]                       }
[11:01:32.592]                       else if (inherits(cond, "condition")) {
[11:01:32.592]                         if (!is.null(pattern)) {
[11:01:32.592]                           computeRestarts <- base::computeRestarts
[11:01:32.592]                           grepl <- base::grepl
[11:01:32.592]                           restarts <- computeRestarts(cond)
[11:01:32.592]                           for (restart in restarts) {
[11:01:32.592]                             name <- restart$name
[11:01:32.592]                             if (is.null(name)) 
[11:01:32.592]                               next
[11:01:32.592]                             if (!grepl(pattern, name)) 
[11:01:32.592]                               next
[11:01:32.592]                             invokeRestart(restart)
[11:01:32.592]                             muffled <- TRUE
[11:01:32.592]                             break
[11:01:32.592]                           }
[11:01:32.592]                         }
[11:01:32.592]                       }
[11:01:32.592]                       invisible(muffled)
[11:01:32.592]                     }
[11:01:32.592]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.592]                   }
[11:01:32.592]                 }
[11:01:32.592]             }
[11:01:32.592]         }))
[11:01:32.592]     }, error = function(ex) {
[11:01:32.592]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.592]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.592]                 ...future.rng), started = ...future.startTime, 
[11:01:32.592]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.592]             version = "1.8"), class = "FutureResult")
[11:01:32.592]     }, finally = {
[11:01:32.592]         if (!identical(...future.workdir, getwd())) 
[11:01:32.592]             setwd(...future.workdir)
[11:01:32.592]         {
[11:01:32.592]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.592]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.592]             }
[11:01:32.592]             base::options(...future.oldOptions)
[11:01:32.592]             if (.Platform$OS.type == "windows") {
[11:01:32.592]                 old_names <- names(...future.oldEnvVars)
[11:01:32.592]                 envs <- base::Sys.getenv()
[11:01:32.592]                 names <- names(envs)
[11:01:32.592]                 common <- intersect(names, old_names)
[11:01:32.592]                 added <- setdiff(names, old_names)
[11:01:32.592]                 removed <- setdiff(old_names, names)
[11:01:32.592]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.592]                   envs[common]]
[11:01:32.592]                 NAMES <- toupper(changed)
[11:01:32.592]                 args <- list()
[11:01:32.592]                 for (kk in seq_along(NAMES)) {
[11:01:32.592]                   name <- changed[[kk]]
[11:01:32.592]                   NAME <- NAMES[[kk]]
[11:01:32.592]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.592]                     next
[11:01:32.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.592]                 }
[11:01:32.592]                 NAMES <- toupper(added)
[11:01:32.592]                 for (kk in seq_along(NAMES)) {
[11:01:32.592]                   name <- added[[kk]]
[11:01:32.592]                   NAME <- NAMES[[kk]]
[11:01:32.592]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.592]                     next
[11:01:32.592]                   args[[name]] <- ""
[11:01:32.592]                 }
[11:01:32.592]                 NAMES <- toupper(removed)
[11:01:32.592]                 for (kk in seq_along(NAMES)) {
[11:01:32.592]                   name <- removed[[kk]]
[11:01:32.592]                   NAME <- NAMES[[kk]]
[11:01:32.592]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.592]                     next
[11:01:32.592]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.592]                 }
[11:01:32.592]                 if (length(args) > 0) 
[11:01:32.592]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.592]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.592]             }
[11:01:32.592]             else {
[11:01:32.592]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.592]             }
[11:01:32.592]             {
[11:01:32.592]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.592]                   0L) {
[11:01:32.592]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.592]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.592]                   base::options(opts)
[11:01:32.592]                 }
[11:01:32.592]                 {
[11:01:32.592]                   {
[11:01:32.592]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.592]                     NULL
[11:01:32.592]                   }
[11:01:32.592]                   options(future.plan = NULL)
[11:01:32.592]                   if (is.na(NA_character_)) 
[11:01:32.592]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.592]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.592]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.592]                     .init = FALSE)
[11:01:32.592]                 }
[11:01:32.592]             }
[11:01:32.592]         }
[11:01:32.592]     })
[11:01:32.592]     if (TRUE) {
[11:01:32.592]         base::sink(type = "output", split = FALSE)
[11:01:32.592]         if (TRUE) {
[11:01:32.592]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.592]         }
[11:01:32.592]         else {
[11:01:32.592]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.592]         }
[11:01:32.592]         base::close(...future.stdout)
[11:01:32.592]         ...future.stdout <- NULL
[11:01:32.592]     }
[11:01:32.592]     ...future.result$conditions <- ...future.conditions
[11:01:32.592]     ...future.result$finished <- base::Sys.time()
[11:01:32.592]     ...future.result
[11:01:32.592] }
[11:01:32.594] requestCore(): workers = 2
[11:01:32.596] MulticoreFuture started
[11:01:32.597] - Launch lazy future ... done
[11:01:32.597] run() for ‘MulticoreFuture’ ... done
[11:01:32.597] getGlobalsAndPackages() ...
[11:01:32.597] plan(): Setting new future strategy stack:
[11:01:32.597] Searching for globals...
[11:01:32.598] 
[11:01:32.597] List of future strategies:
[11:01:32.597] 1. sequential:
[11:01:32.597]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.597]    - tweaked: FALSE
[11:01:32.597]    - call: NULL
[11:01:32.598] Searching for globals ... DONE
[11:01:32.598] plan(): nbrOfWorkers() = 1
[11:01:32.598] - globals: [0] <none>
[11:01:32.599] getGlobalsAndPackages() ... DONE
[11:01:32.599] run() for ‘Future’ ...
[11:01:32.599] - state: ‘created’
[11:01:32.599] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.600] plan(): Setting new future strategy stack:
[11:01:32.601] List of future strategies:
[11:01:32.601] 1. multicore:
[11:01:32.601]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.601]    - tweaked: FALSE
[11:01:32.601]    - call: plan(strategy)
[11:01:32.603] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.603] plan(): nbrOfWorkers() = 2
[11:01:32.603] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.603]   - Field: ‘label’
[11:01:32.603]   - Field: ‘local’
[11:01:32.603]   - Field: ‘owner’
[11:01:32.603]   - Field: ‘envir’
[11:01:32.604]   - Field: ‘workers’
[11:01:32.604]   - Field: ‘packages’
[11:01:32.604]   - Field: ‘gc’
[11:01:32.604]   - Field: ‘job’
[11:01:32.604]   - Field: ‘conditions’
[11:01:32.604]   - Field: ‘expr’
[11:01:32.604]   - Field: ‘uuid’
[11:01:32.604]   - Field: ‘seed’
[11:01:32.605]   - Field: ‘version’
[11:01:32.605]   - Field: ‘result’
[11:01:32.605]   - Field: ‘asynchronous’
[11:01:32.605]   - Field: ‘calls’
[11:01:32.605]   - Field: ‘globals’
[11:01:32.605]   - Field: ‘stdout’
[11:01:32.605]   - Field: ‘earlySignal’
[11:01:32.605]   - Field: ‘lazy’
[11:01:32.606]   - Field: ‘state’
[11:01:32.606] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.606] - Launch lazy future ...
[11:01:32.606] Packages needed by the future expression (n = 0): <none>
[11:01:32.606] Packages needed by future strategies (n = 0): <none>
[11:01:32.607] {
[11:01:32.607]     {
[11:01:32.607]         {
[11:01:32.607]             ...future.startTime <- base::Sys.time()
[11:01:32.607]             {
[11:01:32.607]                 {
[11:01:32.607]                   {
[11:01:32.607]                     {
[11:01:32.607]                       base::local({
[11:01:32.607]                         has_future <- base::requireNamespace("future", 
[11:01:32.607]                           quietly = TRUE)
[11:01:32.607]                         if (has_future) {
[11:01:32.607]                           ns <- base::getNamespace("future")
[11:01:32.607]                           version <- ns[[".package"]][["version"]]
[11:01:32.607]                           if (is.null(version)) 
[11:01:32.607]                             version <- utils::packageVersion("future")
[11:01:32.607]                         }
[11:01:32.607]                         else {
[11:01:32.607]                           version <- NULL
[11:01:32.607]                         }
[11:01:32.607]                         if (!has_future || version < "1.8.0") {
[11:01:32.607]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.607]                             "", base::R.version$version.string), 
[11:01:32.607]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.607]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.607]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.607]                               "release", "version")], collapse = " "), 
[11:01:32.607]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.607]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.607]                             info)
[11:01:32.607]                           info <- base::paste(info, collapse = "; ")
[11:01:32.607]                           if (!has_future) {
[11:01:32.607]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.607]                               info)
[11:01:32.607]                           }
[11:01:32.607]                           else {
[11:01:32.607]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.607]                               info, version)
[11:01:32.607]                           }
[11:01:32.607]                           base::stop(msg)
[11:01:32.607]                         }
[11:01:32.607]                       })
[11:01:32.607]                     }
[11:01:32.607]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.607]                     base::options(mc.cores = 1L)
[11:01:32.607]                   }
[11:01:32.607]                   ...future.strategy.old <- future::plan("list")
[11:01:32.607]                   options(future.plan = NULL)
[11:01:32.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.607]                 }
[11:01:32.607]                 ...future.workdir <- getwd()
[11:01:32.607]             }
[11:01:32.607]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.607]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.607]         }
[11:01:32.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.607]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.607]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.607]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.607]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.607]             base::names(...future.oldOptions))
[11:01:32.607]     }
[11:01:32.607]     if (FALSE) {
[11:01:32.607]     }
[11:01:32.607]     else {
[11:01:32.607]         if (TRUE) {
[11:01:32.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.607]                 open = "w")
[11:01:32.607]         }
[11:01:32.607]         else {
[11:01:32.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.607]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.607]         }
[11:01:32.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.607]             base::sink(type = "output", split = FALSE)
[11:01:32.607]             base::close(...future.stdout)
[11:01:32.607]         }, add = TRUE)
[11:01:32.607]     }
[11:01:32.607]     ...future.frame <- base::sys.nframe()
[11:01:32.607]     ...future.conditions <- base::list()
[11:01:32.607]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.607]     if (FALSE) {
[11:01:32.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.607]     }
[11:01:32.607]     ...future.result <- base::tryCatch({
[11:01:32.607]         base::withCallingHandlers({
[11:01:32.607]             ...future.value <- base::withVisible(base::local({
[11:01:32.607]                 withCallingHandlers({
[11:01:32.607]                   NULL
[11:01:32.607]                 }, immediateCondition = function(cond) {
[11:01:32.607]                   save_rds <- function (object, pathname, ...) 
[11:01:32.607]                   {
[11:01:32.607]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.607]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.607]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.607]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.607]                         fi_tmp[["mtime"]])
[11:01:32.607]                     }
[11:01:32.607]                     tryCatch({
[11:01:32.607]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.607]                     }, error = function(ex) {
[11:01:32.607]                       msg <- conditionMessage(ex)
[11:01:32.607]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.607]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.607]                         fi_tmp[["mtime"]], msg)
[11:01:32.607]                       ex$message <- msg
[11:01:32.607]                       stop(ex)
[11:01:32.607]                     })
[11:01:32.607]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.607]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.607]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.607]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.607]                       fi <- file.info(pathname)
[11:01:32.607]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.607]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.607]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.607]                         fi[["size"]], fi[["mtime"]])
[11:01:32.607]                       stop(msg)
[11:01:32.607]                     }
[11:01:32.607]                     invisible(pathname)
[11:01:32.607]                   }
[11:01:32.607]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.607]                     rootPath = tempdir()) 
[11:01:32.607]                   {
[11:01:32.607]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.607]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.607]                       tmpdir = path, fileext = ".rds")
[11:01:32.607]                     save_rds(obj, file)
[11:01:32.607]                   }
[11:01:32.607]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.607]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.607]                   {
[11:01:32.607]                     inherits <- base::inherits
[11:01:32.607]                     invokeRestart <- base::invokeRestart
[11:01:32.607]                     is.null <- base::is.null
[11:01:32.607]                     muffled <- FALSE
[11:01:32.607]                     if (inherits(cond, "message")) {
[11:01:32.607]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.607]                       if (muffled) 
[11:01:32.607]                         invokeRestart("muffleMessage")
[11:01:32.607]                     }
[11:01:32.607]                     else if (inherits(cond, "warning")) {
[11:01:32.607]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.607]                       if (muffled) 
[11:01:32.607]                         invokeRestart("muffleWarning")
[11:01:32.607]                     }
[11:01:32.607]                     else if (inherits(cond, "condition")) {
[11:01:32.607]                       if (!is.null(pattern)) {
[11:01:32.607]                         computeRestarts <- base::computeRestarts
[11:01:32.607]                         grepl <- base::grepl
[11:01:32.607]                         restarts <- computeRestarts(cond)
[11:01:32.607]                         for (restart in restarts) {
[11:01:32.607]                           name <- restart$name
[11:01:32.607]                           if (is.null(name)) 
[11:01:32.607]                             next
[11:01:32.607]                           if (!grepl(pattern, name)) 
[11:01:32.607]                             next
[11:01:32.607]                           invokeRestart(restart)
[11:01:32.607]                           muffled <- TRUE
[11:01:32.607]                           break
[11:01:32.607]                         }
[11:01:32.607]                       }
[11:01:32.607]                     }
[11:01:32.607]                     invisible(muffled)
[11:01:32.607]                   }
[11:01:32.607]                   muffleCondition(cond)
[11:01:32.607]                 })
[11:01:32.607]             }))
[11:01:32.607]             future::FutureResult(value = ...future.value$value, 
[11:01:32.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.607]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.607]                     ...future.globalenv.names))
[11:01:32.607]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.607]         }, condition = base::local({
[11:01:32.607]             c <- base::c
[11:01:32.607]             inherits <- base::inherits
[11:01:32.607]             invokeRestart <- base::invokeRestart
[11:01:32.607]             length <- base::length
[11:01:32.607]             list <- base::list
[11:01:32.607]             seq.int <- base::seq.int
[11:01:32.607]             signalCondition <- base::signalCondition
[11:01:32.607]             sys.calls <- base::sys.calls
[11:01:32.607]             `[[` <- base::`[[`
[11:01:32.607]             `+` <- base::`+`
[11:01:32.607]             `<<-` <- base::`<<-`
[11:01:32.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.607]                   3L)]
[11:01:32.607]             }
[11:01:32.607]             function(cond) {
[11:01:32.607]                 is_error <- inherits(cond, "error")
[11:01:32.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.607]                   NULL)
[11:01:32.607]                 if (is_error) {
[11:01:32.607]                   sessionInformation <- function() {
[11:01:32.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.607]                       search = base::search(), system = base::Sys.info())
[11:01:32.607]                   }
[11:01:32.607]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.607]                     cond$call), session = sessionInformation(), 
[11:01:32.607]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.607]                   signalCondition(cond)
[11:01:32.607]                 }
[11:01:32.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.607]                 "immediateCondition"))) {
[11:01:32.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.607]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.607]                   if (TRUE && !signal) {
[11:01:32.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.607]                     {
[11:01:32.607]                       inherits <- base::inherits
[11:01:32.607]                       invokeRestart <- base::invokeRestart
[11:01:32.607]                       is.null <- base::is.null
[11:01:32.607]                       muffled <- FALSE
[11:01:32.607]                       if (inherits(cond, "message")) {
[11:01:32.607]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.607]                         if (muffled) 
[11:01:32.607]                           invokeRestart("muffleMessage")
[11:01:32.607]                       }
[11:01:32.607]                       else if (inherits(cond, "warning")) {
[11:01:32.607]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.607]                         if (muffled) 
[11:01:32.607]                           invokeRestart("muffleWarning")
[11:01:32.607]                       }
[11:01:32.607]                       else if (inherits(cond, "condition")) {
[11:01:32.607]                         if (!is.null(pattern)) {
[11:01:32.607]                           computeRestarts <- base::computeRestarts
[11:01:32.607]                           grepl <- base::grepl
[11:01:32.607]                           restarts <- computeRestarts(cond)
[11:01:32.607]                           for (restart in restarts) {
[11:01:32.607]                             name <- restart$name
[11:01:32.607]                             if (is.null(name)) 
[11:01:32.607]                               next
[11:01:32.607]                             if (!grepl(pattern, name)) 
[11:01:32.607]                               next
[11:01:32.607]                             invokeRestart(restart)
[11:01:32.607]                             muffled <- TRUE
[11:01:32.607]                             break
[11:01:32.607]                           }
[11:01:32.607]                         }
[11:01:32.607]                       }
[11:01:32.607]                       invisible(muffled)
[11:01:32.607]                     }
[11:01:32.607]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.607]                   }
[11:01:32.607]                 }
[11:01:32.607]                 else {
[11:01:32.607]                   if (TRUE) {
[11:01:32.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.607]                     {
[11:01:32.607]                       inherits <- base::inherits
[11:01:32.607]                       invokeRestart <- base::invokeRestart
[11:01:32.607]                       is.null <- base::is.null
[11:01:32.607]                       muffled <- FALSE
[11:01:32.607]                       if (inherits(cond, "message")) {
[11:01:32.607]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.607]                         if (muffled) 
[11:01:32.607]                           invokeRestart("muffleMessage")
[11:01:32.607]                       }
[11:01:32.607]                       else if (inherits(cond, "warning")) {
[11:01:32.607]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.607]                         if (muffled) 
[11:01:32.607]                           invokeRestart("muffleWarning")
[11:01:32.607]                       }
[11:01:32.607]                       else if (inherits(cond, "condition")) {
[11:01:32.607]                         if (!is.null(pattern)) {
[11:01:32.607]                           computeRestarts <- base::computeRestarts
[11:01:32.607]                           grepl <- base::grepl
[11:01:32.607]                           restarts <- computeRestarts(cond)
[11:01:32.607]                           for (restart in restarts) {
[11:01:32.607]                             name <- restart$name
[11:01:32.607]                             if (is.null(name)) 
[11:01:32.607]                               next
[11:01:32.607]                             if (!grepl(pattern, name)) 
[11:01:32.607]                               next
[11:01:32.607]                             invokeRestart(restart)
[11:01:32.607]                             muffled <- TRUE
[11:01:32.607]                             break
[11:01:32.607]                           }
[11:01:32.607]                         }
[11:01:32.607]                       }
[11:01:32.607]                       invisible(muffled)
[11:01:32.607]                     }
[11:01:32.607]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.607]                   }
[11:01:32.607]                 }
[11:01:32.607]             }
[11:01:32.607]         }))
[11:01:32.607]     }, error = function(ex) {
[11:01:32.607]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.607]                 ...future.rng), started = ...future.startTime, 
[11:01:32.607]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.607]             version = "1.8"), class = "FutureResult")
[11:01:32.607]     }, finally = {
[11:01:32.607]         if (!identical(...future.workdir, getwd())) 
[11:01:32.607]             setwd(...future.workdir)
[11:01:32.607]         {
[11:01:32.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.607]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.607]             }
[11:01:32.607]             base::options(...future.oldOptions)
[11:01:32.607]             if (.Platform$OS.type == "windows") {
[11:01:32.607]                 old_names <- names(...future.oldEnvVars)
[11:01:32.607]                 envs <- base::Sys.getenv()
[11:01:32.607]                 names <- names(envs)
[11:01:32.607]                 common <- intersect(names, old_names)
[11:01:32.607]                 added <- setdiff(names, old_names)
[11:01:32.607]                 removed <- setdiff(old_names, names)
[11:01:32.607]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.607]                   envs[common]]
[11:01:32.607]                 NAMES <- toupper(changed)
[11:01:32.607]                 args <- list()
[11:01:32.607]                 for (kk in seq_along(NAMES)) {
[11:01:32.607]                   name <- changed[[kk]]
[11:01:32.607]                   NAME <- NAMES[[kk]]
[11:01:32.607]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.607]                     next
[11:01:32.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.607]                 }
[11:01:32.607]                 NAMES <- toupper(added)
[11:01:32.607]                 for (kk in seq_along(NAMES)) {
[11:01:32.607]                   name <- added[[kk]]
[11:01:32.607]                   NAME <- NAMES[[kk]]
[11:01:32.607]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.607]                     next
[11:01:32.607]                   args[[name]] <- ""
[11:01:32.607]                 }
[11:01:32.607]                 NAMES <- toupper(removed)
[11:01:32.607]                 for (kk in seq_along(NAMES)) {
[11:01:32.607]                   name <- removed[[kk]]
[11:01:32.607]                   NAME <- NAMES[[kk]]
[11:01:32.607]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.607]                     next
[11:01:32.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.607]                 }
[11:01:32.607]                 if (length(args) > 0) 
[11:01:32.607]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.607]             }
[11:01:32.607]             else {
[11:01:32.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.607]             }
[11:01:32.607]             {
[11:01:32.607]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.607]                   0L) {
[11:01:32.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.607]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.607]                   base::options(opts)
[11:01:32.607]                 }
[11:01:32.607]                 {
[11:01:32.607]                   {
[11:01:32.607]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.607]                     NULL
[11:01:32.607]                   }
[11:01:32.607]                   options(future.plan = NULL)
[11:01:32.607]                   if (is.na(NA_character_)) 
[11:01:32.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.607]                     .init = FALSE)
[11:01:32.607]                 }
[11:01:32.607]             }
[11:01:32.607]         }
[11:01:32.607]     })
[11:01:32.607]     if (TRUE) {
[11:01:32.607]         base::sink(type = "output", split = FALSE)
[11:01:32.607]         if (TRUE) {
[11:01:32.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.607]         }
[11:01:32.607]         else {
[11:01:32.607]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.607]         }
[11:01:32.607]         base::close(...future.stdout)
[11:01:32.607]         ...future.stdout <- NULL
[11:01:32.607]     }
[11:01:32.607]     ...future.result$conditions <- ...future.conditions
[11:01:32.607]     ...future.result$finished <- base::Sys.time()
[11:01:32.607]     ...future.result
[11:01:32.607] }
[11:01:32.611] requestCore(): workers = 2
[11:01:32.613] MulticoreFuture started
[11:01:32.614] - Launch lazy future ... done
[11:01:32.614] run() for ‘MulticoreFuture’ ... done
[11:01:32.614] plan(): Setting new future strategy stack:
[11:01:32.615] getGlobalsAndPackages() ...
[11:01:32.615] Searching for globals...
[11:01:32.614] List of future strategies:
[11:01:32.614] 1. sequential:
[11:01:32.614]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.614]    - tweaked: FALSE
[11:01:32.614]    - call: NULL
[11:01:32.615] plan(): nbrOfWorkers() = 1
[11:01:32.616] - globals found: [1] ‘{’
[11:01:32.616] Searching for globals ... DONE
[11:01:32.617] Resolving globals: FALSE
[11:01:32.617] 
[11:01:32.617] 
[11:01:32.617] getGlobalsAndPackages() ... DONE
[11:01:32.617] plan(): Setting new future strategy stack:
[11:01:32.618] run() for ‘Future’ ...
[11:01:32.617] List of future strategies:
[11:01:32.617] 1. multicore:
[11:01:32.617]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.617]    - tweaked: FALSE
[11:01:32.617]    - call: plan(strategy)
[11:01:32.618] - state: ‘created’
[11:01:32.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:32.620] plan(): nbrOfWorkers() = 2
[11:01:32.621] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:32.621] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:32.621]   - Field: ‘label’
[11:01:32.621]   - Field: ‘local’
[11:01:32.621]   - Field: ‘owner’
[11:01:32.621]   - Field: ‘envir’
[11:01:32.622]   - Field: ‘workers’
[11:01:32.622]   - Field: ‘packages’
[11:01:32.622]   - Field: ‘gc’
[11:01:32.622]   - Field: ‘job’
[11:01:32.622]   - Field: ‘conditions’
[11:01:32.622]   - Field: ‘expr’
[11:01:32.622]   - Field: ‘uuid’
[11:01:32.622]   - Field: ‘seed’
[11:01:32.623]   - Field: ‘version’
[11:01:32.623]   - Field: ‘result’
[11:01:32.623]   - Field: ‘asynchronous’
[11:01:32.623]   - Field: ‘calls’
[11:01:32.623]   - Field: ‘globals’
[11:01:32.623]   - Field: ‘stdout’
[11:01:32.623]   - Field: ‘earlySignal’
[11:01:32.623]   - Field: ‘lazy’
[11:01:32.624]   - Field: ‘state’
[11:01:32.624] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:32.624] - Launch lazy future ...
[11:01:32.624] Packages needed by the future expression (n = 0): <none>
[11:01:32.624] Packages needed by future strategies (n = 0): <none>
[11:01:32.625] {
[11:01:32.625]     {
[11:01:32.625]         {
[11:01:32.625]             ...future.startTime <- base::Sys.time()
[11:01:32.625]             {
[11:01:32.625]                 {
[11:01:32.625]                   {
[11:01:32.625]                     {
[11:01:32.625]                       base::local({
[11:01:32.625]                         has_future <- base::requireNamespace("future", 
[11:01:32.625]                           quietly = TRUE)
[11:01:32.625]                         if (has_future) {
[11:01:32.625]                           ns <- base::getNamespace("future")
[11:01:32.625]                           version <- ns[[".package"]][["version"]]
[11:01:32.625]                           if (is.null(version)) 
[11:01:32.625]                             version <- utils::packageVersion("future")
[11:01:32.625]                         }
[11:01:32.625]                         else {
[11:01:32.625]                           version <- NULL
[11:01:32.625]                         }
[11:01:32.625]                         if (!has_future || version < "1.8.0") {
[11:01:32.625]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.625]                             "", base::R.version$version.string), 
[11:01:32.625]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.625]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.625]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.625]                               "release", "version")], collapse = " "), 
[11:01:32.625]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.625]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.625]                             info)
[11:01:32.625]                           info <- base::paste(info, collapse = "; ")
[11:01:32.625]                           if (!has_future) {
[11:01:32.625]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.625]                               info)
[11:01:32.625]                           }
[11:01:32.625]                           else {
[11:01:32.625]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.625]                               info, version)
[11:01:32.625]                           }
[11:01:32.625]                           base::stop(msg)
[11:01:32.625]                         }
[11:01:32.625]                       })
[11:01:32.625]                     }
[11:01:32.625]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.625]                     base::options(mc.cores = 1L)
[11:01:32.625]                   }
[11:01:32.625]                   ...future.strategy.old <- future::plan("list")
[11:01:32.625]                   options(future.plan = NULL)
[11:01:32.625]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.625]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.625]                 }
[11:01:32.625]                 ...future.workdir <- getwd()
[11:01:32.625]             }
[11:01:32.625]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.625]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.625]         }
[11:01:32.625]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.625]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.625]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.625]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.625]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.625]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.625]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.625]             base::names(...future.oldOptions))
[11:01:32.625]     }
[11:01:32.625]     if (FALSE) {
[11:01:32.625]     }
[11:01:32.625]     else {
[11:01:32.625]         if (TRUE) {
[11:01:32.625]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.625]                 open = "w")
[11:01:32.625]         }
[11:01:32.625]         else {
[11:01:32.625]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.625]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.625]         }
[11:01:32.625]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.625]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.625]             base::sink(type = "output", split = FALSE)
[11:01:32.625]             base::close(...future.stdout)
[11:01:32.625]         }, add = TRUE)
[11:01:32.625]     }
[11:01:32.625]     ...future.frame <- base::sys.nframe()
[11:01:32.625]     ...future.conditions <- base::list()
[11:01:32.625]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.625]     if (FALSE) {
[11:01:32.625]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.625]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.625]     }
[11:01:32.625]     ...future.result <- base::tryCatch({
[11:01:32.625]         base::withCallingHandlers({
[11:01:32.625]             ...future.value <- base::withVisible(base::local({
[11:01:32.625]                 withCallingHandlers({
[11:01:32.625]                   {
[11:01:32.625]                     4
[11:01:32.625]                   }
[11:01:32.625]                 }, immediateCondition = function(cond) {
[11:01:32.625]                   save_rds <- function (object, pathname, ...) 
[11:01:32.625]                   {
[11:01:32.625]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:32.625]                     if (file_test("-f", pathname_tmp)) {
[11:01:32.625]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.625]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:32.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.625]                         fi_tmp[["mtime"]])
[11:01:32.625]                     }
[11:01:32.625]                     tryCatch({
[11:01:32.625]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:32.625]                     }, error = function(ex) {
[11:01:32.625]                       msg <- conditionMessage(ex)
[11:01:32.625]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.625]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:32.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.625]                         fi_tmp[["mtime"]], msg)
[11:01:32.625]                       ex$message <- msg
[11:01:32.625]                       stop(ex)
[11:01:32.625]                     })
[11:01:32.625]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:32.625]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:32.625]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:32.625]                       fi_tmp <- file.info(pathname_tmp)
[11:01:32.625]                       fi <- file.info(pathname)
[11:01:32.625]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:32.625]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:32.625]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:32.625]                         fi[["size"]], fi[["mtime"]])
[11:01:32.625]                       stop(msg)
[11:01:32.625]                     }
[11:01:32.625]                     invisible(pathname)
[11:01:32.625]                   }
[11:01:32.625]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:32.625]                     rootPath = tempdir()) 
[11:01:32.625]                   {
[11:01:32.625]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:32.625]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:32.625]                       tmpdir = path, fileext = ".rds")
[11:01:32.625]                     save_rds(obj, file)
[11:01:32.625]                   }
[11:01:32.625]                   saveImmediateCondition(cond, path = "/tmp/RtmpkYFZ6g/.future/immediateConditions")
[11:01:32.625]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.625]                   {
[11:01:32.625]                     inherits <- base::inherits
[11:01:32.625]                     invokeRestart <- base::invokeRestart
[11:01:32.625]                     is.null <- base::is.null
[11:01:32.625]                     muffled <- FALSE
[11:01:32.625]                     if (inherits(cond, "message")) {
[11:01:32.625]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.625]                       if (muffled) 
[11:01:32.625]                         invokeRestart("muffleMessage")
[11:01:32.625]                     }
[11:01:32.625]                     else if (inherits(cond, "warning")) {
[11:01:32.625]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.625]                       if (muffled) 
[11:01:32.625]                         invokeRestart("muffleWarning")
[11:01:32.625]                     }
[11:01:32.625]                     else if (inherits(cond, "condition")) {
[11:01:32.625]                       if (!is.null(pattern)) {
[11:01:32.625]                         computeRestarts <- base::computeRestarts
[11:01:32.625]                         grepl <- base::grepl
[11:01:32.625]                         restarts <- computeRestarts(cond)
[11:01:32.625]                         for (restart in restarts) {
[11:01:32.625]                           name <- restart$name
[11:01:32.625]                           if (is.null(name)) 
[11:01:32.625]                             next
[11:01:32.625]                           if (!grepl(pattern, name)) 
[11:01:32.625]                             next
[11:01:32.625]                           invokeRestart(restart)
[11:01:32.625]                           muffled <- TRUE
[11:01:32.625]                           break
[11:01:32.625]                         }
[11:01:32.625]                       }
[11:01:32.625]                     }
[11:01:32.625]                     invisible(muffled)
[11:01:32.625]                   }
[11:01:32.625]                   muffleCondition(cond)
[11:01:32.625]                 })
[11:01:32.625]             }))
[11:01:32.625]             future::FutureResult(value = ...future.value$value, 
[11:01:32.625]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.625]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.625]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.625]                     ...future.globalenv.names))
[11:01:32.625]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.625]         }, condition = base::local({
[11:01:32.625]             c <- base::c
[11:01:32.625]             inherits <- base::inherits
[11:01:32.625]             invokeRestart <- base::invokeRestart
[11:01:32.625]             length <- base::length
[11:01:32.625]             list <- base::list
[11:01:32.625]             seq.int <- base::seq.int
[11:01:32.625]             signalCondition <- base::signalCondition
[11:01:32.625]             sys.calls <- base::sys.calls
[11:01:32.625]             `[[` <- base::`[[`
[11:01:32.625]             `+` <- base::`+`
[11:01:32.625]             `<<-` <- base::`<<-`
[11:01:32.625]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.625]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.625]                   3L)]
[11:01:32.625]             }
[11:01:32.625]             function(cond) {
[11:01:32.625]                 is_error <- inherits(cond, "error")
[11:01:32.625]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.625]                   NULL)
[11:01:32.625]                 if (is_error) {
[11:01:32.625]                   sessionInformation <- function() {
[11:01:32.625]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.625]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.625]                       search = base::search(), system = base::Sys.info())
[11:01:32.625]                   }
[11:01:32.625]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.625]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.625]                     cond$call), session = sessionInformation(), 
[11:01:32.625]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.625]                   signalCondition(cond)
[11:01:32.625]                 }
[11:01:32.625]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.625]                 "immediateCondition"))) {
[11:01:32.625]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.625]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.625]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.625]                   if (TRUE && !signal) {
[11:01:32.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.625]                     {
[11:01:32.625]                       inherits <- base::inherits
[11:01:32.625]                       invokeRestart <- base::invokeRestart
[11:01:32.625]                       is.null <- base::is.null
[11:01:32.625]                       muffled <- FALSE
[11:01:32.625]                       if (inherits(cond, "message")) {
[11:01:32.625]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.625]                         if (muffled) 
[11:01:32.625]                           invokeRestart("muffleMessage")
[11:01:32.625]                       }
[11:01:32.625]                       else if (inherits(cond, "warning")) {
[11:01:32.625]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.625]                         if (muffled) 
[11:01:32.625]                           invokeRestart("muffleWarning")
[11:01:32.625]                       }
[11:01:32.625]                       else if (inherits(cond, "condition")) {
[11:01:32.625]                         if (!is.null(pattern)) {
[11:01:32.625]                           computeRestarts <- base::computeRestarts
[11:01:32.625]                           grepl <- base::grepl
[11:01:32.625]                           restarts <- computeRestarts(cond)
[11:01:32.625]                           for (restart in restarts) {
[11:01:32.625]                             name <- restart$name
[11:01:32.625]                             if (is.null(name)) 
[11:01:32.625]                               next
[11:01:32.625]                             if (!grepl(pattern, name)) 
[11:01:32.625]                               next
[11:01:32.625]                             invokeRestart(restart)
[11:01:32.625]                             muffled <- TRUE
[11:01:32.625]                             break
[11:01:32.625]                           }
[11:01:32.625]                         }
[11:01:32.625]                       }
[11:01:32.625]                       invisible(muffled)
[11:01:32.625]                     }
[11:01:32.625]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.625]                   }
[11:01:32.625]                 }
[11:01:32.625]                 else {
[11:01:32.625]                   if (TRUE) {
[11:01:32.625]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.625]                     {
[11:01:32.625]                       inherits <- base::inherits
[11:01:32.625]                       invokeRestart <- base::invokeRestart
[11:01:32.625]                       is.null <- base::is.null
[11:01:32.625]                       muffled <- FALSE
[11:01:32.625]                       if (inherits(cond, "message")) {
[11:01:32.625]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.625]                         if (muffled) 
[11:01:32.625]                           invokeRestart("muffleMessage")
[11:01:32.625]                       }
[11:01:32.625]                       else if (inherits(cond, "warning")) {
[11:01:32.625]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.625]                         if (muffled) 
[11:01:32.625]                           invokeRestart("muffleWarning")
[11:01:32.625]                       }
[11:01:32.625]                       else if (inherits(cond, "condition")) {
[11:01:32.625]                         if (!is.null(pattern)) {
[11:01:32.625]                           computeRestarts <- base::computeRestarts
[11:01:32.625]                           grepl <- base::grepl
[11:01:32.625]                           restarts <- computeRestarts(cond)
[11:01:32.625]                           for (restart in restarts) {
[11:01:32.625]                             name <- restart$name
[11:01:32.625]                             if (is.null(name)) 
[11:01:32.625]                               next
[11:01:32.625]                             if (!grepl(pattern, name)) 
[11:01:32.625]                               next
[11:01:32.625]                             invokeRestart(restart)
[11:01:32.625]                             muffled <- TRUE
[11:01:32.625]                             break
[11:01:32.625]                           }
[11:01:32.625]                         }
[11:01:32.625]                       }
[11:01:32.625]                       invisible(muffled)
[11:01:32.625]                     }
[11:01:32.625]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.625]                   }
[11:01:32.625]                 }
[11:01:32.625]             }
[11:01:32.625]         }))
[11:01:32.625]     }, error = function(ex) {
[11:01:32.625]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.625]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.625]                 ...future.rng), started = ...future.startTime, 
[11:01:32.625]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.625]             version = "1.8"), class = "FutureResult")
[11:01:32.625]     }, finally = {
[11:01:32.625]         if (!identical(...future.workdir, getwd())) 
[11:01:32.625]             setwd(...future.workdir)
[11:01:32.625]         {
[11:01:32.625]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.625]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.625]             }
[11:01:32.625]             base::options(...future.oldOptions)
[11:01:32.625]             if (.Platform$OS.type == "windows") {
[11:01:32.625]                 old_names <- names(...future.oldEnvVars)
[11:01:32.625]                 envs <- base::Sys.getenv()
[11:01:32.625]                 names <- names(envs)
[11:01:32.625]                 common <- intersect(names, old_names)
[11:01:32.625]                 added <- setdiff(names, old_names)
[11:01:32.625]                 removed <- setdiff(old_names, names)
[11:01:32.625]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.625]                   envs[common]]
[11:01:32.625]                 NAMES <- toupper(changed)
[11:01:32.625]                 args <- list()
[11:01:32.625]                 for (kk in seq_along(NAMES)) {
[11:01:32.625]                   name <- changed[[kk]]
[11:01:32.625]                   NAME <- NAMES[[kk]]
[11:01:32.625]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.625]                     next
[11:01:32.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.625]                 }
[11:01:32.625]                 NAMES <- toupper(added)
[11:01:32.625]                 for (kk in seq_along(NAMES)) {
[11:01:32.625]                   name <- added[[kk]]
[11:01:32.625]                   NAME <- NAMES[[kk]]
[11:01:32.625]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.625]                     next
[11:01:32.625]                   args[[name]] <- ""
[11:01:32.625]                 }
[11:01:32.625]                 NAMES <- toupper(removed)
[11:01:32.625]                 for (kk in seq_along(NAMES)) {
[11:01:32.625]                   name <- removed[[kk]]
[11:01:32.625]                   NAME <- NAMES[[kk]]
[11:01:32.625]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.625]                     next
[11:01:32.625]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.625]                 }
[11:01:32.625]                 if (length(args) > 0) 
[11:01:32.625]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.625]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.625]             }
[11:01:32.625]             else {
[11:01:32.625]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.625]             }
[11:01:32.625]             {
[11:01:32.625]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.625]                   0L) {
[11:01:32.625]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.625]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.625]                   base::options(opts)
[11:01:32.625]                 }
[11:01:32.625]                 {
[11:01:32.625]                   {
[11:01:32.625]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.625]                     NULL
[11:01:32.625]                   }
[11:01:32.625]                   options(future.plan = NULL)
[11:01:32.625]                   if (is.na(NA_character_)) 
[11:01:32.625]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.625]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.625]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.625]                     .init = FALSE)
[11:01:32.625]                 }
[11:01:32.625]             }
[11:01:32.625]         }
[11:01:32.625]     })
[11:01:32.625]     if (TRUE) {
[11:01:32.625]         base::sink(type = "output", split = FALSE)
[11:01:32.625]         if (TRUE) {
[11:01:32.625]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.625]         }
[11:01:32.625]         else {
[11:01:32.625]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.625]         }
[11:01:32.625]         base::close(...future.stdout)
[11:01:32.625]         ...future.stdout <- NULL
[11:01:32.625]     }
[11:01:32.625]     ...future.result$conditions <- ...future.conditions
[11:01:32.625]     ...future.result$finished <- base::Sys.time()
[11:01:32.625]     ...future.result
[11:01:32.625] }
[11:01:32.629] requestCore(): workers = 2
[11:01:32.629] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:32.640] result() for MulticoreFuture ...
[11:01:32.640] result() for MulticoreFuture ...
[11:01:32.641] result() for MulticoreFuture ... done
[11:01:32.641] result() for MulticoreFuture ... done
[11:01:32.641] result() for MulticoreFuture ...
[11:01:32.641] result() for MulticoreFuture ... done
[11:01:32.644] MulticoreFuture started
[11:01:32.644] - Launch lazy future ... done
[11:01:32.644] run() for ‘MulticoreFuture’ ... done
[11:01:32.645] plan(): Setting new future strategy stack:
Classes 'listenv', 'environment' <environment: 0x55a9c4f66198> 
[11:01:32.645] List of future strategies:
[11:01:32.645] 1. sequential:
[11:01:32.645]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:32.645]    - tweaked: FALSE
[11:01:32.645]    - call: NULL
[11:01:32.647] plan(): nbrOfWorkers() = 1
Classes 'listenv', 'environment' <environment: 0x55a9c81b5e90> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=[11:01:32.649] plan(): Setting new future strategy stack:
List of 4
  ..$ :[11:01:32.650] List of future strategies:
[11:01:32.650] 1. multicore:
[11:01:32.650]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:32.650]    - tweaked: FALSE
[11:01:32.650]    - call: plan(strategy)
 chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[11:01:32.654] plan(): nbrOfWorkers() = 2
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE TRUE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:32.659] resolve() on list environment ...
[11:01:32.659]  recursive: 0
[11:01:32.660]  length: 6
[11:01:32.660]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:32.660] signalConditionsASAP(numeric, pos=1) ...
[11:01:32.661] - nx: 6
[11:01:32.661] - relay: TRUE
[11:01:32.661] - stdout: TRUE
[11:01:32.661] - signal: TRUE
[11:01:32.661] - resignal: FALSE
[11:01:32.661] - force: TRUE
[11:01:32.661] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.662] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.662]  - until=2
[11:01:32.662]  - relaying element #2
[11:01:32.662] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.662] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.662] signalConditionsASAP(NULL, pos=1) ... done
[11:01:32.662]  length: 5 (resolved future 1)
[11:01:32.663] Future #2
[11:01:32.663] result() for MulticoreFuture ...
[11:01:32.663] result() for MulticoreFuture ... done
[11:01:32.663] result() for MulticoreFuture ...
[11:01:32.663] result() for MulticoreFuture ... done
[11:01:32.663] signalConditionsASAP(MulticoreFuture, pos=2) ...
[11:01:32.663] - nx: 6
[11:01:32.664] - relay: TRUE
[11:01:32.664] - stdout: TRUE
[11:01:32.664] - signal: TRUE
[11:01:32.664] - resignal: FALSE
[11:01:32.664] - force: TRUE
[11:01:32.664] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.664] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:32.664]  - until=2
[11:01:32.664]  - relaying element #2
[11:01:32.665] result() for MulticoreFuture ...
[11:01:32.665] result() for MulticoreFuture ... done
[11:01:32.665] result() for MulticoreFuture ...
[11:01:32.665] result() for MulticoreFuture ... done
[11:01:32.665] result() for MulticoreFuture ...
[11:01:32.665] result() for MulticoreFuture ... done
[11:01:32.665] result() for MulticoreFuture ...
[11:01:32.665] result() for MulticoreFuture ... done
[11:01:32.666] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.666] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.666] signalConditionsASAP(MulticoreFuture, pos=2) ... done
[11:01:32.666]  length: 4 (resolved future 2)
[11:01:32.666] Future #3
[11:01:32.666] result() for MulticoreFuture ...
[11:01:32.667] result() for MulticoreFuture ...
[11:01:32.667] result() for MulticoreFuture ... done
[11:01:32.668] result() for MulticoreFuture ... done
[11:01:32.668] result() for MulticoreFuture ...
[11:01:32.668] result() for MulticoreFuture ... done
[11:01:32.668] signalConditionsASAP(MulticoreFuture, pos=3) ...
[11:01:32.668] - nx: 6
[11:01:32.668] - relay: TRUE
[11:01:32.668] - stdout: TRUE
[11:01:32.668] - signal: TRUE
[11:01:32.668] - resignal: FALSE
[11:01:32.669] - force: TRUE
[11:01:32.669] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.669] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:32.669]  - until=3
[11:01:32.669]  - relaying element #3
[11:01:32.669] result() for MulticoreFuture ...
[11:01:32.669] result() for MulticoreFuture ... done
[11:01:32.669] result() for MulticoreFuture ...
[11:01:32.670] result() for MulticoreFuture ... done
[11:01:32.670] result() for MulticoreFuture ...
[11:01:32.670] result() for MulticoreFuture ... done
[11:01:32.670] result() for MulticoreFuture ...
[11:01:32.670] result() for MulticoreFuture ... done
[11:01:32.670] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.670] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.670] signalConditionsASAP(MulticoreFuture, pos=3) ... done
[11:01:32.671]  length: 3 (resolved future 3)
[11:01:32.671] Future #4
[11:01:32.671] result() for MulticoreFuture ...
[11:01:32.672] result() for MulticoreFuture ...
[11:01:32.672] result() for MulticoreFuture ... done
[11:01:32.672] result() for MulticoreFuture ... done
[11:01:32.672] result() for MulticoreFuture ...
[11:01:32.672] result() for MulticoreFuture ... done
[11:01:32.673] signalConditionsASAP(MulticoreFuture, pos=4) ...
[11:01:32.673] - nx: 6
[11:01:32.673] - relay: TRUE
[11:01:32.673] - stdout: TRUE
[11:01:32.673] - signal: TRUE
[11:01:32.673] - resignal: FALSE
[11:01:32.673] - force: TRUE
[11:01:32.674] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.674] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:32.674]  - until=4
[11:01:32.674]  - relaying element #4
[11:01:32.674] result() for MulticoreFuture ...
[11:01:32.674] result() for MulticoreFuture ... done
[11:01:32.675] result() for MulticoreFuture ...
[11:01:32.675] result() for MulticoreFuture ... done
[11:01:32.675] result() for MulticoreFuture ...
[11:01:32.675] result() for MulticoreFuture ... done
[11:01:32.675] result() for MulticoreFuture ...
[11:01:32.676] result() for MulticoreFuture ... done
[11:01:32.676] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.676] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.676] signalConditionsASAP(MulticoreFuture, pos=4) ... done
[11:01:32.676]  length: 2 (resolved future 4)
[11:01:32.676] signalConditionsASAP(NULL, pos=5) ...
[11:01:32.676] - nx: 6
[11:01:32.677] - relay: TRUE
[11:01:32.677] - stdout: TRUE
[11:01:32.677] - signal: TRUE
[11:01:32.677] - resignal: FALSE
[11:01:32.677] - force: TRUE
[11:01:32.677] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.677] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.677]  - until=6
[11:01:32.677]  - relaying element #6
[11:01:32.677] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.677] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.678] signalConditionsASAP(NULL, pos=5) ... done
[11:01:32.678]  length: 1 (resolved future 5)
[11:01:32.678] signalConditionsASAP(numeric, pos=6) ...
[11:01:32.678] - nx: 6
[11:01:32.678] - relay: TRUE
[11:01:32.678] - stdout: TRUE
[11:01:32.678] - signal: TRUE
[11:01:32.678] - resignal: FALSE
[11:01:32.678] - force: TRUE
[11:01:32.678] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, FALSE
[11:01:32.679] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.679]  - until=6
[11:01:32.679] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.679] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.679] signalConditionsASAP(numeric, pos=6) ... done
[11:01:32.679]  length: 0 (resolved future 6)
[11:01:32.679] Relaying remaining futures
[11:01:32.679] signalConditionsASAP(NULL, pos=0) ...
[11:01:32.679] - nx: 6
[11:01:32.679] - relay: TRUE
[11:01:32.679] - stdout: TRUE
[11:01:32.680] - signal: TRUE
[11:01:32.680] - resignal: FALSE
[11:01:32.680] - force: TRUE
[11:01:32.680] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.680] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:32.680] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:32.680] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:32.680] signalConditionsASAP(NULL, pos=0) ... done
[11:01:32.680] resolve() on list environment ... DONE
[11:01:32.681] result() for MulticoreFuture ...
[11:01:32.681] result() for MulticoreFuture ... done
[11:01:32.684] result() for MulticoreFuture ...
[11:01:32.684] result() for MulticoreFuture ... done
[11:01:32.685] result() for MulticoreFuture ...
[11:01:32.685] result() for MulticoreFuture ... done
[11:01:32.685] result() for MulticoreFuture ...
[11:01:32.685] result() for MulticoreFuture ... done
[11:01:32.686] result() for MulticoreFuture ...
[11:01:32.686] result() for MulticoreFuture ... done
[11:01:32.686] result() for MulticoreFuture ...
[11:01:32.686] result() for MulticoreFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c8470570> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Type of future: multisession
[11:01:32.689] plan(): Setting new future strategy stack:
[11:01:32.689] List of future strategies:
[11:01:32.689] 1. multisession:
[11:01:32.689]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:32.689]    - tweaked: FALSE
[11:01:32.689]    - call: plan(strategy)
[11:01:32.689] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:01:32.689] multisession:
[11:01:32.689] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:32.689] - tweaked: FALSE
[11:01:32.689] - call: plan(strategy)
[11:01:32.691] getGlobalsAndPackages() ...
[11:01:32.692] Not searching for globals
[11:01:32.692] - globals: [0] <none>
[11:01:32.692] getGlobalsAndPackages() ... DONE
[11:01:32.963] Packages needed by the future expression (n = 0): <none>
[11:01:32.964] Packages needed by future strategies (n = 0): <none>
[11:01:32.964] {
[11:01:32.964]     {
[11:01:32.964]         {
[11:01:32.964]             ...future.startTime <- base::Sys.time()
[11:01:32.964]             {
[11:01:32.964]                 {
[11:01:32.964]                   {
[11:01:32.964]                     {
[11:01:32.964]                       base::local({
[11:01:32.964]                         has_future <- base::requireNamespace("future", 
[11:01:32.964]                           quietly = TRUE)
[11:01:32.964]                         if (has_future) {
[11:01:32.964]                           ns <- base::getNamespace("future")
[11:01:32.964]                           version <- ns[[".package"]][["version"]]
[11:01:32.964]                           if (is.null(version)) 
[11:01:32.964]                             version <- utils::packageVersion("future")
[11:01:32.964]                         }
[11:01:32.964]                         else {
[11:01:32.964]                           version <- NULL
[11:01:32.964]                         }
[11:01:32.964]                         if (!has_future || version < "1.8.0") {
[11:01:32.964]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:32.964]                             "", base::R.version$version.string), 
[11:01:32.964]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:32.964]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:32.964]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:32.964]                               "release", "version")], collapse = " "), 
[11:01:32.964]                             hostname = base::Sys.info()[["nodename"]])
[11:01:32.964]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:32.964]                             info)
[11:01:32.964]                           info <- base::paste(info, collapse = "; ")
[11:01:32.964]                           if (!has_future) {
[11:01:32.964]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:32.964]                               info)
[11:01:32.964]                           }
[11:01:32.964]                           else {
[11:01:32.964]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:32.964]                               info, version)
[11:01:32.964]                           }
[11:01:32.964]                           base::stop(msg)
[11:01:32.964]                         }
[11:01:32.964]                       })
[11:01:32.964]                     }
[11:01:32.964]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:32.964]                     base::options(mc.cores = 1L)
[11:01:32.964]                   }
[11:01:32.964]                   ...future.strategy.old <- future::plan("list")
[11:01:32.964]                   options(future.plan = NULL)
[11:01:32.964]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.964]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:32.964]                 }
[11:01:32.964]                 ...future.workdir <- getwd()
[11:01:32.964]             }
[11:01:32.964]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:32.964]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:32.964]         }
[11:01:32.964]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:32.964]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:32.964]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:32.964]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:32.964]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:32.964]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:32.964]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:32.964]             base::names(...future.oldOptions))
[11:01:32.964]     }
[11:01:32.964]     if (FALSE) {
[11:01:32.964]     }
[11:01:32.964]     else {
[11:01:32.964]         if (TRUE) {
[11:01:32.964]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:32.964]                 open = "w")
[11:01:32.964]         }
[11:01:32.964]         else {
[11:01:32.964]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:32.964]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:32.964]         }
[11:01:32.964]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:32.964]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:32.964]             base::sink(type = "output", split = FALSE)
[11:01:32.964]             base::close(...future.stdout)
[11:01:32.964]         }, add = TRUE)
[11:01:32.964]     }
[11:01:32.964]     ...future.frame <- base::sys.nframe()
[11:01:32.964]     ...future.conditions <- base::list()
[11:01:32.964]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:32.964]     if (FALSE) {
[11:01:32.964]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:32.964]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:32.964]     }
[11:01:32.964]     ...future.result <- base::tryCatch({
[11:01:32.964]         base::withCallingHandlers({
[11:01:32.964]             ...future.value <- base::withVisible(base::local({
[11:01:32.964]                 ...future.makeSendCondition <- base::local({
[11:01:32.964]                   sendCondition <- NULL
[11:01:32.964]                   function(frame = 1L) {
[11:01:32.964]                     if (is.function(sendCondition)) 
[11:01:32.964]                       return(sendCondition)
[11:01:32.964]                     ns <- getNamespace("parallel")
[11:01:32.964]                     if (exists("sendData", mode = "function", 
[11:01:32.964]                       envir = ns)) {
[11:01:32.964]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:32.964]                         envir = ns)
[11:01:32.964]                       envir <- sys.frame(frame)
[11:01:32.964]                       master <- NULL
[11:01:32.964]                       while (!identical(envir, .GlobalEnv) && 
[11:01:32.964]                         !identical(envir, emptyenv())) {
[11:01:32.964]                         if (exists("master", mode = "list", envir = envir, 
[11:01:32.964]                           inherits = FALSE)) {
[11:01:32.964]                           master <- get("master", mode = "list", 
[11:01:32.964]                             envir = envir, inherits = FALSE)
[11:01:32.964]                           if (inherits(master, c("SOCKnode", 
[11:01:32.964]                             "SOCK0node"))) {
[11:01:32.964]                             sendCondition <<- function(cond) {
[11:01:32.964]                               data <- list(type = "VALUE", value = cond, 
[11:01:32.964]                                 success = TRUE)
[11:01:32.964]                               parallel_sendData(master, data)
[11:01:32.964]                             }
[11:01:32.964]                             return(sendCondition)
[11:01:32.964]                           }
[11:01:32.964]                         }
[11:01:32.964]                         frame <- frame + 1L
[11:01:32.964]                         envir <- sys.frame(frame)
[11:01:32.964]                       }
[11:01:32.964]                     }
[11:01:32.964]                     sendCondition <<- function(cond) NULL
[11:01:32.964]                   }
[11:01:32.964]                 })
[11:01:32.964]                 withCallingHandlers({
[11:01:32.964]                   NA
[11:01:32.964]                 }, immediateCondition = function(cond) {
[11:01:32.964]                   sendCondition <- ...future.makeSendCondition()
[11:01:32.964]                   sendCondition(cond)
[11:01:32.964]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.964]                   {
[11:01:32.964]                     inherits <- base::inherits
[11:01:32.964]                     invokeRestart <- base::invokeRestart
[11:01:32.964]                     is.null <- base::is.null
[11:01:32.964]                     muffled <- FALSE
[11:01:32.964]                     if (inherits(cond, "message")) {
[11:01:32.964]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:32.964]                       if (muffled) 
[11:01:32.964]                         invokeRestart("muffleMessage")
[11:01:32.964]                     }
[11:01:32.964]                     else if (inherits(cond, "warning")) {
[11:01:32.964]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:32.964]                       if (muffled) 
[11:01:32.964]                         invokeRestart("muffleWarning")
[11:01:32.964]                     }
[11:01:32.964]                     else if (inherits(cond, "condition")) {
[11:01:32.964]                       if (!is.null(pattern)) {
[11:01:32.964]                         computeRestarts <- base::computeRestarts
[11:01:32.964]                         grepl <- base::grepl
[11:01:32.964]                         restarts <- computeRestarts(cond)
[11:01:32.964]                         for (restart in restarts) {
[11:01:32.964]                           name <- restart$name
[11:01:32.964]                           if (is.null(name)) 
[11:01:32.964]                             next
[11:01:32.964]                           if (!grepl(pattern, name)) 
[11:01:32.964]                             next
[11:01:32.964]                           invokeRestart(restart)
[11:01:32.964]                           muffled <- TRUE
[11:01:32.964]                           break
[11:01:32.964]                         }
[11:01:32.964]                       }
[11:01:32.964]                     }
[11:01:32.964]                     invisible(muffled)
[11:01:32.964]                   }
[11:01:32.964]                   muffleCondition(cond)
[11:01:32.964]                 })
[11:01:32.964]             }))
[11:01:32.964]             future::FutureResult(value = ...future.value$value, 
[11:01:32.964]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.964]                   ...future.rng), globalenv = if (FALSE) 
[11:01:32.964]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:32.964]                     ...future.globalenv.names))
[11:01:32.964]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:32.964]         }, condition = base::local({
[11:01:32.964]             c <- base::c
[11:01:32.964]             inherits <- base::inherits
[11:01:32.964]             invokeRestart <- base::invokeRestart
[11:01:32.964]             length <- base::length
[11:01:32.964]             list <- base::list
[11:01:32.964]             seq.int <- base::seq.int
[11:01:32.964]             signalCondition <- base::signalCondition
[11:01:32.964]             sys.calls <- base::sys.calls
[11:01:32.964]             `[[` <- base::`[[`
[11:01:32.964]             `+` <- base::`+`
[11:01:32.964]             `<<-` <- base::`<<-`
[11:01:32.964]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:32.964]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:32.964]                   3L)]
[11:01:32.964]             }
[11:01:32.964]             function(cond) {
[11:01:32.964]                 is_error <- inherits(cond, "error")
[11:01:32.964]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:32.964]                   NULL)
[11:01:32.964]                 if (is_error) {
[11:01:32.964]                   sessionInformation <- function() {
[11:01:32.964]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:32.964]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:32.964]                       search = base::search(), system = base::Sys.info())
[11:01:32.964]                   }
[11:01:32.964]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.964]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:32.964]                     cond$call), session = sessionInformation(), 
[11:01:32.964]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:32.964]                   signalCondition(cond)
[11:01:32.964]                 }
[11:01:32.964]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:32.964]                 "immediateCondition"))) {
[11:01:32.964]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:32.964]                   ...future.conditions[[length(...future.conditions) + 
[11:01:32.964]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:32.964]                   if (TRUE && !signal) {
[11:01:32.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.964]                     {
[11:01:32.964]                       inherits <- base::inherits
[11:01:32.964]                       invokeRestart <- base::invokeRestart
[11:01:32.964]                       is.null <- base::is.null
[11:01:32.964]                       muffled <- FALSE
[11:01:32.964]                       if (inherits(cond, "message")) {
[11:01:32.964]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.964]                         if (muffled) 
[11:01:32.964]                           invokeRestart("muffleMessage")
[11:01:32.964]                       }
[11:01:32.964]                       else if (inherits(cond, "warning")) {
[11:01:32.964]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.964]                         if (muffled) 
[11:01:32.964]                           invokeRestart("muffleWarning")
[11:01:32.964]                       }
[11:01:32.964]                       else if (inherits(cond, "condition")) {
[11:01:32.964]                         if (!is.null(pattern)) {
[11:01:32.964]                           computeRestarts <- base::computeRestarts
[11:01:32.964]                           grepl <- base::grepl
[11:01:32.964]                           restarts <- computeRestarts(cond)
[11:01:32.964]                           for (restart in restarts) {
[11:01:32.964]                             name <- restart$name
[11:01:32.964]                             if (is.null(name)) 
[11:01:32.964]                               next
[11:01:32.964]                             if (!grepl(pattern, name)) 
[11:01:32.964]                               next
[11:01:32.964]                             invokeRestart(restart)
[11:01:32.964]                             muffled <- TRUE
[11:01:32.964]                             break
[11:01:32.964]                           }
[11:01:32.964]                         }
[11:01:32.964]                       }
[11:01:32.964]                       invisible(muffled)
[11:01:32.964]                     }
[11:01:32.964]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.964]                   }
[11:01:32.964]                 }
[11:01:32.964]                 else {
[11:01:32.964]                   if (TRUE) {
[11:01:32.964]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:32.964]                     {
[11:01:32.964]                       inherits <- base::inherits
[11:01:32.964]                       invokeRestart <- base::invokeRestart
[11:01:32.964]                       is.null <- base::is.null
[11:01:32.964]                       muffled <- FALSE
[11:01:32.964]                       if (inherits(cond, "message")) {
[11:01:32.964]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:32.964]                         if (muffled) 
[11:01:32.964]                           invokeRestart("muffleMessage")
[11:01:32.964]                       }
[11:01:32.964]                       else if (inherits(cond, "warning")) {
[11:01:32.964]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:32.964]                         if (muffled) 
[11:01:32.964]                           invokeRestart("muffleWarning")
[11:01:32.964]                       }
[11:01:32.964]                       else if (inherits(cond, "condition")) {
[11:01:32.964]                         if (!is.null(pattern)) {
[11:01:32.964]                           computeRestarts <- base::computeRestarts
[11:01:32.964]                           grepl <- base::grepl
[11:01:32.964]                           restarts <- computeRestarts(cond)
[11:01:32.964]                           for (restart in restarts) {
[11:01:32.964]                             name <- restart$name
[11:01:32.964]                             if (is.null(name)) 
[11:01:32.964]                               next
[11:01:32.964]                             if (!grepl(pattern, name)) 
[11:01:32.964]                               next
[11:01:32.964]                             invokeRestart(restart)
[11:01:32.964]                             muffled <- TRUE
[11:01:32.964]                             break
[11:01:32.964]                           }
[11:01:32.964]                         }
[11:01:32.964]                       }
[11:01:32.964]                       invisible(muffled)
[11:01:32.964]                     }
[11:01:32.964]                     muffleCondition(cond, pattern = "^muffle")
[11:01:32.964]                   }
[11:01:32.964]                 }
[11:01:32.964]             }
[11:01:32.964]         }))
[11:01:32.964]     }, error = function(ex) {
[11:01:32.964]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:32.964]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:32.964]                 ...future.rng), started = ...future.startTime, 
[11:01:32.964]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:32.964]             version = "1.8"), class = "FutureResult")
[11:01:32.964]     }, finally = {
[11:01:32.964]         if (!identical(...future.workdir, getwd())) 
[11:01:32.964]             setwd(...future.workdir)
[11:01:32.964]         {
[11:01:32.964]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:32.964]                 ...future.oldOptions$nwarnings <- NULL
[11:01:32.964]             }
[11:01:32.964]             base::options(...future.oldOptions)
[11:01:32.964]             if (.Platform$OS.type == "windows") {
[11:01:32.964]                 old_names <- names(...future.oldEnvVars)
[11:01:32.964]                 envs <- base::Sys.getenv()
[11:01:32.964]                 names <- names(envs)
[11:01:32.964]                 common <- intersect(names, old_names)
[11:01:32.964]                 added <- setdiff(names, old_names)
[11:01:32.964]                 removed <- setdiff(old_names, names)
[11:01:32.964]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:32.964]                   envs[common]]
[11:01:32.964]                 NAMES <- toupper(changed)
[11:01:32.964]                 args <- list()
[11:01:32.964]                 for (kk in seq_along(NAMES)) {
[11:01:32.964]                   name <- changed[[kk]]
[11:01:32.964]                   NAME <- NAMES[[kk]]
[11:01:32.964]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.964]                     next
[11:01:32.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.964]                 }
[11:01:32.964]                 NAMES <- toupper(added)
[11:01:32.964]                 for (kk in seq_along(NAMES)) {
[11:01:32.964]                   name <- added[[kk]]
[11:01:32.964]                   NAME <- NAMES[[kk]]
[11:01:32.964]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.964]                     next
[11:01:32.964]                   args[[name]] <- ""
[11:01:32.964]                 }
[11:01:32.964]                 NAMES <- toupper(removed)
[11:01:32.964]                 for (kk in seq_along(NAMES)) {
[11:01:32.964]                   name <- removed[[kk]]
[11:01:32.964]                   NAME <- NAMES[[kk]]
[11:01:32.964]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:32.964]                     next
[11:01:32.964]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:32.964]                 }
[11:01:32.964]                 if (length(args) > 0) 
[11:01:32.964]                   base::do.call(base::Sys.setenv, args = args)
[11:01:32.964]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:32.964]             }
[11:01:32.964]             else {
[11:01:32.964]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:32.964]             }
[11:01:32.964]             {
[11:01:32.964]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:32.964]                   0L) {
[11:01:32.964]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:32.964]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:32.964]                   base::options(opts)
[11:01:32.964]                 }
[11:01:32.964]                 {
[11:01:32.964]                   {
[11:01:32.964]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:32.964]                     NULL
[11:01:32.964]                   }
[11:01:32.964]                   options(future.plan = NULL)
[11:01:32.964]                   if (is.na(NA_character_)) 
[11:01:32.964]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:32.964]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:32.964]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:32.964]                     .init = FALSE)
[11:01:32.964]                 }
[11:01:32.964]             }
[11:01:32.964]         }
[11:01:32.964]     })
[11:01:32.964]     if (TRUE) {
[11:01:32.964]         base::sink(type = "output", split = FALSE)
[11:01:32.964]         if (TRUE) {
[11:01:32.964]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:32.964]         }
[11:01:32.964]         else {
[11:01:32.964]             ...future.result["stdout"] <- base::list(NULL)
[11:01:32.964]         }
[11:01:32.964]         base::close(...future.stdout)
[11:01:32.964]         ...future.stdout <- NULL
[11:01:32.964]     }
[11:01:32.964]     ...future.result$conditions <- ...future.conditions
[11:01:32.964]     ...future.result$finished <- base::Sys.time()
[11:01:32.964]     ...future.result
[11:01:32.964] }
[11:01:33.015] MultisessionFuture started
[11:01:33.015] result() for ClusterFuture ...
[11:01:33.015] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.015] - Validating connection of MultisessionFuture
[11:01:33.045] - received message: FutureResult
[11:01:33.045] - Received FutureResult
[11:01:33.045] - Erased future from FutureRegistry
[11:01:33.046] result() for ClusterFuture ...
[11:01:33.046] - result already collected: FutureResult
[11:01:33.046] result() for ClusterFuture ... done
[11:01:33.046] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.046] result() for ClusterFuture ... done
[11:01:33.046] result() for ClusterFuture ...
[11:01:33.046] - result already collected: FutureResult
[11:01:33.046] result() for ClusterFuture ... done
[11:01:33.047] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:01:33.048] plan(): nbrOfWorkers() = 2
Dimensions: NULL
[11:01:33.049] getGlobalsAndPackages() ...
[11:01:33.049] Searching for globals...
[11:01:33.049] 
[11:01:33.049] Searching for globals ... DONE
[11:01:33.049] - globals: [0] <none>
[11:01:33.049] getGlobalsAndPackages() ... DONE
[11:01:33.050] run() for ‘Future’ ...
[11:01:33.050] - state: ‘created’
[11:01:33.050] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.065] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.065] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.065]   - Field: ‘node’
[11:01:33.065]   - Field: ‘label’
[11:01:33.065]   - Field: ‘local’
[11:01:33.065]   - Field: ‘owner’
[11:01:33.066]   - Field: ‘envir’
[11:01:33.066]   - Field: ‘workers’
[11:01:33.066]   - Field: ‘packages’
[11:01:33.066]   - Field: ‘gc’
[11:01:33.066]   - Field: ‘conditions’
[11:01:33.066]   - Field: ‘persistent’
[11:01:33.066]   - Field: ‘expr’
[11:01:33.066]   - Field: ‘uuid’
[11:01:33.066]   - Field: ‘seed’
[11:01:33.066]   - Field: ‘version’
[11:01:33.067]   - Field: ‘result’
[11:01:33.067]   - Field: ‘asynchronous’
[11:01:33.067]   - Field: ‘calls’
[11:01:33.067]   - Field: ‘globals’
[11:01:33.067]   - Field: ‘stdout’
[11:01:33.067]   - Field: ‘earlySignal’
[11:01:33.067]   - Field: ‘lazy’
[11:01:33.067]   - Field: ‘state’
[11:01:33.067] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.068] - Launch lazy future ...
[11:01:33.068] Packages needed by the future expression (n = 0): <none>
[11:01:33.068] Packages needed by future strategies (n = 0): <none>
[11:01:33.069] {
[11:01:33.069]     {
[11:01:33.069]         {
[11:01:33.069]             ...future.startTime <- base::Sys.time()
[11:01:33.069]             {
[11:01:33.069]                 {
[11:01:33.069]                   {
[11:01:33.069]                     {
[11:01:33.069]                       base::local({
[11:01:33.069]                         has_future <- base::requireNamespace("future", 
[11:01:33.069]                           quietly = TRUE)
[11:01:33.069]                         if (has_future) {
[11:01:33.069]                           ns <- base::getNamespace("future")
[11:01:33.069]                           version <- ns[[".package"]][["version"]]
[11:01:33.069]                           if (is.null(version)) 
[11:01:33.069]                             version <- utils::packageVersion("future")
[11:01:33.069]                         }
[11:01:33.069]                         else {
[11:01:33.069]                           version <- NULL
[11:01:33.069]                         }
[11:01:33.069]                         if (!has_future || version < "1.8.0") {
[11:01:33.069]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.069]                             "", base::R.version$version.string), 
[11:01:33.069]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.069]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.069]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.069]                               "release", "version")], collapse = " "), 
[11:01:33.069]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.069]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.069]                             info)
[11:01:33.069]                           info <- base::paste(info, collapse = "; ")
[11:01:33.069]                           if (!has_future) {
[11:01:33.069]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.069]                               info)
[11:01:33.069]                           }
[11:01:33.069]                           else {
[11:01:33.069]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.069]                               info, version)
[11:01:33.069]                           }
[11:01:33.069]                           base::stop(msg)
[11:01:33.069]                         }
[11:01:33.069]                       })
[11:01:33.069]                     }
[11:01:33.069]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.069]                     base::options(mc.cores = 1L)
[11:01:33.069]                   }
[11:01:33.069]                   ...future.strategy.old <- future::plan("list")
[11:01:33.069]                   options(future.plan = NULL)
[11:01:33.069]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.069]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.069]                 }
[11:01:33.069]                 ...future.workdir <- getwd()
[11:01:33.069]             }
[11:01:33.069]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.069]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.069]         }
[11:01:33.069]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.069]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.069]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.069]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.069]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.069]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.069]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.069]             base::names(...future.oldOptions))
[11:01:33.069]     }
[11:01:33.069]     if (FALSE) {
[11:01:33.069]     }
[11:01:33.069]     else {
[11:01:33.069]         if (TRUE) {
[11:01:33.069]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.069]                 open = "w")
[11:01:33.069]         }
[11:01:33.069]         else {
[11:01:33.069]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.069]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.069]         }
[11:01:33.069]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.069]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.069]             base::sink(type = "output", split = FALSE)
[11:01:33.069]             base::close(...future.stdout)
[11:01:33.069]         }, add = TRUE)
[11:01:33.069]     }
[11:01:33.069]     ...future.frame <- base::sys.nframe()
[11:01:33.069]     ...future.conditions <- base::list()
[11:01:33.069]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.069]     if (FALSE) {
[11:01:33.069]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.069]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.069]     }
[11:01:33.069]     ...future.result <- base::tryCatch({
[11:01:33.069]         base::withCallingHandlers({
[11:01:33.069]             ...future.value <- base::withVisible(base::local({
[11:01:33.069]                 ...future.makeSendCondition <- base::local({
[11:01:33.069]                   sendCondition <- NULL
[11:01:33.069]                   function(frame = 1L) {
[11:01:33.069]                     if (is.function(sendCondition)) 
[11:01:33.069]                       return(sendCondition)
[11:01:33.069]                     ns <- getNamespace("parallel")
[11:01:33.069]                     if (exists("sendData", mode = "function", 
[11:01:33.069]                       envir = ns)) {
[11:01:33.069]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.069]                         envir = ns)
[11:01:33.069]                       envir <- sys.frame(frame)
[11:01:33.069]                       master <- NULL
[11:01:33.069]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.069]                         !identical(envir, emptyenv())) {
[11:01:33.069]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.069]                           inherits = FALSE)) {
[11:01:33.069]                           master <- get("master", mode = "list", 
[11:01:33.069]                             envir = envir, inherits = FALSE)
[11:01:33.069]                           if (inherits(master, c("SOCKnode", 
[11:01:33.069]                             "SOCK0node"))) {
[11:01:33.069]                             sendCondition <<- function(cond) {
[11:01:33.069]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.069]                                 success = TRUE)
[11:01:33.069]                               parallel_sendData(master, data)
[11:01:33.069]                             }
[11:01:33.069]                             return(sendCondition)
[11:01:33.069]                           }
[11:01:33.069]                         }
[11:01:33.069]                         frame <- frame + 1L
[11:01:33.069]                         envir <- sys.frame(frame)
[11:01:33.069]                       }
[11:01:33.069]                     }
[11:01:33.069]                     sendCondition <<- function(cond) NULL
[11:01:33.069]                   }
[11:01:33.069]                 })
[11:01:33.069]                 withCallingHandlers({
[11:01:33.069]                   2
[11:01:33.069]                 }, immediateCondition = function(cond) {
[11:01:33.069]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.069]                   sendCondition(cond)
[11:01:33.069]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.069]                   {
[11:01:33.069]                     inherits <- base::inherits
[11:01:33.069]                     invokeRestart <- base::invokeRestart
[11:01:33.069]                     is.null <- base::is.null
[11:01:33.069]                     muffled <- FALSE
[11:01:33.069]                     if (inherits(cond, "message")) {
[11:01:33.069]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.069]                       if (muffled) 
[11:01:33.069]                         invokeRestart("muffleMessage")
[11:01:33.069]                     }
[11:01:33.069]                     else if (inherits(cond, "warning")) {
[11:01:33.069]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.069]                       if (muffled) 
[11:01:33.069]                         invokeRestart("muffleWarning")
[11:01:33.069]                     }
[11:01:33.069]                     else if (inherits(cond, "condition")) {
[11:01:33.069]                       if (!is.null(pattern)) {
[11:01:33.069]                         computeRestarts <- base::computeRestarts
[11:01:33.069]                         grepl <- base::grepl
[11:01:33.069]                         restarts <- computeRestarts(cond)
[11:01:33.069]                         for (restart in restarts) {
[11:01:33.069]                           name <- restart$name
[11:01:33.069]                           if (is.null(name)) 
[11:01:33.069]                             next
[11:01:33.069]                           if (!grepl(pattern, name)) 
[11:01:33.069]                             next
[11:01:33.069]                           invokeRestart(restart)
[11:01:33.069]                           muffled <- TRUE
[11:01:33.069]                           break
[11:01:33.069]                         }
[11:01:33.069]                       }
[11:01:33.069]                     }
[11:01:33.069]                     invisible(muffled)
[11:01:33.069]                   }
[11:01:33.069]                   muffleCondition(cond)
[11:01:33.069]                 })
[11:01:33.069]             }))
[11:01:33.069]             future::FutureResult(value = ...future.value$value, 
[11:01:33.069]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.069]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.069]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.069]                     ...future.globalenv.names))
[11:01:33.069]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.069]         }, condition = base::local({
[11:01:33.069]             c <- base::c
[11:01:33.069]             inherits <- base::inherits
[11:01:33.069]             invokeRestart <- base::invokeRestart
[11:01:33.069]             length <- base::length
[11:01:33.069]             list <- base::list
[11:01:33.069]             seq.int <- base::seq.int
[11:01:33.069]             signalCondition <- base::signalCondition
[11:01:33.069]             sys.calls <- base::sys.calls
[11:01:33.069]             `[[` <- base::`[[`
[11:01:33.069]             `+` <- base::`+`
[11:01:33.069]             `<<-` <- base::`<<-`
[11:01:33.069]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.069]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.069]                   3L)]
[11:01:33.069]             }
[11:01:33.069]             function(cond) {
[11:01:33.069]                 is_error <- inherits(cond, "error")
[11:01:33.069]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.069]                   NULL)
[11:01:33.069]                 if (is_error) {
[11:01:33.069]                   sessionInformation <- function() {
[11:01:33.069]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.069]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.069]                       search = base::search(), system = base::Sys.info())
[11:01:33.069]                   }
[11:01:33.069]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.069]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.069]                     cond$call), session = sessionInformation(), 
[11:01:33.069]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.069]                   signalCondition(cond)
[11:01:33.069]                 }
[11:01:33.069]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.069]                 "immediateCondition"))) {
[11:01:33.069]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.069]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.069]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.069]                   if (TRUE && !signal) {
[11:01:33.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.069]                     {
[11:01:33.069]                       inherits <- base::inherits
[11:01:33.069]                       invokeRestart <- base::invokeRestart
[11:01:33.069]                       is.null <- base::is.null
[11:01:33.069]                       muffled <- FALSE
[11:01:33.069]                       if (inherits(cond, "message")) {
[11:01:33.069]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.069]                         if (muffled) 
[11:01:33.069]                           invokeRestart("muffleMessage")
[11:01:33.069]                       }
[11:01:33.069]                       else if (inherits(cond, "warning")) {
[11:01:33.069]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.069]                         if (muffled) 
[11:01:33.069]                           invokeRestart("muffleWarning")
[11:01:33.069]                       }
[11:01:33.069]                       else if (inherits(cond, "condition")) {
[11:01:33.069]                         if (!is.null(pattern)) {
[11:01:33.069]                           computeRestarts <- base::computeRestarts
[11:01:33.069]                           grepl <- base::grepl
[11:01:33.069]                           restarts <- computeRestarts(cond)
[11:01:33.069]                           for (restart in restarts) {
[11:01:33.069]                             name <- restart$name
[11:01:33.069]                             if (is.null(name)) 
[11:01:33.069]                               next
[11:01:33.069]                             if (!grepl(pattern, name)) 
[11:01:33.069]                               next
[11:01:33.069]                             invokeRestart(restart)
[11:01:33.069]                             muffled <- TRUE
[11:01:33.069]                             break
[11:01:33.069]                           }
[11:01:33.069]                         }
[11:01:33.069]                       }
[11:01:33.069]                       invisible(muffled)
[11:01:33.069]                     }
[11:01:33.069]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.069]                   }
[11:01:33.069]                 }
[11:01:33.069]                 else {
[11:01:33.069]                   if (TRUE) {
[11:01:33.069]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.069]                     {
[11:01:33.069]                       inherits <- base::inherits
[11:01:33.069]                       invokeRestart <- base::invokeRestart
[11:01:33.069]                       is.null <- base::is.null
[11:01:33.069]                       muffled <- FALSE
[11:01:33.069]                       if (inherits(cond, "message")) {
[11:01:33.069]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.069]                         if (muffled) 
[11:01:33.069]                           invokeRestart("muffleMessage")
[11:01:33.069]                       }
[11:01:33.069]                       else if (inherits(cond, "warning")) {
[11:01:33.069]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.069]                         if (muffled) 
[11:01:33.069]                           invokeRestart("muffleWarning")
[11:01:33.069]                       }
[11:01:33.069]                       else if (inherits(cond, "condition")) {
[11:01:33.069]                         if (!is.null(pattern)) {
[11:01:33.069]                           computeRestarts <- base::computeRestarts
[11:01:33.069]                           grepl <- base::grepl
[11:01:33.069]                           restarts <- computeRestarts(cond)
[11:01:33.069]                           for (restart in restarts) {
[11:01:33.069]                             name <- restart$name
[11:01:33.069]                             if (is.null(name)) 
[11:01:33.069]                               next
[11:01:33.069]                             if (!grepl(pattern, name)) 
[11:01:33.069]                               next
[11:01:33.069]                             invokeRestart(restart)
[11:01:33.069]                             muffled <- TRUE
[11:01:33.069]                             break
[11:01:33.069]                           }
[11:01:33.069]                         }
[11:01:33.069]                       }
[11:01:33.069]                       invisible(muffled)
[11:01:33.069]                     }
[11:01:33.069]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.069]                   }
[11:01:33.069]                 }
[11:01:33.069]             }
[11:01:33.069]         }))
[11:01:33.069]     }, error = function(ex) {
[11:01:33.069]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.069]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.069]                 ...future.rng), started = ...future.startTime, 
[11:01:33.069]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.069]             version = "1.8"), class = "FutureResult")
[11:01:33.069]     }, finally = {
[11:01:33.069]         if (!identical(...future.workdir, getwd())) 
[11:01:33.069]             setwd(...future.workdir)
[11:01:33.069]         {
[11:01:33.069]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.069]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.069]             }
[11:01:33.069]             base::options(...future.oldOptions)
[11:01:33.069]             if (.Platform$OS.type == "windows") {
[11:01:33.069]                 old_names <- names(...future.oldEnvVars)
[11:01:33.069]                 envs <- base::Sys.getenv()
[11:01:33.069]                 names <- names(envs)
[11:01:33.069]                 common <- intersect(names, old_names)
[11:01:33.069]                 added <- setdiff(names, old_names)
[11:01:33.069]                 removed <- setdiff(old_names, names)
[11:01:33.069]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.069]                   envs[common]]
[11:01:33.069]                 NAMES <- toupper(changed)
[11:01:33.069]                 args <- list()
[11:01:33.069]                 for (kk in seq_along(NAMES)) {
[11:01:33.069]                   name <- changed[[kk]]
[11:01:33.069]                   NAME <- NAMES[[kk]]
[11:01:33.069]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.069]                     next
[11:01:33.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.069]                 }
[11:01:33.069]                 NAMES <- toupper(added)
[11:01:33.069]                 for (kk in seq_along(NAMES)) {
[11:01:33.069]                   name <- added[[kk]]
[11:01:33.069]                   NAME <- NAMES[[kk]]
[11:01:33.069]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.069]                     next
[11:01:33.069]                   args[[name]] <- ""
[11:01:33.069]                 }
[11:01:33.069]                 NAMES <- toupper(removed)
[11:01:33.069]                 for (kk in seq_along(NAMES)) {
[11:01:33.069]                   name <- removed[[kk]]
[11:01:33.069]                   NAME <- NAMES[[kk]]
[11:01:33.069]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.069]                     next
[11:01:33.069]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.069]                 }
[11:01:33.069]                 if (length(args) > 0) 
[11:01:33.069]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.069]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.069]             }
[11:01:33.069]             else {
[11:01:33.069]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.069]             }
[11:01:33.069]             {
[11:01:33.069]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.069]                   0L) {
[11:01:33.069]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.069]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.069]                   base::options(opts)
[11:01:33.069]                 }
[11:01:33.069]                 {
[11:01:33.069]                   {
[11:01:33.069]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.069]                     NULL
[11:01:33.069]                   }
[11:01:33.069]                   options(future.plan = NULL)
[11:01:33.069]                   if (is.na(NA_character_)) 
[11:01:33.069]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.069]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.069]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.069]                     .init = FALSE)
[11:01:33.069]                 }
[11:01:33.069]             }
[11:01:33.069]         }
[11:01:33.069]     })
[11:01:33.069]     if (TRUE) {
[11:01:33.069]         base::sink(type = "output", split = FALSE)
[11:01:33.069]         if (TRUE) {
[11:01:33.069]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.069]         }
[11:01:33.069]         else {
[11:01:33.069]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.069]         }
[11:01:33.069]         base::close(...future.stdout)
[11:01:33.069]         ...future.stdout <- NULL
[11:01:33.069]     }
[11:01:33.069]     ...future.result$conditions <- ...future.conditions
[11:01:33.069]     ...future.result$finished <- base::Sys.time()
[11:01:33.069]     ...future.result
[11:01:33.069] }
[11:01:33.072] MultisessionFuture started
[11:01:33.072] - Launch lazy future ... done
[11:01:33.072] run() for ‘MultisessionFuture’ ... done
[11:01:33.072] getGlobalsAndPackages() ...
[11:01:33.072] Searching for globals...
[11:01:33.073] 
[11:01:33.073] Searching for globals ... DONE
[11:01:33.073] - globals: [0] <none>
[11:01:33.073] getGlobalsAndPackages() ... DONE
[11:01:33.073] run() for ‘Future’ ...
[11:01:33.073] - state: ‘created’
[11:01:33.074] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.089] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.089] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.089]   - Field: ‘node’
[11:01:33.090]   - Field: ‘label’
[11:01:33.090]   - Field: ‘local’
[11:01:33.090]   - Field: ‘owner’
[11:01:33.090]   - Field: ‘envir’
[11:01:33.090]   - Field: ‘workers’
[11:01:33.090]   - Field: ‘packages’
[11:01:33.090]   - Field: ‘gc’
[11:01:33.090]   - Field: ‘conditions’
[11:01:33.090]   - Field: ‘persistent’
[11:01:33.090]   - Field: ‘expr’
[11:01:33.091]   - Field: ‘uuid’
[11:01:33.091]   - Field: ‘seed’
[11:01:33.091]   - Field: ‘version’
[11:01:33.091]   - Field: ‘result’
[11:01:33.091]   - Field: ‘asynchronous’
[11:01:33.091]   - Field: ‘calls’
[11:01:33.091]   - Field: ‘globals’
[11:01:33.091]   - Field: ‘stdout’
[11:01:33.091]   - Field: ‘earlySignal’
[11:01:33.091]   - Field: ‘lazy’
[11:01:33.092]   - Field: ‘state’
[11:01:33.092] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.092] - Launch lazy future ...
[11:01:33.092] Packages needed by the future expression (n = 0): <none>
[11:01:33.092] Packages needed by future strategies (n = 0): <none>
[11:01:33.093] {
[11:01:33.093]     {
[11:01:33.093]         {
[11:01:33.093]             ...future.startTime <- base::Sys.time()
[11:01:33.093]             {
[11:01:33.093]                 {
[11:01:33.093]                   {
[11:01:33.093]                     {
[11:01:33.093]                       base::local({
[11:01:33.093]                         has_future <- base::requireNamespace("future", 
[11:01:33.093]                           quietly = TRUE)
[11:01:33.093]                         if (has_future) {
[11:01:33.093]                           ns <- base::getNamespace("future")
[11:01:33.093]                           version <- ns[[".package"]][["version"]]
[11:01:33.093]                           if (is.null(version)) 
[11:01:33.093]                             version <- utils::packageVersion("future")
[11:01:33.093]                         }
[11:01:33.093]                         else {
[11:01:33.093]                           version <- NULL
[11:01:33.093]                         }
[11:01:33.093]                         if (!has_future || version < "1.8.0") {
[11:01:33.093]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.093]                             "", base::R.version$version.string), 
[11:01:33.093]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.093]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.093]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.093]                               "release", "version")], collapse = " "), 
[11:01:33.093]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.093]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.093]                             info)
[11:01:33.093]                           info <- base::paste(info, collapse = "; ")
[11:01:33.093]                           if (!has_future) {
[11:01:33.093]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.093]                               info)
[11:01:33.093]                           }
[11:01:33.093]                           else {
[11:01:33.093]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.093]                               info, version)
[11:01:33.093]                           }
[11:01:33.093]                           base::stop(msg)
[11:01:33.093]                         }
[11:01:33.093]                       })
[11:01:33.093]                     }
[11:01:33.093]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.093]                     base::options(mc.cores = 1L)
[11:01:33.093]                   }
[11:01:33.093]                   ...future.strategy.old <- future::plan("list")
[11:01:33.093]                   options(future.plan = NULL)
[11:01:33.093]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.093]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.093]                 }
[11:01:33.093]                 ...future.workdir <- getwd()
[11:01:33.093]             }
[11:01:33.093]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.093]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.093]         }
[11:01:33.093]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.093]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.093]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.093]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.093]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.093]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.093]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.093]             base::names(...future.oldOptions))
[11:01:33.093]     }
[11:01:33.093]     if (FALSE) {
[11:01:33.093]     }
[11:01:33.093]     else {
[11:01:33.093]         if (TRUE) {
[11:01:33.093]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.093]                 open = "w")
[11:01:33.093]         }
[11:01:33.093]         else {
[11:01:33.093]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.093]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.093]         }
[11:01:33.093]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.093]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.093]             base::sink(type = "output", split = FALSE)
[11:01:33.093]             base::close(...future.stdout)
[11:01:33.093]         }, add = TRUE)
[11:01:33.093]     }
[11:01:33.093]     ...future.frame <- base::sys.nframe()
[11:01:33.093]     ...future.conditions <- base::list()
[11:01:33.093]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.093]     if (FALSE) {
[11:01:33.093]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.093]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.093]     }
[11:01:33.093]     ...future.result <- base::tryCatch({
[11:01:33.093]         base::withCallingHandlers({
[11:01:33.093]             ...future.value <- base::withVisible(base::local({
[11:01:33.093]                 ...future.makeSendCondition <- base::local({
[11:01:33.093]                   sendCondition <- NULL
[11:01:33.093]                   function(frame = 1L) {
[11:01:33.093]                     if (is.function(sendCondition)) 
[11:01:33.093]                       return(sendCondition)
[11:01:33.093]                     ns <- getNamespace("parallel")
[11:01:33.093]                     if (exists("sendData", mode = "function", 
[11:01:33.093]                       envir = ns)) {
[11:01:33.093]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.093]                         envir = ns)
[11:01:33.093]                       envir <- sys.frame(frame)
[11:01:33.093]                       master <- NULL
[11:01:33.093]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.093]                         !identical(envir, emptyenv())) {
[11:01:33.093]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.093]                           inherits = FALSE)) {
[11:01:33.093]                           master <- get("master", mode = "list", 
[11:01:33.093]                             envir = envir, inherits = FALSE)
[11:01:33.093]                           if (inherits(master, c("SOCKnode", 
[11:01:33.093]                             "SOCK0node"))) {
[11:01:33.093]                             sendCondition <<- function(cond) {
[11:01:33.093]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.093]                                 success = TRUE)
[11:01:33.093]                               parallel_sendData(master, data)
[11:01:33.093]                             }
[11:01:33.093]                             return(sendCondition)
[11:01:33.093]                           }
[11:01:33.093]                         }
[11:01:33.093]                         frame <- frame + 1L
[11:01:33.093]                         envir <- sys.frame(frame)
[11:01:33.093]                       }
[11:01:33.093]                     }
[11:01:33.093]                     sendCondition <<- function(cond) NULL
[11:01:33.093]                   }
[11:01:33.093]                 })
[11:01:33.093]                 withCallingHandlers({
[11:01:33.093]                   NULL
[11:01:33.093]                 }, immediateCondition = function(cond) {
[11:01:33.093]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.093]                   sendCondition(cond)
[11:01:33.093]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.093]                   {
[11:01:33.093]                     inherits <- base::inherits
[11:01:33.093]                     invokeRestart <- base::invokeRestart
[11:01:33.093]                     is.null <- base::is.null
[11:01:33.093]                     muffled <- FALSE
[11:01:33.093]                     if (inherits(cond, "message")) {
[11:01:33.093]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.093]                       if (muffled) 
[11:01:33.093]                         invokeRestart("muffleMessage")
[11:01:33.093]                     }
[11:01:33.093]                     else if (inherits(cond, "warning")) {
[11:01:33.093]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.093]                       if (muffled) 
[11:01:33.093]                         invokeRestart("muffleWarning")
[11:01:33.093]                     }
[11:01:33.093]                     else if (inherits(cond, "condition")) {
[11:01:33.093]                       if (!is.null(pattern)) {
[11:01:33.093]                         computeRestarts <- base::computeRestarts
[11:01:33.093]                         grepl <- base::grepl
[11:01:33.093]                         restarts <- computeRestarts(cond)
[11:01:33.093]                         for (restart in restarts) {
[11:01:33.093]                           name <- restart$name
[11:01:33.093]                           if (is.null(name)) 
[11:01:33.093]                             next
[11:01:33.093]                           if (!grepl(pattern, name)) 
[11:01:33.093]                             next
[11:01:33.093]                           invokeRestart(restart)
[11:01:33.093]                           muffled <- TRUE
[11:01:33.093]                           break
[11:01:33.093]                         }
[11:01:33.093]                       }
[11:01:33.093]                     }
[11:01:33.093]                     invisible(muffled)
[11:01:33.093]                   }
[11:01:33.093]                   muffleCondition(cond)
[11:01:33.093]                 })
[11:01:33.093]             }))
[11:01:33.093]             future::FutureResult(value = ...future.value$value, 
[11:01:33.093]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.093]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.093]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.093]                     ...future.globalenv.names))
[11:01:33.093]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.093]         }, condition = base::local({
[11:01:33.093]             c <- base::c
[11:01:33.093]             inherits <- base::inherits
[11:01:33.093]             invokeRestart <- base::invokeRestart
[11:01:33.093]             length <- base::length
[11:01:33.093]             list <- base::list
[11:01:33.093]             seq.int <- base::seq.int
[11:01:33.093]             signalCondition <- base::signalCondition
[11:01:33.093]             sys.calls <- base::sys.calls
[11:01:33.093]             `[[` <- base::`[[`
[11:01:33.093]             `+` <- base::`+`
[11:01:33.093]             `<<-` <- base::`<<-`
[11:01:33.093]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.093]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.093]                   3L)]
[11:01:33.093]             }
[11:01:33.093]             function(cond) {
[11:01:33.093]                 is_error <- inherits(cond, "error")
[11:01:33.093]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.093]                   NULL)
[11:01:33.093]                 if (is_error) {
[11:01:33.093]                   sessionInformation <- function() {
[11:01:33.093]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.093]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.093]                       search = base::search(), system = base::Sys.info())
[11:01:33.093]                   }
[11:01:33.093]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.093]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.093]                     cond$call), session = sessionInformation(), 
[11:01:33.093]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.093]                   signalCondition(cond)
[11:01:33.093]                 }
[11:01:33.093]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.093]                 "immediateCondition"))) {
[11:01:33.093]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.093]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.093]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.093]                   if (TRUE && !signal) {
[11:01:33.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.093]                     {
[11:01:33.093]                       inherits <- base::inherits
[11:01:33.093]                       invokeRestart <- base::invokeRestart
[11:01:33.093]                       is.null <- base::is.null
[11:01:33.093]                       muffled <- FALSE
[11:01:33.093]                       if (inherits(cond, "message")) {
[11:01:33.093]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.093]                         if (muffled) 
[11:01:33.093]                           invokeRestart("muffleMessage")
[11:01:33.093]                       }
[11:01:33.093]                       else if (inherits(cond, "warning")) {
[11:01:33.093]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.093]                         if (muffled) 
[11:01:33.093]                           invokeRestart("muffleWarning")
[11:01:33.093]                       }
[11:01:33.093]                       else if (inherits(cond, "condition")) {
[11:01:33.093]                         if (!is.null(pattern)) {
[11:01:33.093]                           computeRestarts <- base::computeRestarts
[11:01:33.093]                           grepl <- base::grepl
[11:01:33.093]                           restarts <- computeRestarts(cond)
[11:01:33.093]                           for (restart in restarts) {
[11:01:33.093]                             name <- restart$name
[11:01:33.093]                             if (is.null(name)) 
[11:01:33.093]                               next
[11:01:33.093]                             if (!grepl(pattern, name)) 
[11:01:33.093]                               next
[11:01:33.093]                             invokeRestart(restart)
[11:01:33.093]                             muffled <- TRUE
[11:01:33.093]                             break
[11:01:33.093]                           }
[11:01:33.093]                         }
[11:01:33.093]                       }
[11:01:33.093]                       invisible(muffled)
[11:01:33.093]                     }
[11:01:33.093]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.093]                   }
[11:01:33.093]                 }
[11:01:33.093]                 else {
[11:01:33.093]                   if (TRUE) {
[11:01:33.093]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.093]                     {
[11:01:33.093]                       inherits <- base::inherits
[11:01:33.093]                       invokeRestart <- base::invokeRestart
[11:01:33.093]                       is.null <- base::is.null
[11:01:33.093]                       muffled <- FALSE
[11:01:33.093]                       if (inherits(cond, "message")) {
[11:01:33.093]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.093]                         if (muffled) 
[11:01:33.093]                           invokeRestart("muffleMessage")
[11:01:33.093]                       }
[11:01:33.093]                       else if (inherits(cond, "warning")) {
[11:01:33.093]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.093]                         if (muffled) 
[11:01:33.093]                           invokeRestart("muffleWarning")
[11:01:33.093]                       }
[11:01:33.093]                       else if (inherits(cond, "condition")) {
[11:01:33.093]                         if (!is.null(pattern)) {
[11:01:33.093]                           computeRestarts <- base::computeRestarts
[11:01:33.093]                           grepl <- base::grepl
[11:01:33.093]                           restarts <- computeRestarts(cond)
[11:01:33.093]                           for (restart in restarts) {
[11:01:33.093]                             name <- restart$name
[11:01:33.093]                             if (is.null(name)) 
[11:01:33.093]                               next
[11:01:33.093]                             if (!grepl(pattern, name)) 
[11:01:33.093]                               next
[11:01:33.093]                             invokeRestart(restart)
[11:01:33.093]                             muffled <- TRUE
[11:01:33.093]                             break
[11:01:33.093]                           }
[11:01:33.093]                         }
[11:01:33.093]                       }
[11:01:33.093]                       invisible(muffled)
[11:01:33.093]                     }
[11:01:33.093]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.093]                   }
[11:01:33.093]                 }
[11:01:33.093]             }
[11:01:33.093]         }))
[11:01:33.093]     }, error = function(ex) {
[11:01:33.093]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.093]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.093]                 ...future.rng), started = ...future.startTime, 
[11:01:33.093]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.093]             version = "1.8"), class = "FutureResult")
[11:01:33.093]     }, finally = {
[11:01:33.093]         if (!identical(...future.workdir, getwd())) 
[11:01:33.093]             setwd(...future.workdir)
[11:01:33.093]         {
[11:01:33.093]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.093]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.093]             }
[11:01:33.093]             base::options(...future.oldOptions)
[11:01:33.093]             if (.Platform$OS.type == "windows") {
[11:01:33.093]                 old_names <- names(...future.oldEnvVars)
[11:01:33.093]                 envs <- base::Sys.getenv()
[11:01:33.093]                 names <- names(envs)
[11:01:33.093]                 common <- intersect(names, old_names)
[11:01:33.093]                 added <- setdiff(names, old_names)
[11:01:33.093]                 removed <- setdiff(old_names, names)
[11:01:33.093]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.093]                   envs[common]]
[11:01:33.093]                 NAMES <- toupper(changed)
[11:01:33.093]                 args <- list()
[11:01:33.093]                 for (kk in seq_along(NAMES)) {
[11:01:33.093]                   name <- changed[[kk]]
[11:01:33.093]                   NAME <- NAMES[[kk]]
[11:01:33.093]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.093]                     next
[11:01:33.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.093]                 }
[11:01:33.093]                 NAMES <- toupper(added)
[11:01:33.093]                 for (kk in seq_along(NAMES)) {
[11:01:33.093]                   name <- added[[kk]]
[11:01:33.093]                   NAME <- NAMES[[kk]]
[11:01:33.093]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.093]                     next
[11:01:33.093]                   args[[name]] <- ""
[11:01:33.093]                 }
[11:01:33.093]                 NAMES <- toupper(removed)
[11:01:33.093]                 for (kk in seq_along(NAMES)) {
[11:01:33.093]                   name <- removed[[kk]]
[11:01:33.093]                   NAME <- NAMES[[kk]]
[11:01:33.093]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.093]                     next
[11:01:33.093]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.093]                 }
[11:01:33.093]                 if (length(args) > 0) 
[11:01:33.093]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.093]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.093]             }
[11:01:33.093]             else {
[11:01:33.093]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.093]             }
[11:01:33.093]             {
[11:01:33.093]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.093]                   0L) {
[11:01:33.093]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.093]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.093]                   base::options(opts)
[11:01:33.093]                 }
[11:01:33.093]                 {
[11:01:33.093]                   {
[11:01:33.093]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.093]                     NULL
[11:01:33.093]                   }
[11:01:33.093]                   options(future.plan = NULL)
[11:01:33.093]                   if (is.na(NA_character_)) 
[11:01:33.093]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.093]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.093]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.093]                     .init = FALSE)
[11:01:33.093]                 }
[11:01:33.093]             }
[11:01:33.093]         }
[11:01:33.093]     })
[11:01:33.093]     if (TRUE) {
[11:01:33.093]         base::sink(type = "output", split = FALSE)
[11:01:33.093]         if (TRUE) {
[11:01:33.093]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.093]         }
[11:01:33.093]         else {
[11:01:33.093]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.093]         }
[11:01:33.093]         base::close(...future.stdout)
[11:01:33.093]         ...future.stdout <- NULL
[11:01:33.093]     }
[11:01:33.093]     ...future.result$conditions <- ...future.conditions
[11:01:33.093]     ...future.result$finished <- base::Sys.time()
[11:01:33.093]     ...future.result
[11:01:33.093] }
[11:01:33.146] MultisessionFuture started
[11:01:33.146] - Launch lazy future ... done
[11:01:33.146] run() for ‘MultisessionFuture’ ... done
[11:01:33.147] getGlobalsAndPackages() ...
[11:01:33.147] Searching for globals...
[11:01:33.147] - globals found: [1] ‘{’
[11:01:33.148] Searching for globals ... DONE
[11:01:33.148] Resolving globals: FALSE
[11:01:33.148] 
[11:01:33.148] 
[11:01:33.148] getGlobalsAndPackages() ... DONE
[11:01:33.148] run() for ‘Future’ ...
[11:01:33.149] - state: ‘created’
[11:01:33.149] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.163] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.163] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.163]   - Field: ‘node’
[11:01:33.163]   - Field: ‘label’
[11:01:33.163]   - Field: ‘local’
[11:01:33.164]   - Field: ‘owner’
[11:01:33.164]   - Field: ‘envir’
[11:01:33.164]   - Field: ‘workers’
[11:01:33.164]   - Field: ‘packages’
[11:01:33.164]   - Field: ‘gc’
[11:01:33.164]   - Field: ‘conditions’
[11:01:33.164]   - Field: ‘persistent’
[11:01:33.164]   - Field: ‘expr’
[11:01:33.164]   - Field: ‘uuid’
[11:01:33.164]   - Field: ‘seed’
[11:01:33.165]   - Field: ‘version’
[11:01:33.165]   - Field: ‘result’
[11:01:33.165]   - Field: ‘asynchronous’
[11:01:33.165]   - Field: ‘calls’
[11:01:33.165]   - Field: ‘globals’
[11:01:33.165]   - Field: ‘stdout’
[11:01:33.165]   - Field: ‘earlySignal’
[11:01:33.165]   - Field: ‘lazy’
[11:01:33.165]   - Field: ‘state’
[11:01:33.165] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.166] - Launch lazy future ...
[11:01:33.166] Packages needed by the future expression (n = 0): <none>
[11:01:33.166] Packages needed by future strategies (n = 0): <none>
[11:01:33.166] {
[11:01:33.166]     {
[11:01:33.166]         {
[11:01:33.166]             ...future.startTime <- base::Sys.time()
[11:01:33.166]             {
[11:01:33.166]                 {
[11:01:33.166]                   {
[11:01:33.166]                     {
[11:01:33.166]                       base::local({
[11:01:33.166]                         has_future <- base::requireNamespace("future", 
[11:01:33.166]                           quietly = TRUE)
[11:01:33.166]                         if (has_future) {
[11:01:33.166]                           ns <- base::getNamespace("future")
[11:01:33.166]                           version <- ns[[".package"]][["version"]]
[11:01:33.166]                           if (is.null(version)) 
[11:01:33.166]                             version <- utils::packageVersion("future")
[11:01:33.166]                         }
[11:01:33.166]                         else {
[11:01:33.166]                           version <- NULL
[11:01:33.166]                         }
[11:01:33.166]                         if (!has_future || version < "1.8.0") {
[11:01:33.166]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.166]                             "", base::R.version$version.string), 
[11:01:33.166]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.166]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.166]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.166]                               "release", "version")], collapse = " "), 
[11:01:33.166]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.166]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.166]                             info)
[11:01:33.166]                           info <- base::paste(info, collapse = "; ")
[11:01:33.166]                           if (!has_future) {
[11:01:33.166]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.166]                               info)
[11:01:33.166]                           }
[11:01:33.166]                           else {
[11:01:33.166]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.166]                               info, version)
[11:01:33.166]                           }
[11:01:33.166]                           base::stop(msg)
[11:01:33.166]                         }
[11:01:33.166]                       })
[11:01:33.166]                     }
[11:01:33.166]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.166]                     base::options(mc.cores = 1L)
[11:01:33.166]                   }
[11:01:33.166]                   ...future.strategy.old <- future::plan("list")
[11:01:33.166]                   options(future.plan = NULL)
[11:01:33.166]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.166]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.166]                 }
[11:01:33.166]                 ...future.workdir <- getwd()
[11:01:33.166]             }
[11:01:33.166]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.166]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.166]         }
[11:01:33.166]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.166]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.166]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.166]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.166]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.166]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.166]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.166]             base::names(...future.oldOptions))
[11:01:33.166]     }
[11:01:33.166]     if (FALSE) {
[11:01:33.166]     }
[11:01:33.166]     else {
[11:01:33.166]         if (TRUE) {
[11:01:33.166]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.166]                 open = "w")
[11:01:33.166]         }
[11:01:33.166]         else {
[11:01:33.166]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.166]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.166]         }
[11:01:33.166]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.166]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.166]             base::sink(type = "output", split = FALSE)
[11:01:33.166]             base::close(...future.stdout)
[11:01:33.166]         }, add = TRUE)
[11:01:33.166]     }
[11:01:33.166]     ...future.frame <- base::sys.nframe()
[11:01:33.166]     ...future.conditions <- base::list()
[11:01:33.166]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.166]     if (FALSE) {
[11:01:33.166]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.166]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.166]     }
[11:01:33.166]     ...future.result <- base::tryCatch({
[11:01:33.166]         base::withCallingHandlers({
[11:01:33.166]             ...future.value <- base::withVisible(base::local({
[11:01:33.166]                 ...future.makeSendCondition <- base::local({
[11:01:33.166]                   sendCondition <- NULL
[11:01:33.166]                   function(frame = 1L) {
[11:01:33.166]                     if (is.function(sendCondition)) 
[11:01:33.166]                       return(sendCondition)
[11:01:33.166]                     ns <- getNamespace("parallel")
[11:01:33.166]                     if (exists("sendData", mode = "function", 
[11:01:33.166]                       envir = ns)) {
[11:01:33.166]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.166]                         envir = ns)
[11:01:33.166]                       envir <- sys.frame(frame)
[11:01:33.166]                       master <- NULL
[11:01:33.166]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.166]                         !identical(envir, emptyenv())) {
[11:01:33.166]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.166]                           inherits = FALSE)) {
[11:01:33.166]                           master <- get("master", mode = "list", 
[11:01:33.166]                             envir = envir, inherits = FALSE)
[11:01:33.166]                           if (inherits(master, c("SOCKnode", 
[11:01:33.166]                             "SOCK0node"))) {
[11:01:33.166]                             sendCondition <<- function(cond) {
[11:01:33.166]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.166]                                 success = TRUE)
[11:01:33.166]                               parallel_sendData(master, data)
[11:01:33.166]                             }
[11:01:33.166]                             return(sendCondition)
[11:01:33.166]                           }
[11:01:33.166]                         }
[11:01:33.166]                         frame <- frame + 1L
[11:01:33.166]                         envir <- sys.frame(frame)
[11:01:33.166]                       }
[11:01:33.166]                     }
[11:01:33.166]                     sendCondition <<- function(cond) NULL
[11:01:33.166]                   }
[11:01:33.166]                 })
[11:01:33.166]                 withCallingHandlers({
[11:01:33.166]                   {
[11:01:33.166]                     4
[11:01:33.166]                   }
[11:01:33.166]                 }, immediateCondition = function(cond) {
[11:01:33.166]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.166]                   sendCondition(cond)
[11:01:33.166]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.166]                   {
[11:01:33.166]                     inherits <- base::inherits
[11:01:33.166]                     invokeRestart <- base::invokeRestart
[11:01:33.166]                     is.null <- base::is.null
[11:01:33.166]                     muffled <- FALSE
[11:01:33.166]                     if (inherits(cond, "message")) {
[11:01:33.166]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.166]                       if (muffled) 
[11:01:33.166]                         invokeRestart("muffleMessage")
[11:01:33.166]                     }
[11:01:33.166]                     else if (inherits(cond, "warning")) {
[11:01:33.166]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.166]                       if (muffled) 
[11:01:33.166]                         invokeRestart("muffleWarning")
[11:01:33.166]                     }
[11:01:33.166]                     else if (inherits(cond, "condition")) {
[11:01:33.166]                       if (!is.null(pattern)) {
[11:01:33.166]                         computeRestarts <- base::computeRestarts
[11:01:33.166]                         grepl <- base::grepl
[11:01:33.166]                         restarts <- computeRestarts(cond)
[11:01:33.166]                         for (restart in restarts) {
[11:01:33.166]                           name <- restart$name
[11:01:33.166]                           if (is.null(name)) 
[11:01:33.166]                             next
[11:01:33.166]                           if (!grepl(pattern, name)) 
[11:01:33.166]                             next
[11:01:33.166]                           invokeRestart(restart)
[11:01:33.166]                           muffled <- TRUE
[11:01:33.166]                           break
[11:01:33.166]                         }
[11:01:33.166]                       }
[11:01:33.166]                     }
[11:01:33.166]                     invisible(muffled)
[11:01:33.166]                   }
[11:01:33.166]                   muffleCondition(cond)
[11:01:33.166]                 })
[11:01:33.166]             }))
[11:01:33.166]             future::FutureResult(value = ...future.value$value, 
[11:01:33.166]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.166]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.166]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.166]                     ...future.globalenv.names))
[11:01:33.166]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.166]         }, condition = base::local({
[11:01:33.166]             c <- base::c
[11:01:33.166]             inherits <- base::inherits
[11:01:33.166]             invokeRestart <- base::invokeRestart
[11:01:33.166]             length <- base::length
[11:01:33.166]             list <- base::list
[11:01:33.166]             seq.int <- base::seq.int
[11:01:33.166]             signalCondition <- base::signalCondition
[11:01:33.166]             sys.calls <- base::sys.calls
[11:01:33.166]             `[[` <- base::`[[`
[11:01:33.166]             `+` <- base::`+`
[11:01:33.166]             `<<-` <- base::`<<-`
[11:01:33.166]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.166]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.166]                   3L)]
[11:01:33.166]             }
[11:01:33.166]             function(cond) {
[11:01:33.166]                 is_error <- inherits(cond, "error")
[11:01:33.166]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.166]                   NULL)
[11:01:33.166]                 if (is_error) {
[11:01:33.166]                   sessionInformation <- function() {
[11:01:33.166]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.166]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.166]                       search = base::search(), system = base::Sys.info())
[11:01:33.166]                   }
[11:01:33.166]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.166]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.166]                     cond$call), session = sessionInformation(), 
[11:01:33.166]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.166]                   signalCondition(cond)
[11:01:33.166]                 }
[11:01:33.166]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.166]                 "immediateCondition"))) {
[11:01:33.166]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.166]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.166]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.166]                   if (TRUE && !signal) {
[11:01:33.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.166]                     {
[11:01:33.166]                       inherits <- base::inherits
[11:01:33.166]                       invokeRestart <- base::invokeRestart
[11:01:33.166]                       is.null <- base::is.null
[11:01:33.166]                       muffled <- FALSE
[11:01:33.166]                       if (inherits(cond, "message")) {
[11:01:33.166]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.166]                         if (muffled) 
[11:01:33.166]                           invokeRestart("muffleMessage")
[11:01:33.166]                       }
[11:01:33.166]                       else if (inherits(cond, "warning")) {
[11:01:33.166]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.166]                         if (muffled) 
[11:01:33.166]                           invokeRestart("muffleWarning")
[11:01:33.166]                       }
[11:01:33.166]                       else if (inherits(cond, "condition")) {
[11:01:33.166]                         if (!is.null(pattern)) {
[11:01:33.166]                           computeRestarts <- base::computeRestarts
[11:01:33.166]                           grepl <- base::grepl
[11:01:33.166]                           restarts <- computeRestarts(cond)
[11:01:33.166]                           for (restart in restarts) {
[11:01:33.166]                             name <- restart$name
[11:01:33.166]                             if (is.null(name)) 
[11:01:33.166]                               next
[11:01:33.166]                             if (!grepl(pattern, name)) 
[11:01:33.166]                               next
[11:01:33.166]                             invokeRestart(restart)
[11:01:33.166]                             muffled <- TRUE
[11:01:33.166]                             break
[11:01:33.166]                           }
[11:01:33.166]                         }
[11:01:33.166]                       }
[11:01:33.166]                       invisible(muffled)
[11:01:33.166]                     }
[11:01:33.166]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.166]                   }
[11:01:33.166]                 }
[11:01:33.166]                 else {
[11:01:33.166]                   if (TRUE) {
[11:01:33.166]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.166]                     {
[11:01:33.166]                       inherits <- base::inherits
[11:01:33.166]                       invokeRestart <- base::invokeRestart
[11:01:33.166]                       is.null <- base::is.null
[11:01:33.166]                       muffled <- FALSE
[11:01:33.166]                       if (inherits(cond, "message")) {
[11:01:33.166]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.166]                         if (muffled) 
[11:01:33.166]                           invokeRestart("muffleMessage")
[11:01:33.166]                       }
[11:01:33.166]                       else if (inherits(cond, "warning")) {
[11:01:33.166]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.166]                         if (muffled) 
[11:01:33.166]                           invokeRestart("muffleWarning")
[11:01:33.166]                       }
[11:01:33.166]                       else if (inherits(cond, "condition")) {
[11:01:33.166]                         if (!is.null(pattern)) {
[11:01:33.166]                           computeRestarts <- base::computeRestarts
[11:01:33.166]                           grepl <- base::grepl
[11:01:33.166]                           restarts <- computeRestarts(cond)
[11:01:33.166]                           for (restart in restarts) {
[11:01:33.166]                             name <- restart$name
[11:01:33.166]                             if (is.null(name)) 
[11:01:33.166]                               next
[11:01:33.166]                             if (!grepl(pattern, name)) 
[11:01:33.166]                               next
[11:01:33.166]                             invokeRestart(restart)
[11:01:33.166]                             muffled <- TRUE
[11:01:33.166]                             break
[11:01:33.166]                           }
[11:01:33.166]                         }
[11:01:33.166]                       }
[11:01:33.166]                       invisible(muffled)
[11:01:33.166]                     }
[11:01:33.166]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.166]                   }
[11:01:33.166]                 }
[11:01:33.166]             }
[11:01:33.166]         }))
[11:01:33.166]     }, error = function(ex) {
[11:01:33.166]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.166]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.166]                 ...future.rng), started = ...future.startTime, 
[11:01:33.166]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.166]             version = "1.8"), class = "FutureResult")
[11:01:33.166]     }, finally = {
[11:01:33.166]         if (!identical(...future.workdir, getwd())) 
[11:01:33.166]             setwd(...future.workdir)
[11:01:33.166]         {
[11:01:33.166]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.166]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.166]             }
[11:01:33.166]             base::options(...future.oldOptions)
[11:01:33.166]             if (.Platform$OS.type == "windows") {
[11:01:33.166]                 old_names <- names(...future.oldEnvVars)
[11:01:33.166]                 envs <- base::Sys.getenv()
[11:01:33.166]                 names <- names(envs)
[11:01:33.166]                 common <- intersect(names, old_names)
[11:01:33.166]                 added <- setdiff(names, old_names)
[11:01:33.166]                 removed <- setdiff(old_names, names)
[11:01:33.166]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.166]                   envs[common]]
[11:01:33.166]                 NAMES <- toupper(changed)
[11:01:33.166]                 args <- list()
[11:01:33.166]                 for (kk in seq_along(NAMES)) {
[11:01:33.166]                   name <- changed[[kk]]
[11:01:33.166]                   NAME <- NAMES[[kk]]
[11:01:33.166]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.166]                     next
[11:01:33.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.166]                 }
[11:01:33.166]                 NAMES <- toupper(added)
[11:01:33.166]                 for (kk in seq_along(NAMES)) {
[11:01:33.166]                   name <- added[[kk]]
[11:01:33.166]                   NAME <- NAMES[[kk]]
[11:01:33.166]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.166]                     next
[11:01:33.166]                   args[[name]] <- ""
[11:01:33.166]                 }
[11:01:33.166]                 NAMES <- toupper(removed)
[11:01:33.166]                 for (kk in seq_along(NAMES)) {
[11:01:33.166]                   name <- removed[[kk]]
[11:01:33.166]                   NAME <- NAMES[[kk]]
[11:01:33.166]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.166]                     next
[11:01:33.166]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.166]                 }
[11:01:33.166]                 if (length(args) > 0) 
[11:01:33.166]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.166]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.166]             }
[11:01:33.166]             else {
[11:01:33.166]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.166]             }
[11:01:33.166]             {
[11:01:33.166]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.166]                   0L) {
[11:01:33.166]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.166]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.166]                   base::options(opts)
[11:01:33.166]                 }
[11:01:33.166]                 {
[11:01:33.166]                   {
[11:01:33.166]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.166]                     NULL
[11:01:33.166]                   }
[11:01:33.166]                   options(future.plan = NULL)
[11:01:33.166]                   if (is.na(NA_character_)) 
[11:01:33.166]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.166]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.166]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.166]                     .init = FALSE)
[11:01:33.166]                 }
[11:01:33.166]             }
[11:01:33.166]         }
[11:01:33.166]     })
[11:01:33.166]     if (TRUE) {
[11:01:33.166]         base::sink(type = "output", split = FALSE)
[11:01:33.166]         if (TRUE) {
[11:01:33.166]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.166]         }
[11:01:33.166]         else {
[11:01:33.166]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.166]         }
[11:01:33.166]         base::close(...future.stdout)
[11:01:33.166]         ...future.stdout <- NULL
[11:01:33.166]     }
[11:01:33.166]     ...future.result$conditions <- ...future.conditions
[11:01:33.166]     ...future.result$finished <- base::Sys.time()
[11:01:33.166]     ...future.result
[11:01:33.166] }
[11:01:33.169] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:33.180] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.180] - Validating connection of MultisessionFuture
[11:01:33.180] - received message: FutureResult
[11:01:33.180] - Received FutureResult
[11:01:33.180] - Erased future from FutureRegistry
[11:01:33.180] result() for ClusterFuture ...
[11:01:33.180] - result already collected: FutureResult
[11:01:33.181] result() for ClusterFuture ... done
[11:01:33.181] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.181] result() for ClusterFuture ...
[11:01:33.181] - result already collected: FutureResult
[11:01:33.181] result() for ClusterFuture ... done
[11:01:33.181] result() for ClusterFuture ...
[11:01:33.181] - result already collected: FutureResult
[11:01:33.181] result() for ClusterFuture ... done
[11:01:33.182] MultisessionFuture started
[11:01:33.182] - Launch lazy future ... done
[11:01:33.183] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c64af3b0> 
Classes 'listenv', 'environment' <environment: 0x55a9c8041dd0> 
[11:01:33.185] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.186] - Validating connection of MultisessionFuture
[11:01:33.186] - received message: FutureResult
[11:01:33.186] - Received FutureResult
[11:01:33.186] - Erased future from FutureRegistry
[11:01:33.186] result() for ClusterFuture ...
[11:01:33.186] - result already collected: FutureResult
[11:01:33.186] result() for ClusterFuture ... done
[11:01:33.186] receiveMessageFromWorker() for ClusterFuture ... done
 Named logi [1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:33.198] resolve() on list environment ...
[11:01:33.198]  recursive: 0
[11:01:33.199]  length: 6
[11:01:33.199]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:33.199] signalConditionsASAP(numeric, pos=1) ...
[11:01:33.200] - nx: 6
[11:01:33.200] - relay: TRUE
[11:01:33.200] - stdout: TRUE
[11:01:33.200] - signal: TRUE
[11:01:33.200] - resignal: FALSE
[11:01:33.200] - force: TRUE
[11:01:33.200] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.200] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.200]  - until=2
[11:01:33.200]  - relaying element #2
[11:01:33.200] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.200] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.201] signalConditionsASAP(NULL, pos=1) ... done
[11:01:33.201]  length: 5 (resolved future 1)
[11:01:33.201] Future #2
[11:01:33.201] result() for ClusterFuture ...
[11:01:33.201] - result already collected: FutureResult
[11:01:33.201] result() for ClusterFuture ... done
[11:01:33.201] result() for ClusterFuture ...
[11:01:33.201] - result already collected: FutureResult
[11:01:33.201] result() for ClusterFuture ... done
[11:01:33.201] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:33.201] - nx: 6
[11:01:33.202] - relay: TRUE
[11:01:33.202] - stdout: TRUE
[11:01:33.202] - signal: TRUE
[11:01:33.202] - resignal: FALSE
[11:01:33.202] - force: TRUE
[11:01:33.202] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.202] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.202]  - until=2
[11:01:33.202]  - relaying element #2
[11:01:33.202] result() for ClusterFuture ...
[11:01:33.202] - result already collected: FutureResult
[11:01:33.202] result() for ClusterFuture ... done
[11:01:33.203] result() for ClusterFuture ...
[11:01:33.203] - result already collected: FutureResult
[11:01:33.203] result() for ClusterFuture ... done
[11:01:33.203] result() for ClusterFuture ...
[11:01:33.203] - result already collected: FutureResult
[11:01:33.203] result() for ClusterFuture ... done
[11:01:33.203] result() for ClusterFuture ...
[11:01:33.203] - result already collected: FutureResult
[11:01:33.203] result() for ClusterFuture ... done
[11:01:33.203] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.203] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.203] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:33.204]  length: 4 (resolved future 2)
[11:01:33.204] Future #3
[11:01:33.204] result() for ClusterFuture ...
[11:01:33.204] - result already collected: FutureResult
[11:01:33.204] result() for ClusterFuture ... done
[11:01:33.204] result() for ClusterFuture ...
[11:01:33.204] - result already collected: FutureResult
[11:01:33.204] result() for ClusterFuture ... done
[11:01:33.204] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:33.204] - nx: 6
[11:01:33.204] - relay: TRUE
[11:01:33.205] - stdout: TRUE
[11:01:33.205] - signal: TRUE
[11:01:33.205] - resignal: FALSE
[11:01:33.205] - force: TRUE
[11:01:33.205] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.205] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.205]  - until=3
[11:01:33.205]  - relaying element #3
[11:01:33.205] result() for ClusterFuture ...
[11:01:33.205] - result already collected: FutureResult
[11:01:33.205] result() for ClusterFuture ... done
[11:01:33.205] result() for ClusterFuture ...
[11:01:33.206] - result already collected: FutureResult
[11:01:33.206] result() for ClusterFuture ... done
[11:01:33.206] result() for ClusterFuture ...
[11:01:33.206] - result already collected: FutureResult
[11:01:33.206] result() for ClusterFuture ... done
[11:01:33.206] result() for ClusterFuture ...
[11:01:33.206] - result already collected: FutureResult
[11:01:33.206] result() for ClusterFuture ... done
[11:01:33.206] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.206] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.206] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:33.206]  length: 3 (resolved future 3)
[11:01:33.217] signalConditionsASAP(NULL, pos=5) ...
[11:01:33.217] - nx: 6
[11:01:33.217] - relay: TRUE
[11:01:33.217] - stdout: TRUE
[11:01:33.218] - signal: TRUE
[11:01:33.218] - resignal: FALSE
[11:01:33.218] - force: TRUE
[11:01:33.218] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.218] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.218]  - until=6
[11:01:33.218]  - relaying element #4
[11:01:33.218]  - relaying element #6
[11:01:33.218] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.218] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.218] signalConditionsASAP(NULL, pos=5) ... done
[11:01:33.219]  length: 2 (resolved future 5)
[11:01:33.219] signalConditionsASAP(numeric, pos=6) ...
[11:01:33.219] - nx: 6
[11:01:33.219] - relay: TRUE
[11:01:33.219] - stdout: TRUE
[11:01:33.219] - signal: TRUE
[11:01:33.219] - resignal: FALSE
[11:01:33.219] - force: TRUE
[11:01:33.219] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.219] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.219]  - until=6
[11:01:33.219]  - relaying element #4
[11:01:33.220] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.220] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.220] signalConditionsASAP(NULL, pos=6) ... done
[11:01:33.220]  length: 1 (resolved future 6)
[11:01:33.230] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.231] - Validating connection of MultisessionFuture
[11:01:33.231] - received message: FutureResult
[11:01:33.231] - Received FutureResult
[11:01:33.231] - Erased future from FutureRegistry
[11:01:33.231] result() for ClusterFuture ...
[11:01:33.231] - result already collected: FutureResult
[11:01:33.231] result() for ClusterFuture ... done
[11:01:33.231] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.231] Future #4
[11:01:33.232] result() for ClusterFuture ...
[11:01:33.232] - result already collected: FutureResult
[11:01:33.232] result() for ClusterFuture ... done
[11:01:33.232] result() for ClusterFuture ...
[11:01:33.232] - result already collected: FutureResult
[11:01:33.232] result() for ClusterFuture ... done
[11:01:33.232] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:33.232] - nx: 6
[11:01:33.232] - relay: TRUE
[11:01:33.232] - stdout: TRUE
[11:01:33.232] - signal: TRUE
[11:01:33.232] - resignal: FALSE
[11:01:33.233] - force: TRUE
[11:01:33.233] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.233] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.233]  - until=6
[11:01:33.233]  - relaying element #4
[11:01:33.233] result() for ClusterFuture ...
[11:01:33.233] - result already collected: FutureResult
[11:01:33.233] result() for ClusterFuture ... done
[11:01:33.233] result() for ClusterFuture ...
[11:01:33.233] - result already collected: FutureResult
[11:01:33.233] result() for ClusterFuture ... done
[11:01:33.234] result() for ClusterFuture ...
[11:01:33.234] - result already collected: FutureResult
[11:01:33.234] result() for ClusterFuture ... done
[11:01:33.234] result() for ClusterFuture ...
[11:01:33.234] - result already collected: FutureResult
[11:01:33.234] result() for ClusterFuture ... done
[11:01:33.234] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.234] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.234] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:33.234]  length: 0 (resolved future 4)
[11:01:33.234] Relaying remaining futures
[11:01:33.234] signalConditionsASAP(NULL, pos=0) ...
[11:01:33.234] - nx: 6
[11:01:33.235] - relay: TRUE
[11:01:33.235] - stdout: TRUE
[11:01:33.235] - signal: TRUE
[11:01:33.235] - resignal: FALSE
[11:01:33.235] - force: TRUE
[11:01:33.235] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.235] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:33.235] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.235] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.235] signalConditionsASAP(NULL, pos=0) ... done
[11:01:33.235] resolve() on list environment ... DONE
[11:01:33.236] result() for ClusterFuture ...
[11:01:33.236] - result already collected: FutureResult
[11:01:33.236] result() for ClusterFuture ... done
[11:01:33.236] result() for ClusterFuture ...
[11:01:33.236] - result already collected: FutureResult
[11:01:33.236] result() for ClusterFuture ... done
[11:01:33.236] result() for ClusterFuture ...
[11:01:33.236] - result already collected: FutureResult
[11:01:33.236] result() for ClusterFuture ... done
[11:01:33.236] result() for ClusterFuture ...
[11:01:33.236] - result already collected: FutureResult
[11:01:33.237] result() for ClusterFuture ... done
[11:01:33.237] result() for ClusterFuture ...
[11:01:33.237] - result already collected: FutureResult
[11:01:33.237] result() for ClusterFuture ... done
[11:01:33.237] result() for ClusterFuture ...
[11:01:33.237] - result already collected: FutureResult
[11:01:33.237] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c822b5a8> 
Dimensions: c(1, 6)
[11:01:33.238] getGlobalsAndPackages() ...
[11:01:33.240] Searching for globals...
[11:01:33.241] 
[11:01:33.241] Searching for globals ... DONE
[11:01:33.241] - globals: [0] <none>
[11:01:33.241] getGlobalsAndPackages() ... DONE
[11:01:33.241] run() for ‘Future’ ...
[11:01:33.241] - state: ‘created’
[11:01:33.241] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.255] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.256] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.256]   - Field: ‘node’
[11:01:33.256]   - Field: ‘label’
[11:01:33.256]   - Field: ‘local’
[11:01:33.256]   - Field: ‘owner’
[11:01:33.256]   - Field: ‘envir’
[11:01:33.256]   - Field: ‘workers’
[11:01:33.256]   - Field: ‘packages’
[11:01:33.256]   - Field: ‘gc’
[11:01:33.256]   - Field: ‘conditions’
[11:01:33.256]   - Field: ‘persistent’
[11:01:33.257]   - Field: ‘expr’
[11:01:33.257]   - Field: ‘uuid’
[11:01:33.257]   - Field: ‘seed’
[11:01:33.257]   - Field: ‘version’
[11:01:33.257]   - Field: ‘result’
[11:01:33.257]   - Field: ‘asynchronous’
[11:01:33.257]   - Field: ‘calls’
[11:01:33.257]   - Field: ‘globals’
[11:01:33.257]   - Field: ‘stdout’
[11:01:33.257]   - Field: ‘earlySignal’
[11:01:33.257]   - Field: ‘lazy’
[11:01:33.258]   - Field: ‘state’
[11:01:33.258] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.258] - Launch lazy future ...
[11:01:33.258] Packages needed by the future expression (n = 0): <none>
[11:01:33.258] Packages needed by future strategies (n = 0): <none>
[11:01:33.258] {
[11:01:33.258]     {
[11:01:33.258]         {
[11:01:33.258]             ...future.startTime <- base::Sys.time()
[11:01:33.258]             {
[11:01:33.258]                 {
[11:01:33.258]                   {
[11:01:33.258]                     {
[11:01:33.258]                       base::local({
[11:01:33.258]                         has_future <- base::requireNamespace("future", 
[11:01:33.258]                           quietly = TRUE)
[11:01:33.258]                         if (has_future) {
[11:01:33.258]                           ns <- base::getNamespace("future")
[11:01:33.258]                           version <- ns[[".package"]][["version"]]
[11:01:33.258]                           if (is.null(version)) 
[11:01:33.258]                             version <- utils::packageVersion("future")
[11:01:33.258]                         }
[11:01:33.258]                         else {
[11:01:33.258]                           version <- NULL
[11:01:33.258]                         }
[11:01:33.258]                         if (!has_future || version < "1.8.0") {
[11:01:33.258]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.258]                             "", base::R.version$version.string), 
[11:01:33.258]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.258]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.258]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.258]                               "release", "version")], collapse = " "), 
[11:01:33.258]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.258]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.258]                             info)
[11:01:33.258]                           info <- base::paste(info, collapse = "; ")
[11:01:33.258]                           if (!has_future) {
[11:01:33.258]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.258]                               info)
[11:01:33.258]                           }
[11:01:33.258]                           else {
[11:01:33.258]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.258]                               info, version)
[11:01:33.258]                           }
[11:01:33.258]                           base::stop(msg)
[11:01:33.258]                         }
[11:01:33.258]                       })
[11:01:33.258]                     }
[11:01:33.258]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.258]                     base::options(mc.cores = 1L)
[11:01:33.258]                   }
[11:01:33.258]                   ...future.strategy.old <- future::plan("list")
[11:01:33.258]                   options(future.plan = NULL)
[11:01:33.258]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.258]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.258]                 }
[11:01:33.258]                 ...future.workdir <- getwd()
[11:01:33.258]             }
[11:01:33.258]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.258]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.258]         }
[11:01:33.258]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.258]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.258]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.258]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.258]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.258]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.258]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.258]             base::names(...future.oldOptions))
[11:01:33.258]     }
[11:01:33.258]     if (FALSE) {
[11:01:33.258]     }
[11:01:33.258]     else {
[11:01:33.258]         if (TRUE) {
[11:01:33.258]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.258]                 open = "w")
[11:01:33.258]         }
[11:01:33.258]         else {
[11:01:33.258]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.258]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.258]         }
[11:01:33.258]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.258]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.258]             base::sink(type = "output", split = FALSE)
[11:01:33.258]             base::close(...future.stdout)
[11:01:33.258]         }, add = TRUE)
[11:01:33.258]     }
[11:01:33.258]     ...future.frame <- base::sys.nframe()
[11:01:33.258]     ...future.conditions <- base::list()
[11:01:33.258]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.258]     if (FALSE) {
[11:01:33.258]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.258]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.258]     }
[11:01:33.258]     ...future.result <- base::tryCatch({
[11:01:33.258]         base::withCallingHandlers({
[11:01:33.258]             ...future.value <- base::withVisible(base::local({
[11:01:33.258]                 ...future.makeSendCondition <- base::local({
[11:01:33.258]                   sendCondition <- NULL
[11:01:33.258]                   function(frame = 1L) {
[11:01:33.258]                     if (is.function(sendCondition)) 
[11:01:33.258]                       return(sendCondition)
[11:01:33.258]                     ns <- getNamespace("parallel")
[11:01:33.258]                     if (exists("sendData", mode = "function", 
[11:01:33.258]                       envir = ns)) {
[11:01:33.258]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.258]                         envir = ns)
[11:01:33.258]                       envir <- sys.frame(frame)
[11:01:33.258]                       master <- NULL
[11:01:33.258]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.258]                         !identical(envir, emptyenv())) {
[11:01:33.258]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.258]                           inherits = FALSE)) {
[11:01:33.258]                           master <- get("master", mode = "list", 
[11:01:33.258]                             envir = envir, inherits = FALSE)
[11:01:33.258]                           if (inherits(master, c("SOCKnode", 
[11:01:33.258]                             "SOCK0node"))) {
[11:01:33.258]                             sendCondition <<- function(cond) {
[11:01:33.258]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.258]                                 success = TRUE)
[11:01:33.258]                               parallel_sendData(master, data)
[11:01:33.258]                             }
[11:01:33.258]                             return(sendCondition)
[11:01:33.258]                           }
[11:01:33.258]                         }
[11:01:33.258]                         frame <- frame + 1L
[11:01:33.258]                         envir <- sys.frame(frame)
[11:01:33.258]                       }
[11:01:33.258]                     }
[11:01:33.258]                     sendCondition <<- function(cond) NULL
[11:01:33.258]                   }
[11:01:33.258]                 })
[11:01:33.258]                 withCallingHandlers({
[11:01:33.258]                   2
[11:01:33.258]                 }, immediateCondition = function(cond) {
[11:01:33.258]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.258]                   sendCondition(cond)
[11:01:33.258]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.258]                   {
[11:01:33.258]                     inherits <- base::inherits
[11:01:33.258]                     invokeRestart <- base::invokeRestart
[11:01:33.258]                     is.null <- base::is.null
[11:01:33.258]                     muffled <- FALSE
[11:01:33.258]                     if (inherits(cond, "message")) {
[11:01:33.258]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.258]                       if (muffled) 
[11:01:33.258]                         invokeRestart("muffleMessage")
[11:01:33.258]                     }
[11:01:33.258]                     else if (inherits(cond, "warning")) {
[11:01:33.258]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.258]                       if (muffled) 
[11:01:33.258]                         invokeRestart("muffleWarning")
[11:01:33.258]                     }
[11:01:33.258]                     else if (inherits(cond, "condition")) {
[11:01:33.258]                       if (!is.null(pattern)) {
[11:01:33.258]                         computeRestarts <- base::computeRestarts
[11:01:33.258]                         grepl <- base::grepl
[11:01:33.258]                         restarts <- computeRestarts(cond)
[11:01:33.258]                         for (restart in restarts) {
[11:01:33.258]                           name <- restart$name
[11:01:33.258]                           if (is.null(name)) 
[11:01:33.258]                             next
[11:01:33.258]                           if (!grepl(pattern, name)) 
[11:01:33.258]                             next
[11:01:33.258]                           invokeRestart(restart)
[11:01:33.258]                           muffled <- TRUE
[11:01:33.258]                           break
[11:01:33.258]                         }
[11:01:33.258]                       }
[11:01:33.258]                     }
[11:01:33.258]                     invisible(muffled)
[11:01:33.258]                   }
[11:01:33.258]                   muffleCondition(cond)
[11:01:33.258]                 })
[11:01:33.258]             }))
[11:01:33.258]             future::FutureResult(value = ...future.value$value, 
[11:01:33.258]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.258]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.258]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.258]                     ...future.globalenv.names))
[11:01:33.258]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.258]         }, condition = base::local({
[11:01:33.258]             c <- base::c
[11:01:33.258]             inherits <- base::inherits
[11:01:33.258]             invokeRestart <- base::invokeRestart
[11:01:33.258]             length <- base::length
[11:01:33.258]             list <- base::list
[11:01:33.258]             seq.int <- base::seq.int
[11:01:33.258]             signalCondition <- base::signalCondition
[11:01:33.258]             sys.calls <- base::sys.calls
[11:01:33.258]             `[[` <- base::`[[`
[11:01:33.258]             `+` <- base::`+`
[11:01:33.258]             `<<-` <- base::`<<-`
[11:01:33.258]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.258]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.258]                   3L)]
[11:01:33.258]             }
[11:01:33.258]             function(cond) {
[11:01:33.258]                 is_error <- inherits(cond, "error")
[11:01:33.258]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.258]                   NULL)
[11:01:33.258]                 if (is_error) {
[11:01:33.258]                   sessionInformation <- function() {
[11:01:33.258]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.258]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.258]                       search = base::search(), system = base::Sys.info())
[11:01:33.258]                   }
[11:01:33.258]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.258]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.258]                     cond$call), session = sessionInformation(), 
[11:01:33.258]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.258]                   signalCondition(cond)
[11:01:33.258]                 }
[11:01:33.258]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.258]                 "immediateCondition"))) {
[11:01:33.258]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.258]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.258]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.258]                   if (TRUE && !signal) {
[11:01:33.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.258]                     {
[11:01:33.258]                       inherits <- base::inherits
[11:01:33.258]                       invokeRestart <- base::invokeRestart
[11:01:33.258]                       is.null <- base::is.null
[11:01:33.258]                       muffled <- FALSE
[11:01:33.258]                       if (inherits(cond, "message")) {
[11:01:33.258]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.258]                         if (muffled) 
[11:01:33.258]                           invokeRestart("muffleMessage")
[11:01:33.258]                       }
[11:01:33.258]                       else if (inherits(cond, "warning")) {
[11:01:33.258]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.258]                         if (muffled) 
[11:01:33.258]                           invokeRestart("muffleWarning")
[11:01:33.258]                       }
[11:01:33.258]                       else if (inherits(cond, "condition")) {
[11:01:33.258]                         if (!is.null(pattern)) {
[11:01:33.258]                           computeRestarts <- base::computeRestarts
[11:01:33.258]                           grepl <- base::grepl
[11:01:33.258]                           restarts <- computeRestarts(cond)
[11:01:33.258]                           for (restart in restarts) {
[11:01:33.258]                             name <- restart$name
[11:01:33.258]                             if (is.null(name)) 
[11:01:33.258]                               next
[11:01:33.258]                             if (!grepl(pattern, name)) 
[11:01:33.258]                               next
[11:01:33.258]                             invokeRestart(restart)
[11:01:33.258]                             muffled <- TRUE
[11:01:33.258]                             break
[11:01:33.258]                           }
[11:01:33.258]                         }
[11:01:33.258]                       }
[11:01:33.258]                       invisible(muffled)
[11:01:33.258]                     }
[11:01:33.258]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.258]                   }
[11:01:33.258]                 }
[11:01:33.258]                 else {
[11:01:33.258]                   if (TRUE) {
[11:01:33.258]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.258]                     {
[11:01:33.258]                       inherits <- base::inherits
[11:01:33.258]                       invokeRestart <- base::invokeRestart
[11:01:33.258]                       is.null <- base::is.null
[11:01:33.258]                       muffled <- FALSE
[11:01:33.258]                       if (inherits(cond, "message")) {
[11:01:33.258]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.258]                         if (muffled) 
[11:01:33.258]                           invokeRestart("muffleMessage")
[11:01:33.258]                       }
[11:01:33.258]                       else if (inherits(cond, "warning")) {
[11:01:33.258]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.258]                         if (muffled) 
[11:01:33.258]                           invokeRestart("muffleWarning")
[11:01:33.258]                       }
[11:01:33.258]                       else if (inherits(cond, "condition")) {
[11:01:33.258]                         if (!is.null(pattern)) {
[11:01:33.258]                           computeRestarts <- base::computeRestarts
[11:01:33.258]                           grepl <- base::grepl
[11:01:33.258]                           restarts <- computeRestarts(cond)
[11:01:33.258]                           for (restart in restarts) {
[11:01:33.258]                             name <- restart$name
[11:01:33.258]                             if (is.null(name)) 
[11:01:33.258]                               next
[11:01:33.258]                             if (!grepl(pattern, name)) 
[11:01:33.258]                               next
[11:01:33.258]                             invokeRestart(restart)
[11:01:33.258]                             muffled <- TRUE
[11:01:33.258]                             break
[11:01:33.258]                           }
[11:01:33.258]                         }
[11:01:33.258]                       }
[11:01:33.258]                       invisible(muffled)
[11:01:33.258]                     }
[11:01:33.258]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.258]                   }
[11:01:33.258]                 }
[11:01:33.258]             }
[11:01:33.258]         }))
[11:01:33.258]     }, error = function(ex) {
[11:01:33.258]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.258]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.258]                 ...future.rng), started = ...future.startTime, 
[11:01:33.258]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.258]             version = "1.8"), class = "FutureResult")
[11:01:33.258]     }, finally = {
[11:01:33.258]         if (!identical(...future.workdir, getwd())) 
[11:01:33.258]             setwd(...future.workdir)
[11:01:33.258]         {
[11:01:33.258]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.258]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.258]             }
[11:01:33.258]             base::options(...future.oldOptions)
[11:01:33.258]             if (.Platform$OS.type == "windows") {
[11:01:33.258]                 old_names <- names(...future.oldEnvVars)
[11:01:33.258]                 envs <- base::Sys.getenv()
[11:01:33.258]                 names <- names(envs)
[11:01:33.258]                 common <- intersect(names, old_names)
[11:01:33.258]                 added <- setdiff(names, old_names)
[11:01:33.258]                 removed <- setdiff(old_names, names)
[11:01:33.258]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.258]                   envs[common]]
[11:01:33.258]                 NAMES <- toupper(changed)
[11:01:33.258]                 args <- list()
[11:01:33.258]                 for (kk in seq_along(NAMES)) {
[11:01:33.258]                   name <- changed[[kk]]
[11:01:33.258]                   NAME <- NAMES[[kk]]
[11:01:33.258]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.258]                     next
[11:01:33.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.258]                 }
[11:01:33.258]                 NAMES <- toupper(added)
[11:01:33.258]                 for (kk in seq_along(NAMES)) {
[11:01:33.258]                   name <- added[[kk]]
[11:01:33.258]                   NAME <- NAMES[[kk]]
[11:01:33.258]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.258]                     next
[11:01:33.258]                   args[[name]] <- ""
[11:01:33.258]                 }
[11:01:33.258]                 NAMES <- toupper(removed)
[11:01:33.258]                 for (kk in seq_along(NAMES)) {
[11:01:33.258]                   name <- removed[[kk]]
[11:01:33.258]                   NAME <- NAMES[[kk]]
[11:01:33.258]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.258]                     next
[11:01:33.258]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.258]                 }
[11:01:33.258]                 if (length(args) > 0) 
[11:01:33.258]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.258]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.258]             }
[11:01:33.258]             else {
[11:01:33.258]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.258]             }
[11:01:33.258]             {
[11:01:33.258]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.258]                   0L) {
[11:01:33.258]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.258]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.258]                   base::options(opts)
[11:01:33.258]                 }
[11:01:33.258]                 {
[11:01:33.258]                   {
[11:01:33.258]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.258]                     NULL
[11:01:33.258]                   }
[11:01:33.258]                   options(future.plan = NULL)
[11:01:33.258]                   if (is.na(NA_character_)) 
[11:01:33.258]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.258]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.258]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.258]                     .init = FALSE)
[11:01:33.258]                 }
[11:01:33.258]             }
[11:01:33.258]         }
[11:01:33.258]     })
[11:01:33.258]     if (TRUE) {
[11:01:33.258]         base::sink(type = "output", split = FALSE)
[11:01:33.258]         if (TRUE) {
[11:01:33.258]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.258]         }
[11:01:33.258]         else {
[11:01:33.258]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.258]         }
[11:01:33.258]         base::close(...future.stdout)
[11:01:33.258]         ...future.stdout <- NULL
[11:01:33.258]     }
[11:01:33.258]     ...future.result$conditions <- ...future.conditions
[11:01:33.258]     ...future.result$finished <- base::Sys.time()
[11:01:33.258]     ...future.result
[11:01:33.258] }
[11:01:33.261] MultisessionFuture started
[11:01:33.261] - Launch lazy future ... done
[11:01:33.262] run() for ‘MultisessionFuture’ ... done
[11:01:33.262] getGlobalsAndPackages() ...
[11:01:33.262] Searching for globals...
[11:01:33.262] 
[11:01:33.262] Searching for globals ... DONE
[11:01:33.262] - globals: [0] <none>
[11:01:33.262] getGlobalsAndPackages() ... DONE
[11:01:33.263] run() for ‘Future’ ...
[11:01:33.263] - state: ‘created’
[11:01:33.263] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.277] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.277] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.277]   - Field: ‘node’
[11:01:33.277]   - Field: ‘label’
[11:01:33.277]   - Field: ‘local’
[11:01:33.277]   - Field: ‘owner’
[11:01:33.277]   - Field: ‘envir’
[11:01:33.277]   - Field: ‘workers’
[11:01:33.278]   - Field: ‘packages’
[11:01:33.278]   - Field: ‘gc’
[11:01:33.278]   - Field: ‘conditions’
[11:01:33.278]   - Field: ‘persistent’
[11:01:33.278]   - Field: ‘expr’
[11:01:33.278]   - Field: ‘uuid’
[11:01:33.278]   - Field: ‘seed’
[11:01:33.278]   - Field: ‘version’
[11:01:33.278]   - Field: ‘result’
[11:01:33.278]   - Field: ‘asynchronous’
[11:01:33.278]   - Field: ‘calls’
[11:01:33.278]   - Field: ‘globals’
[11:01:33.279]   - Field: ‘stdout’
[11:01:33.279]   - Field: ‘earlySignal’
[11:01:33.279]   - Field: ‘lazy’
[11:01:33.279]   - Field: ‘state’
[11:01:33.279] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.279] - Launch lazy future ...
[11:01:33.279] Packages needed by the future expression (n = 0): <none>
[11:01:33.279] Packages needed by future strategies (n = 0): <none>
[11:01:33.280] {
[11:01:33.280]     {
[11:01:33.280]         {
[11:01:33.280]             ...future.startTime <- base::Sys.time()
[11:01:33.280]             {
[11:01:33.280]                 {
[11:01:33.280]                   {
[11:01:33.280]                     {
[11:01:33.280]                       base::local({
[11:01:33.280]                         has_future <- base::requireNamespace("future", 
[11:01:33.280]                           quietly = TRUE)
[11:01:33.280]                         if (has_future) {
[11:01:33.280]                           ns <- base::getNamespace("future")
[11:01:33.280]                           version <- ns[[".package"]][["version"]]
[11:01:33.280]                           if (is.null(version)) 
[11:01:33.280]                             version <- utils::packageVersion("future")
[11:01:33.280]                         }
[11:01:33.280]                         else {
[11:01:33.280]                           version <- NULL
[11:01:33.280]                         }
[11:01:33.280]                         if (!has_future || version < "1.8.0") {
[11:01:33.280]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.280]                             "", base::R.version$version.string), 
[11:01:33.280]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.280]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.280]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.280]                               "release", "version")], collapse = " "), 
[11:01:33.280]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.280]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.280]                             info)
[11:01:33.280]                           info <- base::paste(info, collapse = "; ")
[11:01:33.280]                           if (!has_future) {
[11:01:33.280]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.280]                               info)
[11:01:33.280]                           }
[11:01:33.280]                           else {
[11:01:33.280]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.280]                               info, version)
[11:01:33.280]                           }
[11:01:33.280]                           base::stop(msg)
[11:01:33.280]                         }
[11:01:33.280]                       })
[11:01:33.280]                     }
[11:01:33.280]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.280]                     base::options(mc.cores = 1L)
[11:01:33.280]                   }
[11:01:33.280]                   ...future.strategy.old <- future::plan("list")
[11:01:33.280]                   options(future.plan = NULL)
[11:01:33.280]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.280]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.280]                 }
[11:01:33.280]                 ...future.workdir <- getwd()
[11:01:33.280]             }
[11:01:33.280]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.280]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.280]         }
[11:01:33.280]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.280]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.280]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.280]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.280]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.280]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.280]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.280]             base::names(...future.oldOptions))
[11:01:33.280]     }
[11:01:33.280]     if (FALSE) {
[11:01:33.280]     }
[11:01:33.280]     else {
[11:01:33.280]         if (TRUE) {
[11:01:33.280]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.280]                 open = "w")
[11:01:33.280]         }
[11:01:33.280]         else {
[11:01:33.280]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.280]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.280]         }
[11:01:33.280]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.280]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.280]             base::sink(type = "output", split = FALSE)
[11:01:33.280]             base::close(...future.stdout)
[11:01:33.280]         }, add = TRUE)
[11:01:33.280]     }
[11:01:33.280]     ...future.frame <- base::sys.nframe()
[11:01:33.280]     ...future.conditions <- base::list()
[11:01:33.280]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.280]     if (FALSE) {
[11:01:33.280]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.280]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.280]     }
[11:01:33.280]     ...future.result <- base::tryCatch({
[11:01:33.280]         base::withCallingHandlers({
[11:01:33.280]             ...future.value <- base::withVisible(base::local({
[11:01:33.280]                 ...future.makeSendCondition <- base::local({
[11:01:33.280]                   sendCondition <- NULL
[11:01:33.280]                   function(frame = 1L) {
[11:01:33.280]                     if (is.function(sendCondition)) 
[11:01:33.280]                       return(sendCondition)
[11:01:33.280]                     ns <- getNamespace("parallel")
[11:01:33.280]                     if (exists("sendData", mode = "function", 
[11:01:33.280]                       envir = ns)) {
[11:01:33.280]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.280]                         envir = ns)
[11:01:33.280]                       envir <- sys.frame(frame)
[11:01:33.280]                       master <- NULL
[11:01:33.280]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.280]                         !identical(envir, emptyenv())) {
[11:01:33.280]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.280]                           inherits = FALSE)) {
[11:01:33.280]                           master <- get("master", mode = "list", 
[11:01:33.280]                             envir = envir, inherits = FALSE)
[11:01:33.280]                           if (inherits(master, c("SOCKnode", 
[11:01:33.280]                             "SOCK0node"))) {
[11:01:33.280]                             sendCondition <<- function(cond) {
[11:01:33.280]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.280]                                 success = TRUE)
[11:01:33.280]                               parallel_sendData(master, data)
[11:01:33.280]                             }
[11:01:33.280]                             return(sendCondition)
[11:01:33.280]                           }
[11:01:33.280]                         }
[11:01:33.280]                         frame <- frame + 1L
[11:01:33.280]                         envir <- sys.frame(frame)
[11:01:33.280]                       }
[11:01:33.280]                     }
[11:01:33.280]                     sendCondition <<- function(cond) NULL
[11:01:33.280]                   }
[11:01:33.280]                 })
[11:01:33.280]                 withCallingHandlers({
[11:01:33.280]                   NULL
[11:01:33.280]                 }, immediateCondition = function(cond) {
[11:01:33.280]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.280]                   sendCondition(cond)
[11:01:33.280]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.280]                   {
[11:01:33.280]                     inherits <- base::inherits
[11:01:33.280]                     invokeRestart <- base::invokeRestart
[11:01:33.280]                     is.null <- base::is.null
[11:01:33.280]                     muffled <- FALSE
[11:01:33.280]                     if (inherits(cond, "message")) {
[11:01:33.280]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.280]                       if (muffled) 
[11:01:33.280]                         invokeRestart("muffleMessage")
[11:01:33.280]                     }
[11:01:33.280]                     else if (inherits(cond, "warning")) {
[11:01:33.280]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.280]                       if (muffled) 
[11:01:33.280]                         invokeRestart("muffleWarning")
[11:01:33.280]                     }
[11:01:33.280]                     else if (inherits(cond, "condition")) {
[11:01:33.280]                       if (!is.null(pattern)) {
[11:01:33.280]                         computeRestarts <- base::computeRestarts
[11:01:33.280]                         grepl <- base::grepl
[11:01:33.280]                         restarts <- computeRestarts(cond)
[11:01:33.280]                         for (restart in restarts) {
[11:01:33.280]                           name <- restart$name
[11:01:33.280]                           if (is.null(name)) 
[11:01:33.280]                             next
[11:01:33.280]                           if (!grepl(pattern, name)) 
[11:01:33.280]                             next
[11:01:33.280]                           invokeRestart(restart)
[11:01:33.280]                           muffled <- TRUE
[11:01:33.280]                           break
[11:01:33.280]                         }
[11:01:33.280]                       }
[11:01:33.280]                     }
[11:01:33.280]                     invisible(muffled)
[11:01:33.280]                   }
[11:01:33.280]                   muffleCondition(cond)
[11:01:33.280]                 })
[11:01:33.280]             }))
[11:01:33.280]             future::FutureResult(value = ...future.value$value, 
[11:01:33.280]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.280]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.280]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.280]                     ...future.globalenv.names))
[11:01:33.280]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.280]         }, condition = base::local({
[11:01:33.280]             c <- base::c
[11:01:33.280]             inherits <- base::inherits
[11:01:33.280]             invokeRestart <- base::invokeRestart
[11:01:33.280]             length <- base::length
[11:01:33.280]             list <- base::list
[11:01:33.280]             seq.int <- base::seq.int
[11:01:33.280]             signalCondition <- base::signalCondition
[11:01:33.280]             sys.calls <- base::sys.calls
[11:01:33.280]             `[[` <- base::`[[`
[11:01:33.280]             `+` <- base::`+`
[11:01:33.280]             `<<-` <- base::`<<-`
[11:01:33.280]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.280]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.280]                   3L)]
[11:01:33.280]             }
[11:01:33.280]             function(cond) {
[11:01:33.280]                 is_error <- inherits(cond, "error")
[11:01:33.280]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.280]                   NULL)
[11:01:33.280]                 if (is_error) {
[11:01:33.280]                   sessionInformation <- function() {
[11:01:33.280]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.280]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.280]                       search = base::search(), system = base::Sys.info())
[11:01:33.280]                   }
[11:01:33.280]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.280]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.280]                     cond$call), session = sessionInformation(), 
[11:01:33.280]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.280]                   signalCondition(cond)
[11:01:33.280]                 }
[11:01:33.280]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.280]                 "immediateCondition"))) {
[11:01:33.280]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.280]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.280]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.280]                   if (TRUE && !signal) {
[11:01:33.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.280]                     {
[11:01:33.280]                       inherits <- base::inherits
[11:01:33.280]                       invokeRestart <- base::invokeRestart
[11:01:33.280]                       is.null <- base::is.null
[11:01:33.280]                       muffled <- FALSE
[11:01:33.280]                       if (inherits(cond, "message")) {
[11:01:33.280]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.280]                         if (muffled) 
[11:01:33.280]                           invokeRestart("muffleMessage")
[11:01:33.280]                       }
[11:01:33.280]                       else if (inherits(cond, "warning")) {
[11:01:33.280]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.280]                         if (muffled) 
[11:01:33.280]                           invokeRestart("muffleWarning")
[11:01:33.280]                       }
[11:01:33.280]                       else if (inherits(cond, "condition")) {
[11:01:33.280]                         if (!is.null(pattern)) {
[11:01:33.280]                           computeRestarts <- base::computeRestarts
[11:01:33.280]                           grepl <- base::grepl
[11:01:33.280]                           restarts <- computeRestarts(cond)
[11:01:33.280]                           for (restart in restarts) {
[11:01:33.280]                             name <- restart$name
[11:01:33.280]                             if (is.null(name)) 
[11:01:33.280]                               next
[11:01:33.280]                             if (!grepl(pattern, name)) 
[11:01:33.280]                               next
[11:01:33.280]                             invokeRestart(restart)
[11:01:33.280]                             muffled <- TRUE
[11:01:33.280]                             break
[11:01:33.280]                           }
[11:01:33.280]                         }
[11:01:33.280]                       }
[11:01:33.280]                       invisible(muffled)
[11:01:33.280]                     }
[11:01:33.280]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.280]                   }
[11:01:33.280]                 }
[11:01:33.280]                 else {
[11:01:33.280]                   if (TRUE) {
[11:01:33.280]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.280]                     {
[11:01:33.280]                       inherits <- base::inherits
[11:01:33.280]                       invokeRestart <- base::invokeRestart
[11:01:33.280]                       is.null <- base::is.null
[11:01:33.280]                       muffled <- FALSE
[11:01:33.280]                       if (inherits(cond, "message")) {
[11:01:33.280]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.280]                         if (muffled) 
[11:01:33.280]                           invokeRestart("muffleMessage")
[11:01:33.280]                       }
[11:01:33.280]                       else if (inherits(cond, "warning")) {
[11:01:33.280]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.280]                         if (muffled) 
[11:01:33.280]                           invokeRestart("muffleWarning")
[11:01:33.280]                       }
[11:01:33.280]                       else if (inherits(cond, "condition")) {
[11:01:33.280]                         if (!is.null(pattern)) {
[11:01:33.280]                           computeRestarts <- base::computeRestarts
[11:01:33.280]                           grepl <- base::grepl
[11:01:33.280]                           restarts <- computeRestarts(cond)
[11:01:33.280]                           for (restart in restarts) {
[11:01:33.280]                             name <- restart$name
[11:01:33.280]                             if (is.null(name)) 
[11:01:33.280]                               next
[11:01:33.280]                             if (!grepl(pattern, name)) 
[11:01:33.280]                               next
[11:01:33.280]                             invokeRestart(restart)
[11:01:33.280]                             muffled <- TRUE
[11:01:33.280]                             break
[11:01:33.280]                           }
[11:01:33.280]                         }
[11:01:33.280]                       }
[11:01:33.280]                       invisible(muffled)
[11:01:33.280]                     }
[11:01:33.280]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.280]                   }
[11:01:33.280]                 }
[11:01:33.280]             }
[11:01:33.280]         }))
[11:01:33.280]     }, error = function(ex) {
[11:01:33.280]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.280]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.280]                 ...future.rng), started = ...future.startTime, 
[11:01:33.280]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.280]             version = "1.8"), class = "FutureResult")
[11:01:33.280]     }, finally = {
[11:01:33.280]         if (!identical(...future.workdir, getwd())) 
[11:01:33.280]             setwd(...future.workdir)
[11:01:33.280]         {
[11:01:33.280]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.280]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.280]             }
[11:01:33.280]             base::options(...future.oldOptions)
[11:01:33.280]             if (.Platform$OS.type == "windows") {
[11:01:33.280]                 old_names <- names(...future.oldEnvVars)
[11:01:33.280]                 envs <- base::Sys.getenv()
[11:01:33.280]                 names <- names(envs)
[11:01:33.280]                 common <- intersect(names, old_names)
[11:01:33.280]                 added <- setdiff(names, old_names)
[11:01:33.280]                 removed <- setdiff(old_names, names)
[11:01:33.280]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.280]                   envs[common]]
[11:01:33.280]                 NAMES <- toupper(changed)
[11:01:33.280]                 args <- list()
[11:01:33.280]                 for (kk in seq_along(NAMES)) {
[11:01:33.280]                   name <- changed[[kk]]
[11:01:33.280]                   NAME <- NAMES[[kk]]
[11:01:33.280]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.280]                     next
[11:01:33.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.280]                 }
[11:01:33.280]                 NAMES <- toupper(added)
[11:01:33.280]                 for (kk in seq_along(NAMES)) {
[11:01:33.280]                   name <- added[[kk]]
[11:01:33.280]                   NAME <- NAMES[[kk]]
[11:01:33.280]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.280]                     next
[11:01:33.280]                   args[[name]] <- ""
[11:01:33.280]                 }
[11:01:33.280]                 NAMES <- toupper(removed)
[11:01:33.280]                 for (kk in seq_along(NAMES)) {
[11:01:33.280]                   name <- removed[[kk]]
[11:01:33.280]                   NAME <- NAMES[[kk]]
[11:01:33.280]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.280]                     next
[11:01:33.280]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.280]                 }
[11:01:33.280]                 if (length(args) > 0) 
[11:01:33.280]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.280]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.280]             }
[11:01:33.280]             else {
[11:01:33.280]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.280]             }
[11:01:33.280]             {
[11:01:33.280]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.280]                   0L) {
[11:01:33.280]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.280]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.280]                   base::options(opts)
[11:01:33.280]                 }
[11:01:33.280]                 {
[11:01:33.280]                   {
[11:01:33.280]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.280]                     NULL
[11:01:33.280]                   }
[11:01:33.280]                   options(future.plan = NULL)
[11:01:33.280]                   if (is.na(NA_character_)) 
[11:01:33.280]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.280]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.280]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.280]                     .init = FALSE)
[11:01:33.280]                 }
[11:01:33.280]             }
[11:01:33.280]         }
[11:01:33.280]     })
[11:01:33.280]     if (TRUE) {
[11:01:33.280]         base::sink(type = "output", split = FALSE)
[11:01:33.280]         if (TRUE) {
[11:01:33.280]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.280]         }
[11:01:33.280]         else {
[11:01:33.280]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.280]         }
[11:01:33.280]         base::close(...future.stdout)
[11:01:33.280]         ...future.stdout <- NULL
[11:01:33.280]     }
[11:01:33.280]     ...future.result$conditions <- ...future.conditions
[11:01:33.280]     ...future.result$finished <- base::Sys.time()
[11:01:33.280]     ...future.result
[11:01:33.280] }
[11:01:33.283] MultisessionFuture started
[11:01:33.283] - Launch lazy future ... done
[11:01:33.283] run() for ‘MultisessionFuture’ ... done
[11:01:33.283] getGlobalsAndPackages() ...
[11:01:33.283] Searching for globals...
[11:01:33.284] - globals found: [1] ‘{’
[11:01:33.284] Searching for globals ... DONE
[11:01:33.284] Resolving globals: FALSE
[11:01:33.284] 
[11:01:33.285] 
[11:01:33.285] getGlobalsAndPackages() ... DONE
[11:01:33.285] run() for ‘Future’ ...
[11:01:33.285] - state: ‘created’
[11:01:33.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.299] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.299]   - Field: ‘node’
[11:01:33.299]   - Field: ‘label’
[11:01:33.299]   - Field: ‘local’
[11:01:33.299]   - Field: ‘owner’
[11:01:33.299]   - Field: ‘envir’
[11:01:33.299]   - Field: ‘workers’
[11:01:33.299]   - Field: ‘packages’
[11:01:33.300]   - Field: ‘gc’
[11:01:33.300]   - Field: ‘conditions’
[11:01:33.300]   - Field: ‘persistent’
[11:01:33.300]   - Field: ‘expr’
[11:01:33.300]   - Field: ‘uuid’
[11:01:33.300]   - Field: ‘seed’
[11:01:33.300]   - Field: ‘version’
[11:01:33.300]   - Field: ‘result’
[11:01:33.300]   - Field: ‘asynchronous’
[11:01:33.300]   - Field: ‘calls’
[11:01:33.300]   - Field: ‘globals’
[11:01:33.301]   - Field: ‘stdout’
[11:01:33.301]   - Field: ‘earlySignal’
[11:01:33.301]   - Field: ‘lazy’
[11:01:33.301]   - Field: ‘state’
[11:01:33.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.301] - Launch lazy future ...
[11:01:33.301] Packages needed by the future expression (n = 0): <none>
[11:01:33.301] Packages needed by future strategies (n = 0): <none>
[11:01:33.302] {
[11:01:33.302]     {
[11:01:33.302]         {
[11:01:33.302]             ...future.startTime <- base::Sys.time()
[11:01:33.302]             {
[11:01:33.302]                 {
[11:01:33.302]                   {
[11:01:33.302]                     {
[11:01:33.302]                       base::local({
[11:01:33.302]                         has_future <- base::requireNamespace("future", 
[11:01:33.302]                           quietly = TRUE)
[11:01:33.302]                         if (has_future) {
[11:01:33.302]                           ns <- base::getNamespace("future")
[11:01:33.302]                           version <- ns[[".package"]][["version"]]
[11:01:33.302]                           if (is.null(version)) 
[11:01:33.302]                             version <- utils::packageVersion("future")
[11:01:33.302]                         }
[11:01:33.302]                         else {
[11:01:33.302]                           version <- NULL
[11:01:33.302]                         }
[11:01:33.302]                         if (!has_future || version < "1.8.0") {
[11:01:33.302]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.302]                             "", base::R.version$version.string), 
[11:01:33.302]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.302]                               "release", "version")], collapse = " "), 
[11:01:33.302]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.302]                             info)
[11:01:33.302]                           info <- base::paste(info, collapse = "; ")
[11:01:33.302]                           if (!has_future) {
[11:01:33.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.302]                               info)
[11:01:33.302]                           }
[11:01:33.302]                           else {
[11:01:33.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.302]                               info, version)
[11:01:33.302]                           }
[11:01:33.302]                           base::stop(msg)
[11:01:33.302]                         }
[11:01:33.302]                       })
[11:01:33.302]                     }
[11:01:33.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.302]                     base::options(mc.cores = 1L)
[11:01:33.302]                   }
[11:01:33.302]                   ...future.strategy.old <- future::plan("list")
[11:01:33.302]                   options(future.plan = NULL)
[11:01:33.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.302]                 }
[11:01:33.302]                 ...future.workdir <- getwd()
[11:01:33.302]             }
[11:01:33.302]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.302]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.302]         }
[11:01:33.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.302]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.302]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.302]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.302]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.302]             base::names(...future.oldOptions))
[11:01:33.302]     }
[11:01:33.302]     if (FALSE) {
[11:01:33.302]     }
[11:01:33.302]     else {
[11:01:33.302]         if (TRUE) {
[11:01:33.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.302]                 open = "w")
[11:01:33.302]         }
[11:01:33.302]         else {
[11:01:33.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.302]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.302]         }
[11:01:33.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.302]             base::sink(type = "output", split = FALSE)
[11:01:33.302]             base::close(...future.stdout)
[11:01:33.302]         }, add = TRUE)
[11:01:33.302]     }
[11:01:33.302]     ...future.frame <- base::sys.nframe()
[11:01:33.302]     ...future.conditions <- base::list()
[11:01:33.302]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.302]     if (FALSE) {
[11:01:33.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.302]     }
[11:01:33.302]     ...future.result <- base::tryCatch({
[11:01:33.302]         base::withCallingHandlers({
[11:01:33.302]             ...future.value <- base::withVisible(base::local({
[11:01:33.302]                 ...future.makeSendCondition <- base::local({
[11:01:33.302]                   sendCondition <- NULL
[11:01:33.302]                   function(frame = 1L) {
[11:01:33.302]                     if (is.function(sendCondition)) 
[11:01:33.302]                       return(sendCondition)
[11:01:33.302]                     ns <- getNamespace("parallel")
[11:01:33.302]                     if (exists("sendData", mode = "function", 
[11:01:33.302]                       envir = ns)) {
[11:01:33.302]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.302]                         envir = ns)
[11:01:33.302]                       envir <- sys.frame(frame)
[11:01:33.302]                       master <- NULL
[11:01:33.302]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.302]                         !identical(envir, emptyenv())) {
[11:01:33.302]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.302]                           inherits = FALSE)) {
[11:01:33.302]                           master <- get("master", mode = "list", 
[11:01:33.302]                             envir = envir, inherits = FALSE)
[11:01:33.302]                           if (inherits(master, c("SOCKnode", 
[11:01:33.302]                             "SOCK0node"))) {
[11:01:33.302]                             sendCondition <<- function(cond) {
[11:01:33.302]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.302]                                 success = TRUE)
[11:01:33.302]                               parallel_sendData(master, data)
[11:01:33.302]                             }
[11:01:33.302]                             return(sendCondition)
[11:01:33.302]                           }
[11:01:33.302]                         }
[11:01:33.302]                         frame <- frame + 1L
[11:01:33.302]                         envir <- sys.frame(frame)
[11:01:33.302]                       }
[11:01:33.302]                     }
[11:01:33.302]                     sendCondition <<- function(cond) NULL
[11:01:33.302]                   }
[11:01:33.302]                 })
[11:01:33.302]                 withCallingHandlers({
[11:01:33.302]                   {
[11:01:33.302]                     4
[11:01:33.302]                   }
[11:01:33.302]                 }, immediateCondition = function(cond) {
[11:01:33.302]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.302]                   sendCondition(cond)
[11:01:33.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.302]                   {
[11:01:33.302]                     inherits <- base::inherits
[11:01:33.302]                     invokeRestart <- base::invokeRestart
[11:01:33.302]                     is.null <- base::is.null
[11:01:33.302]                     muffled <- FALSE
[11:01:33.302]                     if (inherits(cond, "message")) {
[11:01:33.302]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.302]                       if (muffled) 
[11:01:33.302]                         invokeRestart("muffleMessage")
[11:01:33.302]                     }
[11:01:33.302]                     else if (inherits(cond, "warning")) {
[11:01:33.302]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.302]                       if (muffled) 
[11:01:33.302]                         invokeRestart("muffleWarning")
[11:01:33.302]                     }
[11:01:33.302]                     else if (inherits(cond, "condition")) {
[11:01:33.302]                       if (!is.null(pattern)) {
[11:01:33.302]                         computeRestarts <- base::computeRestarts
[11:01:33.302]                         grepl <- base::grepl
[11:01:33.302]                         restarts <- computeRestarts(cond)
[11:01:33.302]                         for (restart in restarts) {
[11:01:33.302]                           name <- restart$name
[11:01:33.302]                           if (is.null(name)) 
[11:01:33.302]                             next
[11:01:33.302]                           if (!grepl(pattern, name)) 
[11:01:33.302]                             next
[11:01:33.302]                           invokeRestart(restart)
[11:01:33.302]                           muffled <- TRUE
[11:01:33.302]                           break
[11:01:33.302]                         }
[11:01:33.302]                       }
[11:01:33.302]                     }
[11:01:33.302]                     invisible(muffled)
[11:01:33.302]                   }
[11:01:33.302]                   muffleCondition(cond)
[11:01:33.302]                 })
[11:01:33.302]             }))
[11:01:33.302]             future::FutureResult(value = ...future.value$value, 
[11:01:33.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.302]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.302]                     ...future.globalenv.names))
[11:01:33.302]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.302]         }, condition = base::local({
[11:01:33.302]             c <- base::c
[11:01:33.302]             inherits <- base::inherits
[11:01:33.302]             invokeRestart <- base::invokeRestart
[11:01:33.302]             length <- base::length
[11:01:33.302]             list <- base::list
[11:01:33.302]             seq.int <- base::seq.int
[11:01:33.302]             signalCondition <- base::signalCondition
[11:01:33.302]             sys.calls <- base::sys.calls
[11:01:33.302]             `[[` <- base::`[[`
[11:01:33.302]             `+` <- base::`+`
[11:01:33.302]             `<<-` <- base::`<<-`
[11:01:33.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.302]                   3L)]
[11:01:33.302]             }
[11:01:33.302]             function(cond) {
[11:01:33.302]                 is_error <- inherits(cond, "error")
[11:01:33.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.302]                   NULL)
[11:01:33.302]                 if (is_error) {
[11:01:33.302]                   sessionInformation <- function() {
[11:01:33.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.302]                       search = base::search(), system = base::Sys.info())
[11:01:33.302]                   }
[11:01:33.302]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.302]                     cond$call), session = sessionInformation(), 
[11:01:33.302]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.302]                   signalCondition(cond)
[11:01:33.302]                 }
[11:01:33.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.302]                 "immediateCondition"))) {
[11:01:33.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.302]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.302]                   if (TRUE && !signal) {
[11:01:33.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.302]                     {
[11:01:33.302]                       inherits <- base::inherits
[11:01:33.302]                       invokeRestart <- base::invokeRestart
[11:01:33.302]                       is.null <- base::is.null
[11:01:33.302]                       muffled <- FALSE
[11:01:33.302]                       if (inherits(cond, "message")) {
[11:01:33.302]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.302]                         if (muffled) 
[11:01:33.302]                           invokeRestart("muffleMessage")
[11:01:33.302]                       }
[11:01:33.302]                       else if (inherits(cond, "warning")) {
[11:01:33.302]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.302]                         if (muffled) 
[11:01:33.302]                           invokeRestart("muffleWarning")
[11:01:33.302]                       }
[11:01:33.302]                       else if (inherits(cond, "condition")) {
[11:01:33.302]                         if (!is.null(pattern)) {
[11:01:33.302]                           computeRestarts <- base::computeRestarts
[11:01:33.302]                           grepl <- base::grepl
[11:01:33.302]                           restarts <- computeRestarts(cond)
[11:01:33.302]                           for (restart in restarts) {
[11:01:33.302]                             name <- restart$name
[11:01:33.302]                             if (is.null(name)) 
[11:01:33.302]                               next
[11:01:33.302]                             if (!grepl(pattern, name)) 
[11:01:33.302]                               next
[11:01:33.302]                             invokeRestart(restart)
[11:01:33.302]                             muffled <- TRUE
[11:01:33.302]                             break
[11:01:33.302]                           }
[11:01:33.302]                         }
[11:01:33.302]                       }
[11:01:33.302]                       invisible(muffled)
[11:01:33.302]                     }
[11:01:33.302]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.302]                   }
[11:01:33.302]                 }
[11:01:33.302]                 else {
[11:01:33.302]                   if (TRUE) {
[11:01:33.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.302]                     {
[11:01:33.302]                       inherits <- base::inherits
[11:01:33.302]                       invokeRestart <- base::invokeRestart
[11:01:33.302]                       is.null <- base::is.null
[11:01:33.302]                       muffled <- FALSE
[11:01:33.302]                       if (inherits(cond, "message")) {
[11:01:33.302]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.302]                         if (muffled) 
[11:01:33.302]                           invokeRestart("muffleMessage")
[11:01:33.302]                       }
[11:01:33.302]                       else if (inherits(cond, "warning")) {
[11:01:33.302]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.302]                         if (muffled) 
[11:01:33.302]                           invokeRestart("muffleWarning")
[11:01:33.302]                       }
[11:01:33.302]                       else if (inherits(cond, "condition")) {
[11:01:33.302]                         if (!is.null(pattern)) {
[11:01:33.302]                           computeRestarts <- base::computeRestarts
[11:01:33.302]                           grepl <- base::grepl
[11:01:33.302]                           restarts <- computeRestarts(cond)
[11:01:33.302]                           for (restart in restarts) {
[11:01:33.302]                             name <- restart$name
[11:01:33.302]                             if (is.null(name)) 
[11:01:33.302]                               next
[11:01:33.302]                             if (!grepl(pattern, name)) 
[11:01:33.302]                               next
[11:01:33.302]                             invokeRestart(restart)
[11:01:33.302]                             muffled <- TRUE
[11:01:33.302]                             break
[11:01:33.302]                           }
[11:01:33.302]                         }
[11:01:33.302]                       }
[11:01:33.302]                       invisible(muffled)
[11:01:33.302]                     }
[11:01:33.302]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.302]                   }
[11:01:33.302]                 }
[11:01:33.302]             }
[11:01:33.302]         }))
[11:01:33.302]     }, error = function(ex) {
[11:01:33.302]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.302]                 ...future.rng), started = ...future.startTime, 
[11:01:33.302]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.302]             version = "1.8"), class = "FutureResult")
[11:01:33.302]     }, finally = {
[11:01:33.302]         if (!identical(...future.workdir, getwd())) 
[11:01:33.302]             setwd(...future.workdir)
[11:01:33.302]         {
[11:01:33.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.302]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.302]             }
[11:01:33.302]             base::options(...future.oldOptions)
[11:01:33.302]             if (.Platform$OS.type == "windows") {
[11:01:33.302]                 old_names <- names(...future.oldEnvVars)
[11:01:33.302]                 envs <- base::Sys.getenv()
[11:01:33.302]                 names <- names(envs)
[11:01:33.302]                 common <- intersect(names, old_names)
[11:01:33.302]                 added <- setdiff(names, old_names)
[11:01:33.302]                 removed <- setdiff(old_names, names)
[11:01:33.302]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.302]                   envs[common]]
[11:01:33.302]                 NAMES <- toupper(changed)
[11:01:33.302]                 args <- list()
[11:01:33.302]                 for (kk in seq_along(NAMES)) {
[11:01:33.302]                   name <- changed[[kk]]
[11:01:33.302]                   NAME <- NAMES[[kk]]
[11:01:33.302]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.302]                     next
[11:01:33.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.302]                 }
[11:01:33.302]                 NAMES <- toupper(added)
[11:01:33.302]                 for (kk in seq_along(NAMES)) {
[11:01:33.302]                   name <- added[[kk]]
[11:01:33.302]                   NAME <- NAMES[[kk]]
[11:01:33.302]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.302]                     next
[11:01:33.302]                   args[[name]] <- ""
[11:01:33.302]                 }
[11:01:33.302]                 NAMES <- toupper(removed)
[11:01:33.302]                 for (kk in seq_along(NAMES)) {
[11:01:33.302]                   name <- removed[[kk]]
[11:01:33.302]                   NAME <- NAMES[[kk]]
[11:01:33.302]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.302]                     next
[11:01:33.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.302]                 }
[11:01:33.302]                 if (length(args) > 0) 
[11:01:33.302]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.302]             }
[11:01:33.302]             else {
[11:01:33.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.302]             }
[11:01:33.302]             {
[11:01:33.302]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.302]                   0L) {
[11:01:33.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.302]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.302]                   base::options(opts)
[11:01:33.302]                 }
[11:01:33.302]                 {
[11:01:33.302]                   {
[11:01:33.302]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.302]                     NULL
[11:01:33.302]                   }
[11:01:33.302]                   options(future.plan = NULL)
[11:01:33.302]                   if (is.na(NA_character_)) 
[11:01:33.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.302]                     .init = FALSE)
[11:01:33.302]                 }
[11:01:33.302]             }
[11:01:33.302]         }
[11:01:33.302]     })
[11:01:33.302]     if (TRUE) {
[11:01:33.302]         base::sink(type = "output", split = FALSE)
[11:01:33.302]         if (TRUE) {
[11:01:33.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.302]         }
[11:01:33.302]         else {
[11:01:33.302]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.302]         }
[11:01:33.302]         base::close(...future.stdout)
[11:01:33.302]         ...future.stdout <- NULL
[11:01:33.302]     }
[11:01:33.302]     ...future.result$conditions <- ...future.conditions
[11:01:33.302]     ...future.result$finished <- base::Sys.time()
[11:01:33.302]     ...future.result
[11:01:33.302] }
[11:01:33.304] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:33.315] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.315] - Validating connection of MultisessionFuture
[11:01:33.315] - received message: FutureResult
[11:01:33.315] - Received FutureResult
[11:01:33.315] - Erased future from FutureRegistry
[11:01:33.315] result() for ClusterFuture ...
[11:01:33.315] - result already collected: FutureResult
[11:01:33.315] result() for ClusterFuture ... done
[11:01:33.316] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.316] result() for ClusterFuture ...
[11:01:33.316] - result already collected: FutureResult
[11:01:33.316] result() for ClusterFuture ... done
[11:01:33.316] result() for ClusterFuture ...
[11:01:33.316] - result already collected: FutureResult
[11:01:33.316] result() for ClusterFuture ... done
[11:01:33.317] MultisessionFuture started
[11:01:33.317] - Launch lazy future ... done
[11:01:33.317] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c8dec028> 
Classes 'listenv', 'environment' <environment: 0x55a9c7a35fb0> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
[11:01:33.325] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.325] - Validating connection of MultisessionFuture
[11:01:33.325] - received message: FutureResult
[11:01:33.326] - Received FutureResult
[11:01:33.326] - Erased future from FutureRegistry
[11:01:33.326] result() for ClusterFuture ...
[11:01:33.326] - result already collected: FutureResult
[11:01:33.326] result() for ClusterFuture ... done
[11:01:33.326] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1, 1:6] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:33.339] resolve() on list environment ...
[11:01:33.339]  recursive: 0
[11:01:33.340]  length: 6
[11:01:33.340]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:33.340] signalConditionsASAP(numeric, pos=1) ...
[11:01:33.340] - nx: 6
[11:01:33.340] - relay: TRUE
[11:01:33.340] - stdout: TRUE
[11:01:33.341] - signal: TRUE
[11:01:33.341] - resignal: FALSE
[11:01:33.341] - force: TRUE
[11:01:33.341] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.341] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.341]  - until=2
[11:01:33.341]  - relaying element #2
[11:01:33.341] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.341] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.341] signalConditionsASAP(NULL, pos=1) ... done
[11:01:33.341]  length: 5 (resolved future 1)
[11:01:33.342] Future #2
[11:01:33.342] result() for ClusterFuture ...
[11:01:33.342] - result already collected: FutureResult
[11:01:33.342] result() for ClusterFuture ... done
[11:01:33.342] result() for ClusterFuture ...
[11:01:33.342] - result already collected: FutureResult
[11:01:33.342] result() for ClusterFuture ... done
[11:01:33.342] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:33.342] - nx: 6
[11:01:33.342] - relay: TRUE
[11:01:33.342] - stdout: TRUE
[11:01:33.342] - signal: TRUE
[11:01:33.342] - resignal: FALSE
[11:01:33.343] - force: TRUE
[11:01:33.343] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.343] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.343]  - until=2
[11:01:33.343]  - relaying element #2
[11:01:33.343] result() for ClusterFuture ...
[11:01:33.343] - result already collected: FutureResult
[11:01:33.343] result() for ClusterFuture ... done
[11:01:33.343] result() for ClusterFuture ...
[11:01:33.343] - result already collected: FutureResult
[11:01:33.343] result() for ClusterFuture ... done
[11:01:33.343] result() for ClusterFuture ...
[11:01:33.344] - result already collected: FutureResult
[11:01:33.344] result() for ClusterFuture ... done
[11:01:33.344] result() for ClusterFuture ...
[11:01:33.344] - result already collected: FutureResult
[11:01:33.344] result() for ClusterFuture ... done
[11:01:33.344] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.344] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.344] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:33.344]  length: 4 (resolved future 2)
[11:01:33.344] Future #3
[11:01:33.344] result() for ClusterFuture ...
[11:01:33.345] - result already collected: FutureResult
[11:01:33.345] result() for ClusterFuture ... done
[11:01:33.345] result() for ClusterFuture ...
[11:01:33.345] - result already collected: FutureResult
[11:01:33.345] result() for ClusterFuture ... done
[11:01:33.345] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:33.345] - nx: 6
[11:01:33.345] - relay: TRUE
[11:01:33.345] - stdout: TRUE
[11:01:33.345] - signal: TRUE
[11:01:33.345] - resignal: FALSE
[11:01:33.345] - force: TRUE
[11:01:33.346] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.346] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.346]  - until=3
[11:01:33.346]  - relaying element #3
[11:01:33.346] result() for ClusterFuture ...
[11:01:33.346] - result already collected: FutureResult
[11:01:33.346] result() for ClusterFuture ... done
[11:01:33.346] result() for ClusterFuture ...
[11:01:33.346] - result already collected: FutureResult
[11:01:33.346] result() for ClusterFuture ... done
[11:01:33.346] result() for ClusterFuture ...
[11:01:33.347] - result already collected: FutureResult
[11:01:33.347] result() for ClusterFuture ... done
[11:01:33.347] result() for ClusterFuture ...
[11:01:33.347] - result already collected: FutureResult
[11:01:33.347] result() for ClusterFuture ... done
[11:01:33.347] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.347] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.347] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:33.347]  length: 3 (resolved future 3)
[11:01:33.358] signalConditionsASAP(NULL, pos=5) ...
[11:01:33.358] - nx: 6
[11:01:33.358] - relay: TRUE
[11:01:33.358] - stdout: TRUE
[11:01:33.358] - signal: TRUE
[11:01:33.358] - resignal: FALSE
[11:01:33.358] - force: TRUE
[11:01:33.358] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.358] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.359]  - until=6
[11:01:33.359]  - relaying element #4
[11:01:33.359]  - relaying element #6
[11:01:33.359] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.359] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.359] signalConditionsASAP(NULL, pos=5) ... done
[11:01:33.359]  length: 2 (resolved future 5)
[11:01:33.359] signalConditionsASAP(numeric, pos=6) ...
[11:01:33.359] - nx: 6
[11:01:33.359] - relay: TRUE
[11:01:33.359] - stdout: TRUE
[11:01:33.359] - signal: TRUE
[11:01:33.360] - resignal: FALSE
[11:01:33.360] - force: TRUE
[11:01:33.360] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.360] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.360]  - until=6
[11:01:33.360]  - relaying element #4
[11:01:33.360] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.360] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.360] signalConditionsASAP(NULL, pos=6) ... done
[11:01:33.360]  length: 1 (resolved future 6)
[11:01:33.371] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.371] - Validating connection of MultisessionFuture
[11:01:33.371] - received message: FutureResult
[11:01:33.371] - Received FutureResult
[11:01:33.371] - Erased future from FutureRegistry
[11:01:33.372] result() for ClusterFuture ...
[11:01:33.372] - result already collected: FutureResult
[11:01:33.372] result() for ClusterFuture ... done
[11:01:33.372] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.372] Future #4
[11:01:33.372] result() for ClusterFuture ...
[11:01:33.372] - result already collected: FutureResult
[11:01:33.372] result() for ClusterFuture ... done
[11:01:33.372] result() for ClusterFuture ...
[11:01:33.372] - result already collected: FutureResult
[11:01:33.372] result() for ClusterFuture ... done
[11:01:33.373] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:33.373] - nx: 6
[11:01:33.373] - relay: TRUE
[11:01:33.373] - stdout: TRUE
[11:01:33.373] - signal: TRUE
[11:01:33.373] - resignal: FALSE
[11:01:33.373] - force: TRUE
[11:01:33.373] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.373] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.373]  - until=6
[11:01:33.373]  - relaying element #4
[11:01:33.373] result() for ClusterFuture ...
[11:01:33.373] - result already collected: FutureResult
[11:01:33.374] result() for ClusterFuture ... done
[11:01:33.374] result() for ClusterFuture ...
[11:01:33.374] - result already collected: FutureResult
[11:01:33.374] result() for ClusterFuture ... done
[11:01:33.374] result() for ClusterFuture ...
[11:01:33.374] - result already collected: FutureResult
[11:01:33.374] result() for ClusterFuture ... done
[11:01:33.374] result() for ClusterFuture ...
[11:01:33.374] - result already collected: FutureResult
[11:01:33.374] result() for ClusterFuture ... done
[11:01:33.374] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.374] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.375] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:33.375]  length: 0 (resolved future 4)
[11:01:33.375] Relaying remaining futures
[11:01:33.375] signalConditionsASAP(NULL, pos=0) ...
[11:01:33.375] - nx: 6
[11:01:33.375] - relay: TRUE
[11:01:33.375] - stdout: TRUE
[11:01:33.375] - signal: TRUE
[11:01:33.375] - resignal: FALSE
[11:01:33.375] - force: TRUE
[11:01:33.375] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.375] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:33.376] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.376] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.376] signalConditionsASAP(NULL, pos=0) ... done
[11:01:33.376] resolve() on list environment ... DONE
[11:01:33.376] result() for ClusterFuture ...
[11:01:33.376] - result already collected: FutureResult
[11:01:33.376] result() for ClusterFuture ... done
[11:01:33.376] result() for ClusterFuture ...
[11:01:33.376] - result already collected: FutureResult
[11:01:33.376] result() for ClusterFuture ... done
[11:01:33.377] result() for ClusterFuture ...
[11:01:33.377] - result already collected: FutureResult
[11:01:33.377] result() for ClusterFuture ... done
[11:01:33.377] result() for ClusterFuture ...
[11:01:33.377] - result already collected: FutureResult
[11:01:33.377] result() for ClusterFuture ... done
[11:01:33.377] result() for ClusterFuture ...
[11:01:33.377] - result already collected: FutureResult
[11:01:33.377] result() for ClusterFuture ... done
[11:01:33.377] result() for ClusterFuture ...
[11:01:33.377] - result already collected: FutureResult
[11:01:33.378] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c7d05358> 
 - attr(*, "dim.")= int [1:2] 1 6
 - attr(*, "dimnames.")=List of 2
  ..$ : chr "a"
  ..$ : chr [1:6] "a" "b" "c" "d" ...
Dimensions: c(2, 3)
[11:01:33.379] getGlobalsAndPackages() ...
[11:01:33.379] Searching for globals...
[11:01:33.380] 
[11:01:33.380] Searching for globals ... DONE
[11:01:33.380] - globals: [0] <none>
[11:01:33.380] getGlobalsAndPackages() ... DONE
[11:01:33.380] run() for ‘Future’ ...
[11:01:33.380] - state: ‘created’
[11:01:33.380] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.394] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.394] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.394]   - Field: ‘node’
[11:01:33.394]   - Field: ‘label’
[11:01:33.394]   - Field: ‘local’
[11:01:33.395]   - Field: ‘owner’
[11:01:33.395]   - Field: ‘envir’
[11:01:33.395]   - Field: ‘workers’
[11:01:33.395]   - Field: ‘packages’
[11:01:33.395]   - Field: ‘gc’
[11:01:33.395]   - Field: ‘conditions’
[11:01:33.395]   - Field: ‘persistent’
[11:01:33.395]   - Field: ‘expr’
[11:01:33.395]   - Field: ‘uuid’
[11:01:33.395]   - Field: ‘seed’
[11:01:33.395]   - Field: ‘version’
[11:01:33.395]   - Field: ‘result’
[11:01:33.396]   - Field: ‘asynchronous’
[11:01:33.396]   - Field: ‘calls’
[11:01:33.396]   - Field: ‘globals’
[11:01:33.396]   - Field: ‘stdout’
[11:01:33.396]   - Field: ‘earlySignal’
[11:01:33.396]   - Field: ‘lazy’
[11:01:33.396]   - Field: ‘state’
[11:01:33.396] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.396] - Launch lazy future ...
[11:01:33.396] Packages needed by the future expression (n = 0): <none>
[11:01:33.397] Packages needed by future strategies (n = 0): <none>
[11:01:33.397] {
[11:01:33.397]     {
[11:01:33.397]         {
[11:01:33.397]             ...future.startTime <- base::Sys.time()
[11:01:33.397]             {
[11:01:33.397]                 {
[11:01:33.397]                   {
[11:01:33.397]                     {
[11:01:33.397]                       base::local({
[11:01:33.397]                         has_future <- base::requireNamespace("future", 
[11:01:33.397]                           quietly = TRUE)
[11:01:33.397]                         if (has_future) {
[11:01:33.397]                           ns <- base::getNamespace("future")
[11:01:33.397]                           version <- ns[[".package"]][["version"]]
[11:01:33.397]                           if (is.null(version)) 
[11:01:33.397]                             version <- utils::packageVersion("future")
[11:01:33.397]                         }
[11:01:33.397]                         else {
[11:01:33.397]                           version <- NULL
[11:01:33.397]                         }
[11:01:33.397]                         if (!has_future || version < "1.8.0") {
[11:01:33.397]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.397]                             "", base::R.version$version.string), 
[11:01:33.397]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.397]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.397]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.397]                               "release", "version")], collapse = " "), 
[11:01:33.397]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.397]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.397]                             info)
[11:01:33.397]                           info <- base::paste(info, collapse = "; ")
[11:01:33.397]                           if (!has_future) {
[11:01:33.397]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.397]                               info)
[11:01:33.397]                           }
[11:01:33.397]                           else {
[11:01:33.397]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.397]                               info, version)
[11:01:33.397]                           }
[11:01:33.397]                           base::stop(msg)
[11:01:33.397]                         }
[11:01:33.397]                       })
[11:01:33.397]                     }
[11:01:33.397]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.397]                     base::options(mc.cores = 1L)
[11:01:33.397]                   }
[11:01:33.397]                   ...future.strategy.old <- future::plan("list")
[11:01:33.397]                   options(future.plan = NULL)
[11:01:33.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.397]                 }
[11:01:33.397]                 ...future.workdir <- getwd()
[11:01:33.397]             }
[11:01:33.397]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.397]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.397]         }
[11:01:33.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.397]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.397]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.397]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.397]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.397]             base::names(...future.oldOptions))
[11:01:33.397]     }
[11:01:33.397]     if (FALSE) {
[11:01:33.397]     }
[11:01:33.397]     else {
[11:01:33.397]         if (TRUE) {
[11:01:33.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.397]                 open = "w")
[11:01:33.397]         }
[11:01:33.397]         else {
[11:01:33.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.397]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.397]         }
[11:01:33.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.397]             base::sink(type = "output", split = FALSE)
[11:01:33.397]             base::close(...future.stdout)
[11:01:33.397]         }, add = TRUE)
[11:01:33.397]     }
[11:01:33.397]     ...future.frame <- base::sys.nframe()
[11:01:33.397]     ...future.conditions <- base::list()
[11:01:33.397]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.397]     if (FALSE) {
[11:01:33.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.397]     }
[11:01:33.397]     ...future.result <- base::tryCatch({
[11:01:33.397]         base::withCallingHandlers({
[11:01:33.397]             ...future.value <- base::withVisible(base::local({
[11:01:33.397]                 ...future.makeSendCondition <- base::local({
[11:01:33.397]                   sendCondition <- NULL
[11:01:33.397]                   function(frame = 1L) {
[11:01:33.397]                     if (is.function(sendCondition)) 
[11:01:33.397]                       return(sendCondition)
[11:01:33.397]                     ns <- getNamespace("parallel")
[11:01:33.397]                     if (exists("sendData", mode = "function", 
[11:01:33.397]                       envir = ns)) {
[11:01:33.397]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.397]                         envir = ns)
[11:01:33.397]                       envir <- sys.frame(frame)
[11:01:33.397]                       master <- NULL
[11:01:33.397]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.397]                         !identical(envir, emptyenv())) {
[11:01:33.397]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.397]                           inherits = FALSE)) {
[11:01:33.397]                           master <- get("master", mode = "list", 
[11:01:33.397]                             envir = envir, inherits = FALSE)
[11:01:33.397]                           if (inherits(master, c("SOCKnode", 
[11:01:33.397]                             "SOCK0node"))) {
[11:01:33.397]                             sendCondition <<- function(cond) {
[11:01:33.397]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.397]                                 success = TRUE)
[11:01:33.397]                               parallel_sendData(master, data)
[11:01:33.397]                             }
[11:01:33.397]                             return(sendCondition)
[11:01:33.397]                           }
[11:01:33.397]                         }
[11:01:33.397]                         frame <- frame + 1L
[11:01:33.397]                         envir <- sys.frame(frame)
[11:01:33.397]                       }
[11:01:33.397]                     }
[11:01:33.397]                     sendCondition <<- function(cond) NULL
[11:01:33.397]                   }
[11:01:33.397]                 })
[11:01:33.397]                 withCallingHandlers({
[11:01:33.397]                   2
[11:01:33.397]                 }, immediateCondition = function(cond) {
[11:01:33.397]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.397]                   sendCondition(cond)
[11:01:33.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.397]                   {
[11:01:33.397]                     inherits <- base::inherits
[11:01:33.397]                     invokeRestart <- base::invokeRestart
[11:01:33.397]                     is.null <- base::is.null
[11:01:33.397]                     muffled <- FALSE
[11:01:33.397]                     if (inherits(cond, "message")) {
[11:01:33.397]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.397]                       if (muffled) 
[11:01:33.397]                         invokeRestart("muffleMessage")
[11:01:33.397]                     }
[11:01:33.397]                     else if (inherits(cond, "warning")) {
[11:01:33.397]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.397]                       if (muffled) 
[11:01:33.397]                         invokeRestart("muffleWarning")
[11:01:33.397]                     }
[11:01:33.397]                     else if (inherits(cond, "condition")) {
[11:01:33.397]                       if (!is.null(pattern)) {
[11:01:33.397]                         computeRestarts <- base::computeRestarts
[11:01:33.397]                         grepl <- base::grepl
[11:01:33.397]                         restarts <- computeRestarts(cond)
[11:01:33.397]                         for (restart in restarts) {
[11:01:33.397]                           name <- restart$name
[11:01:33.397]                           if (is.null(name)) 
[11:01:33.397]                             next
[11:01:33.397]                           if (!grepl(pattern, name)) 
[11:01:33.397]                             next
[11:01:33.397]                           invokeRestart(restart)
[11:01:33.397]                           muffled <- TRUE
[11:01:33.397]                           break
[11:01:33.397]                         }
[11:01:33.397]                       }
[11:01:33.397]                     }
[11:01:33.397]                     invisible(muffled)
[11:01:33.397]                   }
[11:01:33.397]                   muffleCondition(cond)
[11:01:33.397]                 })
[11:01:33.397]             }))
[11:01:33.397]             future::FutureResult(value = ...future.value$value, 
[11:01:33.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.397]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.397]                     ...future.globalenv.names))
[11:01:33.397]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.397]         }, condition = base::local({
[11:01:33.397]             c <- base::c
[11:01:33.397]             inherits <- base::inherits
[11:01:33.397]             invokeRestart <- base::invokeRestart
[11:01:33.397]             length <- base::length
[11:01:33.397]             list <- base::list
[11:01:33.397]             seq.int <- base::seq.int
[11:01:33.397]             signalCondition <- base::signalCondition
[11:01:33.397]             sys.calls <- base::sys.calls
[11:01:33.397]             `[[` <- base::`[[`
[11:01:33.397]             `+` <- base::`+`
[11:01:33.397]             `<<-` <- base::`<<-`
[11:01:33.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.397]                   3L)]
[11:01:33.397]             }
[11:01:33.397]             function(cond) {
[11:01:33.397]                 is_error <- inherits(cond, "error")
[11:01:33.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.397]                   NULL)
[11:01:33.397]                 if (is_error) {
[11:01:33.397]                   sessionInformation <- function() {
[11:01:33.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.397]                       search = base::search(), system = base::Sys.info())
[11:01:33.397]                   }
[11:01:33.397]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.397]                     cond$call), session = sessionInformation(), 
[11:01:33.397]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.397]                   signalCondition(cond)
[11:01:33.397]                 }
[11:01:33.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.397]                 "immediateCondition"))) {
[11:01:33.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.397]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.397]                   if (TRUE && !signal) {
[11:01:33.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.397]                     {
[11:01:33.397]                       inherits <- base::inherits
[11:01:33.397]                       invokeRestart <- base::invokeRestart
[11:01:33.397]                       is.null <- base::is.null
[11:01:33.397]                       muffled <- FALSE
[11:01:33.397]                       if (inherits(cond, "message")) {
[11:01:33.397]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.397]                         if (muffled) 
[11:01:33.397]                           invokeRestart("muffleMessage")
[11:01:33.397]                       }
[11:01:33.397]                       else if (inherits(cond, "warning")) {
[11:01:33.397]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.397]                         if (muffled) 
[11:01:33.397]                           invokeRestart("muffleWarning")
[11:01:33.397]                       }
[11:01:33.397]                       else if (inherits(cond, "condition")) {
[11:01:33.397]                         if (!is.null(pattern)) {
[11:01:33.397]                           computeRestarts <- base::computeRestarts
[11:01:33.397]                           grepl <- base::grepl
[11:01:33.397]                           restarts <- computeRestarts(cond)
[11:01:33.397]                           for (restart in restarts) {
[11:01:33.397]                             name <- restart$name
[11:01:33.397]                             if (is.null(name)) 
[11:01:33.397]                               next
[11:01:33.397]                             if (!grepl(pattern, name)) 
[11:01:33.397]                               next
[11:01:33.397]                             invokeRestart(restart)
[11:01:33.397]                             muffled <- TRUE
[11:01:33.397]                             break
[11:01:33.397]                           }
[11:01:33.397]                         }
[11:01:33.397]                       }
[11:01:33.397]                       invisible(muffled)
[11:01:33.397]                     }
[11:01:33.397]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.397]                   }
[11:01:33.397]                 }
[11:01:33.397]                 else {
[11:01:33.397]                   if (TRUE) {
[11:01:33.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.397]                     {
[11:01:33.397]                       inherits <- base::inherits
[11:01:33.397]                       invokeRestart <- base::invokeRestart
[11:01:33.397]                       is.null <- base::is.null
[11:01:33.397]                       muffled <- FALSE
[11:01:33.397]                       if (inherits(cond, "message")) {
[11:01:33.397]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.397]                         if (muffled) 
[11:01:33.397]                           invokeRestart("muffleMessage")
[11:01:33.397]                       }
[11:01:33.397]                       else if (inherits(cond, "warning")) {
[11:01:33.397]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.397]                         if (muffled) 
[11:01:33.397]                           invokeRestart("muffleWarning")
[11:01:33.397]                       }
[11:01:33.397]                       else if (inherits(cond, "condition")) {
[11:01:33.397]                         if (!is.null(pattern)) {
[11:01:33.397]                           computeRestarts <- base::computeRestarts
[11:01:33.397]                           grepl <- base::grepl
[11:01:33.397]                           restarts <- computeRestarts(cond)
[11:01:33.397]                           for (restart in restarts) {
[11:01:33.397]                             name <- restart$name
[11:01:33.397]                             if (is.null(name)) 
[11:01:33.397]                               next
[11:01:33.397]                             if (!grepl(pattern, name)) 
[11:01:33.397]                               next
[11:01:33.397]                             invokeRestart(restart)
[11:01:33.397]                             muffled <- TRUE
[11:01:33.397]                             break
[11:01:33.397]                           }
[11:01:33.397]                         }
[11:01:33.397]                       }
[11:01:33.397]                       invisible(muffled)
[11:01:33.397]                     }
[11:01:33.397]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.397]                   }
[11:01:33.397]                 }
[11:01:33.397]             }
[11:01:33.397]         }))
[11:01:33.397]     }, error = function(ex) {
[11:01:33.397]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.397]                 ...future.rng), started = ...future.startTime, 
[11:01:33.397]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.397]             version = "1.8"), class = "FutureResult")
[11:01:33.397]     }, finally = {
[11:01:33.397]         if (!identical(...future.workdir, getwd())) 
[11:01:33.397]             setwd(...future.workdir)
[11:01:33.397]         {
[11:01:33.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.397]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.397]             }
[11:01:33.397]             base::options(...future.oldOptions)
[11:01:33.397]             if (.Platform$OS.type == "windows") {
[11:01:33.397]                 old_names <- names(...future.oldEnvVars)
[11:01:33.397]                 envs <- base::Sys.getenv()
[11:01:33.397]                 names <- names(envs)
[11:01:33.397]                 common <- intersect(names, old_names)
[11:01:33.397]                 added <- setdiff(names, old_names)
[11:01:33.397]                 removed <- setdiff(old_names, names)
[11:01:33.397]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.397]                   envs[common]]
[11:01:33.397]                 NAMES <- toupper(changed)
[11:01:33.397]                 args <- list()
[11:01:33.397]                 for (kk in seq_along(NAMES)) {
[11:01:33.397]                   name <- changed[[kk]]
[11:01:33.397]                   NAME <- NAMES[[kk]]
[11:01:33.397]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.397]                     next
[11:01:33.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.397]                 }
[11:01:33.397]                 NAMES <- toupper(added)
[11:01:33.397]                 for (kk in seq_along(NAMES)) {
[11:01:33.397]                   name <- added[[kk]]
[11:01:33.397]                   NAME <- NAMES[[kk]]
[11:01:33.397]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.397]                     next
[11:01:33.397]                   args[[name]] <- ""
[11:01:33.397]                 }
[11:01:33.397]                 NAMES <- toupper(removed)
[11:01:33.397]                 for (kk in seq_along(NAMES)) {
[11:01:33.397]                   name <- removed[[kk]]
[11:01:33.397]                   NAME <- NAMES[[kk]]
[11:01:33.397]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.397]                     next
[11:01:33.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.397]                 }
[11:01:33.397]                 if (length(args) > 0) 
[11:01:33.397]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.397]             }
[11:01:33.397]             else {
[11:01:33.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.397]             }
[11:01:33.397]             {
[11:01:33.397]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.397]                   0L) {
[11:01:33.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.397]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.397]                   base::options(opts)
[11:01:33.397]                 }
[11:01:33.397]                 {
[11:01:33.397]                   {
[11:01:33.397]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.397]                     NULL
[11:01:33.397]                   }
[11:01:33.397]                   options(future.plan = NULL)
[11:01:33.397]                   if (is.na(NA_character_)) 
[11:01:33.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.397]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.397]                     .init = FALSE)
[11:01:33.397]                 }
[11:01:33.397]             }
[11:01:33.397]         }
[11:01:33.397]     })
[11:01:33.397]     if (TRUE) {
[11:01:33.397]         base::sink(type = "output", split = FALSE)
[11:01:33.397]         if (TRUE) {
[11:01:33.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.397]         }
[11:01:33.397]         else {
[11:01:33.397]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.397]         }
[11:01:33.397]         base::close(...future.stdout)
[11:01:33.397]         ...future.stdout <- NULL
[11:01:33.397]     }
[11:01:33.397]     ...future.result$conditions <- ...future.conditions
[11:01:33.397]     ...future.result$finished <- base::Sys.time()
[11:01:33.397]     ...future.result
[11:01:33.397] }
[11:01:33.400] MultisessionFuture started
[11:01:33.400] - Launch lazy future ... done
[11:01:33.400] run() for ‘MultisessionFuture’ ... done
[11:01:33.401] getGlobalsAndPackages() ...
[11:01:33.401] Searching for globals...
[11:01:33.401] 
[11:01:33.401] Searching for globals ... DONE
[11:01:33.401] - globals: [0] <none>
[11:01:33.402] getGlobalsAndPackages() ... DONE
[11:01:33.402] run() for ‘Future’ ...
[11:01:33.402] - state: ‘created’
[11:01:33.402] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.426] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.426] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.426]   - Field: ‘node’
[11:01:33.426]   - Field: ‘label’
[11:01:33.426]   - Field: ‘local’
[11:01:33.426]   - Field: ‘owner’
[11:01:33.426]   - Field: ‘envir’
[11:01:33.426]   - Field: ‘workers’
[11:01:33.426]   - Field: ‘packages’
[11:01:33.426]   - Field: ‘gc’
[11:01:33.427]   - Field: ‘conditions’
[11:01:33.427]   - Field: ‘persistent’
[11:01:33.427]   - Field: ‘expr’
[11:01:33.427]   - Field: ‘uuid’
[11:01:33.427]   - Field: ‘seed’
[11:01:33.427]   - Field: ‘version’
[11:01:33.427]   - Field: ‘result’
[11:01:33.427]   - Field: ‘asynchronous’
[11:01:33.427]   - Field: ‘calls’
[11:01:33.427]   - Field: ‘globals’
[11:01:33.427]   - Field: ‘stdout’
[11:01:33.427]   - Field: ‘earlySignal’
[11:01:33.428]   - Field: ‘lazy’
[11:01:33.428]   - Field: ‘state’
[11:01:33.428] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.428] - Launch lazy future ...
[11:01:33.428] Packages needed by the future expression (n = 0): <none>
[11:01:33.428] Packages needed by future strategies (n = 0): <none>
[11:01:33.429] {
[11:01:33.429]     {
[11:01:33.429]         {
[11:01:33.429]             ...future.startTime <- base::Sys.time()
[11:01:33.429]             {
[11:01:33.429]                 {
[11:01:33.429]                   {
[11:01:33.429]                     {
[11:01:33.429]                       base::local({
[11:01:33.429]                         has_future <- base::requireNamespace("future", 
[11:01:33.429]                           quietly = TRUE)
[11:01:33.429]                         if (has_future) {
[11:01:33.429]                           ns <- base::getNamespace("future")
[11:01:33.429]                           version <- ns[[".package"]][["version"]]
[11:01:33.429]                           if (is.null(version)) 
[11:01:33.429]                             version <- utils::packageVersion("future")
[11:01:33.429]                         }
[11:01:33.429]                         else {
[11:01:33.429]                           version <- NULL
[11:01:33.429]                         }
[11:01:33.429]                         if (!has_future || version < "1.8.0") {
[11:01:33.429]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.429]                             "", base::R.version$version.string), 
[11:01:33.429]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.429]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.429]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.429]                               "release", "version")], collapse = " "), 
[11:01:33.429]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.429]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.429]                             info)
[11:01:33.429]                           info <- base::paste(info, collapse = "; ")
[11:01:33.429]                           if (!has_future) {
[11:01:33.429]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.429]                               info)
[11:01:33.429]                           }
[11:01:33.429]                           else {
[11:01:33.429]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.429]                               info, version)
[11:01:33.429]                           }
[11:01:33.429]                           base::stop(msg)
[11:01:33.429]                         }
[11:01:33.429]                       })
[11:01:33.429]                     }
[11:01:33.429]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.429]                     base::options(mc.cores = 1L)
[11:01:33.429]                   }
[11:01:33.429]                   ...future.strategy.old <- future::plan("list")
[11:01:33.429]                   options(future.plan = NULL)
[11:01:33.429]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.429]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.429]                 }
[11:01:33.429]                 ...future.workdir <- getwd()
[11:01:33.429]             }
[11:01:33.429]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.429]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.429]         }
[11:01:33.429]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.429]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.429]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.429]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.429]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.429]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.429]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.429]             base::names(...future.oldOptions))
[11:01:33.429]     }
[11:01:33.429]     if (FALSE) {
[11:01:33.429]     }
[11:01:33.429]     else {
[11:01:33.429]         if (TRUE) {
[11:01:33.429]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.429]                 open = "w")
[11:01:33.429]         }
[11:01:33.429]         else {
[11:01:33.429]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.429]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.429]         }
[11:01:33.429]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.429]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.429]             base::sink(type = "output", split = FALSE)
[11:01:33.429]             base::close(...future.stdout)
[11:01:33.429]         }, add = TRUE)
[11:01:33.429]     }
[11:01:33.429]     ...future.frame <- base::sys.nframe()
[11:01:33.429]     ...future.conditions <- base::list()
[11:01:33.429]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.429]     if (FALSE) {
[11:01:33.429]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.429]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.429]     }
[11:01:33.429]     ...future.result <- base::tryCatch({
[11:01:33.429]         base::withCallingHandlers({
[11:01:33.429]             ...future.value <- base::withVisible(base::local({
[11:01:33.429]                 ...future.makeSendCondition <- base::local({
[11:01:33.429]                   sendCondition <- NULL
[11:01:33.429]                   function(frame = 1L) {
[11:01:33.429]                     if (is.function(sendCondition)) 
[11:01:33.429]                       return(sendCondition)
[11:01:33.429]                     ns <- getNamespace("parallel")
[11:01:33.429]                     if (exists("sendData", mode = "function", 
[11:01:33.429]                       envir = ns)) {
[11:01:33.429]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.429]                         envir = ns)
[11:01:33.429]                       envir <- sys.frame(frame)
[11:01:33.429]                       master <- NULL
[11:01:33.429]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.429]                         !identical(envir, emptyenv())) {
[11:01:33.429]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.429]                           inherits = FALSE)) {
[11:01:33.429]                           master <- get("master", mode = "list", 
[11:01:33.429]                             envir = envir, inherits = FALSE)
[11:01:33.429]                           if (inherits(master, c("SOCKnode", 
[11:01:33.429]                             "SOCK0node"))) {
[11:01:33.429]                             sendCondition <<- function(cond) {
[11:01:33.429]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.429]                                 success = TRUE)
[11:01:33.429]                               parallel_sendData(master, data)
[11:01:33.429]                             }
[11:01:33.429]                             return(sendCondition)
[11:01:33.429]                           }
[11:01:33.429]                         }
[11:01:33.429]                         frame <- frame + 1L
[11:01:33.429]                         envir <- sys.frame(frame)
[11:01:33.429]                       }
[11:01:33.429]                     }
[11:01:33.429]                     sendCondition <<- function(cond) NULL
[11:01:33.429]                   }
[11:01:33.429]                 })
[11:01:33.429]                 withCallingHandlers({
[11:01:33.429]                   NULL
[11:01:33.429]                 }, immediateCondition = function(cond) {
[11:01:33.429]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.429]                   sendCondition(cond)
[11:01:33.429]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.429]                   {
[11:01:33.429]                     inherits <- base::inherits
[11:01:33.429]                     invokeRestart <- base::invokeRestart
[11:01:33.429]                     is.null <- base::is.null
[11:01:33.429]                     muffled <- FALSE
[11:01:33.429]                     if (inherits(cond, "message")) {
[11:01:33.429]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.429]                       if (muffled) 
[11:01:33.429]                         invokeRestart("muffleMessage")
[11:01:33.429]                     }
[11:01:33.429]                     else if (inherits(cond, "warning")) {
[11:01:33.429]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.429]                       if (muffled) 
[11:01:33.429]                         invokeRestart("muffleWarning")
[11:01:33.429]                     }
[11:01:33.429]                     else if (inherits(cond, "condition")) {
[11:01:33.429]                       if (!is.null(pattern)) {
[11:01:33.429]                         computeRestarts <- base::computeRestarts
[11:01:33.429]                         grepl <- base::grepl
[11:01:33.429]                         restarts <- computeRestarts(cond)
[11:01:33.429]                         for (restart in restarts) {
[11:01:33.429]                           name <- restart$name
[11:01:33.429]                           if (is.null(name)) 
[11:01:33.429]                             next
[11:01:33.429]                           if (!grepl(pattern, name)) 
[11:01:33.429]                             next
[11:01:33.429]                           invokeRestart(restart)
[11:01:33.429]                           muffled <- TRUE
[11:01:33.429]                           break
[11:01:33.429]                         }
[11:01:33.429]                       }
[11:01:33.429]                     }
[11:01:33.429]                     invisible(muffled)
[11:01:33.429]                   }
[11:01:33.429]                   muffleCondition(cond)
[11:01:33.429]                 })
[11:01:33.429]             }))
[11:01:33.429]             future::FutureResult(value = ...future.value$value, 
[11:01:33.429]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.429]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.429]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.429]                     ...future.globalenv.names))
[11:01:33.429]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.429]         }, condition = base::local({
[11:01:33.429]             c <- base::c
[11:01:33.429]             inherits <- base::inherits
[11:01:33.429]             invokeRestart <- base::invokeRestart
[11:01:33.429]             length <- base::length
[11:01:33.429]             list <- base::list
[11:01:33.429]             seq.int <- base::seq.int
[11:01:33.429]             signalCondition <- base::signalCondition
[11:01:33.429]             sys.calls <- base::sys.calls
[11:01:33.429]             `[[` <- base::`[[`
[11:01:33.429]             `+` <- base::`+`
[11:01:33.429]             `<<-` <- base::`<<-`
[11:01:33.429]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.429]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.429]                   3L)]
[11:01:33.429]             }
[11:01:33.429]             function(cond) {
[11:01:33.429]                 is_error <- inherits(cond, "error")
[11:01:33.429]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.429]                   NULL)
[11:01:33.429]                 if (is_error) {
[11:01:33.429]                   sessionInformation <- function() {
[11:01:33.429]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.429]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.429]                       search = base::search(), system = base::Sys.info())
[11:01:33.429]                   }
[11:01:33.429]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.429]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.429]                     cond$call), session = sessionInformation(), 
[11:01:33.429]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.429]                   signalCondition(cond)
[11:01:33.429]                 }
[11:01:33.429]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.429]                 "immediateCondition"))) {
[11:01:33.429]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.429]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.429]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.429]                   if (TRUE && !signal) {
[11:01:33.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.429]                     {
[11:01:33.429]                       inherits <- base::inherits
[11:01:33.429]                       invokeRestart <- base::invokeRestart
[11:01:33.429]                       is.null <- base::is.null
[11:01:33.429]                       muffled <- FALSE
[11:01:33.429]                       if (inherits(cond, "message")) {
[11:01:33.429]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.429]                         if (muffled) 
[11:01:33.429]                           invokeRestart("muffleMessage")
[11:01:33.429]                       }
[11:01:33.429]                       else if (inherits(cond, "warning")) {
[11:01:33.429]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.429]                         if (muffled) 
[11:01:33.429]                           invokeRestart("muffleWarning")
[11:01:33.429]                       }
[11:01:33.429]                       else if (inherits(cond, "condition")) {
[11:01:33.429]                         if (!is.null(pattern)) {
[11:01:33.429]                           computeRestarts <- base::computeRestarts
[11:01:33.429]                           grepl <- base::grepl
[11:01:33.429]                           restarts <- computeRestarts(cond)
[11:01:33.429]                           for (restart in restarts) {
[11:01:33.429]                             name <- restart$name
[11:01:33.429]                             if (is.null(name)) 
[11:01:33.429]                               next
[11:01:33.429]                             if (!grepl(pattern, name)) 
[11:01:33.429]                               next
[11:01:33.429]                             invokeRestart(restart)
[11:01:33.429]                             muffled <- TRUE
[11:01:33.429]                             break
[11:01:33.429]                           }
[11:01:33.429]                         }
[11:01:33.429]                       }
[11:01:33.429]                       invisible(muffled)
[11:01:33.429]                     }
[11:01:33.429]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.429]                   }
[11:01:33.429]                 }
[11:01:33.429]                 else {
[11:01:33.429]                   if (TRUE) {
[11:01:33.429]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.429]                     {
[11:01:33.429]                       inherits <- base::inherits
[11:01:33.429]                       invokeRestart <- base::invokeRestart
[11:01:33.429]                       is.null <- base::is.null
[11:01:33.429]                       muffled <- FALSE
[11:01:33.429]                       if (inherits(cond, "message")) {
[11:01:33.429]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.429]                         if (muffled) 
[11:01:33.429]                           invokeRestart("muffleMessage")
[11:01:33.429]                       }
[11:01:33.429]                       else if (inherits(cond, "warning")) {
[11:01:33.429]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.429]                         if (muffled) 
[11:01:33.429]                           invokeRestart("muffleWarning")
[11:01:33.429]                       }
[11:01:33.429]                       else if (inherits(cond, "condition")) {
[11:01:33.429]                         if (!is.null(pattern)) {
[11:01:33.429]                           computeRestarts <- base::computeRestarts
[11:01:33.429]                           grepl <- base::grepl
[11:01:33.429]                           restarts <- computeRestarts(cond)
[11:01:33.429]                           for (restart in restarts) {
[11:01:33.429]                             name <- restart$name
[11:01:33.429]                             if (is.null(name)) 
[11:01:33.429]                               next
[11:01:33.429]                             if (!grepl(pattern, name)) 
[11:01:33.429]                               next
[11:01:33.429]                             invokeRestart(restart)
[11:01:33.429]                             muffled <- TRUE
[11:01:33.429]                             break
[11:01:33.429]                           }
[11:01:33.429]                         }
[11:01:33.429]                       }
[11:01:33.429]                       invisible(muffled)
[11:01:33.429]                     }
[11:01:33.429]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.429]                   }
[11:01:33.429]                 }
[11:01:33.429]             }
[11:01:33.429]         }))
[11:01:33.429]     }, error = function(ex) {
[11:01:33.429]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.429]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.429]                 ...future.rng), started = ...future.startTime, 
[11:01:33.429]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.429]             version = "1.8"), class = "FutureResult")
[11:01:33.429]     }, finally = {
[11:01:33.429]         if (!identical(...future.workdir, getwd())) 
[11:01:33.429]             setwd(...future.workdir)
[11:01:33.429]         {
[11:01:33.429]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.429]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.429]             }
[11:01:33.429]             base::options(...future.oldOptions)
[11:01:33.429]             if (.Platform$OS.type == "windows") {
[11:01:33.429]                 old_names <- names(...future.oldEnvVars)
[11:01:33.429]                 envs <- base::Sys.getenv()
[11:01:33.429]                 names <- names(envs)
[11:01:33.429]                 common <- intersect(names, old_names)
[11:01:33.429]                 added <- setdiff(names, old_names)
[11:01:33.429]                 removed <- setdiff(old_names, names)
[11:01:33.429]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.429]                   envs[common]]
[11:01:33.429]                 NAMES <- toupper(changed)
[11:01:33.429]                 args <- list()
[11:01:33.429]                 for (kk in seq_along(NAMES)) {
[11:01:33.429]                   name <- changed[[kk]]
[11:01:33.429]                   NAME <- NAMES[[kk]]
[11:01:33.429]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.429]                     next
[11:01:33.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.429]                 }
[11:01:33.429]                 NAMES <- toupper(added)
[11:01:33.429]                 for (kk in seq_along(NAMES)) {
[11:01:33.429]                   name <- added[[kk]]
[11:01:33.429]                   NAME <- NAMES[[kk]]
[11:01:33.429]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.429]                     next
[11:01:33.429]                   args[[name]] <- ""
[11:01:33.429]                 }
[11:01:33.429]                 NAMES <- toupper(removed)
[11:01:33.429]                 for (kk in seq_along(NAMES)) {
[11:01:33.429]                   name <- removed[[kk]]
[11:01:33.429]                   NAME <- NAMES[[kk]]
[11:01:33.429]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.429]                     next
[11:01:33.429]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.429]                 }
[11:01:33.429]                 if (length(args) > 0) 
[11:01:33.429]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.429]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.429]             }
[11:01:33.429]             else {
[11:01:33.429]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.429]             }
[11:01:33.429]             {
[11:01:33.429]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.429]                   0L) {
[11:01:33.429]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.429]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.429]                   base::options(opts)
[11:01:33.429]                 }
[11:01:33.429]                 {
[11:01:33.429]                   {
[11:01:33.429]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.429]                     NULL
[11:01:33.429]                   }
[11:01:33.429]                   options(future.plan = NULL)
[11:01:33.429]                   if (is.na(NA_character_)) 
[11:01:33.429]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.429]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.429]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.429]                     .init = FALSE)
[11:01:33.429]                 }
[11:01:33.429]             }
[11:01:33.429]         }
[11:01:33.429]     })
[11:01:33.429]     if (TRUE) {
[11:01:33.429]         base::sink(type = "output", split = FALSE)
[11:01:33.429]         if (TRUE) {
[11:01:33.429]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.429]         }
[11:01:33.429]         else {
[11:01:33.429]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.429]         }
[11:01:33.429]         base::close(...future.stdout)
[11:01:33.429]         ...future.stdout <- NULL
[11:01:33.429]     }
[11:01:33.429]     ...future.result$conditions <- ...future.conditions
[11:01:33.429]     ...future.result$finished <- base::Sys.time()
[11:01:33.429]     ...future.result
[11:01:33.429] }
[11:01:33.431] MultisessionFuture started
[11:01:33.432] - Launch lazy future ... done
[11:01:33.432] run() for ‘MultisessionFuture’ ... done
[11:01:33.432] getGlobalsAndPackages() ...
[11:01:33.432] Searching for globals...
[11:01:33.433] - globals found: [1] ‘{’
[11:01:33.433] Searching for globals ... DONE
[11:01:33.433] Resolving globals: FALSE
[11:01:33.433] 
[11:01:33.433] 
[11:01:33.433] getGlobalsAndPackages() ... DONE
[11:01:33.434] run() for ‘Future’ ...
[11:01:33.434] - state: ‘created’
[11:01:33.434] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.447] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.447] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.447]   - Field: ‘node’
[11:01:33.448]   - Field: ‘label’
[11:01:33.448]   - Field: ‘local’
[11:01:33.448]   - Field: ‘owner’
[11:01:33.448]   - Field: ‘envir’
[11:01:33.448]   - Field: ‘workers’
[11:01:33.448]   - Field: ‘packages’
[11:01:33.448]   - Field: ‘gc’
[11:01:33.448]   - Field: ‘conditions’
[11:01:33.448]   - Field: ‘persistent’
[11:01:33.448]   - Field: ‘expr’
[11:01:33.448]   - Field: ‘uuid’
[11:01:33.449]   - Field: ‘seed’
[11:01:33.449]   - Field: ‘version’
[11:01:33.449]   - Field: ‘result’
[11:01:33.449]   - Field: ‘asynchronous’
[11:01:33.449]   - Field: ‘calls’
[11:01:33.449]   - Field: ‘globals’
[11:01:33.449]   - Field: ‘stdout’
[11:01:33.449]   - Field: ‘earlySignal’
[11:01:33.449]   - Field: ‘lazy’
[11:01:33.449]   - Field: ‘state’
[11:01:33.449] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.449] - Launch lazy future ...
[11:01:33.450] Packages needed by the future expression (n = 0): <none>
[11:01:33.450] Packages needed by future strategies (n = 0): <none>
[11:01:33.450] {
[11:01:33.450]     {
[11:01:33.450]         {
[11:01:33.450]             ...future.startTime <- base::Sys.time()
[11:01:33.450]             {
[11:01:33.450]                 {
[11:01:33.450]                   {
[11:01:33.450]                     {
[11:01:33.450]                       base::local({
[11:01:33.450]                         has_future <- base::requireNamespace("future", 
[11:01:33.450]                           quietly = TRUE)
[11:01:33.450]                         if (has_future) {
[11:01:33.450]                           ns <- base::getNamespace("future")
[11:01:33.450]                           version <- ns[[".package"]][["version"]]
[11:01:33.450]                           if (is.null(version)) 
[11:01:33.450]                             version <- utils::packageVersion("future")
[11:01:33.450]                         }
[11:01:33.450]                         else {
[11:01:33.450]                           version <- NULL
[11:01:33.450]                         }
[11:01:33.450]                         if (!has_future || version < "1.8.0") {
[11:01:33.450]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.450]                             "", base::R.version$version.string), 
[11:01:33.450]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.450]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.450]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.450]                               "release", "version")], collapse = " "), 
[11:01:33.450]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.450]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.450]                             info)
[11:01:33.450]                           info <- base::paste(info, collapse = "; ")
[11:01:33.450]                           if (!has_future) {
[11:01:33.450]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.450]                               info)
[11:01:33.450]                           }
[11:01:33.450]                           else {
[11:01:33.450]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.450]                               info, version)
[11:01:33.450]                           }
[11:01:33.450]                           base::stop(msg)
[11:01:33.450]                         }
[11:01:33.450]                       })
[11:01:33.450]                     }
[11:01:33.450]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.450]                     base::options(mc.cores = 1L)
[11:01:33.450]                   }
[11:01:33.450]                   ...future.strategy.old <- future::plan("list")
[11:01:33.450]                   options(future.plan = NULL)
[11:01:33.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.450]                 }
[11:01:33.450]                 ...future.workdir <- getwd()
[11:01:33.450]             }
[11:01:33.450]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.450]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.450]         }
[11:01:33.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.450]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.450]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.450]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.450]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.450]             base::names(...future.oldOptions))
[11:01:33.450]     }
[11:01:33.450]     if (FALSE) {
[11:01:33.450]     }
[11:01:33.450]     else {
[11:01:33.450]         if (TRUE) {
[11:01:33.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.450]                 open = "w")
[11:01:33.450]         }
[11:01:33.450]         else {
[11:01:33.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.450]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.450]         }
[11:01:33.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.450]             base::sink(type = "output", split = FALSE)
[11:01:33.450]             base::close(...future.stdout)
[11:01:33.450]         }, add = TRUE)
[11:01:33.450]     }
[11:01:33.450]     ...future.frame <- base::sys.nframe()
[11:01:33.450]     ...future.conditions <- base::list()
[11:01:33.450]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.450]     if (FALSE) {
[11:01:33.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.450]     }
[11:01:33.450]     ...future.result <- base::tryCatch({
[11:01:33.450]         base::withCallingHandlers({
[11:01:33.450]             ...future.value <- base::withVisible(base::local({
[11:01:33.450]                 ...future.makeSendCondition <- base::local({
[11:01:33.450]                   sendCondition <- NULL
[11:01:33.450]                   function(frame = 1L) {
[11:01:33.450]                     if (is.function(sendCondition)) 
[11:01:33.450]                       return(sendCondition)
[11:01:33.450]                     ns <- getNamespace("parallel")
[11:01:33.450]                     if (exists("sendData", mode = "function", 
[11:01:33.450]                       envir = ns)) {
[11:01:33.450]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.450]                         envir = ns)
[11:01:33.450]                       envir <- sys.frame(frame)
[11:01:33.450]                       master <- NULL
[11:01:33.450]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.450]                         !identical(envir, emptyenv())) {
[11:01:33.450]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.450]                           inherits = FALSE)) {
[11:01:33.450]                           master <- get("master", mode = "list", 
[11:01:33.450]                             envir = envir, inherits = FALSE)
[11:01:33.450]                           if (inherits(master, c("SOCKnode", 
[11:01:33.450]                             "SOCK0node"))) {
[11:01:33.450]                             sendCondition <<- function(cond) {
[11:01:33.450]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.450]                                 success = TRUE)
[11:01:33.450]                               parallel_sendData(master, data)
[11:01:33.450]                             }
[11:01:33.450]                             return(sendCondition)
[11:01:33.450]                           }
[11:01:33.450]                         }
[11:01:33.450]                         frame <- frame + 1L
[11:01:33.450]                         envir <- sys.frame(frame)
[11:01:33.450]                       }
[11:01:33.450]                     }
[11:01:33.450]                     sendCondition <<- function(cond) NULL
[11:01:33.450]                   }
[11:01:33.450]                 })
[11:01:33.450]                 withCallingHandlers({
[11:01:33.450]                   {
[11:01:33.450]                     4
[11:01:33.450]                   }
[11:01:33.450]                 }, immediateCondition = function(cond) {
[11:01:33.450]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.450]                   sendCondition(cond)
[11:01:33.450]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.450]                   {
[11:01:33.450]                     inherits <- base::inherits
[11:01:33.450]                     invokeRestart <- base::invokeRestart
[11:01:33.450]                     is.null <- base::is.null
[11:01:33.450]                     muffled <- FALSE
[11:01:33.450]                     if (inherits(cond, "message")) {
[11:01:33.450]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.450]                       if (muffled) 
[11:01:33.450]                         invokeRestart("muffleMessage")
[11:01:33.450]                     }
[11:01:33.450]                     else if (inherits(cond, "warning")) {
[11:01:33.450]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.450]                       if (muffled) 
[11:01:33.450]                         invokeRestart("muffleWarning")
[11:01:33.450]                     }
[11:01:33.450]                     else if (inherits(cond, "condition")) {
[11:01:33.450]                       if (!is.null(pattern)) {
[11:01:33.450]                         computeRestarts <- base::computeRestarts
[11:01:33.450]                         grepl <- base::grepl
[11:01:33.450]                         restarts <- computeRestarts(cond)
[11:01:33.450]                         for (restart in restarts) {
[11:01:33.450]                           name <- restart$name
[11:01:33.450]                           if (is.null(name)) 
[11:01:33.450]                             next
[11:01:33.450]                           if (!grepl(pattern, name)) 
[11:01:33.450]                             next
[11:01:33.450]                           invokeRestart(restart)
[11:01:33.450]                           muffled <- TRUE
[11:01:33.450]                           break
[11:01:33.450]                         }
[11:01:33.450]                       }
[11:01:33.450]                     }
[11:01:33.450]                     invisible(muffled)
[11:01:33.450]                   }
[11:01:33.450]                   muffleCondition(cond)
[11:01:33.450]                 })
[11:01:33.450]             }))
[11:01:33.450]             future::FutureResult(value = ...future.value$value, 
[11:01:33.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.450]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.450]                     ...future.globalenv.names))
[11:01:33.450]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.450]         }, condition = base::local({
[11:01:33.450]             c <- base::c
[11:01:33.450]             inherits <- base::inherits
[11:01:33.450]             invokeRestart <- base::invokeRestart
[11:01:33.450]             length <- base::length
[11:01:33.450]             list <- base::list
[11:01:33.450]             seq.int <- base::seq.int
[11:01:33.450]             signalCondition <- base::signalCondition
[11:01:33.450]             sys.calls <- base::sys.calls
[11:01:33.450]             `[[` <- base::`[[`
[11:01:33.450]             `+` <- base::`+`
[11:01:33.450]             `<<-` <- base::`<<-`
[11:01:33.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.450]                   3L)]
[11:01:33.450]             }
[11:01:33.450]             function(cond) {
[11:01:33.450]                 is_error <- inherits(cond, "error")
[11:01:33.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.450]                   NULL)
[11:01:33.450]                 if (is_error) {
[11:01:33.450]                   sessionInformation <- function() {
[11:01:33.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.450]                       search = base::search(), system = base::Sys.info())
[11:01:33.450]                   }
[11:01:33.450]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.450]                     cond$call), session = sessionInformation(), 
[11:01:33.450]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.450]                   signalCondition(cond)
[11:01:33.450]                 }
[11:01:33.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.450]                 "immediateCondition"))) {
[11:01:33.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.450]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.450]                   if (TRUE && !signal) {
[11:01:33.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.450]                     {
[11:01:33.450]                       inherits <- base::inherits
[11:01:33.450]                       invokeRestart <- base::invokeRestart
[11:01:33.450]                       is.null <- base::is.null
[11:01:33.450]                       muffled <- FALSE
[11:01:33.450]                       if (inherits(cond, "message")) {
[11:01:33.450]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.450]                         if (muffled) 
[11:01:33.450]                           invokeRestart("muffleMessage")
[11:01:33.450]                       }
[11:01:33.450]                       else if (inherits(cond, "warning")) {
[11:01:33.450]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.450]                         if (muffled) 
[11:01:33.450]                           invokeRestart("muffleWarning")
[11:01:33.450]                       }
[11:01:33.450]                       else if (inherits(cond, "condition")) {
[11:01:33.450]                         if (!is.null(pattern)) {
[11:01:33.450]                           computeRestarts <- base::computeRestarts
[11:01:33.450]                           grepl <- base::grepl
[11:01:33.450]                           restarts <- computeRestarts(cond)
[11:01:33.450]                           for (restart in restarts) {
[11:01:33.450]                             name <- restart$name
[11:01:33.450]                             if (is.null(name)) 
[11:01:33.450]                               next
[11:01:33.450]                             if (!grepl(pattern, name)) 
[11:01:33.450]                               next
[11:01:33.450]                             invokeRestart(restart)
[11:01:33.450]                             muffled <- TRUE
[11:01:33.450]                             break
[11:01:33.450]                           }
[11:01:33.450]                         }
[11:01:33.450]                       }
[11:01:33.450]                       invisible(muffled)
[11:01:33.450]                     }
[11:01:33.450]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.450]                   }
[11:01:33.450]                 }
[11:01:33.450]                 else {
[11:01:33.450]                   if (TRUE) {
[11:01:33.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.450]                     {
[11:01:33.450]                       inherits <- base::inherits
[11:01:33.450]                       invokeRestart <- base::invokeRestart
[11:01:33.450]                       is.null <- base::is.null
[11:01:33.450]                       muffled <- FALSE
[11:01:33.450]                       if (inherits(cond, "message")) {
[11:01:33.450]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.450]                         if (muffled) 
[11:01:33.450]                           invokeRestart("muffleMessage")
[11:01:33.450]                       }
[11:01:33.450]                       else if (inherits(cond, "warning")) {
[11:01:33.450]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.450]                         if (muffled) 
[11:01:33.450]                           invokeRestart("muffleWarning")
[11:01:33.450]                       }
[11:01:33.450]                       else if (inherits(cond, "condition")) {
[11:01:33.450]                         if (!is.null(pattern)) {
[11:01:33.450]                           computeRestarts <- base::computeRestarts
[11:01:33.450]                           grepl <- base::grepl
[11:01:33.450]                           restarts <- computeRestarts(cond)
[11:01:33.450]                           for (restart in restarts) {
[11:01:33.450]                             name <- restart$name
[11:01:33.450]                             if (is.null(name)) 
[11:01:33.450]                               next
[11:01:33.450]                             if (!grepl(pattern, name)) 
[11:01:33.450]                               next
[11:01:33.450]                             invokeRestart(restart)
[11:01:33.450]                             muffled <- TRUE
[11:01:33.450]                             break
[11:01:33.450]                           }
[11:01:33.450]                         }
[11:01:33.450]                       }
[11:01:33.450]                       invisible(muffled)
[11:01:33.450]                     }
[11:01:33.450]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.450]                   }
[11:01:33.450]                 }
[11:01:33.450]             }
[11:01:33.450]         }))
[11:01:33.450]     }, error = function(ex) {
[11:01:33.450]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.450]                 ...future.rng), started = ...future.startTime, 
[11:01:33.450]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.450]             version = "1.8"), class = "FutureResult")
[11:01:33.450]     }, finally = {
[11:01:33.450]         if (!identical(...future.workdir, getwd())) 
[11:01:33.450]             setwd(...future.workdir)
[11:01:33.450]         {
[11:01:33.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.450]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.450]             }
[11:01:33.450]             base::options(...future.oldOptions)
[11:01:33.450]             if (.Platform$OS.type == "windows") {
[11:01:33.450]                 old_names <- names(...future.oldEnvVars)
[11:01:33.450]                 envs <- base::Sys.getenv()
[11:01:33.450]                 names <- names(envs)
[11:01:33.450]                 common <- intersect(names, old_names)
[11:01:33.450]                 added <- setdiff(names, old_names)
[11:01:33.450]                 removed <- setdiff(old_names, names)
[11:01:33.450]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.450]                   envs[common]]
[11:01:33.450]                 NAMES <- toupper(changed)
[11:01:33.450]                 args <- list()
[11:01:33.450]                 for (kk in seq_along(NAMES)) {
[11:01:33.450]                   name <- changed[[kk]]
[11:01:33.450]                   NAME <- NAMES[[kk]]
[11:01:33.450]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.450]                     next
[11:01:33.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.450]                 }
[11:01:33.450]                 NAMES <- toupper(added)
[11:01:33.450]                 for (kk in seq_along(NAMES)) {
[11:01:33.450]                   name <- added[[kk]]
[11:01:33.450]                   NAME <- NAMES[[kk]]
[11:01:33.450]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.450]                     next
[11:01:33.450]                   args[[name]] <- ""
[11:01:33.450]                 }
[11:01:33.450]                 NAMES <- toupper(removed)
[11:01:33.450]                 for (kk in seq_along(NAMES)) {
[11:01:33.450]                   name <- removed[[kk]]
[11:01:33.450]                   NAME <- NAMES[[kk]]
[11:01:33.450]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.450]                     next
[11:01:33.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.450]                 }
[11:01:33.450]                 if (length(args) > 0) 
[11:01:33.450]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.450]             }
[11:01:33.450]             else {
[11:01:33.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.450]             }
[11:01:33.450]             {
[11:01:33.450]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.450]                   0L) {
[11:01:33.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.450]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.450]                   base::options(opts)
[11:01:33.450]                 }
[11:01:33.450]                 {
[11:01:33.450]                   {
[11:01:33.450]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.450]                     NULL
[11:01:33.450]                   }
[11:01:33.450]                   options(future.plan = NULL)
[11:01:33.450]                   if (is.na(NA_character_)) 
[11:01:33.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.450]                     .init = FALSE)
[11:01:33.450]                 }
[11:01:33.450]             }
[11:01:33.450]         }
[11:01:33.450]     })
[11:01:33.450]     if (TRUE) {
[11:01:33.450]         base::sink(type = "output", split = FALSE)
[11:01:33.450]         if (TRUE) {
[11:01:33.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.450]         }
[11:01:33.450]         else {
[11:01:33.450]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.450]         }
[11:01:33.450]         base::close(...future.stdout)
[11:01:33.450]         ...future.stdout <- NULL
[11:01:33.450]     }
[11:01:33.450]     ...future.result$conditions <- ...future.conditions
[11:01:33.450]     ...future.result$finished <- base::Sys.time()
[11:01:33.450]     ...future.result
[11:01:33.450] }
[11:01:33.452] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:33.463] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.463] - Validating connection of MultisessionFuture
[11:01:33.463] - received message: FutureResult
[11:01:33.463] - Received FutureResult
[11:01:33.464] - Erased future from FutureRegistry
[11:01:33.464] result() for ClusterFuture ...
[11:01:33.464] - result already collected: FutureResult
[11:01:33.464] result() for ClusterFuture ... done
[11:01:33.464] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.464] result() for ClusterFuture ...
[11:01:33.464] - result already collected: FutureResult
[11:01:33.464] result() for ClusterFuture ... done
[11:01:33.464] result() for ClusterFuture ...
[11:01:33.464] - result already collected: FutureResult
[11:01:33.464] result() for ClusterFuture ... done
[11:01:33.465] MultisessionFuture started
[11:01:33.465] - Launch lazy future ... done
[11:01:33.465] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c87539e0> 
Classes 'listenv', 'environment' <environment: 0x55a9c61e6a58> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
[11:01:33.473] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.473] - Validating connection of MultisessionFuture
[11:01:33.473] - received message: FutureResult
[11:01:33.473] - Received FutureResult
[11:01:33.474] - Erased future from FutureRegistry
[11:01:33.474] result() for ClusterFuture ...
[11:01:33.474] - result already collected: FutureResult
[11:01:33.474] result() for ClusterFuture ... done
[11:01:33.474] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:33.487] resolve() on list environment ...
[11:01:33.487]  recursive: 0
[11:01:33.488]  length: 6
[11:01:33.488]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:33.488] signalConditionsASAP(numeric, pos=1) ...
[11:01:33.488] - nx: 6
[11:01:33.488] - relay: TRUE
[11:01:33.488] - stdout: TRUE
[11:01:33.488] - signal: TRUE
[11:01:33.488] - resignal: FALSE
[11:01:33.488] - force: TRUE
[11:01:33.488] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.489] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.489]  - until=2
[11:01:33.489]  - relaying element #2
[11:01:33.489] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.489] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.489] signalConditionsASAP(NULL, pos=1) ... done
[11:01:33.489]  length: 5 (resolved future 1)
[11:01:33.489] Future #2
[11:01:33.489] result() for ClusterFuture ...
[11:01:33.489] - result already collected: FutureResult
[11:01:33.489] result() for ClusterFuture ... done
[11:01:33.490] result() for ClusterFuture ...
[11:01:33.490] - result already collected: FutureResult
[11:01:33.490] result() for ClusterFuture ... done
[11:01:33.490] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:33.490] - nx: 6
[11:01:33.490] - relay: TRUE
[11:01:33.490] - stdout: TRUE
[11:01:33.490] - signal: TRUE
[11:01:33.490] - resignal: FALSE
[11:01:33.490] - force: TRUE
[11:01:33.490] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.490] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.490]  - until=2
[11:01:33.491]  - relaying element #2
[11:01:33.491] result() for ClusterFuture ...
[11:01:33.491] - result already collected: FutureResult
[11:01:33.491] result() for ClusterFuture ... done
[11:01:33.491] result() for ClusterFuture ...
[11:01:33.491] - result already collected: FutureResult
[11:01:33.491] result() for ClusterFuture ... done
[11:01:33.491] result() for ClusterFuture ...
[11:01:33.491] - result already collected: FutureResult
[11:01:33.491] result() for ClusterFuture ... done
[11:01:33.491] result() for ClusterFuture ...
[11:01:33.492] - result already collected: FutureResult
[11:01:33.492] result() for ClusterFuture ... done
[11:01:33.492] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.492] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.492] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:33.492]  length: 4 (resolved future 2)
[11:01:33.492] Future #3
[11:01:33.492] result() for ClusterFuture ...
[11:01:33.492] - result already collected: FutureResult
[11:01:33.492] result() for ClusterFuture ... done
[11:01:33.493] result() for ClusterFuture ...
[11:01:33.493] - result already collected: FutureResult
[11:01:33.493] result() for ClusterFuture ... done
[11:01:33.493] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:33.493] - nx: 6
[11:01:33.493] - relay: TRUE
[11:01:33.493] - stdout: TRUE
[11:01:33.493] - signal: TRUE
[11:01:33.493] - resignal: FALSE
[11:01:33.493] - force: TRUE
[11:01:33.493] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.493] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.494]  - until=3
[11:01:33.494]  - relaying element #3
[11:01:33.494] result() for ClusterFuture ...
[11:01:33.494] - result already collected: FutureResult
[11:01:33.494] result() for ClusterFuture ... done
[11:01:33.494] result() for ClusterFuture ...
[11:01:33.494] - result already collected: FutureResult
[11:01:33.494] result() for ClusterFuture ... done
[11:01:33.494] result() for ClusterFuture ...
[11:01:33.494] - result already collected: FutureResult
[11:01:33.494] result() for ClusterFuture ... done
[11:01:33.494] result() for ClusterFuture ...
[11:01:33.495] - result already collected: FutureResult
[11:01:33.495] result() for ClusterFuture ... done
[11:01:33.495] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.495] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.495] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:33.495]  length: 3 (resolved future 3)
[11:01:33.505] signalConditionsASAP(NULL, pos=5) ...
[11:01:33.506] - nx: 6
[11:01:33.506] - relay: TRUE
[11:01:33.506] - stdout: TRUE
[11:01:33.506] - signal: TRUE
[11:01:33.506] - resignal: FALSE
[11:01:33.506] - force: TRUE
[11:01:33.506] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.506] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.506]  - until=6
[11:01:33.506]  - relaying element #4
[11:01:33.507]  - relaying element #6
[11:01:33.507] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.507] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.507] signalConditionsASAP(NULL, pos=5) ... done
[11:01:33.507]  length: 2 (resolved future 5)
[11:01:33.507] signalConditionsASAP(numeric, pos=6) ...
[11:01:33.507] - nx: 6
[11:01:33.507] - relay: TRUE
[11:01:33.507] - stdout: TRUE
[11:01:33.507] - signal: TRUE
[11:01:33.507] - resignal: FALSE
[11:01:33.507] - force: TRUE
[11:01:33.508] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.508] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.508]  - until=6
[11:01:33.508]  - relaying element #4
[11:01:33.508] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.508] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.508] signalConditionsASAP(NULL, pos=6) ... done
[11:01:33.508]  length: 1 (resolved future 6)
[11:01:33.519] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.519] - Validating connection of MultisessionFuture
[11:01:33.519] - received message: FutureResult
[11:01:33.519] - Received FutureResult
[11:01:33.519] - Erased future from FutureRegistry
[11:01:33.519] result() for ClusterFuture ...
[11:01:33.520] - result already collected: FutureResult
[11:01:33.520] result() for ClusterFuture ... done
[11:01:33.520] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.520] Future #4
[11:01:33.520] result() for ClusterFuture ...
[11:01:33.520] - result already collected: FutureResult
[11:01:33.520] result() for ClusterFuture ... done
[11:01:33.520] result() for ClusterFuture ...
[11:01:33.520] - result already collected: FutureResult
[11:01:33.520] result() for ClusterFuture ... done
[11:01:33.520] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:33.520] - nx: 6
[11:01:33.521] - relay: TRUE
[11:01:33.521] - stdout: TRUE
[11:01:33.521] - signal: TRUE
[11:01:33.521] - resignal: FALSE
[11:01:33.521] - force: TRUE
[11:01:33.521] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.521] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.521]  - until=6
[11:01:33.521]  - relaying element #4
[11:01:33.521] result() for ClusterFuture ...
[11:01:33.521] - result already collected: FutureResult
[11:01:33.521] result() for ClusterFuture ... done
[11:01:33.522] result() for ClusterFuture ...
[11:01:33.522] - result already collected: FutureResult
[11:01:33.522] result() for ClusterFuture ... done
[11:01:33.522] result() for ClusterFuture ...
[11:01:33.522] - result already collected: FutureResult
[11:01:33.522] result() for ClusterFuture ... done
[11:01:33.522] result() for ClusterFuture ...
[11:01:33.522] - result already collected: FutureResult
[11:01:33.522] result() for ClusterFuture ... done
[11:01:33.522] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.522] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.522] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:33.523]  length: 0 (resolved future 4)
[11:01:33.523] Relaying remaining futures
[11:01:33.523] signalConditionsASAP(NULL, pos=0) ...
[11:01:33.523] - nx: 6
[11:01:33.523] - relay: TRUE
[11:01:33.523] - stdout: TRUE
[11:01:33.523] - signal: TRUE
[11:01:33.523] - resignal: FALSE
[11:01:33.523] - force: TRUE
[11:01:33.523] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.523] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:33.523] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.524] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.524] signalConditionsASAP(NULL, pos=0) ... done
[11:01:33.524] resolve() on list environment ... DONE
[11:01:33.524] result() for ClusterFuture ...
[11:01:33.524] - result already collected: FutureResult
[11:01:33.524] result() for ClusterFuture ... done
[11:01:33.524] result() for ClusterFuture ...
[11:01:33.524] - result already collected: FutureResult
[11:01:33.524] result() for ClusterFuture ... done
[11:01:33.524] result() for ClusterFuture ...
[11:01:33.524] - result already collected: FutureResult
[11:01:33.525] result() for ClusterFuture ... done
[11:01:33.525] result() for ClusterFuture ...
[11:01:33.525] - result already collected: FutureResult
[11:01:33.525] result() for ClusterFuture ... done
[11:01:33.525] result() for ClusterFuture ...
[11:01:33.525] - result already collected: FutureResult
[11:01:33.525] result() for ClusterFuture ... done
[11:01:33.525] result() for ClusterFuture ...
[11:01:33.525] - result already collected: FutureResult
[11:01:33.525] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c4ddc330> 
 - attr(*, "dim.")= int [1:2] 2 3
 - attr(*, "dimnames.")=List of 2
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
Dimensions: c(2, 3, 1)
[11:01:33.527] getGlobalsAndPackages() ...
[11:01:33.527] Searching for globals...
[11:01:33.527] 
[11:01:33.528] Searching for globals ... DONE
[11:01:33.528] - globals: [0] <none>
[11:01:33.528] getGlobalsAndPackages() ... DONE
[11:01:33.528] run() for ‘Future’ ...
[11:01:33.528] - state: ‘created’
[11:01:33.528] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.542] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.542] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.542]   - Field: ‘node’
[11:01:33.542]   - Field: ‘label’
[11:01:33.542]   - Field: ‘local’
[11:01:33.542]   - Field: ‘owner’
[11:01:33.542]   - Field: ‘envir’
[11:01:33.542]   - Field: ‘workers’
[11:01:33.543]   - Field: ‘packages’
[11:01:33.543]   - Field: ‘gc’
[11:01:33.543]   - Field: ‘conditions’
[11:01:33.543]   - Field: ‘persistent’
[11:01:33.543]   - Field: ‘expr’
[11:01:33.543]   - Field: ‘uuid’
[11:01:33.543]   - Field: ‘seed’
[11:01:33.543]   - Field: ‘version’
[11:01:33.543]   - Field: ‘result’
[11:01:33.543]   - Field: ‘asynchronous’
[11:01:33.543]   - Field: ‘calls’
[11:01:33.544]   - Field: ‘globals’
[11:01:33.544]   - Field: ‘stdout’
[11:01:33.544]   - Field: ‘earlySignal’
[11:01:33.544]   - Field: ‘lazy’
[11:01:33.544]   - Field: ‘state’
[11:01:33.544] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.544] - Launch lazy future ...
[11:01:33.544] Packages needed by the future expression (n = 0): <none>
[11:01:33.544] Packages needed by future strategies (n = 0): <none>
[11:01:33.545] {
[11:01:33.545]     {
[11:01:33.545]         {
[11:01:33.545]             ...future.startTime <- base::Sys.time()
[11:01:33.545]             {
[11:01:33.545]                 {
[11:01:33.545]                   {
[11:01:33.545]                     {
[11:01:33.545]                       base::local({
[11:01:33.545]                         has_future <- base::requireNamespace("future", 
[11:01:33.545]                           quietly = TRUE)
[11:01:33.545]                         if (has_future) {
[11:01:33.545]                           ns <- base::getNamespace("future")
[11:01:33.545]                           version <- ns[[".package"]][["version"]]
[11:01:33.545]                           if (is.null(version)) 
[11:01:33.545]                             version <- utils::packageVersion("future")
[11:01:33.545]                         }
[11:01:33.545]                         else {
[11:01:33.545]                           version <- NULL
[11:01:33.545]                         }
[11:01:33.545]                         if (!has_future || version < "1.8.0") {
[11:01:33.545]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.545]                             "", base::R.version$version.string), 
[11:01:33.545]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.545]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.545]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.545]                               "release", "version")], collapse = " "), 
[11:01:33.545]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.545]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.545]                             info)
[11:01:33.545]                           info <- base::paste(info, collapse = "; ")
[11:01:33.545]                           if (!has_future) {
[11:01:33.545]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.545]                               info)
[11:01:33.545]                           }
[11:01:33.545]                           else {
[11:01:33.545]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.545]                               info, version)
[11:01:33.545]                           }
[11:01:33.545]                           base::stop(msg)
[11:01:33.545]                         }
[11:01:33.545]                       })
[11:01:33.545]                     }
[11:01:33.545]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.545]                     base::options(mc.cores = 1L)
[11:01:33.545]                   }
[11:01:33.545]                   ...future.strategy.old <- future::plan("list")
[11:01:33.545]                   options(future.plan = NULL)
[11:01:33.545]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.545]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.545]                 }
[11:01:33.545]                 ...future.workdir <- getwd()
[11:01:33.545]             }
[11:01:33.545]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.545]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.545]         }
[11:01:33.545]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.545]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.545]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.545]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.545]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.545]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.545]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.545]             base::names(...future.oldOptions))
[11:01:33.545]     }
[11:01:33.545]     if (FALSE) {
[11:01:33.545]     }
[11:01:33.545]     else {
[11:01:33.545]         if (TRUE) {
[11:01:33.545]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.545]                 open = "w")
[11:01:33.545]         }
[11:01:33.545]         else {
[11:01:33.545]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.545]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.545]         }
[11:01:33.545]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.545]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.545]             base::sink(type = "output", split = FALSE)
[11:01:33.545]             base::close(...future.stdout)
[11:01:33.545]         }, add = TRUE)
[11:01:33.545]     }
[11:01:33.545]     ...future.frame <- base::sys.nframe()
[11:01:33.545]     ...future.conditions <- base::list()
[11:01:33.545]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.545]     if (FALSE) {
[11:01:33.545]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.545]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.545]     }
[11:01:33.545]     ...future.result <- base::tryCatch({
[11:01:33.545]         base::withCallingHandlers({
[11:01:33.545]             ...future.value <- base::withVisible(base::local({
[11:01:33.545]                 ...future.makeSendCondition <- base::local({
[11:01:33.545]                   sendCondition <- NULL
[11:01:33.545]                   function(frame = 1L) {
[11:01:33.545]                     if (is.function(sendCondition)) 
[11:01:33.545]                       return(sendCondition)
[11:01:33.545]                     ns <- getNamespace("parallel")
[11:01:33.545]                     if (exists("sendData", mode = "function", 
[11:01:33.545]                       envir = ns)) {
[11:01:33.545]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.545]                         envir = ns)
[11:01:33.545]                       envir <- sys.frame(frame)
[11:01:33.545]                       master <- NULL
[11:01:33.545]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.545]                         !identical(envir, emptyenv())) {
[11:01:33.545]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.545]                           inherits = FALSE)) {
[11:01:33.545]                           master <- get("master", mode = "list", 
[11:01:33.545]                             envir = envir, inherits = FALSE)
[11:01:33.545]                           if (inherits(master, c("SOCKnode", 
[11:01:33.545]                             "SOCK0node"))) {
[11:01:33.545]                             sendCondition <<- function(cond) {
[11:01:33.545]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.545]                                 success = TRUE)
[11:01:33.545]                               parallel_sendData(master, data)
[11:01:33.545]                             }
[11:01:33.545]                             return(sendCondition)
[11:01:33.545]                           }
[11:01:33.545]                         }
[11:01:33.545]                         frame <- frame + 1L
[11:01:33.545]                         envir <- sys.frame(frame)
[11:01:33.545]                       }
[11:01:33.545]                     }
[11:01:33.545]                     sendCondition <<- function(cond) NULL
[11:01:33.545]                   }
[11:01:33.545]                 })
[11:01:33.545]                 withCallingHandlers({
[11:01:33.545]                   2
[11:01:33.545]                 }, immediateCondition = function(cond) {
[11:01:33.545]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.545]                   sendCondition(cond)
[11:01:33.545]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.545]                   {
[11:01:33.545]                     inherits <- base::inherits
[11:01:33.545]                     invokeRestart <- base::invokeRestart
[11:01:33.545]                     is.null <- base::is.null
[11:01:33.545]                     muffled <- FALSE
[11:01:33.545]                     if (inherits(cond, "message")) {
[11:01:33.545]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.545]                       if (muffled) 
[11:01:33.545]                         invokeRestart("muffleMessage")
[11:01:33.545]                     }
[11:01:33.545]                     else if (inherits(cond, "warning")) {
[11:01:33.545]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.545]                       if (muffled) 
[11:01:33.545]                         invokeRestart("muffleWarning")
[11:01:33.545]                     }
[11:01:33.545]                     else if (inherits(cond, "condition")) {
[11:01:33.545]                       if (!is.null(pattern)) {
[11:01:33.545]                         computeRestarts <- base::computeRestarts
[11:01:33.545]                         grepl <- base::grepl
[11:01:33.545]                         restarts <- computeRestarts(cond)
[11:01:33.545]                         for (restart in restarts) {
[11:01:33.545]                           name <- restart$name
[11:01:33.545]                           if (is.null(name)) 
[11:01:33.545]                             next
[11:01:33.545]                           if (!grepl(pattern, name)) 
[11:01:33.545]                             next
[11:01:33.545]                           invokeRestart(restart)
[11:01:33.545]                           muffled <- TRUE
[11:01:33.545]                           break
[11:01:33.545]                         }
[11:01:33.545]                       }
[11:01:33.545]                     }
[11:01:33.545]                     invisible(muffled)
[11:01:33.545]                   }
[11:01:33.545]                   muffleCondition(cond)
[11:01:33.545]                 })
[11:01:33.545]             }))
[11:01:33.545]             future::FutureResult(value = ...future.value$value, 
[11:01:33.545]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.545]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.545]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.545]                     ...future.globalenv.names))
[11:01:33.545]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.545]         }, condition = base::local({
[11:01:33.545]             c <- base::c
[11:01:33.545]             inherits <- base::inherits
[11:01:33.545]             invokeRestart <- base::invokeRestart
[11:01:33.545]             length <- base::length
[11:01:33.545]             list <- base::list
[11:01:33.545]             seq.int <- base::seq.int
[11:01:33.545]             signalCondition <- base::signalCondition
[11:01:33.545]             sys.calls <- base::sys.calls
[11:01:33.545]             `[[` <- base::`[[`
[11:01:33.545]             `+` <- base::`+`
[11:01:33.545]             `<<-` <- base::`<<-`
[11:01:33.545]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.545]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.545]                   3L)]
[11:01:33.545]             }
[11:01:33.545]             function(cond) {
[11:01:33.545]                 is_error <- inherits(cond, "error")
[11:01:33.545]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.545]                   NULL)
[11:01:33.545]                 if (is_error) {
[11:01:33.545]                   sessionInformation <- function() {
[11:01:33.545]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.545]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.545]                       search = base::search(), system = base::Sys.info())
[11:01:33.545]                   }
[11:01:33.545]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.545]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.545]                     cond$call), session = sessionInformation(), 
[11:01:33.545]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.545]                   signalCondition(cond)
[11:01:33.545]                 }
[11:01:33.545]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.545]                 "immediateCondition"))) {
[11:01:33.545]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.545]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.545]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.545]                   if (TRUE && !signal) {
[11:01:33.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.545]                     {
[11:01:33.545]                       inherits <- base::inherits
[11:01:33.545]                       invokeRestart <- base::invokeRestart
[11:01:33.545]                       is.null <- base::is.null
[11:01:33.545]                       muffled <- FALSE
[11:01:33.545]                       if (inherits(cond, "message")) {
[11:01:33.545]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.545]                         if (muffled) 
[11:01:33.545]                           invokeRestart("muffleMessage")
[11:01:33.545]                       }
[11:01:33.545]                       else if (inherits(cond, "warning")) {
[11:01:33.545]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.545]                         if (muffled) 
[11:01:33.545]                           invokeRestart("muffleWarning")
[11:01:33.545]                       }
[11:01:33.545]                       else if (inherits(cond, "condition")) {
[11:01:33.545]                         if (!is.null(pattern)) {
[11:01:33.545]                           computeRestarts <- base::computeRestarts
[11:01:33.545]                           grepl <- base::grepl
[11:01:33.545]                           restarts <- computeRestarts(cond)
[11:01:33.545]                           for (restart in restarts) {
[11:01:33.545]                             name <- restart$name
[11:01:33.545]                             if (is.null(name)) 
[11:01:33.545]                               next
[11:01:33.545]                             if (!grepl(pattern, name)) 
[11:01:33.545]                               next
[11:01:33.545]                             invokeRestart(restart)
[11:01:33.545]                             muffled <- TRUE
[11:01:33.545]                             break
[11:01:33.545]                           }
[11:01:33.545]                         }
[11:01:33.545]                       }
[11:01:33.545]                       invisible(muffled)
[11:01:33.545]                     }
[11:01:33.545]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.545]                   }
[11:01:33.545]                 }
[11:01:33.545]                 else {
[11:01:33.545]                   if (TRUE) {
[11:01:33.545]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.545]                     {
[11:01:33.545]                       inherits <- base::inherits
[11:01:33.545]                       invokeRestart <- base::invokeRestart
[11:01:33.545]                       is.null <- base::is.null
[11:01:33.545]                       muffled <- FALSE
[11:01:33.545]                       if (inherits(cond, "message")) {
[11:01:33.545]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.545]                         if (muffled) 
[11:01:33.545]                           invokeRestart("muffleMessage")
[11:01:33.545]                       }
[11:01:33.545]                       else if (inherits(cond, "warning")) {
[11:01:33.545]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.545]                         if (muffled) 
[11:01:33.545]                           invokeRestart("muffleWarning")
[11:01:33.545]                       }
[11:01:33.545]                       else if (inherits(cond, "condition")) {
[11:01:33.545]                         if (!is.null(pattern)) {
[11:01:33.545]                           computeRestarts <- base::computeRestarts
[11:01:33.545]                           grepl <- base::grepl
[11:01:33.545]                           restarts <- computeRestarts(cond)
[11:01:33.545]                           for (restart in restarts) {
[11:01:33.545]                             name <- restart$name
[11:01:33.545]                             if (is.null(name)) 
[11:01:33.545]                               next
[11:01:33.545]                             if (!grepl(pattern, name)) 
[11:01:33.545]                               next
[11:01:33.545]                             invokeRestart(restart)
[11:01:33.545]                             muffled <- TRUE
[11:01:33.545]                             break
[11:01:33.545]                           }
[11:01:33.545]                         }
[11:01:33.545]                       }
[11:01:33.545]                       invisible(muffled)
[11:01:33.545]                     }
[11:01:33.545]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.545]                   }
[11:01:33.545]                 }
[11:01:33.545]             }
[11:01:33.545]         }))
[11:01:33.545]     }, error = function(ex) {
[11:01:33.545]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.545]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.545]                 ...future.rng), started = ...future.startTime, 
[11:01:33.545]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.545]             version = "1.8"), class = "FutureResult")
[11:01:33.545]     }, finally = {
[11:01:33.545]         if (!identical(...future.workdir, getwd())) 
[11:01:33.545]             setwd(...future.workdir)
[11:01:33.545]         {
[11:01:33.545]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.545]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.545]             }
[11:01:33.545]             base::options(...future.oldOptions)
[11:01:33.545]             if (.Platform$OS.type == "windows") {
[11:01:33.545]                 old_names <- names(...future.oldEnvVars)
[11:01:33.545]                 envs <- base::Sys.getenv()
[11:01:33.545]                 names <- names(envs)
[11:01:33.545]                 common <- intersect(names, old_names)
[11:01:33.545]                 added <- setdiff(names, old_names)
[11:01:33.545]                 removed <- setdiff(old_names, names)
[11:01:33.545]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.545]                   envs[common]]
[11:01:33.545]                 NAMES <- toupper(changed)
[11:01:33.545]                 args <- list()
[11:01:33.545]                 for (kk in seq_along(NAMES)) {
[11:01:33.545]                   name <- changed[[kk]]
[11:01:33.545]                   NAME <- NAMES[[kk]]
[11:01:33.545]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.545]                     next
[11:01:33.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.545]                 }
[11:01:33.545]                 NAMES <- toupper(added)
[11:01:33.545]                 for (kk in seq_along(NAMES)) {
[11:01:33.545]                   name <- added[[kk]]
[11:01:33.545]                   NAME <- NAMES[[kk]]
[11:01:33.545]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.545]                     next
[11:01:33.545]                   args[[name]] <- ""
[11:01:33.545]                 }
[11:01:33.545]                 NAMES <- toupper(removed)
[11:01:33.545]                 for (kk in seq_along(NAMES)) {
[11:01:33.545]                   name <- removed[[kk]]
[11:01:33.545]                   NAME <- NAMES[[kk]]
[11:01:33.545]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.545]                     next
[11:01:33.545]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.545]                 }
[11:01:33.545]                 if (length(args) > 0) 
[11:01:33.545]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.545]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.545]             }
[11:01:33.545]             else {
[11:01:33.545]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.545]             }
[11:01:33.545]             {
[11:01:33.545]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.545]                   0L) {
[11:01:33.545]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.545]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.545]                   base::options(opts)
[11:01:33.545]                 }
[11:01:33.545]                 {
[11:01:33.545]                   {
[11:01:33.545]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.545]                     NULL
[11:01:33.545]                   }
[11:01:33.545]                   options(future.plan = NULL)
[11:01:33.545]                   if (is.na(NA_character_)) 
[11:01:33.545]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.545]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.545]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.545]                     .init = FALSE)
[11:01:33.545]                 }
[11:01:33.545]             }
[11:01:33.545]         }
[11:01:33.545]     })
[11:01:33.545]     if (TRUE) {
[11:01:33.545]         base::sink(type = "output", split = FALSE)
[11:01:33.545]         if (TRUE) {
[11:01:33.545]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.545]         }
[11:01:33.545]         else {
[11:01:33.545]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.545]         }
[11:01:33.545]         base::close(...future.stdout)
[11:01:33.545]         ...future.stdout <- NULL
[11:01:33.545]     }
[11:01:33.545]     ...future.result$conditions <- ...future.conditions
[11:01:33.545]     ...future.result$finished <- base::Sys.time()
[11:01:33.545]     ...future.result
[11:01:33.545] }
[11:01:33.548] MultisessionFuture started
[11:01:33.548] - Launch lazy future ... done
[11:01:33.548] run() for ‘MultisessionFuture’ ... done
[11:01:33.548] getGlobalsAndPackages() ...
[11:01:33.548] Searching for globals...
[11:01:33.548] 
[11:01:33.549] Searching for globals ... DONE
[11:01:33.549] - globals: [0] <none>
[11:01:33.549] getGlobalsAndPackages() ... DONE
[11:01:33.549] run() for ‘Future’ ...
[11:01:33.549] - state: ‘created’
[11:01:33.549] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.563] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.563] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.564]   - Field: ‘node’
[11:01:33.564]   - Field: ‘label’
[11:01:33.564]   - Field: ‘local’
[11:01:33.564]   - Field: ‘owner’
[11:01:33.564]   - Field: ‘envir’
[11:01:33.564]   - Field: ‘workers’
[11:01:33.564]   - Field: ‘packages’
[11:01:33.564]   - Field: ‘gc’
[11:01:33.564]   - Field: ‘conditions’
[11:01:33.564]   - Field: ‘persistent’
[11:01:33.564]   - Field: ‘expr’
[11:01:33.565]   - Field: ‘uuid’
[11:01:33.565]   - Field: ‘seed’
[11:01:33.565]   - Field: ‘version’
[11:01:33.565]   - Field: ‘result’
[11:01:33.565]   - Field: ‘asynchronous’
[11:01:33.565]   - Field: ‘calls’
[11:01:33.565]   - Field: ‘globals’
[11:01:33.565]   - Field: ‘stdout’
[11:01:33.565]   - Field: ‘earlySignal’
[11:01:33.565]   - Field: ‘lazy’
[11:01:33.565]   - Field: ‘state’
[11:01:33.565] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.566] - Launch lazy future ...
[11:01:33.566] Packages needed by the future expression (n = 0): <none>
[11:01:33.566] Packages needed by future strategies (n = 0): <none>
[11:01:33.566] {
[11:01:33.566]     {
[11:01:33.566]         {
[11:01:33.566]             ...future.startTime <- base::Sys.time()
[11:01:33.566]             {
[11:01:33.566]                 {
[11:01:33.566]                   {
[11:01:33.566]                     {
[11:01:33.566]                       base::local({
[11:01:33.566]                         has_future <- base::requireNamespace("future", 
[11:01:33.566]                           quietly = TRUE)
[11:01:33.566]                         if (has_future) {
[11:01:33.566]                           ns <- base::getNamespace("future")
[11:01:33.566]                           version <- ns[[".package"]][["version"]]
[11:01:33.566]                           if (is.null(version)) 
[11:01:33.566]                             version <- utils::packageVersion("future")
[11:01:33.566]                         }
[11:01:33.566]                         else {
[11:01:33.566]                           version <- NULL
[11:01:33.566]                         }
[11:01:33.566]                         if (!has_future || version < "1.8.0") {
[11:01:33.566]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.566]                             "", base::R.version$version.string), 
[11:01:33.566]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.566]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.566]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.566]                               "release", "version")], collapse = " "), 
[11:01:33.566]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.566]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.566]                             info)
[11:01:33.566]                           info <- base::paste(info, collapse = "; ")
[11:01:33.566]                           if (!has_future) {
[11:01:33.566]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.566]                               info)
[11:01:33.566]                           }
[11:01:33.566]                           else {
[11:01:33.566]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.566]                               info, version)
[11:01:33.566]                           }
[11:01:33.566]                           base::stop(msg)
[11:01:33.566]                         }
[11:01:33.566]                       })
[11:01:33.566]                     }
[11:01:33.566]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.566]                     base::options(mc.cores = 1L)
[11:01:33.566]                   }
[11:01:33.566]                   ...future.strategy.old <- future::plan("list")
[11:01:33.566]                   options(future.plan = NULL)
[11:01:33.566]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.566]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.566]                 }
[11:01:33.566]                 ...future.workdir <- getwd()
[11:01:33.566]             }
[11:01:33.566]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.566]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.566]         }
[11:01:33.566]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.566]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.566]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.566]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.566]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.566]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.566]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.566]             base::names(...future.oldOptions))
[11:01:33.566]     }
[11:01:33.566]     if (FALSE) {
[11:01:33.566]     }
[11:01:33.566]     else {
[11:01:33.566]         if (TRUE) {
[11:01:33.566]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.566]                 open = "w")
[11:01:33.566]         }
[11:01:33.566]         else {
[11:01:33.566]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.566]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.566]         }
[11:01:33.566]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.566]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.566]             base::sink(type = "output", split = FALSE)
[11:01:33.566]             base::close(...future.stdout)
[11:01:33.566]         }, add = TRUE)
[11:01:33.566]     }
[11:01:33.566]     ...future.frame <- base::sys.nframe()
[11:01:33.566]     ...future.conditions <- base::list()
[11:01:33.566]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.566]     if (FALSE) {
[11:01:33.566]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.566]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.566]     }
[11:01:33.566]     ...future.result <- base::tryCatch({
[11:01:33.566]         base::withCallingHandlers({
[11:01:33.566]             ...future.value <- base::withVisible(base::local({
[11:01:33.566]                 ...future.makeSendCondition <- base::local({
[11:01:33.566]                   sendCondition <- NULL
[11:01:33.566]                   function(frame = 1L) {
[11:01:33.566]                     if (is.function(sendCondition)) 
[11:01:33.566]                       return(sendCondition)
[11:01:33.566]                     ns <- getNamespace("parallel")
[11:01:33.566]                     if (exists("sendData", mode = "function", 
[11:01:33.566]                       envir = ns)) {
[11:01:33.566]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.566]                         envir = ns)
[11:01:33.566]                       envir <- sys.frame(frame)
[11:01:33.566]                       master <- NULL
[11:01:33.566]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.566]                         !identical(envir, emptyenv())) {
[11:01:33.566]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.566]                           inherits = FALSE)) {
[11:01:33.566]                           master <- get("master", mode = "list", 
[11:01:33.566]                             envir = envir, inherits = FALSE)
[11:01:33.566]                           if (inherits(master, c("SOCKnode", 
[11:01:33.566]                             "SOCK0node"))) {
[11:01:33.566]                             sendCondition <<- function(cond) {
[11:01:33.566]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.566]                                 success = TRUE)
[11:01:33.566]                               parallel_sendData(master, data)
[11:01:33.566]                             }
[11:01:33.566]                             return(sendCondition)
[11:01:33.566]                           }
[11:01:33.566]                         }
[11:01:33.566]                         frame <- frame + 1L
[11:01:33.566]                         envir <- sys.frame(frame)
[11:01:33.566]                       }
[11:01:33.566]                     }
[11:01:33.566]                     sendCondition <<- function(cond) NULL
[11:01:33.566]                   }
[11:01:33.566]                 })
[11:01:33.566]                 withCallingHandlers({
[11:01:33.566]                   NULL
[11:01:33.566]                 }, immediateCondition = function(cond) {
[11:01:33.566]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.566]                   sendCondition(cond)
[11:01:33.566]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.566]                   {
[11:01:33.566]                     inherits <- base::inherits
[11:01:33.566]                     invokeRestart <- base::invokeRestart
[11:01:33.566]                     is.null <- base::is.null
[11:01:33.566]                     muffled <- FALSE
[11:01:33.566]                     if (inherits(cond, "message")) {
[11:01:33.566]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.566]                       if (muffled) 
[11:01:33.566]                         invokeRestart("muffleMessage")
[11:01:33.566]                     }
[11:01:33.566]                     else if (inherits(cond, "warning")) {
[11:01:33.566]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.566]                       if (muffled) 
[11:01:33.566]                         invokeRestart("muffleWarning")
[11:01:33.566]                     }
[11:01:33.566]                     else if (inherits(cond, "condition")) {
[11:01:33.566]                       if (!is.null(pattern)) {
[11:01:33.566]                         computeRestarts <- base::computeRestarts
[11:01:33.566]                         grepl <- base::grepl
[11:01:33.566]                         restarts <- computeRestarts(cond)
[11:01:33.566]                         for (restart in restarts) {
[11:01:33.566]                           name <- restart$name
[11:01:33.566]                           if (is.null(name)) 
[11:01:33.566]                             next
[11:01:33.566]                           if (!grepl(pattern, name)) 
[11:01:33.566]                             next
[11:01:33.566]                           invokeRestart(restart)
[11:01:33.566]                           muffled <- TRUE
[11:01:33.566]                           break
[11:01:33.566]                         }
[11:01:33.566]                       }
[11:01:33.566]                     }
[11:01:33.566]                     invisible(muffled)
[11:01:33.566]                   }
[11:01:33.566]                   muffleCondition(cond)
[11:01:33.566]                 })
[11:01:33.566]             }))
[11:01:33.566]             future::FutureResult(value = ...future.value$value, 
[11:01:33.566]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.566]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.566]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.566]                     ...future.globalenv.names))
[11:01:33.566]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.566]         }, condition = base::local({
[11:01:33.566]             c <- base::c
[11:01:33.566]             inherits <- base::inherits
[11:01:33.566]             invokeRestart <- base::invokeRestart
[11:01:33.566]             length <- base::length
[11:01:33.566]             list <- base::list
[11:01:33.566]             seq.int <- base::seq.int
[11:01:33.566]             signalCondition <- base::signalCondition
[11:01:33.566]             sys.calls <- base::sys.calls
[11:01:33.566]             `[[` <- base::`[[`
[11:01:33.566]             `+` <- base::`+`
[11:01:33.566]             `<<-` <- base::`<<-`
[11:01:33.566]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.566]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.566]                   3L)]
[11:01:33.566]             }
[11:01:33.566]             function(cond) {
[11:01:33.566]                 is_error <- inherits(cond, "error")
[11:01:33.566]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.566]                   NULL)
[11:01:33.566]                 if (is_error) {
[11:01:33.566]                   sessionInformation <- function() {
[11:01:33.566]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.566]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.566]                       search = base::search(), system = base::Sys.info())
[11:01:33.566]                   }
[11:01:33.566]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.566]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.566]                     cond$call), session = sessionInformation(), 
[11:01:33.566]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.566]                   signalCondition(cond)
[11:01:33.566]                 }
[11:01:33.566]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.566]                 "immediateCondition"))) {
[11:01:33.566]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.566]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.566]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.566]                   if (TRUE && !signal) {
[11:01:33.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.566]                     {
[11:01:33.566]                       inherits <- base::inherits
[11:01:33.566]                       invokeRestart <- base::invokeRestart
[11:01:33.566]                       is.null <- base::is.null
[11:01:33.566]                       muffled <- FALSE
[11:01:33.566]                       if (inherits(cond, "message")) {
[11:01:33.566]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.566]                         if (muffled) 
[11:01:33.566]                           invokeRestart("muffleMessage")
[11:01:33.566]                       }
[11:01:33.566]                       else if (inherits(cond, "warning")) {
[11:01:33.566]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.566]                         if (muffled) 
[11:01:33.566]                           invokeRestart("muffleWarning")
[11:01:33.566]                       }
[11:01:33.566]                       else if (inherits(cond, "condition")) {
[11:01:33.566]                         if (!is.null(pattern)) {
[11:01:33.566]                           computeRestarts <- base::computeRestarts
[11:01:33.566]                           grepl <- base::grepl
[11:01:33.566]                           restarts <- computeRestarts(cond)
[11:01:33.566]                           for (restart in restarts) {
[11:01:33.566]                             name <- restart$name
[11:01:33.566]                             if (is.null(name)) 
[11:01:33.566]                               next
[11:01:33.566]                             if (!grepl(pattern, name)) 
[11:01:33.566]                               next
[11:01:33.566]                             invokeRestart(restart)
[11:01:33.566]                             muffled <- TRUE
[11:01:33.566]                             break
[11:01:33.566]                           }
[11:01:33.566]                         }
[11:01:33.566]                       }
[11:01:33.566]                       invisible(muffled)
[11:01:33.566]                     }
[11:01:33.566]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.566]                   }
[11:01:33.566]                 }
[11:01:33.566]                 else {
[11:01:33.566]                   if (TRUE) {
[11:01:33.566]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.566]                     {
[11:01:33.566]                       inherits <- base::inherits
[11:01:33.566]                       invokeRestart <- base::invokeRestart
[11:01:33.566]                       is.null <- base::is.null
[11:01:33.566]                       muffled <- FALSE
[11:01:33.566]                       if (inherits(cond, "message")) {
[11:01:33.566]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.566]                         if (muffled) 
[11:01:33.566]                           invokeRestart("muffleMessage")
[11:01:33.566]                       }
[11:01:33.566]                       else if (inherits(cond, "warning")) {
[11:01:33.566]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.566]                         if (muffled) 
[11:01:33.566]                           invokeRestart("muffleWarning")
[11:01:33.566]                       }
[11:01:33.566]                       else if (inherits(cond, "condition")) {
[11:01:33.566]                         if (!is.null(pattern)) {
[11:01:33.566]                           computeRestarts <- base::computeRestarts
[11:01:33.566]                           grepl <- base::grepl
[11:01:33.566]                           restarts <- computeRestarts(cond)
[11:01:33.566]                           for (restart in restarts) {
[11:01:33.566]                             name <- restart$name
[11:01:33.566]                             if (is.null(name)) 
[11:01:33.566]                               next
[11:01:33.566]                             if (!grepl(pattern, name)) 
[11:01:33.566]                               next
[11:01:33.566]                             invokeRestart(restart)
[11:01:33.566]                             muffled <- TRUE
[11:01:33.566]                             break
[11:01:33.566]                           }
[11:01:33.566]                         }
[11:01:33.566]                       }
[11:01:33.566]                       invisible(muffled)
[11:01:33.566]                     }
[11:01:33.566]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.566]                   }
[11:01:33.566]                 }
[11:01:33.566]             }
[11:01:33.566]         }))
[11:01:33.566]     }, error = function(ex) {
[11:01:33.566]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.566]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.566]                 ...future.rng), started = ...future.startTime, 
[11:01:33.566]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.566]             version = "1.8"), class = "FutureResult")
[11:01:33.566]     }, finally = {
[11:01:33.566]         if (!identical(...future.workdir, getwd())) 
[11:01:33.566]             setwd(...future.workdir)
[11:01:33.566]         {
[11:01:33.566]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.566]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.566]             }
[11:01:33.566]             base::options(...future.oldOptions)
[11:01:33.566]             if (.Platform$OS.type == "windows") {
[11:01:33.566]                 old_names <- names(...future.oldEnvVars)
[11:01:33.566]                 envs <- base::Sys.getenv()
[11:01:33.566]                 names <- names(envs)
[11:01:33.566]                 common <- intersect(names, old_names)
[11:01:33.566]                 added <- setdiff(names, old_names)
[11:01:33.566]                 removed <- setdiff(old_names, names)
[11:01:33.566]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.566]                   envs[common]]
[11:01:33.566]                 NAMES <- toupper(changed)
[11:01:33.566]                 args <- list()
[11:01:33.566]                 for (kk in seq_along(NAMES)) {
[11:01:33.566]                   name <- changed[[kk]]
[11:01:33.566]                   NAME <- NAMES[[kk]]
[11:01:33.566]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.566]                     next
[11:01:33.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.566]                 }
[11:01:33.566]                 NAMES <- toupper(added)
[11:01:33.566]                 for (kk in seq_along(NAMES)) {
[11:01:33.566]                   name <- added[[kk]]
[11:01:33.566]                   NAME <- NAMES[[kk]]
[11:01:33.566]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.566]                     next
[11:01:33.566]                   args[[name]] <- ""
[11:01:33.566]                 }
[11:01:33.566]                 NAMES <- toupper(removed)
[11:01:33.566]                 for (kk in seq_along(NAMES)) {
[11:01:33.566]                   name <- removed[[kk]]
[11:01:33.566]                   NAME <- NAMES[[kk]]
[11:01:33.566]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.566]                     next
[11:01:33.566]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.566]                 }
[11:01:33.566]                 if (length(args) > 0) 
[11:01:33.566]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.566]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.566]             }
[11:01:33.566]             else {
[11:01:33.566]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.566]             }
[11:01:33.566]             {
[11:01:33.566]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.566]                   0L) {
[11:01:33.566]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.566]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.566]                   base::options(opts)
[11:01:33.566]                 }
[11:01:33.566]                 {
[11:01:33.566]                   {
[11:01:33.566]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.566]                     NULL
[11:01:33.566]                   }
[11:01:33.566]                   options(future.plan = NULL)
[11:01:33.566]                   if (is.na(NA_character_)) 
[11:01:33.566]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.566]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.566]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.566]                     .init = FALSE)
[11:01:33.566]                 }
[11:01:33.566]             }
[11:01:33.566]         }
[11:01:33.566]     })
[11:01:33.566]     if (TRUE) {
[11:01:33.566]         base::sink(type = "output", split = FALSE)
[11:01:33.566]         if (TRUE) {
[11:01:33.566]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.566]         }
[11:01:33.566]         else {
[11:01:33.566]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.566]         }
[11:01:33.566]         base::close(...future.stdout)
[11:01:33.566]         ...future.stdout <- NULL
[11:01:33.566]     }
[11:01:33.566]     ...future.result$conditions <- ...future.conditions
[11:01:33.566]     ...future.result$finished <- base::Sys.time()
[11:01:33.566]     ...future.result
[11:01:33.566] }
[11:01:33.569] MultisessionFuture started
[11:01:33.569] - Launch lazy future ... done
[11:01:33.569] run() for ‘MultisessionFuture’ ... done
[11:01:33.570] getGlobalsAndPackages() ...
[11:01:33.570] Searching for globals...
[11:01:33.570] - globals found: [1] ‘{’
[11:01:33.571] Searching for globals ... DONE
[11:01:33.571] Resolving globals: FALSE
[11:01:33.571] 
[11:01:33.571] 
[11:01:33.571] getGlobalsAndPackages() ... DONE
[11:01:33.571] run() for ‘Future’ ...
[11:01:33.571] - state: ‘created’
[11:01:33.571] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.585] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.585] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.586]   - Field: ‘node’
[11:01:33.586]   - Field: ‘label’
[11:01:33.588]   - Field: ‘local’
[11:01:33.588]   - Field: ‘owner’
[11:01:33.588]   - Field: ‘envir’
[11:01:33.589]   - Field: ‘workers’
[11:01:33.589]   - Field: ‘packages’
[11:01:33.589]   - Field: ‘gc’
[11:01:33.589]   - Field: ‘conditions’
[11:01:33.589]   - Field: ‘persistent’
[11:01:33.589]   - Field: ‘expr’
[11:01:33.589]   - Field: ‘uuid’
[11:01:33.589]   - Field: ‘seed’
[11:01:33.589]   - Field: ‘version’
[11:01:33.589]   - Field: ‘result’
[11:01:33.589]   - Field: ‘asynchronous’
[11:01:33.590]   - Field: ‘calls’
[11:01:33.590]   - Field: ‘globals’
[11:01:33.590]   - Field: ‘stdout’
[11:01:33.590]   - Field: ‘earlySignal’
[11:01:33.590]   - Field: ‘lazy’
[11:01:33.590]   - Field: ‘state’
[11:01:33.590] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.590] - Launch lazy future ...
[11:01:33.590] Packages needed by the future expression (n = 0): <none>
[11:01:33.590] Packages needed by future strategies (n = 0): <none>
[11:01:33.591] {
[11:01:33.591]     {
[11:01:33.591]         {
[11:01:33.591]             ...future.startTime <- base::Sys.time()
[11:01:33.591]             {
[11:01:33.591]                 {
[11:01:33.591]                   {
[11:01:33.591]                     {
[11:01:33.591]                       base::local({
[11:01:33.591]                         has_future <- base::requireNamespace("future", 
[11:01:33.591]                           quietly = TRUE)
[11:01:33.591]                         if (has_future) {
[11:01:33.591]                           ns <- base::getNamespace("future")
[11:01:33.591]                           version <- ns[[".package"]][["version"]]
[11:01:33.591]                           if (is.null(version)) 
[11:01:33.591]                             version <- utils::packageVersion("future")
[11:01:33.591]                         }
[11:01:33.591]                         else {
[11:01:33.591]                           version <- NULL
[11:01:33.591]                         }
[11:01:33.591]                         if (!has_future || version < "1.8.0") {
[11:01:33.591]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.591]                             "", base::R.version$version.string), 
[11:01:33.591]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.591]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.591]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.591]                               "release", "version")], collapse = " "), 
[11:01:33.591]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.591]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.591]                             info)
[11:01:33.591]                           info <- base::paste(info, collapse = "; ")
[11:01:33.591]                           if (!has_future) {
[11:01:33.591]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.591]                               info)
[11:01:33.591]                           }
[11:01:33.591]                           else {
[11:01:33.591]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.591]                               info, version)
[11:01:33.591]                           }
[11:01:33.591]                           base::stop(msg)
[11:01:33.591]                         }
[11:01:33.591]                       })
[11:01:33.591]                     }
[11:01:33.591]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.591]                     base::options(mc.cores = 1L)
[11:01:33.591]                   }
[11:01:33.591]                   ...future.strategy.old <- future::plan("list")
[11:01:33.591]                   options(future.plan = NULL)
[11:01:33.591]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.591]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.591]                 }
[11:01:33.591]                 ...future.workdir <- getwd()
[11:01:33.591]             }
[11:01:33.591]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.591]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.591]         }
[11:01:33.591]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.591]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.591]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.591]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.591]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.591]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.591]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.591]             base::names(...future.oldOptions))
[11:01:33.591]     }
[11:01:33.591]     if (FALSE) {
[11:01:33.591]     }
[11:01:33.591]     else {
[11:01:33.591]         if (TRUE) {
[11:01:33.591]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.591]                 open = "w")
[11:01:33.591]         }
[11:01:33.591]         else {
[11:01:33.591]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.591]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.591]         }
[11:01:33.591]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.591]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.591]             base::sink(type = "output", split = FALSE)
[11:01:33.591]             base::close(...future.stdout)
[11:01:33.591]         }, add = TRUE)
[11:01:33.591]     }
[11:01:33.591]     ...future.frame <- base::sys.nframe()
[11:01:33.591]     ...future.conditions <- base::list()
[11:01:33.591]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.591]     if (FALSE) {
[11:01:33.591]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.591]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.591]     }
[11:01:33.591]     ...future.result <- base::tryCatch({
[11:01:33.591]         base::withCallingHandlers({
[11:01:33.591]             ...future.value <- base::withVisible(base::local({
[11:01:33.591]                 ...future.makeSendCondition <- base::local({
[11:01:33.591]                   sendCondition <- NULL
[11:01:33.591]                   function(frame = 1L) {
[11:01:33.591]                     if (is.function(sendCondition)) 
[11:01:33.591]                       return(sendCondition)
[11:01:33.591]                     ns <- getNamespace("parallel")
[11:01:33.591]                     if (exists("sendData", mode = "function", 
[11:01:33.591]                       envir = ns)) {
[11:01:33.591]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.591]                         envir = ns)
[11:01:33.591]                       envir <- sys.frame(frame)
[11:01:33.591]                       master <- NULL
[11:01:33.591]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.591]                         !identical(envir, emptyenv())) {
[11:01:33.591]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.591]                           inherits = FALSE)) {
[11:01:33.591]                           master <- get("master", mode = "list", 
[11:01:33.591]                             envir = envir, inherits = FALSE)
[11:01:33.591]                           if (inherits(master, c("SOCKnode", 
[11:01:33.591]                             "SOCK0node"))) {
[11:01:33.591]                             sendCondition <<- function(cond) {
[11:01:33.591]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.591]                                 success = TRUE)
[11:01:33.591]                               parallel_sendData(master, data)
[11:01:33.591]                             }
[11:01:33.591]                             return(sendCondition)
[11:01:33.591]                           }
[11:01:33.591]                         }
[11:01:33.591]                         frame <- frame + 1L
[11:01:33.591]                         envir <- sys.frame(frame)
[11:01:33.591]                       }
[11:01:33.591]                     }
[11:01:33.591]                     sendCondition <<- function(cond) NULL
[11:01:33.591]                   }
[11:01:33.591]                 })
[11:01:33.591]                 withCallingHandlers({
[11:01:33.591]                   {
[11:01:33.591]                     4
[11:01:33.591]                   }
[11:01:33.591]                 }, immediateCondition = function(cond) {
[11:01:33.591]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.591]                   sendCondition(cond)
[11:01:33.591]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.591]                   {
[11:01:33.591]                     inherits <- base::inherits
[11:01:33.591]                     invokeRestart <- base::invokeRestart
[11:01:33.591]                     is.null <- base::is.null
[11:01:33.591]                     muffled <- FALSE
[11:01:33.591]                     if (inherits(cond, "message")) {
[11:01:33.591]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.591]                       if (muffled) 
[11:01:33.591]                         invokeRestart("muffleMessage")
[11:01:33.591]                     }
[11:01:33.591]                     else if (inherits(cond, "warning")) {
[11:01:33.591]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.591]                       if (muffled) 
[11:01:33.591]                         invokeRestart("muffleWarning")
[11:01:33.591]                     }
[11:01:33.591]                     else if (inherits(cond, "condition")) {
[11:01:33.591]                       if (!is.null(pattern)) {
[11:01:33.591]                         computeRestarts <- base::computeRestarts
[11:01:33.591]                         grepl <- base::grepl
[11:01:33.591]                         restarts <- computeRestarts(cond)
[11:01:33.591]                         for (restart in restarts) {
[11:01:33.591]                           name <- restart$name
[11:01:33.591]                           if (is.null(name)) 
[11:01:33.591]                             next
[11:01:33.591]                           if (!grepl(pattern, name)) 
[11:01:33.591]                             next
[11:01:33.591]                           invokeRestart(restart)
[11:01:33.591]                           muffled <- TRUE
[11:01:33.591]                           break
[11:01:33.591]                         }
[11:01:33.591]                       }
[11:01:33.591]                     }
[11:01:33.591]                     invisible(muffled)
[11:01:33.591]                   }
[11:01:33.591]                   muffleCondition(cond)
[11:01:33.591]                 })
[11:01:33.591]             }))
[11:01:33.591]             future::FutureResult(value = ...future.value$value, 
[11:01:33.591]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.591]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.591]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.591]                     ...future.globalenv.names))
[11:01:33.591]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.591]         }, condition = base::local({
[11:01:33.591]             c <- base::c
[11:01:33.591]             inherits <- base::inherits
[11:01:33.591]             invokeRestart <- base::invokeRestart
[11:01:33.591]             length <- base::length
[11:01:33.591]             list <- base::list
[11:01:33.591]             seq.int <- base::seq.int
[11:01:33.591]             signalCondition <- base::signalCondition
[11:01:33.591]             sys.calls <- base::sys.calls
[11:01:33.591]             `[[` <- base::`[[`
[11:01:33.591]             `+` <- base::`+`
[11:01:33.591]             `<<-` <- base::`<<-`
[11:01:33.591]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.591]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.591]                   3L)]
[11:01:33.591]             }
[11:01:33.591]             function(cond) {
[11:01:33.591]                 is_error <- inherits(cond, "error")
[11:01:33.591]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.591]                   NULL)
[11:01:33.591]                 if (is_error) {
[11:01:33.591]                   sessionInformation <- function() {
[11:01:33.591]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.591]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.591]                       search = base::search(), system = base::Sys.info())
[11:01:33.591]                   }
[11:01:33.591]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.591]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.591]                     cond$call), session = sessionInformation(), 
[11:01:33.591]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.591]                   signalCondition(cond)
[11:01:33.591]                 }
[11:01:33.591]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.591]                 "immediateCondition"))) {
[11:01:33.591]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.591]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.591]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.591]                   if (TRUE && !signal) {
[11:01:33.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.591]                     {
[11:01:33.591]                       inherits <- base::inherits
[11:01:33.591]                       invokeRestart <- base::invokeRestart
[11:01:33.591]                       is.null <- base::is.null
[11:01:33.591]                       muffled <- FALSE
[11:01:33.591]                       if (inherits(cond, "message")) {
[11:01:33.591]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.591]                         if (muffled) 
[11:01:33.591]                           invokeRestart("muffleMessage")
[11:01:33.591]                       }
[11:01:33.591]                       else if (inherits(cond, "warning")) {
[11:01:33.591]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.591]                         if (muffled) 
[11:01:33.591]                           invokeRestart("muffleWarning")
[11:01:33.591]                       }
[11:01:33.591]                       else if (inherits(cond, "condition")) {
[11:01:33.591]                         if (!is.null(pattern)) {
[11:01:33.591]                           computeRestarts <- base::computeRestarts
[11:01:33.591]                           grepl <- base::grepl
[11:01:33.591]                           restarts <- computeRestarts(cond)
[11:01:33.591]                           for (restart in restarts) {
[11:01:33.591]                             name <- restart$name
[11:01:33.591]                             if (is.null(name)) 
[11:01:33.591]                               next
[11:01:33.591]                             if (!grepl(pattern, name)) 
[11:01:33.591]                               next
[11:01:33.591]                             invokeRestart(restart)
[11:01:33.591]                             muffled <- TRUE
[11:01:33.591]                             break
[11:01:33.591]                           }
[11:01:33.591]                         }
[11:01:33.591]                       }
[11:01:33.591]                       invisible(muffled)
[11:01:33.591]                     }
[11:01:33.591]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.591]                   }
[11:01:33.591]                 }
[11:01:33.591]                 else {
[11:01:33.591]                   if (TRUE) {
[11:01:33.591]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.591]                     {
[11:01:33.591]                       inherits <- base::inherits
[11:01:33.591]                       invokeRestart <- base::invokeRestart
[11:01:33.591]                       is.null <- base::is.null
[11:01:33.591]                       muffled <- FALSE
[11:01:33.591]                       if (inherits(cond, "message")) {
[11:01:33.591]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.591]                         if (muffled) 
[11:01:33.591]                           invokeRestart("muffleMessage")
[11:01:33.591]                       }
[11:01:33.591]                       else if (inherits(cond, "warning")) {
[11:01:33.591]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.591]                         if (muffled) 
[11:01:33.591]                           invokeRestart("muffleWarning")
[11:01:33.591]                       }
[11:01:33.591]                       else if (inherits(cond, "condition")) {
[11:01:33.591]                         if (!is.null(pattern)) {
[11:01:33.591]                           computeRestarts <- base::computeRestarts
[11:01:33.591]                           grepl <- base::grepl
[11:01:33.591]                           restarts <- computeRestarts(cond)
[11:01:33.591]                           for (restart in restarts) {
[11:01:33.591]                             name <- restart$name
[11:01:33.591]                             if (is.null(name)) 
[11:01:33.591]                               next
[11:01:33.591]                             if (!grepl(pattern, name)) 
[11:01:33.591]                               next
[11:01:33.591]                             invokeRestart(restart)
[11:01:33.591]                             muffled <- TRUE
[11:01:33.591]                             break
[11:01:33.591]                           }
[11:01:33.591]                         }
[11:01:33.591]                       }
[11:01:33.591]                       invisible(muffled)
[11:01:33.591]                     }
[11:01:33.591]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.591]                   }
[11:01:33.591]                 }
[11:01:33.591]             }
[11:01:33.591]         }))
[11:01:33.591]     }, error = function(ex) {
[11:01:33.591]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.591]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.591]                 ...future.rng), started = ...future.startTime, 
[11:01:33.591]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.591]             version = "1.8"), class = "FutureResult")
[11:01:33.591]     }, finally = {
[11:01:33.591]         if (!identical(...future.workdir, getwd())) 
[11:01:33.591]             setwd(...future.workdir)
[11:01:33.591]         {
[11:01:33.591]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.591]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.591]             }
[11:01:33.591]             base::options(...future.oldOptions)
[11:01:33.591]             if (.Platform$OS.type == "windows") {
[11:01:33.591]                 old_names <- names(...future.oldEnvVars)
[11:01:33.591]                 envs <- base::Sys.getenv()
[11:01:33.591]                 names <- names(envs)
[11:01:33.591]                 common <- intersect(names, old_names)
[11:01:33.591]                 added <- setdiff(names, old_names)
[11:01:33.591]                 removed <- setdiff(old_names, names)
[11:01:33.591]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.591]                   envs[common]]
[11:01:33.591]                 NAMES <- toupper(changed)
[11:01:33.591]                 args <- list()
[11:01:33.591]                 for (kk in seq_along(NAMES)) {
[11:01:33.591]                   name <- changed[[kk]]
[11:01:33.591]                   NAME <- NAMES[[kk]]
[11:01:33.591]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.591]                     next
[11:01:33.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.591]                 }
[11:01:33.591]                 NAMES <- toupper(added)
[11:01:33.591]                 for (kk in seq_along(NAMES)) {
[11:01:33.591]                   name <- added[[kk]]
[11:01:33.591]                   NAME <- NAMES[[kk]]
[11:01:33.591]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.591]                     next
[11:01:33.591]                   args[[name]] <- ""
[11:01:33.591]                 }
[11:01:33.591]                 NAMES <- toupper(removed)
[11:01:33.591]                 for (kk in seq_along(NAMES)) {
[11:01:33.591]                   name <- removed[[kk]]
[11:01:33.591]                   NAME <- NAMES[[kk]]
[11:01:33.591]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.591]                     next
[11:01:33.591]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.591]                 }
[11:01:33.591]                 if (length(args) > 0) 
[11:01:33.591]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.591]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.591]             }
[11:01:33.591]             else {
[11:01:33.591]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.591]             }
[11:01:33.591]             {
[11:01:33.591]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.591]                   0L) {
[11:01:33.591]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.591]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.591]                   base::options(opts)
[11:01:33.591]                 }
[11:01:33.591]                 {
[11:01:33.591]                   {
[11:01:33.591]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.591]                     NULL
[11:01:33.591]                   }
[11:01:33.591]                   options(future.plan = NULL)
[11:01:33.591]                   if (is.na(NA_character_)) 
[11:01:33.591]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.591]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.591]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.591]                     .init = FALSE)
[11:01:33.591]                 }
[11:01:33.591]             }
[11:01:33.591]         }
[11:01:33.591]     })
[11:01:33.591]     if (TRUE) {
[11:01:33.591]         base::sink(type = "output", split = FALSE)
[11:01:33.591]         if (TRUE) {
[11:01:33.591]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.591]         }
[11:01:33.591]         else {
[11:01:33.591]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.591]         }
[11:01:33.591]         base::close(...future.stdout)
[11:01:33.591]         ...future.stdout <- NULL
[11:01:33.591]     }
[11:01:33.591]     ...future.result$conditions <- ...future.conditions
[11:01:33.591]     ...future.result$finished <- base::Sys.time()
[11:01:33.591]     ...future.result
[11:01:33.591] }
[11:01:33.593] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:33.604] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.604] - Validating connection of MultisessionFuture
[11:01:33.604] - received message: FutureResult
[11:01:33.604] - Received FutureResult
[11:01:33.604] - Erased future from FutureRegistry
[11:01:33.605] result() for ClusterFuture ...
[11:01:33.605] - result already collected: FutureResult
[11:01:33.605] result() for ClusterFuture ... done
[11:01:33.605] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.605] result() for ClusterFuture ...
[11:01:33.605] - result already collected: FutureResult
[11:01:33.605] result() for ClusterFuture ... done
[11:01:33.605] result() for ClusterFuture ...
[11:01:33.605] - result already collected: FutureResult
[11:01:33.605] result() for ClusterFuture ... done
[11:01:33.606] MultisessionFuture started
[11:01:33.606] - Launch lazy future ... done
[11:01:33.606] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c8246da0> 
Classes 'listenv', 'environment' <environment: 0x55a9c6b632a0> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[11:01:33.611] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.611] - Validating connection of MultisessionFuture
[11:01:33.611] - received message: FutureResult
[11:01:33.612] - Received FutureResult
[11:01:33.612] - Erased future from FutureRegistry
[11:01:33.612] result() for ClusterFuture ...
[11:01:33.612] - result already collected: FutureResult
[11:01:33.612] result() for ClusterFuture ... done
[11:01:33.612] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:33.625] resolve() on list environment ...
[11:01:33.625]  recursive: 0
[11:01:33.626]  length: 6
[11:01:33.626]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:33.626] signalConditionsASAP(numeric, pos=1) ...
[11:01:33.626] - nx: 6
[11:01:33.627] - relay: TRUE
[11:01:33.627] - stdout: TRUE
[11:01:33.627] - signal: TRUE
[11:01:33.627] - resignal: FALSE
[11:01:33.627] - force: TRUE
[11:01:33.627] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.627] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.627]  - until=2
[11:01:33.627]  - relaying element #2
[11:01:33.627] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.627] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.627] signalConditionsASAP(NULL, pos=1) ... done
[11:01:33.627]  length: 5 (resolved future 1)
[11:01:33.628] Future #2
[11:01:33.628] result() for ClusterFuture ...
[11:01:33.628] - result already collected: FutureResult
[11:01:33.628] result() for ClusterFuture ... done
[11:01:33.628] result() for ClusterFuture ...
[11:01:33.628] - result already collected: FutureResult
[11:01:33.628] result() for ClusterFuture ... done
[11:01:33.628] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:33.628] - nx: 6
[11:01:33.628] - relay: TRUE
[11:01:33.628] - stdout: TRUE
[11:01:33.628] - signal: TRUE
[11:01:33.629] - resignal: FALSE
[11:01:33.629] - force: TRUE
[11:01:33.629] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.629] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.629]  - until=2
[11:01:33.629]  - relaying element #2
[11:01:33.629] result() for ClusterFuture ...
[11:01:33.629] - result already collected: FutureResult
[11:01:33.629] result() for ClusterFuture ... done
[11:01:33.629] result() for ClusterFuture ...
[11:01:33.629] - result already collected: FutureResult
[11:01:33.629] result() for ClusterFuture ... done
[11:01:33.630] result() for ClusterFuture ...
[11:01:33.630] - result already collected: FutureResult
[11:01:33.630] result() for ClusterFuture ... done
[11:01:33.630] result() for ClusterFuture ...
[11:01:33.630] - result already collected: FutureResult
[11:01:33.630] result() for ClusterFuture ... done
[11:01:33.630] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.630] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.630] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:33.630]  length: 4 (resolved future 2)
[11:01:33.630] Future #3
[11:01:33.631] result() for ClusterFuture ...
[11:01:33.631] - result already collected: FutureResult
[11:01:33.631] result() for ClusterFuture ... done
[11:01:33.631] result() for ClusterFuture ...
[11:01:33.631] - result already collected: FutureResult
[11:01:33.631] result() for ClusterFuture ... done
[11:01:33.631] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:33.631] - nx: 6
[11:01:33.631] - relay: TRUE
[11:01:33.631] - stdout: TRUE
[11:01:33.631] - signal: TRUE
[11:01:33.631] - resignal: FALSE
[11:01:33.632] - force: TRUE
[11:01:33.632] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.632] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.632]  - until=3
[11:01:33.632]  - relaying element #3
[11:01:33.632] result() for ClusterFuture ...
[11:01:33.632] - result already collected: FutureResult
[11:01:33.632] result() for ClusterFuture ... done
[11:01:33.632] result() for ClusterFuture ...
[11:01:33.632] - result already collected: FutureResult
[11:01:33.632] result() for ClusterFuture ... done
[11:01:33.632] result() for ClusterFuture ...
[11:01:33.633] - result already collected: FutureResult
[11:01:33.633] result() for ClusterFuture ... done
[11:01:33.633] result() for ClusterFuture ...
[11:01:33.633] - result already collected: FutureResult
[11:01:33.633] result() for ClusterFuture ... done
[11:01:33.633] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.633] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.633] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:33.633]  length: 3 (resolved future 3)
[11:01:33.644] signalConditionsASAP(NULL, pos=5) ...
[11:01:33.644] - nx: 6
[11:01:33.644] - relay: TRUE
[11:01:33.644] - stdout: TRUE
[11:01:33.644] - signal: TRUE
[11:01:33.644] - resignal: FALSE
[11:01:33.644] - force: TRUE
[11:01:33.645] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.645] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.645]  - until=6
[11:01:33.645]  - relaying element #4
[11:01:33.645]  - relaying element #6
[11:01:33.645] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.645] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.645] signalConditionsASAP(NULL, pos=5) ... done
[11:01:33.645]  length: 2 (resolved future 5)
[11:01:33.645] signalConditionsASAP(numeric, pos=6) ...
[11:01:33.645] - nx: 6
[11:01:33.645] - relay: TRUE
[11:01:33.646] - stdout: TRUE
[11:01:33.646] - signal: TRUE
[11:01:33.646] - resignal: FALSE
[11:01:33.646] - force: TRUE
[11:01:33.646] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.646] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.646]  - until=6
[11:01:33.646]  - relaying element #4
[11:01:33.646] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.646] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.646] signalConditionsASAP(NULL, pos=6) ... done
[11:01:33.646]  length: 1 (resolved future 6)
[11:01:33.657] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.657] - Validating connection of MultisessionFuture
[11:01:33.658] - received message: FutureResult
[11:01:33.658] - Received FutureResult
[11:01:33.658] - Erased future from FutureRegistry
[11:01:33.658] result() for ClusterFuture ...
[11:01:33.658] - result already collected: FutureResult
[11:01:33.658] result() for ClusterFuture ... done
[11:01:33.658] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.658] Future #4
[11:01:33.658] result() for ClusterFuture ...
[11:01:33.658] - result already collected: FutureResult
[11:01:33.658] result() for ClusterFuture ... done
[11:01:33.659] result() for ClusterFuture ...
[11:01:33.659] - result already collected: FutureResult
[11:01:33.659] result() for ClusterFuture ... done
[11:01:33.659] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:33.659] - nx: 6
[11:01:33.659] - relay: TRUE
[11:01:33.659] - stdout: TRUE
[11:01:33.659] - signal: TRUE
[11:01:33.659] - resignal: FALSE
[11:01:33.659] - force: TRUE
[11:01:33.660] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.660] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.660]  - until=6
[11:01:33.660]  - relaying element #4
[11:01:33.660] result() for ClusterFuture ...
[11:01:33.660] - result already collected: FutureResult
[11:01:33.660] result() for ClusterFuture ... done
[11:01:33.660] result() for ClusterFuture ...
[11:01:33.660] - result already collected: FutureResult
[11:01:33.660] result() for ClusterFuture ... done
[11:01:33.660] result() for ClusterFuture ...
[11:01:33.661] - result already collected: FutureResult
[11:01:33.661] result() for ClusterFuture ... done
[11:01:33.661] result() for ClusterFuture ...
[11:01:33.661] - result already collected: FutureResult
[11:01:33.661] result() for ClusterFuture ... done
[11:01:33.661] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.661] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.661] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:33.661]  length: 0 (resolved future 4)
[11:01:33.661] Relaying remaining futures
[11:01:33.661] signalConditionsASAP(NULL, pos=0) ...
[11:01:33.661] - nx: 6
[11:01:33.662] - relay: TRUE
[11:01:33.662] - stdout: TRUE
[11:01:33.662] - signal: TRUE
[11:01:33.662] - resignal: FALSE
[11:01:33.662] - force: TRUE
[11:01:33.662] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.662] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:33.662] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.662] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.662] signalConditionsASAP(NULL, pos=0) ... done
[11:01:33.662] resolve() on list environment ... DONE
[11:01:33.663] result() for ClusterFuture ...
[11:01:33.663] - result already collected: FutureResult
[11:01:33.663] result() for ClusterFuture ... done
[11:01:33.663] result() for ClusterFuture ...
[11:01:33.663] - result already collected: FutureResult
[11:01:33.663] result() for ClusterFuture ... done
[11:01:33.663] result() for ClusterFuture ...
[11:01:33.663] - result already collected: FutureResult
[11:01:33.663] result() for ClusterFuture ... done
[11:01:33.663] result() for ClusterFuture ...
[11:01:33.663] - result already collected: FutureResult
[11:01:33.663] result() for ClusterFuture ... done
[11:01:33.664] result() for ClusterFuture ...
[11:01:33.664] - result already collected: FutureResult
[11:01:33.664] result() for ClusterFuture ... done
[11:01:33.664] result() for ClusterFuture ...
[11:01:33.664] - result already collected: FutureResult
[11:01:33.664] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c64cb710> 
 - attr(*, "dim.")= int [1:3] 2 3 1
 - attr(*, "dimnames.")=List of 3
  ..$ : chr [1:2] "a" "b"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
Dimensions: c(2, 1, 3, 1)
[11:01:33.666] getGlobalsAndPackages() ...
[11:01:33.666] Searching for globals...
[11:01:33.666] 
[11:01:33.666] Searching for globals ... DONE
[11:01:33.666] - globals: [0] <none>
[11:01:33.667] getGlobalsAndPackages() ... DONE
[11:01:33.667] run() for ‘Future’ ...
[11:01:33.667] - state: ‘created’
[11:01:33.667] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.681] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.681] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.681]   - Field: ‘node’
[11:01:33.681]   - Field: ‘label’
[11:01:33.681]   - Field: ‘local’
[11:01:33.681]   - Field: ‘owner’
[11:01:33.681]   - Field: ‘envir’
[11:01:33.681]   - Field: ‘workers’
[11:01:33.681]   - Field: ‘packages’
[11:01:33.681]   - Field: ‘gc’
[11:01:33.682]   - Field: ‘conditions’
[11:01:33.682]   - Field: ‘persistent’
[11:01:33.682]   - Field: ‘expr’
[11:01:33.682]   - Field: ‘uuid’
[11:01:33.682]   - Field: ‘seed’
[11:01:33.682]   - Field: ‘version’
[11:01:33.682]   - Field: ‘result’
[11:01:33.682]   - Field: ‘asynchronous’
[11:01:33.682]   - Field: ‘calls’
[11:01:33.682]   - Field: ‘globals’
[11:01:33.682]   - Field: ‘stdout’
[11:01:33.683]   - Field: ‘earlySignal’
[11:01:33.683]   - Field: ‘lazy’
[11:01:33.683]   - Field: ‘state’
[11:01:33.683] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.683] - Launch lazy future ...
[11:01:33.683] Packages needed by the future expression (n = 0): <none>
[11:01:33.683] Packages needed by future strategies (n = 0): <none>
[11:01:33.684] {
[11:01:33.684]     {
[11:01:33.684]         {
[11:01:33.684]             ...future.startTime <- base::Sys.time()
[11:01:33.684]             {
[11:01:33.684]                 {
[11:01:33.684]                   {
[11:01:33.684]                     {
[11:01:33.684]                       base::local({
[11:01:33.684]                         has_future <- base::requireNamespace("future", 
[11:01:33.684]                           quietly = TRUE)
[11:01:33.684]                         if (has_future) {
[11:01:33.684]                           ns <- base::getNamespace("future")
[11:01:33.684]                           version <- ns[[".package"]][["version"]]
[11:01:33.684]                           if (is.null(version)) 
[11:01:33.684]                             version <- utils::packageVersion("future")
[11:01:33.684]                         }
[11:01:33.684]                         else {
[11:01:33.684]                           version <- NULL
[11:01:33.684]                         }
[11:01:33.684]                         if (!has_future || version < "1.8.0") {
[11:01:33.684]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.684]                             "", base::R.version$version.string), 
[11:01:33.684]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.684]                               "release", "version")], collapse = " "), 
[11:01:33.684]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.684]                             info)
[11:01:33.684]                           info <- base::paste(info, collapse = "; ")
[11:01:33.684]                           if (!has_future) {
[11:01:33.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.684]                               info)
[11:01:33.684]                           }
[11:01:33.684]                           else {
[11:01:33.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.684]                               info, version)
[11:01:33.684]                           }
[11:01:33.684]                           base::stop(msg)
[11:01:33.684]                         }
[11:01:33.684]                       })
[11:01:33.684]                     }
[11:01:33.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.684]                     base::options(mc.cores = 1L)
[11:01:33.684]                   }
[11:01:33.684]                   ...future.strategy.old <- future::plan("list")
[11:01:33.684]                   options(future.plan = NULL)
[11:01:33.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.684]                 }
[11:01:33.684]                 ...future.workdir <- getwd()
[11:01:33.684]             }
[11:01:33.684]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.684]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.684]         }
[11:01:33.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.684]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.684]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.684]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.684]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.684]             base::names(...future.oldOptions))
[11:01:33.684]     }
[11:01:33.684]     if (FALSE) {
[11:01:33.684]     }
[11:01:33.684]     else {
[11:01:33.684]         if (TRUE) {
[11:01:33.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.684]                 open = "w")
[11:01:33.684]         }
[11:01:33.684]         else {
[11:01:33.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.684]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.684]         }
[11:01:33.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.684]             base::sink(type = "output", split = FALSE)
[11:01:33.684]             base::close(...future.stdout)
[11:01:33.684]         }, add = TRUE)
[11:01:33.684]     }
[11:01:33.684]     ...future.frame <- base::sys.nframe()
[11:01:33.684]     ...future.conditions <- base::list()
[11:01:33.684]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.684]     if (FALSE) {
[11:01:33.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.684]     }
[11:01:33.684]     ...future.result <- base::tryCatch({
[11:01:33.684]         base::withCallingHandlers({
[11:01:33.684]             ...future.value <- base::withVisible(base::local({
[11:01:33.684]                 ...future.makeSendCondition <- base::local({
[11:01:33.684]                   sendCondition <- NULL
[11:01:33.684]                   function(frame = 1L) {
[11:01:33.684]                     if (is.function(sendCondition)) 
[11:01:33.684]                       return(sendCondition)
[11:01:33.684]                     ns <- getNamespace("parallel")
[11:01:33.684]                     if (exists("sendData", mode = "function", 
[11:01:33.684]                       envir = ns)) {
[11:01:33.684]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.684]                         envir = ns)
[11:01:33.684]                       envir <- sys.frame(frame)
[11:01:33.684]                       master <- NULL
[11:01:33.684]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.684]                         !identical(envir, emptyenv())) {
[11:01:33.684]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.684]                           inherits = FALSE)) {
[11:01:33.684]                           master <- get("master", mode = "list", 
[11:01:33.684]                             envir = envir, inherits = FALSE)
[11:01:33.684]                           if (inherits(master, c("SOCKnode", 
[11:01:33.684]                             "SOCK0node"))) {
[11:01:33.684]                             sendCondition <<- function(cond) {
[11:01:33.684]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.684]                                 success = TRUE)
[11:01:33.684]                               parallel_sendData(master, data)
[11:01:33.684]                             }
[11:01:33.684]                             return(sendCondition)
[11:01:33.684]                           }
[11:01:33.684]                         }
[11:01:33.684]                         frame <- frame + 1L
[11:01:33.684]                         envir <- sys.frame(frame)
[11:01:33.684]                       }
[11:01:33.684]                     }
[11:01:33.684]                     sendCondition <<- function(cond) NULL
[11:01:33.684]                   }
[11:01:33.684]                 })
[11:01:33.684]                 withCallingHandlers({
[11:01:33.684]                   2
[11:01:33.684]                 }, immediateCondition = function(cond) {
[11:01:33.684]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.684]                   sendCondition(cond)
[11:01:33.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.684]                   {
[11:01:33.684]                     inherits <- base::inherits
[11:01:33.684]                     invokeRestart <- base::invokeRestart
[11:01:33.684]                     is.null <- base::is.null
[11:01:33.684]                     muffled <- FALSE
[11:01:33.684]                     if (inherits(cond, "message")) {
[11:01:33.684]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.684]                       if (muffled) 
[11:01:33.684]                         invokeRestart("muffleMessage")
[11:01:33.684]                     }
[11:01:33.684]                     else if (inherits(cond, "warning")) {
[11:01:33.684]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.684]                       if (muffled) 
[11:01:33.684]                         invokeRestart("muffleWarning")
[11:01:33.684]                     }
[11:01:33.684]                     else if (inherits(cond, "condition")) {
[11:01:33.684]                       if (!is.null(pattern)) {
[11:01:33.684]                         computeRestarts <- base::computeRestarts
[11:01:33.684]                         grepl <- base::grepl
[11:01:33.684]                         restarts <- computeRestarts(cond)
[11:01:33.684]                         for (restart in restarts) {
[11:01:33.684]                           name <- restart$name
[11:01:33.684]                           if (is.null(name)) 
[11:01:33.684]                             next
[11:01:33.684]                           if (!grepl(pattern, name)) 
[11:01:33.684]                             next
[11:01:33.684]                           invokeRestart(restart)
[11:01:33.684]                           muffled <- TRUE
[11:01:33.684]                           break
[11:01:33.684]                         }
[11:01:33.684]                       }
[11:01:33.684]                     }
[11:01:33.684]                     invisible(muffled)
[11:01:33.684]                   }
[11:01:33.684]                   muffleCondition(cond)
[11:01:33.684]                 })
[11:01:33.684]             }))
[11:01:33.684]             future::FutureResult(value = ...future.value$value, 
[11:01:33.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.684]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.684]                     ...future.globalenv.names))
[11:01:33.684]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.684]         }, condition = base::local({
[11:01:33.684]             c <- base::c
[11:01:33.684]             inherits <- base::inherits
[11:01:33.684]             invokeRestart <- base::invokeRestart
[11:01:33.684]             length <- base::length
[11:01:33.684]             list <- base::list
[11:01:33.684]             seq.int <- base::seq.int
[11:01:33.684]             signalCondition <- base::signalCondition
[11:01:33.684]             sys.calls <- base::sys.calls
[11:01:33.684]             `[[` <- base::`[[`
[11:01:33.684]             `+` <- base::`+`
[11:01:33.684]             `<<-` <- base::`<<-`
[11:01:33.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.684]                   3L)]
[11:01:33.684]             }
[11:01:33.684]             function(cond) {
[11:01:33.684]                 is_error <- inherits(cond, "error")
[11:01:33.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.684]                   NULL)
[11:01:33.684]                 if (is_error) {
[11:01:33.684]                   sessionInformation <- function() {
[11:01:33.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.684]                       search = base::search(), system = base::Sys.info())
[11:01:33.684]                   }
[11:01:33.684]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.684]                     cond$call), session = sessionInformation(), 
[11:01:33.684]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.684]                   signalCondition(cond)
[11:01:33.684]                 }
[11:01:33.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.684]                 "immediateCondition"))) {
[11:01:33.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.684]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.684]                   if (TRUE && !signal) {
[11:01:33.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.684]                     {
[11:01:33.684]                       inherits <- base::inherits
[11:01:33.684]                       invokeRestart <- base::invokeRestart
[11:01:33.684]                       is.null <- base::is.null
[11:01:33.684]                       muffled <- FALSE
[11:01:33.684]                       if (inherits(cond, "message")) {
[11:01:33.684]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.684]                         if (muffled) 
[11:01:33.684]                           invokeRestart("muffleMessage")
[11:01:33.684]                       }
[11:01:33.684]                       else if (inherits(cond, "warning")) {
[11:01:33.684]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.684]                         if (muffled) 
[11:01:33.684]                           invokeRestart("muffleWarning")
[11:01:33.684]                       }
[11:01:33.684]                       else if (inherits(cond, "condition")) {
[11:01:33.684]                         if (!is.null(pattern)) {
[11:01:33.684]                           computeRestarts <- base::computeRestarts
[11:01:33.684]                           grepl <- base::grepl
[11:01:33.684]                           restarts <- computeRestarts(cond)
[11:01:33.684]                           for (restart in restarts) {
[11:01:33.684]                             name <- restart$name
[11:01:33.684]                             if (is.null(name)) 
[11:01:33.684]                               next
[11:01:33.684]                             if (!grepl(pattern, name)) 
[11:01:33.684]                               next
[11:01:33.684]                             invokeRestart(restart)
[11:01:33.684]                             muffled <- TRUE
[11:01:33.684]                             break
[11:01:33.684]                           }
[11:01:33.684]                         }
[11:01:33.684]                       }
[11:01:33.684]                       invisible(muffled)
[11:01:33.684]                     }
[11:01:33.684]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.684]                   }
[11:01:33.684]                 }
[11:01:33.684]                 else {
[11:01:33.684]                   if (TRUE) {
[11:01:33.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.684]                     {
[11:01:33.684]                       inherits <- base::inherits
[11:01:33.684]                       invokeRestart <- base::invokeRestart
[11:01:33.684]                       is.null <- base::is.null
[11:01:33.684]                       muffled <- FALSE
[11:01:33.684]                       if (inherits(cond, "message")) {
[11:01:33.684]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.684]                         if (muffled) 
[11:01:33.684]                           invokeRestart("muffleMessage")
[11:01:33.684]                       }
[11:01:33.684]                       else if (inherits(cond, "warning")) {
[11:01:33.684]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.684]                         if (muffled) 
[11:01:33.684]                           invokeRestart("muffleWarning")
[11:01:33.684]                       }
[11:01:33.684]                       else if (inherits(cond, "condition")) {
[11:01:33.684]                         if (!is.null(pattern)) {
[11:01:33.684]                           computeRestarts <- base::computeRestarts
[11:01:33.684]                           grepl <- base::grepl
[11:01:33.684]                           restarts <- computeRestarts(cond)
[11:01:33.684]                           for (restart in restarts) {
[11:01:33.684]                             name <- restart$name
[11:01:33.684]                             if (is.null(name)) 
[11:01:33.684]                               next
[11:01:33.684]                             if (!grepl(pattern, name)) 
[11:01:33.684]                               next
[11:01:33.684]                             invokeRestart(restart)
[11:01:33.684]                             muffled <- TRUE
[11:01:33.684]                             break
[11:01:33.684]                           }
[11:01:33.684]                         }
[11:01:33.684]                       }
[11:01:33.684]                       invisible(muffled)
[11:01:33.684]                     }
[11:01:33.684]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.684]                   }
[11:01:33.684]                 }
[11:01:33.684]             }
[11:01:33.684]         }))
[11:01:33.684]     }, error = function(ex) {
[11:01:33.684]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.684]                 ...future.rng), started = ...future.startTime, 
[11:01:33.684]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.684]             version = "1.8"), class = "FutureResult")
[11:01:33.684]     }, finally = {
[11:01:33.684]         if (!identical(...future.workdir, getwd())) 
[11:01:33.684]             setwd(...future.workdir)
[11:01:33.684]         {
[11:01:33.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.684]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.684]             }
[11:01:33.684]             base::options(...future.oldOptions)
[11:01:33.684]             if (.Platform$OS.type == "windows") {
[11:01:33.684]                 old_names <- names(...future.oldEnvVars)
[11:01:33.684]                 envs <- base::Sys.getenv()
[11:01:33.684]                 names <- names(envs)
[11:01:33.684]                 common <- intersect(names, old_names)
[11:01:33.684]                 added <- setdiff(names, old_names)
[11:01:33.684]                 removed <- setdiff(old_names, names)
[11:01:33.684]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.684]                   envs[common]]
[11:01:33.684]                 NAMES <- toupper(changed)
[11:01:33.684]                 args <- list()
[11:01:33.684]                 for (kk in seq_along(NAMES)) {
[11:01:33.684]                   name <- changed[[kk]]
[11:01:33.684]                   NAME <- NAMES[[kk]]
[11:01:33.684]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.684]                     next
[11:01:33.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.684]                 }
[11:01:33.684]                 NAMES <- toupper(added)
[11:01:33.684]                 for (kk in seq_along(NAMES)) {
[11:01:33.684]                   name <- added[[kk]]
[11:01:33.684]                   NAME <- NAMES[[kk]]
[11:01:33.684]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.684]                     next
[11:01:33.684]                   args[[name]] <- ""
[11:01:33.684]                 }
[11:01:33.684]                 NAMES <- toupper(removed)
[11:01:33.684]                 for (kk in seq_along(NAMES)) {
[11:01:33.684]                   name <- removed[[kk]]
[11:01:33.684]                   NAME <- NAMES[[kk]]
[11:01:33.684]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.684]                     next
[11:01:33.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.684]                 }
[11:01:33.684]                 if (length(args) > 0) 
[11:01:33.684]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.684]             }
[11:01:33.684]             else {
[11:01:33.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.684]             }
[11:01:33.684]             {
[11:01:33.684]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.684]                   0L) {
[11:01:33.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.684]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.684]                   base::options(opts)
[11:01:33.684]                 }
[11:01:33.684]                 {
[11:01:33.684]                   {
[11:01:33.684]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.684]                     NULL
[11:01:33.684]                   }
[11:01:33.684]                   options(future.plan = NULL)
[11:01:33.684]                   if (is.na(NA_character_)) 
[11:01:33.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.684]                     .init = FALSE)
[11:01:33.684]                 }
[11:01:33.684]             }
[11:01:33.684]         }
[11:01:33.684]     })
[11:01:33.684]     if (TRUE) {
[11:01:33.684]         base::sink(type = "output", split = FALSE)
[11:01:33.684]         if (TRUE) {
[11:01:33.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.684]         }
[11:01:33.684]         else {
[11:01:33.684]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.684]         }
[11:01:33.684]         base::close(...future.stdout)
[11:01:33.684]         ...future.stdout <- NULL
[11:01:33.684]     }
[11:01:33.684]     ...future.result$conditions <- ...future.conditions
[11:01:33.684]     ...future.result$finished <- base::Sys.time()
[11:01:33.684]     ...future.result
[11:01:33.684] }
[11:01:33.687] MultisessionFuture started
[11:01:33.687] - Launch lazy future ... done
[11:01:33.687] run() for ‘MultisessionFuture’ ... done
[11:01:33.687] getGlobalsAndPackages() ...
[11:01:33.687] Searching for globals...
[11:01:33.687] 
[11:01:33.687] Searching for globals ... DONE
[11:01:33.688] - globals: [0] <none>
[11:01:33.688] getGlobalsAndPackages() ... DONE
[11:01:33.688] run() for ‘Future’ ...
[11:01:33.688] - state: ‘created’
[11:01:33.688] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.702] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.702] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.702]   - Field: ‘node’
[11:01:33.702]   - Field: ‘label’
[11:01:33.702]   - Field: ‘local’
[11:01:33.702]   - Field: ‘owner’
[11:01:33.702]   - Field: ‘envir’
[11:01:33.702]   - Field: ‘workers’
[11:01:33.702]   - Field: ‘packages’
[11:01:33.702]   - Field: ‘gc’
[11:01:33.703]   - Field: ‘conditions’
[11:01:33.703]   - Field: ‘persistent’
[11:01:33.703]   - Field: ‘expr’
[11:01:33.703]   - Field: ‘uuid’
[11:01:33.703]   - Field: ‘seed’
[11:01:33.703]   - Field: ‘version’
[11:01:33.703]   - Field: ‘result’
[11:01:33.703]   - Field: ‘asynchronous’
[11:01:33.703]   - Field: ‘calls’
[11:01:33.703]   - Field: ‘globals’
[11:01:33.703]   - Field: ‘stdout’
[11:01:33.703]   - Field: ‘earlySignal’
[11:01:33.704]   - Field: ‘lazy’
[11:01:33.704]   - Field: ‘state’
[11:01:33.704] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.704] - Launch lazy future ...
[11:01:33.704] Packages needed by the future expression (n = 0): <none>
[11:01:33.704] Packages needed by future strategies (n = 0): <none>
[11:01:33.705] {
[11:01:33.705]     {
[11:01:33.705]         {
[11:01:33.705]             ...future.startTime <- base::Sys.time()
[11:01:33.705]             {
[11:01:33.705]                 {
[11:01:33.705]                   {
[11:01:33.705]                     {
[11:01:33.705]                       base::local({
[11:01:33.705]                         has_future <- base::requireNamespace("future", 
[11:01:33.705]                           quietly = TRUE)
[11:01:33.705]                         if (has_future) {
[11:01:33.705]                           ns <- base::getNamespace("future")
[11:01:33.705]                           version <- ns[[".package"]][["version"]]
[11:01:33.705]                           if (is.null(version)) 
[11:01:33.705]                             version <- utils::packageVersion("future")
[11:01:33.705]                         }
[11:01:33.705]                         else {
[11:01:33.705]                           version <- NULL
[11:01:33.705]                         }
[11:01:33.705]                         if (!has_future || version < "1.8.0") {
[11:01:33.705]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.705]                             "", base::R.version$version.string), 
[11:01:33.705]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.705]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.705]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.705]                               "release", "version")], collapse = " "), 
[11:01:33.705]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.705]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.705]                             info)
[11:01:33.705]                           info <- base::paste(info, collapse = "; ")
[11:01:33.705]                           if (!has_future) {
[11:01:33.705]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.705]                               info)
[11:01:33.705]                           }
[11:01:33.705]                           else {
[11:01:33.705]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.705]                               info, version)
[11:01:33.705]                           }
[11:01:33.705]                           base::stop(msg)
[11:01:33.705]                         }
[11:01:33.705]                       })
[11:01:33.705]                     }
[11:01:33.705]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.705]                     base::options(mc.cores = 1L)
[11:01:33.705]                   }
[11:01:33.705]                   ...future.strategy.old <- future::plan("list")
[11:01:33.705]                   options(future.plan = NULL)
[11:01:33.705]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.705]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.705]                 }
[11:01:33.705]                 ...future.workdir <- getwd()
[11:01:33.705]             }
[11:01:33.705]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.705]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.705]         }
[11:01:33.705]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.705]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.705]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.705]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.705]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.705]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.705]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.705]             base::names(...future.oldOptions))
[11:01:33.705]     }
[11:01:33.705]     if (FALSE) {
[11:01:33.705]     }
[11:01:33.705]     else {
[11:01:33.705]         if (TRUE) {
[11:01:33.705]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.705]                 open = "w")
[11:01:33.705]         }
[11:01:33.705]         else {
[11:01:33.705]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.705]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.705]         }
[11:01:33.705]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.705]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.705]             base::sink(type = "output", split = FALSE)
[11:01:33.705]             base::close(...future.stdout)
[11:01:33.705]         }, add = TRUE)
[11:01:33.705]     }
[11:01:33.705]     ...future.frame <- base::sys.nframe()
[11:01:33.705]     ...future.conditions <- base::list()
[11:01:33.705]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.705]     if (FALSE) {
[11:01:33.705]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.705]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.705]     }
[11:01:33.705]     ...future.result <- base::tryCatch({
[11:01:33.705]         base::withCallingHandlers({
[11:01:33.705]             ...future.value <- base::withVisible(base::local({
[11:01:33.705]                 ...future.makeSendCondition <- base::local({
[11:01:33.705]                   sendCondition <- NULL
[11:01:33.705]                   function(frame = 1L) {
[11:01:33.705]                     if (is.function(sendCondition)) 
[11:01:33.705]                       return(sendCondition)
[11:01:33.705]                     ns <- getNamespace("parallel")
[11:01:33.705]                     if (exists("sendData", mode = "function", 
[11:01:33.705]                       envir = ns)) {
[11:01:33.705]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.705]                         envir = ns)
[11:01:33.705]                       envir <- sys.frame(frame)
[11:01:33.705]                       master <- NULL
[11:01:33.705]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.705]                         !identical(envir, emptyenv())) {
[11:01:33.705]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.705]                           inherits = FALSE)) {
[11:01:33.705]                           master <- get("master", mode = "list", 
[11:01:33.705]                             envir = envir, inherits = FALSE)
[11:01:33.705]                           if (inherits(master, c("SOCKnode", 
[11:01:33.705]                             "SOCK0node"))) {
[11:01:33.705]                             sendCondition <<- function(cond) {
[11:01:33.705]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.705]                                 success = TRUE)
[11:01:33.705]                               parallel_sendData(master, data)
[11:01:33.705]                             }
[11:01:33.705]                             return(sendCondition)
[11:01:33.705]                           }
[11:01:33.705]                         }
[11:01:33.705]                         frame <- frame + 1L
[11:01:33.705]                         envir <- sys.frame(frame)
[11:01:33.705]                       }
[11:01:33.705]                     }
[11:01:33.705]                     sendCondition <<- function(cond) NULL
[11:01:33.705]                   }
[11:01:33.705]                 })
[11:01:33.705]                 withCallingHandlers({
[11:01:33.705]                   NULL
[11:01:33.705]                 }, immediateCondition = function(cond) {
[11:01:33.705]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.705]                   sendCondition(cond)
[11:01:33.705]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.705]                   {
[11:01:33.705]                     inherits <- base::inherits
[11:01:33.705]                     invokeRestart <- base::invokeRestart
[11:01:33.705]                     is.null <- base::is.null
[11:01:33.705]                     muffled <- FALSE
[11:01:33.705]                     if (inherits(cond, "message")) {
[11:01:33.705]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.705]                       if (muffled) 
[11:01:33.705]                         invokeRestart("muffleMessage")
[11:01:33.705]                     }
[11:01:33.705]                     else if (inherits(cond, "warning")) {
[11:01:33.705]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.705]                       if (muffled) 
[11:01:33.705]                         invokeRestart("muffleWarning")
[11:01:33.705]                     }
[11:01:33.705]                     else if (inherits(cond, "condition")) {
[11:01:33.705]                       if (!is.null(pattern)) {
[11:01:33.705]                         computeRestarts <- base::computeRestarts
[11:01:33.705]                         grepl <- base::grepl
[11:01:33.705]                         restarts <- computeRestarts(cond)
[11:01:33.705]                         for (restart in restarts) {
[11:01:33.705]                           name <- restart$name
[11:01:33.705]                           if (is.null(name)) 
[11:01:33.705]                             next
[11:01:33.705]                           if (!grepl(pattern, name)) 
[11:01:33.705]                             next
[11:01:33.705]                           invokeRestart(restart)
[11:01:33.705]                           muffled <- TRUE
[11:01:33.705]                           break
[11:01:33.705]                         }
[11:01:33.705]                       }
[11:01:33.705]                     }
[11:01:33.705]                     invisible(muffled)
[11:01:33.705]                   }
[11:01:33.705]                   muffleCondition(cond)
[11:01:33.705]                 })
[11:01:33.705]             }))
[11:01:33.705]             future::FutureResult(value = ...future.value$value, 
[11:01:33.705]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.705]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.705]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.705]                     ...future.globalenv.names))
[11:01:33.705]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.705]         }, condition = base::local({
[11:01:33.705]             c <- base::c
[11:01:33.705]             inherits <- base::inherits
[11:01:33.705]             invokeRestart <- base::invokeRestart
[11:01:33.705]             length <- base::length
[11:01:33.705]             list <- base::list
[11:01:33.705]             seq.int <- base::seq.int
[11:01:33.705]             signalCondition <- base::signalCondition
[11:01:33.705]             sys.calls <- base::sys.calls
[11:01:33.705]             `[[` <- base::`[[`
[11:01:33.705]             `+` <- base::`+`
[11:01:33.705]             `<<-` <- base::`<<-`
[11:01:33.705]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.705]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.705]                   3L)]
[11:01:33.705]             }
[11:01:33.705]             function(cond) {
[11:01:33.705]                 is_error <- inherits(cond, "error")
[11:01:33.705]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.705]                   NULL)
[11:01:33.705]                 if (is_error) {
[11:01:33.705]                   sessionInformation <- function() {
[11:01:33.705]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.705]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.705]                       search = base::search(), system = base::Sys.info())
[11:01:33.705]                   }
[11:01:33.705]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.705]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.705]                     cond$call), session = sessionInformation(), 
[11:01:33.705]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.705]                   signalCondition(cond)
[11:01:33.705]                 }
[11:01:33.705]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.705]                 "immediateCondition"))) {
[11:01:33.705]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.705]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.705]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.705]                   if (TRUE && !signal) {
[11:01:33.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.705]                     {
[11:01:33.705]                       inherits <- base::inherits
[11:01:33.705]                       invokeRestart <- base::invokeRestart
[11:01:33.705]                       is.null <- base::is.null
[11:01:33.705]                       muffled <- FALSE
[11:01:33.705]                       if (inherits(cond, "message")) {
[11:01:33.705]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.705]                         if (muffled) 
[11:01:33.705]                           invokeRestart("muffleMessage")
[11:01:33.705]                       }
[11:01:33.705]                       else if (inherits(cond, "warning")) {
[11:01:33.705]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.705]                         if (muffled) 
[11:01:33.705]                           invokeRestart("muffleWarning")
[11:01:33.705]                       }
[11:01:33.705]                       else if (inherits(cond, "condition")) {
[11:01:33.705]                         if (!is.null(pattern)) {
[11:01:33.705]                           computeRestarts <- base::computeRestarts
[11:01:33.705]                           grepl <- base::grepl
[11:01:33.705]                           restarts <- computeRestarts(cond)
[11:01:33.705]                           for (restart in restarts) {
[11:01:33.705]                             name <- restart$name
[11:01:33.705]                             if (is.null(name)) 
[11:01:33.705]                               next
[11:01:33.705]                             if (!grepl(pattern, name)) 
[11:01:33.705]                               next
[11:01:33.705]                             invokeRestart(restart)
[11:01:33.705]                             muffled <- TRUE
[11:01:33.705]                             break
[11:01:33.705]                           }
[11:01:33.705]                         }
[11:01:33.705]                       }
[11:01:33.705]                       invisible(muffled)
[11:01:33.705]                     }
[11:01:33.705]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.705]                   }
[11:01:33.705]                 }
[11:01:33.705]                 else {
[11:01:33.705]                   if (TRUE) {
[11:01:33.705]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.705]                     {
[11:01:33.705]                       inherits <- base::inherits
[11:01:33.705]                       invokeRestart <- base::invokeRestart
[11:01:33.705]                       is.null <- base::is.null
[11:01:33.705]                       muffled <- FALSE
[11:01:33.705]                       if (inherits(cond, "message")) {
[11:01:33.705]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.705]                         if (muffled) 
[11:01:33.705]                           invokeRestart("muffleMessage")
[11:01:33.705]                       }
[11:01:33.705]                       else if (inherits(cond, "warning")) {
[11:01:33.705]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.705]                         if (muffled) 
[11:01:33.705]                           invokeRestart("muffleWarning")
[11:01:33.705]                       }
[11:01:33.705]                       else if (inherits(cond, "condition")) {
[11:01:33.705]                         if (!is.null(pattern)) {
[11:01:33.705]                           computeRestarts <- base::computeRestarts
[11:01:33.705]                           grepl <- base::grepl
[11:01:33.705]                           restarts <- computeRestarts(cond)
[11:01:33.705]                           for (restart in restarts) {
[11:01:33.705]                             name <- restart$name
[11:01:33.705]                             if (is.null(name)) 
[11:01:33.705]                               next
[11:01:33.705]                             if (!grepl(pattern, name)) 
[11:01:33.705]                               next
[11:01:33.705]                             invokeRestart(restart)
[11:01:33.705]                             muffled <- TRUE
[11:01:33.705]                             break
[11:01:33.705]                           }
[11:01:33.705]                         }
[11:01:33.705]                       }
[11:01:33.705]                       invisible(muffled)
[11:01:33.705]                     }
[11:01:33.705]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.705]                   }
[11:01:33.705]                 }
[11:01:33.705]             }
[11:01:33.705]         }))
[11:01:33.705]     }, error = function(ex) {
[11:01:33.705]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.705]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.705]                 ...future.rng), started = ...future.startTime, 
[11:01:33.705]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.705]             version = "1.8"), class = "FutureResult")
[11:01:33.705]     }, finally = {
[11:01:33.705]         if (!identical(...future.workdir, getwd())) 
[11:01:33.705]             setwd(...future.workdir)
[11:01:33.705]         {
[11:01:33.705]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.705]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.705]             }
[11:01:33.705]             base::options(...future.oldOptions)
[11:01:33.705]             if (.Platform$OS.type == "windows") {
[11:01:33.705]                 old_names <- names(...future.oldEnvVars)
[11:01:33.705]                 envs <- base::Sys.getenv()
[11:01:33.705]                 names <- names(envs)
[11:01:33.705]                 common <- intersect(names, old_names)
[11:01:33.705]                 added <- setdiff(names, old_names)
[11:01:33.705]                 removed <- setdiff(old_names, names)
[11:01:33.705]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.705]                   envs[common]]
[11:01:33.705]                 NAMES <- toupper(changed)
[11:01:33.705]                 args <- list()
[11:01:33.705]                 for (kk in seq_along(NAMES)) {
[11:01:33.705]                   name <- changed[[kk]]
[11:01:33.705]                   NAME <- NAMES[[kk]]
[11:01:33.705]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.705]                     next
[11:01:33.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.705]                 }
[11:01:33.705]                 NAMES <- toupper(added)
[11:01:33.705]                 for (kk in seq_along(NAMES)) {
[11:01:33.705]                   name <- added[[kk]]
[11:01:33.705]                   NAME <- NAMES[[kk]]
[11:01:33.705]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.705]                     next
[11:01:33.705]                   args[[name]] <- ""
[11:01:33.705]                 }
[11:01:33.705]                 NAMES <- toupper(removed)
[11:01:33.705]                 for (kk in seq_along(NAMES)) {
[11:01:33.705]                   name <- removed[[kk]]
[11:01:33.705]                   NAME <- NAMES[[kk]]
[11:01:33.705]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.705]                     next
[11:01:33.705]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.705]                 }
[11:01:33.705]                 if (length(args) > 0) 
[11:01:33.705]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.705]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.705]             }
[11:01:33.705]             else {
[11:01:33.705]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.705]             }
[11:01:33.705]             {
[11:01:33.705]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.705]                   0L) {
[11:01:33.705]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.705]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.705]                   base::options(opts)
[11:01:33.705]                 }
[11:01:33.705]                 {
[11:01:33.705]                   {
[11:01:33.705]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.705]                     NULL
[11:01:33.705]                   }
[11:01:33.705]                   options(future.plan = NULL)
[11:01:33.705]                   if (is.na(NA_character_)) 
[11:01:33.705]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.705]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.705]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.705]                     .init = FALSE)
[11:01:33.705]                 }
[11:01:33.705]             }
[11:01:33.705]         }
[11:01:33.705]     })
[11:01:33.705]     if (TRUE) {
[11:01:33.705]         base::sink(type = "output", split = FALSE)
[11:01:33.705]         if (TRUE) {
[11:01:33.705]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.705]         }
[11:01:33.705]         else {
[11:01:33.705]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.705]         }
[11:01:33.705]         base::close(...future.stdout)
[11:01:33.705]         ...future.stdout <- NULL
[11:01:33.705]     }
[11:01:33.705]     ...future.result$conditions <- ...future.conditions
[11:01:33.705]     ...future.result$finished <- base::Sys.time()
[11:01:33.705]     ...future.result
[11:01:33.705] }
[11:01:33.707] MultisessionFuture started
[11:01:33.708] - Launch lazy future ... done
[11:01:33.708] run() for ‘MultisessionFuture’ ... done
[11:01:33.708] getGlobalsAndPackages() ...
[11:01:33.708] Searching for globals...
[11:01:33.709] - globals found: [1] ‘{’
[11:01:33.709] Searching for globals ... DONE
[11:01:33.709] Resolving globals: FALSE
[11:01:33.709] 
[11:01:33.709] 
[11:01:33.709] getGlobalsAndPackages() ... DONE
[11:01:33.710] run() for ‘Future’ ...
[11:01:33.710] - state: ‘created’
[11:01:33.710] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:33.723] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:33.723] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:33.724]   - Field: ‘node’
[11:01:33.724]   - Field: ‘label’
[11:01:33.724]   - Field: ‘local’
[11:01:33.724]   - Field: ‘owner’
[11:01:33.724]   - Field: ‘envir’
[11:01:33.724]   - Field: ‘workers’
[11:01:33.724]   - Field: ‘packages’
[11:01:33.724]   - Field: ‘gc’
[11:01:33.724]   - Field: ‘conditions’
[11:01:33.724]   - Field: ‘persistent’
[11:01:33.724]   - Field: ‘expr’
[11:01:33.725]   - Field: ‘uuid’
[11:01:33.725]   - Field: ‘seed’
[11:01:33.725]   - Field: ‘version’
[11:01:33.725]   - Field: ‘result’
[11:01:33.725]   - Field: ‘asynchronous’
[11:01:33.725]   - Field: ‘calls’
[11:01:33.725]   - Field: ‘globals’
[11:01:33.725]   - Field: ‘stdout’
[11:01:33.725]   - Field: ‘earlySignal’
[11:01:33.725]   - Field: ‘lazy’
[11:01:33.725]   - Field: ‘state’
[11:01:33.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:33.726] - Launch lazy future ...
[11:01:33.726] Packages needed by the future expression (n = 0): <none>
[11:01:33.726] Packages needed by future strategies (n = 0): <none>
[11:01:33.726] {
[11:01:33.726]     {
[11:01:33.726]         {
[11:01:33.726]             ...future.startTime <- base::Sys.time()
[11:01:33.726]             {
[11:01:33.726]                 {
[11:01:33.726]                   {
[11:01:33.726]                     {
[11:01:33.726]                       base::local({
[11:01:33.726]                         has_future <- base::requireNamespace("future", 
[11:01:33.726]                           quietly = TRUE)
[11:01:33.726]                         if (has_future) {
[11:01:33.726]                           ns <- base::getNamespace("future")
[11:01:33.726]                           version <- ns[[".package"]][["version"]]
[11:01:33.726]                           if (is.null(version)) 
[11:01:33.726]                             version <- utils::packageVersion("future")
[11:01:33.726]                         }
[11:01:33.726]                         else {
[11:01:33.726]                           version <- NULL
[11:01:33.726]                         }
[11:01:33.726]                         if (!has_future || version < "1.8.0") {
[11:01:33.726]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:33.726]                             "", base::R.version$version.string), 
[11:01:33.726]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:33.726]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:33.726]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:33.726]                               "release", "version")], collapse = " "), 
[11:01:33.726]                             hostname = base::Sys.info()[["nodename"]])
[11:01:33.726]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:33.726]                             info)
[11:01:33.726]                           info <- base::paste(info, collapse = "; ")
[11:01:33.726]                           if (!has_future) {
[11:01:33.726]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:33.726]                               info)
[11:01:33.726]                           }
[11:01:33.726]                           else {
[11:01:33.726]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:33.726]                               info, version)
[11:01:33.726]                           }
[11:01:33.726]                           base::stop(msg)
[11:01:33.726]                         }
[11:01:33.726]                       })
[11:01:33.726]                     }
[11:01:33.726]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:33.726]                     base::options(mc.cores = 1L)
[11:01:33.726]                   }
[11:01:33.726]                   ...future.strategy.old <- future::plan("list")
[11:01:33.726]                   options(future.plan = NULL)
[11:01:33.726]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.726]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:33.726]                 }
[11:01:33.726]                 ...future.workdir <- getwd()
[11:01:33.726]             }
[11:01:33.726]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:33.726]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:33.726]         }
[11:01:33.726]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[11:01:33.726]             future.globals.maxSize = NULL, future.globals.method = NULL, 
[11:01:33.726]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[11:01:33.726]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[11:01:33.726]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:33.726]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:33.726]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:33.726]             base::names(...future.oldOptions))
[11:01:33.726]     }
[11:01:33.726]     if (FALSE) {
[11:01:33.726]     }
[11:01:33.726]     else {
[11:01:33.726]         if (TRUE) {
[11:01:33.726]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:33.726]                 open = "w")
[11:01:33.726]         }
[11:01:33.726]         else {
[11:01:33.726]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:33.726]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:33.726]         }
[11:01:33.726]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:33.726]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:33.726]             base::sink(type = "output", split = FALSE)
[11:01:33.726]             base::close(...future.stdout)
[11:01:33.726]         }, add = TRUE)
[11:01:33.726]     }
[11:01:33.726]     ...future.frame <- base::sys.nframe()
[11:01:33.726]     ...future.conditions <- base::list()
[11:01:33.726]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:33.726]     if (FALSE) {
[11:01:33.726]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:33.726]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:33.726]     }
[11:01:33.726]     ...future.result <- base::tryCatch({
[11:01:33.726]         base::withCallingHandlers({
[11:01:33.726]             ...future.value <- base::withVisible(base::local({
[11:01:33.726]                 ...future.makeSendCondition <- base::local({
[11:01:33.726]                   sendCondition <- NULL
[11:01:33.726]                   function(frame = 1L) {
[11:01:33.726]                     if (is.function(sendCondition)) 
[11:01:33.726]                       return(sendCondition)
[11:01:33.726]                     ns <- getNamespace("parallel")
[11:01:33.726]                     if (exists("sendData", mode = "function", 
[11:01:33.726]                       envir = ns)) {
[11:01:33.726]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:33.726]                         envir = ns)
[11:01:33.726]                       envir <- sys.frame(frame)
[11:01:33.726]                       master <- NULL
[11:01:33.726]                       while (!identical(envir, .GlobalEnv) && 
[11:01:33.726]                         !identical(envir, emptyenv())) {
[11:01:33.726]                         if (exists("master", mode = "list", envir = envir, 
[11:01:33.726]                           inherits = FALSE)) {
[11:01:33.726]                           master <- get("master", mode = "list", 
[11:01:33.726]                             envir = envir, inherits = FALSE)
[11:01:33.726]                           if (inherits(master, c("SOCKnode", 
[11:01:33.726]                             "SOCK0node"))) {
[11:01:33.726]                             sendCondition <<- function(cond) {
[11:01:33.726]                               data <- list(type = "VALUE", value = cond, 
[11:01:33.726]                                 success = TRUE)
[11:01:33.726]                               parallel_sendData(master, data)
[11:01:33.726]                             }
[11:01:33.726]                             return(sendCondition)
[11:01:33.726]                           }
[11:01:33.726]                         }
[11:01:33.726]                         frame <- frame + 1L
[11:01:33.726]                         envir <- sys.frame(frame)
[11:01:33.726]                       }
[11:01:33.726]                     }
[11:01:33.726]                     sendCondition <<- function(cond) NULL
[11:01:33.726]                   }
[11:01:33.726]                 })
[11:01:33.726]                 withCallingHandlers({
[11:01:33.726]                   {
[11:01:33.726]                     4
[11:01:33.726]                   }
[11:01:33.726]                 }, immediateCondition = function(cond) {
[11:01:33.726]                   sendCondition <- ...future.makeSendCondition()
[11:01:33.726]                   sendCondition(cond)
[11:01:33.726]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.726]                   {
[11:01:33.726]                     inherits <- base::inherits
[11:01:33.726]                     invokeRestart <- base::invokeRestart
[11:01:33.726]                     is.null <- base::is.null
[11:01:33.726]                     muffled <- FALSE
[11:01:33.726]                     if (inherits(cond, "message")) {
[11:01:33.726]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:33.726]                       if (muffled) 
[11:01:33.726]                         invokeRestart("muffleMessage")
[11:01:33.726]                     }
[11:01:33.726]                     else if (inherits(cond, "warning")) {
[11:01:33.726]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:33.726]                       if (muffled) 
[11:01:33.726]                         invokeRestart("muffleWarning")
[11:01:33.726]                     }
[11:01:33.726]                     else if (inherits(cond, "condition")) {
[11:01:33.726]                       if (!is.null(pattern)) {
[11:01:33.726]                         computeRestarts <- base::computeRestarts
[11:01:33.726]                         grepl <- base::grepl
[11:01:33.726]                         restarts <- computeRestarts(cond)
[11:01:33.726]                         for (restart in restarts) {
[11:01:33.726]                           name <- restart$name
[11:01:33.726]                           if (is.null(name)) 
[11:01:33.726]                             next
[11:01:33.726]                           if (!grepl(pattern, name)) 
[11:01:33.726]                             next
[11:01:33.726]                           invokeRestart(restart)
[11:01:33.726]                           muffled <- TRUE
[11:01:33.726]                           break
[11:01:33.726]                         }
[11:01:33.726]                       }
[11:01:33.726]                     }
[11:01:33.726]                     invisible(muffled)
[11:01:33.726]                   }
[11:01:33.726]                   muffleCondition(cond)
[11:01:33.726]                 })
[11:01:33.726]             }))
[11:01:33.726]             future::FutureResult(value = ...future.value$value, 
[11:01:33.726]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.726]                   ...future.rng), globalenv = if (FALSE) 
[11:01:33.726]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:33.726]                     ...future.globalenv.names))
[11:01:33.726]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:33.726]         }, condition = base::local({
[11:01:33.726]             c <- base::c
[11:01:33.726]             inherits <- base::inherits
[11:01:33.726]             invokeRestart <- base::invokeRestart
[11:01:33.726]             length <- base::length
[11:01:33.726]             list <- base::list
[11:01:33.726]             seq.int <- base::seq.int
[11:01:33.726]             signalCondition <- base::signalCondition
[11:01:33.726]             sys.calls <- base::sys.calls
[11:01:33.726]             `[[` <- base::`[[`
[11:01:33.726]             `+` <- base::`+`
[11:01:33.726]             `<<-` <- base::`<<-`
[11:01:33.726]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:33.726]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:33.726]                   3L)]
[11:01:33.726]             }
[11:01:33.726]             function(cond) {
[11:01:33.726]                 is_error <- inherits(cond, "error")
[11:01:33.726]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:33.726]                   NULL)
[11:01:33.726]                 if (is_error) {
[11:01:33.726]                   sessionInformation <- function() {
[11:01:33.726]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:33.726]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:33.726]                       search = base::search(), system = base::Sys.info())
[11:01:33.726]                   }
[11:01:33.726]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.726]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:33.726]                     cond$call), session = sessionInformation(), 
[11:01:33.726]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:33.726]                   signalCondition(cond)
[11:01:33.726]                 }
[11:01:33.726]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:33.726]                 "immediateCondition"))) {
[11:01:33.726]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:33.726]                   ...future.conditions[[length(...future.conditions) + 
[11:01:33.726]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:33.726]                   if (TRUE && !signal) {
[11:01:33.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.726]                     {
[11:01:33.726]                       inherits <- base::inherits
[11:01:33.726]                       invokeRestart <- base::invokeRestart
[11:01:33.726]                       is.null <- base::is.null
[11:01:33.726]                       muffled <- FALSE
[11:01:33.726]                       if (inherits(cond, "message")) {
[11:01:33.726]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.726]                         if (muffled) 
[11:01:33.726]                           invokeRestart("muffleMessage")
[11:01:33.726]                       }
[11:01:33.726]                       else if (inherits(cond, "warning")) {
[11:01:33.726]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.726]                         if (muffled) 
[11:01:33.726]                           invokeRestart("muffleWarning")
[11:01:33.726]                       }
[11:01:33.726]                       else if (inherits(cond, "condition")) {
[11:01:33.726]                         if (!is.null(pattern)) {
[11:01:33.726]                           computeRestarts <- base::computeRestarts
[11:01:33.726]                           grepl <- base::grepl
[11:01:33.726]                           restarts <- computeRestarts(cond)
[11:01:33.726]                           for (restart in restarts) {
[11:01:33.726]                             name <- restart$name
[11:01:33.726]                             if (is.null(name)) 
[11:01:33.726]                               next
[11:01:33.726]                             if (!grepl(pattern, name)) 
[11:01:33.726]                               next
[11:01:33.726]                             invokeRestart(restart)
[11:01:33.726]                             muffled <- TRUE
[11:01:33.726]                             break
[11:01:33.726]                           }
[11:01:33.726]                         }
[11:01:33.726]                       }
[11:01:33.726]                       invisible(muffled)
[11:01:33.726]                     }
[11:01:33.726]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.726]                   }
[11:01:33.726]                 }
[11:01:33.726]                 else {
[11:01:33.726]                   if (TRUE) {
[11:01:33.726]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:33.726]                     {
[11:01:33.726]                       inherits <- base::inherits
[11:01:33.726]                       invokeRestart <- base::invokeRestart
[11:01:33.726]                       is.null <- base::is.null
[11:01:33.726]                       muffled <- FALSE
[11:01:33.726]                       if (inherits(cond, "message")) {
[11:01:33.726]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:33.726]                         if (muffled) 
[11:01:33.726]                           invokeRestart("muffleMessage")
[11:01:33.726]                       }
[11:01:33.726]                       else if (inherits(cond, "warning")) {
[11:01:33.726]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:33.726]                         if (muffled) 
[11:01:33.726]                           invokeRestart("muffleWarning")
[11:01:33.726]                       }
[11:01:33.726]                       else if (inherits(cond, "condition")) {
[11:01:33.726]                         if (!is.null(pattern)) {
[11:01:33.726]                           computeRestarts <- base::computeRestarts
[11:01:33.726]                           grepl <- base::grepl
[11:01:33.726]                           restarts <- computeRestarts(cond)
[11:01:33.726]                           for (restart in restarts) {
[11:01:33.726]                             name <- restart$name
[11:01:33.726]                             if (is.null(name)) 
[11:01:33.726]                               next
[11:01:33.726]                             if (!grepl(pattern, name)) 
[11:01:33.726]                               next
[11:01:33.726]                             invokeRestart(restart)
[11:01:33.726]                             muffled <- TRUE
[11:01:33.726]                             break
[11:01:33.726]                           }
[11:01:33.726]                         }
[11:01:33.726]                       }
[11:01:33.726]                       invisible(muffled)
[11:01:33.726]                     }
[11:01:33.726]                     muffleCondition(cond, pattern = "^muffle")
[11:01:33.726]                   }
[11:01:33.726]                 }
[11:01:33.726]             }
[11:01:33.726]         }))
[11:01:33.726]     }, error = function(ex) {
[11:01:33.726]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:33.726]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:33.726]                 ...future.rng), started = ...future.startTime, 
[11:01:33.726]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:33.726]             version = "1.8"), class = "FutureResult")
[11:01:33.726]     }, finally = {
[11:01:33.726]         if (!identical(...future.workdir, getwd())) 
[11:01:33.726]             setwd(...future.workdir)
[11:01:33.726]         {
[11:01:33.726]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:33.726]                 ...future.oldOptions$nwarnings <- NULL
[11:01:33.726]             }
[11:01:33.726]             base::options(...future.oldOptions)
[11:01:33.726]             if (.Platform$OS.type == "windows") {
[11:01:33.726]                 old_names <- names(...future.oldEnvVars)
[11:01:33.726]                 envs <- base::Sys.getenv()
[11:01:33.726]                 names <- names(envs)
[11:01:33.726]                 common <- intersect(names, old_names)
[11:01:33.726]                 added <- setdiff(names, old_names)
[11:01:33.726]                 removed <- setdiff(old_names, names)
[11:01:33.726]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:33.726]                   envs[common]]
[11:01:33.726]                 NAMES <- toupper(changed)
[11:01:33.726]                 args <- list()
[11:01:33.726]                 for (kk in seq_along(NAMES)) {
[11:01:33.726]                   name <- changed[[kk]]
[11:01:33.726]                   NAME <- NAMES[[kk]]
[11:01:33.726]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.726]                     next
[11:01:33.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.726]                 }
[11:01:33.726]                 NAMES <- toupper(added)
[11:01:33.726]                 for (kk in seq_along(NAMES)) {
[11:01:33.726]                   name <- added[[kk]]
[11:01:33.726]                   NAME <- NAMES[[kk]]
[11:01:33.726]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.726]                     next
[11:01:33.726]                   args[[name]] <- ""
[11:01:33.726]                 }
[11:01:33.726]                 NAMES <- toupper(removed)
[11:01:33.726]                 for (kk in seq_along(NAMES)) {
[11:01:33.726]                   name <- removed[[kk]]
[11:01:33.726]                   NAME <- NAMES[[kk]]
[11:01:33.726]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:33.726]                     next
[11:01:33.726]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:33.726]                 }
[11:01:33.726]                 if (length(args) > 0) 
[11:01:33.726]                   base::do.call(base::Sys.setenv, args = args)
[11:01:33.726]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:33.726]             }
[11:01:33.726]             else {
[11:01:33.726]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:33.726]             }
[11:01:33.726]             {
[11:01:33.726]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:33.726]                   0L) {
[11:01:33.726]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:33.726]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:33.726]                   base::options(opts)
[11:01:33.726]                 }
[11:01:33.726]                 {
[11:01:33.726]                   {
[11:01:33.726]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:33.726]                     NULL
[11:01:33.726]                   }
[11:01:33.726]                   options(future.plan = NULL)
[11:01:33.726]                   if (is.na(NA_character_)) 
[11:01:33.726]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:33.726]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:33.726]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:33.726]                     .init = FALSE)
[11:01:33.726]                 }
[11:01:33.726]             }
[11:01:33.726]         }
[11:01:33.726]     })
[11:01:33.726]     if (TRUE) {
[11:01:33.726]         base::sink(type = "output", split = FALSE)
[11:01:33.726]         if (TRUE) {
[11:01:33.726]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:33.726]         }
[11:01:33.726]         else {
[11:01:33.726]             ...future.result["stdout"] <- base::list(NULL)
[11:01:33.726]         }
[11:01:33.726]         base::close(...future.stdout)
[11:01:33.726]         ...future.stdout <- NULL
[11:01:33.726]     }
[11:01:33.726]     ...future.result$conditions <- ...future.conditions
[11:01:33.726]     ...future.result$finished <- base::Sys.time()
[11:01:33.726]     ...future.result
[11:01:33.726] }
[11:01:33.729] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:33.739] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.739] - Validating connection of MultisessionFuture
[11:01:33.739] - received message: FutureResult
[11:01:33.740] - Received FutureResult
[11:01:33.740] - Erased future from FutureRegistry
[11:01:33.740] result() for ClusterFuture ...
[11:01:33.740] - result already collected: FutureResult
[11:01:33.740] result() for ClusterFuture ... done
[11:01:33.740] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.740] result() for ClusterFuture ...
[11:01:33.740] - result already collected: FutureResult
[11:01:33.740] result() for ClusterFuture ... done
[11:01:33.740] result() for ClusterFuture ...
[11:01:33.740] - result already collected: FutureResult
[11:01:33.740] result() for ClusterFuture ... done
[11:01:33.741] MultisessionFuture started
[11:01:33.741] - Launch lazy future ... done
[11:01:33.742] run() for ‘MultisessionFuture’ ... done
Classes 'listenv', 'environment' <environment: 0x55a9c7e79290> 
Classes 'listenv', 'environment' <environment: 0x55a9c8c0e620> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
[11:01:33.749] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.749] - Validating connection of MultisessionFuture
[11:01:33.749] - received message: FutureResult
[11:01:33.750] - Received FutureResult
[11:01:33.750] - Erased future from FutureRegistry
[11:01:33.750] result() for ClusterFuture ...
[11:01:33.750] - result already collected: FutureResult
[11:01:33.750] result() for ClusterFuture ... done
[11:01:33.750] receiveMessageFromWorker() for ClusterFuture ... done
 logi [1:2, 1, 1:3, 1] TRUE TRUE TRUE FALSE TRUE TRUE
 - attr(*, "dimnames")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
 - attr(*, "names")= chr [1:6] "a" "b" "c" "d" ...
[11:01:33.763] resolve() on list environment ...
[11:01:33.763]  recursive: 0
[11:01:33.764]  length: 6
[11:01:33.764]  elements: ‘a’, ‘b’, ‘c’, ‘d’, ‘’, ‘’
[11:01:33.764] signalConditionsASAP(numeric, pos=1) ...
[11:01:33.765] - nx: 6
[11:01:33.765] - relay: TRUE
[11:01:33.765] - stdout: TRUE
[11:01:33.765] - signal: TRUE
[11:01:33.765] - resignal: FALSE
[11:01:33.765] - force: TRUE
[11:01:33.765] - relayed: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.765] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.765]  - until=2
[11:01:33.765]  - relaying element #2
[11:01:33.765] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.765] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.766] signalConditionsASAP(NULL, pos=1) ... done
[11:01:33.766]  length: 5 (resolved future 1)
[11:01:33.766] Future #2
[11:01:33.766] result() for ClusterFuture ...
[11:01:33.766] - result already collected: FutureResult
[11:01:33.766] result() for ClusterFuture ... done
[11:01:33.766] result() for ClusterFuture ...
[11:01:33.766] - result already collected: FutureResult
[11:01:33.766] result() for ClusterFuture ... done
[11:01:33.766] signalConditionsASAP(MultisessionFuture, pos=2) ...
[11:01:33.766] - nx: 6
[11:01:33.766] - relay: TRUE
[11:01:33.767] - stdout: TRUE
[11:01:33.767] - signal: TRUE
[11:01:33.767] - resignal: FALSE
[11:01:33.767] - force: TRUE
[11:01:33.767] - relayed: [n=6] TRUE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.767] - queued futures: [n=6] FALSE, FALSE, FALSE, FALSE, FALSE, FALSE
[11:01:33.767]  - until=2
[11:01:33.767]  - relaying element #2
[11:01:33.767] result() for ClusterFuture ...
[11:01:33.767] - result already collected: FutureResult
[11:01:33.767] result() for ClusterFuture ... done
[11:01:33.767] result() for ClusterFuture ...
[11:01:33.767] - result already collected: FutureResult
[11:01:33.768] result() for ClusterFuture ... done
[11:01:33.768] result() for ClusterFuture ...
[11:01:33.768] - result already collected: FutureResult
[11:01:33.768] result() for ClusterFuture ... done
[11:01:33.768] result() for ClusterFuture ...
[11:01:33.768] - result already collected: FutureResult
[11:01:33.768] result() for ClusterFuture ... done
[11:01:33.768] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.768] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.768] signalConditionsASAP(MultisessionFuture, pos=2) ... done
[11:01:33.768]  length: 4 (resolved future 2)
[11:01:33.769] Future #3
[11:01:33.769] result() for ClusterFuture ...
[11:01:33.769] - result already collected: FutureResult
[11:01:33.769] result() for ClusterFuture ... done
[11:01:33.769] result() for ClusterFuture ...
[11:01:33.769] - result already collected: FutureResult
[11:01:33.769] result() for ClusterFuture ... done
[11:01:33.769] signalConditionsASAP(MultisessionFuture, pos=3) ...
[11:01:33.769] - nx: 6
[11:01:33.769] - relay: TRUE
[11:01:33.769] - stdout: TRUE
[11:01:33.769] - signal: TRUE
[11:01:33.769] - resignal: FALSE
[11:01:33.770] - force: TRUE
[11:01:33.770] - relayed: [n=6] TRUE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.770] - queued futures: [n=6] FALSE, TRUE, FALSE, FALSE, FALSE, FALSE
[11:01:33.770]  - until=3
[11:01:33.770]  - relaying element #3
[11:01:33.770] result() for ClusterFuture ...
[11:01:33.770] - result already collected: FutureResult
[11:01:33.770] result() for ClusterFuture ... done
[11:01:33.770] result() for ClusterFuture ...
[11:01:33.770] - result already collected: FutureResult
[11:01:33.770] result() for ClusterFuture ... done
[11:01:33.770] result() for ClusterFuture ...
[11:01:33.771] - result already collected: FutureResult
[11:01:33.771] result() for ClusterFuture ... done
[11:01:33.771] result() for ClusterFuture ...
[11:01:33.771] - result already collected: FutureResult
[11:01:33.771] result() for ClusterFuture ... done
[11:01:33.771] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.771] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.771] signalConditionsASAP(MultisessionFuture, pos=3) ... done
[11:01:33.771]  length: 3 (resolved future 3)
[11:01:33.782] signalConditionsASAP(NULL, pos=5) ...
[11:01:33.782] - nx: 6
[11:01:33.782] - relay: TRUE
[11:01:33.782] - stdout: TRUE
[11:01:33.782] - signal: TRUE
[11:01:33.782] - resignal: FALSE
[11:01:33.782] - force: TRUE
[11:01:33.782] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.782] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.783]  - until=6
[11:01:33.783]  - relaying element #4
[11:01:33.783]  - relaying element #6
[11:01:33.783] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.783] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.783] signalConditionsASAP(NULL, pos=5) ... done
[11:01:33.783]  length: 2 (resolved future 5)
[11:01:33.783] signalConditionsASAP(numeric, pos=6) ...
[11:01:33.783] - nx: 6
[11:01:33.783] - relay: TRUE
[11:01:33.783] - stdout: TRUE
[11:01:33.783] - signal: TRUE
[11:01:33.784] - resignal: FALSE
[11:01:33.784] - force: TRUE
[11:01:33.784] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, FALSE
[11:01:33.784] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.784]  - until=6
[11:01:33.784]  - relaying element #4
[11:01:33.784] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.784] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.784] signalConditionsASAP(NULL, pos=6) ... done
[11:01:33.784]  length: 1 (resolved future 6)
[11:01:33.795] receiveMessageFromWorker() for ClusterFuture ...
[11:01:33.795] - Validating connection of MultisessionFuture
[11:01:33.795] - received message: FutureResult
[11:01:33.795] - Received FutureResult
[11:01:33.795] - Erased future from FutureRegistry
[11:01:33.796] result() for ClusterFuture ...
[11:01:33.796] - result already collected: FutureResult
[11:01:33.796] result() for ClusterFuture ... done
[11:01:33.796] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:33.796] Future #4
[11:01:33.796] result() for ClusterFuture ...
[11:01:33.796] - result already collected: FutureResult
[11:01:33.796] result() for ClusterFuture ... done
[11:01:33.796] result() for ClusterFuture ...
[11:01:33.796] - result already collected: FutureResult
[11:01:33.796] result() for ClusterFuture ... done
[11:01:33.796] signalConditionsASAP(MultisessionFuture, pos=4) ...
[11:01:33.796] - nx: 6
[11:01:33.797] - relay: TRUE
[11:01:33.797] - stdout: TRUE
[11:01:33.797] - signal: TRUE
[11:01:33.797] - resignal: FALSE
[11:01:33.797] - force: TRUE
[11:01:33.797] - relayed: [n=6] TRUE, TRUE, TRUE, FALSE, TRUE, TRUE
[11:01:33.797] - queued futures: [n=6] FALSE, TRUE, TRUE, FALSE, FALSE, FALSE
[11:01:33.797]  - until=6
[11:01:33.797]  - relaying element #4
[11:01:33.797] result() for ClusterFuture ...
[11:01:33.797] - result already collected: FutureResult
[11:01:33.797] result() for ClusterFuture ... done
[11:01:33.798] result() for ClusterFuture ...
[11:01:33.798] - result already collected: FutureResult
[11:01:33.798] result() for ClusterFuture ... done
[11:01:33.798] result() for ClusterFuture ...
[11:01:33.798] - result already collected: FutureResult
[11:01:33.798] result() for ClusterFuture ... done
[11:01:33.798] result() for ClusterFuture ...
[11:01:33.798] - result already collected: FutureResult
[11:01:33.798] result() for ClusterFuture ... done
[11:01:33.798] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.798] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.798] signalConditionsASAP(MultisessionFuture, pos=4) ... done
[11:01:33.799]  length: 0 (resolved future 4)
[11:01:33.799] Relaying remaining futures
[11:01:33.799] signalConditionsASAP(NULL, pos=0) ...
[11:01:33.799] - nx: 6
[11:01:33.799] - relay: TRUE
[11:01:33.799] - stdout: TRUE
[11:01:33.799] - signal: TRUE
[11:01:33.799] - resignal: FALSE
[11:01:33.799] - force: TRUE
[11:01:33.799] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.799] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
 - flush all
[11:01:33.799] - relayed: [n=6] TRUE, TRUE, TRUE, TRUE, TRUE, TRUE
[11:01:33.800] - queued futures: [n=6] FALSE, TRUE, TRUE, TRUE, FALSE, FALSE
[11:01:33.800] signalConditionsASAP(NULL, pos=0) ... done
[11:01:33.800] resolve() on list environment ... DONE
[11:01:33.800] result() for ClusterFuture ...
[11:01:33.800] - result already collected: FutureResult
[11:01:33.800] result() for ClusterFuture ... done
[11:01:33.800] result() for ClusterFuture ...
[11:01:33.800] - result already collected: FutureResult
[11:01:33.800] result() for ClusterFuture ... done
[11:01:33.800] result() for ClusterFuture ...
[11:01:33.800] - result already collected: FutureResult
[11:01:33.801] result() for ClusterFuture ... done
[11:01:33.801] result() for ClusterFuture ...
[11:01:33.801] - result already collected: FutureResult
[11:01:33.801] result() for ClusterFuture ... done
[11:01:33.801] result() for ClusterFuture ...
[11:01:33.801] - result already collected: FutureResult
[11:01:33.801] result() for ClusterFuture ... done
[11:01:33.801] result() for ClusterFuture ...
[11:01:33.801] - result already collected: FutureResult
[11:01:33.801] result() for ClusterFuture ... done
Classes 'listenv', 'environment' <environment: 0x55a9c6bddf98> 
 - attr(*, "dim.")= int [1:4] 2 1 3 1
 - attr(*, "dimnames.")=List of 4
  ..$ : chr [1:2] "a" "b"
  ..$ : chr "a"
  ..$ : chr [1:3] "a" "b" "c"
  ..$ : chr "a"
*** futures() - listenv ... DONE
Testing with 2 cores ... DONE
> 
> message("*** futures() / resolved() / value() ... DONE")
*** futures() / resolved() / value() ... DONE
> 
> source("incl/end.R")
[11:01:33.804] plan(): Setting new future strategy stack:
[11:01:33.804] List of future strategies:
[11:01:33.804] 1. FutureStrategy:
[11:01:33.804]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:33.804]    - tweaked: FALSE
[11:01:33.804]    - call: future::plan(oplan)
[11:01:33.805] plan(): nbrOfWorkers() = 1
> 
